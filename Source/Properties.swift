///
/// Auto-generated by Stone, do not modify.
///

import Foundation

/// Datatypes and serializers for the properties namespace
public class Properties {
    /// The GetPropertyTemplateArg struct
    public class GetPropertyTemplateArg: CustomStringConvertible {
        /// An identifier for property template added by route properties/template/add.
        public let templateId: String
        public init(templateId: String) {
            stringValidator(minLength: 1, pattern: "(/|ptid:).*")(templateId)
            self.templateId = templateId
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GetPropertyTemplateArgSerializer().serialize(self)))"
        }
    }
    public class GetPropertyTemplateArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: GetPropertyTemplateArg) -> JSON {
            let output = [ 
            "template_id": Serialization._StringSerializer.serialize(value.templateId),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> GetPropertyTemplateArg {
            switch json {
                case .Dictionary(let dict):
                    let templateId = Serialization._StringSerializer.deserialize(dict["template_id"] ?? .Null)
                    return GetPropertyTemplateArg(templateId: templateId)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Describes property templates that can be filled and associated with a file.
    public class PropertyGroupTemplate: CustomStringConvertible {
        /// A display name for the property template. Property template names can be up to 256 bytes.
        public let name: String
        /// Description for new property template. Property template descriptions can be up to 1024 bytes.
        public let description_: String
        /// This is a list of custom properties associated with a property template. There can be up to 64 properties in
        /// a single property template.
        public let fields: Array<Properties.PropertyFieldTemplate>
        public init(name: String, description_: String, fields: Array<Properties.PropertyFieldTemplate>) {
            stringValidator()(name)
            self.name = name
            stringValidator()(description_)
            self.description_ = description_
            self.fields = fields
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PropertyGroupTemplateSerializer().serialize(self)))"
        }
    }
    public class PropertyGroupTemplateSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: PropertyGroupTemplate) -> JSON {
            let output = [ 
            "name": Serialization._StringSerializer.serialize(value.name),
            "description": Serialization._StringSerializer.serialize(value.description_),
            "fields": ArraySerializer(Properties.PropertyFieldTemplateSerializer()).serialize(value.fields),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> PropertyGroupTemplate {
            switch json {
                case .Dictionary(let dict):
                    let name = Serialization._StringSerializer.deserialize(dict["name"] ?? .Null)
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .Null)
                    let fields = ArraySerializer(Properties.PropertyFieldTemplateSerializer()).deserialize(dict["fields"] ?? .Null)
                    return PropertyGroupTemplate(name: name, description_: description_, fields: fields)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The Property template for the specified template.
    public class GetPropertyTemplateResult: Properties.PropertyGroupTemplate {
        public override var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GetPropertyTemplateResultSerializer().serialize(self)))"
        }
    }
    public class GetPropertyTemplateResultSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: GetPropertyTemplateResult) -> JSON {
            let output = [ 
            "name": Serialization._StringSerializer.serialize(value.name),
            "description": Serialization._StringSerializer.serialize(value.description_),
            "fields": ArraySerializer(Properties.PropertyFieldTemplateSerializer()).serialize(value.fields),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> GetPropertyTemplateResult {
            switch json {
                case .Dictionary(let dict):
                    let name = Serialization._StringSerializer.deserialize(dict["name"] ?? .Null)
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .Null)
                    let fields = ArraySerializer(Properties.PropertyFieldTemplateSerializer()).deserialize(dict["fields"] ?? .Null)
                    return GetPropertyTemplateResult(name: name, description_: description_, fields: fields)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The ListPropertyTemplateIds struct
    public class ListPropertyTemplateIds: CustomStringConvertible {
        /// List of identifiers for templates added by route properties/template/add.
        public let templateIds: Array<String>
        public init(templateIds: Array<String>) {
            arrayValidator(itemValidator: stringValidator(minLength: 1, pattern: "(/|ptid:).*"))(templateIds)
            self.templateIds = templateIds
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListPropertyTemplateIdsSerializer().serialize(self)))"
        }
    }
    public class ListPropertyTemplateIdsSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: ListPropertyTemplateIds) -> JSON {
            let output = [ 
            "template_ids": ArraySerializer(Serialization._StringSerializer).serialize(value.templateIds),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> ListPropertyTemplateIds {
            switch json {
                case .Dictionary(let dict):
                    let templateIds = ArraySerializer(Serialization._StringSerializer).deserialize(dict["template_ids"] ?? .Null)
                    return ListPropertyTemplateIds(templateIds: templateIds)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The PropertyTemplateError union
    public enum PropertyTemplateError: CustomStringConvertible {
        /// Property template does not exist for given identifier.
        case TemplateNotFound(String)
        /// You do not have the permissions to modify this property template.
        case RestrictedContent
        /// An unspecified error.
        case Other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PropertyTemplateErrorSerializer().serialize(self)))"
        }
    }
    public class PropertyTemplateErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: PropertyTemplateError) -> JSON {
            switch value {
                case .TemplateNotFound(let arg):
                    var d = ["template_not_found": Serialization._StringSerializer.serialize(arg)]
                    d[".tag"] = .Str("template_not_found")
                    return .Dictionary(d)
                case .RestrictedContent:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("restricted_content")
                    return .Dictionary(d)
                case .Other:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> PropertyTemplateError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "template_not_found":
                            let v = Serialization._StringSerializer.deserialize(d["template_not_found"] ?? .Null)
                            return PropertyTemplateError.TemplateNotFound(v)
                        case "restricted_content":
                            return PropertyTemplateError.RestrictedContent
                        case "other":
                            return PropertyTemplateError.Other
                        default:
                            return PropertyTemplateError.Other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The ModifyPropertyTemplateError union
    public enum ModifyPropertyTemplateError: CustomStringConvertible {
        /// Property template does not exist for given identifier.
        case TemplateNotFound(String)
        /// You do not have the permissions to modify this property template.
        case RestrictedContent
        /// An unspecified error.
        case Other
        /// A property field name already exists in the template.
        case ConflictingPropertyNames
        /// There are too many properties in the changed template. The maximum number of properties per template is 32.
        case TooManyProperties
        /// There are too many templates for the team.
        case TooManyTemplates
        /// The template name, description or field names is too large.
        case TemplateAttributeTooLarge

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ModifyPropertyTemplateErrorSerializer().serialize(self)))"
        }
    }
    public class ModifyPropertyTemplateErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: ModifyPropertyTemplateError) -> JSON {
            switch value {
                case .TemplateNotFound(let arg):
                    var d = ["template_not_found": Serialization._StringSerializer.serialize(arg)]
                    d[".tag"] = .Str("template_not_found")
                    return .Dictionary(d)
                case .RestrictedContent:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("restricted_content")
                    return .Dictionary(d)
                case .Other:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
                case .ConflictingPropertyNames:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("conflicting_property_names")
                    return .Dictionary(d)
                case .TooManyProperties:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("too_many_properties")
                    return .Dictionary(d)
                case .TooManyTemplates:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("too_many_templates")
                    return .Dictionary(d)
                case .TemplateAttributeTooLarge:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("template_attribute_too_large")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> ModifyPropertyTemplateError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "template_not_found":
                            let v = Serialization._StringSerializer.deserialize(d["template_not_found"] ?? .Null)
                            return ModifyPropertyTemplateError.TemplateNotFound(v)
                        case "restricted_content":
                            return ModifyPropertyTemplateError.RestrictedContent
                        case "other":
                            return ModifyPropertyTemplateError.Other
                        case "conflicting_property_names":
                            return ModifyPropertyTemplateError.ConflictingPropertyNames
                        case "too_many_properties":
                            return ModifyPropertyTemplateError.TooManyProperties
                        case "too_many_templates":
                            return ModifyPropertyTemplateError.TooManyTemplates
                        case "template_attribute_too_large":
                            return ModifyPropertyTemplateError.TemplateAttributeTooLarge
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The PropertyField struct
    public class PropertyField: CustomStringConvertible {
        /// This is the name or key of a custom property in a property template. File property names can be up to 256
        /// bytes.
        public let name: String
        /// Value of a custom property attached to a file. Values can be up to 1024 bytes.
        public let value: String
        public init(name: String, value: String) {
            stringValidator()(name)
            self.name = name
            stringValidator()(value)
            self.value = value
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PropertyFieldSerializer().serialize(self)))"
        }
    }
    public class PropertyFieldSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: PropertyField) -> JSON {
            let output = [ 
            "name": Serialization._StringSerializer.serialize(value.name),
            "value": Serialization._StringSerializer.serialize(value.value),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> PropertyField {
            switch json {
                case .Dictionary(let dict):
                    let name = Serialization._StringSerializer.deserialize(dict["name"] ?? .Null)
                    let value = Serialization._StringSerializer.deserialize(dict["value"] ?? .Null)
                    return PropertyField(name: name, value: value)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Describe a single property field type which that can be part of a property template.
    public class PropertyFieldTemplate: CustomStringConvertible {
        /// This is the name or key of a custom property in a property template. File property names can be up to 256
        /// bytes.
        public let name: String
        /// This is the description for a custom property in a property template. File property description can be up to
        /// 1024 bytes.
        public let description_: String
        /// This is the data type of the value of this property. This type will be enforced upon property creation and
        /// modifications.
        public let type: Properties.PropertyType
        public init(name: String, description_: String, type: Properties.PropertyType) {
            stringValidator()(name)
            self.name = name
            stringValidator()(description_)
            self.description_ = description_
            self.type = type
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PropertyFieldTemplateSerializer().serialize(self)))"
        }
    }
    public class PropertyFieldTemplateSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: PropertyFieldTemplate) -> JSON {
            let output = [ 
            "name": Serialization._StringSerializer.serialize(value.name),
            "description": Serialization._StringSerializer.serialize(value.description_),
            "type": Properties.PropertyTypeSerializer().serialize(value.type),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> PropertyFieldTemplate {
            switch json {
                case .Dictionary(let dict):
                    let name = Serialization._StringSerializer.deserialize(dict["name"] ?? .Null)
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .Null)
                    let type = Properties.PropertyTypeSerializer().deserialize(dict["type"] ?? .Null)
                    return PropertyFieldTemplate(name: name, description_: description_, type: type)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Collection of custom properties in filled property templates.
    public class PropertyGroup: CustomStringConvertible {
        /// A unique identifier for a property template type.
        public let templateId: String
        /// This is a list of custom properties associated with a file. There can be up to 32 properties for a template.
        public let fields: Array<Properties.PropertyField>
        public init(templateId: String, fields: Array<Properties.PropertyField>) {
            stringValidator(minLength: 1, pattern: "(/|ptid:).*")(templateId)
            self.templateId = templateId
            self.fields = fields
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PropertyGroupSerializer().serialize(self)))"
        }
    }
    public class PropertyGroupSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: PropertyGroup) -> JSON {
            let output = [ 
            "template_id": Serialization._StringSerializer.serialize(value.templateId),
            "fields": ArraySerializer(Properties.PropertyFieldSerializer()).serialize(value.fields),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> PropertyGroup {
            switch json {
                case .Dictionary(let dict):
                    let templateId = Serialization._StringSerializer.deserialize(dict["template_id"] ?? .Null)
                    let fields = ArraySerializer(Properties.PropertyFieldSerializer()).deserialize(dict["fields"] ?? .Null)
                    return PropertyGroup(templateId: templateId, fields: fields)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Data type of the given property added. This endpoint is in beta and  only properties of type strings is
    /// supported.
    public enum PropertyType: CustomStringConvertible {
        /// The associated property will be of type string. Unicode is supported.
        case String_
        /// An unspecified error.
        case Other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PropertyTypeSerializer().serialize(self)))"
        }
    }
    public class PropertyTypeSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: PropertyType) -> JSON {
            switch value {
                case .String_:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("string")
                    return .Dictionary(d)
                case .Other:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> PropertyType {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "string":
                            return PropertyType.String_
                        case "other":
                            return PropertyType.Other
                        default:
                            return PropertyType.Other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

}
