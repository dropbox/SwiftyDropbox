///
/// Auto-generated by Stone, do not modify.
///

import Foundation

/// Datatypes and serializers for the sharing namespace
public class Sharing {
    /// Defines the access levels for collaborators.
    public enum AccessLevel: CustomStringConvertible {
        /// The collaborator is the owner of the shared folder. Owners can view and edit the shared folder as well as
        /// set the folder's policies using updateFolderPolicy.
        case Owner
        /// The collaborator can both view and edit the shared folder.
        case Editor
        /// The collaborator can only view the shared folder.
        case Viewer
        /// The collaborator can only view the shared folder and does not have any access to comments.
        case ViewerNoComment
        /// (undocumented)
        case Other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(AccessLevelSerializer().serialize(self)))"
        }
    }
    public class AccessLevelSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: AccessLevel) -> JSON {
            switch value {
                case .Owner:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("owner")
                    return .Dictionary(d)
                case .Editor:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("editor")
                    return .Dictionary(d)
                case .Viewer:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("viewer")
                    return .Dictionary(d)
                case .ViewerNoComment:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("viewer_no_comment")
                    return .Dictionary(d)
                case .Other:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> AccessLevel {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "owner":
                            return AccessLevel.Owner
                        case "editor":
                            return AccessLevel.Editor
                        case "viewer":
                            return AccessLevel.Viewer
                        case "viewer_no_comment":
                            return AccessLevel.ViewerNoComment
                        case "other":
                            return AccessLevel.Other
                        default:
                            return AccessLevel.Other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Policy governing who can change a shared folder's access control list (ACL). In other words, who can add,
    /// remove, or change the privileges of members.
    public enum AclUpdatePolicy: CustomStringConvertible {
        /// Only the owner can update the ACL.
        case Owner
        /// Any editor can update the ACL. This may be further restricted to editors on the same team.
        case Editors
        /// (undocumented)
        case Other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(AclUpdatePolicySerializer().serialize(self)))"
        }
    }
    public class AclUpdatePolicySerializer: JSONSerializer {
        public init() { }
        public func serialize(value: AclUpdatePolicy) -> JSON {
            switch value {
                case .Owner:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("owner")
                    return .Dictionary(d)
                case .Editors:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("editors")
                    return .Dictionary(d)
                case .Other:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> AclUpdatePolicy {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "owner":
                            return AclUpdatePolicy.Owner
                        case "editors":
                            return AclUpdatePolicy.Editors
                        case "other":
                            return AclUpdatePolicy.Other
                        default:
                            return AclUpdatePolicy.Other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Arguments for addFileMember.
    public class AddFileMemberArgs: CustomStringConvertible {
        /// File to which to add members.
        public let file: String
        /// Members to add. Note that even an email address is given, this may result in a user being directy added to
        /// the membership if that email is the user's main account email.
        public let members: Array<Sharing.MemberSelector>
        /// Message to send to added members in their invitation.
        public let customMessage: String?
        /// Whether added members should be notified via device notifications of their invitation.
        public let quiet: Bool
        /// AccessLevel union object, describing what access level we want to give new members.
        public let accessLevel: Sharing.AccessLevel
        /// If the custom message should be added as a comment on the file.
        public let addMessageAsComment: Bool
        public init(file: String, members: Array<Sharing.MemberSelector>, customMessage: String? = nil, quiet: Bool = false, accessLevel: Sharing.AccessLevel = .Viewer, addMessageAsComment: Bool = false) {
            stringValidator(minLength: 1, pattern: "((/|id:).*|nspath:[^:]*:[^:]*)")(file)
            self.file = file
            self.members = members
            nullableValidator(stringValidator())(customMessage)
            self.customMessage = customMessage
            self.quiet = quiet
            self.accessLevel = accessLevel
            self.addMessageAsComment = addMessageAsComment
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(AddFileMemberArgsSerializer().serialize(self)))"
        }
    }
    public class AddFileMemberArgsSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: AddFileMemberArgs) -> JSON {
            let output = [ 
            "file": Serialization._StringSerializer.serialize(value.file),
            "members": ArraySerializer(Sharing.MemberSelectorSerializer()).serialize(value.members),
            "custom_message": NullableSerializer(Serialization._StringSerializer).serialize(value.customMessage),
            "quiet": Serialization._BoolSerializer.serialize(value.quiet),
            "access_level": Sharing.AccessLevelSerializer().serialize(value.accessLevel),
            "add_message_as_comment": Serialization._BoolSerializer.serialize(value.addMessageAsComment),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> AddFileMemberArgs {
            switch json {
                case .Dictionary(let dict):
                    let file = Serialization._StringSerializer.deserialize(dict["file"] ?? .Null)
                    let members = ArraySerializer(Sharing.MemberSelectorSerializer()).deserialize(dict["members"] ?? .Null)
                    let customMessage = NullableSerializer(Serialization._StringSerializer).deserialize(dict["custom_message"] ?? .Null)
                    let quiet = Serialization._BoolSerializer.deserialize(dict["quiet"] ?? .Null)
                    let accessLevel = Sharing.AccessLevelSerializer().deserialize(dict["access_level"] ?? .Null)
                    let addMessageAsComment = Serialization._BoolSerializer.deserialize(dict["add_message_as_comment"] ?? .Null)
                    return AddFileMemberArgs(file: file, members: members, customMessage: customMessage, quiet: quiet, accessLevel: accessLevel, addMessageAsComment: addMessageAsComment)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Errors for addFileMember.
    public enum AddFileMemberError: CustomStringConvertible {
        /// (undocumented)
        case UserError(Sharing.SharingUserError)
        /// (undocumented)
        case AccessError(Sharing.SharingFileAccessError)
        /// The user has reached the rate limit for invitations.
        case RateLimit
        /// The custom message did not pass comment permissions checks.
        case InvalidComment
        /// (undocumented)
        case Other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(AddFileMemberErrorSerializer().serialize(self)))"
        }
    }
    public class AddFileMemberErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: AddFileMemberError) -> JSON {
            switch value {
                case .UserError(let arg):
                    var d = ["user_error": Sharing.SharingUserErrorSerializer().serialize(arg)]
                    d[".tag"] = .Str("user_error")
                    return .Dictionary(d)
                case .AccessError(let arg):
                    var d = ["access_error": Sharing.SharingFileAccessErrorSerializer().serialize(arg)]
                    d[".tag"] = .Str("access_error")
                    return .Dictionary(d)
                case .RateLimit:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("rate_limit")
                    return .Dictionary(d)
                case .InvalidComment:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("invalid_comment")
                    return .Dictionary(d)
                case .Other:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> AddFileMemberError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "user_error":
                            let v = Sharing.SharingUserErrorSerializer().deserialize(d["user_error"] ?? .Null)
                            return AddFileMemberError.UserError(v)
                        case "access_error":
                            let v = Sharing.SharingFileAccessErrorSerializer().deserialize(d["access_error"] ?? .Null)
                            return AddFileMemberError.AccessError(v)
                        case "rate_limit":
                            return AddFileMemberError.RateLimit
                        case "invalid_comment":
                            return AddFileMemberError.InvalidComment
                        case "other":
                            return AddFileMemberError.Other
                        default:
                            return AddFileMemberError.Other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The AddFolderMemberArg struct
    public class AddFolderMemberArg: CustomStringConvertible {
        /// The ID for the shared folder.
        public let sharedFolderId: String
        /// The intended list of members to add.  Added members will receive invites to join the shared folder.
        public let members: Array<Sharing.AddMember>
        /// Whether added members should be notified via email and device notifications of their invite.
        public let quiet: Bool
        /// Optional message to display to added members in their invitation.
        public let customMessage: String?
        public init(sharedFolderId: String, members: Array<Sharing.AddMember>, quiet: Bool = false, customMessage: String? = nil) {
            stringValidator(pattern: "[-_0-9a-zA-Z:]+")(sharedFolderId)
            self.sharedFolderId = sharedFolderId
            self.members = members
            self.quiet = quiet
            nullableValidator(stringValidator(minLength: 1))(customMessage)
            self.customMessage = customMessage
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(AddFolderMemberArgSerializer().serialize(self)))"
        }
    }
    public class AddFolderMemberArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: AddFolderMemberArg) -> JSON {
            let output = [ 
            "shared_folder_id": Serialization._StringSerializer.serialize(value.sharedFolderId),
            "members": ArraySerializer(Sharing.AddMemberSerializer()).serialize(value.members),
            "quiet": Serialization._BoolSerializer.serialize(value.quiet),
            "custom_message": NullableSerializer(Serialization._StringSerializer).serialize(value.customMessage),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> AddFolderMemberArg {
            switch json {
                case .Dictionary(let dict):
                    let sharedFolderId = Serialization._StringSerializer.deserialize(dict["shared_folder_id"] ?? .Null)
                    let members = ArraySerializer(Sharing.AddMemberSerializer()).deserialize(dict["members"] ?? .Null)
                    let quiet = Serialization._BoolSerializer.deserialize(dict["quiet"] ?? .Null)
                    let customMessage = NullableSerializer(Serialization._StringSerializer).deserialize(dict["custom_message"] ?? .Null)
                    return AddFolderMemberArg(sharedFolderId: sharedFolderId, members: members, quiet: quiet, customMessage: customMessage)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The AddFolderMemberError union
    public enum AddFolderMemberError: CustomStringConvertible {
        /// Unable to access shared folder.
        case AccessError(Sharing.SharedFolderAccessError)
        /// The current user's e-mail address is unverified.
        case EmailUnverified
        /// members in AddFolderMemberArg contains a bad invitation recipient.
        case BadMember(Sharing.AddMemberSelectorError)
        /// Your team policy does not allow sharing outside of the team.
        case CantShareOutsideTeam
        /// The value is the member limit that was reached.
        case TooManyMembers(UInt64)
        /// The value is the pending invite limit that was reached.
        case TooManyPendingInvites(UInt64)
        /// The user has reached the rate limit for invitations.
        case RateLimit
        /// The current user's account doesn't support this action. An example of this is when adding a read-only
        /// member. This action can only be performed by users that have upgraded to a Pro or Business plan.
        case InsufficientPlan
        /// This action cannot be performed on a team shared folder.
        case TeamFolder
        /// The current user does not have permission to perform this action.
        case NoPermission
        /// (undocumented)
        case Other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(AddFolderMemberErrorSerializer().serialize(self)))"
        }
    }
    public class AddFolderMemberErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: AddFolderMemberError) -> JSON {
            switch value {
                case .AccessError(let arg):
                    var d = ["access_error": Sharing.SharedFolderAccessErrorSerializer().serialize(arg)]
                    d[".tag"] = .Str("access_error")
                    return .Dictionary(d)
                case .EmailUnverified:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("email_unverified")
                    return .Dictionary(d)
                case .BadMember(let arg):
                    var d = ["bad_member": Sharing.AddMemberSelectorErrorSerializer().serialize(arg)]
                    d[".tag"] = .Str("bad_member")
                    return .Dictionary(d)
                case .CantShareOutsideTeam:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("cant_share_outside_team")
                    return .Dictionary(d)
                case .TooManyMembers(let arg):
                    var d = ["too_many_members": Serialization._UInt64Serializer.serialize(arg)]
                    d[".tag"] = .Str("too_many_members")
                    return .Dictionary(d)
                case .TooManyPendingInvites(let arg):
                    var d = ["too_many_pending_invites": Serialization._UInt64Serializer.serialize(arg)]
                    d[".tag"] = .Str("too_many_pending_invites")
                    return .Dictionary(d)
                case .RateLimit:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("rate_limit")
                    return .Dictionary(d)
                case .InsufficientPlan:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("insufficient_plan")
                    return .Dictionary(d)
                case .TeamFolder:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("team_folder")
                    return .Dictionary(d)
                case .NoPermission:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("no_permission")
                    return .Dictionary(d)
                case .Other:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> AddFolderMemberError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "access_error":
                            let v = Sharing.SharedFolderAccessErrorSerializer().deserialize(d["access_error"] ?? .Null)
                            return AddFolderMemberError.AccessError(v)
                        case "email_unverified":
                            return AddFolderMemberError.EmailUnverified
                        case "bad_member":
                            let v = Sharing.AddMemberSelectorErrorSerializer().deserialize(d["bad_member"] ?? .Null)
                            return AddFolderMemberError.BadMember(v)
                        case "cant_share_outside_team":
                            return AddFolderMemberError.CantShareOutsideTeam
                        case "too_many_members":
                            let v = Serialization._UInt64Serializer.deserialize(d["too_many_members"] ?? .Null)
                            return AddFolderMemberError.TooManyMembers(v)
                        case "too_many_pending_invites":
                            let v = Serialization._UInt64Serializer.deserialize(d["too_many_pending_invites"] ?? .Null)
                            return AddFolderMemberError.TooManyPendingInvites(v)
                        case "rate_limit":
                            return AddFolderMemberError.RateLimit
                        case "insufficient_plan":
                            return AddFolderMemberError.InsufficientPlan
                        case "team_folder":
                            return AddFolderMemberError.TeamFolder
                        case "no_permission":
                            return AddFolderMemberError.NoPermission
                        case "other":
                            return AddFolderMemberError.Other
                        default:
                            return AddFolderMemberError.Other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The member and type of access the member should have when added to a shared folder.
    public class AddMember: CustomStringConvertible {
        /// The member to add to the shared folder.
        public let member: Sharing.MemberSelector
        /// The access level to grant member to the shared folder.  owner in AccessLevel is disallowed.
        public let accessLevel: Sharing.AccessLevel
        public init(member: Sharing.MemberSelector, accessLevel: Sharing.AccessLevel = .Viewer) {
            self.member = member
            self.accessLevel = accessLevel
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(AddMemberSerializer().serialize(self)))"
        }
    }
    public class AddMemberSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: AddMember) -> JSON {
            let output = [ 
            "member": Sharing.MemberSelectorSerializer().serialize(value.member),
            "access_level": Sharing.AccessLevelSerializer().serialize(value.accessLevel),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> AddMember {
            switch json {
                case .Dictionary(let dict):
                    let member = Sharing.MemberSelectorSerializer().deserialize(dict["member"] ?? .Null)
                    let accessLevel = Sharing.AccessLevelSerializer().deserialize(dict["access_level"] ?? .Null)
                    return AddMember(member: member, accessLevel: accessLevel)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The AddMemberSelectorError union
    public enum AddMemberSelectorError: CustomStringConvertible {
        /// The value is the ID that could not be identified.
        case InvalidDropboxId(String)
        /// The value is the e-email address that is malformed.
        case InvalidEmail(String)
        /// The value is the ID of the Dropbox user with an unverified e-mail address.  Invite unverified users by
        /// e-mail address instead of by their Dropbox ID.
        case UnverifiedDropboxId(String)
        /// At least one of the specified groups in members in AddFolderMemberArg is deleted.
        case GroupDeleted
        /// Sharing to a group that is not on the current user's team.
        case GroupNotOnTeam
        /// (undocumented)
        case Other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(AddMemberSelectorErrorSerializer().serialize(self)))"
        }
    }
    public class AddMemberSelectorErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: AddMemberSelectorError) -> JSON {
            switch value {
                case .InvalidDropboxId(let arg):
                    var d = ["invalid_dropbox_id": Serialization._StringSerializer.serialize(arg)]
                    d[".tag"] = .Str("invalid_dropbox_id")
                    return .Dictionary(d)
                case .InvalidEmail(let arg):
                    var d = ["invalid_email": Serialization._StringSerializer.serialize(arg)]
                    d[".tag"] = .Str("invalid_email")
                    return .Dictionary(d)
                case .UnverifiedDropboxId(let arg):
                    var d = ["unverified_dropbox_id": Serialization._StringSerializer.serialize(arg)]
                    d[".tag"] = .Str("unverified_dropbox_id")
                    return .Dictionary(d)
                case .GroupDeleted:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("group_deleted")
                    return .Dictionary(d)
                case .GroupNotOnTeam:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("group_not_on_team")
                    return .Dictionary(d)
                case .Other:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> AddMemberSelectorError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "invalid_dropbox_id":
                            let v = Serialization._StringSerializer.deserialize(d["invalid_dropbox_id"] ?? .Null)
                            return AddMemberSelectorError.InvalidDropboxId(v)
                        case "invalid_email":
                            let v = Serialization._StringSerializer.deserialize(d["invalid_email"] ?? .Null)
                            return AddMemberSelectorError.InvalidEmail(v)
                        case "unverified_dropbox_id":
                            let v = Serialization._StringSerializer.deserialize(d["unverified_dropbox_id"] ?? .Null)
                            return AddMemberSelectorError.UnverifiedDropboxId(v)
                        case "group_deleted":
                            return AddMemberSelectorError.GroupDeleted
                        case "group_not_on_team":
                            return AddMemberSelectorError.GroupNotOnTeam
                        case "other":
                            return AddMemberSelectorError.Other
                        default:
                            return AddMemberSelectorError.Other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Metadata for a shared link. This can be either a PathLinkMetadata or CollectionLinkMetadata.
    public class LinkMetadata: CustomStringConvertible {
        /// URL of the shared link.
        public let url: String
        /// Who can access the link.
        public let visibility: Sharing.Visibility
        /// Expiration time, if set. By default the link won't expire.
        public let expires: NSDate?
        public init(url: String, visibility: Sharing.Visibility, expires: NSDate? = nil) {
            stringValidator()(url)
            self.url = url
            self.visibility = visibility
            self.expires = expires
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(LinkMetadataSerializer().serialize(self)))"
        }
    }
    public class LinkMetadataSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: LinkMetadata) -> JSON {
            var output = [ 
            "url": Serialization._StringSerializer.serialize(value.url),
            "visibility": Sharing.VisibilitySerializer().serialize(value.visibility),
            "expires": NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.expires),
            ]
            switch value {
                case let path as Sharing.PathLinkMetadata:
                    for (k,v) in Serialization.getFields(Sharing.PathLinkMetadataSerializer().serialize(path)) {
                        output[k] = v
                    }
                    output[".tag"] = .Str("path")
                case let collection as Sharing.CollectionLinkMetadata:
                    for (k,v) in Serialization.getFields(Sharing.CollectionLinkMetadataSerializer().serialize(collection)) {
                        output[k] = v
                    }
                    output[".tag"] = .Str("collection")
                default: fatalError("Tried to serialize unexpected subtype")
            }
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> LinkMetadata {
            switch json {
                case .Dictionary(let dict):
                    let tag = Serialization.getTag(dict)
                    switch tag {
                        case "path":
                            return Sharing.PathLinkMetadataSerializer().deserialize(json)
                        case "collection":
                            return Sharing.CollectionLinkMetadataSerializer().deserialize(json)
                        default:
                            let url = Serialization._StringSerializer.deserialize(dict["url"] ?? .Null)
                            let visibility = Sharing.VisibilitySerializer().deserialize(dict["visibility"] ?? .Null)
                            let expires = NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).deserialize(dict["expires"] ?? .Null)
                            return LinkMetadata(url: url, visibility: visibility, expires: expires)
                    }
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Metadata for a collection-based shared link.
    public class CollectionLinkMetadata: Sharing.LinkMetadata {
        public override var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(CollectionLinkMetadataSerializer().serialize(self)))"
        }
    }
    public class CollectionLinkMetadataSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: CollectionLinkMetadata) -> JSON {
            let output = [ 
            "url": Serialization._StringSerializer.serialize(value.url),
            "visibility": Sharing.VisibilitySerializer().serialize(value.visibility),
            "expires": NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.expires),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> CollectionLinkMetadata {
            switch json {
                case .Dictionary(let dict):
                    let url = Serialization._StringSerializer.deserialize(dict["url"] ?? .Null)
                    let visibility = Sharing.VisibilitySerializer().deserialize(dict["visibility"] ?? .Null)
                    let expires = NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).deserialize(dict["expires"] ?? .Null)
                    return CollectionLinkMetadata(url: url, visibility: visibility, expires: expires)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The CreateSharedLinkArg struct
    public class CreateSharedLinkArg: CustomStringConvertible {
        /// The path to share.
        public let path: String
        /// Whether to return a shortened URL.
        public let shortUrl: Bool
        /// If it's okay to share a path that does not yet exist, set this to either file in PendingUploadMode or folder
        /// in PendingUploadMode to indicate whether to assume it's a file or folder.
        public let pendingUpload: Sharing.PendingUploadMode?
        public init(path: String, shortUrl: Bool = false, pendingUpload: Sharing.PendingUploadMode? = nil) {
            stringValidator()(path)
            self.path = path
            self.shortUrl = shortUrl
            self.pendingUpload = pendingUpload
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(CreateSharedLinkArgSerializer().serialize(self)))"
        }
    }
    public class CreateSharedLinkArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: CreateSharedLinkArg) -> JSON {
            let output = [ 
            "path": Serialization._StringSerializer.serialize(value.path),
            "short_url": Serialization._BoolSerializer.serialize(value.shortUrl),
            "pending_upload": NullableSerializer(Sharing.PendingUploadModeSerializer()).serialize(value.pendingUpload),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> CreateSharedLinkArg {
            switch json {
                case .Dictionary(let dict):
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .Null)
                    let shortUrl = Serialization._BoolSerializer.deserialize(dict["short_url"] ?? .Null)
                    let pendingUpload = NullableSerializer(Sharing.PendingUploadModeSerializer()).deserialize(dict["pending_upload"] ?? .Null)
                    return CreateSharedLinkArg(path: path, shortUrl: shortUrl, pendingUpload: pendingUpload)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The CreateSharedLinkError union
    public enum CreateSharedLinkError: CustomStringConvertible {
        /// (undocumented)
        case Path(Files.LookupError)
        /// (undocumented)
        case Other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(CreateSharedLinkErrorSerializer().serialize(self)))"
        }
    }
    public class CreateSharedLinkErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: CreateSharedLinkError) -> JSON {
            switch value {
                case .Path(let arg):
                    var d = ["path": Files.LookupErrorSerializer().serialize(arg)]
                    d[".tag"] = .Str("path")
                    return .Dictionary(d)
                case .Other:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> CreateSharedLinkError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "path":
                            let v = Files.LookupErrorSerializer().deserialize(d["path"] ?? .Null)
                            return CreateSharedLinkError.Path(v)
                        case "other":
                            return CreateSharedLinkError.Other
                        default:
                            return CreateSharedLinkError.Other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The CreateSharedLinkWithSettingsArg struct
    public class CreateSharedLinkWithSettingsArg: CustomStringConvertible {
        /// The path to be shared by the shared link
        public let path: String
        /// The requested settings for the newly created shared link
        public let settings: Sharing.SharedLinkSettings?
        public init(path: String, settings: Sharing.SharedLinkSettings? = nil) {
            stringValidator(pattern: "(/(.|[\\r\\n])*|id:.*)|(rev:[0-9a-f]{9,})|(ns:[0-9]+(/.*)?)")(path)
            self.path = path
            self.settings = settings
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(CreateSharedLinkWithSettingsArgSerializer().serialize(self)))"
        }
    }
    public class CreateSharedLinkWithSettingsArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: CreateSharedLinkWithSettingsArg) -> JSON {
            let output = [ 
            "path": Serialization._StringSerializer.serialize(value.path),
            "settings": NullableSerializer(Sharing.SharedLinkSettingsSerializer()).serialize(value.settings),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> CreateSharedLinkWithSettingsArg {
            switch json {
                case .Dictionary(let dict):
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .Null)
                    let settings = NullableSerializer(Sharing.SharedLinkSettingsSerializer()).deserialize(dict["settings"] ?? .Null)
                    return CreateSharedLinkWithSettingsArg(path: path, settings: settings)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The CreateSharedLinkWithSettingsError union
    public enum CreateSharedLinkWithSettingsError: CustomStringConvertible {
        /// (undocumented)
        case Path(Files.LookupError)
        /// User's email should be verified
        case EmailNotVerified
        /// The shared link already exists
        case SharedLinkAlreadyExists
        /// There is an error with the given settings
        case SettingsError(Sharing.SharedLinkSettingsError)
        /// Access to the requested path is forbidden
        case AccessDenied

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(CreateSharedLinkWithSettingsErrorSerializer().serialize(self)))"
        }
    }
    public class CreateSharedLinkWithSettingsErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: CreateSharedLinkWithSettingsError) -> JSON {
            switch value {
                case .Path(let arg):
                    var d = ["path": Files.LookupErrorSerializer().serialize(arg)]
                    d[".tag"] = .Str("path")
                    return .Dictionary(d)
                case .EmailNotVerified:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("email_not_verified")
                    return .Dictionary(d)
                case .SharedLinkAlreadyExists:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("shared_link_already_exists")
                    return .Dictionary(d)
                case .SettingsError(let arg):
                    var d = ["settings_error": Sharing.SharedLinkSettingsErrorSerializer().serialize(arg)]
                    d[".tag"] = .Str("settings_error")
                    return .Dictionary(d)
                case .AccessDenied:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("access_denied")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> CreateSharedLinkWithSettingsError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "path":
                            let v = Files.LookupErrorSerializer().deserialize(d["path"] ?? .Null)
                            return CreateSharedLinkWithSettingsError.Path(v)
                        case "email_not_verified":
                            return CreateSharedLinkWithSettingsError.EmailNotVerified
                        case "shared_link_already_exists":
                            return CreateSharedLinkWithSettingsError.SharedLinkAlreadyExists
                        case "settings_error":
                            let v = Sharing.SharedLinkSettingsErrorSerializer().deserialize(d["settings_error"] ?? .Null)
                            return CreateSharedLinkWithSettingsError.SettingsError(v)
                        case "access_denied":
                            return CreateSharedLinkWithSettingsError.AccessDenied
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Sharing actions that may be taken on files.
    public enum FileAction: CustomStringConvertible {
        /// Change or edit contents of the file.
        case EditContents
        /// Add a member with view permissions.
        case InviteViewer
        /// Stop sharing this file.
        case Unshare
        /// Relinquish one's own membership to the file.
        case RelinquishMembership
        /// (undocumented)
        case Other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(FileActionSerializer().serialize(self)))"
        }
    }
    public class FileActionSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: FileAction) -> JSON {
            switch value {
                case .EditContents:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("edit_contents")
                    return .Dictionary(d)
                case .InviteViewer:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("invite_viewer")
                    return .Dictionary(d)
                case .Unshare:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("unshare")
                    return .Dictionary(d)
                case .RelinquishMembership:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("relinquish_membership")
                    return .Dictionary(d)
                case .Other:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> FileAction {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "edit_contents":
                            return FileAction.EditContents
                        case "invite_viewer":
                            return FileAction.InviteViewer
                        case "unshare":
                            return FileAction.Unshare
                        case "relinquish_membership":
                            return FileAction.RelinquishMembership
                        case "other":
                            return FileAction.Other
                        default:
                            return FileAction.Other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The FileErrorResult union
    public enum FileErrorResult: CustomStringConvertible {
        /// File specified by id was not found.
        case FileNotFoundError(String)
        /// User does not have permission to take the specified action on the file.
        case InvalidFileActionError(String)
        /// User does not have permission to access file specified by file.Id.
        case PermissionDeniedError(String)
        /// (undocumented)
        case Other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(FileErrorResultSerializer().serialize(self)))"
        }
    }
    public class FileErrorResultSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: FileErrorResult) -> JSON {
            switch value {
                case .FileNotFoundError(let arg):
                    var d = ["file_not_found_error": Serialization._StringSerializer.serialize(arg)]
                    d[".tag"] = .Str("file_not_found_error")
                    return .Dictionary(d)
                case .InvalidFileActionError(let arg):
                    var d = ["invalid_file_action_error": Serialization._StringSerializer.serialize(arg)]
                    d[".tag"] = .Str("invalid_file_action_error")
                    return .Dictionary(d)
                case .PermissionDeniedError(let arg):
                    var d = ["permission_denied_error": Serialization._StringSerializer.serialize(arg)]
                    d[".tag"] = .Str("permission_denied_error")
                    return .Dictionary(d)
                case .Other:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> FileErrorResult {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "file_not_found_error":
                            let v = Serialization._StringSerializer.deserialize(d["file_not_found_error"] ?? .Null)
                            return FileErrorResult.FileNotFoundError(v)
                        case "invalid_file_action_error":
                            let v = Serialization._StringSerializer.deserialize(d["invalid_file_action_error"] ?? .Null)
                            return FileErrorResult.InvalidFileActionError(v)
                        case "permission_denied_error":
                            let v = Serialization._StringSerializer.deserialize(d["permission_denied_error"] ?? .Null)
                            return FileErrorResult.PermissionDeniedError(v)
                        case "other":
                            return FileErrorResult.Other
                        default:
                            return FileErrorResult.Other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The metadata of a shared link
    public class SharedLinkMetadata: CustomStringConvertible {
        /// URL of the shared link.
        public let url: String
        /// A unique identifier for the linked file.
        public let id: String?
        /// The linked file name (including extension). This never contains a slash.
        public let name: String
        /// Expiration time, if set. By default the link won't expire.
        public let expires: NSDate?
        /// The lowercased full path in the user's Dropbox. This always starts with a slash. This field will only be
        /// present only if the linked file is in the authenticated user's  dropbox.
        public let pathLower: String?
        /// The link's access permissions.
        public let linkPermissions: Sharing.LinkPermissions
        /// The team membership information of the link's owner.  This field will only be present  if the link's owner
        /// is a team member.
        public let teamMemberInfo: Sharing.TeamMemberInfo?
        /// The team information of the content's owner. This field will only be present if the content's owner is a
        /// team member and the content's owner team is different from the link's owner team.
        public let contentOwnerTeamInfo: Users.Team?
        public init(url: String, name: String, linkPermissions: Sharing.LinkPermissions, id: String? = nil, expires: NSDate? = nil, pathLower: String? = nil, teamMemberInfo: Sharing.TeamMemberInfo? = nil, contentOwnerTeamInfo: Users.Team? = nil) {
            stringValidator()(url)
            self.url = url
            nullableValidator(stringValidator(minLength: 1))(id)
            self.id = id
            stringValidator()(name)
            self.name = name
            self.expires = expires
            nullableValidator(stringValidator())(pathLower)
            self.pathLower = pathLower
            self.linkPermissions = linkPermissions
            self.teamMemberInfo = teamMemberInfo
            self.contentOwnerTeamInfo = contentOwnerTeamInfo
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharedLinkMetadataSerializer().serialize(self)))"
        }
    }
    public class SharedLinkMetadataSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: SharedLinkMetadata) -> JSON {
            var output = [ 
            "url": Serialization._StringSerializer.serialize(value.url),
            "name": Serialization._StringSerializer.serialize(value.name),
            "link_permissions": Sharing.LinkPermissionsSerializer().serialize(value.linkPermissions),
            "id": NullableSerializer(Serialization._StringSerializer).serialize(value.id),
            "expires": NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.expires),
            "path_lower": NullableSerializer(Serialization._StringSerializer).serialize(value.pathLower),
            "team_member_info": NullableSerializer(Sharing.TeamMemberInfoSerializer()).serialize(value.teamMemberInfo),
            "content_owner_team_info": NullableSerializer(Users.TeamSerializer()).serialize(value.contentOwnerTeamInfo),
            ]
            switch value {
                case let file as Sharing.FileLinkMetadata:
                    for (k,v) in Serialization.getFields(Sharing.FileLinkMetadataSerializer().serialize(file)) {
                        output[k] = v
                    }
                    output[".tag"] = .Str("file")
                case let folder as Sharing.FolderLinkMetadata:
                    for (k,v) in Serialization.getFields(Sharing.FolderLinkMetadataSerializer().serialize(folder)) {
                        output[k] = v
                    }
                    output[".tag"] = .Str("folder")
                default: fatalError("Tried to serialize unexpected subtype")
            }
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> SharedLinkMetadata {
            switch json {
                case .Dictionary(let dict):
                    let tag = Serialization.getTag(dict)
                    switch tag {
                        case "file":
                            return Sharing.FileLinkMetadataSerializer().deserialize(json)
                        case "folder":
                            return Sharing.FolderLinkMetadataSerializer().deserialize(json)
                        default:
                            let url = Serialization._StringSerializer.deserialize(dict["url"] ?? .Null)
                            let name = Serialization._StringSerializer.deserialize(dict["name"] ?? .Null)
                            let linkPermissions = Sharing.LinkPermissionsSerializer().deserialize(dict["link_permissions"] ?? .Null)
                            let id = NullableSerializer(Serialization._StringSerializer).deserialize(dict["id"] ?? .Null)
                            let expires = NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).deserialize(dict["expires"] ?? .Null)
                            let pathLower = NullableSerializer(Serialization._StringSerializer).deserialize(dict["path_lower"] ?? .Null)
                            let teamMemberInfo = NullableSerializer(Sharing.TeamMemberInfoSerializer()).deserialize(dict["team_member_info"] ?? .Null)
                            let contentOwnerTeamInfo = NullableSerializer(Users.TeamSerializer()).deserialize(dict["content_owner_team_info"] ?? .Null)
                            return SharedLinkMetadata(url: url, name: name, linkPermissions: linkPermissions, id: id, expires: expires, pathLower: pathLower, teamMemberInfo: teamMemberInfo, contentOwnerTeamInfo: contentOwnerTeamInfo)
                    }
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The metadata of a file shared link
    public class FileLinkMetadata: Sharing.SharedLinkMetadata {
        /// The modification time set by the desktop client when the file was added to Dropbox. Since this time is not
        /// verified (the Dropbox server stores whatever the desktop client sends up), this should only be used for
        /// display purposes (such as sorting) and not, for example, to determine if a file has changed or not.
        public let clientModified: NSDate
        /// The last time the file was modified on Dropbox.
        public let serverModified: NSDate
        /// A unique identifier for the current revision of a file. This field is the same rev as elsewhere in the API
        /// and can be used to detect changes and avoid conflicts.
        public let rev: String
        /// The file size in bytes.
        public let size: UInt64
        public init(url: String, name: String, linkPermissions: Sharing.LinkPermissions, clientModified: NSDate, serverModified: NSDate, rev: String, size: UInt64, id: String? = nil, expires: NSDate? = nil, pathLower: String? = nil, teamMemberInfo: Sharing.TeamMemberInfo? = nil, contentOwnerTeamInfo: Users.Team? = nil) {
            self.clientModified = clientModified
            self.serverModified = serverModified
            stringValidator(minLength: 9, pattern: "[0-9a-f]+")(rev)
            self.rev = rev
            comparableValidator()(size)
            self.size = size
            super.init(url: url, name: name, linkPermissions: linkPermissions, id: id, expires: expires, pathLower: pathLower, teamMemberInfo: teamMemberInfo, contentOwnerTeamInfo: contentOwnerTeamInfo)
        }
        public override var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(FileLinkMetadataSerializer().serialize(self)))"
        }
    }
    public class FileLinkMetadataSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: FileLinkMetadata) -> JSON {
            let output = [ 
            "url": Serialization._StringSerializer.serialize(value.url),
            "name": Serialization._StringSerializer.serialize(value.name),
            "link_permissions": Sharing.LinkPermissionsSerializer().serialize(value.linkPermissions),
            "client_modified": NSDateSerializer("%Y-%m-%dT%H:%M:%SZ").serialize(value.clientModified),
            "server_modified": NSDateSerializer("%Y-%m-%dT%H:%M:%SZ").serialize(value.serverModified),
            "rev": Serialization._StringSerializer.serialize(value.rev),
            "size": Serialization._UInt64Serializer.serialize(value.size),
            "id": NullableSerializer(Serialization._StringSerializer).serialize(value.id),
            "expires": NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.expires),
            "path_lower": NullableSerializer(Serialization._StringSerializer).serialize(value.pathLower),
            "team_member_info": NullableSerializer(Sharing.TeamMemberInfoSerializer()).serialize(value.teamMemberInfo),
            "content_owner_team_info": NullableSerializer(Users.TeamSerializer()).serialize(value.contentOwnerTeamInfo),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> FileLinkMetadata {
            switch json {
                case .Dictionary(let dict):
                    let url = Serialization._StringSerializer.deserialize(dict["url"] ?? .Null)
                    let name = Serialization._StringSerializer.deserialize(dict["name"] ?? .Null)
                    let linkPermissions = Sharing.LinkPermissionsSerializer().deserialize(dict["link_permissions"] ?? .Null)
                    let clientModified = NSDateSerializer("%Y-%m-%dT%H:%M:%SZ").deserialize(dict["client_modified"] ?? .Null)
                    let serverModified = NSDateSerializer("%Y-%m-%dT%H:%M:%SZ").deserialize(dict["server_modified"] ?? .Null)
                    let rev = Serialization._StringSerializer.deserialize(dict["rev"] ?? .Null)
                    let size = Serialization._UInt64Serializer.deserialize(dict["size"] ?? .Null)
                    let id = NullableSerializer(Serialization._StringSerializer).deserialize(dict["id"] ?? .Null)
                    let expires = NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).deserialize(dict["expires"] ?? .Null)
                    let pathLower = NullableSerializer(Serialization._StringSerializer).deserialize(dict["path_lower"] ?? .Null)
                    let teamMemberInfo = NullableSerializer(Sharing.TeamMemberInfoSerializer()).deserialize(dict["team_member_info"] ?? .Null)
                    let contentOwnerTeamInfo = NullableSerializer(Users.TeamSerializer()).deserialize(dict["content_owner_team_info"] ?? .Null)
                    return FileLinkMetadata(url: url, name: name, linkPermissions: linkPermissions, clientModified: clientModified, serverModified: serverModified, rev: rev, size: size, id: id, expires: expires, pathLower: pathLower, teamMemberInfo: teamMemberInfo, contentOwnerTeamInfo: contentOwnerTeamInfo)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The FileMemberActionError union
    public enum FileMemberActionError: CustomStringConvertible {
        /// Specified member was not found.
        case InvalidMember
        /// User does not have permission to perform this action on this member.
        case NoPermission
        /// Unknown error when applying action to member.
        case Other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(FileMemberActionErrorSerializer().serialize(self)))"
        }
    }
    public class FileMemberActionErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: FileMemberActionError) -> JSON {
            switch value {
                case .InvalidMember:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("invalid_member")
                    return .Dictionary(d)
                case .NoPermission:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("no_permission")
                    return .Dictionary(d)
                case .Other:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> FileMemberActionError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "invalid_member":
                            return FileMemberActionError.InvalidMember
                        case "no_permission":
                            return FileMemberActionError.NoPermission
                        case "other":
                            return FileMemberActionError.Other
                        default:
                            return FileMemberActionError.Other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The FileMemberActionIndividualResult union
    public enum FileMemberActionIndividualResult: CustomStringConvertible {
        /// Member was successfully removed from this file. If AccessLevel is given, the member still has access via a
        /// parent shared folder.
        case Success(Sharing.AccessLevel?)
        /// User was not able to remove this member.
        case MemberError(Sharing.FileMemberActionError)

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(FileMemberActionIndividualResultSerializer().serialize(self)))"
        }
    }
    public class FileMemberActionIndividualResultSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: FileMemberActionIndividualResult) -> JSON {
            switch value {
                case .Success(let arg):
                    var d = ["success": NullableSerializer(Sharing.AccessLevelSerializer()).serialize(arg)]
                    d[".tag"] = .Str("success")
                    return .Dictionary(d)
                case .MemberError(let arg):
                    var d = ["member_error": Sharing.FileMemberActionErrorSerializer().serialize(arg)]
                    d[".tag"] = .Str("member_error")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> FileMemberActionIndividualResult {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "success":
                            let v = NullableSerializer(Sharing.AccessLevelSerializer()).deserialize(d["success"] ?? .Null)
                            return FileMemberActionIndividualResult.Success(v)
                        case "member_error":
                            let v = Sharing.FileMemberActionErrorSerializer().deserialize(d["member_error"] ?? .Null)
                            return FileMemberActionIndividualResult.MemberError(v)
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Per-member result for removeFileMember2 or addFileMember.
    public class FileMemberActionResult: CustomStringConvertible {
        /// One of specified input members.
        public let member: Sharing.MemberSelector
        /// The outcome of the action on this member.
        public let result: Sharing.FileMemberActionIndividualResult
        public init(member: Sharing.MemberSelector, result: Sharing.FileMemberActionIndividualResult) {
            self.member = member
            self.result = result
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(FileMemberActionResultSerializer().serialize(self)))"
        }
    }
    public class FileMemberActionResultSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: FileMemberActionResult) -> JSON {
            let output = [ 
            "member": Sharing.MemberSelectorSerializer().serialize(value.member),
            "result": Sharing.FileMemberActionIndividualResultSerializer().serialize(value.result),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> FileMemberActionResult {
            switch json {
                case .Dictionary(let dict):
                    let member = Sharing.MemberSelectorSerializer().deserialize(dict["member"] ?? .Null)
                    let result = Sharing.FileMemberActionIndividualResultSerializer().deserialize(dict["result"] ?? .Null)
                    return FileMemberActionResult(member: member, result: result)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The FileMemberRemoveActionResult union
    public enum FileMemberRemoveActionResult: CustomStringConvertible {
        /// Member was successfully removed from this file.
        case Success(Sharing.MemberAccessLevelResult)
        /// User was not able to remove this member.
        case MemberError(Sharing.FileMemberActionError)
        /// (undocumented)
        case Other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(FileMemberRemoveActionResultSerializer().serialize(self)))"
        }
    }
    public class FileMemberRemoveActionResultSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: FileMemberRemoveActionResult) -> JSON {
            switch value {
                case .Success(let arg):
                    var d = Serialization.getFields(Sharing.MemberAccessLevelResultSerializer().serialize(arg))
                    d[".tag"] = .Str("success")
                    return .Dictionary(d)
                case .MemberError(let arg):
                    var d = ["member_error": Sharing.FileMemberActionErrorSerializer().serialize(arg)]
                    d[".tag"] = .Str("member_error")
                    return .Dictionary(d)
                case .Other:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> FileMemberRemoveActionResult {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "success":
                            let v = Sharing.MemberAccessLevelResultSerializer().deserialize(json)
                            return FileMemberRemoveActionResult.Success(v)
                        case "member_error":
                            let v = Sharing.FileMemberActionErrorSerializer().deserialize(d["member_error"] ?? .Null)
                            return FileMemberRemoveActionResult.MemberError(v)
                        case "other":
                            return FileMemberRemoveActionResult.Other
                        default:
                            return FileMemberRemoveActionResult.Other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Whether the user is allowed to take the sharing action on the file.
    public class FilePermission: CustomStringConvertible {
        /// The action that the user may wish to take on the file.
        public let action: Sharing.FileAction
        /// True if the user is allowed to take the action.
        public let allow: Bool
        /// The reason why the user is denied the permission. Not present if the action is allowed
        public let reason: Sharing.PermissionDeniedReason?
        public init(action: Sharing.FileAction, allow: Bool, reason: Sharing.PermissionDeniedReason? = nil) {
            self.action = action
            self.allow = allow
            self.reason = reason
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(FilePermissionSerializer().serialize(self)))"
        }
    }
    public class FilePermissionSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: FilePermission) -> JSON {
            let output = [ 
            "action": Sharing.FileActionSerializer().serialize(value.action),
            "allow": Serialization._BoolSerializer.serialize(value.allow),
            "reason": NullableSerializer(Sharing.PermissionDeniedReasonSerializer()).serialize(value.reason),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> FilePermission {
            switch json {
                case .Dictionary(let dict):
                    let action = Sharing.FileActionSerializer().deserialize(dict["action"] ?? .Null)
                    let allow = Serialization._BoolSerializer.deserialize(dict["allow"] ?? .Null)
                    let reason = NullableSerializer(Sharing.PermissionDeniedReasonSerializer()).deserialize(dict["reason"] ?? .Null)
                    return FilePermission(action: action, allow: allow, reason: reason)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Actions that may be taken on shared folders.
    public enum FolderAction: CustomStringConvertible {
        /// Change folder options, such as who can be invited to join the folder.
        case ChangeOptions
        /// Change or edit contents of the folder.
        case EditContents
        /// Invite a user or group to join the folder with read and write permission.
        case InviteEditor
        /// Invite a user or group to join the folder with read permission.
        case InviteViewer
        /// Relinquish one's own membership in the folder.
        case RelinquishMembership
        /// Unmount the folder.
        case Unmount
        /// Stop sharing this folder.
        case Unshare
        /// Keep a copy of the contents upon leaving or being kicked from the folder.
        case LeaveACopy
        /// (undocumented)
        case Other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(FolderActionSerializer().serialize(self)))"
        }
    }
    public class FolderActionSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: FolderAction) -> JSON {
            switch value {
                case .ChangeOptions:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("change_options")
                    return .Dictionary(d)
                case .EditContents:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("edit_contents")
                    return .Dictionary(d)
                case .InviteEditor:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("invite_editor")
                    return .Dictionary(d)
                case .InviteViewer:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("invite_viewer")
                    return .Dictionary(d)
                case .RelinquishMembership:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("relinquish_membership")
                    return .Dictionary(d)
                case .Unmount:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("unmount")
                    return .Dictionary(d)
                case .Unshare:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("unshare")
                    return .Dictionary(d)
                case .LeaveACopy:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("leave_a_copy")
                    return .Dictionary(d)
                case .Other:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> FolderAction {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "change_options":
                            return FolderAction.ChangeOptions
                        case "edit_contents":
                            return FolderAction.EditContents
                        case "invite_editor":
                            return FolderAction.InviteEditor
                        case "invite_viewer":
                            return FolderAction.InviteViewer
                        case "relinquish_membership":
                            return FolderAction.RelinquishMembership
                        case "unmount":
                            return FolderAction.Unmount
                        case "unshare":
                            return FolderAction.Unshare
                        case "leave_a_copy":
                            return FolderAction.LeaveACopy
                        case "other":
                            return FolderAction.Other
                        default:
                            return FolderAction.Other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The metadata of a folder shared link
    public class FolderLinkMetadata: Sharing.SharedLinkMetadata {
        public override var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(FolderLinkMetadataSerializer().serialize(self)))"
        }
    }
    public class FolderLinkMetadataSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: FolderLinkMetadata) -> JSON {
            let output = [ 
            "url": Serialization._StringSerializer.serialize(value.url),
            "name": Serialization._StringSerializer.serialize(value.name),
            "link_permissions": Sharing.LinkPermissionsSerializer().serialize(value.linkPermissions),
            "id": NullableSerializer(Serialization._StringSerializer).serialize(value.id),
            "expires": NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.expires),
            "path_lower": NullableSerializer(Serialization._StringSerializer).serialize(value.pathLower),
            "team_member_info": NullableSerializer(Sharing.TeamMemberInfoSerializer()).serialize(value.teamMemberInfo),
            "content_owner_team_info": NullableSerializer(Users.TeamSerializer()).serialize(value.contentOwnerTeamInfo),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> FolderLinkMetadata {
            switch json {
                case .Dictionary(let dict):
                    let url = Serialization._StringSerializer.deserialize(dict["url"] ?? .Null)
                    let name = Serialization._StringSerializer.deserialize(dict["name"] ?? .Null)
                    let linkPermissions = Sharing.LinkPermissionsSerializer().deserialize(dict["link_permissions"] ?? .Null)
                    let id = NullableSerializer(Serialization._StringSerializer).deserialize(dict["id"] ?? .Null)
                    let expires = NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).deserialize(dict["expires"] ?? .Null)
                    let pathLower = NullableSerializer(Serialization._StringSerializer).deserialize(dict["path_lower"] ?? .Null)
                    let teamMemberInfo = NullableSerializer(Sharing.TeamMemberInfoSerializer()).deserialize(dict["team_member_info"] ?? .Null)
                    let contentOwnerTeamInfo = NullableSerializer(Users.TeamSerializer()).deserialize(dict["content_owner_team_info"] ?? .Null)
                    return FolderLinkMetadata(url: url, name: name, linkPermissions: linkPermissions, id: id, expires: expires, pathLower: pathLower, teamMemberInfo: teamMemberInfo, contentOwnerTeamInfo: contentOwnerTeamInfo)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Whether the user is allowed to take the action on the shared folder.
    public class FolderPermission: CustomStringConvertible {
        /// The action that the user may wish to take on the folder.
        public let action: Sharing.FolderAction
        /// True if the user is allowed to take the action.
        public let allow: Bool
        /// The reason why the user is denied the permission. Not present if the action is allowed, or if no reason is
        /// available.
        public let reason: Sharing.PermissionDeniedReason?
        public init(action: Sharing.FolderAction, allow: Bool, reason: Sharing.PermissionDeniedReason? = nil) {
            self.action = action
            self.allow = allow
            self.reason = reason
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(FolderPermissionSerializer().serialize(self)))"
        }
    }
    public class FolderPermissionSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: FolderPermission) -> JSON {
            let output = [ 
            "action": Sharing.FolderActionSerializer().serialize(value.action),
            "allow": Serialization._BoolSerializer.serialize(value.allow),
            "reason": NullableSerializer(Sharing.PermissionDeniedReasonSerializer()).serialize(value.reason),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> FolderPermission {
            switch json {
                case .Dictionary(let dict):
                    let action = Sharing.FolderActionSerializer().deserialize(dict["action"] ?? .Null)
                    let allow = Serialization._BoolSerializer.deserialize(dict["allow"] ?? .Null)
                    let reason = NullableSerializer(Sharing.PermissionDeniedReasonSerializer()).deserialize(dict["reason"] ?? .Null)
                    return FolderPermission(action: action, allow: allow, reason: reason)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// A set of policies governing membership and privileges for a shared folder.
    public class FolderPolicy: CustomStringConvertible {
        /// Who can be a member of this shared folder, as set on the folder itself. The effective policy may differ from
        /// this value if the team-wide policy is more restrictive. Present only if the folder is owned by a team.
        public let memberPolicy: Sharing.MemberPolicy?
        /// Who can be a member of this shared folder, taking into account both the folder and the team-wide policy.
        /// This value may differ from that of member_policy if the team-wide policy is more restrictive than the folder
        /// policy. Present only if the folder is owned by a team.
        public let resolvedMemberPolicy: Sharing.MemberPolicy?
        /// Who can add and remove members from this shared folder.
        public let aclUpdatePolicy: Sharing.AclUpdatePolicy
        /// Who links can be shared with.
        public let sharedLinkPolicy: Sharing.SharedLinkPolicy
        public init(aclUpdatePolicy: Sharing.AclUpdatePolicy, sharedLinkPolicy: Sharing.SharedLinkPolicy, memberPolicy: Sharing.MemberPolicy? = nil, resolvedMemberPolicy: Sharing.MemberPolicy? = nil) {
            self.memberPolicy = memberPolicy
            self.resolvedMemberPolicy = resolvedMemberPolicy
            self.aclUpdatePolicy = aclUpdatePolicy
            self.sharedLinkPolicy = sharedLinkPolicy
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(FolderPolicySerializer().serialize(self)))"
        }
    }
    public class FolderPolicySerializer: JSONSerializer {
        public init() { }
        public func serialize(value: FolderPolicy) -> JSON {
            let output = [ 
            "acl_update_policy": Sharing.AclUpdatePolicySerializer().serialize(value.aclUpdatePolicy),
            "shared_link_policy": Sharing.SharedLinkPolicySerializer().serialize(value.sharedLinkPolicy),
            "member_policy": NullableSerializer(Sharing.MemberPolicySerializer()).serialize(value.memberPolicy),
            "resolved_member_policy": NullableSerializer(Sharing.MemberPolicySerializer()).serialize(value.resolvedMemberPolicy),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> FolderPolicy {
            switch json {
                case .Dictionary(let dict):
                    let aclUpdatePolicy = Sharing.AclUpdatePolicySerializer().deserialize(dict["acl_update_policy"] ?? .Null)
                    let sharedLinkPolicy = Sharing.SharedLinkPolicySerializer().deserialize(dict["shared_link_policy"] ?? .Null)
                    let memberPolicy = NullableSerializer(Sharing.MemberPolicySerializer()).deserialize(dict["member_policy"] ?? .Null)
                    let resolvedMemberPolicy = NullableSerializer(Sharing.MemberPolicySerializer()).deserialize(dict["resolved_member_policy"] ?? .Null)
                    return FolderPolicy(aclUpdatePolicy: aclUpdatePolicy, sharedLinkPolicy: sharedLinkPolicy, memberPolicy: memberPolicy, resolvedMemberPolicy: resolvedMemberPolicy)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Arguments of getFileMetadata
    public class GetFileMetadataArg: CustomStringConvertible {
        /// The file to query.
        public let file: String
        /// File actions to query.
        public let actions: Array<Sharing.FileAction>?
        public init(file: String, actions: Array<Sharing.FileAction>? = nil) {
            stringValidator(minLength: 1, pattern: "((/|id:).*|nspath:[^:]*:[^:]*)")(file)
            self.file = file
            self.actions = actions
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GetFileMetadataArgSerializer().serialize(self)))"
        }
    }
    public class GetFileMetadataArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: GetFileMetadataArg) -> JSON {
            let output = [ 
            "file": Serialization._StringSerializer.serialize(value.file),
            "actions": NullableSerializer(ArraySerializer(Sharing.FileActionSerializer())).serialize(value.actions),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> GetFileMetadataArg {
            switch json {
                case .Dictionary(let dict):
                    let file = Serialization._StringSerializer.deserialize(dict["file"] ?? .Null)
                    let actions = NullableSerializer(ArraySerializer(Sharing.FileActionSerializer())).deserialize(dict["actions"] ?? .Null)
                    return GetFileMetadataArg(file: file, actions: actions)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Arguments of getFileMetadataBatch
    public class GetFileMetadataBatchArg: CustomStringConvertible {
        /// The files to query.
        public let files: Array<String>
        /// File actions to query.
        public let actions: Array<Sharing.FileAction>?
        public init(files: Array<String>, actions: Array<Sharing.FileAction>? = nil) {
            arrayValidator(maxItems: 100, itemValidator: stringValidator(minLength: 1, pattern: "((/|id:).*|nspath:[^:]*:[^:]*)"))(files)
            self.files = files
            self.actions = actions
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GetFileMetadataBatchArgSerializer().serialize(self)))"
        }
    }
    public class GetFileMetadataBatchArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: GetFileMetadataBatchArg) -> JSON {
            let output = [ 
            "files": ArraySerializer(Serialization._StringSerializer).serialize(value.files),
            "actions": NullableSerializer(ArraySerializer(Sharing.FileActionSerializer())).serialize(value.actions),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> GetFileMetadataBatchArg {
            switch json {
                case .Dictionary(let dict):
                    let files = ArraySerializer(Serialization._StringSerializer).deserialize(dict["files"] ?? .Null)
                    let actions = NullableSerializer(ArraySerializer(Sharing.FileActionSerializer())).deserialize(dict["actions"] ?? .Null)
                    return GetFileMetadataBatchArg(files: files, actions: actions)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Per file results of getFileMetadataBatch
    public class GetFileMetadataBatchResult: CustomStringConvertible {
        /// This is the input file identifier corresponding to one of files in GetFileMetadataBatchArg.
        public let file: String
        /// The result for this particular file
        public let result: Sharing.GetFileMetadataIndividualResult
        public init(file: String, result: Sharing.GetFileMetadataIndividualResult) {
            stringValidator(minLength: 1, pattern: "((/|id:).*|nspath:[^:]*:[^:]*)")(file)
            self.file = file
            self.result = result
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GetFileMetadataBatchResultSerializer().serialize(self)))"
        }
    }
    public class GetFileMetadataBatchResultSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: GetFileMetadataBatchResult) -> JSON {
            let output = [ 
            "file": Serialization._StringSerializer.serialize(value.file),
            "result": Sharing.GetFileMetadataIndividualResultSerializer().serialize(value.result),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> GetFileMetadataBatchResult {
            switch json {
                case .Dictionary(let dict):
                    let file = Serialization._StringSerializer.deserialize(dict["file"] ?? .Null)
                    let result = Sharing.GetFileMetadataIndividualResultSerializer().deserialize(dict["result"] ?? .Null)
                    return GetFileMetadataBatchResult(file: file, result: result)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Error result for getFileMetadata.
    public enum GetFileMetadataError: CustomStringConvertible {
        /// (undocumented)
        case UserError(Sharing.SharingUserError)
        /// (undocumented)
        case AccessError(Sharing.SharingFileAccessError)
        /// (undocumented)
        case Other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GetFileMetadataErrorSerializer().serialize(self)))"
        }
    }
    public class GetFileMetadataErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: GetFileMetadataError) -> JSON {
            switch value {
                case .UserError(let arg):
                    var d = ["user_error": Sharing.SharingUserErrorSerializer().serialize(arg)]
                    d[".tag"] = .Str("user_error")
                    return .Dictionary(d)
                case .AccessError(let arg):
                    var d = ["access_error": Sharing.SharingFileAccessErrorSerializer().serialize(arg)]
                    d[".tag"] = .Str("access_error")
                    return .Dictionary(d)
                case .Other:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> GetFileMetadataError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "user_error":
                            let v = Sharing.SharingUserErrorSerializer().deserialize(d["user_error"] ?? .Null)
                            return GetFileMetadataError.UserError(v)
                        case "access_error":
                            let v = Sharing.SharingFileAccessErrorSerializer().deserialize(d["access_error"] ?? .Null)
                            return GetFileMetadataError.AccessError(v)
                        case "other":
                            return GetFileMetadataError.Other
                        default:
                            return GetFileMetadataError.Other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The GetFileMetadataIndividualResult union
    public enum GetFileMetadataIndividualResult: CustomStringConvertible {
        /// The result for this file if it was successful.
        case Metadata(Sharing.SharedFileMetadata)
        /// The result for this file if it was an error.
        case AccessError(Sharing.SharingFileAccessError)
        /// (undocumented)
        case Other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GetFileMetadataIndividualResultSerializer().serialize(self)))"
        }
    }
    public class GetFileMetadataIndividualResultSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: GetFileMetadataIndividualResult) -> JSON {
            switch value {
                case .Metadata(let arg):
                    var d = Serialization.getFields(Sharing.SharedFileMetadataSerializer().serialize(arg))
                    d[".tag"] = .Str("metadata")
                    return .Dictionary(d)
                case .AccessError(let arg):
                    var d = ["access_error": Sharing.SharingFileAccessErrorSerializer().serialize(arg)]
                    d[".tag"] = .Str("access_error")
                    return .Dictionary(d)
                case .Other:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> GetFileMetadataIndividualResult {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "metadata":
                            let v = Sharing.SharedFileMetadataSerializer().deserialize(json)
                            return GetFileMetadataIndividualResult.Metadata(v)
                        case "access_error":
                            let v = Sharing.SharingFileAccessErrorSerializer().deserialize(d["access_error"] ?? .Null)
                            return GetFileMetadataIndividualResult.AccessError(v)
                        case "other":
                            return GetFileMetadataIndividualResult.Other
                        default:
                            return GetFileMetadataIndividualResult.Other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The GetMetadataArgs struct
    public class GetMetadataArgs: CustomStringConvertible {
        /// The ID for the shared folder.
        public let sharedFolderId: String
        /// This is a list indicating whether the returned folder data will include a boolean value  allow in
        /// FolderPermission that describes whether the current user can perform the  FolderAction on the folder.
        public let actions: Array<Sharing.FolderAction>?
        public init(sharedFolderId: String, actions: Array<Sharing.FolderAction>? = nil) {
            stringValidator(pattern: "[-_0-9a-zA-Z:]+")(sharedFolderId)
            self.sharedFolderId = sharedFolderId
            self.actions = actions
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GetMetadataArgsSerializer().serialize(self)))"
        }
    }
    public class GetMetadataArgsSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: GetMetadataArgs) -> JSON {
            let output = [ 
            "shared_folder_id": Serialization._StringSerializer.serialize(value.sharedFolderId),
            "actions": NullableSerializer(ArraySerializer(Sharing.FolderActionSerializer())).serialize(value.actions),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> GetMetadataArgs {
            switch json {
                case .Dictionary(let dict):
                    let sharedFolderId = Serialization._StringSerializer.deserialize(dict["shared_folder_id"] ?? .Null)
                    let actions = NullableSerializer(ArraySerializer(Sharing.FolderActionSerializer())).deserialize(dict["actions"] ?? .Null)
                    return GetMetadataArgs(sharedFolderId: sharedFolderId, actions: actions)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The SharedLinkError union
    public enum SharedLinkError: CustomStringConvertible {
        /// The shared link wasn't found
        case SharedLinkNotFound
        /// The caller is not allowed to access this shared link
        case SharedLinkAccessDenied
        /// An unspecified error
        case Other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharedLinkErrorSerializer().serialize(self)))"
        }
    }
    public class SharedLinkErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: SharedLinkError) -> JSON {
            switch value {
                case .SharedLinkNotFound:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("shared_link_not_found")
                    return .Dictionary(d)
                case .SharedLinkAccessDenied:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("shared_link_access_denied")
                    return .Dictionary(d)
                case .Other:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> SharedLinkError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "shared_link_not_found":
                            return SharedLinkError.SharedLinkNotFound
                        case "shared_link_access_denied":
                            return SharedLinkError.SharedLinkAccessDenied
                        case "other":
                            return SharedLinkError.Other
                        default:
                            return SharedLinkError.Other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The GetSharedLinkFileError union
    public enum GetSharedLinkFileError: CustomStringConvertible {
        /// The shared link wasn't found
        case SharedLinkNotFound
        /// The caller is not allowed to access this shared link
        case SharedLinkAccessDenied
        /// An unspecified error
        case Other
        /// Directories cannot be retrieved by this endpoint.
        case SharedLinkIsDirectory

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GetSharedLinkFileErrorSerializer().serialize(self)))"
        }
    }
    public class GetSharedLinkFileErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: GetSharedLinkFileError) -> JSON {
            switch value {
                case .SharedLinkNotFound:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("shared_link_not_found")
                    return .Dictionary(d)
                case .SharedLinkAccessDenied:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("shared_link_access_denied")
                    return .Dictionary(d)
                case .Other:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
                case .SharedLinkIsDirectory:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("shared_link_is_directory")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> GetSharedLinkFileError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "shared_link_not_found":
                            return GetSharedLinkFileError.SharedLinkNotFound
                        case "shared_link_access_denied":
                            return GetSharedLinkFileError.SharedLinkAccessDenied
                        case "other":
                            return GetSharedLinkFileError.Other
                        case "shared_link_is_directory":
                            return GetSharedLinkFileError.SharedLinkIsDirectory
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The GetSharedLinkMetadataArg struct
    public class GetSharedLinkMetadataArg: CustomStringConvertible {
        /// URL of the shared link.
        public let url: String
        /// If the shared link is to a folder, this parameter can be used to retrieve the metadata for a specific file
        /// or sub-folder in this folder. A relative path should be used.
        public let path: String?
        /// If the shared link has a password, this parameter can be used.
        public let linkPassword: String?
        public init(url: String, path: String? = nil, linkPassword: String? = nil) {
            stringValidator()(url)
            self.url = url
            nullableValidator(stringValidator(pattern: "/(.|[\\r\\n])*"))(path)
            self.path = path
            nullableValidator(stringValidator())(linkPassword)
            self.linkPassword = linkPassword
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GetSharedLinkMetadataArgSerializer().serialize(self)))"
        }
    }
    public class GetSharedLinkMetadataArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: GetSharedLinkMetadataArg) -> JSON {
            let output = [ 
            "url": Serialization._StringSerializer.serialize(value.url),
            "path": NullableSerializer(Serialization._StringSerializer).serialize(value.path),
            "link_password": NullableSerializer(Serialization._StringSerializer).serialize(value.linkPassword),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> GetSharedLinkMetadataArg {
            switch json {
                case .Dictionary(let dict):
                    let url = Serialization._StringSerializer.deserialize(dict["url"] ?? .Null)
                    let path = NullableSerializer(Serialization._StringSerializer).deserialize(dict["path"] ?? .Null)
                    let linkPassword = NullableSerializer(Serialization._StringSerializer).deserialize(dict["link_password"] ?? .Null)
                    return GetSharedLinkMetadataArg(url: url, path: path, linkPassword: linkPassword)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The GetSharedLinksArg struct
    public class GetSharedLinksArg: CustomStringConvertible {
        /// See getSharedLinks description.
        public let path: String?
        public init(path: String? = nil) {
            nullableValidator(stringValidator())(path)
            self.path = path
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GetSharedLinksArgSerializer().serialize(self)))"
        }
    }
    public class GetSharedLinksArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: GetSharedLinksArg) -> JSON {
            let output = [ 
            "path": NullableSerializer(Serialization._StringSerializer).serialize(value.path),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> GetSharedLinksArg {
            switch json {
                case .Dictionary(let dict):
                    let path = NullableSerializer(Serialization._StringSerializer).deserialize(dict["path"] ?? .Null)
                    return GetSharedLinksArg(path: path)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The GetSharedLinksError union
    public enum GetSharedLinksError: CustomStringConvertible {
        /// (undocumented)
        case Path(String?)
        /// (undocumented)
        case Other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GetSharedLinksErrorSerializer().serialize(self)))"
        }
    }
    public class GetSharedLinksErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: GetSharedLinksError) -> JSON {
            switch value {
                case .Path(let arg):
                    var d = ["path": NullableSerializer(Serialization._StringSerializer).serialize(arg)]
                    d[".tag"] = .Str("path")
                    return .Dictionary(d)
                case .Other:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> GetSharedLinksError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "path":
                            let v = NullableSerializer(Serialization._StringSerializer).deserialize(d["path"] ?? .Null)
                            return GetSharedLinksError.Path(v)
                        case "other":
                            return GetSharedLinksError.Other
                        default:
                            return GetSharedLinksError.Other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The GetSharedLinksResult struct
    public class GetSharedLinksResult: CustomStringConvertible {
        /// Shared links applicable to the path argument.
        public let links: Array<Sharing.LinkMetadata>
        public init(links: Array<Sharing.LinkMetadata>) {
            self.links = links
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GetSharedLinksResultSerializer().serialize(self)))"
        }
    }
    public class GetSharedLinksResultSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: GetSharedLinksResult) -> JSON {
            let output = [ 
            "links": ArraySerializer(Sharing.LinkMetadataSerializer()).serialize(value.links),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> GetSharedLinksResult {
            switch json {
                case .Dictionary(let dict):
                    let links = ArraySerializer(Sharing.LinkMetadataSerializer()).deserialize(dict["links"] ?? .Null)
                    return GetSharedLinksResult(links: links)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The information about a group. Groups is a way to manage a list of users  who need same access permission to the
    /// shared folder.
    public class GroupInfo: TeamCommon.GroupSummary {
        /// The type of group.
        public let groupType: TeamCommon.GroupType
        /// If the current user is an owner of the group.
        public let isOwner: Bool
        /// If the group is owned by the current user's team.
        public let sameTeam: Bool
        public init(groupName: String, groupId: String, groupType: TeamCommon.GroupType, isOwner: Bool, sameTeam: Bool, groupExternalId: String? = nil, memberCount: UInt32? = nil) {
            self.groupType = groupType
            self.isOwner = isOwner
            self.sameTeam = sameTeam
            super.init(groupName: groupName, groupId: groupId, groupExternalId: groupExternalId, memberCount: memberCount)
        }
        public override var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GroupInfoSerializer().serialize(self)))"
        }
    }
    public class GroupInfoSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: GroupInfo) -> JSON {
            let output = [ 
            "group_name": Serialization._StringSerializer.serialize(value.groupName),
            "group_id": Serialization._StringSerializer.serialize(value.groupId),
            "group_type": TeamCommon.GroupTypeSerializer().serialize(value.groupType),
            "is_owner": Serialization._BoolSerializer.serialize(value.isOwner),
            "same_team": Serialization._BoolSerializer.serialize(value.sameTeam),
            "group_external_id": NullableSerializer(Serialization._StringSerializer).serialize(value.groupExternalId),
            "member_count": NullableSerializer(Serialization._UInt32Serializer).serialize(value.memberCount),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> GroupInfo {
            switch json {
                case .Dictionary(let dict):
                    let groupName = Serialization._StringSerializer.deserialize(dict["group_name"] ?? .Null)
                    let groupId = Serialization._StringSerializer.deserialize(dict["group_id"] ?? .Null)
                    let groupType = TeamCommon.GroupTypeSerializer().deserialize(dict["group_type"] ?? .Null)
                    let isOwner = Serialization._BoolSerializer.deserialize(dict["is_owner"] ?? .Null)
                    let sameTeam = Serialization._BoolSerializer.deserialize(dict["same_team"] ?? .Null)
                    let groupExternalId = NullableSerializer(Serialization._StringSerializer).deserialize(dict["group_external_id"] ?? .Null)
                    let memberCount = NullableSerializer(Serialization._UInt32Serializer).deserialize(dict["member_count"] ?? .Null)
                    return GroupInfo(groupName: groupName, groupId: groupId, groupType: groupType, isOwner: isOwner, sameTeam: sameTeam, groupExternalId: groupExternalId, memberCount: memberCount)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The information about a member of the shared content.
    public class MembershipInfo: CustomStringConvertible {
        /// The access type for this member.
        public let accessType: Sharing.AccessLevel
        /// The permissions that requesting user has on this member. The set of permissions corresponds to the
        /// MemberActions in the request.
        public let permissions: Array<Sharing.MemberPermission>?
        /// Suggested name initials for a member.
        public let initials: String?
        /// True if the member has access from a parent folder.
        public let isInherited: Bool
        public init(accessType: Sharing.AccessLevel, permissions: Array<Sharing.MemberPermission>? = nil, initials: String? = nil, isInherited: Bool = false) {
            self.accessType = accessType
            self.permissions = permissions
            nullableValidator(stringValidator())(initials)
            self.initials = initials
            self.isInherited = isInherited
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MembershipInfoSerializer().serialize(self)))"
        }
    }
    public class MembershipInfoSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: MembershipInfo) -> JSON {
            let output = [ 
            "access_type": Sharing.AccessLevelSerializer().serialize(value.accessType),
            "permissions": NullableSerializer(ArraySerializer(Sharing.MemberPermissionSerializer())).serialize(value.permissions),
            "initials": NullableSerializer(Serialization._StringSerializer).serialize(value.initials),
            "is_inherited": Serialization._BoolSerializer.serialize(value.isInherited),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> MembershipInfo {
            switch json {
                case .Dictionary(let dict):
                    let accessType = Sharing.AccessLevelSerializer().deserialize(dict["access_type"] ?? .Null)
                    let permissions = NullableSerializer(ArraySerializer(Sharing.MemberPermissionSerializer())).deserialize(dict["permissions"] ?? .Null)
                    let initials = NullableSerializer(Serialization._StringSerializer).deserialize(dict["initials"] ?? .Null)
                    let isInherited = Serialization._BoolSerializer.deserialize(dict["is_inherited"] ?? .Null)
                    return MembershipInfo(accessType: accessType, permissions: permissions, initials: initials, isInherited: isInherited)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The information about a group member of the shared content.
    public class GroupMembershipInfo: Sharing.MembershipInfo {
        /// The information about the membership group.
        public let group: Sharing.GroupInfo
        public init(accessType: Sharing.AccessLevel, group: Sharing.GroupInfo, permissions: Array<Sharing.MemberPermission>? = nil, initials: String? = nil, isInherited: Bool = false) {
            self.group = group
            super.init(accessType: accessType, permissions: permissions, initials: initials, isInherited: isInherited)
        }
        public override var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GroupMembershipInfoSerializer().serialize(self)))"
        }
    }
    public class GroupMembershipInfoSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: GroupMembershipInfo) -> JSON {
            let output = [ 
            "access_type": Sharing.AccessLevelSerializer().serialize(value.accessType),
            "group": Sharing.GroupInfoSerializer().serialize(value.group),
            "permissions": NullableSerializer(ArraySerializer(Sharing.MemberPermissionSerializer())).serialize(value.permissions),
            "initials": NullableSerializer(Serialization._StringSerializer).serialize(value.initials),
            "is_inherited": Serialization._BoolSerializer.serialize(value.isInherited),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> GroupMembershipInfo {
            switch json {
                case .Dictionary(let dict):
                    let accessType = Sharing.AccessLevelSerializer().deserialize(dict["access_type"] ?? .Null)
                    let group = Sharing.GroupInfoSerializer().deserialize(dict["group"] ?? .Null)
                    let permissions = NullableSerializer(ArraySerializer(Sharing.MemberPermissionSerializer())).deserialize(dict["permissions"] ?? .Null)
                    let initials = NullableSerializer(Serialization._StringSerializer).deserialize(dict["initials"] ?? .Null)
                    let isInherited = Serialization._BoolSerializer.deserialize(dict["is_inherited"] ?? .Null)
                    return GroupMembershipInfo(accessType: accessType, group: group, permissions: permissions, initials: initials, isInherited: isInherited)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Information about the recipient of a shared content invitation.
    public enum InviteeInfo: CustomStringConvertible {
        /// E-mail address of invited user.
        case Email(String)
        /// (undocumented)
        case Other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(InviteeInfoSerializer().serialize(self)))"
        }
    }
    public class InviteeInfoSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: InviteeInfo) -> JSON {
            switch value {
                case .Email(let arg):
                    var d = ["email": Serialization._StringSerializer.serialize(arg)]
                    d[".tag"] = .Str("email")
                    return .Dictionary(d)
                case .Other:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> InviteeInfo {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "email":
                            let v = Serialization._StringSerializer.deserialize(d["email"] ?? .Null)
                            return InviteeInfo.Email(v)
                        case "other":
                            return InviteeInfo.Other
                        default:
                            return InviteeInfo.Other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Information about an invited member of a shared content.
    public class InviteeMembershipInfo: Sharing.MembershipInfo {
        /// Recipient of the invitation.
        public let invitee: Sharing.InviteeInfo
        /// The user this invitation is tied to, if available.
        public let user: Sharing.UserInfo?
        public init(accessType: Sharing.AccessLevel, invitee: Sharing.InviteeInfo, permissions: Array<Sharing.MemberPermission>? = nil, initials: String? = nil, isInherited: Bool = false, user: Sharing.UserInfo? = nil) {
            self.invitee = invitee
            self.user = user
            super.init(accessType: accessType, permissions: permissions, initials: initials, isInherited: isInherited)
        }
        public override var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(InviteeMembershipInfoSerializer().serialize(self)))"
        }
    }
    public class InviteeMembershipInfoSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: InviteeMembershipInfo) -> JSON {
            let output = [ 
            "access_type": Sharing.AccessLevelSerializer().serialize(value.accessType),
            "invitee": Sharing.InviteeInfoSerializer().serialize(value.invitee),
            "permissions": NullableSerializer(ArraySerializer(Sharing.MemberPermissionSerializer())).serialize(value.permissions),
            "initials": NullableSerializer(Serialization._StringSerializer).serialize(value.initials),
            "is_inherited": Serialization._BoolSerializer.serialize(value.isInherited),
            "user": NullableSerializer(Sharing.UserInfoSerializer()).serialize(value.user),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> InviteeMembershipInfo {
            switch json {
                case .Dictionary(let dict):
                    let accessType = Sharing.AccessLevelSerializer().deserialize(dict["access_type"] ?? .Null)
                    let invitee = Sharing.InviteeInfoSerializer().deserialize(dict["invitee"] ?? .Null)
                    let permissions = NullableSerializer(ArraySerializer(Sharing.MemberPermissionSerializer())).deserialize(dict["permissions"] ?? .Null)
                    let initials = NullableSerializer(Serialization._StringSerializer).deserialize(dict["initials"] ?? .Null)
                    let isInherited = Serialization._BoolSerializer.deserialize(dict["is_inherited"] ?? .Null)
                    let user = NullableSerializer(Sharing.UserInfoSerializer()).deserialize(dict["user"] ?? .Null)
                    return InviteeMembershipInfo(accessType: accessType, invitee: invitee, permissions: permissions, initials: initials, isInherited: isInherited, user: user)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Error occurred while performing an asynchronous job from unshareFolder or removeFolderMember.
    public enum JobError: CustomStringConvertible {
        /// Error occurred while performing unshareFolder action.
        case UnshareFolderError(Sharing.UnshareFolderError)
        /// Error occurred while performing removeFolderMember action.
        case RemoveFolderMemberError(Sharing.RemoveFolderMemberError)
        /// Error occurred while performing relinquishFolderMembership action.
        case RelinquishFolderMembershipError(Sharing.RelinquishFolderMembershipError)
        /// (undocumented)
        case Other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(JobErrorSerializer().serialize(self)))"
        }
    }
    public class JobErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: JobError) -> JSON {
            switch value {
                case .UnshareFolderError(let arg):
                    var d = ["unshare_folder_error": Sharing.UnshareFolderErrorSerializer().serialize(arg)]
                    d[".tag"] = .Str("unshare_folder_error")
                    return .Dictionary(d)
                case .RemoveFolderMemberError(let arg):
                    var d = ["remove_folder_member_error": Sharing.RemoveFolderMemberErrorSerializer().serialize(arg)]
                    d[".tag"] = .Str("remove_folder_member_error")
                    return .Dictionary(d)
                case .RelinquishFolderMembershipError(let arg):
                    var d = ["relinquish_folder_membership_error": Sharing.RelinquishFolderMembershipErrorSerializer().serialize(arg)]
                    d[".tag"] = .Str("relinquish_folder_membership_error")
                    return .Dictionary(d)
                case .Other:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> JobError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "unshare_folder_error":
                            let v = Sharing.UnshareFolderErrorSerializer().deserialize(d["unshare_folder_error"] ?? .Null)
                            return JobError.UnshareFolderError(v)
                        case "remove_folder_member_error":
                            let v = Sharing.RemoveFolderMemberErrorSerializer().deserialize(d["remove_folder_member_error"] ?? .Null)
                            return JobError.RemoveFolderMemberError(v)
                        case "relinquish_folder_membership_error":
                            let v = Sharing.RelinquishFolderMembershipErrorSerializer().deserialize(d["relinquish_folder_membership_error"] ?? .Null)
                            return JobError.RelinquishFolderMembershipError(v)
                        case "other":
                            return JobError.Other
                        default:
                            return JobError.Other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The JobStatus union
    public enum JobStatus: CustomStringConvertible {
        /// The asynchronous job is still in progress.
        case InProgress
        /// The asynchronous job has finished.
        case Complete
        /// The asynchronous job returned an error.
        case Failed(Sharing.JobError)

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(JobStatusSerializer().serialize(self)))"
        }
    }
    public class JobStatusSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: JobStatus) -> JSON {
            switch value {
                case .InProgress:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("in_progress")
                    return .Dictionary(d)
                case .Complete:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("complete")
                    return .Dictionary(d)
                case .Failed(let arg):
                    var d = ["failed": Sharing.JobErrorSerializer().serialize(arg)]
                    d[".tag"] = .Str("failed")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> JobStatus {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "in_progress":
                            return JobStatus.InProgress
                        case "complete":
                            return JobStatus.Complete
                        case "failed":
                            let v = Sharing.JobErrorSerializer().deserialize(d["failed"] ?? .Null)
                            return JobStatus.Failed(v)
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The LinkPermissions struct
    public class LinkPermissions: CustomStringConvertible {
        /// The current visibility of the link after considering the shared links policies of the the team (in case the
        /// link's owner is part of a team) and the shared folder (in case the linked file is part of a shared folder).
        /// This field is shown only if the caller has access to this info (the link's owner always has access to this
        /// data).
        public let resolvedVisibility: Sharing.ResolvedVisibility?
        /// The shared link's requested visibility. This can be overridden by the team and shared folder policies. The
        /// final visibility, after considering these policies, can be found in resolvedVisibility. This is shown only
        /// if the caller is the link's owner.
        public let requestedVisibility: Sharing.RequestedVisibility?
        /// Whether the caller can revoke the shared link
        public let canRevoke: Bool
        /// The failure reason for revoking the link. This field will only be present if the canRevoke is false.
        public let revokeFailureReason: Sharing.SharedLinkAccessFailureReason?
        public init(canRevoke: Bool, resolvedVisibility: Sharing.ResolvedVisibility? = nil, requestedVisibility: Sharing.RequestedVisibility? = nil, revokeFailureReason: Sharing.SharedLinkAccessFailureReason? = nil) {
            self.resolvedVisibility = resolvedVisibility
            self.requestedVisibility = requestedVisibility
            self.canRevoke = canRevoke
            self.revokeFailureReason = revokeFailureReason
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(LinkPermissionsSerializer().serialize(self)))"
        }
    }
    public class LinkPermissionsSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: LinkPermissions) -> JSON {
            let output = [ 
            "can_revoke": Serialization._BoolSerializer.serialize(value.canRevoke),
            "resolved_visibility": NullableSerializer(Sharing.ResolvedVisibilitySerializer()).serialize(value.resolvedVisibility),
            "requested_visibility": NullableSerializer(Sharing.RequestedVisibilitySerializer()).serialize(value.requestedVisibility),
            "revoke_failure_reason": NullableSerializer(Sharing.SharedLinkAccessFailureReasonSerializer()).serialize(value.revokeFailureReason),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> LinkPermissions {
            switch json {
                case .Dictionary(let dict):
                    let canRevoke = Serialization._BoolSerializer.deserialize(dict["can_revoke"] ?? .Null)
                    let resolvedVisibility = NullableSerializer(Sharing.ResolvedVisibilitySerializer()).deserialize(dict["resolved_visibility"] ?? .Null)
                    let requestedVisibility = NullableSerializer(Sharing.RequestedVisibilitySerializer()).deserialize(dict["requested_visibility"] ?? .Null)
                    let revokeFailureReason = NullableSerializer(Sharing.SharedLinkAccessFailureReasonSerializer()).deserialize(dict["revoke_failure_reason"] ?? .Null)
                    return LinkPermissions(canRevoke: canRevoke, resolvedVisibility: resolvedVisibility, requestedVisibility: requestedVisibility, revokeFailureReason: revokeFailureReason)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Arguments for listFileMembers.
    public class ListFileMembersArg: CustomStringConvertible {
        /// The file for which you want to see members.
        public let file: String
        /// The actions for which to return permissions on a member
        public let actions: Array<Sharing.MemberAction>?
        /// Whether to include members who only have access from a parent shared folder.
        public let includeInherited: Bool
        /// Number of members to return max per query. Defaults to 100 if no limit is specified.
        public let limit: UInt32
        public init(file: String, actions: Array<Sharing.MemberAction>? = nil, includeInherited: Bool = true, limit: UInt32 = 100) {
            stringValidator(minLength: 1, pattern: "((/|id:).*|nspath:[^:]*:[^:]*)")(file)
            self.file = file
            self.actions = actions
            self.includeInherited = includeInherited
            comparableValidator(minValue: 1, maxValue: 300)(limit)
            self.limit = limit
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListFileMembersArgSerializer().serialize(self)))"
        }
    }
    public class ListFileMembersArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: ListFileMembersArg) -> JSON {
            let output = [ 
            "file": Serialization._StringSerializer.serialize(value.file),
            "actions": NullableSerializer(ArraySerializer(Sharing.MemberActionSerializer())).serialize(value.actions),
            "include_inherited": Serialization._BoolSerializer.serialize(value.includeInherited),
            "limit": Serialization._UInt32Serializer.serialize(value.limit),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> ListFileMembersArg {
            switch json {
                case .Dictionary(let dict):
                    let file = Serialization._StringSerializer.deserialize(dict["file"] ?? .Null)
                    let actions = NullableSerializer(ArraySerializer(Sharing.MemberActionSerializer())).deserialize(dict["actions"] ?? .Null)
                    let includeInherited = Serialization._BoolSerializer.deserialize(dict["include_inherited"] ?? .Null)
                    let limit = Serialization._UInt32Serializer.deserialize(dict["limit"] ?? .Null)
                    return ListFileMembersArg(file: file, actions: actions, includeInherited: includeInherited, limit: limit)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Arguments for listFileMembersBatch.
    public class ListFileMembersBatchArg: CustomStringConvertible {
        /// Files for which to return members.
        public let files: Array<String>
        /// Number of members to return max per query. Defaults to 10 if no limit is specified.
        public let limit: UInt32
        public init(files: Array<String>, limit: UInt32 = 10) {
            arrayValidator(maxItems: 100, itemValidator: stringValidator(minLength: 1, pattern: "((/|id:).*|nspath:[^:]*:[^:]*)"))(files)
            self.files = files
            comparableValidator(maxValue: 20)(limit)
            self.limit = limit
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListFileMembersBatchArgSerializer().serialize(self)))"
        }
    }
    public class ListFileMembersBatchArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: ListFileMembersBatchArg) -> JSON {
            let output = [ 
            "files": ArraySerializer(Serialization._StringSerializer).serialize(value.files),
            "limit": Serialization._UInt32Serializer.serialize(value.limit),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> ListFileMembersBatchArg {
            switch json {
                case .Dictionary(let dict):
                    let files = ArraySerializer(Serialization._StringSerializer).deserialize(dict["files"] ?? .Null)
                    let limit = Serialization._UInt32Serializer.deserialize(dict["limit"] ?? .Null)
                    return ListFileMembersBatchArg(files: files, limit: limit)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Per-file result for listFileMembersBatch.
    public class ListFileMembersBatchResult: CustomStringConvertible {
        /// This is the input file identifier, whether an ID or a path.
        public let file: String
        /// The result for this particular file
        public let result: Sharing.ListFileMembersIndividualResult
        public init(file: String, result: Sharing.ListFileMembersIndividualResult) {
            stringValidator(minLength: 1, pattern: "((/|id:).*|nspath:[^:]*:[^:]*)")(file)
            self.file = file
            self.result = result
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListFileMembersBatchResultSerializer().serialize(self)))"
        }
    }
    public class ListFileMembersBatchResultSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: ListFileMembersBatchResult) -> JSON {
            let output = [ 
            "file": Serialization._StringSerializer.serialize(value.file),
            "result": Sharing.ListFileMembersIndividualResultSerializer().serialize(value.result),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> ListFileMembersBatchResult {
            switch json {
                case .Dictionary(let dict):
                    let file = Serialization._StringSerializer.deserialize(dict["file"] ?? .Null)
                    let result = Sharing.ListFileMembersIndividualResultSerializer().deserialize(dict["result"] ?? .Null)
                    return ListFileMembersBatchResult(file: file, result: result)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Arguments for listFileMembersContinue.
    public class ListFileMembersContinueArg: CustomStringConvertible {
        /// The cursor returned by your last call to listFileMembers, listFileMembersContinue, or listFileMembersBatch.
        public let cursor: String
        public init(cursor: String) {
            stringValidator()(cursor)
            self.cursor = cursor
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListFileMembersContinueArgSerializer().serialize(self)))"
        }
    }
    public class ListFileMembersContinueArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: ListFileMembersContinueArg) -> JSON {
            let output = [ 
            "cursor": Serialization._StringSerializer.serialize(value.cursor),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> ListFileMembersContinueArg {
            switch json {
                case .Dictionary(let dict):
                    let cursor = Serialization._StringSerializer.deserialize(dict["cursor"] ?? .Null)
                    return ListFileMembersContinueArg(cursor: cursor)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Error for listFileMembersContinue.
    public enum ListFileMembersContinueError: CustomStringConvertible {
        /// (undocumented)
        case UserError(Sharing.SharingUserError)
        /// (undocumented)
        case AccessError(Sharing.SharingFileAccessError)
        /// cursor in ListFileMembersContinueArg is invalid.
        case InvalidCursor
        /// (undocumented)
        case Other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListFileMembersContinueErrorSerializer().serialize(self)))"
        }
    }
    public class ListFileMembersContinueErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: ListFileMembersContinueError) -> JSON {
            switch value {
                case .UserError(let arg):
                    var d = ["user_error": Sharing.SharingUserErrorSerializer().serialize(arg)]
                    d[".tag"] = .Str("user_error")
                    return .Dictionary(d)
                case .AccessError(let arg):
                    var d = ["access_error": Sharing.SharingFileAccessErrorSerializer().serialize(arg)]
                    d[".tag"] = .Str("access_error")
                    return .Dictionary(d)
                case .InvalidCursor:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("invalid_cursor")
                    return .Dictionary(d)
                case .Other:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> ListFileMembersContinueError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "user_error":
                            let v = Sharing.SharingUserErrorSerializer().deserialize(d["user_error"] ?? .Null)
                            return ListFileMembersContinueError.UserError(v)
                        case "access_error":
                            let v = Sharing.SharingFileAccessErrorSerializer().deserialize(d["access_error"] ?? .Null)
                            return ListFileMembersContinueError.AccessError(v)
                        case "invalid_cursor":
                            return ListFileMembersContinueError.InvalidCursor
                        case "other":
                            return ListFileMembersContinueError.Other
                        default:
                            return ListFileMembersContinueError.Other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The ListFileMembersCountResult struct
    public class ListFileMembersCountResult: CustomStringConvertible {
        /// A list of members on this file.
        public let members: Sharing.SharedFileMembers
        /// The number of members on this file. This does not include inherited members
        public let memberCount: UInt32
        public init(members: Sharing.SharedFileMembers, memberCount: UInt32) {
            self.members = members
            comparableValidator()(memberCount)
            self.memberCount = memberCount
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListFileMembersCountResultSerializer().serialize(self)))"
        }
    }
    public class ListFileMembersCountResultSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: ListFileMembersCountResult) -> JSON {
            let output = [ 
            "members": Sharing.SharedFileMembersSerializer().serialize(value.members),
            "member_count": Serialization._UInt32Serializer.serialize(value.memberCount),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> ListFileMembersCountResult {
            switch json {
                case .Dictionary(let dict):
                    let members = Sharing.SharedFileMembersSerializer().deserialize(dict["members"] ?? .Null)
                    let memberCount = Serialization._UInt32Serializer.deserialize(dict["member_count"] ?? .Null)
                    return ListFileMembersCountResult(members: members, memberCount: memberCount)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Error for listFileMembers.
    public enum ListFileMembersError: CustomStringConvertible {
        /// (undocumented)
        case UserError(Sharing.SharingUserError)
        /// (undocumented)
        case AccessError(Sharing.SharingFileAccessError)
        /// (undocumented)
        case Other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListFileMembersErrorSerializer().serialize(self)))"
        }
    }
    public class ListFileMembersErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: ListFileMembersError) -> JSON {
            switch value {
                case .UserError(let arg):
                    var d = ["user_error": Sharing.SharingUserErrorSerializer().serialize(arg)]
                    d[".tag"] = .Str("user_error")
                    return .Dictionary(d)
                case .AccessError(let arg):
                    var d = ["access_error": Sharing.SharingFileAccessErrorSerializer().serialize(arg)]
                    d[".tag"] = .Str("access_error")
                    return .Dictionary(d)
                case .Other:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> ListFileMembersError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "user_error":
                            let v = Sharing.SharingUserErrorSerializer().deserialize(d["user_error"] ?? .Null)
                            return ListFileMembersError.UserError(v)
                        case "access_error":
                            let v = Sharing.SharingFileAccessErrorSerializer().deserialize(d["access_error"] ?? .Null)
                            return ListFileMembersError.AccessError(v)
                        case "other":
                            return ListFileMembersError.Other
                        default:
                            return ListFileMembersError.Other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The ListFileMembersIndividualResult union
    public enum ListFileMembersIndividualResult: CustomStringConvertible {
        /// The results of the query for this file if it was successful
        case Result(Sharing.ListFileMembersCountResult)
        /// The result of the query for this file if it was an error.
        case AccessError(Sharing.SharingFileAccessError)
        /// (undocumented)
        case Other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListFileMembersIndividualResultSerializer().serialize(self)))"
        }
    }
    public class ListFileMembersIndividualResultSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: ListFileMembersIndividualResult) -> JSON {
            switch value {
                case .Result(let arg):
                    var d = Serialization.getFields(Sharing.ListFileMembersCountResultSerializer().serialize(arg))
                    d[".tag"] = .Str("result")
                    return .Dictionary(d)
                case .AccessError(let arg):
                    var d = ["access_error": Sharing.SharingFileAccessErrorSerializer().serialize(arg)]
                    d[".tag"] = .Str("access_error")
                    return .Dictionary(d)
                case .Other:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> ListFileMembersIndividualResult {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "result":
                            let v = Sharing.ListFileMembersCountResultSerializer().deserialize(json)
                            return ListFileMembersIndividualResult.Result(v)
                        case "access_error":
                            let v = Sharing.SharingFileAccessErrorSerializer().deserialize(d["access_error"] ?? .Null)
                            return ListFileMembersIndividualResult.AccessError(v)
                        case "other":
                            return ListFileMembersIndividualResult.Other
                        default:
                            return ListFileMembersIndividualResult.Other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Arguments for listReceivedFiles.
    public class ListFilesArg: CustomStringConvertible {
        /// Number of files to return max per query. Defaults to 100 if no limit is specified.
        public let limit: UInt32
        /// File actions to query.
        public let actions: Array<Sharing.FileAction>?
        public init(limit: UInt32 = 100, actions: Array<Sharing.FileAction>? = nil) {
            comparableValidator(minValue: 1, maxValue: 300)(limit)
            self.limit = limit
            self.actions = actions
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListFilesArgSerializer().serialize(self)))"
        }
    }
    public class ListFilesArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: ListFilesArg) -> JSON {
            let output = [ 
            "limit": Serialization._UInt32Serializer.serialize(value.limit),
            "actions": NullableSerializer(ArraySerializer(Sharing.FileActionSerializer())).serialize(value.actions),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> ListFilesArg {
            switch json {
                case .Dictionary(let dict):
                    let limit = Serialization._UInt32Serializer.deserialize(dict["limit"] ?? .Null)
                    let actions = NullableSerializer(ArraySerializer(Sharing.FileActionSerializer())).deserialize(dict["actions"] ?? .Null)
                    return ListFilesArg(limit: limit, actions: actions)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Arguments for listReceivedFilesContinue.
    public class ListFilesContinueArg: CustomStringConvertible {
        /// Cursor in cursor in ListFilesResult
        public let cursor: String
        public init(cursor: String) {
            stringValidator()(cursor)
            self.cursor = cursor
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListFilesContinueArgSerializer().serialize(self)))"
        }
    }
    public class ListFilesContinueArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: ListFilesContinueArg) -> JSON {
            let output = [ 
            "cursor": Serialization._StringSerializer.serialize(value.cursor),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> ListFilesContinueArg {
            switch json {
                case .Dictionary(let dict):
                    let cursor = Serialization._StringSerializer.deserialize(dict["cursor"] ?? .Null)
                    return ListFilesContinueArg(cursor: cursor)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Error results for listReceivedFilesContinue.
    public enum ListFilesContinueError: CustomStringConvertible {
        /// User account had a problem.
        case UserError(Sharing.SharingUserError)
        /// cursor in ListFilesContinueArg is invalid.
        case InvalidCursor
        /// (undocumented)
        case Other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListFilesContinueErrorSerializer().serialize(self)))"
        }
    }
    public class ListFilesContinueErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: ListFilesContinueError) -> JSON {
            switch value {
                case .UserError(let arg):
                    var d = ["user_error": Sharing.SharingUserErrorSerializer().serialize(arg)]
                    d[".tag"] = .Str("user_error")
                    return .Dictionary(d)
                case .InvalidCursor:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("invalid_cursor")
                    return .Dictionary(d)
                case .Other:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> ListFilesContinueError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "user_error":
                            let v = Sharing.SharingUserErrorSerializer().deserialize(d["user_error"] ?? .Null)
                            return ListFilesContinueError.UserError(v)
                        case "invalid_cursor":
                            return ListFilesContinueError.InvalidCursor
                        case "other":
                            return ListFilesContinueError.Other
                        default:
                            return ListFilesContinueError.Other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Success results for listReceivedFiles.
    public class ListFilesResult: CustomStringConvertible {
        /// Information about the files shared with current user.
        public let entries: Array<Sharing.SharedFileMetadata>
        /// Cursor used to obtain additional shared files.
        public let cursor: String?
        public init(entries: Array<Sharing.SharedFileMetadata>, cursor: String? = nil) {
            self.entries = entries
            nullableValidator(stringValidator())(cursor)
            self.cursor = cursor
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListFilesResultSerializer().serialize(self)))"
        }
    }
    public class ListFilesResultSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: ListFilesResult) -> JSON {
            let output = [ 
            "entries": ArraySerializer(Sharing.SharedFileMetadataSerializer()).serialize(value.entries),
            "cursor": NullableSerializer(Serialization._StringSerializer).serialize(value.cursor),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> ListFilesResult {
            switch json {
                case .Dictionary(let dict):
                    let entries = ArraySerializer(Sharing.SharedFileMetadataSerializer()).deserialize(dict["entries"] ?? .Null)
                    let cursor = NullableSerializer(Serialization._StringSerializer).deserialize(dict["cursor"] ?? .Null)
                    return ListFilesResult(entries: entries, cursor: cursor)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The ListFolderMembersCursorArg struct
    public class ListFolderMembersCursorArg: CustomStringConvertible {
        /// This is a list indicating whether each returned member will include a boolean value allow in
        /// MemberPermission that describes whether the current user can perform the MemberAction on the member.
        public let actions: Array<Sharing.MemberAction>?
        /// The maximum number of results that include members, groups and invitees to return per request.
        public let limit: UInt32
        public init(actions: Array<Sharing.MemberAction>? = nil, limit: UInt32 = 1000) {
            self.actions = actions
            comparableValidator(minValue: 1, maxValue: 1000)(limit)
            self.limit = limit
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListFolderMembersCursorArgSerializer().serialize(self)))"
        }
    }
    public class ListFolderMembersCursorArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: ListFolderMembersCursorArg) -> JSON {
            let output = [ 
            "actions": NullableSerializer(ArraySerializer(Sharing.MemberActionSerializer())).serialize(value.actions),
            "limit": Serialization._UInt32Serializer.serialize(value.limit),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> ListFolderMembersCursorArg {
            switch json {
                case .Dictionary(let dict):
                    let actions = NullableSerializer(ArraySerializer(Sharing.MemberActionSerializer())).deserialize(dict["actions"] ?? .Null)
                    let limit = Serialization._UInt32Serializer.deserialize(dict["limit"] ?? .Null)
                    return ListFolderMembersCursorArg(actions: actions, limit: limit)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The ListFolderMembersArgs struct
    public class ListFolderMembersArgs: Sharing.ListFolderMembersCursorArg {
        /// The ID for the shared folder.
        public let sharedFolderId: String
        public init(sharedFolderId: String, actions: Array<Sharing.MemberAction>? = nil, limit: UInt32 = 1000) {
            stringValidator(pattern: "[-_0-9a-zA-Z:]+")(sharedFolderId)
            self.sharedFolderId = sharedFolderId
            super.init(actions: actions, limit: limit)
        }
        public override var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListFolderMembersArgsSerializer().serialize(self)))"
        }
    }
    public class ListFolderMembersArgsSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: ListFolderMembersArgs) -> JSON {
            let output = [ 
            "shared_folder_id": Serialization._StringSerializer.serialize(value.sharedFolderId),
            "actions": NullableSerializer(ArraySerializer(Sharing.MemberActionSerializer())).serialize(value.actions),
            "limit": Serialization._UInt32Serializer.serialize(value.limit),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> ListFolderMembersArgs {
            switch json {
                case .Dictionary(let dict):
                    let sharedFolderId = Serialization._StringSerializer.deserialize(dict["shared_folder_id"] ?? .Null)
                    let actions = NullableSerializer(ArraySerializer(Sharing.MemberActionSerializer())).deserialize(dict["actions"] ?? .Null)
                    let limit = Serialization._UInt32Serializer.deserialize(dict["limit"] ?? .Null)
                    return ListFolderMembersArgs(sharedFolderId: sharedFolderId, actions: actions, limit: limit)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The ListFolderMembersContinueArg struct
    public class ListFolderMembersContinueArg: CustomStringConvertible {
        /// The cursor returned by your last call to listFolderMembers or listFolderMembersContinue.
        public let cursor: String
        public init(cursor: String) {
            stringValidator()(cursor)
            self.cursor = cursor
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListFolderMembersContinueArgSerializer().serialize(self)))"
        }
    }
    public class ListFolderMembersContinueArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: ListFolderMembersContinueArg) -> JSON {
            let output = [ 
            "cursor": Serialization._StringSerializer.serialize(value.cursor),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> ListFolderMembersContinueArg {
            switch json {
                case .Dictionary(let dict):
                    let cursor = Serialization._StringSerializer.deserialize(dict["cursor"] ?? .Null)
                    return ListFolderMembersContinueArg(cursor: cursor)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The ListFolderMembersContinueError union
    public enum ListFolderMembersContinueError: CustomStringConvertible {
        /// (undocumented)
        case AccessError(Sharing.SharedFolderAccessError)
        /// cursor in ListFolderMembersContinueArg is invalid.
        case InvalidCursor
        /// (undocumented)
        case Other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListFolderMembersContinueErrorSerializer().serialize(self)))"
        }
    }
    public class ListFolderMembersContinueErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: ListFolderMembersContinueError) -> JSON {
            switch value {
                case .AccessError(let arg):
                    var d = ["access_error": Sharing.SharedFolderAccessErrorSerializer().serialize(arg)]
                    d[".tag"] = .Str("access_error")
                    return .Dictionary(d)
                case .InvalidCursor:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("invalid_cursor")
                    return .Dictionary(d)
                case .Other:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> ListFolderMembersContinueError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "access_error":
                            let v = Sharing.SharedFolderAccessErrorSerializer().deserialize(d["access_error"] ?? .Null)
                            return ListFolderMembersContinueError.AccessError(v)
                        case "invalid_cursor":
                            return ListFolderMembersContinueError.InvalidCursor
                        case "other":
                            return ListFolderMembersContinueError.Other
                        default:
                            return ListFolderMembersContinueError.Other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The ListFoldersArgs struct
    public class ListFoldersArgs: CustomStringConvertible {
        /// The maximum number of results to return per request.
        public let limit: UInt32
        /// This is a list indicating whether each returned folder data entry will include a boolean field allow in
        /// FolderPermission that describes whether the current user can perform the `FolderAction` on the folder.
        public let actions: Array<Sharing.FolderAction>?
        public init(limit: UInt32 = 1000, actions: Array<Sharing.FolderAction>? = nil) {
            comparableValidator(minValue: 1, maxValue: 1000)(limit)
            self.limit = limit
            self.actions = actions
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListFoldersArgsSerializer().serialize(self)))"
        }
    }
    public class ListFoldersArgsSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: ListFoldersArgs) -> JSON {
            let output = [ 
            "limit": Serialization._UInt32Serializer.serialize(value.limit),
            "actions": NullableSerializer(ArraySerializer(Sharing.FolderActionSerializer())).serialize(value.actions),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> ListFoldersArgs {
            switch json {
                case .Dictionary(let dict):
                    let limit = Serialization._UInt32Serializer.deserialize(dict["limit"] ?? .Null)
                    let actions = NullableSerializer(ArraySerializer(Sharing.FolderActionSerializer())).deserialize(dict["actions"] ?? .Null)
                    return ListFoldersArgs(limit: limit, actions: actions)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The ListFoldersContinueArg struct
    public class ListFoldersContinueArg: CustomStringConvertible {
        /// The cursor returned by the previous API call specified in the endpoint description.
        public let cursor: String
        public init(cursor: String) {
            stringValidator()(cursor)
            self.cursor = cursor
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListFoldersContinueArgSerializer().serialize(self)))"
        }
    }
    public class ListFoldersContinueArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: ListFoldersContinueArg) -> JSON {
            let output = [ 
            "cursor": Serialization._StringSerializer.serialize(value.cursor),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> ListFoldersContinueArg {
            switch json {
                case .Dictionary(let dict):
                    let cursor = Serialization._StringSerializer.deserialize(dict["cursor"] ?? .Null)
                    return ListFoldersContinueArg(cursor: cursor)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The ListFoldersContinueError union
    public enum ListFoldersContinueError: CustomStringConvertible {
        /// cursor in ListFoldersContinueArg is invalid.
        case InvalidCursor
        /// (undocumented)
        case Other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListFoldersContinueErrorSerializer().serialize(self)))"
        }
    }
    public class ListFoldersContinueErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: ListFoldersContinueError) -> JSON {
            switch value {
                case .InvalidCursor:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("invalid_cursor")
                    return .Dictionary(d)
                case .Other:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> ListFoldersContinueError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "invalid_cursor":
                            return ListFoldersContinueError.InvalidCursor
                        case "other":
                            return ListFoldersContinueError.Other
                        default:
                            return ListFoldersContinueError.Other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Result for listFolders or listMountableFolders, depending on which endpoint was requested. Unmounted shared
    /// folders can be identified by the absence of pathLower in SharedFolderMetadata.
    public class ListFoldersResult: CustomStringConvertible {
        /// List of all shared folders the authenticated user has access to.
        public let entries: Array<Sharing.SharedFolderMetadata>
        /// Present if there are additional shared folders that have not been returned yet. Pass the cursor into the
        /// corresponding continue endpoint (either listFoldersContinue or listMountableFoldersContinue) to list
        /// additional folders.
        public let cursor: String?
        public init(entries: Array<Sharing.SharedFolderMetadata>, cursor: String? = nil) {
            self.entries = entries
            nullableValidator(stringValidator())(cursor)
            self.cursor = cursor
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListFoldersResultSerializer().serialize(self)))"
        }
    }
    public class ListFoldersResultSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: ListFoldersResult) -> JSON {
            let output = [ 
            "entries": ArraySerializer(Sharing.SharedFolderMetadataSerializer()).serialize(value.entries),
            "cursor": NullableSerializer(Serialization._StringSerializer).serialize(value.cursor),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> ListFoldersResult {
            switch json {
                case .Dictionary(let dict):
                    let entries = ArraySerializer(Sharing.SharedFolderMetadataSerializer()).deserialize(dict["entries"] ?? .Null)
                    let cursor = NullableSerializer(Serialization._StringSerializer).deserialize(dict["cursor"] ?? .Null)
                    return ListFoldersResult(entries: entries, cursor: cursor)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The ListSharedLinksArg struct
    public class ListSharedLinksArg: CustomStringConvertible {
        /// See listSharedLinks description.
        public let path: String?
        /// The cursor returned by your last call to listSharedLinks.
        public let cursor: String?
        /// See listSharedLinks description.
        public let directOnly: Bool?
        public init(path: String? = nil, cursor: String? = nil, directOnly: Bool? = nil) {
            nullableValidator(stringValidator(pattern: "(/(.|[\\r\\n])*|id:.*)|(rev:[0-9a-f]{9,})|(ns:[0-9]+(/.*)?)"))(path)
            self.path = path
            nullableValidator(stringValidator())(cursor)
            self.cursor = cursor
            self.directOnly = directOnly
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListSharedLinksArgSerializer().serialize(self)))"
        }
    }
    public class ListSharedLinksArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: ListSharedLinksArg) -> JSON {
            let output = [ 
            "path": NullableSerializer(Serialization._StringSerializer).serialize(value.path),
            "cursor": NullableSerializer(Serialization._StringSerializer).serialize(value.cursor),
            "direct_only": NullableSerializer(Serialization._BoolSerializer).serialize(value.directOnly),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> ListSharedLinksArg {
            switch json {
                case .Dictionary(let dict):
                    let path = NullableSerializer(Serialization._StringSerializer).deserialize(dict["path"] ?? .Null)
                    let cursor = NullableSerializer(Serialization._StringSerializer).deserialize(dict["cursor"] ?? .Null)
                    let directOnly = NullableSerializer(Serialization._BoolSerializer).deserialize(dict["direct_only"] ?? .Null)
                    return ListSharedLinksArg(path: path, cursor: cursor, directOnly: directOnly)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The ListSharedLinksError union
    public enum ListSharedLinksError: CustomStringConvertible {
        /// (undocumented)
        case Path(Files.LookupError)
        /// Indicates that the cursor has been invalidated. Call listSharedLinks to obtain a new cursor.
        case Reset
        /// (undocumented)
        case Other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListSharedLinksErrorSerializer().serialize(self)))"
        }
    }
    public class ListSharedLinksErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: ListSharedLinksError) -> JSON {
            switch value {
                case .Path(let arg):
                    var d = ["path": Files.LookupErrorSerializer().serialize(arg)]
                    d[".tag"] = .Str("path")
                    return .Dictionary(d)
                case .Reset:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("reset")
                    return .Dictionary(d)
                case .Other:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> ListSharedLinksError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "path":
                            let v = Files.LookupErrorSerializer().deserialize(d["path"] ?? .Null)
                            return ListSharedLinksError.Path(v)
                        case "reset":
                            return ListSharedLinksError.Reset
                        case "other":
                            return ListSharedLinksError.Other
                        default:
                            return ListSharedLinksError.Other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The ListSharedLinksResult struct
    public class ListSharedLinksResult: CustomStringConvertible {
        /// Shared links applicable to the path argument.
        public let links: Array<Sharing.SharedLinkMetadata>
        /// Is true if there are additional shared links that have not been returned yet. Pass the cursor into
        /// listSharedLinks to retrieve them.
        public let hasMore: Bool
        /// Pass the cursor into listSharedLinks to obtain the additional links. Cursor is returned only if no path is
        /// given or the path is empty.
        public let cursor: String?
        public init(links: Array<Sharing.SharedLinkMetadata>, hasMore: Bool, cursor: String? = nil) {
            self.links = links
            self.hasMore = hasMore
            nullableValidator(stringValidator())(cursor)
            self.cursor = cursor
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListSharedLinksResultSerializer().serialize(self)))"
        }
    }
    public class ListSharedLinksResultSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: ListSharedLinksResult) -> JSON {
            let output = [ 
            "links": ArraySerializer(Sharing.SharedLinkMetadataSerializer()).serialize(value.links),
            "has_more": Serialization._BoolSerializer.serialize(value.hasMore),
            "cursor": NullableSerializer(Serialization._StringSerializer).serialize(value.cursor),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> ListSharedLinksResult {
            switch json {
                case .Dictionary(let dict):
                    let links = ArraySerializer(Sharing.SharedLinkMetadataSerializer()).deserialize(dict["links"] ?? .Null)
                    let hasMore = Serialization._BoolSerializer.deserialize(dict["has_more"] ?? .Null)
                    let cursor = NullableSerializer(Serialization._StringSerializer).deserialize(dict["cursor"] ?? .Null)
                    return ListSharedLinksResult(links: links, hasMore: hasMore, cursor: cursor)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Contains information about a member's access level to content after an operation.
    public class MemberAccessLevelResult: CustomStringConvertible {
        /// The member still has this level of access to the content through a parent folder.
        public let accessLevel: Sharing.AccessLevel?
        /// A localized string with additional information about why the user has this access level to the content.
        public let warning: String?
        public init(accessLevel: Sharing.AccessLevel? = nil, warning: String? = nil) {
            self.accessLevel = accessLevel
            nullableValidator(stringValidator())(warning)
            self.warning = warning
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MemberAccessLevelResultSerializer().serialize(self)))"
        }
    }
    public class MemberAccessLevelResultSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: MemberAccessLevelResult) -> JSON {
            let output = [ 
            "access_level": NullableSerializer(Sharing.AccessLevelSerializer()).serialize(value.accessLevel),
            "warning": NullableSerializer(Serialization._StringSerializer).serialize(value.warning),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> MemberAccessLevelResult {
            switch json {
                case .Dictionary(let dict):
                    let accessLevel = NullableSerializer(Sharing.AccessLevelSerializer()).deserialize(dict["access_level"] ?? .Null)
                    let warning = NullableSerializer(Serialization._StringSerializer).deserialize(dict["warning"] ?? .Null)
                    return MemberAccessLevelResult(accessLevel: accessLevel, warning: warning)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Actions that may be taken on members of a shared folder.
    public enum MemberAction: CustomStringConvertible {
        /// Allow the member to keep a copy of the folder when removing.
        case LeaveACopy
        /// Make the member an editor of the folder.
        case MakeEditor
        /// Make the member an owner of the folder.
        case MakeOwner
        /// Make the member a viewer of the folder.
        case MakeViewer
        /// Remove the member from the folder.
        case Remove
        /// (undocumented)
        case Other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MemberActionSerializer().serialize(self)))"
        }
    }
    public class MemberActionSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: MemberAction) -> JSON {
            switch value {
                case .LeaveACopy:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("leave_a_copy")
                    return .Dictionary(d)
                case .MakeEditor:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("make_editor")
                    return .Dictionary(d)
                case .MakeOwner:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("make_owner")
                    return .Dictionary(d)
                case .MakeViewer:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("make_viewer")
                    return .Dictionary(d)
                case .Remove:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("remove")
                    return .Dictionary(d)
                case .Other:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> MemberAction {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "leave_a_copy":
                            return MemberAction.LeaveACopy
                        case "make_editor":
                            return MemberAction.MakeEditor
                        case "make_owner":
                            return MemberAction.MakeOwner
                        case "make_viewer":
                            return MemberAction.MakeViewer
                        case "remove":
                            return MemberAction.Remove
                        case "other":
                            return MemberAction.Other
                        default:
                            return MemberAction.Other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Whether the user is allowed to take the action on the associated member.
    public class MemberPermission: CustomStringConvertible {
        /// The action that the user may wish to take on the member.
        public let action: Sharing.MemberAction
        /// True if the user is allowed to take the action.
        public let allow: Bool
        /// The reason why the user is denied the permission. Not present if the action is allowed
        public let reason: Sharing.PermissionDeniedReason?
        public init(action: Sharing.MemberAction, allow: Bool, reason: Sharing.PermissionDeniedReason? = nil) {
            self.action = action
            self.allow = allow
            self.reason = reason
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MemberPermissionSerializer().serialize(self)))"
        }
    }
    public class MemberPermissionSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: MemberPermission) -> JSON {
            let output = [ 
            "action": Sharing.MemberActionSerializer().serialize(value.action),
            "allow": Serialization._BoolSerializer.serialize(value.allow),
            "reason": NullableSerializer(Sharing.PermissionDeniedReasonSerializer()).serialize(value.reason),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> MemberPermission {
            switch json {
                case .Dictionary(let dict):
                    let action = Sharing.MemberActionSerializer().deserialize(dict["action"] ?? .Null)
                    let allow = Serialization._BoolSerializer.deserialize(dict["allow"] ?? .Null)
                    let reason = NullableSerializer(Sharing.PermissionDeniedReasonSerializer()).deserialize(dict["reason"] ?? .Null)
                    return MemberPermission(action: action, allow: allow, reason: reason)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Policy governing who can be a member of a shared folder. Only applicable to folders owned by a user on a team.
    public enum MemberPolicy: CustomStringConvertible {
        /// Only a teammate can become a member.
        case Team
        /// Anyone can become a member.
        case Anyone
        /// (undocumented)
        case Other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MemberPolicySerializer().serialize(self)))"
        }
    }
    public class MemberPolicySerializer: JSONSerializer {
        public init() { }
        public func serialize(value: MemberPolicy) -> JSON {
            switch value {
                case .Team:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("team")
                    return .Dictionary(d)
                case .Anyone:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("anyone")
                    return .Dictionary(d)
                case .Other:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> MemberPolicy {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "team":
                            return MemberPolicy.Team
                        case "anyone":
                            return MemberPolicy.Anyone
                        case "other":
                            return MemberPolicy.Other
                        default:
                            return MemberPolicy.Other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Includes different ways to identify a member of a shared folder.
    public enum MemberSelector: CustomStringConvertible {
        /// Dropbox account, team member, or group ID of member.
        case DropboxId(String)
        /// E-mail address of member.
        case Email(String)
        /// (undocumented)
        case Other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MemberSelectorSerializer().serialize(self)))"
        }
    }
    public class MemberSelectorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: MemberSelector) -> JSON {
            switch value {
                case .DropboxId(let arg):
                    var d = ["dropbox_id": Serialization._StringSerializer.serialize(arg)]
                    d[".tag"] = .Str("dropbox_id")
                    return .Dictionary(d)
                case .Email(let arg):
                    var d = ["email": Serialization._StringSerializer.serialize(arg)]
                    d[".tag"] = .Str("email")
                    return .Dictionary(d)
                case .Other:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> MemberSelector {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "dropbox_id":
                            let v = Serialization._StringSerializer.deserialize(d["dropbox_id"] ?? .Null)
                            return MemberSelector.DropboxId(v)
                        case "email":
                            let v = Serialization._StringSerializer.deserialize(d["email"] ?? .Null)
                            return MemberSelector.Email(v)
                        case "other":
                            return MemberSelector.Other
                        default:
                            return MemberSelector.Other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The ModifySharedLinkSettingsArgs struct
    public class ModifySharedLinkSettingsArgs: CustomStringConvertible {
        /// URL of the shared link to change its settings
        public let url: String
        /// Set of settings for the shared link.
        public let settings: Sharing.SharedLinkSettings
        /// If set to true, removes the expiration of the shared link.
        public let removeExpiration: Bool
        public init(url: String, settings: Sharing.SharedLinkSettings, removeExpiration: Bool = false) {
            stringValidator()(url)
            self.url = url
            self.settings = settings
            self.removeExpiration = removeExpiration
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ModifySharedLinkSettingsArgsSerializer().serialize(self)))"
        }
    }
    public class ModifySharedLinkSettingsArgsSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: ModifySharedLinkSettingsArgs) -> JSON {
            let output = [ 
            "url": Serialization._StringSerializer.serialize(value.url),
            "settings": Sharing.SharedLinkSettingsSerializer().serialize(value.settings),
            "remove_expiration": Serialization._BoolSerializer.serialize(value.removeExpiration),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> ModifySharedLinkSettingsArgs {
            switch json {
                case .Dictionary(let dict):
                    let url = Serialization._StringSerializer.deserialize(dict["url"] ?? .Null)
                    let settings = Sharing.SharedLinkSettingsSerializer().deserialize(dict["settings"] ?? .Null)
                    let removeExpiration = Serialization._BoolSerializer.deserialize(dict["remove_expiration"] ?? .Null)
                    return ModifySharedLinkSettingsArgs(url: url, settings: settings, removeExpiration: removeExpiration)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The ModifySharedLinkSettingsError union
    public enum ModifySharedLinkSettingsError: CustomStringConvertible {
        /// The shared link wasn't found
        case SharedLinkNotFound
        /// The caller is not allowed to access this shared link
        case SharedLinkAccessDenied
        /// An unspecified error
        case Other
        /// There is an error with the given settings
        case SettingsError(Sharing.SharedLinkSettingsError)
        /// The caller's email should be verified
        case EmailNotVerified

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ModifySharedLinkSettingsErrorSerializer().serialize(self)))"
        }
    }
    public class ModifySharedLinkSettingsErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: ModifySharedLinkSettingsError) -> JSON {
            switch value {
                case .SharedLinkNotFound:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("shared_link_not_found")
                    return .Dictionary(d)
                case .SharedLinkAccessDenied:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("shared_link_access_denied")
                    return .Dictionary(d)
                case .Other:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
                case .SettingsError(let arg):
                    var d = ["settings_error": Sharing.SharedLinkSettingsErrorSerializer().serialize(arg)]
                    d[".tag"] = .Str("settings_error")
                    return .Dictionary(d)
                case .EmailNotVerified:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("email_not_verified")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> ModifySharedLinkSettingsError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "shared_link_not_found":
                            return ModifySharedLinkSettingsError.SharedLinkNotFound
                        case "shared_link_access_denied":
                            return ModifySharedLinkSettingsError.SharedLinkAccessDenied
                        case "other":
                            return ModifySharedLinkSettingsError.Other
                        case "settings_error":
                            let v = Sharing.SharedLinkSettingsErrorSerializer().deserialize(d["settings_error"] ?? .Null)
                            return ModifySharedLinkSettingsError.SettingsError(v)
                        case "email_not_verified":
                            return ModifySharedLinkSettingsError.EmailNotVerified
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The MountFolderArg struct
    public class MountFolderArg: CustomStringConvertible {
        /// The ID of the shared folder to mount.
        public let sharedFolderId: String
        public init(sharedFolderId: String) {
            stringValidator(pattern: "[-_0-9a-zA-Z:]+")(sharedFolderId)
            self.sharedFolderId = sharedFolderId
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MountFolderArgSerializer().serialize(self)))"
        }
    }
    public class MountFolderArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: MountFolderArg) -> JSON {
            let output = [ 
            "shared_folder_id": Serialization._StringSerializer.serialize(value.sharedFolderId),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> MountFolderArg {
            switch json {
                case .Dictionary(let dict):
                    let sharedFolderId = Serialization._StringSerializer.deserialize(dict["shared_folder_id"] ?? .Null)
                    return MountFolderArg(sharedFolderId: sharedFolderId)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The MountFolderError union
    public enum MountFolderError: CustomStringConvertible {
        /// (undocumented)
        case AccessError(Sharing.SharedFolderAccessError)
        /// Mounting would cause a shared folder to be inside another, which is disallowed.
        case InsideSharedFolder
        /// The current user does not have enough space to mount the shared folder.
        case InsufficientQuota
        /// The shared folder is already mounted.
        case AlreadyMounted
        /// The current user does not have permission to perform this action.
        case NoPermission
        /// The shared folder is not mountable. One example where this can occur is when the shared folder belongs
        /// within a team folder in the user's Dropbox.
        case NotMountable
        /// (undocumented)
        case Other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MountFolderErrorSerializer().serialize(self)))"
        }
    }
    public class MountFolderErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: MountFolderError) -> JSON {
            switch value {
                case .AccessError(let arg):
                    var d = ["access_error": Sharing.SharedFolderAccessErrorSerializer().serialize(arg)]
                    d[".tag"] = .Str("access_error")
                    return .Dictionary(d)
                case .InsideSharedFolder:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("inside_shared_folder")
                    return .Dictionary(d)
                case .InsufficientQuota:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("insufficient_quota")
                    return .Dictionary(d)
                case .AlreadyMounted:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("already_mounted")
                    return .Dictionary(d)
                case .NoPermission:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("no_permission")
                    return .Dictionary(d)
                case .NotMountable:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("not_mountable")
                    return .Dictionary(d)
                case .Other:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> MountFolderError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "access_error":
                            let v = Sharing.SharedFolderAccessErrorSerializer().deserialize(d["access_error"] ?? .Null)
                            return MountFolderError.AccessError(v)
                        case "inside_shared_folder":
                            return MountFolderError.InsideSharedFolder
                        case "insufficient_quota":
                            return MountFolderError.InsufficientQuota
                        case "already_mounted":
                            return MountFolderError.AlreadyMounted
                        case "no_permission":
                            return MountFolderError.NoPermission
                        case "not_mountable":
                            return MountFolderError.NotMountable
                        case "other":
                            return MountFolderError.Other
                        default:
                            return MountFolderError.Other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Metadata for a path-based shared link.
    public class PathLinkMetadata: Sharing.LinkMetadata {
        /// Path in user's Dropbox.
        public let path: String
        public init(url: String, visibility: Sharing.Visibility, path: String, expires: NSDate? = nil) {
            stringValidator()(path)
            self.path = path
            super.init(url: url, visibility: visibility, expires: expires)
        }
        public override var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PathLinkMetadataSerializer().serialize(self)))"
        }
    }
    public class PathLinkMetadataSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: PathLinkMetadata) -> JSON {
            let output = [ 
            "url": Serialization._StringSerializer.serialize(value.url),
            "visibility": Sharing.VisibilitySerializer().serialize(value.visibility),
            "path": Serialization._StringSerializer.serialize(value.path),
            "expires": NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.expires),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> PathLinkMetadata {
            switch json {
                case .Dictionary(let dict):
                    let url = Serialization._StringSerializer.deserialize(dict["url"] ?? .Null)
                    let visibility = Sharing.VisibilitySerializer().deserialize(dict["visibility"] ?? .Null)
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .Null)
                    let expires = NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).deserialize(dict["expires"] ?? .Null)
                    return PathLinkMetadata(url: url, visibility: visibility, path: path, expires: expires)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Flag to indicate pending upload default (for linking to not-yet-existing paths).
    public enum PendingUploadMode: CustomStringConvertible {
        /// Assume pending uploads are files.
        case File
        /// Assume pending uploads are folders.
        case Folder

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PendingUploadModeSerializer().serialize(self)))"
        }
    }
    public class PendingUploadModeSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: PendingUploadMode) -> JSON {
            switch value {
                case .File:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("file")
                    return .Dictionary(d)
                case .Folder:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("folder")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> PendingUploadMode {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "file":
                            return PendingUploadMode.File
                        case "folder":
                            return PendingUploadMode.Folder
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Possible reasons the user is denied a permission.
    public enum PermissionDeniedReason: CustomStringConvertible {
        /// User is not on the same team as the folder owner.
        case UserNotSameTeamAsOwner
        /// User is prohibited by the owner from taking the action.
        case UserNotAllowedByOwner
        /// Target is indirectly a member of the folder, for example by being part of a group.
        case TargetIsIndirectMember
        /// Target is the owner of the folder.
        case TargetIsOwner
        /// Target is the user itself.
        case TargetIsSelf
        /// Target is not an active member of the team.
        case TargetNotActive
        /// (undocumented)
        case Other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PermissionDeniedReasonSerializer().serialize(self)))"
        }
    }
    public class PermissionDeniedReasonSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: PermissionDeniedReason) -> JSON {
            switch value {
                case .UserNotSameTeamAsOwner:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("user_not_same_team_as_owner")
                    return .Dictionary(d)
                case .UserNotAllowedByOwner:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("user_not_allowed_by_owner")
                    return .Dictionary(d)
                case .TargetIsIndirectMember:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("target_is_indirect_member")
                    return .Dictionary(d)
                case .TargetIsOwner:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("target_is_owner")
                    return .Dictionary(d)
                case .TargetIsSelf:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("target_is_self")
                    return .Dictionary(d)
                case .TargetNotActive:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("target_not_active")
                    return .Dictionary(d)
                case .Other:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> PermissionDeniedReason {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "user_not_same_team_as_owner":
                            return PermissionDeniedReason.UserNotSameTeamAsOwner
                        case "user_not_allowed_by_owner":
                            return PermissionDeniedReason.UserNotAllowedByOwner
                        case "target_is_indirect_member":
                            return PermissionDeniedReason.TargetIsIndirectMember
                        case "target_is_owner":
                            return PermissionDeniedReason.TargetIsOwner
                        case "target_is_self":
                            return PermissionDeniedReason.TargetIsSelf
                        case "target_not_active":
                            return PermissionDeniedReason.TargetNotActive
                        case "other":
                            return PermissionDeniedReason.Other
                        default:
                            return PermissionDeniedReason.Other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The RelinquishFileMembershipArg struct
    public class RelinquishFileMembershipArg: CustomStringConvertible {
        /// The path or id for the file.
        public let file: String
        public init(file: String) {
            stringValidator(minLength: 1, pattern: "((/|id:).*|nspath:[^:]*:[^:]*)")(file)
            self.file = file
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(RelinquishFileMembershipArgSerializer().serialize(self)))"
        }
    }
    public class RelinquishFileMembershipArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: RelinquishFileMembershipArg) -> JSON {
            let output = [ 
            "file": Serialization._StringSerializer.serialize(value.file),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> RelinquishFileMembershipArg {
            switch json {
                case .Dictionary(let dict):
                    let file = Serialization._StringSerializer.deserialize(dict["file"] ?? .Null)
                    return RelinquishFileMembershipArg(file: file)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The RelinquishFileMembershipError union
    public enum RelinquishFileMembershipError: CustomStringConvertible {
        /// (undocumented)
        case AccessError(Sharing.SharingFileAccessError)
        /// The current user has access to the shared file via a group.  You can't relinquish membership to a file
        /// shared via groups.
        case GroupAccess
        /// The current user does not have permission to perform this action.
        case NoPermission
        /// (undocumented)
        case Other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(RelinquishFileMembershipErrorSerializer().serialize(self)))"
        }
    }
    public class RelinquishFileMembershipErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: RelinquishFileMembershipError) -> JSON {
            switch value {
                case .AccessError(let arg):
                    var d = ["access_error": Sharing.SharingFileAccessErrorSerializer().serialize(arg)]
                    d[".tag"] = .Str("access_error")
                    return .Dictionary(d)
                case .GroupAccess:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("group_access")
                    return .Dictionary(d)
                case .NoPermission:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("no_permission")
                    return .Dictionary(d)
                case .Other:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> RelinquishFileMembershipError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "access_error":
                            let v = Sharing.SharingFileAccessErrorSerializer().deserialize(d["access_error"] ?? .Null)
                            return RelinquishFileMembershipError.AccessError(v)
                        case "group_access":
                            return RelinquishFileMembershipError.GroupAccess
                        case "no_permission":
                            return RelinquishFileMembershipError.NoPermission
                        case "other":
                            return RelinquishFileMembershipError.Other
                        default:
                            return RelinquishFileMembershipError.Other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The RelinquishFolderMembershipArg struct
    public class RelinquishFolderMembershipArg: CustomStringConvertible {
        /// The ID for the shared folder.
        public let sharedFolderId: String
        /// Keep a copy of the folder's contents upon relinquishing membership.
        public let leaveACopy: Bool
        public init(sharedFolderId: String, leaveACopy: Bool = false) {
            stringValidator(pattern: "[-_0-9a-zA-Z:]+")(sharedFolderId)
            self.sharedFolderId = sharedFolderId
            self.leaveACopy = leaveACopy
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(RelinquishFolderMembershipArgSerializer().serialize(self)))"
        }
    }
    public class RelinquishFolderMembershipArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: RelinquishFolderMembershipArg) -> JSON {
            let output = [ 
            "shared_folder_id": Serialization._StringSerializer.serialize(value.sharedFolderId),
            "leave_a_copy": Serialization._BoolSerializer.serialize(value.leaveACopy),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> RelinquishFolderMembershipArg {
            switch json {
                case .Dictionary(let dict):
                    let sharedFolderId = Serialization._StringSerializer.deserialize(dict["shared_folder_id"] ?? .Null)
                    let leaveACopy = Serialization._BoolSerializer.deserialize(dict["leave_a_copy"] ?? .Null)
                    return RelinquishFolderMembershipArg(sharedFolderId: sharedFolderId, leaveACopy: leaveACopy)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The RelinquishFolderMembershipError union
    public enum RelinquishFolderMembershipError: CustomStringConvertible {
        /// (undocumented)
        case AccessError(Sharing.SharedFolderAccessError)
        /// The current user is the owner of the shared folder. Owners cannot relinquish membership to their own
        /// folders. Try unsharing or transferring ownership first.
        case FolderOwner
        /// The shared folder is currently mounted.  Unmount the shared folder before relinquishing membership.
        case Mounted
        /// The current user has access to the shared folder via a group.  You can't relinquish membership to folders
        /// shared via groups.
        case GroupAccess
        /// This action cannot be performed on a team shared folder.
        case TeamFolder
        /// The current user does not have permission to perform this action.
        case NoPermission
        /// (undocumented)
        case Other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(RelinquishFolderMembershipErrorSerializer().serialize(self)))"
        }
    }
    public class RelinquishFolderMembershipErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: RelinquishFolderMembershipError) -> JSON {
            switch value {
                case .AccessError(let arg):
                    var d = ["access_error": Sharing.SharedFolderAccessErrorSerializer().serialize(arg)]
                    d[".tag"] = .Str("access_error")
                    return .Dictionary(d)
                case .FolderOwner:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("folder_owner")
                    return .Dictionary(d)
                case .Mounted:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("mounted")
                    return .Dictionary(d)
                case .GroupAccess:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("group_access")
                    return .Dictionary(d)
                case .TeamFolder:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("team_folder")
                    return .Dictionary(d)
                case .NoPermission:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("no_permission")
                    return .Dictionary(d)
                case .Other:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> RelinquishFolderMembershipError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "access_error":
                            let v = Sharing.SharedFolderAccessErrorSerializer().deserialize(d["access_error"] ?? .Null)
                            return RelinquishFolderMembershipError.AccessError(v)
                        case "folder_owner":
                            return RelinquishFolderMembershipError.FolderOwner
                        case "mounted":
                            return RelinquishFolderMembershipError.Mounted
                        case "group_access":
                            return RelinquishFolderMembershipError.GroupAccess
                        case "team_folder":
                            return RelinquishFolderMembershipError.TeamFolder
                        case "no_permission":
                            return RelinquishFolderMembershipError.NoPermission
                        case "other":
                            return RelinquishFolderMembershipError.Other
                        default:
                            return RelinquishFolderMembershipError.Other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Arguments for removeFileMember2.
    public class RemoveFileMemberArg: CustomStringConvertible {
        /// File from which to remove members.
        public let file: String
        /// Member to remove from this file. Note that even if an email is specified, it may result in the removal of a
        /// user (not an invitee) if the user's main account corresponds to that email address.
        public let member: Sharing.MemberSelector
        public init(file: String, member: Sharing.MemberSelector) {
            stringValidator(minLength: 1, pattern: "((/|id:).*|nspath:[^:]*:[^:]*)")(file)
            self.file = file
            self.member = member
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(RemoveFileMemberArgSerializer().serialize(self)))"
        }
    }
    public class RemoveFileMemberArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: RemoveFileMemberArg) -> JSON {
            let output = [ 
            "file": Serialization._StringSerializer.serialize(value.file),
            "member": Sharing.MemberSelectorSerializer().serialize(value.member),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> RemoveFileMemberArg {
            switch json {
                case .Dictionary(let dict):
                    let file = Serialization._StringSerializer.deserialize(dict["file"] ?? .Null)
                    let member = Sharing.MemberSelectorSerializer().deserialize(dict["member"] ?? .Null)
                    return RemoveFileMemberArg(file: file, member: member)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Errors for removeFileMember2.
    public enum RemoveFileMemberError: CustomStringConvertible {
        /// (undocumented)
        case UserError(Sharing.SharingUserError)
        /// (undocumented)
        case AccessError(Sharing.SharingFileAccessError)
        /// This member does not have explicit access to the file and therefore cannot be removed.
        case NoExplicitAccess
        /// (undocumented)
        case Other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(RemoveFileMemberErrorSerializer().serialize(self)))"
        }
    }
    public class RemoveFileMemberErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: RemoveFileMemberError) -> JSON {
            switch value {
                case .UserError(let arg):
                    var d = ["user_error": Sharing.SharingUserErrorSerializer().serialize(arg)]
                    d[".tag"] = .Str("user_error")
                    return .Dictionary(d)
                case .AccessError(let arg):
                    var d = ["access_error": Sharing.SharingFileAccessErrorSerializer().serialize(arg)]
                    d[".tag"] = .Str("access_error")
                    return .Dictionary(d)
                case .NoExplicitAccess:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("no_explicit_access")
                    return .Dictionary(d)
                case .Other:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> RemoveFileMemberError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "user_error":
                            let v = Sharing.SharingUserErrorSerializer().deserialize(d["user_error"] ?? .Null)
                            return RemoveFileMemberError.UserError(v)
                        case "access_error":
                            let v = Sharing.SharingFileAccessErrorSerializer().deserialize(d["access_error"] ?? .Null)
                            return RemoveFileMemberError.AccessError(v)
                        case "no_explicit_access":
                            return RemoveFileMemberError.NoExplicitAccess
                        case "other":
                            return RemoveFileMemberError.Other
                        default:
                            return RemoveFileMemberError.Other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The RemoveFolderMemberArg struct
    public class RemoveFolderMemberArg: CustomStringConvertible {
        /// The ID for the shared folder.
        public let sharedFolderId: String
        /// The member to remove from the folder.
        public let member: Sharing.MemberSelector
        /// If true, the removed user will keep their copy of the folder after it's unshared, assuming it was mounted.
        /// Otherwise, it will be removed from their Dropbox. Also, this must be set to false when kicking a group.
        public let leaveACopy: Bool
        public init(sharedFolderId: String, member: Sharing.MemberSelector, leaveACopy: Bool) {
            stringValidator(pattern: "[-_0-9a-zA-Z:]+")(sharedFolderId)
            self.sharedFolderId = sharedFolderId
            self.member = member
            self.leaveACopy = leaveACopy
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(RemoveFolderMemberArgSerializer().serialize(self)))"
        }
    }
    public class RemoveFolderMemberArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: RemoveFolderMemberArg) -> JSON {
            let output = [ 
            "shared_folder_id": Serialization._StringSerializer.serialize(value.sharedFolderId),
            "member": Sharing.MemberSelectorSerializer().serialize(value.member),
            "leave_a_copy": Serialization._BoolSerializer.serialize(value.leaveACopy),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> RemoveFolderMemberArg {
            switch json {
                case .Dictionary(let dict):
                    let sharedFolderId = Serialization._StringSerializer.deserialize(dict["shared_folder_id"] ?? .Null)
                    let member = Sharing.MemberSelectorSerializer().deserialize(dict["member"] ?? .Null)
                    let leaveACopy = Serialization._BoolSerializer.deserialize(dict["leave_a_copy"] ?? .Null)
                    return RemoveFolderMemberArg(sharedFolderId: sharedFolderId, member: member, leaveACopy: leaveACopy)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The RemoveFolderMemberError union
    public enum RemoveFolderMemberError: CustomStringConvertible {
        /// (undocumented)
        case AccessError(Sharing.SharedFolderAccessError)
        /// (undocumented)
        case MemberError(Sharing.SharedFolderMemberError)
        /// The target user is the owner of the shared folder. You can't remove this user until ownership has been
        /// transferred to another member.
        case FolderOwner
        /// The target user has access to the shared folder via a group.
        case GroupAccess
        /// This action cannot be performed on a team shared folder.
        case TeamFolder
        /// The current user does not have permission to perform this action.
        case NoPermission
        /// (undocumented)
        case Other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(RemoveFolderMemberErrorSerializer().serialize(self)))"
        }
    }
    public class RemoveFolderMemberErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: RemoveFolderMemberError) -> JSON {
            switch value {
                case .AccessError(let arg):
                    var d = ["access_error": Sharing.SharedFolderAccessErrorSerializer().serialize(arg)]
                    d[".tag"] = .Str("access_error")
                    return .Dictionary(d)
                case .MemberError(let arg):
                    var d = ["member_error": Sharing.SharedFolderMemberErrorSerializer().serialize(arg)]
                    d[".tag"] = .Str("member_error")
                    return .Dictionary(d)
                case .FolderOwner:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("folder_owner")
                    return .Dictionary(d)
                case .GroupAccess:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("group_access")
                    return .Dictionary(d)
                case .TeamFolder:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("team_folder")
                    return .Dictionary(d)
                case .NoPermission:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("no_permission")
                    return .Dictionary(d)
                case .Other:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> RemoveFolderMemberError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "access_error":
                            let v = Sharing.SharedFolderAccessErrorSerializer().deserialize(d["access_error"] ?? .Null)
                            return RemoveFolderMemberError.AccessError(v)
                        case "member_error":
                            let v = Sharing.SharedFolderMemberErrorSerializer().deserialize(d["member_error"] ?? .Null)
                            return RemoveFolderMemberError.MemberError(v)
                        case "folder_owner":
                            return RemoveFolderMemberError.FolderOwner
                        case "group_access":
                            return RemoveFolderMemberError.GroupAccess
                        case "team_folder":
                            return RemoveFolderMemberError.TeamFolder
                        case "no_permission":
                            return RemoveFolderMemberError.NoPermission
                        case "other":
                            return RemoveFolderMemberError.Other
                        default:
                            return RemoveFolderMemberError.Other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The RemoveMemberJobStatus union
    public enum RemoveMemberJobStatus: CustomStringConvertible {
        /// The asynchronous job is still in progress.
        case InProgress
        /// Removing the folder member has finished. The value is information about whether the member has another form
        /// of access.
        case Complete(Sharing.MemberAccessLevelResult)
        /// (undocumented)
        case Failed(Sharing.RemoveFolderMemberError)

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(RemoveMemberJobStatusSerializer().serialize(self)))"
        }
    }
    public class RemoveMemberJobStatusSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: RemoveMemberJobStatus) -> JSON {
            switch value {
                case .InProgress:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("in_progress")
                    return .Dictionary(d)
                case .Complete(let arg):
                    var d = Serialization.getFields(Sharing.MemberAccessLevelResultSerializer().serialize(arg))
                    d[".tag"] = .Str("complete")
                    return .Dictionary(d)
                case .Failed(let arg):
                    var d = ["failed": Sharing.RemoveFolderMemberErrorSerializer().serialize(arg)]
                    d[".tag"] = .Str("failed")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> RemoveMemberJobStatus {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "in_progress":
                            return RemoveMemberJobStatus.InProgress
                        case "complete":
                            let v = Sharing.MemberAccessLevelResultSerializer().deserialize(json)
                            return RemoveMemberJobStatus.Complete(v)
                        case "failed":
                            let v = Sharing.RemoveFolderMemberErrorSerializer().deserialize(d["failed"] ?? .Null)
                            return RemoveMemberJobStatus.Failed(v)
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The access permission that can be requested by the caller for the shared link. Note that the final resolved
    /// visibility of the shared link takes into account other aspects, such as team and shared folder settings. Check
    /// the ResolvedVisibility for more info on the possible resolved visibility values of shared links.
    public enum RequestedVisibility: CustomStringConvertible {
        /// Anyone who has received the link can access it. No login required.
        case Public_
        /// Only members of the same team can access the link. Login is required.
        case TeamOnly
        /// A link-specific password is required to access the link. Login is not required.
        case Password

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(RequestedVisibilitySerializer().serialize(self)))"
        }
    }
    public class RequestedVisibilitySerializer: JSONSerializer {
        public init() { }
        public func serialize(value: RequestedVisibility) -> JSON {
            switch value {
                case .Public_:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("public")
                    return .Dictionary(d)
                case .TeamOnly:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("team_only")
                    return .Dictionary(d)
                case .Password:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("password")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> RequestedVisibility {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "public":
                            return RequestedVisibility.Public_
                        case "team_only":
                            return RequestedVisibility.TeamOnly
                        case "password":
                            return RequestedVisibility.Password
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The actual access permissions values of shared links after taking into account user preferences and the team and
    /// shared folder settings. Check the RequestedVisibility for more info on the possible visibility values that can
    /// be set by the shared link's owner.
    public enum ResolvedVisibility: CustomStringConvertible {
        /// Anyone who has received the link can access it. No login required.
        case Public_
        /// Only members of the same team can access the link. Login is required.
        case TeamOnly
        /// A link-specific password is required to access the link. Login is not required.
        case Password
        /// Only members of the same team who have the link-specific password can access the link. Login is required.
        case TeamAndPassword
        /// Only members of the shared folder containing the linked file can access the link. Login is required.
        case SharedFolderOnly
        /// An unknown restriction is in place.
        case Other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ResolvedVisibilitySerializer().serialize(self)))"
        }
    }
    public class ResolvedVisibilitySerializer: JSONSerializer {
        public init() { }
        public func serialize(value: ResolvedVisibility) -> JSON {
            switch value {
                case .Public_:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("public")
                    return .Dictionary(d)
                case .TeamOnly:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("team_only")
                    return .Dictionary(d)
                case .Password:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("password")
                    return .Dictionary(d)
                case .TeamAndPassword:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("team_and_password")
                    return .Dictionary(d)
                case .SharedFolderOnly:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("shared_folder_only")
                    return .Dictionary(d)
                case .Other:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> ResolvedVisibility {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "public":
                            return ResolvedVisibility.Public_
                        case "team_only":
                            return ResolvedVisibility.TeamOnly
                        case "password":
                            return ResolvedVisibility.Password
                        case "team_and_password":
                            return ResolvedVisibility.TeamAndPassword
                        case "shared_folder_only":
                            return ResolvedVisibility.SharedFolderOnly
                        case "other":
                            return ResolvedVisibility.Other
                        default:
                            return ResolvedVisibility.Other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The RevokeSharedLinkArg struct
    public class RevokeSharedLinkArg: CustomStringConvertible {
        /// URL of the shared link.
        public let url: String
        public init(url: String) {
            stringValidator()(url)
            self.url = url
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(RevokeSharedLinkArgSerializer().serialize(self)))"
        }
    }
    public class RevokeSharedLinkArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: RevokeSharedLinkArg) -> JSON {
            let output = [ 
            "url": Serialization._StringSerializer.serialize(value.url),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> RevokeSharedLinkArg {
            switch json {
                case .Dictionary(let dict):
                    let url = Serialization._StringSerializer.deserialize(dict["url"] ?? .Null)
                    return RevokeSharedLinkArg(url: url)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The RevokeSharedLinkError union
    public enum RevokeSharedLinkError: CustomStringConvertible {
        /// The shared link wasn't found
        case SharedLinkNotFound
        /// The caller is not allowed to access this shared link
        case SharedLinkAccessDenied
        /// An unspecified error
        case Other
        /// Shared link is malformed.
        case SharedLinkMalformed

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(RevokeSharedLinkErrorSerializer().serialize(self)))"
        }
    }
    public class RevokeSharedLinkErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: RevokeSharedLinkError) -> JSON {
            switch value {
                case .SharedLinkNotFound:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("shared_link_not_found")
                    return .Dictionary(d)
                case .SharedLinkAccessDenied:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("shared_link_access_denied")
                    return .Dictionary(d)
                case .Other:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
                case .SharedLinkMalformed:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("shared_link_malformed")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> RevokeSharedLinkError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "shared_link_not_found":
                            return RevokeSharedLinkError.SharedLinkNotFound
                        case "shared_link_access_denied":
                            return RevokeSharedLinkError.SharedLinkAccessDenied
                        case "other":
                            return RevokeSharedLinkError.Other
                        case "shared_link_malformed":
                            return RevokeSharedLinkError.SharedLinkMalformed
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The ShareFolderArg struct
    public class ShareFolderArg: CustomStringConvertible {
        /// The path to the folder to share. If it does not exist, then a new one is created.
        public let path: String
        /// Who can be a member of this shared folder. Only applicable if the current user is on a team.
        public let memberPolicy: Sharing.MemberPolicy
        /// Who can add and remove members of this shared folder.
        public let aclUpdatePolicy: Sharing.AclUpdatePolicy
        /// The policy to apply to shared links created for content inside this shared folder.  The current user must be
        /// on a team to set this policy to members in SharedLinkPolicy.
        public let sharedLinkPolicy: Sharing.SharedLinkPolicy
        /// Whether to force the share to happen asynchronously.
        public let forceAsync: Bool
        public init(path: String, memberPolicy: Sharing.MemberPolicy = .Anyone, aclUpdatePolicy: Sharing.AclUpdatePolicy = .Owner, sharedLinkPolicy: Sharing.SharedLinkPolicy = .Anyone, forceAsync: Bool = false) {
            stringValidator(pattern: "/(.|[\\r\\n])*")(path)
            self.path = path
            self.memberPolicy = memberPolicy
            self.aclUpdatePolicy = aclUpdatePolicy
            self.sharedLinkPolicy = sharedLinkPolicy
            self.forceAsync = forceAsync
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ShareFolderArgSerializer().serialize(self)))"
        }
    }
    public class ShareFolderArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: ShareFolderArg) -> JSON {
            let output = [ 
            "path": Serialization._StringSerializer.serialize(value.path),
            "member_policy": Sharing.MemberPolicySerializer().serialize(value.memberPolicy),
            "acl_update_policy": Sharing.AclUpdatePolicySerializer().serialize(value.aclUpdatePolicy),
            "shared_link_policy": Sharing.SharedLinkPolicySerializer().serialize(value.sharedLinkPolicy),
            "force_async": Serialization._BoolSerializer.serialize(value.forceAsync),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> ShareFolderArg {
            switch json {
                case .Dictionary(let dict):
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .Null)
                    let memberPolicy = Sharing.MemberPolicySerializer().deserialize(dict["member_policy"] ?? .Null)
                    let aclUpdatePolicy = Sharing.AclUpdatePolicySerializer().deserialize(dict["acl_update_policy"] ?? .Null)
                    let sharedLinkPolicy = Sharing.SharedLinkPolicySerializer().deserialize(dict["shared_link_policy"] ?? .Null)
                    let forceAsync = Serialization._BoolSerializer.deserialize(dict["force_async"] ?? .Null)
                    return ShareFolderArg(path: path, memberPolicy: memberPolicy, aclUpdatePolicy: aclUpdatePolicy, sharedLinkPolicy: sharedLinkPolicy, forceAsync: forceAsync)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The ShareFolderErrorBase union
    public enum ShareFolderErrorBase: CustomStringConvertible {
        /// The current user's e-mail address is unverified.
        case EmailUnverified
        /// path in ShareFolderArg is invalid.
        case BadPath(Sharing.SharePathError)
        /// Team policy is more restrictive than memberPolicy in ShareFolderArg.
        case TeamPolicyDisallowsMemberPolicy
        /// The current user's account is not allowed to select the specified sharedLinkPolicy in ShareFolderArg.
        case DisallowedSharedLinkPolicy
        /// (undocumented)
        case Other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ShareFolderErrorBaseSerializer().serialize(self)))"
        }
    }
    public class ShareFolderErrorBaseSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: ShareFolderErrorBase) -> JSON {
            switch value {
                case .EmailUnverified:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("email_unverified")
                    return .Dictionary(d)
                case .BadPath(let arg):
                    var d = ["bad_path": Sharing.SharePathErrorSerializer().serialize(arg)]
                    d[".tag"] = .Str("bad_path")
                    return .Dictionary(d)
                case .TeamPolicyDisallowsMemberPolicy:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("team_policy_disallows_member_policy")
                    return .Dictionary(d)
                case .DisallowedSharedLinkPolicy:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("disallowed_shared_link_policy")
                    return .Dictionary(d)
                case .Other:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> ShareFolderErrorBase {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "email_unverified":
                            return ShareFolderErrorBase.EmailUnverified
                        case "bad_path":
                            let v = Sharing.SharePathErrorSerializer().deserialize(d["bad_path"] ?? .Null)
                            return ShareFolderErrorBase.BadPath(v)
                        case "team_policy_disallows_member_policy":
                            return ShareFolderErrorBase.TeamPolicyDisallowsMemberPolicy
                        case "disallowed_shared_link_policy":
                            return ShareFolderErrorBase.DisallowedSharedLinkPolicy
                        case "other":
                            return ShareFolderErrorBase.Other
                        default:
                            return ShareFolderErrorBase.Other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The ShareFolderError union
    public enum ShareFolderError: CustomStringConvertible {
        /// The current user's e-mail address is unverified.
        case EmailUnverified
        /// path in ShareFolderArg is invalid.
        case BadPath(Sharing.SharePathError)
        /// Team policy is more restrictive than memberPolicy in ShareFolderArg.
        case TeamPolicyDisallowsMemberPolicy
        /// The current user's account is not allowed to select the specified sharedLinkPolicy in ShareFolderArg.
        case DisallowedSharedLinkPolicy
        /// (undocumented)
        case Other
        /// The current user does not have permission to perform this action.
        case NoPermission

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ShareFolderErrorSerializer().serialize(self)))"
        }
    }
    public class ShareFolderErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: ShareFolderError) -> JSON {
            switch value {
                case .EmailUnverified:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("email_unverified")
                    return .Dictionary(d)
                case .BadPath(let arg):
                    var d = ["bad_path": Sharing.SharePathErrorSerializer().serialize(arg)]
                    d[".tag"] = .Str("bad_path")
                    return .Dictionary(d)
                case .TeamPolicyDisallowsMemberPolicy:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("team_policy_disallows_member_policy")
                    return .Dictionary(d)
                case .DisallowedSharedLinkPolicy:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("disallowed_shared_link_policy")
                    return .Dictionary(d)
                case .Other:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
                case .NoPermission:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("no_permission")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> ShareFolderError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "email_unverified":
                            return ShareFolderError.EmailUnverified
                        case "bad_path":
                            let v = Sharing.SharePathErrorSerializer().deserialize(d["bad_path"] ?? .Null)
                            return ShareFolderError.BadPath(v)
                        case "team_policy_disallows_member_policy":
                            return ShareFolderError.TeamPolicyDisallowsMemberPolicy
                        case "disallowed_shared_link_policy":
                            return ShareFolderError.DisallowedSharedLinkPolicy
                        case "other":
                            return ShareFolderError.Other
                        case "no_permission":
                            return ShareFolderError.NoPermission
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The ShareFolderJobStatus union
    public enum ShareFolderJobStatus: CustomStringConvertible {
        /// The asynchronous job is still in progress.
        case InProgress
        /// The share job has finished. The value is the metadata for the folder.
        case Complete(Sharing.SharedFolderMetadata)
        /// (undocumented)
        case Failed(Sharing.ShareFolderError)

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ShareFolderJobStatusSerializer().serialize(self)))"
        }
    }
    public class ShareFolderJobStatusSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: ShareFolderJobStatus) -> JSON {
            switch value {
                case .InProgress:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("in_progress")
                    return .Dictionary(d)
                case .Complete(let arg):
                    var d = Serialization.getFields(Sharing.SharedFolderMetadataSerializer().serialize(arg))
                    d[".tag"] = .Str("complete")
                    return .Dictionary(d)
                case .Failed(let arg):
                    var d = ["failed": Sharing.ShareFolderErrorSerializer().serialize(arg)]
                    d[".tag"] = .Str("failed")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> ShareFolderJobStatus {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "in_progress":
                            return ShareFolderJobStatus.InProgress
                        case "complete":
                            let v = Sharing.SharedFolderMetadataSerializer().deserialize(json)
                            return ShareFolderJobStatus.Complete(v)
                        case "failed":
                            let v = Sharing.ShareFolderErrorSerializer().deserialize(d["failed"] ?? .Null)
                            return ShareFolderJobStatus.Failed(v)
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The ShareFolderLaunch union
    public enum ShareFolderLaunch: CustomStringConvertible {
        /// This response indicates that the processing is asynchronous. The string is an id that can be used to obtain
        /// the status of the asynchronous job.
        case AsyncJobId(String)
        /// (undocumented)
        case Complete(Sharing.SharedFolderMetadata)

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ShareFolderLaunchSerializer().serialize(self)))"
        }
    }
    public class ShareFolderLaunchSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: ShareFolderLaunch) -> JSON {
            switch value {
                case .AsyncJobId(let arg):
                    var d = ["async_job_id": Serialization._StringSerializer.serialize(arg)]
                    d[".tag"] = .Str("async_job_id")
                    return .Dictionary(d)
                case .Complete(let arg):
                    var d = Serialization.getFields(Sharing.SharedFolderMetadataSerializer().serialize(arg))
                    d[".tag"] = .Str("complete")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> ShareFolderLaunch {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "async_job_id":
                            let v = Serialization._StringSerializer.deserialize(d["async_job_id"] ?? .Null)
                            return ShareFolderLaunch.AsyncJobId(v)
                        case "complete":
                            let v = Sharing.SharedFolderMetadataSerializer().deserialize(json)
                            return ShareFolderLaunch.Complete(v)
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The SharePathError union
    public enum SharePathError: CustomStringConvertible {
        /// A file is at the specified path.
        case IsFile
        /// We do not support sharing a folder inside a shared folder.
        case InsideSharedFolder
        /// We do not support shared folders that contain shared folders.
        case ContainsSharedFolder
        /// We do not support sharing an app folder.
        case IsAppFolder
        /// We do not support sharing a folder inside an app folder.
        case InsideAppFolder
        /// A public folder can't be shared this way. Use a public link instead.
        case IsPublicFolder
        /// A folder inside a public folder can't be shared this way. Use a public link instead.
        case InsidePublicFolder
        /// Folder is already shared. Contains metadata about the existing shared folder.
        case AlreadyShared(Sharing.SharedFolderMetadata)
        /// Path is not valid.
        case InvalidPath
        /// We do not support sharing a Mac OS X package.
        case IsOsxPackage
        /// We do not support sharing a folder inside a Mac OS X package.
        case InsideOsxPackage
        /// (undocumented)
        case Other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharePathErrorSerializer().serialize(self)))"
        }
    }
    public class SharePathErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: SharePathError) -> JSON {
            switch value {
                case .IsFile:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("is_file")
                    return .Dictionary(d)
                case .InsideSharedFolder:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("inside_shared_folder")
                    return .Dictionary(d)
                case .ContainsSharedFolder:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("contains_shared_folder")
                    return .Dictionary(d)
                case .IsAppFolder:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("is_app_folder")
                    return .Dictionary(d)
                case .InsideAppFolder:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("inside_app_folder")
                    return .Dictionary(d)
                case .IsPublicFolder:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("is_public_folder")
                    return .Dictionary(d)
                case .InsidePublicFolder:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("inside_public_folder")
                    return .Dictionary(d)
                case .AlreadyShared(let arg):
                    var d = Serialization.getFields(Sharing.SharedFolderMetadataSerializer().serialize(arg))
                    d[".tag"] = .Str("already_shared")
                    return .Dictionary(d)
                case .InvalidPath:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("invalid_path")
                    return .Dictionary(d)
                case .IsOsxPackage:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("is_osx_package")
                    return .Dictionary(d)
                case .InsideOsxPackage:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("inside_osx_package")
                    return .Dictionary(d)
                case .Other:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> SharePathError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "is_file":
                            return SharePathError.IsFile
                        case "inside_shared_folder":
                            return SharePathError.InsideSharedFolder
                        case "contains_shared_folder":
                            return SharePathError.ContainsSharedFolder
                        case "is_app_folder":
                            return SharePathError.IsAppFolder
                        case "inside_app_folder":
                            return SharePathError.InsideAppFolder
                        case "is_public_folder":
                            return SharePathError.IsPublicFolder
                        case "inside_public_folder":
                            return SharePathError.InsidePublicFolder
                        case "already_shared":
                            let v = Sharing.SharedFolderMetadataSerializer().deserialize(json)
                            return SharePathError.AlreadyShared(v)
                        case "invalid_path":
                            return SharePathError.InvalidPath
                        case "is_osx_package":
                            return SharePathError.IsOsxPackage
                        case "inside_osx_package":
                            return SharePathError.InsideOsxPackage
                        case "other":
                            return SharePathError.Other
                        default:
                            return SharePathError.Other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Shared file user, group, and invitee membership. Used for the results of listFileMembers and
    /// listFileMembersContinue, and used as part of the results for listFileMembersBatch.
    public class SharedFileMembers: CustomStringConvertible {
        /// The list of user members of the shared file.
        public let users: Array<Sharing.UserMembershipInfo>
        /// The list of group members of the shared file.
        public let groups: Array<Sharing.GroupMembershipInfo>
        /// The list of invited members of a file, but have not logged in and claimed this.
        public let invitees: Array<Sharing.InviteeMembershipInfo>
        /// Present if there are additional shared file members that have not been returned yet. Pass the cursor into
        /// listFileMembersContinue to list additional members.
        public let cursor: String?
        public init(users: Array<Sharing.UserMembershipInfo>, groups: Array<Sharing.GroupMembershipInfo>, invitees: Array<Sharing.InviteeMembershipInfo>, cursor: String? = nil) {
            self.users = users
            self.groups = groups
            self.invitees = invitees
            nullableValidator(stringValidator())(cursor)
            self.cursor = cursor
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharedFileMembersSerializer().serialize(self)))"
        }
    }
    public class SharedFileMembersSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: SharedFileMembers) -> JSON {
            let output = [ 
            "users": ArraySerializer(Sharing.UserMembershipInfoSerializer()).serialize(value.users),
            "groups": ArraySerializer(Sharing.GroupMembershipInfoSerializer()).serialize(value.groups),
            "invitees": ArraySerializer(Sharing.InviteeMembershipInfoSerializer()).serialize(value.invitees),
            "cursor": NullableSerializer(Serialization._StringSerializer).serialize(value.cursor),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> SharedFileMembers {
            switch json {
                case .Dictionary(let dict):
                    let users = ArraySerializer(Sharing.UserMembershipInfoSerializer()).deserialize(dict["users"] ?? .Null)
                    let groups = ArraySerializer(Sharing.GroupMembershipInfoSerializer()).deserialize(dict["groups"] ?? .Null)
                    let invitees = ArraySerializer(Sharing.InviteeMembershipInfoSerializer()).deserialize(dict["invitees"] ?? .Null)
                    let cursor = NullableSerializer(Serialization._StringSerializer).deserialize(dict["cursor"] ?? .Null)
                    return SharedFileMembers(users: users, groups: groups, invitees: invitees, cursor: cursor)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Properties of the shared file.
    public class SharedFileMetadata: CustomStringConvertible {
        /// Policies governing this shared file.
        public let policy: Sharing.FolderPolicy
        /// The sharing permissions that requesting user has on this file. This corresponds to the entries given in
        /// actions in GetFileMetadataBatchArg or actions in GetFileMetadataArg.
        public let permissions: Array<Sharing.FilePermission>?
        /// The team that owns the file. This field is not present if the file is not owned by a team.
        public let ownerTeam: Users.Team?
        /// The ID of the parent shared folder. This field is present only if the file is contained within a shared
        /// folder.
        public let parentSharedFolderId: String?
        /// URL for displaying a web preview of the shared file.
        public let previewUrl: String
        /// The lower-case full path of this file. Absent for unmounted files.
        public let pathLower: String?
        /// The cased path to be used for display purposes only. In rare instances the casing will not correctly match
        /// the user's filesystem, but this behavior will match the path provided in the Core API v1. Absent for
        /// unmounted files.
        public let pathDisplay: String?
        /// The name of this file.
        public let name: String
        /// The ID of the file.
        public let id: String
        public init(policy: Sharing.FolderPolicy, previewUrl: String, name: String, id: String, permissions: Array<Sharing.FilePermission>? = nil, ownerTeam: Users.Team? = nil, parentSharedFolderId: String? = nil, pathLower: String? = nil, pathDisplay: String? = nil) {
            self.policy = policy
            self.permissions = permissions
            self.ownerTeam = ownerTeam
            nullableValidator(stringValidator(pattern: "[-_0-9a-zA-Z:]+"))(parentSharedFolderId)
            self.parentSharedFolderId = parentSharedFolderId
            stringValidator()(previewUrl)
            self.previewUrl = previewUrl
            nullableValidator(stringValidator())(pathLower)
            self.pathLower = pathLower
            nullableValidator(stringValidator())(pathDisplay)
            self.pathDisplay = pathDisplay
            stringValidator()(name)
            self.name = name
            stringValidator(minLength: 1, pattern: "id:.*")(id)
            self.id = id
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharedFileMetadataSerializer().serialize(self)))"
        }
    }
    public class SharedFileMetadataSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: SharedFileMetadata) -> JSON {
            let output = [ 
            "policy": Sharing.FolderPolicySerializer().serialize(value.policy),
            "preview_url": Serialization._StringSerializer.serialize(value.previewUrl),
            "name": Serialization._StringSerializer.serialize(value.name),
            "id": Serialization._StringSerializer.serialize(value.id),
            "permissions": NullableSerializer(ArraySerializer(Sharing.FilePermissionSerializer())).serialize(value.permissions),
            "owner_team": NullableSerializer(Users.TeamSerializer()).serialize(value.ownerTeam),
            "parent_shared_folder_id": NullableSerializer(Serialization._StringSerializer).serialize(value.parentSharedFolderId),
            "path_lower": NullableSerializer(Serialization._StringSerializer).serialize(value.pathLower),
            "path_display": NullableSerializer(Serialization._StringSerializer).serialize(value.pathDisplay),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> SharedFileMetadata {
            switch json {
                case .Dictionary(let dict):
                    let policy = Sharing.FolderPolicySerializer().deserialize(dict["policy"] ?? .Null)
                    let previewUrl = Serialization._StringSerializer.deserialize(dict["preview_url"] ?? .Null)
                    let name = Serialization._StringSerializer.deserialize(dict["name"] ?? .Null)
                    let id = Serialization._StringSerializer.deserialize(dict["id"] ?? .Null)
                    let permissions = NullableSerializer(ArraySerializer(Sharing.FilePermissionSerializer())).deserialize(dict["permissions"] ?? .Null)
                    let ownerTeam = NullableSerializer(Users.TeamSerializer()).deserialize(dict["owner_team"] ?? .Null)
                    let parentSharedFolderId = NullableSerializer(Serialization._StringSerializer).deserialize(dict["parent_shared_folder_id"] ?? .Null)
                    let pathLower = NullableSerializer(Serialization._StringSerializer).deserialize(dict["path_lower"] ?? .Null)
                    let pathDisplay = NullableSerializer(Serialization._StringSerializer).deserialize(dict["path_display"] ?? .Null)
                    return SharedFileMetadata(policy: policy, previewUrl: previewUrl, name: name, id: id, permissions: permissions, ownerTeam: ownerTeam, parentSharedFolderId: parentSharedFolderId, pathLower: pathLower, pathDisplay: pathDisplay)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// There is an error accessing the shared folder.
    public enum SharedFolderAccessError: CustomStringConvertible {
        /// This shared folder ID is invalid.
        case InvalidId
        /// The user is not a member of the shared folder thus cannot access it.
        case NotAMember
        /// The current user's e-mail address is unverified.
        case EmailUnverified
        /// The shared folder is unmounted.
        case Unmounted
        /// (undocumented)
        case Other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharedFolderAccessErrorSerializer().serialize(self)))"
        }
    }
    public class SharedFolderAccessErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: SharedFolderAccessError) -> JSON {
            switch value {
                case .InvalidId:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("invalid_id")
                    return .Dictionary(d)
                case .NotAMember:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("not_a_member")
                    return .Dictionary(d)
                case .EmailUnverified:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("email_unverified")
                    return .Dictionary(d)
                case .Unmounted:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("unmounted")
                    return .Dictionary(d)
                case .Other:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> SharedFolderAccessError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "invalid_id":
                            return SharedFolderAccessError.InvalidId
                        case "not_a_member":
                            return SharedFolderAccessError.NotAMember
                        case "email_unverified":
                            return SharedFolderAccessError.EmailUnverified
                        case "unmounted":
                            return SharedFolderAccessError.Unmounted
                        case "other":
                            return SharedFolderAccessError.Other
                        default:
                            return SharedFolderAccessError.Other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The SharedFolderMemberError union
    public enum SharedFolderMemberError: CustomStringConvertible {
        /// The target dropbox_id is invalid.
        case InvalidDropboxId
        /// The target dropbox_id is not a member of the shared folder.
        case NotAMember
        /// (undocumented)
        case Other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharedFolderMemberErrorSerializer().serialize(self)))"
        }
    }
    public class SharedFolderMemberErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: SharedFolderMemberError) -> JSON {
            switch value {
                case .InvalidDropboxId:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("invalid_dropbox_id")
                    return .Dictionary(d)
                case .NotAMember:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("not_a_member")
                    return .Dictionary(d)
                case .Other:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> SharedFolderMemberError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "invalid_dropbox_id":
                            return SharedFolderMemberError.InvalidDropboxId
                        case "not_a_member":
                            return SharedFolderMemberError.NotAMember
                        case "other":
                            return SharedFolderMemberError.Other
                        default:
                            return SharedFolderMemberError.Other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Shared folder user and group membership.
    public class SharedFolderMembers: CustomStringConvertible {
        /// The list of user members of the shared folder.
        public let users: Array<Sharing.UserMembershipInfo>
        /// The list of group members of the shared folder.
        public let groups: Array<Sharing.GroupMembershipInfo>
        /// The list of invitees to the shared folder.
        public let invitees: Array<Sharing.InviteeMembershipInfo>
        /// Present if there are additional shared folder members that have not been returned yet. Pass the cursor into
        /// listFolderMembersContinue to list additional members.
        public let cursor: String?
        public init(users: Array<Sharing.UserMembershipInfo>, groups: Array<Sharing.GroupMembershipInfo>, invitees: Array<Sharing.InviteeMembershipInfo>, cursor: String? = nil) {
            self.users = users
            self.groups = groups
            self.invitees = invitees
            nullableValidator(stringValidator())(cursor)
            self.cursor = cursor
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharedFolderMembersSerializer().serialize(self)))"
        }
    }
    public class SharedFolderMembersSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: SharedFolderMembers) -> JSON {
            let output = [ 
            "users": ArraySerializer(Sharing.UserMembershipInfoSerializer()).serialize(value.users),
            "groups": ArraySerializer(Sharing.GroupMembershipInfoSerializer()).serialize(value.groups),
            "invitees": ArraySerializer(Sharing.InviteeMembershipInfoSerializer()).serialize(value.invitees),
            "cursor": NullableSerializer(Serialization._StringSerializer).serialize(value.cursor),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> SharedFolderMembers {
            switch json {
                case .Dictionary(let dict):
                    let users = ArraySerializer(Sharing.UserMembershipInfoSerializer()).deserialize(dict["users"] ?? .Null)
                    let groups = ArraySerializer(Sharing.GroupMembershipInfoSerializer()).deserialize(dict["groups"] ?? .Null)
                    let invitees = ArraySerializer(Sharing.InviteeMembershipInfoSerializer()).deserialize(dict["invitees"] ?? .Null)
                    let cursor = NullableSerializer(Serialization._StringSerializer).deserialize(dict["cursor"] ?? .Null)
                    return SharedFolderMembers(users: users, groups: groups, invitees: invitees, cursor: cursor)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Properties of the shared folder.
    public class SharedFolderMetadataBase: CustomStringConvertible {
        /// The current user's access level for this shared folder.
        public let accessType: Sharing.AccessLevel
        /// Whether this folder is a team folder https://www.dropbox.com/en/help/986.
        public let isTeamFolder: Bool
        /// Policies governing this shared folder.
        public let policy: Sharing.FolderPolicy
        /// The team that owns the folder. This field is not present if the folder is not owned by a team.
        public let ownerTeam: Users.Team?
        /// The ID of the parent shared folder. This field is present only if the folder is contained within another
        /// shared folder.
        public let parentSharedFolderId: String?
        public init(accessType: Sharing.AccessLevel, isTeamFolder: Bool, policy: Sharing.FolderPolicy, ownerTeam: Users.Team? = nil, parentSharedFolderId: String? = nil) {
            self.accessType = accessType
            self.isTeamFolder = isTeamFolder
            self.policy = policy
            self.ownerTeam = ownerTeam
            nullableValidator(stringValidator(pattern: "[-_0-9a-zA-Z:]+"))(parentSharedFolderId)
            self.parentSharedFolderId = parentSharedFolderId
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharedFolderMetadataBaseSerializer().serialize(self)))"
        }
    }
    public class SharedFolderMetadataBaseSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: SharedFolderMetadataBase) -> JSON {
            let output = [ 
            "access_type": Sharing.AccessLevelSerializer().serialize(value.accessType),
            "is_team_folder": Serialization._BoolSerializer.serialize(value.isTeamFolder),
            "policy": Sharing.FolderPolicySerializer().serialize(value.policy),
            "owner_team": NullableSerializer(Users.TeamSerializer()).serialize(value.ownerTeam),
            "parent_shared_folder_id": NullableSerializer(Serialization._StringSerializer).serialize(value.parentSharedFolderId),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> SharedFolderMetadataBase {
            switch json {
                case .Dictionary(let dict):
                    let accessType = Sharing.AccessLevelSerializer().deserialize(dict["access_type"] ?? .Null)
                    let isTeamFolder = Serialization._BoolSerializer.deserialize(dict["is_team_folder"] ?? .Null)
                    let policy = Sharing.FolderPolicySerializer().deserialize(dict["policy"] ?? .Null)
                    let ownerTeam = NullableSerializer(Users.TeamSerializer()).deserialize(dict["owner_team"] ?? .Null)
                    let parentSharedFolderId = NullableSerializer(Serialization._StringSerializer).deserialize(dict["parent_shared_folder_id"] ?? .Null)
                    return SharedFolderMetadataBase(accessType: accessType, isTeamFolder: isTeamFolder, policy: policy, ownerTeam: ownerTeam, parentSharedFolderId: parentSharedFolderId)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The metadata which includes basic information about the shared folder.
    public class SharedFolderMetadata: Sharing.SharedFolderMetadataBase {
        /// The lower-cased full path of this shared folder. Absent for unmounted folders.
        public let pathLower: String?
        /// The name of the this shared folder.
        public let name: String
        /// The ID of the shared folder.
        public let sharedFolderId: String
        /// Actions the current user may perform on the folder and its contents. The set of permissions corresponds to
        /// the FolderActions in the request.
        public let permissions: Array<Sharing.FolderPermission>?
        /// Timestamp indicating when the current user was invited to this shared folder.
        public let timeInvited: NSDate
        public init(accessType: Sharing.AccessLevel, isTeamFolder: Bool, policy: Sharing.FolderPolicy, name: String, sharedFolderId: String, timeInvited: NSDate, ownerTeam: Users.Team? = nil, parentSharedFolderId: String? = nil, pathLower: String? = nil, permissions: Array<Sharing.FolderPermission>? = nil) {
            nullableValidator(stringValidator())(pathLower)
            self.pathLower = pathLower
            stringValidator()(name)
            self.name = name
            stringValidator(pattern: "[-_0-9a-zA-Z:]+")(sharedFolderId)
            self.sharedFolderId = sharedFolderId
            self.permissions = permissions
            self.timeInvited = timeInvited
            super.init(accessType: accessType, isTeamFolder: isTeamFolder, policy: policy, ownerTeam: ownerTeam, parentSharedFolderId: parentSharedFolderId)
        }
        public override var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharedFolderMetadataSerializer().serialize(self)))"
        }
    }
    public class SharedFolderMetadataSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: SharedFolderMetadata) -> JSON {
            let output = [ 
            "access_type": Sharing.AccessLevelSerializer().serialize(value.accessType),
            "is_team_folder": Serialization._BoolSerializer.serialize(value.isTeamFolder),
            "policy": Sharing.FolderPolicySerializer().serialize(value.policy),
            "name": Serialization._StringSerializer.serialize(value.name),
            "shared_folder_id": Serialization._StringSerializer.serialize(value.sharedFolderId),
            "time_invited": NSDateSerializer("%Y-%m-%dT%H:%M:%SZ").serialize(value.timeInvited),
            "owner_team": NullableSerializer(Users.TeamSerializer()).serialize(value.ownerTeam),
            "parent_shared_folder_id": NullableSerializer(Serialization._StringSerializer).serialize(value.parentSharedFolderId),
            "path_lower": NullableSerializer(Serialization._StringSerializer).serialize(value.pathLower),
            "permissions": NullableSerializer(ArraySerializer(Sharing.FolderPermissionSerializer())).serialize(value.permissions),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> SharedFolderMetadata {
            switch json {
                case .Dictionary(let dict):
                    let accessType = Sharing.AccessLevelSerializer().deserialize(dict["access_type"] ?? .Null)
                    let isTeamFolder = Serialization._BoolSerializer.deserialize(dict["is_team_folder"] ?? .Null)
                    let policy = Sharing.FolderPolicySerializer().deserialize(dict["policy"] ?? .Null)
                    let name = Serialization._StringSerializer.deserialize(dict["name"] ?? .Null)
                    let sharedFolderId = Serialization._StringSerializer.deserialize(dict["shared_folder_id"] ?? .Null)
                    let timeInvited = NSDateSerializer("%Y-%m-%dT%H:%M:%SZ").deserialize(dict["time_invited"] ?? .Null)
                    let ownerTeam = NullableSerializer(Users.TeamSerializer()).deserialize(dict["owner_team"] ?? .Null)
                    let parentSharedFolderId = NullableSerializer(Serialization._StringSerializer).deserialize(dict["parent_shared_folder_id"] ?? .Null)
                    let pathLower = NullableSerializer(Serialization._StringSerializer).deserialize(dict["path_lower"] ?? .Null)
                    let permissions = NullableSerializer(ArraySerializer(Sharing.FolderPermissionSerializer())).deserialize(dict["permissions"] ?? .Null)
                    return SharedFolderMetadata(accessType: accessType, isTeamFolder: isTeamFolder, policy: policy, name: name, sharedFolderId: sharedFolderId, timeInvited: timeInvited, ownerTeam: ownerTeam, parentSharedFolderId: parentSharedFolderId, pathLower: pathLower, permissions: permissions)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The SharedLinkAccessFailureReason union
    public enum SharedLinkAccessFailureReason: CustomStringConvertible {
        /// User is not logged in.
        case LoginRequired
        /// User's email is not verified.
        case EmailVerifyRequired
        /// The link is password protected.
        case PasswordRequired
        /// Access is allowed for team members only.
        case TeamOnly
        /// Access is allowed for the shared link's owner only.
        case OwnerOnly
        /// An unknown accessibility failure.
        case Other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharedLinkAccessFailureReasonSerializer().serialize(self)))"
        }
    }
    public class SharedLinkAccessFailureReasonSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: SharedLinkAccessFailureReason) -> JSON {
            switch value {
                case .LoginRequired:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("login_required")
                    return .Dictionary(d)
                case .EmailVerifyRequired:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("email_verify_required")
                    return .Dictionary(d)
                case .PasswordRequired:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("password_required")
                    return .Dictionary(d)
                case .TeamOnly:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("team_only")
                    return .Dictionary(d)
                case .OwnerOnly:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("owner_only")
                    return .Dictionary(d)
                case .Other:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> SharedLinkAccessFailureReason {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "login_required":
                            return SharedLinkAccessFailureReason.LoginRequired
                        case "email_verify_required":
                            return SharedLinkAccessFailureReason.EmailVerifyRequired
                        case "password_required":
                            return SharedLinkAccessFailureReason.PasswordRequired
                        case "team_only":
                            return SharedLinkAccessFailureReason.TeamOnly
                        case "owner_only":
                            return SharedLinkAccessFailureReason.OwnerOnly
                        case "other":
                            return SharedLinkAccessFailureReason.Other
                        default:
                            return SharedLinkAccessFailureReason.Other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Policy governing who can view shared links.
    public enum SharedLinkPolicy: CustomStringConvertible {
        /// Links can be shared with anyone.
        case Anyone
        /// Links can only be shared among members of the shared folder.
        case Members
        /// An unknown shared link policy.
        case Other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharedLinkPolicySerializer().serialize(self)))"
        }
    }
    public class SharedLinkPolicySerializer: JSONSerializer {
        public init() { }
        public func serialize(value: SharedLinkPolicy) -> JSON {
            switch value {
                case .Anyone:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("anyone")
                    return .Dictionary(d)
                case .Members:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("members")
                    return .Dictionary(d)
                case .Other:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> SharedLinkPolicy {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "anyone":
                            return SharedLinkPolicy.Anyone
                        case "members":
                            return SharedLinkPolicy.Members
                        case "other":
                            return SharedLinkPolicy.Other
                        default:
                            return SharedLinkPolicy.Other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The SharedLinkSettings struct
    public class SharedLinkSettings: CustomStringConvertible {
        /// The requested access for this shared link.
        public let requestedVisibility: Sharing.RequestedVisibility?
        /// If requestedVisibility is password in RequestedVisibility this is needed to specify the password to access
        /// the link.
        public let linkPassword: String?
        /// Expiration time of the shared link. By default the link won't expire.
        public let expires: NSDate?
        public init(requestedVisibility: Sharing.RequestedVisibility? = nil, linkPassword: String? = nil, expires: NSDate? = nil) {
            self.requestedVisibility = requestedVisibility
            nullableValidator(stringValidator())(linkPassword)
            self.linkPassword = linkPassword
            self.expires = expires
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharedLinkSettingsSerializer().serialize(self)))"
        }
    }
    public class SharedLinkSettingsSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: SharedLinkSettings) -> JSON {
            let output = [ 
            "requested_visibility": NullableSerializer(Sharing.RequestedVisibilitySerializer()).serialize(value.requestedVisibility),
            "link_password": NullableSerializer(Serialization._StringSerializer).serialize(value.linkPassword),
            "expires": NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.expires),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> SharedLinkSettings {
            switch json {
                case .Dictionary(let dict):
                    let requestedVisibility = NullableSerializer(Sharing.RequestedVisibilitySerializer()).deserialize(dict["requested_visibility"] ?? .Null)
                    let linkPassword = NullableSerializer(Serialization._StringSerializer).deserialize(dict["link_password"] ?? .Null)
                    let expires = NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).deserialize(dict["expires"] ?? .Null)
                    return SharedLinkSettings(requestedVisibility: requestedVisibility, linkPassword: linkPassword, expires: expires)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The SharedLinkSettingsError union
    public enum SharedLinkSettingsError: CustomStringConvertible {
        /// The given settings are invalid (for example, all attributes of the SharedLinkSettings are empty, the
        /// requested visibility is password in RequestedVisibility but the linkPassword in SharedLinkSettings is
        /// missing, expires in SharedLinkSettings is set to the past, etc.)
        case InvalidSettings
        /// User is not allowed to modify the settings of this link. Note that basic users can only set public_ in
        /// RequestedVisibility as the requestedVisibility in SharedLinkSettings and cannot set expires in
        /// SharedLinkSettings
        case NotAuthorized

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharedLinkSettingsErrorSerializer().serialize(self)))"
        }
    }
    public class SharedLinkSettingsErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: SharedLinkSettingsError) -> JSON {
            switch value {
                case .InvalidSettings:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("invalid_settings")
                    return .Dictionary(d)
                case .NotAuthorized:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("not_authorized")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> SharedLinkSettingsError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "invalid_settings":
                            return SharedLinkSettingsError.InvalidSettings
                        case "not_authorized":
                            return SharedLinkSettingsError.NotAuthorized
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// User could not access this file.
    public enum SharingFileAccessError: CustomStringConvertible {
        /// Current user does not have sufficient privileges to perform the desired action.
        case NoPermission
        /// File specified was not found.
        case InvalidFile
        /// A folder can't be shared this way. Use folder sharing or a shared link instead.
        case IsFolder
        /// A file inside a public folder can't be shared this way. Use a public link instead.
        case InsidePublicFolder
        /// A Mac OS X package can't be shared this way. Use a shared link instead.
        case InsideOsxPackage
        /// (undocumented)
        case Other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharingFileAccessErrorSerializer().serialize(self)))"
        }
    }
    public class SharingFileAccessErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: SharingFileAccessError) -> JSON {
            switch value {
                case .NoPermission:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("no_permission")
                    return .Dictionary(d)
                case .InvalidFile:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("invalid_file")
                    return .Dictionary(d)
                case .IsFolder:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("is_folder")
                    return .Dictionary(d)
                case .InsidePublicFolder:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("inside_public_folder")
                    return .Dictionary(d)
                case .InsideOsxPackage:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("inside_osx_package")
                    return .Dictionary(d)
                case .Other:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> SharingFileAccessError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "no_permission":
                            return SharingFileAccessError.NoPermission
                        case "invalid_file":
                            return SharingFileAccessError.InvalidFile
                        case "is_folder":
                            return SharingFileAccessError.IsFolder
                        case "inside_public_folder":
                            return SharingFileAccessError.InsidePublicFolder
                        case "inside_osx_package":
                            return SharingFileAccessError.InsideOsxPackage
                        case "other":
                            return SharingFileAccessError.Other
                        default:
                            return SharingFileAccessError.Other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// User account had a problem preventing this action.
    public enum SharingUserError: CustomStringConvertible {
        /// The current user must verify the account e-mail address before performing this action.
        case EmailUnverified
        /// (undocumented)
        case Other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharingUserErrorSerializer().serialize(self)))"
        }
    }
    public class SharingUserErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: SharingUserError) -> JSON {
            switch value {
                case .EmailUnverified:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("email_unverified")
                    return .Dictionary(d)
                case .Other:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> SharingUserError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "email_unverified":
                            return SharingUserError.EmailUnverified
                        case "other":
                            return SharingUserError.Other
                        default:
                            return SharingUserError.Other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Information about a team member.
    public class TeamMemberInfo: CustomStringConvertible {
        /// Information about the member's team
        public let teamInfo: Users.Team
        /// The display name of the user.
        public let displayName: String
        /// ID of user as a member of a team. This field will only be present if the member is in the same team as
        /// current user.
        public let memberId: String?
        public init(teamInfo: Users.Team, displayName: String, memberId: String? = nil) {
            self.teamInfo = teamInfo
            stringValidator()(displayName)
            self.displayName = displayName
            nullableValidator(stringValidator())(memberId)
            self.memberId = memberId
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(TeamMemberInfoSerializer().serialize(self)))"
        }
    }
    public class TeamMemberInfoSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: TeamMemberInfo) -> JSON {
            let output = [ 
            "team_info": Users.TeamSerializer().serialize(value.teamInfo),
            "display_name": Serialization._StringSerializer.serialize(value.displayName),
            "member_id": NullableSerializer(Serialization._StringSerializer).serialize(value.memberId),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> TeamMemberInfo {
            switch json {
                case .Dictionary(let dict):
                    let teamInfo = Users.TeamSerializer().deserialize(dict["team_info"] ?? .Null)
                    let displayName = Serialization._StringSerializer.deserialize(dict["display_name"] ?? .Null)
                    let memberId = NullableSerializer(Serialization._StringSerializer).deserialize(dict["member_id"] ?? .Null)
                    return TeamMemberInfo(teamInfo: teamInfo, displayName: displayName, memberId: memberId)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The TransferFolderArg struct
    public class TransferFolderArg: CustomStringConvertible {
        /// The ID for the shared folder.
        public let sharedFolderId: String
        /// A account or team member ID to transfer ownership to.
        public let toDropboxId: String
        public init(sharedFolderId: String, toDropboxId: String) {
            stringValidator(pattern: "[-_0-9a-zA-Z:]+")(sharedFolderId)
            self.sharedFolderId = sharedFolderId
            stringValidator(minLength: 1)(toDropboxId)
            self.toDropboxId = toDropboxId
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(TransferFolderArgSerializer().serialize(self)))"
        }
    }
    public class TransferFolderArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: TransferFolderArg) -> JSON {
            let output = [ 
            "shared_folder_id": Serialization._StringSerializer.serialize(value.sharedFolderId),
            "to_dropbox_id": Serialization._StringSerializer.serialize(value.toDropboxId),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> TransferFolderArg {
            switch json {
                case .Dictionary(let dict):
                    let sharedFolderId = Serialization._StringSerializer.deserialize(dict["shared_folder_id"] ?? .Null)
                    let toDropboxId = Serialization._StringSerializer.deserialize(dict["to_dropbox_id"] ?? .Null)
                    return TransferFolderArg(sharedFolderId: sharedFolderId, toDropboxId: toDropboxId)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The TransferFolderError union
    public enum TransferFolderError: CustomStringConvertible {
        /// (undocumented)
        case AccessError(Sharing.SharedFolderAccessError)
        /// toDropboxId in TransferFolderArg is invalid.
        case InvalidDropboxId
        /// The new designated owner is not currently a member of the shared folder.
        case NewOwnerNotAMember
        /// The new designated owner has not added the folder to their Dropbox.
        case NewOwnerUnmounted
        /// The new designated owner's e-mail address is unverified.
        case NewOwnerEmailUnverified
        /// This action cannot be performed on a team shared folder.
        case TeamFolder
        /// The current user does not have permission to perform this action.
        case NoPermission
        /// (undocumented)
        case Other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(TransferFolderErrorSerializer().serialize(self)))"
        }
    }
    public class TransferFolderErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: TransferFolderError) -> JSON {
            switch value {
                case .AccessError(let arg):
                    var d = ["access_error": Sharing.SharedFolderAccessErrorSerializer().serialize(arg)]
                    d[".tag"] = .Str("access_error")
                    return .Dictionary(d)
                case .InvalidDropboxId:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("invalid_dropbox_id")
                    return .Dictionary(d)
                case .NewOwnerNotAMember:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("new_owner_not_a_member")
                    return .Dictionary(d)
                case .NewOwnerUnmounted:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("new_owner_unmounted")
                    return .Dictionary(d)
                case .NewOwnerEmailUnverified:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("new_owner_email_unverified")
                    return .Dictionary(d)
                case .TeamFolder:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("team_folder")
                    return .Dictionary(d)
                case .NoPermission:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("no_permission")
                    return .Dictionary(d)
                case .Other:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> TransferFolderError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "access_error":
                            let v = Sharing.SharedFolderAccessErrorSerializer().deserialize(d["access_error"] ?? .Null)
                            return TransferFolderError.AccessError(v)
                        case "invalid_dropbox_id":
                            return TransferFolderError.InvalidDropboxId
                        case "new_owner_not_a_member":
                            return TransferFolderError.NewOwnerNotAMember
                        case "new_owner_unmounted":
                            return TransferFolderError.NewOwnerUnmounted
                        case "new_owner_email_unverified":
                            return TransferFolderError.NewOwnerEmailUnverified
                        case "team_folder":
                            return TransferFolderError.TeamFolder
                        case "no_permission":
                            return TransferFolderError.NoPermission
                        case "other":
                            return TransferFolderError.Other
                        default:
                            return TransferFolderError.Other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The UnmountFolderArg struct
    public class UnmountFolderArg: CustomStringConvertible {
        /// The ID for the shared folder.
        public let sharedFolderId: String
        public init(sharedFolderId: String) {
            stringValidator(pattern: "[-_0-9a-zA-Z:]+")(sharedFolderId)
            self.sharedFolderId = sharedFolderId
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(UnmountFolderArgSerializer().serialize(self)))"
        }
    }
    public class UnmountFolderArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: UnmountFolderArg) -> JSON {
            let output = [ 
            "shared_folder_id": Serialization._StringSerializer.serialize(value.sharedFolderId),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> UnmountFolderArg {
            switch json {
                case .Dictionary(let dict):
                    let sharedFolderId = Serialization._StringSerializer.deserialize(dict["shared_folder_id"] ?? .Null)
                    return UnmountFolderArg(sharedFolderId: sharedFolderId)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The UnmountFolderError union
    public enum UnmountFolderError: CustomStringConvertible {
        /// (undocumented)
        case AccessError(Sharing.SharedFolderAccessError)
        /// The current user does not have permission to perform this action.
        case NoPermission
        /// The shared folder can't be unmounted. One example where this can occur is when the shared folder's parent
        /// folder is also a shared folder that resides in the current user's Dropbox.
        case NotUnmountable
        /// (undocumented)
        case Other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(UnmountFolderErrorSerializer().serialize(self)))"
        }
    }
    public class UnmountFolderErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: UnmountFolderError) -> JSON {
            switch value {
                case .AccessError(let arg):
                    var d = ["access_error": Sharing.SharedFolderAccessErrorSerializer().serialize(arg)]
                    d[".tag"] = .Str("access_error")
                    return .Dictionary(d)
                case .NoPermission:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("no_permission")
                    return .Dictionary(d)
                case .NotUnmountable:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("not_unmountable")
                    return .Dictionary(d)
                case .Other:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> UnmountFolderError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "access_error":
                            let v = Sharing.SharedFolderAccessErrorSerializer().deserialize(d["access_error"] ?? .Null)
                            return UnmountFolderError.AccessError(v)
                        case "no_permission":
                            return UnmountFolderError.NoPermission
                        case "not_unmountable":
                            return UnmountFolderError.NotUnmountable
                        case "other":
                            return UnmountFolderError.Other
                        default:
                            return UnmountFolderError.Other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Arguments for unshareFile.
    public class UnshareFileArg: CustomStringConvertible {
        /// The file to unshare.
        public let file: String
        public init(file: String) {
            stringValidator(minLength: 1, pattern: "((/|id:).*|nspath:[^:]*:[^:]*)")(file)
            self.file = file
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(UnshareFileArgSerializer().serialize(self)))"
        }
    }
    public class UnshareFileArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: UnshareFileArg) -> JSON {
            let output = [ 
            "file": Serialization._StringSerializer.serialize(value.file),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> UnshareFileArg {
            switch json {
                case .Dictionary(let dict):
                    let file = Serialization._StringSerializer.deserialize(dict["file"] ?? .Null)
                    return UnshareFileArg(file: file)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Error result for unshareFile.
    public enum UnshareFileError: CustomStringConvertible {
        /// (undocumented)
        case UserError(Sharing.SharingUserError)
        /// (undocumented)
        case AccessError(Sharing.SharingFileAccessError)
        /// (undocumented)
        case Other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(UnshareFileErrorSerializer().serialize(self)))"
        }
    }
    public class UnshareFileErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: UnshareFileError) -> JSON {
            switch value {
                case .UserError(let arg):
                    var d = ["user_error": Sharing.SharingUserErrorSerializer().serialize(arg)]
                    d[".tag"] = .Str("user_error")
                    return .Dictionary(d)
                case .AccessError(let arg):
                    var d = ["access_error": Sharing.SharingFileAccessErrorSerializer().serialize(arg)]
                    d[".tag"] = .Str("access_error")
                    return .Dictionary(d)
                case .Other:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> UnshareFileError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "user_error":
                            let v = Sharing.SharingUserErrorSerializer().deserialize(d["user_error"] ?? .Null)
                            return UnshareFileError.UserError(v)
                        case "access_error":
                            let v = Sharing.SharingFileAccessErrorSerializer().deserialize(d["access_error"] ?? .Null)
                            return UnshareFileError.AccessError(v)
                        case "other":
                            return UnshareFileError.Other
                        default:
                            return UnshareFileError.Other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The UnshareFolderArg struct
    public class UnshareFolderArg: CustomStringConvertible {
        /// The ID for the shared folder.
        public let sharedFolderId: String
        /// If true, members of this shared folder will get a copy of this folder after it's unshared. Otherwise, it
        /// will be removed from their Dropbox. The current user, who is an owner, will always retain their copy.
        public let leaveACopy: Bool
        public init(sharedFolderId: String, leaveACopy: Bool = false) {
            stringValidator(pattern: "[-_0-9a-zA-Z:]+")(sharedFolderId)
            self.sharedFolderId = sharedFolderId
            self.leaveACopy = leaveACopy
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(UnshareFolderArgSerializer().serialize(self)))"
        }
    }
    public class UnshareFolderArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: UnshareFolderArg) -> JSON {
            let output = [ 
            "shared_folder_id": Serialization._StringSerializer.serialize(value.sharedFolderId),
            "leave_a_copy": Serialization._BoolSerializer.serialize(value.leaveACopy),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> UnshareFolderArg {
            switch json {
                case .Dictionary(let dict):
                    let sharedFolderId = Serialization._StringSerializer.deserialize(dict["shared_folder_id"] ?? .Null)
                    let leaveACopy = Serialization._BoolSerializer.deserialize(dict["leave_a_copy"] ?? .Null)
                    return UnshareFolderArg(sharedFolderId: sharedFolderId, leaveACopy: leaveACopy)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The UnshareFolderError union
    public enum UnshareFolderError: CustomStringConvertible {
        /// (undocumented)
        case AccessError(Sharing.SharedFolderAccessError)
        /// This action cannot be performed on a team shared folder.
        case TeamFolder
        /// The current user does not have permission to perform this action.
        case NoPermission
        /// (undocumented)
        case Other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(UnshareFolderErrorSerializer().serialize(self)))"
        }
    }
    public class UnshareFolderErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: UnshareFolderError) -> JSON {
            switch value {
                case .AccessError(let arg):
                    var d = ["access_error": Sharing.SharedFolderAccessErrorSerializer().serialize(arg)]
                    d[".tag"] = .Str("access_error")
                    return .Dictionary(d)
                case .TeamFolder:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("team_folder")
                    return .Dictionary(d)
                case .NoPermission:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("no_permission")
                    return .Dictionary(d)
                case .Other:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> UnshareFolderError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "access_error":
                            let v = Sharing.SharedFolderAccessErrorSerializer().deserialize(d["access_error"] ?? .Null)
                            return UnshareFolderError.AccessError(v)
                        case "team_folder":
                            return UnshareFolderError.TeamFolder
                        case "no_permission":
                            return UnshareFolderError.NoPermission
                        case "other":
                            return UnshareFolderError.Other
                        default:
                            return UnshareFolderError.Other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The UpdateFolderMemberArg struct
    public class UpdateFolderMemberArg: CustomStringConvertible {
        /// The ID for the shared folder.
        public let sharedFolderId: String
        /// The member of the shared folder to update.  Only the dropboxId in MemberSelector may be set at this time.
        public let member: Sharing.MemberSelector
        /// The new access level for member. owner in AccessLevel is disallowed.
        public let accessLevel: Sharing.AccessLevel
        public init(sharedFolderId: String, member: Sharing.MemberSelector, accessLevel: Sharing.AccessLevel) {
            stringValidator(pattern: "[-_0-9a-zA-Z:]+")(sharedFolderId)
            self.sharedFolderId = sharedFolderId
            self.member = member
            self.accessLevel = accessLevel
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(UpdateFolderMemberArgSerializer().serialize(self)))"
        }
    }
    public class UpdateFolderMemberArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: UpdateFolderMemberArg) -> JSON {
            let output = [ 
            "shared_folder_id": Serialization._StringSerializer.serialize(value.sharedFolderId),
            "member": Sharing.MemberSelectorSerializer().serialize(value.member),
            "access_level": Sharing.AccessLevelSerializer().serialize(value.accessLevel),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> UpdateFolderMemberArg {
            switch json {
                case .Dictionary(let dict):
                    let sharedFolderId = Serialization._StringSerializer.deserialize(dict["shared_folder_id"] ?? .Null)
                    let member = Sharing.MemberSelectorSerializer().deserialize(dict["member"] ?? .Null)
                    let accessLevel = Sharing.AccessLevelSerializer().deserialize(dict["access_level"] ?? .Null)
                    return UpdateFolderMemberArg(sharedFolderId: sharedFolderId, member: member, accessLevel: accessLevel)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The UpdateFolderMemberError union
    public enum UpdateFolderMemberError: CustomStringConvertible {
        /// (undocumented)
        case AccessError(Sharing.SharedFolderAccessError)
        /// (undocumented)
        case MemberError(Sharing.SharedFolderMemberError)
        /// If updating the access type required the member to be added to the shared folder and there was an error when
        /// adding the member.
        case NoExplicitAccess(Sharing.AddFolderMemberError)
        /// The current user's account doesn't support this action. An example of this is when downgrading a member from
        /// editor to viewer. This action can only be performed by users that have upgraded to a Pro or Business plan.
        case InsufficientPlan
        /// The current user does not have permission to perform this action.
        case NoPermission
        /// (undocumented)
        case Other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(UpdateFolderMemberErrorSerializer().serialize(self)))"
        }
    }
    public class UpdateFolderMemberErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: UpdateFolderMemberError) -> JSON {
            switch value {
                case .AccessError(let arg):
                    var d = ["access_error": Sharing.SharedFolderAccessErrorSerializer().serialize(arg)]
                    d[".tag"] = .Str("access_error")
                    return .Dictionary(d)
                case .MemberError(let arg):
                    var d = ["member_error": Sharing.SharedFolderMemberErrorSerializer().serialize(arg)]
                    d[".tag"] = .Str("member_error")
                    return .Dictionary(d)
                case .NoExplicitAccess(let arg):
                    var d = ["no_explicit_access": Sharing.AddFolderMemberErrorSerializer().serialize(arg)]
                    d[".tag"] = .Str("no_explicit_access")
                    return .Dictionary(d)
                case .InsufficientPlan:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("insufficient_plan")
                    return .Dictionary(d)
                case .NoPermission:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("no_permission")
                    return .Dictionary(d)
                case .Other:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> UpdateFolderMemberError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "access_error":
                            let v = Sharing.SharedFolderAccessErrorSerializer().deserialize(d["access_error"] ?? .Null)
                            return UpdateFolderMemberError.AccessError(v)
                        case "member_error":
                            let v = Sharing.SharedFolderMemberErrorSerializer().deserialize(d["member_error"] ?? .Null)
                            return UpdateFolderMemberError.MemberError(v)
                        case "no_explicit_access":
                            let v = Sharing.AddFolderMemberErrorSerializer().deserialize(d["no_explicit_access"] ?? .Null)
                            return UpdateFolderMemberError.NoExplicitAccess(v)
                        case "insufficient_plan":
                            return UpdateFolderMemberError.InsufficientPlan
                        case "no_permission":
                            return UpdateFolderMemberError.NoPermission
                        case "other":
                            return UpdateFolderMemberError.Other
                        default:
                            return UpdateFolderMemberError.Other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// If any of the policy's are unset, then they retain their current setting.
    public class UpdateFolderPolicyArg: CustomStringConvertible {
        /// The ID for the shared folder.
        public let sharedFolderId: String
        /// Who can be a member of this shared folder. Only applicable if the current user is on a team.
        public let memberPolicy: Sharing.MemberPolicy?
        /// Who can add and remove members of this shared folder.
        public let aclUpdatePolicy: Sharing.AclUpdatePolicy?
        /// The policy to apply to shared links created for content inside this shared folder. The current user must be
        /// on a team to set this policy to members in SharedLinkPolicy.
        public let sharedLinkPolicy: Sharing.SharedLinkPolicy?
        public init(sharedFolderId: String, memberPolicy: Sharing.MemberPolicy? = nil, aclUpdatePolicy: Sharing.AclUpdatePolicy? = nil, sharedLinkPolicy: Sharing.SharedLinkPolicy? = nil) {
            stringValidator(pattern: "[-_0-9a-zA-Z:]+")(sharedFolderId)
            self.sharedFolderId = sharedFolderId
            self.memberPolicy = memberPolicy
            self.aclUpdatePolicy = aclUpdatePolicy
            self.sharedLinkPolicy = sharedLinkPolicy
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(UpdateFolderPolicyArgSerializer().serialize(self)))"
        }
    }
    public class UpdateFolderPolicyArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: UpdateFolderPolicyArg) -> JSON {
            let output = [ 
            "shared_folder_id": Serialization._StringSerializer.serialize(value.sharedFolderId),
            "member_policy": NullableSerializer(Sharing.MemberPolicySerializer()).serialize(value.memberPolicy),
            "acl_update_policy": NullableSerializer(Sharing.AclUpdatePolicySerializer()).serialize(value.aclUpdatePolicy),
            "shared_link_policy": NullableSerializer(Sharing.SharedLinkPolicySerializer()).serialize(value.sharedLinkPolicy),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> UpdateFolderPolicyArg {
            switch json {
                case .Dictionary(let dict):
                    let sharedFolderId = Serialization._StringSerializer.deserialize(dict["shared_folder_id"] ?? .Null)
                    let memberPolicy = NullableSerializer(Sharing.MemberPolicySerializer()).deserialize(dict["member_policy"] ?? .Null)
                    let aclUpdatePolicy = NullableSerializer(Sharing.AclUpdatePolicySerializer()).deserialize(dict["acl_update_policy"] ?? .Null)
                    let sharedLinkPolicy = NullableSerializer(Sharing.SharedLinkPolicySerializer()).deserialize(dict["shared_link_policy"] ?? .Null)
                    return UpdateFolderPolicyArg(sharedFolderId: sharedFolderId, memberPolicy: memberPolicy, aclUpdatePolicy: aclUpdatePolicy, sharedLinkPolicy: sharedLinkPolicy)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The UpdateFolderPolicyError union
    public enum UpdateFolderPolicyError: CustomStringConvertible {
        /// (undocumented)
        case AccessError(Sharing.SharedFolderAccessError)
        /// memberPolicy in UpdateFolderPolicyArg was set even though user is not on a team.
        case NotOnTeam
        /// Team policy is more restrictive than memberPolicy in ShareFolderArg.
        case TeamPolicyDisallowsMemberPolicy
        /// The current account is not allowed to select the specified sharedLinkPolicy in ShareFolderArg.
        case DisallowedSharedLinkPolicy
        /// (undocumented)
        case Other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(UpdateFolderPolicyErrorSerializer().serialize(self)))"
        }
    }
    public class UpdateFolderPolicyErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: UpdateFolderPolicyError) -> JSON {
            switch value {
                case .AccessError(let arg):
                    var d = ["access_error": Sharing.SharedFolderAccessErrorSerializer().serialize(arg)]
                    d[".tag"] = .Str("access_error")
                    return .Dictionary(d)
                case .NotOnTeam:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("not_on_team")
                    return .Dictionary(d)
                case .TeamPolicyDisallowsMemberPolicy:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("team_policy_disallows_member_policy")
                    return .Dictionary(d)
                case .DisallowedSharedLinkPolicy:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("disallowed_shared_link_policy")
                    return .Dictionary(d)
                case .Other:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> UpdateFolderPolicyError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "access_error":
                            let v = Sharing.SharedFolderAccessErrorSerializer().deserialize(d["access_error"] ?? .Null)
                            return UpdateFolderPolicyError.AccessError(v)
                        case "not_on_team":
                            return UpdateFolderPolicyError.NotOnTeam
                        case "team_policy_disallows_member_policy":
                            return UpdateFolderPolicyError.TeamPolicyDisallowsMemberPolicy
                        case "disallowed_shared_link_policy":
                            return UpdateFolderPolicyError.DisallowedSharedLinkPolicy
                        case "other":
                            return UpdateFolderPolicyError.Other
                        default:
                            return UpdateFolderPolicyError.Other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Basic information about a user. Use usersAccount and usersAccountBatch to obtain more detailed information.
    public class UserInfo: CustomStringConvertible {
        /// The account ID of the user.
        public let accountId: String
        /// If the user is in the same team as current user.
        public let sameTeam: Bool
        /// The team member ID of the shared folder member. Only present if sameTeam is true.
        public let teamMemberId: String?
        public init(accountId: String, sameTeam: Bool, teamMemberId: String? = nil) {
            stringValidator(minLength: 40, maxLength: 40)(accountId)
            self.accountId = accountId
            self.sameTeam = sameTeam
            nullableValidator(stringValidator())(teamMemberId)
            self.teamMemberId = teamMemberId
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(UserInfoSerializer().serialize(self)))"
        }
    }
    public class UserInfoSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: UserInfo) -> JSON {
            let output = [ 
            "account_id": Serialization._StringSerializer.serialize(value.accountId),
            "same_team": Serialization._BoolSerializer.serialize(value.sameTeam),
            "team_member_id": NullableSerializer(Serialization._StringSerializer).serialize(value.teamMemberId),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> UserInfo {
            switch json {
                case .Dictionary(let dict):
                    let accountId = Serialization._StringSerializer.deserialize(dict["account_id"] ?? .Null)
                    let sameTeam = Serialization._BoolSerializer.deserialize(dict["same_team"] ?? .Null)
                    let teamMemberId = NullableSerializer(Serialization._StringSerializer).deserialize(dict["team_member_id"] ?? .Null)
                    return UserInfo(accountId: accountId, sameTeam: sameTeam, teamMemberId: teamMemberId)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The information about a user member of the shared content.
    public class UserMembershipInfo: Sharing.MembershipInfo {
        /// The account information for the membership user.
        public let user: Sharing.UserInfo
        public init(accessType: Sharing.AccessLevel, user: Sharing.UserInfo, permissions: Array<Sharing.MemberPermission>? = nil, initials: String? = nil, isInherited: Bool = false) {
            self.user = user
            super.init(accessType: accessType, permissions: permissions, initials: initials, isInherited: isInherited)
        }
        public override var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(UserMembershipInfoSerializer().serialize(self)))"
        }
    }
    public class UserMembershipInfoSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: UserMembershipInfo) -> JSON {
            let output = [ 
            "access_type": Sharing.AccessLevelSerializer().serialize(value.accessType),
            "user": Sharing.UserInfoSerializer().serialize(value.user),
            "permissions": NullableSerializer(ArraySerializer(Sharing.MemberPermissionSerializer())).serialize(value.permissions),
            "initials": NullableSerializer(Serialization._StringSerializer).serialize(value.initials),
            "is_inherited": Serialization._BoolSerializer.serialize(value.isInherited),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> UserMembershipInfo {
            switch json {
                case .Dictionary(let dict):
                    let accessType = Sharing.AccessLevelSerializer().deserialize(dict["access_type"] ?? .Null)
                    let user = Sharing.UserInfoSerializer().deserialize(dict["user"] ?? .Null)
                    let permissions = NullableSerializer(ArraySerializer(Sharing.MemberPermissionSerializer())).deserialize(dict["permissions"] ?? .Null)
                    let initials = NullableSerializer(Serialization._StringSerializer).deserialize(dict["initials"] ?? .Null)
                    let isInherited = Serialization._BoolSerializer.deserialize(dict["is_inherited"] ?? .Null)
                    return UserMembershipInfo(accessType: accessType, user: user, permissions: permissions, initials: initials, isInherited: isInherited)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Who can access a shared link. The most open visibility is public_. The default depends on many aspects, such as
    /// team and user preferences and shared folder settings.
    public enum Visibility: CustomStringConvertible {
        /// Anyone who has received the link can access it. No login required.
        case Public_
        /// Only members of the same team can access the link. Login is required.
        case TeamOnly
        /// A link-specific password is required to access the link. Login is not required.
        case Password
        /// Only members of the same team who have the link-specific password can access the link.
        case TeamAndPassword
        /// Only members of the shared folder containing the linked file can access the link. Login is required.
        case SharedFolderOnly
        /// An unknown restriction is in place.
        case Other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(VisibilitySerializer().serialize(self)))"
        }
    }
    public class VisibilitySerializer: JSONSerializer {
        public init() { }
        public func serialize(value: Visibility) -> JSON {
            switch value {
                case .Public_:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("public")
                    return .Dictionary(d)
                case .TeamOnly:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("team_only")
                    return .Dictionary(d)
                case .Password:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("password")
                    return .Dictionary(d)
                case .TeamAndPassword:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("team_and_password")
                    return .Dictionary(d)
                case .SharedFolderOnly:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("shared_folder_only")
                    return .Dictionary(d)
                case .Other:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> Visibility {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "public":
                            return Visibility.Public_
                        case "team_only":
                            return Visibility.TeamOnly
                        case "password":
                            return Visibility.Password
                        case "team_and_password":
                            return Visibility.TeamAndPassword
                        case "shared_folder_only":
                            return Visibility.SharedFolderOnly
                        case "other":
                            return Visibility.Other
                        default:
                            return Visibility.Other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }


    /// Stone Route Objects

    static let addFileMember = Route(
        name: "add_file_member",
        namespace: "sharing",
        deprecated: false,
        argSerializer: Sharing.AddFileMemberArgsSerializer(),
        responseSerializer: ArraySerializer(Sharing.FileMemberActionResultSerializer()),
        errorSerializer: Sharing.AddFileMemberErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let addFolderMember = Route(
        name: "add_folder_member",
        namespace: "sharing",
        deprecated: false,
        argSerializer: Sharing.AddFolderMemberArgSerializer(),
        responseSerializer: Serialization._VoidSerializer,
        errorSerializer: Sharing.AddFolderMemberErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let checkJobStatus = Route(
        name: "check_job_status",
        namespace: "sharing",
        deprecated: false,
        argSerializer: Async.PollArgSerializer(),
        responseSerializer: Sharing.JobStatusSerializer(),
        errorSerializer: Async.PollErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let checkRemoveMemberJobStatus = Route(
        name: "check_remove_member_job_status",
        namespace: "sharing",
        deprecated: false,
        argSerializer: Async.PollArgSerializer(),
        responseSerializer: Sharing.RemoveMemberJobStatusSerializer(),
        errorSerializer: Async.PollErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let checkShareJobStatus = Route(
        name: "check_share_job_status",
        namespace: "sharing",
        deprecated: false,
        argSerializer: Async.PollArgSerializer(),
        responseSerializer: Sharing.ShareFolderJobStatusSerializer(),
        errorSerializer: Async.PollErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let createSharedLink = Route(
        name: "create_shared_link",
        namespace: "sharing",
        deprecated: true,
        argSerializer: Sharing.CreateSharedLinkArgSerializer(),
        responseSerializer: Sharing.PathLinkMetadataSerializer(),
        errorSerializer: Sharing.CreateSharedLinkErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let createSharedLinkWithSettings = Route(
        name: "create_shared_link_with_settings",
        namespace: "sharing",
        deprecated: false,
        argSerializer: Sharing.CreateSharedLinkWithSettingsArgSerializer(),
        responseSerializer: Sharing.SharedLinkMetadataSerializer(),
        errorSerializer: Sharing.CreateSharedLinkWithSettingsErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let getFileMetadata = Route(
        name: "get_file_metadata",
        namespace: "sharing",
        deprecated: false,
        argSerializer: Sharing.GetFileMetadataArgSerializer(),
        responseSerializer: Sharing.SharedFileMetadataSerializer(),
        errorSerializer: Sharing.GetFileMetadataErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let getFileMetadataBatch = Route(
        name: "get_file_metadata/batch",
        namespace: "sharing",
        deprecated: false,
        argSerializer: Sharing.GetFileMetadataBatchArgSerializer(),
        responseSerializer: ArraySerializer(Sharing.GetFileMetadataBatchResultSerializer()),
        errorSerializer: Sharing.SharingUserErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let getFolderMetadata = Route(
        name: "get_folder_metadata",
        namespace: "sharing",
        deprecated: false,
        argSerializer: Sharing.GetMetadataArgsSerializer(),
        responseSerializer: Sharing.SharedFolderMetadataSerializer(),
        errorSerializer: Sharing.SharedFolderAccessErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let getSharedLinkFile = Route(
        name: "get_shared_link_file",
        namespace: "sharing",
        deprecated: false,
        argSerializer: Sharing.GetSharedLinkMetadataArgSerializer(),
        responseSerializer: Sharing.SharedLinkMetadataSerializer(),
        errorSerializer: Sharing.GetSharedLinkFileErrorSerializer(),
        attrs: ["host": "content",
                "style": "download"]
    )
    static let getSharedLinkMetadata = Route(
        name: "get_shared_link_metadata",
        namespace: "sharing",
        deprecated: false,
        argSerializer: Sharing.GetSharedLinkMetadataArgSerializer(),
        responseSerializer: Sharing.SharedLinkMetadataSerializer(),
        errorSerializer: Sharing.SharedLinkErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let getSharedLinks = Route(
        name: "get_shared_links",
        namespace: "sharing",
        deprecated: true,
        argSerializer: Sharing.GetSharedLinksArgSerializer(),
        responseSerializer: Sharing.GetSharedLinksResultSerializer(),
        errorSerializer: Sharing.GetSharedLinksErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let listFileMembers = Route(
        name: "list_file_members",
        namespace: "sharing",
        deprecated: false,
        argSerializer: Sharing.ListFileMembersArgSerializer(),
        responseSerializer: Sharing.SharedFileMembersSerializer(),
        errorSerializer: Sharing.ListFileMembersErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let listFileMembersBatch = Route(
        name: "list_file_members/batch",
        namespace: "sharing",
        deprecated: false,
        argSerializer: Sharing.ListFileMembersBatchArgSerializer(),
        responseSerializer: ArraySerializer(Sharing.ListFileMembersBatchResultSerializer()),
        errorSerializer: Sharing.SharingUserErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let listFileMembersContinue = Route(
        name: "list_file_members/continue",
        namespace: "sharing",
        deprecated: false,
        argSerializer: Sharing.ListFileMembersContinueArgSerializer(),
        responseSerializer: Sharing.SharedFileMembersSerializer(),
        errorSerializer: Sharing.ListFileMembersContinueErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let listFolderMembers = Route(
        name: "list_folder_members",
        namespace: "sharing",
        deprecated: false,
        argSerializer: Sharing.ListFolderMembersArgsSerializer(),
        responseSerializer: Sharing.SharedFolderMembersSerializer(),
        errorSerializer: Sharing.SharedFolderAccessErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let listFolderMembersContinue = Route(
        name: "list_folder_members/continue",
        namespace: "sharing",
        deprecated: false,
        argSerializer: Sharing.ListFolderMembersContinueArgSerializer(),
        responseSerializer: Sharing.SharedFolderMembersSerializer(),
        errorSerializer: Sharing.ListFolderMembersContinueErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let listFolders = Route(
        name: "list_folders",
        namespace: "sharing",
        deprecated: false,
        argSerializer: Sharing.ListFoldersArgsSerializer(),
        responseSerializer: Sharing.ListFoldersResultSerializer(),
        errorSerializer: Serialization._VoidSerializer,
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let listFoldersContinue = Route(
        name: "list_folders/continue",
        namespace: "sharing",
        deprecated: false,
        argSerializer: Sharing.ListFoldersContinueArgSerializer(),
        responseSerializer: Sharing.ListFoldersResultSerializer(),
        errorSerializer: Sharing.ListFoldersContinueErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let listMountableFolders = Route(
        name: "list_mountable_folders",
        namespace: "sharing",
        deprecated: false,
        argSerializer: Sharing.ListFoldersArgsSerializer(),
        responseSerializer: Sharing.ListFoldersResultSerializer(),
        errorSerializer: Serialization._VoidSerializer,
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let listMountableFoldersContinue = Route(
        name: "list_mountable_folders/continue",
        namespace: "sharing",
        deprecated: false,
        argSerializer: Sharing.ListFoldersContinueArgSerializer(),
        responseSerializer: Sharing.ListFoldersResultSerializer(),
        errorSerializer: Sharing.ListFoldersContinueErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let listReceivedFiles = Route(
        name: "list_received_files",
        namespace: "sharing",
        deprecated: false,
        argSerializer: Sharing.ListFilesArgSerializer(),
        responseSerializer: Sharing.ListFilesResultSerializer(),
        errorSerializer: Sharing.SharingUserErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let listReceivedFilesContinue = Route(
        name: "list_received_files/continue",
        namespace: "sharing",
        deprecated: false,
        argSerializer: Sharing.ListFilesContinueArgSerializer(),
        responseSerializer: Sharing.ListFilesResultSerializer(),
        errorSerializer: Sharing.ListFilesContinueErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let listSharedLinks = Route(
        name: "list_shared_links",
        namespace: "sharing",
        deprecated: false,
        argSerializer: Sharing.ListSharedLinksArgSerializer(),
        responseSerializer: Sharing.ListSharedLinksResultSerializer(),
        errorSerializer: Sharing.ListSharedLinksErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let modifySharedLinkSettings = Route(
        name: "modify_shared_link_settings",
        namespace: "sharing",
        deprecated: false,
        argSerializer: Sharing.ModifySharedLinkSettingsArgsSerializer(),
        responseSerializer: Sharing.SharedLinkMetadataSerializer(),
        errorSerializer: Sharing.ModifySharedLinkSettingsErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let mountFolder = Route(
        name: "mount_folder",
        namespace: "sharing",
        deprecated: false,
        argSerializer: Sharing.MountFolderArgSerializer(),
        responseSerializer: Sharing.SharedFolderMetadataSerializer(),
        errorSerializer: Sharing.MountFolderErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let relinquishFileMembership = Route(
        name: "relinquish_file_membership",
        namespace: "sharing",
        deprecated: false,
        argSerializer: Sharing.RelinquishFileMembershipArgSerializer(),
        responseSerializer: Serialization._VoidSerializer,
        errorSerializer: Sharing.RelinquishFileMembershipErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let relinquishFolderMembership = Route(
        name: "relinquish_folder_membership",
        namespace: "sharing",
        deprecated: false,
        argSerializer: Sharing.RelinquishFolderMembershipArgSerializer(),
        responseSerializer: Async.LaunchEmptyResultSerializer(),
        errorSerializer: Sharing.RelinquishFolderMembershipErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let removeFileMember = Route(
        name: "remove_file_member",
        namespace: "sharing",
        deprecated: true,
        argSerializer: Sharing.RemoveFileMemberArgSerializer(),
        responseSerializer: Sharing.FileMemberActionIndividualResultSerializer(),
        errorSerializer: Sharing.RemoveFileMemberErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let removeFileMember2 = Route(
        name: "remove_file_member_2",
        namespace: "sharing",
        deprecated: false,
        argSerializer: Sharing.RemoveFileMemberArgSerializer(),
        responseSerializer: Sharing.FileMemberRemoveActionResultSerializer(),
        errorSerializer: Sharing.RemoveFileMemberErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let removeFolderMember = Route(
        name: "remove_folder_member",
        namespace: "sharing",
        deprecated: false,
        argSerializer: Sharing.RemoveFolderMemberArgSerializer(),
        responseSerializer: Async.LaunchResultBaseSerializer(),
        errorSerializer: Sharing.RemoveFolderMemberErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let revokeSharedLink = Route(
        name: "revoke_shared_link",
        namespace: "sharing",
        deprecated: false,
        argSerializer: Sharing.RevokeSharedLinkArgSerializer(),
        responseSerializer: Serialization._VoidSerializer,
        errorSerializer: Sharing.RevokeSharedLinkErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let shareFolder = Route(
        name: "share_folder",
        namespace: "sharing",
        deprecated: false,
        argSerializer: Sharing.ShareFolderArgSerializer(),
        responseSerializer: Sharing.ShareFolderLaunchSerializer(),
        errorSerializer: Sharing.ShareFolderErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let transferFolder = Route(
        name: "transfer_folder",
        namespace: "sharing",
        deprecated: false,
        argSerializer: Sharing.TransferFolderArgSerializer(),
        responseSerializer: Serialization._VoidSerializer,
        errorSerializer: Sharing.TransferFolderErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let unmountFolder = Route(
        name: "unmount_folder",
        namespace: "sharing",
        deprecated: false,
        argSerializer: Sharing.UnmountFolderArgSerializer(),
        responseSerializer: Serialization._VoidSerializer,
        errorSerializer: Sharing.UnmountFolderErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let unshareFile = Route(
        name: "unshare_file",
        namespace: "sharing",
        deprecated: false,
        argSerializer: Sharing.UnshareFileArgSerializer(),
        responseSerializer: Serialization._VoidSerializer,
        errorSerializer: Sharing.UnshareFileErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let unshareFolder = Route(
        name: "unshare_folder",
        namespace: "sharing",
        deprecated: false,
        argSerializer: Sharing.UnshareFolderArgSerializer(),
        responseSerializer: Async.LaunchEmptyResultSerializer(),
        errorSerializer: Sharing.UnshareFolderErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let updateFolderMember = Route(
        name: "update_folder_member",
        namespace: "sharing",
        deprecated: false,
        argSerializer: Sharing.UpdateFolderMemberArgSerializer(),
        responseSerializer: Sharing.MemberAccessLevelResultSerializer(),
        errorSerializer: Sharing.UpdateFolderMemberErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let updateFolderPolicy = Route(
        name: "update_folder_policy",
        namespace: "sharing",
        deprecated: false,
        argSerializer: Sharing.UpdateFolderPolicyArgSerializer(),
        responseSerializer: Sharing.SharedFolderMetadataSerializer(),
        errorSerializer: Sharing.UpdateFolderPolicyErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
}
