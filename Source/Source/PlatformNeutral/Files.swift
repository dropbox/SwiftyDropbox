///
/// Copyright (c) 2016 Dropbox, Inc. All rights reserved.
///
/// Auto-generated by Stone, do not modify.
///

import Foundation

/// Datatypes and serializers for the files namespace
public class Files {
    /// The PropertiesError union
    public enum PropertiesError: CustomStringConvertible {
        /// Property template does not exist for given identifier.
        case templateNotFound(String)
        /// You do not have the permissions to modify this property template.
        case restrictedContent
        /// An unspecified error.
        case other
        /// An unspecified error.
        case path(Files.LookupError)

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PropertiesErrorSerializer().serialize(self)))"
        }
    }
    public class PropertiesErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: PropertiesError) -> JSON {
            switch value {
                case .templateNotFound(let arg):
                    var d = ["template_not_found": Serialization._StringSerializer.serialize(arg)]
                    d[".tag"] = .str("template_not_found")
                    return .dictionary(d)
                case .restrictedContent:
                    var d = [String: JSON]()
                    d[".tag"] = .str("restricted_content")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
                case .path(let arg):
                    var d = ["path": Files.LookupErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("path")
                    return .dictionary(d)
            }
        }
        public func deserialize(_ json: JSON) -> PropertiesError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "template_not_found":
                            let v = Serialization._StringSerializer.deserialize(d["template_not_found"] ?? .null)
                            return PropertiesError.templateNotFound(v)
                        case "restricted_content":
                            return PropertiesError.restrictedContent
                        case "other":
                            return PropertiesError.other
                        case "path":
                            let v = Files.LookupErrorSerializer().deserialize(d["path"] ?? .null)
                            return PropertiesError.path(v)
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The InvalidPropertyGroupError union
    public enum InvalidPropertyGroupError: CustomStringConvertible {
        /// Property template does not exist for given identifier.
        case templateNotFound(String)
        /// You do not have the permissions to modify this property template.
        case restrictedContent
        /// An unspecified error.
        case other
        /// An unspecified error.
        case path(Files.LookupError)
        /// A field value in this property group is too large.
        case propertyFieldTooLarge
        /// The property group specified does not conform to the property template.
        case doesNotFitTemplate

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(InvalidPropertyGroupErrorSerializer().serialize(self)))"
        }
    }
    public class InvalidPropertyGroupErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: InvalidPropertyGroupError) -> JSON {
            switch value {
                case .templateNotFound(let arg):
                    var d = ["template_not_found": Serialization._StringSerializer.serialize(arg)]
                    d[".tag"] = .str("template_not_found")
                    return .dictionary(d)
                case .restrictedContent:
                    var d = [String: JSON]()
                    d[".tag"] = .str("restricted_content")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
                case .path(let arg):
                    var d = ["path": Files.LookupErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("path")
                    return .dictionary(d)
                case .propertyFieldTooLarge:
                    var d = [String: JSON]()
                    d[".tag"] = .str("property_field_too_large")
                    return .dictionary(d)
                case .doesNotFitTemplate:
                    var d = [String: JSON]()
                    d[".tag"] = .str("does_not_fit_template")
                    return .dictionary(d)
            }
        }
        public func deserialize(_ json: JSON) -> InvalidPropertyGroupError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "template_not_found":
                            let v = Serialization._StringSerializer.deserialize(d["template_not_found"] ?? .null)
                            return InvalidPropertyGroupError.templateNotFound(v)
                        case "restricted_content":
                            return InvalidPropertyGroupError.restrictedContent
                        case "other":
                            return InvalidPropertyGroupError.other
                        case "path":
                            let v = Files.LookupErrorSerializer().deserialize(d["path"] ?? .null)
                            return InvalidPropertyGroupError.path(v)
                        case "property_field_too_large":
                            return InvalidPropertyGroupError.propertyFieldTooLarge
                        case "does_not_fit_template":
                            return InvalidPropertyGroupError.doesNotFitTemplate
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The AddPropertiesError union
    public enum AddPropertiesError: CustomStringConvertible {
        /// Property template does not exist for given identifier.
        case templateNotFound(String)
        /// You do not have the permissions to modify this property template.
        case restrictedContent
        /// An unspecified error.
        case other
        /// An unspecified error.
        case path(Files.LookupError)
        /// A field value in this property group is too large.
        case propertyFieldTooLarge
        /// The property group specified does not conform to the property template.
        case doesNotFitTemplate
        /// This property group already exists for this file.
        case propertyGroupAlreadyExists

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(AddPropertiesErrorSerializer().serialize(self)))"
        }
    }
    public class AddPropertiesErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: AddPropertiesError) -> JSON {
            switch value {
                case .templateNotFound(let arg):
                    var d = ["template_not_found": Serialization._StringSerializer.serialize(arg)]
                    d[".tag"] = .str("template_not_found")
                    return .dictionary(d)
                case .restrictedContent:
                    var d = [String: JSON]()
                    d[".tag"] = .str("restricted_content")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
                case .path(let arg):
                    var d = ["path": Files.LookupErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("path")
                    return .dictionary(d)
                case .propertyFieldTooLarge:
                    var d = [String: JSON]()
                    d[".tag"] = .str("property_field_too_large")
                    return .dictionary(d)
                case .doesNotFitTemplate:
                    var d = [String: JSON]()
                    d[".tag"] = .str("does_not_fit_template")
                    return .dictionary(d)
                case .propertyGroupAlreadyExists:
                    var d = [String: JSON]()
                    d[".tag"] = .str("property_group_already_exists")
                    return .dictionary(d)
            }
        }
        public func deserialize(_ json: JSON) -> AddPropertiesError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "template_not_found":
                            let v = Serialization._StringSerializer.deserialize(d["template_not_found"] ?? .null)
                            return AddPropertiesError.templateNotFound(v)
                        case "restricted_content":
                            return AddPropertiesError.restrictedContent
                        case "other":
                            return AddPropertiesError.other
                        case "path":
                            let v = Files.LookupErrorSerializer().deserialize(d["path"] ?? .null)
                            return AddPropertiesError.path(v)
                        case "property_field_too_large":
                            return AddPropertiesError.propertyFieldTooLarge
                        case "does_not_fit_template":
                            return AddPropertiesError.doesNotFitTemplate
                        case "property_group_already_exists":
                            return AddPropertiesError.propertyGroupAlreadyExists
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The GetMetadataArg struct
    public class GetMetadataArg: CustomStringConvertible {
        /// The path of a file or folder on Dropbox.
        public let path: String
        /// If true, mediaInfo in FileMetadata is set for photo and video.
        public let includeMediaInfo: Bool
        /// If true, DeletedMetadata will be returned for deleted file or folder, otherwise notFound in LookupError will
        /// be returned.
        public let includeDeleted: Bool
        /// If true, the results will include a flag for each file indicating whether or not  that file has any explicit
        /// members.
        public let includeHasExplicitSharedMembers: Bool
        public init(path: String, includeMediaInfo: Bool = false, includeDeleted: Bool = false, includeHasExplicitSharedMembers: Bool = false) {
            stringValidator(pattern: "(/(.|[\\r\\n])*|id:.*)|(rev:[0-9a-f]{9,})|(ns:[0-9]+(/.*)?)")(path)
            self.path = path
            self.includeMediaInfo = includeMediaInfo
            self.includeDeleted = includeDeleted
            self.includeHasExplicitSharedMembers = includeHasExplicitSharedMembers
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GetMetadataArgSerializer().serialize(self)))"
        }
    }
    public class GetMetadataArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: GetMetadataArg) -> JSON {
            let output = [ 
            "path": Serialization._StringSerializer.serialize(value.path),
            "include_media_info": Serialization._BoolSerializer.serialize(value.includeMediaInfo),
            "include_deleted": Serialization._BoolSerializer.serialize(value.includeDeleted),
            "include_has_explicit_shared_members": Serialization._BoolSerializer.serialize(value.includeHasExplicitSharedMembers),
            ]
            return .dictionary(output)
        }
        public func deserialize(_ json: JSON) -> GetMetadataArg {
            switch json {
                case .dictionary(let dict):
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .null)
                    let includeMediaInfo = Serialization._BoolSerializer.deserialize(dict["include_media_info"] ?? .number(0))
                    let includeDeleted = Serialization._BoolSerializer.deserialize(dict["include_deleted"] ?? .number(0))
                    let includeHasExplicitSharedMembers = Serialization._BoolSerializer.deserialize(dict["include_has_explicit_shared_members"] ?? .number(0))
                    return GetMetadataArg(path: path, includeMediaInfo: includeMediaInfo, includeDeleted: includeDeleted, includeHasExplicitSharedMembers: includeHasExplicitSharedMembers)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The AlphaGetMetadataArg struct
    public class AlphaGetMetadataArg: Files.GetMetadataArg {
        /// If set to a valid list of template IDs, propertyGroups in FileMetadata is set for files with custom
        /// properties.
        public let includePropertyTemplates: Array<String>?
        public init(path: String, includeMediaInfo: Bool = false, includeDeleted: Bool = false, includeHasExplicitSharedMembers: Bool = false, includePropertyTemplates: Array<String>? = nil) {
            nullableValidator(arrayValidator(itemValidator: stringValidator(minLength: 1, pattern: "(/|ptid:).*")))(includePropertyTemplates)
            self.includePropertyTemplates = includePropertyTemplates
            super.init(path: path, includeMediaInfo: includeMediaInfo, includeDeleted: includeDeleted, includeHasExplicitSharedMembers: includeHasExplicitSharedMembers)
        }
        public override var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(AlphaGetMetadataArgSerializer().serialize(self)))"
        }
    }
    public class AlphaGetMetadataArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: AlphaGetMetadataArg) -> JSON {
            let output = [ 
            "path": Serialization._StringSerializer.serialize(value.path),
            "include_media_info": Serialization._BoolSerializer.serialize(value.includeMediaInfo),
            "include_deleted": Serialization._BoolSerializer.serialize(value.includeDeleted),
            "include_has_explicit_shared_members": Serialization._BoolSerializer.serialize(value.includeHasExplicitSharedMembers),
            "include_property_templates": NullableSerializer(ArraySerializer(Serialization._StringSerializer)).serialize(value.includePropertyTemplates),
            ]
            return .dictionary(output)
        }
        public func deserialize(_ json: JSON) -> AlphaGetMetadataArg {
            switch json {
                case .dictionary(let dict):
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .null)
                    let includeMediaInfo = Serialization._BoolSerializer.deserialize(dict["include_media_info"] ?? .number(0))
                    let includeDeleted = Serialization._BoolSerializer.deserialize(dict["include_deleted"] ?? .number(0))
                    let includeHasExplicitSharedMembers = Serialization._BoolSerializer.deserialize(dict["include_has_explicit_shared_members"] ?? .number(0))
                    let includePropertyTemplates = NullableSerializer(ArraySerializer(Serialization._StringSerializer)).deserialize(dict["include_property_templates"] ?? .null)
                    return AlphaGetMetadataArg(path: path, includeMediaInfo: includeMediaInfo, includeDeleted: includeDeleted, includeHasExplicitSharedMembers: includeHasExplicitSharedMembers, includePropertyTemplates: includePropertyTemplates)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The GetMetadataError union
    public enum GetMetadataError: CustomStringConvertible {
        /// An unspecified error.
        case path(Files.LookupError)

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GetMetadataErrorSerializer().serialize(self)))"
        }
    }
    public class GetMetadataErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: GetMetadataError) -> JSON {
            switch value {
                case .path(let arg):
                    var d = ["path": Files.LookupErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("path")
                    return .dictionary(d)
            }
        }
        public func deserialize(_ json: JSON) -> GetMetadataError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "path":
                            let v = Files.LookupErrorSerializer().deserialize(d["path"] ?? .null)
                            return GetMetadataError.path(v)
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The AlphaGetMetadataError union
    public enum AlphaGetMetadataError: CustomStringConvertible {
        /// An unspecified error.
        case path(Files.LookupError)
        /// An unspecified error.
        case propertiesError(Files.LookUpPropertiesError)

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(AlphaGetMetadataErrorSerializer().serialize(self)))"
        }
    }
    public class AlphaGetMetadataErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: AlphaGetMetadataError) -> JSON {
            switch value {
                case .path(let arg):
                    var d = ["path": Files.LookupErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("path")
                    return .dictionary(d)
                case .propertiesError(let arg):
                    var d = ["properties_error": Files.LookUpPropertiesErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("properties_error")
                    return .dictionary(d)
            }
        }
        public func deserialize(_ json: JSON) -> AlphaGetMetadataError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "path":
                            let v = Files.LookupErrorSerializer().deserialize(d["path"] ?? .null)
                            return AlphaGetMetadataError.path(v)
                        case "properties_error":
                            let v = Files.LookUpPropertiesErrorSerializer().deserialize(d["properties_error"] ?? .null)
                            return AlphaGetMetadataError.propertiesError(v)
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The CommitInfo struct
    public class CommitInfo: CustomStringConvertible {
        /// Path in the user's Dropbox to save the file.
        public let path: String
        /// Selects what to do if the file already exists.
        public let mode: Files.WriteMode
        /// If there's a conflict, as determined by mode, have the Dropbox server try to autorename the file to avoid
        /// conflict.
        public let autorename: Bool
        /// The value to store as the clientModified timestamp. Dropbox automatically records the time at which the file
        /// was written to the Dropbox servers. It can also record an additional timestamp, provided by Dropbox desktop
        /// clients, mobile clients, and API apps of when the file was actually created or modified.
        public let clientModified: Date?
        /// Normally, users are made aware of any file modifications in their Dropbox account via notifications in the
        /// client software. If true, this tells the clients that this modification shouldn't result in a user
        /// notification.
        public let mute: Bool
        public init(path: String, mode: Files.WriteMode = .add, autorename: Bool = false, clientModified: Date? = nil, mute: Bool = false) {
            stringValidator(pattern: "(/(.|[\\r\\n])*)|(ns:[0-9]+(/.*)?)")(path)
            self.path = path
            self.mode = mode
            self.autorename = autorename
            self.clientModified = clientModified
            self.mute = mute
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(CommitInfoSerializer().serialize(self)))"
        }
    }
    public class CommitInfoSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: CommitInfo) -> JSON {
            let output = [ 
            "path": Serialization._StringSerializer.serialize(value.path),
            "mode": Files.WriteModeSerializer().serialize(value.mode),
            "autorename": Serialization._BoolSerializer.serialize(value.autorename),
            "client_modified": NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.clientModified),
            "mute": Serialization._BoolSerializer.serialize(value.mute),
            ]
            return .dictionary(output)
        }
        public func deserialize(_ json: JSON) -> CommitInfo {
            switch json {
                case .dictionary(let dict):
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .null)
                    let mode = Files.WriteModeSerializer().deserialize(dict["mode"] ?? Files.WriteModeSerializer().serialize(.add))
                    let autorename = Serialization._BoolSerializer.deserialize(dict["autorename"] ?? .number(0))
                    let clientModified = NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).deserialize(dict["client_modified"] ?? .null)
                    let mute = Serialization._BoolSerializer.deserialize(dict["mute"] ?? .number(0))
                    return CommitInfo(path: path, mode: mode, autorename: autorename, clientModified: clientModified, mute: mute)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The CommitInfoWithProperties struct
    public class CommitInfoWithProperties: Files.CommitInfo {
        /// List of custom properties to add to file.
        public let propertyGroups: Array<Properties.PropertyGroup>?
        public init(path: String, mode: Files.WriteMode = .add, autorename: Bool = false, clientModified: Date? = nil, mute: Bool = false, propertyGroups: Array<Properties.PropertyGroup>? = nil) {
            self.propertyGroups = propertyGroups
            super.init(path: path, mode: mode, autorename: autorename, clientModified: clientModified, mute: mute)
        }
        public override var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(CommitInfoWithPropertiesSerializer().serialize(self)))"
        }
    }
    public class CommitInfoWithPropertiesSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: CommitInfoWithProperties) -> JSON {
            let output = [ 
            "path": Serialization._StringSerializer.serialize(value.path),
            "mode": Files.WriteModeSerializer().serialize(value.mode),
            "autorename": Serialization._BoolSerializer.serialize(value.autorename),
            "client_modified": NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.clientModified),
            "mute": Serialization._BoolSerializer.serialize(value.mute),
            "property_groups": NullableSerializer(ArraySerializer(Properties.PropertyGroupSerializer())).serialize(value.propertyGroups),
            ]
            return .dictionary(output)
        }
        public func deserialize(_ json: JSON) -> CommitInfoWithProperties {
            switch json {
                case .dictionary(let dict):
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .null)
                    let mode = Files.WriteModeSerializer().deserialize(dict["mode"] ?? Files.WriteModeSerializer().serialize(.add))
                    let autorename = Serialization._BoolSerializer.deserialize(dict["autorename"] ?? .number(0))
                    let clientModified = NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).deserialize(dict["client_modified"] ?? .null)
                    let mute = Serialization._BoolSerializer.deserialize(dict["mute"] ?? .number(0))
                    let propertyGroups = NullableSerializer(ArraySerializer(Properties.PropertyGroupSerializer())).deserialize(dict["property_groups"] ?? .null)
                    return CommitInfoWithProperties(path: path, mode: mode, autorename: autorename, clientModified: clientModified, mute: mute, propertyGroups: propertyGroups)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The CreateFolderArg struct
    public class CreateFolderArg: CustomStringConvertible {
        /// Path in the user's Dropbox to create.
        public let path: String
        public init(path: String) {
            stringValidator(pattern: "(/(.|[\\r\\n])*)|(ns:[0-9]+(/.*)?)")(path)
            self.path = path
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(CreateFolderArgSerializer().serialize(self)))"
        }
    }
    public class CreateFolderArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: CreateFolderArg) -> JSON {
            let output = [ 
            "path": Serialization._StringSerializer.serialize(value.path),
            ]
            return .dictionary(output)
        }
        public func deserialize(_ json: JSON) -> CreateFolderArg {
            switch json {
                case .dictionary(let dict):
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .null)
                    return CreateFolderArg(path: path)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The CreateFolderError union
    public enum CreateFolderError: CustomStringConvertible {
        /// An unspecified error.
        case path(Files.WriteError)

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(CreateFolderErrorSerializer().serialize(self)))"
        }
    }
    public class CreateFolderErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: CreateFolderError) -> JSON {
            switch value {
                case .path(let arg):
                    var d = ["path": Files.WriteErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("path")
                    return .dictionary(d)
            }
        }
        public func deserialize(_ json: JSON) -> CreateFolderError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "path":
                            let v = Files.WriteErrorSerializer().deserialize(d["path"] ?? .null)
                            return CreateFolderError.path(v)
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The DeleteArg struct
    public class DeleteArg: CustomStringConvertible {
        /// Path in the user's Dropbox to delete.
        public let path: String
        public init(path: String) {
            stringValidator(pattern: "(/(.|[\\r\\n])*)|(ns:[0-9]+(/.*)?)")(path)
            self.path = path
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(DeleteArgSerializer().serialize(self)))"
        }
    }
    public class DeleteArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: DeleteArg) -> JSON {
            let output = [ 
            "path": Serialization._StringSerializer.serialize(value.path),
            ]
            return .dictionary(output)
        }
        public func deserialize(_ json: JSON) -> DeleteArg {
            switch json {
                case .dictionary(let dict):
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .null)
                    return DeleteArg(path: path)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The DeleteError union
    public enum DeleteError: CustomStringConvertible {
        /// An unspecified error.
        case pathLookup(Files.LookupError)
        /// An unspecified error.
        case pathWrite(Files.WriteError)
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(DeleteErrorSerializer().serialize(self)))"
        }
    }
    public class DeleteErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: DeleteError) -> JSON {
            switch value {
                case .pathLookup(let arg):
                    var d = ["path_lookup": Files.LookupErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("path_lookup")
                    return .dictionary(d)
                case .pathWrite(let arg):
                    var d = ["path_write": Files.WriteErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("path_write")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        public func deserialize(_ json: JSON) -> DeleteError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "path_lookup":
                            let v = Files.LookupErrorSerializer().deserialize(d["path_lookup"] ?? .null)
                            return DeleteError.pathLookup(v)
                        case "path_write":
                            let v = Files.WriteErrorSerializer().deserialize(d["path_write"] ?? .null)
                            return DeleteError.pathWrite(v)
                        case "other":
                            return DeleteError.other
                        default:
                            return DeleteError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Metadata for a file or folder.
    public class Metadata: CustomStringConvertible {
        /// The last component of the path (including extension). This never contains a slash.
        public let name: String
        /// The lowercased full path in the user's Dropbox. This always starts with a slash. This field will be null if
        /// the file or folder is not mounted.
        public let pathLower: String?
        /// The cased path to be used for display purposes only. In rare instances the casing will not correctly match
        /// the user's filesystem, but this behavior will match the path provided in the Core API v1. Changes to the
        /// casing of paths won't be returned by listFolderContinue. This field will be null if the file or folder is
        /// not mounted.
        public let pathDisplay: String?
        /// Deprecated. Please use parentSharedFolderId in FileSharingInfo or parentSharedFolderId in FolderSharingInfo
        /// instead.
        public let parentSharedFolderId: String?
        public init(name: String, pathLower: String? = nil, pathDisplay: String? = nil, parentSharedFolderId: String? = nil) {
            stringValidator()(name)
            self.name = name
            nullableValidator(stringValidator())(pathLower)
            self.pathLower = pathLower
            nullableValidator(stringValidator())(pathDisplay)
            self.pathDisplay = pathDisplay
            nullableValidator(stringValidator(pattern: "[-_0-9a-zA-Z:]+"))(parentSharedFolderId)
            self.parentSharedFolderId = parentSharedFolderId
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MetadataSerializer().serialize(self)))"
        }
    }
    public class MetadataSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: Metadata) -> JSON {
            var output = [ 
            "name": Serialization._StringSerializer.serialize(value.name),
            "path_lower": NullableSerializer(Serialization._StringSerializer).serialize(value.pathLower),
            "path_display": NullableSerializer(Serialization._StringSerializer).serialize(value.pathDisplay),
            "parent_shared_folder_id": NullableSerializer(Serialization._StringSerializer).serialize(value.parentSharedFolderId),
            ]
            switch value {
                case let file as Files.FileMetadata:
                    for (k, v) in Serialization.getFields(Files.FileMetadataSerializer().serialize(file)) {
                        output[k] = v
                    }
                    output[".tag"] = .str("file")
                case let folder as Files.FolderMetadata:
                    for (k, v) in Serialization.getFields(Files.FolderMetadataSerializer().serialize(folder)) {
                        output[k] = v
                    }
                    output[".tag"] = .str("folder")
                case let deleted as Files.DeletedMetadata:
                    for (k, v) in Serialization.getFields(Files.DeletedMetadataSerializer().serialize(deleted)) {
                        output[k] = v
                    }
                    output[".tag"] = .str("deleted")
                default: fatalError("Tried to serialize unexpected subtype")
            }
            return .dictionary(output)
        }
        public func deserialize(_ json: JSON) -> Metadata {
            switch json {
                case .dictionary(let dict):
                    let tag = Serialization.getTag(dict)
                    switch tag {
                        case "file":
                            return Files.FileMetadataSerializer().deserialize(json)
                        case "folder":
                            return Files.FolderMetadataSerializer().deserialize(json)
                        case "deleted":
                            return Files.DeletedMetadataSerializer().deserialize(json)
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Indicates that there used to be a file or folder at this path, but it no longer exists.
    public class DeletedMetadata: Files.Metadata {
        public override var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(DeletedMetadataSerializer().serialize(self)))"
        }
    }
    public class DeletedMetadataSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: DeletedMetadata) -> JSON {
            let output = [ 
            "name": Serialization._StringSerializer.serialize(value.name),
            "path_lower": NullableSerializer(Serialization._StringSerializer).serialize(value.pathLower),
            "path_display": NullableSerializer(Serialization._StringSerializer).serialize(value.pathDisplay),
            "parent_shared_folder_id": NullableSerializer(Serialization._StringSerializer).serialize(value.parentSharedFolderId),
            ]
            return .dictionary(output)
        }
        public func deserialize(_ json: JSON) -> DeletedMetadata {
            switch json {
                case .dictionary(let dict):
                    let name = Serialization._StringSerializer.deserialize(dict["name"] ?? .null)
                    let pathLower = NullableSerializer(Serialization._StringSerializer).deserialize(dict["path_lower"] ?? .null)
                    let pathDisplay = NullableSerializer(Serialization._StringSerializer).deserialize(dict["path_display"] ?? .null)
                    let parentSharedFolderId = NullableSerializer(Serialization._StringSerializer).deserialize(dict["parent_shared_folder_id"] ?? .null)
                    return DeletedMetadata(name: name, pathLower: pathLower, pathDisplay: pathDisplay, parentSharedFolderId: parentSharedFolderId)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Dimensions for a photo or video.
    public class Dimensions: CustomStringConvertible {
        /// Height of the photo/video.
        public let height: UInt64
        /// Width of the photo/video.
        public let width: UInt64
        public init(height: UInt64, width: UInt64) {
            comparableValidator()(height)
            self.height = height
            comparableValidator()(width)
            self.width = width
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(DimensionsSerializer().serialize(self)))"
        }
    }
    public class DimensionsSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: Dimensions) -> JSON {
            let output = [ 
            "height": Serialization._UInt64Serializer.serialize(value.height),
            "width": Serialization._UInt64Serializer.serialize(value.width),
            ]
            return .dictionary(output)
        }
        public func deserialize(_ json: JSON) -> Dimensions {
            switch json {
                case .dictionary(let dict):
                    let height = Serialization._UInt64Serializer.deserialize(dict["height"] ?? .null)
                    let width = Serialization._UInt64Serializer.deserialize(dict["width"] ?? .null)
                    return Dimensions(height: height, width: width)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The DownloadArg struct
    public class DownloadArg: CustomStringConvertible {
        /// The path of the file to download.
        public let path: String
        /// Deprecated. Please specify revision in path instead
        public let rev: String?
        public init(path: String, rev: String? = nil) {
            stringValidator(pattern: "(/(.|[\\r\\n])*|id:.*)|(rev:[0-9a-f]{9,})|(ns:[0-9]+(/.*)?)")(path)
            self.path = path
            nullableValidator(stringValidator(minLength: 9, pattern: "[0-9a-f]+"))(rev)
            self.rev = rev
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(DownloadArgSerializer().serialize(self)))"
        }
    }
    public class DownloadArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: DownloadArg) -> JSON {
            let output = [ 
            "path": Serialization._StringSerializer.serialize(value.path),
            "rev": NullableSerializer(Serialization._StringSerializer).serialize(value.rev),
            ]
            return .dictionary(output)
        }
        public func deserialize(_ json: JSON) -> DownloadArg {
            switch json {
                case .dictionary(let dict):
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .null)
                    let rev = NullableSerializer(Serialization._StringSerializer).deserialize(dict["rev"] ?? .null)
                    return DownloadArg(path: path, rev: rev)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The DownloadError union
    public enum DownloadError: CustomStringConvertible {
        /// An unspecified error.
        case path(Files.LookupError)
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(DownloadErrorSerializer().serialize(self)))"
        }
    }
    public class DownloadErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: DownloadError) -> JSON {
            switch value {
                case .path(let arg):
                    var d = ["path": Files.LookupErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("path")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        public func deserialize(_ json: JSON) -> DownloadError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "path":
                            let v = Files.LookupErrorSerializer().deserialize(d["path"] ?? .null)
                            return DownloadError.path(v)
                        case "other":
                            return DownloadError.other
                        default:
                            return DownloadError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The FileMetadata struct
    public class FileMetadata: Files.Metadata {
        /// A unique identifier for the file.
        public let id: String
        /// For files, this is the modification time set by the desktop client when the file was added to Dropbox. Since
        /// this time is not verified (the Dropbox server stores whatever the desktop client sends up), this should only
        /// be used for display purposes (such as sorting) and not, for example, to determine if a file has changed or
        /// not.
        public let clientModified: Date
        /// The last time the file was modified on Dropbox.
        public let serverModified: Date
        /// A unique identifier for the current revision of a file. This field is the same rev as elsewhere in the API
        /// and can be used to detect changes and avoid conflicts.
        public let rev: String
        /// The file size in bytes.
        public let size: UInt64
        /// Additional information if the file is a photo or video.
        public let mediaInfo: Files.MediaInfo?
        /// Set if this file is contained in a shared folder.
        public let sharingInfo: Files.FileSharingInfo?
        /// Additional information if the file has custom properties with the property template specified.
        public let propertyGroups: Array<Properties.PropertyGroup>?
        /// This flag will only be present if include_has_explicit_shared_members  is true in listFolder or getMetadata.
        /// If this  flag is present, it will be true if this file has any explicit shared  members. This is different
        /// from sharing_info in that this could be true  in the case where a file has explicit members but is not
        /// contained within  a shared folder.
        public let hasExplicitSharedMembers: Bool?
        public init(name: String, id: String, clientModified: Date, serverModified: Date, rev: String, size: UInt64, pathLower: String? = nil, pathDisplay: String? = nil, parentSharedFolderId: String? = nil, mediaInfo: Files.MediaInfo? = nil, sharingInfo: Files.FileSharingInfo? = nil, propertyGroups: Array<Properties.PropertyGroup>? = nil, hasExplicitSharedMembers: Bool? = nil) {
            stringValidator(minLength: 1)(id)
            self.id = id
            self.clientModified = clientModified
            self.serverModified = serverModified
            stringValidator(minLength: 9, pattern: "[0-9a-f]+")(rev)
            self.rev = rev
            comparableValidator()(size)
            self.size = size
            self.mediaInfo = mediaInfo
            self.sharingInfo = sharingInfo
            self.propertyGroups = propertyGroups
            self.hasExplicitSharedMembers = hasExplicitSharedMembers
            super.init(name: name, pathLower: pathLower, pathDisplay: pathDisplay, parentSharedFolderId: parentSharedFolderId)
        }
        public override var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(FileMetadataSerializer().serialize(self)))"
        }
    }
    public class FileMetadataSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: FileMetadata) -> JSON {
            let output = [ 
            "name": Serialization._StringSerializer.serialize(value.name),
            "id": Serialization._StringSerializer.serialize(value.id),
            "client_modified": NSDateSerializer("%Y-%m-%dT%H:%M:%SZ").serialize(value.clientModified),
            "server_modified": NSDateSerializer("%Y-%m-%dT%H:%M:%SZ").serialize(value.serverModified),
            "rev": Serialization._StringSerializer.serialize(value.rev),
            "size": Serialization._UInt64Serializer.serialize(value.size),
            "path_lower": NullableSerializer(Serialization._StringSerializer).serialize(value.pathLower),
            "path_display": NullableSerializer(Serialization._StringSerializer).serialize(value.pathDisplay),
            "parent_shared_folder_id": NullableSerializer(Serialization._StringSerializer).serialize(value.parentSharedFolderId),
            "media_info": NullableSerializer(Files.MediaInfoSerializer()).serialize(value.mediaInfo),
            "sharing_info": NullableSerializer(Files.FileSharingInfoSerializer()).serialize(value.sharingInfo),
            "property_groups": NullableSerializer(ArraySerializer(Properties.PropertyGroupSerializer())).serialize(value.propertyGroups),
            "has_explicit_shared_members": NullableSerializer(Serialization._BoolSerializer).serialize(value.hasExplicitSharedMembers),
            ]
            return .dictionary(output)
        }
        public func deserialize(_ json: JSON) -> FileMetadata {
            switch json {
                case .dictionary(let dict):
                    let name = Serialization._StringSerializer.deserialize(dict["name"] ?? .null)
                    let id = Serialization._StringSerializer.deserialize(dict["id"] ?? .null)
                    let clientModified = NSDateSerializer("%Y-%m-%dT%H:%M:%SZ").deserialize(dict["client_modified"] ?? .null)
                    let serverModified = NSDateSerializer("%Y-%m-%dT%H:%M:%SZ").deserialize(dict["server_modified"] ?? .null)
                    let rev = Serialization._StringSerializer.deserialize(dict["rev"] ?? .null)
                    let size = Serialization._UInt64Serializer.deserialize(dict["size"] ?? .null)
                    let pathLower = NullableSerializer(Serialization._StringSerializer).deserialize(dict["path_lower"] ?? .null)
                    let pathDisplay = NullableSerializer(Serialization._StringSerializer).deserialize(dict["path_display"] ?? .null)
                    let parentSharedFolderId = NullableSerializer(Serialization._StringSerializer).deserialize(dict["parent_shared_folder_id"] ?? .null)
                    let mediaInfo = NullableSerializer(Files.MediaInfoSerializer()).deserialize(dict["media_info"] ?? .null)
                    let sharingInfo = NullableSerializer(Files.FileSharingInfoSerializer()).deserialize(dict["sharing_info"] ?? .null)
                    let propertyGroups = NullableSerializer(ArraySerializer(Properties.PropertyGroupSerializer())).deserialize(dict["property_groups"] ?? .null)
                    let hasExplicitSharedMembers = NullableSerializer(Serialization._BoolSerializer).deserialize(dict["has_explicit_shared_members"] ?? .null)
                    return FileMetadata(name: name, id: id, clientModified: clientModified, serverModified: serverModified, rev: rev, size: size, pathLower: pathLower, pathDisplay: pathDisplay, parentSharedFolderId: parentSharedFolderId, mediaInfo: mediaInfo, sharingInfo: sharingInfo, propertyGroups: propertyGroups, hasExplicitSharedMembers: hasExplicitSharedMembers)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Sharing info for a file or folder.
    public class SharingInfo: CustomStringConvertible {
        /// True if the file or folder is inside a read-only shared folder.
        public let readOnly: Bool
        public init(readOnly: Bool) {
            self.readOnly = readOnly
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharingInfoSerializer().serialize(self)))"
        }
    }
    public class SharingInfoSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: SharingInfo) -> JSON {
            let output = [ 
            "read_only": Serialization._BoolSerializer.serialize(value.readOnly),
            ]
            return .dictionary(output)
        }
        public func deserialize(_ json: JSON) -> SharingInfo {
            switch json {
                case .dictionary(let dict):
                    let readOnly = Serialization._BoolSerializer.deserialize(dict["read_only"] ?? .null)
                    return SharingInfo(readOnly: readOnly)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Sharing info for a file which is contained by a shared folder.
    public class FileSharingInfo: Files.SharingInfo {
        /// ID of shared folder that holds this file.
        public let parentSharedFolderId: String
        /// The last user who modified the file. This field will be null if the user's account has been deleted.
        public let modifiedBy: String?
        public init(readOnly: Bool, parentSharedFolderId: String, modifiedBy: String? = nil) {
            stringValidator(pattern: "[-_0-9a-zA-Z:]+")(parentSharedFolderId)
            self.parentSharedFolderId = parentSharedFolderId
            nullableValidator(stringValidator(minLength: 40, maxLength: 40))(modifiedBy)
            self.modifiedBy = modifiedBy
            super.init(readOnly: readOnly)
        }
        public override var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(FileSharingInfoSerializer().serialize(self)))"
        }
    }
    public class FileSharingInfoSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: FileSharingInfo) -> JSON {
            let output = [ 
            "read_only": Serialization._BoolSerializer.serialize(value.readOnly),
            "parent_shared_folder_id": Serialization._StringSerializer.serialize(value.parentSharedFolderId),
            "modified_by": NullableSerializer(Serialization._StringSerializer).serialize(value.modifiedBy),
            ]
            return .dictionary(output)
        }
        public func deserialize(_ json: JSON) -> FileSharingInfo {
            switch json {
                case .dictionary(let dict):
                    let readOnly = Serialization._BoolSerializer.deserialize(dict["read_only"] ?? .null)
                    let parentSharedFolderId = Serialization._StringSerializer.deserialize(dict["parent_shared_folder_id"] ?? .null)
                    let modifiedBy = NullableSerializer(Serialization._StringSerializer).deserialize(dict["modified_by"] ?? .null)
                    return FileSharingInfo(readOnly: readOnly, parentSharedFolderId: parentSharedFolderId, modifiedBy: modifiedBy)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The FolderMetadata struct
    public class FolderMetadata: Files.Metadata {
        /// A unique identifier for the folder.
        public let id: String
        /// Deprecated. Please use sharingInfo instead.
        public let sharedFolderId: String?
        /// Set if the folder is contained in a shared folder or is a shared folder mount point.
        public let sharingInfo: Files.FolderSharingInfo?
        /// Additional information if the file has custom properties with the property template specified.
        public let propertyGroups: Array<Properties.PropertyGroup>?
        public init(name: String, id: String, pathLower: String? = nil, pathDisplay: String? = nil, parentSharedFolderId: String? = nil, sharedFolderId: String? = nil, sharingInfo: Files.FolderSharingInfo? = nil, propertyGroups: Array<Properties.PropertyGroup>? = nil) {
            stringValidator(minLength: 1)(id)
            self.id = id
            nullableValidator(stringValidator(pattern: "[-_0-9a-zA-Z:]+"))(sharedFolderId)
            self.sharedFolderId = sharedFolderId
            self.sharingInfo = sharingInfo
            self.propertyGroups = propertyGroups
            super.init(name: name, pathLower: pathLower, pathDisplay: pathDisplay, parentSharedFolderId: parentSharedFolderId)
        }
        public override var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(FolderMetadataSerializer().serialize(self)))"
        }
    }
    public class FolderMetadataSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: FolderMetadata) -> JSON {
            let output = [ 
            "name": Serialization._StringSerializer.serialize(value.name),
            "id": Serialization._StringSerializer.serialize(value.id),
            "path_lower": NullableSerializer(Serialization._StringSerializer).serialize(value.pathLower),
            "path_display": NullableSerializer(Serialization._StringSerializer).serialize(value.pathDisplay),
            "parent_shared_folder_id": NullableSerializer(Serialization._StringSerializer).serialize(value.parentSharedFolderId),
            "shared_folder_id": NullableSerializer(Serialization._StringSerializer).serialize(value.sharedFolderId),
            "sharing_info": NullableSerializer(Files.FolderSharingInfoSerializer()).serialize(value.sharingInfo),
            "property_groups": NullableSerializer(ArraySerializer(Properties.PropertyGroupSerializer())).serialize(value.propertyGroups),
            ]
            return .dictionary(output)
        }
        public func deserialize(_ json: JSON) -> FolderMetadata {
            switch json {
                case .dictionary(let dict):
                    let name = Serialization._StringSerializer.deserialize(dict["name"] ?? .null)
                    let id = Serialization._StringSerializer.deserialize(dict["id"] ?? .null)
                    let pathLower = NullableSerializer(Serialization._StringSerializer).deserialize(dict["path_lower"] ?? .null)
                    let pathDisplay = NullableSerializer(Serialization._StringSerializer).deserialize(dict["path_display"] ?? .null)
                    let parentSharedFolderId = NullableSerializer(Serialization._StringSerializer).deserialize(dict["parent_shared_folder_id"] ?? .null)
                    let sharedFolderId = NullableSerializer(Serialization._StringSerializer).deserialize(dict["shared_folder_id"] ?? .null)
                    let sharingInfo = NullableSerializer(Files.FolderSharingInfoSerializer()).deserialize(dict["sharing_info"] ?? .null)
                    let propertyGroups = NullableSerializer(ArraySerializer(Properties.PropertyGroupSerializer())).deserialize(dict["property_groups"] ?? .null)
                    return FolderMetadata(name: name, id: id, pathLower: pathLower, pathDisplay: pathDisplay, parentSharedFolderId: parentSharedFolderId, sharedFolderId: sharedFolderId, sharingInfo: sharingInfo, propertyGroups: propertyGroups)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Sharing info for a folder which is contained in a shared folder or is a shared folder mount point.
    public class FolderSharingInfo: Files.SharingInfo {
        /// Set if the folder is contained by a shared folder.
        public let parentSharedFolderId: String?
        /// If this folder is a shared folder mount point, the ID of the shared folder mounted at this location.
        public let sharedFolderId: String?
        /// Specifies that the folder can only be traversed and the user can only see a limited subset of the contents
        /// of this folder because they don't have read access to this folder. They do, however, have access to some sub
        /// folder.
        public let traverseOnly: Bool
        /// Specifies that the folder cannot be accessed by the user
        public let noAccess: Bool
        public init(readOnly: Bool, parentSharedFolderId: String? = nil, sharedFolderId: String? = nil, traverseOnly: Bool = false, noAccess: Bool = false) {
            nullableValidator(stringValidator(pattern: "[-_0-9a-zA-Z:]+"))(parentSharedFolderId)
            self.parentSharedFolderId = parentSharedFolderId
            nullableValidator(stringValidator(pattern: "[-_0-9a-zA-Z:]+"))(sharedFolderId)
            self.sharedFolderId = sharedFolderId
            self.traverseOnly = traverseOnly
            self.noAccess = noAccess
            super.init(readOnly: readOnly)
        }
        public override var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(FolderSharingInfoSerializer().serialize(self)))"
        }
    }
    public class FolderSharingInfoSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: FolderSharingInfo) -> JSON {
            let output = [ 
            "read_only": Serialization._BoolSerializer.serialize(value.readOnly),
            "parent_shared_folder_id": NullableSerializer(Serialization._StringSerializer).serialize(value.parentSharedFolderId),
            "shared_folder_id": NullableSerializer(Serialization._StringSerializer).serialize(value.sharedFolderId),
            "traverse_only": Serialization._BoolSerializer.serialize(value.traverseOnly),
            "no_access": Serialization._BoolSerializer.serialize(value.noAccess),
            ]
            return .dictionary(output)
        }
        public func deserialize(_ json: JSON) -> FolderSharingInfo {
            switch json {
                case .dictionary(let dict):
                    let readOnly = Serialization._BoolSerializer.deserialize(dict["read_only"] ?? .null)
                    let parentSharedFolderId = NullableSerializer(Serialization._StringSerializer).deserialize(dict["parent_shared_folder_id"] ?? .null)
                    let sharedFolderId = NullableSerializer(Serialization._StringSerializer).deserialize(dict["shared_folder_id"] ?? .null)
                    let traverseOnly = Serialization._BoolSerializer.deserialize(dict["traverse_only"] ?? .number(0))
                    let noAccess = Serialization._BoolSerializer.deserialize(dict["no_access"] ?? .number(0))
                    return FolderSharingInfo(readOnly: readOnly, parentSharedFolderId: parentSharedFolderId, sharedFolderId: sharedFolderId, traverseOnly: traverseOnly, noAccess: noAccess)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The GetCopyReferenceArg struct
    public class GetCopyReferenceArg: CustomStringConvertible {
        /// The path to the file or folder you want to get a copy reference to.
        public let path: String
        public init(path: String) {
            stringValidator(pattern: "(/(.|[\\r\\n])*|id:.*)|(rev:[0-9a-f]{9,})|(ns:[0-9]+(/.*)?)")(path)
            self.path = path
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GetCopyReferenceArgSerializer().serialize(self)))"
        }
    }
    public class GetCopyReferenceArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: GetCopyReferenceArg) -> JSON {
            let output = [ 
            "path": Serialization._StringSerializer.serialize(value.path),
            ]
            return .dictionary(output)
        }
        public func deserialize(_ json: JSON) -> GetCopyReferenceArg {
            switch json {
                case .dictionary(let dict):
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .null)
                    return GetCopyReferenceArg(path: path)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The GetCopyReferenceError union
    public enum GetCopyReferenceError: CustomStringConvertible {
        /// An unspecified error.
        case path(Files.LookupError)
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GetCopyReferenceErrorSerializer().serialize(self)))"
        }
    }
    public class GetCopyReferenceErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: GetCopyReferenceError) -> JSON {
            switch value {
                case .path(let arg):
                    var d = ["path": Files.LookupErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("path")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        public func deserialize(_ json: JSON) -> GetCopyReferenceError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "path":
                            let v = Files.LookupErrorSerializer().deserialize(d["path"] ?? .null)
                            return GetCopyReferenceError.path(v)
                        case "other":
                            return GetCopyReferenceError.other
                        default:
                            return GetCopyReferenceError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The GetCopyReferenceResult struct
    public class GetCopyReferenceResult: CustomStringConvertible {
        /// Metadata of the file or folder.
        public let metadata: Files.Metadata
        /// A copy reference to the file or folder.
        public let copyReference: String
        /// The expiration date of the copy reference. This value is currently set to be far enough in the future so
        /// that expiration is effectively not an issue.
        public let expires: Date
        public init(metadata: Files.Metadata, copyReference: String, expires: Date) {
            self.metadata = metadata
            stringValidator()(copyReference)
            self.copyReference = copyReference
            self.expires = expires
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GetCopyReferenceResultSerializer().serialize(self)))"
        }
    }
    public class GetCopyReferenceResultSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: GetCopyReferenceResult) -> JSON {
            let output = [ 
            "metadata": Files.MetadataSerializer().serialize(value.metadata),
            "copy_reference": Serialization._StringSerializer.serialize(value.copyReference),
            "expires": NSDateSerializer("%Y-%m-%dT%H:%M:%SZ").serialize(value.expires),
            ]
            return .dictionary(output)
        }
        public func deserialize(_ json: JSON) -> GetCopyReferenceResult {
            switch json {
                case .dictionary(let dict):
                    let metadata = Files.MetadataSerializer().deserialize(dict["metadata"] ?? .null)
                    let copyReference = Serialization._StringSerializer.deserialize(dict["copy_reference"] ?? .null)
                    let expires = NSDateSerializer("%Y-%m-%dT%H:%M:%SZ").deserialize(dict["expires"] ?? .null)
                    return GetCopyReferenceResult(metadata: metadata, copyReference: copyReference, expires: expires)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The GetTemporaryLinkArg struct
    public class GetTemporaryLinkArg: CustomStringConvertible {
        /// The path to the file you want a temporary link to.
        public let path: String
        public init(path: String) {
            stringValidator(pattern: "(/(.|[\\r\\n])*|id:.*)|(rev:[0-9a-f]{9,})|(ns:[0-9]+(/.*)?)")(path)
            self.path = path
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GetTemporaryLinkArgSerializer().serialize(self)))"
        }
    }
    public class GetTemporaryLinkArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: GetTemporaryLinkArg) -> JSON {
            let output = [ 
            "path": Serialization._StringSerializer.serialize(value.path),
            ]
            return .dictionary(output)
        }
        public func deserialize(_ json: JSON) -> GetTemporaryLinkArg {
            switch json {
                case .dictionary(let dict):
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .null)
                    return GetTemporaryLinkArg(path: path)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The GetTemporaryLinkError union
    public enum GetTemporaryLinkError: CustomStringConvertible {
        /// An unspecified error.
        case path(Files.LookupError)
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GetTemporaryLinkErrorSerializer().serialize(self)))"
        }
    }
    public class GetTemporaryLinkErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: GetTemporaryLinkError) -> JSON {
            switch value {
                case .path(let arg):
                    var d = ["path": Files.LookupErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("path")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        public func deserialize(_ json: JSON) -> GetTemporaryLinkError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "path":
                            let v = Files.LookupErrorSerializer().deserialize(d["path"] ?? .null)
                            return GetTemporaryLinkError.path(v)
                        case "other":
                            return GetTemporaryLinkError.other
                        default:
                            return GetTemporaryLinkError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The GetTemporaryLinkResult struct
    public class GetTemporaryLinkResult: CustomStringConvertible {
        /// Metadata of the file.
        public let metadata: Files.FileMetadata
        /// The temporary link which can be used to stream content the file.
        public let link: String
        public init(metadata: Files.FileMetadata, link: String) {
            self.metadata = metadata
            stringValidator()(link)
            self.link = link
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GetTemporaryLinkResultSerializer().serialize(self)))"
        }
    }
    public class GetTemporaryLinkResultSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: GetTemporaryLinkResult) -> JSON {
            let output = [ 
            "metadata": Files.FileMetadataSerializer().serialize(value.metadata),
            "link": Serialization._StringSerializer.serialize(value.link),
            ]
            return .dictionary(output)
        }
        public func deserialize(_ json: JSON) -> GetTemporaryLinkResult {
            switch json {
                case .dictionary(let dict):
                    let metadata = Files.FileMetadataSerializer().deserialize(dict["metadata"] ?? .null)
                    let link = Serialization._StringSerializer.deserialize(dict["link"] ?? .null)
                    return GetTemporaryLinkResult(metadata: metadata, link: link)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// GPS coordinates for a photo or video.
    public class GpsCoordinates: CustomStringConvertible {
        /// Latitude of the GPS coordinates.
        public let latitude: Double
        /// Longitude of the GPS coordinates.
        public let longitude: Double
        public init(latitude: Double, longitude: Double) {
            comparableValidator()(latitude)
            self.latitude = latitude
            comparableValidator()(longitude)
            self.longitude = longitude
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GpsCoordinatesSerializer().serialize(self)))"
        }
    }
    public class GpsCoordinatesSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: GpsCoordinates) -> JSON {
            let output = [ 
            "latitude": Serialization._DoubleSerializer.serialize(value.latitude),
            "longitude": Serialization._DoubleSerializer.serialize(value.longitude),
            ]
            return .dictionary(output)
        }
        public func deserialize(_ json: JSON) -> GpsCoordinates {
            switch json {
                case .dictionary(let dict):
                    let latitude = Serialization._DoubleSerializer.deserialize(dict["latitude"] ?? .null)
                    let longitude = Serialization._DoubleSerializer.deserialize(dict["longitude"] ?? .null)
                    return GpsCoordinates(latitude: latitude, longitude: longitude)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The ListFolderArg struct
    public class ListFolderArg: CustomStringConvertible {
        /// The path to the folder you want to see the contents of.
        public let path: String
        /// If true, the list folder operation will be applied recursively to all subfolders and the response will
        /// contain contents of all subfolders.
        public let recursive: Bool
        /// If true, mediaInfo in FileMetadata is set for photo and video.
        public let includeMediaInfo: Bool
        /// If true, the results will include entries for files and folders that used to exist but were deleted.
        public let includeDeleted: Bool
        /// If true, the results will include a flag for each file indicating whether or not  that file has any explicit
        /// members.
        public let includeHasExplicitSharedMembers: Bool
        public init(path: String, recursive: Bool = false, includeMediaInfo: Bool = false, includeDeleted: Bool = false, includeHasExplicitSharedMembers: Bool = false) {
            stringValidator(pattern: "(/(.|[\\r\\n])*)?|(ns:[0-9]+(/.*)?)")(path)
            self.path = path
            self.recursive = recursive
            self.includeMediaInfo = includeMediaInfo
            self.includeDeleted = includeDeleted
            self.includeHasExplicitSharedMembers = includeHasExplicitSharedMembers
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListFolderArgSerializer().serialize(self)))"
        }
    }
    public class ListFolderArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: ListFolderArg) -> JSON {
            let output = [ 
            "path": Serialization._StringSerializer.serialize(value.path),
            "recursive": Serialization._BoolSerializer.serialize(value.recursive),
            "include_media_info": Serialization._BoolSerializer.serialize(value.includeMediaInfo),
            "include_deleted": Serialization._BoolSerializer.serialize(value.includeDeleted),
            "include_has_explicit_shared_members": Serialization._BoolSerializer.serialize(value.includeHasExplicitSharedMembers),
            ]
            return .dictionary(output)
        }
        public func deserialize(_ json: JSON) -> ListFolderArg {
            switch json {
                case .dictionary(let dict):
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .null)
                    let recursive = Serialization._BoolSerializer.deserialize(dict["recursive"] ?? .number(0))
                    let includeMediaInfo = Serialization._BoolSerializer.deserialize(dict["include_media_info"] ?? .number(0))
                    let includeDeleted = Serialization._BoolSerializer.deserialize(dict["include_deleted"] ?? .number(0))
                    let includeHasExplicitSharedMembers = Serialization._BoolSerializer.deserialize(dict["include_has_explicit_shared_members"] ?? .number(0))
                    return ListFolderArg(path: path, recursive: recursive, includeMediaInfo: includeMediaInfo, includeDeleted: includeDeleted, includeHasExplicitSharedMembers: includeHasExplicitSharedMembers)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The ListFolderContinueArg struct
    public class ListFolderContinueArg: CustomStringConvertible {
        /// The cursor returned by your last call to listFolder or listFolderContinue.
        public let cursor: String
        public init(cursor: String) {
            stringValidator(minLength: 1)(cursor)
            self.cursor = cursor
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListFolderContinueArgSerializer().serialize(self)))"
        }
    }
    public class ListFolderContinueArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: ListFolderContinueArg) -> JSON {
            let output = [ 
            "cursor": Serialization._StringSerializer.serialize(value.cursor),
            ]
            return .dictionary(output)
        }
        public func deserialize(_ json: JSON) -> ListFolderContinueArg {
            switch json {
                case .dictionary(let dict):
                    let cursor = Serialization._StringSerializer.deserialize(dict["cursor"] ?? .null)
                    return ListFolderContinueArg(cursor: cursor)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The ListFolderContinueError union
    public enum ListFolderContinueError: CustomStringConvertible {
        /// An unspecified error.
        case path(Files.LookupError)
        /// Indicates that the cursor has been invalidated. Call listFolder to obtain a new cursor.
        case reset
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListFolderContinueErrorSerializer().serialize(self)))"
        }
    }
    public class ListFolderContinueErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: ListFolderContinueError) -> JSON {
            switch value {
                case .path(let arg):
                    var d = ["path": Files.LookupErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("path")
                    return .dictionary(d)
                case .reset:
                    var d = [String: JSON]()
                    d[".tag"] = .str("reset")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        public func deserialize(_ json: JSON) -> ListFolderContinueError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "path":
                            let v = Files.LookupErrorSerializer().deserialize(d["path"] ?? .null)
                            return ListFolderContinueError.path(v)
                        case "reset":
                            return ListFolderContinueError.reset
                        case "other":
                            return ListFolderContinueError.other
                        default:
                            return ListFolderContinueError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The ListFolderError union
    public enum ListFolderError: CustomStringConvertible {
        /// An unspecified error.
        case path(Files.LookupError)
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListFolderErrorSerializer().serialize(self)))"
        }
    }
    public class ListFolderErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: ListFolderError) -> JSON {
            switch value {
                case .path(let arg):
                    var d = ["path": Files.LookupErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("path")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        public func deserialize(_ json: JSON) -> ListFolderError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "path":
                            let v = Files.LookupErrorSerializer().deserialize(d["path"] ?? .null)
                            return ListFolderError.path(v)
                        case "other":
                            return ListFolderError.other
                        default:
                            return ListFolderError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The ListFolderGetLatestCursorResult struct
    public class ListFolderGetLatestCursorResult: CustomStringConvertible {
        /// Pass the cursor into listFolderContinue to see what's changed in the folder since your previous query.
        public let cursor: String
        public init(cursor: String) {
            stringValidator(minLength: 1)(cursor)
            self.cursor = cursor
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListFolderGetLatestCursorResultSerializer().serialize(self)))"
        }
    }
    public class ListFolderGetLatestCursorResultSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: ListFolderGetLatestCursorResult) -> JSON {
            let output = [ 
            "cursor": Serialization._StringSerializer.serialize(value.cursor),
            ]
            return .dictionary(output)
        }
        public func deserialize(_ json: JSON) -> ListFolderGetLatestCursorResult {
            switch json {
                case .dictionary(let dict):
                    let cursor = Serialization._StringSerializer.deserialize(dict["cursor"] ?? .null)
                    return ListFolderGetLatestCursorResult(cursor: cursor)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The ListFolderLongpollArg struct
    public class ListFolderLongpollArg: CustomStringConvertible {
        /// A cursor as returned by listFolder or listFolderContinue. Cursors retrieved by setting includeMediaInfo in
        /// ListFolderArg to true are not supported.
        public let cursor: String
        /// A timeout in seconds. The request will block for at most this length of time, plus up to 90 seconds of
        /// random jitter added to avoid the thundering herd problem. Care should be taken when using this parameter, as
        /// some network infrastructure does not support long timeouts.
        public let timeout: UInt64
        public init(cursor: String, timeout: UInt64 = 30) {
            stringValidator(minLength: 1)(cursor)
            self.cursor = cursor
            comparableValidator(minValue: 30, maxValue: 480)(timeout)
            self.timeout = timeout
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListFolderLongpollArgSerializer().serialize(self)))"
        }
    }
    public class ListFolderLongpollArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: ListFolderLongpollArg) -> JSON {
            let output = [ 
            "cursor": Serialization._StringSerializer.serialize(value.cursor),
            "timeout": Serialization._UInt64Serializer.serialize(value.timeout),
            ]
            return .dictionary(output)
        }
        public func deserialize(_ json: JSON) -> ListFolderLongpollArg {
            switch json {
                case .dictionary(let dict):
                    let cursor = Serialization._StringSerializer.deserialize(dict["cursor"] ?? .null)
                    let timeout = Serialization._UInt64Serializer.deserialize(dict["timeout"] ?? .number(30))
                    return ListFolderLongpollArg(cursor: cursor, timeout: timeout)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The ListFolderLongpollError union
    public enum ListFolderLongpollError: CustomStringConvertible {
        /// Indicates that the cursor has been invalidated. Call listFolder to obtain a new cursor.
        case reset
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListFolderLongpollErrorSerializer().serialize(self)))"
        }
    }
    public class ListFolderLongpollErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: ListFolderLongpollError) -> JSON {
            switch value {
                case .reset:
                    var d = [String: JSON]()
                    d[".tag"] = .str("reset")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        public func deserialize(_ json: JSON) -> ListFolderLongpollError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "reset":
                            return ListFolderLongpollError.reset
                        case "other":
                            return ListFolderLongpollError.other
                        default:
                            return ListFolderLongpollError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The ListFolderLongpollResult struct
    public class ListFolderLongpollResult: CustomStringConvertible {
        /// Indicates whether new changes are available. If true, call listFolderContinue to retrieve the changes.
        public let changes: Bool
        /// If present, backoff for at least this many seconds before calling listFolderLongpoll again.
        public let backoff: UInt64?
        public init(changes: Bool, backoff: UInt64? = nil) {
            self.changes = changes
            nullableValidator(comparableValidator())(backoff)
            self.backoff = backoff
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListFolderLongpollResultSerializer().serialize(self)))"
        }
    }
    public class ListFolderLongpollResultSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: ListFolderLongpollResult) -> JSON {
            let output = [ 
            "changes": Serialization._BoolSerializer.serialize(value.changes),
            "backoff": NullableSerializer(Serialization._UInt64Serializer).serialize(value.backoff),
            ]
            return .dictionary(output)
        }
        public func deserialize(_ json: JSON) -> ListFolderLongpollResult {
            switch json {
                case .dictionary(let dict):
                    let changes = Serialization._BoolSerializer.deserialize(dict["changes"] ?? .null)
                    let backoff = NullableSerializer(Serialization._UInt64Serializer).deserialize(dict["backoff"] ?? .null)
                    return ListFolderLongpollResult(changes: changes, backoff: backoff)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The ListFolderResult struct
    public class ListFolderResult: CustomStringConvertible {
        /// The files and (direct) subfolders in the folder.
        public let entries: Array<Files.Metadata>
        /// Pass the cursor into listFolderContinue to see what's changed in the folder since your previous query.
        public let cursor: String
        /// If true, then there are more entries available. Pass the cursor to listFolderContinue to retrieve the rest.
        public let hasMore: Bool
        public init(entries: Array<Files.Metadata>, cursor: String, hasMore: Bool) {
            self.entries = entries
            stringValidator(minLength: 1)(cursor)
            self.cursor = cursor
            self.hasMore = hasMore
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListFolderResultSerializer().serialize(self)))"
        }
    }
    public class ListFolderResultSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: ListFolderResult) -> JSON {
            let output = [ 
            "entries": ArraySerializer(Files.MetadataSerializer()).serialize(value.entries),
            "cursor": Serialization._StringSerializer.serialize(value.cursor),
            "has_more": Serialization._BoolSerializer.serialize(value.hasMore),
            ]
            return .dictionary(output)
        }
        public func deserialize(_ json: JSON) -> ListFolderResult {
            switch json {
                case .dictionary(let dict):
                    let entries = ArraySerializer(Files.MetadataSerializer()).deserialize(dict["entries"] ?? .null)
                    let cursor = Serialization._StringSerializer.deserialize(dict["cursor"] ?? .null)
                    let hasMore = Serialization._BoolSerializer.deserialize(dict["has_more"] ?? .null)
                    return ListFolderResult(entries: entries, cursor: cursor, hasMore: hasMore)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The ListRevisionsArg struct
    public class ListRevisionsArg: CustomStringConvertible {
        /// The path to the file you want to see the revisions of.
        public let path: String
        /// The maximum number of revision entries returned.
        public let limit: UInt64
        public init(path: String, limit: UInt64 = 10) {
            stringValidator(pattern: "/(.|[\\r\\n])*|id:.*|(ns:[0-9]+(/.*)?)")(path)
            self.path = path
            comparableValidator(minValue: 1, maxValue: 100)(limit)
            self.limit = limit
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListRevisionsArgSerializer().serialize(self)))"
        }
    }
    public class ListRevisionsArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: ListRevisionsArg) -> JSON {
            let output = [ 
            "path": Serialization._StringSerializer.serialize(value.path),
            "limit": Serialization._UInt64Serializer.serialize(value.limit),
            ]
            return .dictionary(output)
        }
        public func deserialize(_ json: JSON) -> ListRevisionsArg {
            switch json {
                case .dictionary(let dict):
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .null)
                    let limit = Serialization._UInt64Serializer.deserialize(dict["limit"] ?? .number(10))
                    return ListRevisionsArg(path: path, limit: limit)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The ListRevisionsError union
    public enum ListRevisionsError: CustomStringConvertible {
        /// An unspecified error.
        case path(Files.LookupError)
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListRevisionsErrorSerializer().serialize(self)))"
        }
    }
    public class ListRevisionsErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: ListRevisionsError) -> JSON {
            switch value {
                case .path(let arg):
                    var d = ["path": Files.LookupErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("path")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        public func deserialize(_ json: JSON) -> ListRevisionsError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "path":
                            let v = Files.LookupErrorSerializer().deserialize(d["path"] ?? .null)
                            return ListRevisionsError.path(v)
                        case "other":
                            return ListRevisionsError.other
                        default:
                            return ListRevisionsError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The ListRevisionsResult struct
    public class ListRevisionsResult: CustomStringConvertible {
        /// If the file is deleted.
        public let isDeleted: Bool
        /// The revisions for the file. Only non-delete revisions will show up here.
        public let entries: Array<Files.FileMetadata>
        public init(isDeleted: Bool, entries: Array<Files.FileMetadata>) {
            self.isDeleted = isDeleted
            self.entries = entries
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListRevisionsResultSerializer().serialize(self)))"
        }
    }
    public class ListRevisionsResultSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: ListRevisionsResult) -> JSON {
            let output = [ 
            "is_deleted": Serialization._BoolSerializer.serialize(value.isDeleted),
            "entries": ArraySerializer(Files.FileMetadataSerializer()).serialize(value.entries),
            ]
            return .dictionary(output)
        }
        public func deserialize(_ json: JSON) -> ListRevisionsResult {
            switch json {
                case .dictionary(let dict):
                    let isDeleted = Serialization._BoolSerializer.deserialize(dict["is_deleted"] ?? .null)
                    let entries = ArraySerializer(Files.FileMetadataSerializer()).deserialize(dict["entries"] ?? .null)
                    return ListRevisionsResult(isDeleted: isDeleted, entries: entries)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The LookUpPropertiesError union
    public enum LookUpPropertiesError: CustomStringConvertible {
        /// This property group does not exist for this file.
        case propertyGroupNotFound

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(LookUpPropertiesErrorSerializer().serialize(self)))"
        }
    }
    public class LookUpPropertiesErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: LookUpPropertiesError) -> JSON {
            switch value {
                case .propertyGroupNotFound:
                    var d = [String: JSON]()
                    d[".tag"] = .str("property_group_not_found")
                    return .dictionary(d)
            }
        }
        public func deserialize(_ json: JSON) -> LookUpPropertiesError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "property_group_not_found":
                            return LookUpPropertiesError.propertyGroupNotFound
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The LookupError union
    public enum LookupError: CustomStringConvertible {
        /// An unspecified error.
        case malformedPath(String?)
        /// There is nothing at the given path.
        case notFound
        /// We were expecting a file, but the given path refers to something that isn't a file.
        case notFile
        /// We were expecting a folder, but the given path refers to something that isn't a folder.
        case notFolder
        /// The file cannot be transferred because the content is restricted.  For example, sometimes there are legal
        /// restrictions due to copyright claims.
        case restrictedContent
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(LookupErrorSerializer().serialize(self)))"
        }
    }
    public class LookupErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: LookupError) -> JSON {
            switch value {
                case .malformedPath(let arg):
                    var d = ["malformed_path": NullableSerializer(Serialization._StringSerializer).serialize(arg)]
                    d[".tag"] = .str("malformed_path")
                    return .dictionary(d)
                case .notFound:
                    var d = [String: JSON]()
                    d[".tag"] = .str("not_found")
                    return .dictionary(d)
                case .notFile:
                    var d = [String: JSON]()
                    d[".tag"] = .str("not_file")
                    return .dictionary(d)
                case .notFolder:
                    var d = [String: JSON]()
                    d[".tag"] = .str("not_folder")
                    return .dictionary(d)
                case .restrictedContent:
                    var d = [String: JSON]()
                    d[".tag"] = .str("restricted_content")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        public func deserialize(_ json: JSON) -> LookupError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "malformed_path":
                            let v = NullableSerializer(Serialization._StringSerializer).deserialize(d["malformed_path"] ?? .null)
                            return LookupError.malformedPath(v)
                        case "not_found":
                            return LookupError.notFound
                        case "not_file":
                            return LookupError.notFile
                        case "not_folder":
                            return LookupError.notFolder
                        case "restricted_content":
                            return LookupError.restrictedContent
                        case "other":
                            return LookupError.other
                        default:
                            return LookupError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The MediaInfo union
    public enum MediaInfo: CustomStringConvertible {
        /// Indicate the photo/video is still under processing and metadata is not available yet.
        case pending
        /// The metadata for the photo/video.
        case metadata(Files.MediaMetadata)

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MediaInfoSerializer().serialize(self)))"
        }
    }
    public class MediaInfoSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: MediaInfo) -> JSON {
            switch value {
                case .pending:
                    var d = [String: JSON]()
                    d[".tag"] = .str("pending")
                    return .dictionary(d)
                case .metadata(let arg):
                    var d = ["metadata": Files.MediaMetadataSerializer().serialize(arg)]
                    d[".tag"] = .str("metadata")
                    return .dictionary(d)
            }
        }
        public func deserialize(_ json: JSON) -> MediaInfo {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "pending":
                            return MediaInfo.pending
                        case "metadata":
                            let v = Files.MediaMetadataSerializer().deserialize(d["metadata"] ?? .null)
                            return MediaInfo.metadata(v)
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Metadata for a photo or video.
    public class MediaMetadata: CustomStringConvertible {
        /// Dimension of the photo/video.
        public let dimensions: Files.Dimensions?
        /// The GPS coordinate of the photo/video.
        public let location: Files.GpsCoordinates?
        /// The timestamp when the photo/video is taken.
        public let timeTaken: Date?
        public init(dimensions: Files.Dimensions? = nil, location: Files.GpsCoordinates? = nil, timeTaken: Date? = nil) {
            self.dimensions = dimensions
            self.location = location
            self.timeTaken = timeTaken
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MediaMetadataSerializer().serialize(self)))"
        }
    }
    public class MediaMetadataSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: MediaMetadata) -> JSON {
            var output = [ 
            "dimensions": NullableSerializer(Files.DimensionsSerializer()).serialize(value.dimensions),
            "location": NullableSerializer(Files.GpsCoordinatesSerializer()).serialize(value.location),
            "time_taken": NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.timeTaken),
            ]
            switch value {
                case let photo as Files.PhotoMetadata:
                    for (k, v) in Serialization.getFields(Files.PhotoMetadataSerializer().serialize(photo)) {
                        output[k] = v
                    }
                    output[".tag"] = .str("photo")
                case let video as Files.VideoMetadata:
                    for (k, v) in Serialization.getFields(Files.VideoMetadataSerializer().serialize(video)) {
                        output[k] = v
                    }
                    output[".tag"] = .str("video")
                default: fatalError("Tried to serialize unexpected subtype")
            }
            return .dictionary(output)
        }
        public func deserialize(_ json: JSON) -> MediaMetadata {
            switch json {
                case .dictionary(let dict):
                    let tag = Serialization.getTag(dict)
                    switch tag {
                        case "photo":
                            return Files.PhotoMetadataSerializer().deserialize(json)
                        case "video":
                            return Files.VideoMetadataSerializer().deserialize(json)
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Metadata for a photo.
    public class PhotoMetadata: Files.MediaMetadata {
        public override var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PhotoMetadataSerializer().serialize(self)))"
        }
    }
    public class PhotoMetadataSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: PhotoMetadata) -> JSON {
            let output = [ 
            "dimensions": NullableSerializer(Files.DimensionsSerializer()).serialize(value.dimensions),
            "location": NullableSerializer(Files.GpsCoordinatesSerializer()).serialize(value.location),
            "time_taken": NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.timeTaken),
            ]
            return .dictionary(output)
        }
        public func deserialize(_ json: JSON) -> PhotoMetadata {
            switch json {
                case .dictionary(let dict):
                    let dimensions = NullableSerializer(Files.DimensionsSerializer()).deserialize(dict["dimensions"] ?? .null)
                    let location = NullableSerializer(Files.GpsCoordinatesSerializer()).deserialize(dict["location"] ?? .null)
                    let timeTaken = NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).deserialize(dict["time_taken"] ?? .null)
                    return PhotoMetadata(dimensions: dimensions, location: location, timeTaken: timeTaken)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The PreviewArg struct
    public class PreviewArg: CustomStringConvertible {
        /// The path of the file to preview.
        public let path: String
        /// Deprecated. Please specify revision in path instead
        public let rev: String?
        public init(path: String, rev: String? = nil) {
            stringValidator(pattern: "(/(.|[\\r\\n])*|id:.*)|(rev:[0-9a-f]{9,})|(ns:[0-9]+(/.*)?)")(path)
            self.path = path
            nullableValidator(stringValidator(minLength: 9, pattern: "[0-9a-f]+"))(rev)
            self.rev = rev
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PreviewArgSerializer().serialize(self)))"
        }
    }
    public class PreviewArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: PreviewArg) -> JSON {
            let output = [ 
            "path": Serialization._StringSerializer.serialize(value.path),
            "rev": NullableSerializer(Serialization._StringSerializer).serialize(value.rev),
            ]
            return .dictionary(output)
        }
        public func deserialize(_ json: JSON) -> PreviewArg {
            switch json {
                case .dictionary(let dict):
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .null)
                    let rev = NullableSerializer(Serialization._StringSerializer).deserialize(dict["rev"] ?? .null)
                    return PreviewArg(path: path, rev: rev)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The PreviewError union
    public enum PreviewError: CustomStringConvertible {
        /// An error occurs when downloading metadata for the file.
        case path(Files.LookupError)
        /// This preview generation is still in progress and the file is not ready  for preview yet.
        case inProgress
        /// The file extension is not supported preview generation.
        case unsupportedExtension
        /// The file content is not supported for preview generation.
        case unsupportedContent

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PreviewErrorSerializer().serialize(self)))"
        }
    }
    public class PreviewErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: PreviewError) -> JSON {
            switch value {
                case .path(let arg):
                    var d = ["path": Files.LookupErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("path")
                    return .dictionary(d)
                case .inProgress:
                    var d = [String: JSON]()
                    d[".tag"] = .str("in_progress")
                    return .dictionary(d)
                case .unsupportedExtension:
                    var d = [String: JSON]()
                    d[".tag"] = .str("unsupported_extension")
                    return .dictionary(d)
                case .unsupportedContent:
                    var d = [String: JSON]()
                    d[".tag"] = .str("unsupported_content")
                    return .dictionary(d)
            }
        }
        public func deserialize(_ json: JSON) -> PreviewError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "path":
                            let v = Files.LookupErrorSerializer().deserialize(d["path"] ?? .null)
                            return PreviewError.path(v)
                        case "in_progress":
                            return PreviewError.inProgress
                        case "unsupported_extension":
                            return PreviewError.unsupportedExtension
                        case "unsupported_content":
                            return PreviewError.unsupportedContent
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The PropertyGroupUpdate struct
    public class PropertyGroupUpdate: CustomStringConvertible {
        /// A unique identifier for a property template.
        public let templateId: String
        /// List of property fields to update if the field already exists. If the field doesn't exist, add the field to
        /// the property group.
        public let addOrUpdateFields: Array<Properties.PropertyField>?
        /// List of property field names to remove from property group if the field exists.
        public let removeFields: Array<String>?
        public init(templateId: String, addOrUpdateFields: Array<Properties.PropertyField>? = nil, removeFields: Array<String>? = nil) {
            stringValidator(minLength: 1, pattern: "(/|ptid:).*")(templateId)
            self.templateId = templateId
            self.addOrUpdateFields = addOrUpdateFields
            nullableValidator(arrayValidator(itemValidator: stringValidator()))(removeFields)
            self.removeFields = removeFields
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PropertyGroupUpdateSerializer().serialize(self)))"
        }
    }
    public class PropertyGroupUpdateSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: PropertyGroupUpdate) -> JSON {
            let output = [ 
            "template_id": Serialization._StringSerializer.serialize(value.templateId),
            "add_or_update_fields": NullableSerializer(ArraySerializer(Properties.PropertyFieldSerializer())).serialize(value.addOrUpdateFields),
            "remove_fields": NullableSerializer(ArraySerializer(Serialization._StringSerializer)).serialize(value.removeFields),
            ]
            return .dictionary(output)
        }
        public func deserialize(_ json: JSON) -> PropertyGroupUpdate {
            switch json {
                case .dictionary(let dict):
                    let templateId = Serialization._StringSerializer.deserialize(dict["template_id"] ?? .null)
                    let addOrUpdateFields = NullableSerializer(ArraySerializer(Properties.PropertyFieldSerializer())).deserialize(dict["add_or_update_fields"] ?? .null)
                    let removeFields = NullableSerializer(ArraySerializer(Serialization._StringSerializer)).deserialize(dict["remove_fields"] ?? .null)
                    return PropertyGroupUpdate(templateId: templateId, addOrUpdateFields: addOrUpdateFields, removeFields: removeFields)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The PropertyGroupWithPath struct
    public class PropertyGroupWithPath: CustomStringConvertible {
        /// A unique identifier for the file.
        public let path: String
        /// Filled custom property templates associated with a file.
        public let propertyGroups: Array<Properties.PropertyGroup>
        public init(path: String, propertyGroups: Array<Properties.PropertyGroup>) {
            stringValidator(pattern: "/(.|[\\r\\n])*|id:.*|(ns:[0-9]+(/.*)?)")(path)
            self.path = path
            self.propertyGroups = propertyGroups
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PropertyGroupWithPathSerializer().serialize(self)))"
        }
    }
    public class PropertyGroupWithPathSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: PropertyGroupWithPath) -> JSON {
            let output = [ 
            "path": Serialization._StringSerializer.serialize(value.path),
            "property_groups": ArraySerializer(Properties.PropertyGroupSerializer()).serialize(value.propertyGroups),
            ]
            return .dictionary(output)
        }
        public func deserialize(_ json: JSON) -> PropertyGroupWithPath {
            switch json {
                case .dictionary(let dict):
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .null)
                    let propertyGroups = ArraySerializer(Properties.PropertyGroupSerializer()).deserialize(dict["property_groups"] ?? .null)
                    return PropertyGroupWithPath(path: path, propertyGroups: propertyGroups)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The RelocationArg struct
    public class RelocationArg: CustomStringConvertible {
        /// Path in the user's Dropbox to be copied or moved.
        public let fromPath: String
        /// Path in the user's Dropbox that is the destination.
        public let toPath: String
        public init(fromPath: String, toPath: String) {
            stringValidator(pattern: "(/(.|[\\r\\n])*)|(ns:[0-9]+(/.*)?)")(fromPath)
            self.fromPath = fromPath
            stringValidator(pattern: "(/(.|[\\r\\n])*)|(ns:[0-9]+(/.*)?)")(toPath)
            self.toPath = toPath
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(RelocationArgSerializer().serialize(self)))"
        }
    }
    public class RelocationArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: RelocationArg) -> JSON {
            let output = [ 
            "from_path": Serialization._StringSerializer.serialize(value.fromPath),
            "to_path": Serialization._StringSerializer.serialize(value.toPath),
            ]
            return .dictionary(output)
        }
        public func deserialize(_ json: JSON) -> RelocationArg {
            switch json {
                case .dictionary(let dict):
                    let fromPath = Serialization._StringSerializer.deserialize(dict["from_path"] ?? .null)
                    let toPath = Serialization._StringSerializer.deserialize(dict["to_path"] ?? .null)
                    return RelocationArg(fromPath: fromPath, toPath: toPath)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The RelocationError union
    public enum RelocationError: CustomStringConvertible {
        /// An unspecified error.
        case fromLookup(Files.LookupError)
        /// An unspecified error.
        case fromWrite(Files.WriteError)
        /// An unspecified error.
        case to(Files.WriteError)
        /// Shared folders can't be copied.
        case cantCopySharedFolder
        /// Your move operation would result in nested shared folders.  This is not allowed.
        case cantNestSharedFolder
        /// You cannot move a folder into itself.
        case cantMoveFolderIntoItself
        /// The operation would involve more than 10,000 files and folders.
        case tooManyFiles
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(RelocationErrorSerializer().serialize(self)))"
        }
    }
    public class RelocationErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: RelocationError) -> JSON {
            switch value {
                case .fromLookup(let arg):
                    var d = ["from_lookup": Files.LookupErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("from_lookup")
                    return .dictionary(d)
                case .fromWrite(let arg):
                    var d = ["from_write": Files.WriteErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("from_write")
                    return .dictionary(d)
                case .to(let arg):
                    var d = ["to": Files.WriteErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("to")
                    return .dictionary(d)
                case .cantCopySharedFolder:
                    var d = [String: JSON]()
                    d[".tag"] = .str("cant_copy_shared_folder")
                    return .dictionary(d)
                case .cantNestSharedFolder:
                    var d = [String: JSON]()
                    d[".tag"] = .str("cant_nest_shared_folder")
                    return .dictionary(d)
                case .cantMoveFolderIntoItself:
                    var d = [String: JSON]()
                    d[".tag"] = .str("cant_move_folder_into_itself")
                    return .dictionary(d)
                case .tooManyFiles:
                    var d = [String: JSON]()
                    d[".tag"] = .str("too_many_files")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        public func deserialize(_ json: JSON) -> RelocationError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "from_lookup":
                            let v = Files.LookupErrorSerializer().deserialize(d["from_lookup"] ?? .null)
                            return RelocationError.fromLookup(v)
                        case "from_write":
                            let v = Files.WriteErrorSerializer().deserialize(d["from_write"] ?? .null)
                            return RelocationError.fromWrite(v)
                        case "to":
                            let v = Files.WriteErrorSerializer().deserialize(d["to"] ?? .null)
                            return RelocationError.to(v)
                        case "cant_copy_shared_folder":
                            return RelocationError.cantCopySharedFolder
                        case "cant_nest_shared_folder":
                            return RelocationError.cantNestSharedFolder
                        case "cant_move_folder_into_itself":
                            return RelocationError.cantMoveFolderIntoItself
                        case "too_many_files":
                            return RelocationError.tooManyFiles
                        case "other":
                            return RelocationError.other
                        default:
                            return RelocationError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The RemovePropertiesArg struct
    public class RemovePropertiesArg: CustomStringConvertible {
        /// A unique identifier for the file.
        public let path: String
        /// A list of identifiers for a property template created by route properties/template/add.
        public let propertyTemplateIds: Array<String>
        public init(path: String, propertyTemplateIds: Array<String>) {
            stringValidator(pattern: "/(.|[\\r\\n])*|id:.*|(ns:[0-9]+(/.*)?)")(path)
            self.path = path
            arrayValidator(itemValidator: stringValidator(minLength: 1, pattern: "(/|ptid:).*"))(propertyTemplateIds)
            self.propertyTemplateIds = propertyTemplateIds
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(RemovePropertiesArgSerializer().serialize(self)))"
        }
    }
    public class RemovePropertiesArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: RemovePropertiesArg) -> JSON {
            let output = [ 
            "path": Serialization._StringSerializer.serialize(value.path),
            "property_template_ids": ArraySerializer(Serialization._StringSerializer).serialize(value.propertyTemplateIds),
            ]
            return .dictionary(output)
        }
        public func deserialize(_ json: JSON) -> RemovePropertiesArg {
            switch json {
                case .dictionary(let dict):
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .null)
                    let propertyTemplateIds = ArraySerializer(Serialization._StringSerializer).deserialize(dict["property_template_ids"] ?? .null)
                    return RemovePropertiesArg(path: path, propertyTemplateIds: propertyTemplateIds)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The RemovePropertiesError union
    public enum RemovePropertiesError: CustomStringConvertible {
        /// Property template does not exist for given identifier.
        case templateNotFound(String)
        /// You do not have the permissions to modify this property template.
        case restrictedContent
        /// An unspecified error.
        case other
        /// An unspecified error.
        case path(Files.LookupError)
        /// An unspecified error.
        case propertyGroupLookup(Files.LookUpPropertiesError)

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(RemovePropertiesErrorSerializer().serialize(self)))"
        }
    }
    public class RemovePropertiesErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: RemovePropertiesError) -> JSON {
            switch value {
                case .templateNotFound(let arg):
                    var d = ["template_not_found": Serialization._StringSerializer.serialize(arg)]
                    d[".tag"] = .str("template_not_found")
                    return .dictionary(d)
                case .restrictedContent:
                    var d = [String: JSON]()
                    d[".tag"] = .str("restricted_content")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
                case .path(let arg):
                    var d = ["path": Files.LookupErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("path")
                    return .dictionary(d)
                case .propertyGroupLookup(let arg):
                    var d = ["property_group_lookup": Files.LookUpPropertiesErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("property_group_lookup")
                    return .dictionary(d)
            }
        }
        public func deserialize(_ json: JSON) -> RemovePropertiesError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "template_not_found":
                            let v = Serialization._StringSerializer.deserialize(d["template_not_found"] ?? .null)
                            return RemovePropertiesError.templateNotFound(v)
                        case "restricted_content":
                            return RemovePropertiesError.restrictedContent
                        case "other":
                            return RemovePropertiesError.other
                        case "path":
                            let v = Files.LookupErrorSerializer().deserialize(d["path"] ?? .null)
                            return RemovePropertiesError.path(v)
                        case "property_group_lookup":
                            let v = Files.LookUpPropertiesErrorSerializer().deserialize(d["property_group_lookup"] ?? .null)
                            return RemovePropertiesError.propertyGroupLookup(v)
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The RestoreArg struct
    public class RestoreArg: CustomStringConvertible {
        /// The path to the file you want to restore.
        public let path: String
        /// The revision to restore for the file.
        public let rev: String
        public init(path: String, rev: String) {
            stringValidator(pattern: "(/(.|[\\r\\n])*)|(ns:[0-9]+(/.*)?)")(path)
            self.path = path
            stringValidator(minLength: 9, pattern: "[0-9a-f]+")(rev)
            self.rev = rev
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(RestoreArgSerializer().serialize(self)))"
        }
    }
    public class RestoreArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: RestoreArg) -> JSON {
            let output = [ 
            "path": Serialization._StringSerializer.serialize(value.path),
            "rev": Serialization._StringSerializer.serialize(value.rev),
            ]
            return .dictionary(output)
        }
        public func deserialize(_ json: JSON) -> RestoreArg {
            switch json {
                case .dictionary(let dict):
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .null)
                    let rev = Serialization._StringSerializer.deserialize(dict["rev"] ?? .null)
                    return RestoreArg(path: path, rev: rev)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The RestoreError union
    public enum RestoreError: CustomStringConvertible {
        /// An error occurs when downloading metadata for the file.
        case pathLookup(Files.LookupError)
        /// An error occurs when trying to restore the file to that path.
        case pathWrite(Files.WriteError)
        /// The revision is invalid. It may point to a different file.
        case invalidRevision
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(RestoreErrorSerializer().serialize(self)))"
        }
    }
    public class RestoreErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: RestoreError) -> JSON {
            switch value {
                case .pathLookup(let arg):
                    var d = ["path_lookup": Files.LookupErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("path_lookup")
                    return .dictionary(d)
                case .pathWrite(let arg):
                    var d = ["path_write": Files.WriteErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("path_write")
                    return .dictionary(d)
                case .invalidRevision:
                    var d = [String: JSON]()
                    d[".tag"] = .str("invalid_revision")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        public func deserialize(_ json: JSON) -> RestoreError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "path_lookup":
                            let v = Files.LookupErrorSerializer().deserialize(d["path_lookup"] ?? .null)
                            return RestoreError.pathLookup(v)
                        case "path_write":
                            let v = Files.WriteErrorSerializer().deserialize(d["path_write"] ?? .null)
                            return RestoreError.pathWrite(v)
                        case "invalid_revision":
                            return RestoreError.invalidRevision
                        case "other":
                            return RestoreError.other
                        default:
                            return RestoreError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The SaveCopyReferenceArg struct
    public class SaveCopyReferenceArg: CustomStringConvertible {
        /// A copy reference returned by copyReferenceGet.
        public let copyReference: String
        /// Path in the user's Dropbox that is the destination.
        public let path: String
        public init(copyReference: String, path: String) {
            stringValidator()(copyReference)
            self.copyReference = copyReference
            stringValidator(pattern: "/(.|[\\r\\n])*")(path)
            self.path = path
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SaveCopyReferenceArgSerializer().serialize(self)))"
        }
    }
    public class SaveCopyReferenceArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: SaveCopyReferenceArg) -> JSON {
            let output = [ 
            "copy_reference": Serialization._StringSerializer.serialize(value.copyReference),
            "path": Serialization._StringSerializer.serialize(value.path),
            ]
            return .dictionary(output)
        }
        public func deserialize(_ json: JSON) -> SaveCopyReferenceArg {
            switch json {
                case .dictionary(let dict):
                    let copyReference = Serialization._StringSerializer.deserialize(dict["copy_reference"] ?? .null)
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .null)
                    return SaveCopyReferenceArg(copyReference: copyReference, path: path)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The SaveCopyReferenceError union
    public enum SaveCopyReferenceError: CustomStringConvertible {
        /// An unspecified error.
        case path(Files.WriteError)
        /// The copy reference is invalid.
        case invalidCopyReference
        /// You don't have permission to save the given copy reference. Please make sure this app is same app which
        /// created the copy reference and the source user is still linked to the app.
        case noPermission
        /// The file referenced by the copy reference cannot be found.
        case notFound
        /// The operation would involve more than 10,000 files and folders.
        case tooManyFiles
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SaveCopyReferenceErrorSerializer().serialize(self)))"
        }
    }
    public class SaveCopyReferenceErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: SaveCopyReferenceError) -> JSON {
            switch value {
                case .path(let arg):
                    var d = ["path": Files.WriteErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("path")
                    return .dictionary(d)
                case .invalidCopyReference:
                    var d = [String: JSON]()
                    d[".tag"] = .str("invalid_copy_reference")
                    return .dictionary(d)
                case .noPermission:
                    var d = [String: JSON]()
                    d[".tag"] = .str("no_permission")
                    return .dictionary(d)
                case .notFound:
                    var d = [String: JSON]()
                    d[".tag"] = .str("not_found")
                    return .dictionary(d)
                case .tooManyFiles:
                    var d = [String: JSON]()
                    d[".tag"] = .str("too_many_files")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        public func deserialize(_ json: JSON) -> SaveCopyReferenceError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "path":
                            let v = Files.WriteErrorSerializer().deserialize(d["path"] ?? .null)
                            return SaveCopyReferenceError.path(v)
                        case "invalid_copy_reference":
                            return SaveCopyReferenceError.invalidCopyReference
                        case "no_permission":
                            return SaveCopyReferenceError.noPermission
                        case "not_found":
                            return SaveCopyReferenceError.notFound
                        case "too_many_files":
                            return SaveCopyReferenceError.tooManyFiles
                        case "other":
                            return SaveCopyReferenceError.other
                        default:
                            return SaveCopyReferenceError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The SaveCopyReferenceResult struct
    public class SaveCopyReferenceResult: CustomStringConvertible {
        /// The metadata of the saved file or folder in the user's Dropbox.
        public let metadata: Files.Metadata
        public init(metadata: Files.Metadata) {
            self.metadata = metadata
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SaveCopyReferenceResultSerializer().serialize(self)))"
        }
    }
    public class SaveCopyReferenceResultSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: SaveCopyReferenceResult) -> JSON {
            let output = [ 
            "metadata": Files.MetadataSerializer().serialize(value.metadata),
            ]
            return .dictionary(output)
        }
        public func deserialize(_ json: JSON) -> SaveCopyReferenceResult {
            switch json {
                case .dictionary(let dict):
                    let metadata = Files.MetadataSerializer().deserialize(dict["metadata"] ?? .null)
                    return SaveCopyReferenceResult(metadata: metadata)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The SaveUrlArg struct
    public class SaveUrlArg: CustomStringConvertible {
        /// The path in Dropbox where the URL will be saved to.
        public let path: String
        /// The URL to be saved.
        public let url: String
        public init(path: String, url: String) {
            stringValidator(pattern: "/(.|[\\r\\n])*")(path)
            self.path = path
            stringValidator()(url)
            self.url = url
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SaveUrlArgSerializer().serialize(self)))"
        }
    }
    public class SaveUrlArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: SaveUrlArg) -> JSON {
            let output = [ 
            "path": Serialization._StringSerializer.serialize(value.path),
            "url": Serialization._StringSerializer.serialize(value.url),
            ]
            return .dictionary(output)
        }
        public func deserialize(_ json: JSON) -> SaveUrlArg {
            switch json {
                case .dictionary(let dict):
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .null)
                    let url = Serialization._StringSerializer.deserialize(dict["url"] ?? .null)
                    return SaveUrlArg(path: path, url: url)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The SaveUrlError union
    public enum SaveUrlError: CustomStringConvertible {
        /// An unspecified error.
        case path(Files.WriteError)
        /// Failed downloading the given URL.
        case downloadFailed
        /// The given URL is invalid.
        case invalidUrl
        /// The file where the URL is saved to no longer exists.
        case notFound
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SaveUrlErrorSerializer().serialize(self)))"
        }
    }
    public class SaveUrlErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: SaveUrlError) -> JSON {
            switch value {
                case .path(let arg):
                    var d = ["path": Files.WriteErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("path")
                    return .dictionary(d)
                case .downloadFailed:
                    var d = [String: JSON]()
                    d[".tag"] = .str("download_failed")
                    return .dictionary(d)
                case .invalidUrl:
                    var d = [String: JSON]()
                    d[".tag"] = .str("invalid_url")
                    return .dictionary(d)
                case .notFound:
                    var d = [String: JSON]()
                    d[".tag"] = .str("not_found")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        public func deserialize(_ json: JSON) -> SaveUrlError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "path":
                            let v = Files.WriteErrorSerializer().deserialize(d["path"] ?? .null)
                            return SaveUrlError.path(v)
                        case "download_failed":
                            return SaveUrlError.downloadFailed
                        case "invalid_url":
                            return SaveUrlError.invalidUrl
                        case "not_found":
                            return SaveUrlError.notFound
                        case "other":
                            return SaveUrlError.other
                        default:
                            return SaveUrlError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The SaveUrlJobStatus union
    public enum SaveUrlJobStatus: CustomStringConvertible {
        /// The asynchronous job is still in progress.
        case inProgress
        /// Metadata of the file where the URL is saved to.
        case complete(Files.FileMetadata)
        /// An unspecified error.
        case failed(Files.SaveUrlError)

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SaveUrlJobStatusSerializer().serialize(self)))"
        }
    }
    public class SaveUrlJobStatusSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: SaveUrlJobStatus) -> JSON {
            switch value {
                case .inProgress:
                    var d = [String: JSON]()
                    d[".tag"] = .str("in_progress")
                    return .dictionary(d)
                case .complete(let arg):
                    var d = Serialization.getFields(Files.FileMetadataSerializer().serialize(arg))
                    d[".tag"] = .str("complete")
                    return .dictionary(d)
                case .failed(let arg):
                    var d = ["failed": Files.SaveUrlErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("failed")
                    return .dictionary(d)
            }
        }
        public func deserialize(_ json: JSON) -> SaveUrlJobStatus {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "in_progress":
                            return SaveUrlJobStatus.inProgress
                        case "complete":
                            let v = Files.FileMetadataSerializer().deserialize(json)
                            return SaveUrlJobStatus.complete(v)
                        case "failed":
                            let v = Files.SaveUrlErrorSerializer().deserialize(d["failed"] ?? .null)
                            return SaveUrlJobStatus.failed(v)
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The SaveUrlResult union
    public enum SaveUrlResult: CustomStringConvertible {
        /// This response indicates that the processing is asynchronous. The string is an id that can be used to obtain
        /// the status of the asynchronous job.
        case asyncJobId(String)
        /// Metadata of the file where the URL is saved to.
        case complete(Files.FileMetadata)

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SaveUrlResultSerializer().serialize(self)))"
        }
    }
    public class SaveUrlResultSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: SaveUrlResult) -> JSON {
            switch value {
                case .asyncJobId(let arg):
                    var d = ["async_job_id": Serialization._StringSerializer.serialize(arg)]
                    d[".tag"] = .str("async_job_id")
                    return .dictionary(d)
                case .complete(let arg):
                    var d = Serialization.getFields(Files.FileMetadataSerializer().serialize(arg))
                    d[".tag"] = .str("complete")
                    return .dictionary(d)
            }
        }
        public func deserialize(_ json: JSON) -> SaveUrlResult {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "async_job_id":
                            let v = Serialization._StringSerializer.deserialize(d["async_job_id"] ?? .null)
                            return SaveUrlResult.asyncJobId(v)
                        case "complete":
                            let v = Files.FileMetadataSerializer().deserialize(json)
                            return SaveUrlResult.complete(v)
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The SearchArg struct
    public class SearchArg: CustomStringConvertible {
        /// The path in the user's Dropbox to search. Should probably be a folder.
        public let path: String
        /// The string to search for. The search string is split on spaces into multiple tokens. For file name
        /// searching, the last token is used for prefix matching (i.e. "bat c" matches "bat cave" but not "batman
        /// car").
        public let query: String
        /// The starting index within the search results (used for paging).
        public let start: UInt64
        /// The maximum number of search results to return.
        public let maxResults: UInt64
        /// The search mode (filename, filename_and_content, or deleted_filename). Note that searching file content is
        /// only available for Dropbox Business accounts.
        public let mode: Files.SearchMode
        public init(path: String, query: String, start: UInt64 = 0, maxResults: UInt64 = 100, mode: Files.SearchMode = .filename) {
            stringValidator(pattern: "(/(.|[\\r\\n])*)?|(ns:[0-9]+(/.*)?)")(path)
            self.path = path
            stringValidator()(query)
            self.query = query
            comparableValidator()(start)
            self.start = start
            comparableValidator(minValue: 1, maxValue: 1000)(maxResults)
            self.maxResults = maxResults
            self.mode = mode
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SearchArgSerializer().serialize(self)))"
        }
    }
    public class SearchArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: SearchArg) -> JSON {
            let output = [ 
            "path": Serialization._StringSerializer.serialize(value.path),
            "query": Serialization._StringSerializer.serialize(value.query),
            "start": Serialization._UInt64Serializer.serialize(value.start),
            "max_results": Serialization._UInt64Serializer.serialize(value.maxResults),
            "mode": Files.SearchModeSerializer().serialize(value.mode),
            ]
            return .dictionary(output)
        }
        public func deserialize(_ json: JSON) -> SearchArg {
            switch json {
                case .dictionary(let dict):
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .null)
                    let query = Serialization._StringSerializer.deserialize(dict["query"] ?? .null)
                    let start = Serialization._UInt64Serializer.deserialize(dict["start"] ?? .number(0))
                    let maxResults = Serialization._UInt64Serializer.deserialize(dict["max_results"] ?? .number(100))
                    let mode = Files.SearchModeSerializer().deserialize(dict["mode"] ?? Files.SearchModeSerializer().serialize(.filename))
                    return SearchArg(path: path, query: query, start: start, maxResults: maxResults, mode: mode)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The SearchError union
    public enum SearchError: CustomStringConvertible {
        /// An unspecified error.
        case path(Files.LookupError)
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SearchErrorSerializer().serialize(self)))"
        }
    }
    public class SearchErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: SearchError) -> JSON {
            switch value {
                case .path(let arg):
                    var d = ["path": Files.LookupErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("path")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        public func deserialize(_ json: JSON) -> SearchError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "path":
                            let v = Files.LookupErrorSerializer().deserialize(d["path"] ?? .null)
                            return SearchError.path(v)
                        case "other":
                            return SearchError.other
                        default:
                            return SearchError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The SearchMatch struct
    public class SearchMatch: CustomStringConvertible {
        /// The type of the match.
        public let matchType: Files.SearchMatchType
        /// The metadata for the matched file or folder.
        public let metadata: Files.Metadata
        public init(matchType: Files.SearchMatchType, metadata: Files.Metadata) {
            self.matchType = matchType
            self.metadata = metadata
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SearchMatchSerializer().serialize(self)))"
        }
    }
    public class SearchMatchSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: SearchMatch) -> JSON {
            let output = [ 
            "match_type": Files.SearchMatchTypeSerializer().serialize(value.matchType),
            "metadata": Files.MetadataSerializer().serialize(value.metadata),
            ]
            return .dictionary(output)
        }
        public func deserialize(_ json: JSON) -> SearchMatch {
            switch json {
                case .dictionary(let dict):
                    let matchType = Files.SearchMatchTypeSerializer().deserialize(dict["match_type"] ?? .null)
                    let metadata = Files.MetadataSerializer().deserialize(dict["metadata"] ?? .null)
                    return SearchMatch(matchType: matchType, metadata: metadata)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Indicates what type of match was found for a given item.
    public enum SearchMatchType: CustomStringConvertible {
        /// This item was matched on its file or folder name.
        case filename
        /// This item was matched based on its file contents.
        case content
        /// This item was matched based on both its contents and its file name.
        case both

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SearchMatchTypeSerializer().serialize(self)))"
        }
    }
    public class SearchMatchTypeSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: SearchMatchType) -> JSON {
            switch value {
                case .filename:
                    var d = [String: JSON]()
                    d[".tag"] = .str("filename")
                    return .dictionary(d)
                case .content:
                    var d = [String: JSON]()
                    d[".tag"] = .str("content")
                    return .dictionary(d)
                case .both:
                    var d = [String: JSON]()
                    d[".tag"] = .str("both")
                    return .dictionary(d)
            }
        }
        public func deserialize(_ json: JSON) -> SearchMatchType {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "filename":
                            return SearchMatchType.filename
                        case "content":
                            return SearchMatchType.content
                        case "both":
                            return SearchMatchType.both
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The SearchMode union
    public enum SearchMode: CustomStringConvertible {
        /// Search file and folder names.
        case filename
        /// Search file and folder names as well as file contents.
        case filenameAndContent
        /// Search for deleted file and folder names.
        case deletedFilename

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SearchModeSerializer().serialize(self)))"
        }
    }
    public class SearchModeSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: SearchMode) -> JSON {
            switch value {
                case .filename:
                    var d = [String: JSON]()
                    d[".tag"] = .str("filename")
                    return .dictionary(d)
                case .filenameAndContent:
                    var d = [String: JSON]()
                    d[".tag"] = .str("filename_and_content")
                    return .dictionary(d)
                case .deletedFilename:
                    var d = [String: JSON]()
                    d[".tag"] = .str("deleted_filename")
                    return .dictionary(d)
            }
        }
        public func deserialize(_ json: JSON) -> SearchMode {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "filename":
                            return SearchMode.filename
                        case "filename_and_content":
                            return SearchMode.filenameAndContent
                        case "deleted_filename":
                            return SearchMode.deletedFilename
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The SearchResult struct
    public class SearchResult: CustomStringConvertible {
        /// A list (possibly empty) of matches for the query.
        public let matches: Array<Files.SearchMatch>
        /// Used for paging. If true, indicates there is another page of results available that can be fetched by
        /// calling search again.
        public let more: Bool
        /// Used for paging. Value to set the start argument to when calling search to fetch the next page of results.
        public let start: UInt64
        public init(matches: Array<Files.SearchMatch>, more: Bool, start: UInt64) {
            self.matches = matches
            self.more = more
            comparableValidator()(start)
            self.start = start
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SearchResultSerializer().serialize(self)))"
        }
    }
    public class SearchResultSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: SearchResult) -> JSON {
            let output = [ 
            "matches": ArraySerializer(Files.SearchMatchSerializer()).serialize(value.matches),
            "more": Serialization._BoolSerializer.serialize(value.more),
            "start": Serialization._UInt64Serializer.serialize(value.start),
            ]
            return .dictionary(output)
        }
        public func deserialize(_ json: JSON) -> SearchResult {
            switch json {
                case .dictionary(let dict):
                    let matches = ArraySerializer(Files.SearchMatchSerializer()).deserialize(dict["matches"] ?? .null)
                    let more = Serialization._BoolSerializer.deserialize(dict["more"] ?? .null)
                    let start = Serialization._UInt64Serializer.deserialize(dict["start"] ?? .null)
                    return SearchResult(matches: matches, more: more, start: start)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The ThumbnailArg struct
    public class ThumbnailArg: CustomStringConvertible {
        /// The path to the image file you want to thumbnail.
        public let path: String
        /// The format for the thumbnail image, jpeg (default) or png. For  images that are photos, jpeg should be
        /// preferred, while png is  better for screenshots and digital arts.
        public let format: Files.ThumbnailFormat
        /// The size for the thumbnail image.
        public let size: Files.ThumbnailSize
        public init(path: String, format: Files.ThumbnailFormat = .jpeg, size: Files.ThumbnailSize = .w64h64) {
            stringValidator(pattern: "(/(.|[\\r\\n])*|id:.*)|(rev:[0-9a-f]{9,})|(ns:[0-9]+(/.*)?)")(path)
            self.path = path
            self.format = format
            self.size = size
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ThumbnailArgSerializer().serialize(self)))"
        }
    }
    public class ThumbnailArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: ThumbnailArg) -> JSON {
            let output = [ 
            "path": Serialization._StringSerializer.serialize(value.path),
            "format": Files.ThumbnailFormatSerializer().serialize(value.format),
            "size": Files.ThumbnailSizeSerializer().serialize(value.size),
            ]
            return .dictionary(output)
        }
        public func deserialize(_ json: JSON) -> ThumbnailArg {
            switch json {
                case .dictionary(let dict):
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .null)
                    let format = Files.ThumbnailFormatSerializer().deserialize(dict["format"] ?? Files.ThumbnailFormatSerializer().serialize(.jpeg))
                    let size = Files.ThumbnailSizeSerializer().deserialize(dict["size"] ?? Files.ThumbnailSizeSerializer().serialize(.w64h64))
                    return ThumbnailArg(path: path, format: format, size: size)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The ThumbnailError union
    public enum ThumbnailError: CustomStringConvertible {
        /// An error occurs when downloading metadata for the image.
        case path(Files.LookupError)
        /// The file extension doesn't allow conversion to a thumbnail.
        case unsupportedExtension
        /// The image cannot be converted to a thumbnail.
        case unsupportedImage
        /// An error occurs during thumbnail conversion.
        case conversionError

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ThumbnailErrorSerializer().serialize(self)))"
        }
    }
    public class ThumbnailErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: ThumbnailError) -> JSON {
            switch value {
                case .path(let arg):
                    var d = ["path": Files.LookupErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("path")
                    return .dictionary(d)
                case .unsupportedExtension:
                    var d = [String: JSON]()
                    d[".tag"] = .str("unsupported_extension")
                    return .dictionary(d)
                case .unsupportedImage:
                    var d = [String: JSON]()
                    d[".tag"] = .str("unsupported_image")
                    return .dictionary(d)
                case .conversionError:
                    var d = [String: JSON]()
                    d[".tag"] = .str("conversion_error")
                    return .dictionary(d)
            }
        }
        public func deserialize(_ json: JSON) -> ThumbnailError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "path":
                            let v = Files.LookupErrorSerializer().deserialize(d["path"] ?? .null)
                            return ThumbnailError.path(v)
                        case "unsupported_extension":
                            return ThumbnailError.unsupportedExtension
                        case "unsupported_image":
                            return ThumbnailError.unsupportedImage
                        case "conversion_error":
                            return ThumbnailError.conversionError
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The ThumbnailFormat union
    public enum ThumbnailFormat: CustomStringConvertible {
        /// An unspecified error.
        case jpeg
        /// An unspecified error.
        case png

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ThumbnailFormatSerializer().serialize(self)))"
        }
    }
    public class ThumbnailFormatSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: ThumbnailFormat) -> JSON {
            switch value {
                case .jpeg:
                    var d = [String: JSON]()
                    d[".tag"] = .str("jpeg")
                    return .dictionary(d)
                case .png:
                    var d = [String: JSON]()
                    d[".tag"] = .str("png")
                    return .dictionary(d)
            }
        }
        public func deserialize(_ json: JSON) -> ThumbnailFormat {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "jpeg":
                            return ThumbnailFormat.jpeg
                        case "png":
                            return ThumbnailFormat.png
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The ThumbnailSize union
    public enum ThumbnailSize: CustomStringConvertible {
        /// 32 by 32 px.
        case w32h32
        /// 64 by 64 px.
        case w64h64
        /// 128 by 128 px.
        case w128h128
        /// 640 by 480 px.
        case w640h480
        /// 1024 by 768
        case w1024h768

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ThumbnailSizeSerializer().serialize(self)))"
        }
    }
    public class ThumbnailSizeSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: ThumbnailSize) -> JSON {
            switch value {
                case .w32h32:
                    var d = [String: JSON]()
                    d[".tag"] = .str("w32h32")
                    return .dictionary(d)
                case .w64h64:
                    var d = [String: JSON]()
                    d[".tag"] = .str("w64h64")
                    return .dictionary(d)
                case .w128h128:
                    var d = [String: JSON]()
                    d[".tag"] = .str("w128h128")
                    return .dictionary(d)
                case .w640h480:
                    var d = [String: JSON]()
                    d[".tag"] = .str("w640h480")
                    return .dictionary(d)
                case .w1024h768:
                    var d = [String: JSON]()
                    d[".tag"] = .str("w1024h768")
                    return .dictionary(d)
            }
        }
        public func deserialize(_ json: JSON) -> ThumbnailSize {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "w32h32":
                            return ThumbnailSize.w32h32
                        case "w64h64":
                            return ThumbnailSize.w64h64
                        case "w128h128":
                            return ThumbnailSize.w128h128
                        case "w640h480":
                            return ThumbnailSize.w640h480
                        case "w1024h768":
                            return ThumbnailSize.w1024h768
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The UpdatePropertiesError union
    public enum UpdatePropertiesError: CustomStringConvertible {
        /// Property template does not exist for given identifier.
        case templateNotFound(String)
        /// You do not have the permissions to modify this property template.
        case restrictedContent
        /// An unspecified error.
        case other
        /// An unspecified error.
        case path(Files.LookupError)
        /// A field value in this property group is too large.
        case propertyFieldTooLarge
        /// The property group specified does not conform to the property template.
        case doesNotFitTemplate
        /// An unspecified error.
        case propertyGroupLookup(Files.LookUpPropertiesError)

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(UpdatePropertiesErrorSerializer().serialize(self)))"
        }
    }
    public class UpdatePropertiesErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: UpdatePropertiesError) -> JSON {
            switch value {
                case .templateNotFound(let arg):
                    var d = ["template_not_found": Serialization._StringSerializer.serialize(arg)]
                    d[".tag"] = .str("template_not_found")
                    return .dictionary(d)
                case .restrictedContent:
                    var d = [String: JSON]()
                    d[".tag"] = .str("restricted_content")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
                case .path(let arg):
                    var d = ["path": Files.LookupErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("path")
                    return .dictionary(d)
                case .propertyFieldTooLarge:
                    var d = [String: JSON]()
                    d[".tag"] = .str("property_field_too_large")
                    return .dictionary(d)
                case .doesNotFitTemplate:
                    var d = [String: JSON]()
                    d[".tag"] = .str("does_not_fit_template")
                    return .dictionary(d)
                case .propertyGroupLookup(let arg):
                    var d = ["property_group_lookup": Files.LookUpPropertiesErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("property_group_lookup")
                    return .dictionary(d)
            }
        }
        public func deserialize(_ json: JSON) -> UpdatePropertiesError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "template_not_found":
                            let v = Serialization._StringSerializer.deserialize(d["template_not_found"] ?? .null)
                            return UpdatePropertiesError.templateNotFound(v)
                        case "restricted_content":
                            return UpdatePropertiesError.restrictedContent
                        case "other":
                            return UpdatePropertiesError.other
                        case "path":
                            let v = Files.LookupErrorSerializer().deserialize(d["path"] ?? .null)
                            return UpdatePropertiesError.path(v)
                        case "property_field_too_large":
                            return UpdatePropertiesError.propertyFieldTooLarge
                        case "does_not_fit_template":
                            return UpdatePropertiesError.doesNotFitTemplate
                        case "property_group_lookup":
                            let v = Files.LookUpPropertiesErrorSerializer().deserialize(d["property_group_lookup"] ?? .null)
                            return UpdatePropertiesError.propertyGroupLookup(v)
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The UpdatePropertyGroupArg struct
    public class UpdatePropertyGroupArg: CustomStringConvertible {
        /// A unique identifier for the file.
        public let path: String
        /// Filled custom property templates associated with a file.
        public let updatePropertyGroups: Array<Files.PropertyGroupUpdate>
        public init(path: String, updatePropertyGroups: Array<Files.PropertyGroupUpdate>) {
            stringValidator(pattern: "/(.|[\\r\\n])*|id:.*|(ns:[0-9]+(/.*)?)")(path)
            self.path = path
            self.updatePropertyGroups = updatePropertyGroups
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(UpdatePropertyGroupArgSerializer().serialize(self)))"
        }
    }
    public class UpdatePropertyGroupArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: UpdatePropertyGroupArg) -> JSON {
            let output = [ 
            "path": Serialization._StringSerializer.serialize(value.path),
            "update_property_groups": ArraySerializer(Files.PropertyGroupUpdateSerializer()).serialize(value.updatePropertyGroups),
            ]
            return .dictionary(output)
        }
        public func deserialize(_ json: JSON) -> UpdatePropertyGroupArg {
            switch json {
                case .dictionary(let dict):
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .null)
                    let updatePropertyGroups = ArraySerializer(Files.PropertyGroupUpdateSerializer()).deserialize(dict["update_property_groups"] ?? .null)
                    return UpdatePropertyGroupArg(path: path, updatePropertyGroups: updatePropertyGroups)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The UploadError union
    public enum UploadError: CustomStringConvertible {
        /// Unable to save the uploaded contents to a file.
        case path(Files.UploadWriteFailed)
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(UploadErrorSerializer().serialize(self)))"
        }
    }
    public class UploadErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: UploadError) -> JSON {
            switch value {
                case .path(let arg):
                    var d = Serialization.getFields(Files.UploadWriteFailedSerializer().serialize(arg))
                    d[".tag"] = .str("path")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        public func deserialize(_ json: JSON) -> UploadError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "path":
                            let v = Files.UploadWriteFailedSerializer().deserialize(json)
                            return UploadError.path(v)
                        case "other":
                            return UploadError.other
                        default:
                            return UploadError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The UploadErrorWithProperties union
    public enum UploadErrorWithProperties: CustomStringConvertible {
        /// Unable to save the uploaded contents to a file.
        case path(Files.UploadWriteFailed)
        /// An unspecified error.
        case other
        /// An unspecified error.
        case propertiesError(Files.InvalidPropertyGroupError)

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(UploadErrorWithPropertiesSerializer().serialize(self)))"
        }
    }
    public class UploadErrorWithPropertiesSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: UploadErrorWithProperties) -> JSON {
            switch value {
                case .path(let arg):
                    var d = Serialization.getFields(Files.UploadWriteFailedSerializer().serialize(arg))
                    d[".tag"] = .str("path")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
                case .propertiesError(let arg):
                    var d = ["properties_error": Files.InvalidPropertyGroupErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("properties_error")
                    return .dictionary(d)
            }
        }
        public func deserialize(_ json: JSON) -> UploadErrorWithProperties {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "path":
                            let v = Files.UploadWriteFailedSerializer().deserialize(json)
                            return UploadErrorWithProperties.path(v)
                        case "other":
                            return UploadErrorWithProperties.other
                        case "properties_error":
                            let v = Files.InvalidPropertyGroupErrorSerializer().deserialize(d["properties_error"] ?? .null)
                            return UploadErrorWithProperties.propertiesError(v)
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The UploadSessionAppendArg struct
    public class UploadSessionAppendArg: CustomStringConvertible {
        /// Contains the upload session ID and the offset.
        public let cursor: Files.UploadSessionCursor
        /// If true, the current session will be closed, at which point you won't be able to call uploadSessionAppendV2
        /// anymore with the current session.
        public let close: Bool
        public init(cursor: Files.UploadSessionCursor, close: Bool = false) {
            self.cursor = cursor
            self.close = close
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(UploadSessionAppendArgSerializer().serialize(self)))"
        }
    }
    public class UploadSessionAppendArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: UploadSessionAppendArg) -> JSON {
            let output = [ 
            "cursor": Files.UploadSessionCursorSerializer().serialize(value.cursor),
            "close": Serialization._BoolSerializer.serialize(value.close),
            ]
            return .dictionary(output)
        }
        public func deserialize(_ json: JSON) -> UploadSessionAppendArg {
            switch json {
                case .dictionary(let dict):
                    let cursor = Files.UploadSessionCursorSerializer().deserialize(dict["cursor"] ?? .null)
                    let close = Serialization._BoolSerializer.deserialize(dict["close"] ?? .number(0))
                    return UploadSessionAppendArg(cursor: cursor, close: close)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The UploadSessionCursor struct
    public class UploadSessionCursor: CustomStringConvertible {
        /// The upload session ID (returned by uploadSessionStart).
        public let sessionId: String
        /// The amount of data that has been uploaded so far. We use this to make sure upload data isn't lost or
        /// duplicated in the event of a network error.
        public let offset: UInt64
        public init(sessionId: String, offset: UInt64) {
            stringValidator()(sessionId)
            self.sessionId = sessionId
            comparableValidator()(offset)
            self.offset = offset
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(UploadSessionCursorSerializer().serialize(self)))"
        }
    }
    public class UploadSessionCursorSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: UploadSessionCursor) -> JSON {
            let output = [ 
            "session_id": Serialization._StringSerializer.serialize(value.sessionId),
            "offset": Serialization._UInt64Serializer.serialize(value.offset),
            ]
            return .dictionary(output)
        }
        public func deserialize(_ json: JSON) -> UploadSessionCursor {
            switch json {
                case .dictionary(let dict):
                    let sessionId = Serialization._StringSerializer.deserialize(dict["session_id"] ?? .null)
                    let offset = Serialization._UInt64Serializer.deserialize(dict["offset"] ?? .null)
                    return UploadSessionCursor(sessionId: sessionId, offset: offset)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The UploadSessionFinishArg struct
    public class UploadSessionFinishArg: CustomStringConvertible {
        /// Contains the upload session ID and the offset.
        public let cursor: Files.UploadSessionCursor
        /// Contains the path and other optional modifiers for the commit.
        public let commit: Files.CommitInfo
        public init(cursor: Files.UploadSessionCursor, commit: Files.CommitInfo) {
            self.cursor = cursor
            self.commit = commit
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(UploadSessionFinishArgSerializer().serialize(self)))"
        }
    }
    public class UploadSessionFinishArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: UploadSessionFinishArg) -> JSON {
            let output = [ 
            "cursor": Files.UploadSessionCursorSerializer().serialize(value.cursor),
            "commit": Files.CommitInfoSerializer().serialize(value.commit),
            ]
            return .dictionary(output)
        }
        public func deserialize(_ json: JSON) -> UploadSessionFinishArg {
            switch json {
                case .dictionary(let dict):
                    let cursor = Files.UploadSessionCursorSerializer().deserialize(dict["cursor"] ?? .null)
                    let commit = Files.CommitInfoSerializer().deserialize(dict["commit"] ?? .null)
                    return UploadSessionFinishArg(cursor: cursor, commit: commit)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The UploadSessionFinishBatchArg struct
    public class UploadSessionFinishBatchArg: CustomStringConvertible {
        /// Commit information for each file in the batch.
        public let entries: Array<Files.UploadSessionFinishArg>
        public init(entries: Array<Files.UploadSessionFinishArg>) {
            self.entries = entries
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(UploadSessionFinishBatchArgSerializer().serialize(self)))"
        }
    }
    public class UploadSessionFinishBatchArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: UploadSessionFinishBatchArg) -> JSON {
            let output = [ 
            "entries": ArraySerializer(Files.UploadSessionFinishArgSerializer()).serialize(value.entries),
            ]
            return .dictionary(output)
        }
        public func deserialize(_ json: JSON) -> UploadSessionFinishBatchArg {
            switch json {
                case .dictionary(let dict):
                    let entries = ArraySerializer(Files.UploadSessionFinishArgSerializer()).deserialize(dict["entries"] ?? .null)
                    return UploadSessionFinishBatchArg(entries: entries)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The UploadSessionFinishBatchJobStatus union
    public enum UploadSessionFinishBatchJobStatus: CustomStringConvertible {
        /// The asynchronous job is still in progress.
        case inProgress
        /// The uploadSessionFinishBatch has finished.
        case complete(Files.UploadSessionFinishBatchResult)

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(UploadSessionFinishBatchJobStatusSerializer().serialize(self)))"
        }
    }
    public class UploadSessionFinishBatchJobStatusSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: UploadSessionFinishBatchJobStatus) -> JSON {
            switch value {
                case .inProgress:
                    var d = [String: JSON]()
                    d[".tag"] = .str("in_progress")
                    return .dictionary(d)
                case .complete(let arg):
                    var d = Serialization.getFields(Files.UploadSessionFinishBatchResultSerializer().serialize(arg))
                    d[".tag"] = .str("complete")
                    return .dictionary(d)
            }
        }
        public func deserialize(_ json: JSON) -> UploadSessionFinishBatchJobStatus {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "in_progress":
                            return UploadSessionFinishBatchJobStatus.inProgress
                        case "complete":
                            let v = Files.UploadSessionFinishBatchResultSerializer().deserialize(json)
                            return UploadSessionFinishBatchJobStatus.complete(v)
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The UploadSessionFinishBatchResult struct
    public class UploadSessionFinishBatchResult: CustomStringConvertible {
        /// Commit result for each file in the batch.
        public let entries: Array<Files.UploadSessionFinishBatchResultEntry>
        public init(entries: Array<Files.UploadSessionFinishBatchResultEntry>) {
            self.entries = entries
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(UploadSessionFinishBatchResultSerializer().serialize(self)))"
        }
    }
    public class UploadSessionFinishBatchResultSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: UploadSessionFinishBatchResult) -> JSON {
            let output = [ 
            "entries": ArraySerializer(Files.UploadSessionFinishBatchResultEntrySerializer()).serialize(value.entries),
            ]
            return .dictionary(output)
        }
        public func deserialize(_ json: JSON) -> UploadSessionFinishBatchResult {
            switch json {
                case .dictionary(let dict):
                    let entries = ArraySerializer(Files.UploadSessionFinishBatchResultEntrySerializer()).deserialize(dict["entries"] ?? .null)
                    return UploadSessionFinishBatchResult(entries: entries)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The UploadSessionFinishBatchResultEntry union
    public enum UploadSessionFinishBatchResultEntry: CustomStringConvertible {
        /// An unspecified error.
        case success(Files.FileMetadata)
        /// An unspecified error.
        case failure(Files.UploadSessionFinishError)

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(UploadSessionFinishBatchResultEntrySerializer().serialize(self)))"
        }
    }
    public class UploadSessionFinishBatchResultEntrySerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: UploadSessionFinishBatchResultEntry) -> JSON {
            switch value {
                case .success(let arg):
                    var d = Serialization.getFields(Files.FileMetadataSerializer().serialize(arg))
                    d[".tag"] = .str("success")
                    return .dictionary(d)
                case .failure(let arg):
                    var d = ["failure": Files.UploadSessionFinishErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("failure")
                    return .dictionary(d)
            }
        }
        public func deserialize(_ json: JSON) -> UploadSessionFinishBatchResultEntry {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "success":
                            let v = Files.FileMetadataSerializer().deserialize(json)
                            return UploadSessionFinishBatchResultEntry.success(v)
                        case "failure":
                            let v = Files.UploadSessionFinishErrorSerializer().deserialize(d["failure"] ?? .null)
                            return UploadSessionFinishBatchResultEntry.failure(v)
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The UploadSessionFinishError union
    public enum UploadSessionFinishError: CustomStringConvertible {
        /// The session arguments are incorrect; the value explains the reason.
        case lookupFailed(Files.UploadSessionLookupError)
        /// Unable to save the uploaded contents to a file.
        case path(Files.WriteError)
        /// The batch request commits files into too many different shared folders. Please limit your batch request to
        /// files contained in a single shared folder.
        case tooManySharedFolderTargets
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(UploadSessionFinishErrorSerializer().serialize(self)))"
        }
    }
    public class UploadSessionFinishErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: UploadSessionFinishError) -> JSON {
            switch value {
                case .lookupFailed(let arg):
                    var d = ["lookup_failed": Files.UploadSessionLookupErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("lookup_failed")
                    return .dictionary(d)
                case .path(let arg):
                    var d = ["path": Files.WriteErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("path")
                    return .dictionary(d)
                case .tooManySharedFolderTargets:
                    var d = [String: JSON]()
                    d[".tag"] = .str("too_many_shared_folder_targets")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        public func deserialize(_ json: JSON) -> UploadSessionFinishError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "lookup_failed":
                            let v = Files.UploadSessionLookupErrorSerializer().deserialize(d["lookup_failed"] ?? .null)
                            return UploadSessionFinishError.lookupFailed(v)
                        case "path":
                            let v = Files.WriteErrorSerializer().deserialize(d["path"] ?? .null)
                            return UploadSessionFinishError.path(v)
                        case "too_many_shared_folder_targets":
                            return UploadSessionFinishError.tooManySharedFolderTargets
                        case "other":
                            return UploadSessionFinishError.other
                        default:
                            return UploadSessionFinishError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The UploadSessionLookupError union
    public enum UploadSessionLookupError: CustomStringConvertible {
        /// The upload session id was not found.
        case notFound
        /// The specified offset was incorrect. See the value for the correct offset. (This error may occur when a
        /// previous request was received and processed successfully but the client did not receive the response, e.g.
        /// due to a network error.)
        case incorrectOffset(Files.UploadSessionOffsetError)
        /// You are attempting to append data to an upload session that has alread been closed (i.e. committed).
        case closed
        /// The session must be closed before calling upload_session/finish_batch.
        case notClosed
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(UploadSessionLookupErrorSerializer().serialize(self)))"
        }
    }
    public class UploadSessionLookupErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: UploadSessionLookupError) -> JSON {
            switch value {
                case .notFound:
                    var d = [String: JSON]()
                    d[".tag"] = .str("not_found")
                    return .dictionary(d)
                case .incorrectOffset(let arg):
                    var d = Serialization.getFields(Files.UploadSessionOffsetErrorSerializer().serialize(arg))
                    d[".tag"] = .str("incorrect_offset")
                    return .dictionary(d)
                case .closed:
                    var d = [String: JSON]()
                    d[".tag"] = .str("closed")
                    return .dictionary(d)
                case .notClosed:
                    var d = [String: JSON]()
                    d[".tag"] = .str("not_closed")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        public func deserialize(_ json: JSON) -> UploadSessionLookupError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "not_found":
                            return UploadSessionLookupError.notFound
                        case "incorrect_offset":
                            let v = Files.UploadSessionOffsetErrorSerializer().deserialize(json)
                            return UploadSessionLookupError.incorrectOffset(v)
                        case "closed":
                            return UploadSessionLookupError.closed
                        case "not_closed":
                            return UploadSessionLookupError.notClosed
                        case "other":
                            return UploadSessionLookupError.other
                        default:
                            return UploadSessionLookupError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The UploadSessionOffsetError struct
    public class UploadSessionOffsetError: CustomStringConvertible {
        /// The offset up to which data has been collected.
        public let correctOffset: UInt64
        public init(correctOffset: UInt64) {
            comparableValidator()(correctOffset)
            self.correctOffset = correctOffset
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(UploadSessionOffsetErrorSerializer().serialize(self)))"
        }
    }
    public class UploadSessionOffsetErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: UploadSessionOffsetError) -> JSON {
            let output = [ 
            "correct_offset": Serialization._UInt64Serializer.serialize(value.correctOffset),
            ]
            return .dictionary(output)
        }
        public func deserialize(_ json: JSON) -> UploadSessionOffsetError {
            switch json {
                case .dictionary(let dict):
                    let correctOffset = Serialization._UInt64Serializer.deserialize(dict["correct_offset"] ?? .null)
                    return UploadSessionOffsetError(correctOffset: correctOffset)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The UploadSessionStartArg struct
    public class UploadSessionStartArg: CustomStringConvertible {
        /// If true, the current session will be closed, at which point you won't be able to call uploadSessionAppendV2
        /// anymore with the current session.
        public let close: Bool
        public init(close: Bool = false) {
            self.close = close
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(UploadSessionStartArgSerializer().serialize(self)))"
        }
    }
    public class UploadSessionStartArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: UploadSessionStartArg) -> JSON {
            let output = [ 
            "close": Serialization._BoolSerializer.serialize(value.close),
            ]
            return .dictionary(output)
        }
        public func deserialize(_ json: JSON) -> UploadSessionStartArg {
            switch json {
                case .dictionary(let dict):
                    let close = Serialization._BoolSerializer.deserialize(dict["close"] ?? .number(0))
                    return UploadSessionStartArg(close: close)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The UploadSessionStartResult struct
    public class UploadSessionStartResult: CustomStringConvertible {
        /// A unique identifier for the upload session. Pass this to uploadSessionAppendV2 and uploadSessionFinish.
        public let sessionId: String
        public init(sessionId: String) {
            stringValidator()(sessionId)
            self.sessionId = sessionId
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(UploadSessionStartResultSerializer().serialize(self)))"
        }
    }
    public class UploadSessionStartResultSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: UploadSessionStartResult) -> JSON {
            let output = [ 
            "session_id": Serialization._StringSerializer.serialize(value.sessionId),
            ]
            return .dictionary(output)
        }
        public func deserialize(_ json: JSON) -> UploadSessionStartResult {
            switch json {
                case .dictionary(let dict):
                    let sessionId = Serialization._StringSerializer.deserialize(dict["session_id"] ?? .null)
                    return UploadSessionStartResult(sessionId: sessionId)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The UploadWriteFailed struct
    public class UploadWriteFailed: CustomStringConvertible {
        /// The reason why the file couldn't be saved.
        public let reason: Files.WriteError
        /// The upload session ID; this may be used to retry the commit.
        public let uploadSessionId: String
        public init(reason: Files.WriteError, uploadSessionId: String) {
            self.reason = reason
            stringValidator()(uploadSessionId)
            self.uploadSessionId = uploadSessionId
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(UploadWriteFailedSerializer().serialize(self)))"
        }
    }
    public class UploadWriteFailedSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: UploadWriteFailed) -> JSON {
            let output = [ 
            "reason": Files.WriteErrorSerializer().serialize(value.reason),
            "upload_session_id": Serialization._StringSerializer.serialize(value.uploadSessionId),
            ]
            return .dictionary(output)
        }
        public func deserialize(_ json: JSON) -> UploadWriteFailed {
            switch json {
                case .dictionary(let dict):
                    let reason = Files.WriteErrorSerializer().deserialize(dict["reason"] ?? .null)
                    let uploadSessionId = Serialization._StringSerializer.deserialize(dict["upload_session_id"] ?? .null)
                    return UploadWriteFailed(reason: reason, uploadSessionId: uploadSessionId)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Metadata for a video.
    public class VideoMetadata: Files.MediaMetadata {
        /// The duration of the video in milliseconds.
        public let duration: UInt64?
        public init(dimensions: Files.Dimensions? = nil, location: Files.GpsCoordinates? = nil, timeTaken: Date? = nil, duration: UInt64? = nil) {
            nullableValidator(comparableValidator())(duration)
            self.duration = duration
            super.init(dimensions: dimensions, location: location, timeTaken: timeTaken)
        }
        public override var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(VideoMetadataSerializer().serialize(self)))"
        }
    }
    public class VideoMetadataSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: VideoMetadata) -> JSON {
            let output = [ 
            "dimensions": NullableSerializer(Files.DimensionsSerializer()).serialize(value.dimensions),
            "location": NullableSerializer(Files.GpsCoordinatesSerializer()).serialize(value.location),
            "time_taken": NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.timeTaken),
            "duration": NullableSerializer(Serialization._UInt64Serializer).serialize(value.duration),
            ]
            return .dictionary(output)
        }
        public func deserialize(_ json: JSON) -> VideoMetadata {
            switch json {
                case .dictionary(let dict):
                    let dimensions = NullableSerializer(Files.DimensionsSerializer()).deserialize(dict["dimensions"] ?? .null)
                    let location = NullableSerializer(Files.GpsCoordinatesSerializer()).deserialize(dict["location"] ?? .null)
                    let timeTaken = NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).deserialize(dict["time_taken"] ?? .null)
                    let duration = NullableSerializer(Serialization._UInt64Serializer).deserialize(dict["duration"] ?? .null)
                    return VideoMetadata(dimensions: dimensions, location: location, timeTaken: timeTaken, duration: duration)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The WriteConflictError union
    public enum WriteConflictError: CustomStringConvertible {
        /// There's a file in the way.
        case file
        /// There's a folder in the way.
        case folder
        /// There's a file at an ancestor path, so we couldn't create the required parent folders.
        case fileAncestor
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(WriteConflictErrorSerializer().serialize(self)))"
        }
    }
    public class WriteConflictErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: WriteConflictError) -> JSON {
            switch value {
                case .file:
                    var d = [String: JSON]()
                    d[".tag"] = .str("file")
                    return .dictionary(d)
                case .folder:
                    var d = [String: JSON]()
                    d[".tag"] = .str("folder")
                    return .dictionary(d)
                case .fileAncestor:
                    var d = [String: JSON]()
                    d[".tag"] = .str("file_ancestor")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        public func deserialize(_ json: JSON) -> WriteConflictError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "file":
                            return WriteConflictError.file
                        case "folder":
                            return WriteConflictError.folder
                        case "file_ancestor":
                            return WriteConflictError.fileAncestor
                        case "other":
                            return WriteConflictError.other
                        default:
                            return WriteConflictError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The WriteError union
    public enum WriteError: CustomStringConvertible {
        /// An unspecified error.
        case malformedPath(String?)
        /// Couldn't write to the target path because there was something in the way.
        case conflict(Files.WriteConflictError)
        /// The user doesn't have permissions to write to the target location.
        case noWritePermission
        /// The user doesn't have enough available space (bytes) to write more data.
        case insufficientSpace
        /// Dropbox will not save the file or folder because of its name.
        case disallowedName
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(WriteErrorSerializer().serialize(self)))"
        }
    }
    public class WriteErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: WriteError) -> JSON {
            switch value {
                case .malformedPath(let arg):
                    var d = ["malformed_path": NullableSerializer(Serialization._StringSerializer).serialize(arg)]
                    d[".tag"] = .str("malformed_path")
                    return .dictionary(d)
                case .conflict(let arg):
                    var d = ["conflict": Files.WriteConflictErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("conflict")
                    return .dictionary(d)
                case .noWritePermission:
                    var d = [String: JSON]()
                    d[".tag"] = .str("no_write_permission")
                    return .dictionary(d)
                case .insufficientSpace:
                    var d = [String: JSON]()
                    d[".tag"] = .str("insufficient_space")
                    return .dictionary(d)
                case .disallowedName:
                    var d = [String: JSON]()
                    d[".tag"] = .str("disallowed_name")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        public func deserialize(_ json: JSON) -> WriteError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "malformed_path":
                            let v = NullableSerializer(Serialization._StringSerializer).deserialize(d["malformed_path"] ?? .null)
                            return WriteError.malformedPath(v)
                        case "conflict":
                            let v = Files.WriteConflictErrorSerializer().deserialize(d["conflict"] ?? .null)
                            return WriteError.conflict(v)
                        case "no_write_permission":
                            return WriteError.noWritePermission
                        case "insufficient_space":
                            return WriteError.insufficientSpace
                        case "disallowed_name":
                            return WriteError.disallowedName
                        case "other":
                            return WriteError.other
                        default:
                            return WriteError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Your intent when writing a file to some path. This is used to determine what constitutes a conflict and what the
    /// autorename strategy is. In some situations, the conflict behavior is identical: (a) If the target path doesn't
    /// contain anything, the file is always written; no conflict. (b) If the target path contains a folder, it's always
    /// a conflict. (c) If the target path contains a file with identical contents, nothing gets written; no conflict.
    /// The conflict checking differs in the case where there's a file at the target path with contents different from
    /// the contents you're trying to write.
    public enum WriteMode: CustomStringConvertible {
        /// Never overwrite the existing file. The autorename strategy is to append a number to the file name. For
        /// example, "document.txt" might become "document (2).txt".
        case add
        /// Always overwrite the existing file. The autorename strategy is the same as it is for add.
        case overwrite
        /// Overwrite if the given "rev" matches the existing file's "rev". The autorename strategy is to append the
        /// string "conflicted copy" to the file name. For example, "document.txt" might become "document (conflicted
        /// copy).txt" or "document (Panda's conflicted copy).txt".
        case update(String)

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(WriteModeSerializer().serialize(self)))"
        }
    }
    public class WriteModeSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: WriteMode) -> JSON {
            switch value {
                case .add:
                    var d = [String: JSON]()
                    d[".tag"] = .str("add")
                    return .dictionary(d)
                case .overwrite:
                    var d = [String: JSON]()
                    d[".tag"] = .str("overwrite")
                    return .dictionary(d)
                case .update(let arg):
                    var d = ["update": Serialization._StringSerializer.serialize(arg)]
                    d[".tag"] = .str("update")
                    return .dictionary(d)
            }
        }
        public func deserialize(_ json: JSON) -> WriteMode {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "add":
                            return WriteMode.add
                        case "overwrite":
                            return WriteMode.overwrite
                        case "update":
                            let v = Serialization._StringSerializer.deserialize(d["update"] ?? .null)
                            return WriteMode.update(v)
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }


    /// Stone Route Objects

    static let alphaGetMetadata = Route(
        name: "alpha/get_metadata",
        namespace: "files",
        deprecated: false,
        argSerializer: Files.AlphaGetMetadataArgSerializer(),
        responseSerializer: Files.MetadataSerializer(),
        errorSerializer: Files.AlphaGetMetadataErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let alphaUpload = Route(
        name: "alpha/upload",
        namespace: "files",
        deprecated: false,
        argSerializer: Files.CommitInfoWithPropertiesSerializer(),
        responseSerializer: Files.FileMetadataSerializer(),
        errorSerializer: Files.UploadErrorWithPropertiesSerializer(),
        attrs: ["host": "content",
                "style": "upload"]
    )
    static let copy = Route(
        name: "copy",
        namespace: "files",
        deprecated: false,
        argSerializer: Files.RelocationArgSerializer(),
        responseSerializer: Files.MetadataSerializer(),
        errorSerializer: Files.RelocationErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let copyReferenceGet = Route(
        name: "copy_reference/get",
        namespace: "files",
        deprecated: false,
        argSerializer: Files.GetCopyReferenceArgSerializer(),
        responseSerializer: Files.GetCopyReferenceResultSerializer(),
        errorSerializer: Files.GetCopyReferenceErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let copyReferenceSave = Route(
        name: "copy_reference/save",
        namespace: "files",
        deprecated: false,
        argSerializer: Files.SaveCopyReferenceArgSerializer(),
        responseSerializer: Files.SaveCopyReferenceResultSerializer(),
        errorSerializer: Files.SaveCopyReferenceErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let createFolder = Route(
        name: "create_folder",
        namespace: "files",
        deprecated: false,
        argSerializer: Files.CreateFolderArgSerializer(),
        responseSerializer: Files.FolderMetadataSerializer(),
        errorSerializer: Files.CreateFolderErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let delete = Route(
        name: "delete",
        namespace: "files",
        deprecated: false,
        argSerializer: Files.DeleteArgSerializer(),
        responseSerializer: Files.MetadataSerializer(),
        errorSerializer: Files.DeleteErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let download = Route(
        name: "download",
        namespace: "files",
        deprecated: false,
        argSerializer: Files.DownloadArgSerializer(),
        responseSerializer: Files.FileMetadataSerializer(),
        errorSerializer: Files.DownloadErrorSerializer(),
        attrs: ["host": "content",
                "style": "download"]
    )
    static let getMetadata = Route(
        name: "get_metadata",
        namespace: "files",
        deprecated: false,
        argSerializer: Files.GetMetadataArgSerializer(),
        responseSerializer: Files.MetadataSerializer(),
        errorSerializer: Files.GetMetadataErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let getPreview = Route(
        name: "get_preview",
        namespace: "files",
        deprecated: false,
        argSerializer: Files.PreviewArgSerializer(),
        responseSerializer: Files.FileMetadataSerializer(),
        errorSerializer: Files.PreviewErrorSerializer(),
        attrs: ["host": "content",
                "style": "download"]
    )
    static let getTemporaryLink = Route(
        name: "get_temporary_link",
        namespace: "files",
        deprecated: false,
        argSerializer: Files.GetTemporaryLinkArgSerializer(),
        responseSerializer: Files.GetTemporaryLinkResultSerializer(),
        errorSerializer: Files.GetTemporaryLinkErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let getThumbnail = Route(
        name: "get_thumbnail",
        namespace: "files",
        deprecated: false,
        argSerializer: Files.ThumbnailArgSerializer(),
        responseSerializer: Files.FileMetadataSerializer(),
        errorSerializer: Files.ThumbnailErrorSerializer(),
        attrs: ["host": "content",
                "style": "download"]
    )
    static let listFolder = Route(
        name: "list_folder",
        namespace: "files",
        deprecated: false,
        argSerializer: Files.ListFolderArgSerializer(),
        responseSerializer: Files.ListFolderResultSerializer(),
        errorSerializer: Files.ListFolderErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let listFolderContinue = Route(
        name: "list_folder/continue",
        namespace: "files",
        deprecated: false,
        argSerializer: Files.ListFolderContinueArgSerializer(),
        responseSerializer: Files.ListFolderResultSerializer(),
        errorSerializer: Files.ListFolderContinueErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let listFolderGetLatestCursor = Route(
        name: "list_folder/get_latest_cursor",
        namespace: "files",
        deprecated: false,
        argSerializer: Files.ListFolderArgSerializer(),
        responseSerializer: Files.ListFolderGetLatestCursorResultSerializer(),
        errorSerializer: Files.ListFolderErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let listFolderLongpoll = Route(
        name: "list_folder/longpoll",
        namespace: "files",
        deprecated: false,
        argSerializer: Files.ListFolderLongpollArgSerializer(),
        responseSerializer: Files.ListFolderLongpollResultSerializer(),
        errorSerializer: Files.ListFolderLongpollErrorSerializer(),
        attrs: ["host": "notify",
                "style": "rpc"]
    )
    static let listRevisions = Route(
        name: "list_revisions",
        namespace: "files",
        deprecated: false,
        argSerializer: Files.ListRevisionsArgSerializer(),
        responseSerializer: Files.ListRevisionsResultSerializer(),
        errorSerializer: Files.ListRevisionsErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let move = Route(
        name: "move",
        namespace: "files",
        deprecated: false,
        argSerializer: Files.RelocationArgSerializer(),
        responseSerializer: Files.MetadataSerializer(),
        errorSerializer: Files.RelocationErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let permanentlyDelete = Route(
        name: "permanently_delete",
        namespace: "files",
        deprecated: false,
        argSerializer: Files.DeleteArgSerializer(),
        responseSerializer: Serialization._VoidSerializer,
        errorSerializer: Files.DeleteErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let propertiesAdd = Route(
        name: "properties/add",
        namespace: "files",
        deprecated: false,
        argSerializer: Files.PropertyGroupWithPathSerializer(),
        responseSerializer: Serialization._VoidSerializer,
        errorSerializer: Files.AddPropertiesErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let propertiesOverwrite = Route(
        name: "properties/overwrite",
        namespace: "files",
        deprecated: false,
        argSerializer: Files.PropertyGroupWithPathSerializer(),
        responseSerializer: Serialization._VoidSerializer,
        errorSerializer: Files.InvalidPropertyGroupErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let propertiesRemove = Route(
        name: "properties/remove",
        namespace: "files",
        deprecated: false,
        argSerializer: Files.RemovePropertiesArgSerializer(),
        responseSerializer: Serialization._VoidSerializer,
        errorSerializer: Files.RemovePropertiesErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let propertiesTemplateGet = Route(
        name: "properties/template/get",
        namespace: "files",
        deprecated: false,
        argSerializer: Properties.GetPropertyTemplateArgSerializer(),
        responseSerializer: Properties.GetPropertyTemplateResultSerializer(),
        errorSerializer: Properties.PropertyTemplateErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let propertiesTemplateList = Route(
        name: "properties/template/list",
        namespace: "files",
        deprecated: false,
        argSerializer: Serialization._VoidSerializer,
        responseSerializer: Properties.ListPropertyTemplateIdsSerializer(),
        errorSerializer: Properties.PropertyTemplateErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let propertiesUpdate = Route(
        name: "properties/update",
        namespace: "files",
        deprecated: false,
        argSerializer: Files.UpdatePropertyGroupArgSerializer(),
        responseSerializer: Serialization._VoidSerializer,
        errorSerializer: Files.UpdatePropertiesErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let restore = Route(
        name: "restore",
        namespace: "files",
        deprecated: false,
        argSerializer: Files.RestoreArgSerializer(),
        responseSerializer: Files.FileMetadataSerializer(),
        errorSerializer: Files.RestoreErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let saveUrl = Route(
        name: "save_url",
        namespace: "files",
        deprecated: false,
        argSerializer: Files.SaveUrlArgSerializer(),
        responseSerializer: Files.SaveUrlResultSerializer(),
        errorSerializer: Files.SaveUrlErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let saveUrlCheckJobStatus = Route(
        name: "save_url/check_job_status",
        namespace: "files",
        deprecated: false,
        argSerializer: Async.PollArgSerializer(),
        responseSerializer: Files.SaveUrlJobStatusSerializer(),
        errorSerializer: Async.PollErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let search = Route(
        name: "search",
        namespace: "files",
        deprecated: false,
        argSerializer: Files.SearchArgSerializer(),
        responseSerializer: Files.SearchResultSerializer(),
        errorSerializer: Files.SearchErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let upload = Route(
        name: "upload",
        namespace: "files",
        deprecated: false,
        argSerializer: Files.CommitInfoSerializer(),
        responseSerializer: Files.FileMetadataSerializer(),
        errorSerializer: Files.UploadErrorSerializer(),
        attrs: ["host": "content",
                "style": "upload"]
    )
    static let uploadSessionAppend = Route(
        name: "upload_session/append",
        namespace: "files",
        deprecated: true,
        argSerializer: Files.UploadSessionCursorSerializer(),
        responseSerializer: Serialization._VoidSerializer,
        errorSerializer: Files.UploadSessionLookupErrorSerializer(),
        attrs: ["host": "content",
                "style": "upload"]
    )
    static let uploadSessionAppendV2 = Route(
        name: "upload_session/append_v2",
        namespace: "files",
        deprecated: false,
        argSerializer: Files.UploadSessionAppendArgSerializer(),
        responseSerializer: Serialization._VoidSerializer,
        errorSerializer: Files.UploadSessionLookupErrorSerializer(),
        attrs: ["host": "content",
                "style": "upload"]
    )
    static let uploadSessionFinish = Route(
        name: "upload_session/finish",
        namespace: "files",
        deprecated: false,
        argSerializer: Files.UploadSessionFinishArgSerializer(),
        responseSerializer: Files.FileMetadataSerializer(),
        errorSerializer: Files.UploadSessionFinishErrorSerializer(),
        attrs: ["host": "content",
                "style": "upload"]
    )
    static let uploadSessionFinishBatch = Route(
        name: "upload_session/finish_batch",
        namespace: "files",
        deprecated: false,
        argSerializer: Files.UploadSessionFinishBatchArgSerializer(),
        responseSerializer: Async.LaunchEmptyResultSerializer(),
        errorSerializer: Serialization._VoidSerializer,
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let uploadSessionFinishBatchCheck = Route(
        name: "upload_session/finish_batch/check",
        namespace: "files",
        deprecated: false,
        argSerializer: Async.PollArgSerializer(),
        responseSerializer: Files.UploadSessionFinishBatchJobStatusSerializer(),
        errorSerializer: Async.PollErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let uploadSessionStart = Route(
        name: "upload_session/start",
        namespace: "files",
        deprecated: false,
        argSerializer: Files.UploadSessionStartArgSerializer(),
        responseSerializer: Files.UploadSessionStartResultSerializer(),
        errorSerializer: Serialization._VoidSerializer,
        attrs: ["host": "content",
                "style": "upload"]
    )
}
