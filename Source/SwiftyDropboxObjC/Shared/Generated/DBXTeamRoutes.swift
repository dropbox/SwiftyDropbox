///
/// Copyright (c) 2022 Dropbox, Inc. All rights reserved.
///
/// Auto-generated by Stone, do not modify.
///

import Foundation
import SwiftyDropbox

/// Objective-C compatible routes for the team namespace
/// For Swift routes see TeamRoutes
@objc
public class DBXTeamRoutes: NSObject {
    private let swift: TeamRoutes
    init(swift: TeamRoutes) {
        self.swift = swift
        self.client = swift.client.objc
    }

    public let client: DBXDropboxTransportClient

    /// List all device sessions of a team's member.
    ///
    /// - scope: sessions.list
    ///
    /// - parameter teamMemberId: The team's member id.
    /// - parameter includeWebSessions: Whether to list web sessions of the team's member.
    /// - parameter includeDesktopClients: Whether to list linked desktop devices of the team's member.
    /// - parameter includeMobileClients: Whether to list linked mobile devices of the team's member.
    ///
    /// - returns: Through the response callback, the caller will receive a `Team.ListMemberDevicesResult` object on
    /// success or a `Team.ListMemberDevicesError` object on failure.
    @objc
    @discardableResult public func devicesListMemberDevices(
        teamMemberId: String,
        includeWebSessions: NSNumber,
        includeDesktopClients: NSNumber,
        includeMobileClients: NSNumber
    ) -> DBXTeamDevicesListMemberDevicesRpcRequest {
        let swift = swift.devicesListMemberDevices(
            teamMemberId: teamMemberId,
            includeWebSessions: includeWebSessions.boolValue,
            includeDesktopClients: includeDesktopClients.boolValue,
            includeMobileClients: includeMobileClients.boolValue
        )
        return DBXTeamDevicesListMemberDevicesRpcRequest(swift: swift)
    }

    /// List all device sessions of a team's member.
    ///
    /// - scope: sessions.list
    ///
    /// - returns: Through the response callback, the caller will receive a `Team.ListMemberDevicesResult` object on
    /// success or a `Team.ListMemberDevicesError` object on failure.
    @objc
    @discardableResult public func devicesListMemberDevices(teamMemberId: String) -> DBXTeamDevicesListMemberDevicesRpcRequest {
        let swift = swift.devicesListMemberDevices(teamMemberId: teamMemberId)
        return DBXTeamDevicesListMemberDevicesRpcRequest(swift: swift)
    }

    /// List all device sessions of a team. Permission : Team member file access.
    ///
    /// - scope: sessions.list
    ///
    /// - parameter cursor: At the first call to the devicesListMembersDevices the cursor shouldn't be passed. Then, if
    /// the result of the call includes a cursor, the following requests should include the received cursors in
    /// order to receive the next sub list of team devices.
    /// - parameter includeWebSessions: Whether to list web sessions of the team members.
    /// - parameter includeDesktopClients: Whether to list desktop clients of the team members.
    /// - parameter includeMobileClients: Whether to list mobile clients of the team members.
    ///
    /// - returns: Through the response callback, the caller will receive a `Team.ListMembersDevicesResult` object on
    /// success or a `Team.ListMembersDevicesError` object on failure.
    @objc
    @discardableResult public func devicesListMembersDevices(
        cursor: String?,
        includeWebSessions: NSNumber,
        includeDesktopClients: NSNumber,
        includeMobileClients: NSNumber
    ) -> DBXTeamDevicesListMembersDevicesRpcRequest {
        let swift = swift.devicesListMembersDevices(
            cursor: cursor,
            includeWebSessions: includeWebSessions.boolValue,
            includeDesktopClients: includeDesktopClients.boolValue,
            includeMobileClients: includeMobileClients.boolValue
        )
        return DBXTeamDevicesListMembersDevicesRpcRequest(swift: swift)
    }

    /// List all device sessions of a team. Permission : Team member file access.
    ///
    /// - scope: sessions.list
    ///
    /// - returns: Through the response callback, the caller will receive a `Team.ListMembersDevicesResult` object on
    /// success or a `Team.ListMembersDevicesError` object on failure.
    @objc
    @discardableResult public func devicesListMembersDevices() -> DBXTeamDevicesListMembersDevicesRpcRequest {
        let swift = swift.devicesListMembersDevices()
        return DBXTeamDevicesListMembersDevicesRpcRequest(swift: swift)
    }

    /// Revoke a device session of a team's member.
    ///
    /// - scope: sessions.modify
    ///
    /// - parameter revokeDeviceSessionArg: The RevokeDeviceSessionArg union
    ///
    /// - returns: Through the response callback, the caller will receive a `Void` object on success or a
    /// `Team.RevokeDeviceSessionError` object on failure.
    @objc
    @discardableResult public func devicesRevokeDeviceSession(revokeDeviceSessionArg: DBXTeamRevokeDeviceSessionArg)
        -> DBXTeamDevicesRevokeDeviceSessionRpcRequest {
        let swift = swift.devicesRevokeDeviceSession(revokeDeviceSessionArg: revokeDeviceSessionArg.swift)
        return DBXTeamDevicesRevokeDeviceSessionRpcRequest(swift: swift)
    }

    /// Revoke a list of device sessions of team members.
    ///
    /// - scope: sessions.modify
    ///
    ///
    /// - returns: Through the response callback, the caller will receive a `Team.RevokeDeviceSessionBatchResult` object
    /// on success or a `Team.RevokeDeviceSessionBatchError` object on failure.
    @objc
    @discardableResult public func devicesRevokeDeviceSessionBatch(revokeDevices: [DBXTeamRevokeDeviceSessionArg])
        -> DBXTeamDevicesRevokeDeviceSessionBatchRpcRequest {
        let swift = swift.devicesRevokeDeviceSessionBatch(revokeDevices: revokeDevices.map(\.swift))
        return DBXTeamDevicesRevokeDeviceSessionBatchRpcRequest(swift: swift)
    }

    /// Get the values for one or more featues. This route allows you to check your account's capability for what
    /// feature you can access or what value you have for certain features. Permission : Team information.
    ///
    /// - scope: team_info.read
    ///
    /// - parameter features: A list of features in Feature. If the list is empty, this route will return
    /// FeaturesGetValuesBatchError.
    ///
    /// - returns: Through the response callback, the caller will receive a `Team.FeaturesGetValuesBatchResult` object
    /// on success or a `Team.FeaturesGetValuesBatchError` object on failure.
    @objc
    @discardableResult public func featuresGetValues(features: [DBXTeamFeature]) -> DBXTeamFeaturesGetValuesRpcRequest {
        let swift = swift.featuresGetValues(features: features.map(\.swift))
        return DBXTeamFeaturesGetValuesRpcRequest(swift: swift)
    }

    /// Retrieves information about a team.
    ///
    /// - scope: team_info.read
    ///
    ///
    /// - returns: Through the response callback, the caller will receive a `Team.TeamGetInfoResult` object on success
    /// or a `Void` object on failure.
    @objc
    @discardableResult public func getInfo() -> DBXTeamGetInfoRpcRequest {
        let swift = swift.getInfo()
        return DBXTeamGetInfoRpcRequest(swift: swift)
    }

    /// Creates a new, empty group, with a requested name. Permission : Team member management.
    ///
    /// - scope: groups.write
    ///
    /// - parameter groupName: Group name.
    /// - parameter addCreatorAsOwner: Automatically add the creator of the group.
    /// - parameter groupExternalId: The creator of a team can associate an arbitrary external ID to the group.
    /// - parameter groupManagementType: Whether the team can be managed by selected users, or only by team admins.
    ///
    /// - returns: Through the response callback, the caller will receive a `Team.GroupFullInfo` object on success or a
    /// `Team.GroupCreateError` object on failure.
    @objc
    @discardableResult public func groupsCreate(
        groupName: String,
        addCreatorAsOwner: NSNumber,
        groupExternalId: String?,
        groupManagementType: DBXTeamCommonGroupManagementType?
    ) -> DBXTeamGroupsCreateRpcRequest {
        let swift = swift.groupsCreate(
            groupName: groupName,
            addCreatorAsOwner: addCreatorAsOwner.boolValue,
            groupExternalId: groupExternalId,
            groupManagementType: groupManagementType?.swift
        )
        return DBXTeamGroupsCreateRpcRequest(swift: swift)
    }

    /// Creates a new, empty group, with a requested name. Permission : Team member management.
    ///
    /// - scope: groups.write
    ///
    /// - returns: Through the response callback, the caller will receive a `Team.GroupFullInfo` object on success or a
    /// `Team.GroupCreateError` object on failure.
    @objc
    @discardableResult public func groupsCreate(groupName: String) -> DBXTeamGroupsCreateRpcRequest {
        let swift = swift.groupsCreate(groupName: groupName)
        return DBXTeamGroupsCreateRpcRequest(swift: swift)
    }

    /// Deletes a group. The group is deleted immediately. However the revoking of group-owned resources may take
    /// additional time. Use the groupsJobStatusGet to determine whether this process has completed. Permission :
    /// Team member management.
    ///
    /// - scope: groups.write
    ///
    /// - parameter groupSelector: Argument for selecting a single group, either by group_id or by external group ID.
    ///
    /// - returns: Through the response callback, the caller will receive a `Async.LaunchEmptyResult` object on success
    /// or a `Team.GroupDeleteError` object on failure.
    @objc
    @discardableResult public func groupsDelete(groupSelector: DBXTeamGroupSelector) -> DBXTeamGroupsDeleteRpcRequest {
        let swift = swift.groupsDelete(groupSelector: groupSelector.swift)
        return DBXTeamGroupsDeleteRpcRequest(swift: swift)
    }

    /// Retrieves information about one or more groups. Note that the optional field  members in GroupFullInfo is not
    /// returned for system-managed groups. Permission : Team Information.
    ///
    /// - scope: groups.read
    ///
    /// - parameter groupsSelector: Argument for selecting a list of groups, either by group_ids, or external group IDs.
    ///
    /// - returns: Through the response callback, the caller will receive a `Array<Team.GroupsGetInfoItem>` object on
    /// success or a `Team.GroupsGetInfoError` object on failure.
    @objc
    @discardableResult public func groupsGetInfo(groupsSelector: DBXTeamGroupsSelector) -> DBXTeamGroupsGetInfoRpcRequest {
        let swift = swift.groupsGetInfo(groupsSelector: groupsSelector.swift)
        return DBXTeamGroupsGetInfoRpcRequest(swift: swift)
    }

    /// Once an async_job_id is returned from groupsDelete, groupsMembersAdd , or groupsMembersRemove use this method to
    /// poll the status of granting/revoking group members' access to group-owned resources. Permission : Team
    /// member management.
    ///
    /// - scope: groups.write
    ///
    /// - parameter asyncJobId: Id of the asynchronous job. This is the value of a response returned from the method
    /// that launched the job.
    ///
    /// - returns: Through the response callback, the caller will receive a `Async.PollEmptyResult` object on success or
    /// a `Team.GroupsPollError` object on failure.
    @objc
    @discardableResult public func groupsJobStatusGet(asyncJobId: String) -> DBXTeamGroupsJobStatusGetRpcRequest {
        let swift = swift.groupsJobStatusGet(asyncJobId: asyncJobId)
        return DBXTeamGroupsJobStatusGetRpcRequest(swift: swift)
    }

    /// Lists groups on a team. Permission : Team Information.
    ///
    /// - scope: groups.read
    ///
    /// - parameter limit: Number of results to return per call.
    ///
    /// - returns: Through the response callback, the caller will receive a `Team.GroupsListResult` object on success or
    /// a `Void` object on failure.
    @objc
    @discardableResult public func groupsList(limit: NSNumber) -> DBXTeamGroupsListRpcRequest {
        let swift = swift.groupsList(limit: limit.uint32Value)
        return DBXTeamGroupsListRpcRequest(swift: swift)
    }

    /// Lists groups on a team. Permission : Team Information.
    ///
    /// - scope: groups.read
    ///
    /// - returns: Through the response callback, the caller will receive a `Team.GroupsListResult` object on success or
    /// a `Void` object on failure.
    @objc
    @discardableResult public func groupsList() -> DBXTeamGroupsListRpcRequest {
        let swift = swift.groupsList()
        return DBXTeamGroupsListRpcRequest(swift: swift)
    }

    /// Once a cursor has been retrieved from groupsList, use this to paginate through all groups. Permission : Team
    /// Information.
    ///
    /// - scope: groups.read
    ///
    /// - parameter cursor: Indicates from what point to get the next set of groups.
    ///
    /// - returns: Through the response callback, the caller will receive a `Team.GroupsListResult` object on success or
    /// a `Team.GroupsListContinueError` object on failure.
    @objc
    @discardableResult public func groupsListContinue(cursor: String) -> DBXTeamGroupsListContinueRpcRequest {
        let swift = swift.groupsListContinue(cursor: cursor)
        return DBXTeamGroupsListContinueRpcRequest(swift: swift)
    }

    /// Adds members to a group. The members are added immediately. However the granting of group-owned resources may
    /// take additional time. Use the groupsJobStatusGet to determine whether this process has completed. Permission
    /// : Team member management.
    ///
    /// - scope: groups.write
    ///
    /// - parameter group: Group to which users will be added.
    /// - parameter members: List of users to be added to the group.
    ///
    /// - returns: Through the response callback, the caller will receive a `Team.GroupMembersChangeResult` object on
    /// success or a `Team.GroupMembersAddError` object on failure.
    @objc
    @discardableResult public func groupsMembersAdd(
        group: DBXTeamGroupSelector,
        members: [DBXTeamMemberAccess],
        returnMembers: NSNumber
    ) -> DBXTeamGroupsMembersAddRpcRequest {
        let swift = swift.groupsMembersAdd(group: group.swift, members: members.map(\.swift), returnMembers: returnMembers.boolValue)
        return DBXTeamGroupsMembersAddRpcRequest(swift: swift)
    }

    /// Adds members to a group. The members are added immediately. However the granting of group-owned resources may
    /// take additional time. Use the groupsJobStatusGet to determine whether this process has completed. Permission
    /// : Team member management.
    ///
    /// - scope: groups.write
    ///
    /// - returns: Through the response callback, the caller will receive a `Team.GroupMembersChangeResult` object on
    /// success or a `Team.GroupMembersAddError` object on failure.
    @objc
    @discardableResult public func groupsMembersAdd(group: DBXTeamGroupSelector, members: [DBXTeamMemberAccess]) -> DBXTeamGroupsMembersAddRpcRequest {
        let swift = swift.groupsMembersAdd(group: group.swift, members: members.map(\.swift))
        return DBXTeamGroupsMembersAddRpcRequest(swift: swift)
    }

    /// Lists members of a group. Permission : Team Information.
    ///
    /// - scope: groups.read
    ///
    /// - parameter group: The group whose members are to be listed.
    /// - parameter limit: Number of results to return per call.
    ///
    /// - returns: Through the response callback, the caller will receive a `Team.GroupsMembersListResult` object on
    /// success or a `Team.GroupSelectorError` object on failure.
    @objc
    @discardableResult public func groupsMembersList(group: DBXTeamGroupSelector, limit: NSNumber) -> DBXTeamGroupsMembersListRpcRequest {
        let swift = swift.groupsMembersList(group: group.swift, limit: limit.uint32Value)
        return DBXTeamGroupsMembersListRpcRequest(swift: swift)
    }

    /// Lists members of a group. Permission : Team Information.
    ///
    /// - scope: groups.read
    ///
    /// - returns: Through the response callback, the caller will receive a `Team.GroupsMembersListResult` object on
    /// success or a `Team.GroupSelectorError` object on failure.
    @objc
    @discardableResult public func groupsMembersList(group: DBXTeamGroupSelector) -> DBXTeamGroupsMembersListRpcRequest {
        let swift = swift.groupsMembersList(group: group.swift)
        return DBXTeamGroupsMembersListRpcRequest(swift: swift)
    }

    /// Once a cursor has been retrieved from groupsMembersList, use this to paginate through all members of the group.
    /// Permission : Team information.
    ///
    /// - scope: groups.read
    ///
    /// - parameter cursor: Indicates from what point to get the next set of groups.
    ///
    /// - returns: Through the response callback, the caller will receive a `Team.GroupsMembersListResult` object on
    /// success or a `Team.GroupsMembersListContinueError` object on failure.
    @objc
    @discardableResult public func groupsMembersListContinue(cursor: String) -> DBXTeamGroupsMembersListContinueRpcRequest {
        let swift = swift.groupsMembersListContinue(cursor: cursor)
        return DBXTeamGroupsMembersListContinueRpcRequest(swift: swift)
    }

    /// Removes members from a group. The members are removed immediately. However the revoking of group-owned resources
    /// may take additional time. Use the groupsJobStatusGet to determine whether this process has completed. This
    /// method permits removing the only owner of a group, even in cases where this is not possible via the web
    /// client. Permission : Team member management.
    ///
    /// - scope: groups.write
    ///
    /// - parameter group: Group from which users will be removed.
    /// - parameter users: List of users to be removed from the group.
    ///
    /// - returns: Through the response callback, the caller will receive a `Team.GroupMembersChangeResult` object on
    /// success or a `Team.GroupMembersRemoveError` object on failure.
    @objc
    @discardableResult public func groupsMembersRemove(
        group: DBXTeamGroupSelector,
        users: [DBXTeamUserSelectorArg],
        returnMembers: NSNumber
    ) -> DBXTeamGroupsMembersRemoveRpcRequest {
        let swift = swift.groupsMembersRemove(group: group.swift, users: users.map(\.swift), returnMembers: returnMembers.boolValue)
        return DBXTeamGroupsMembersRemoveRpcRequest(swift: swift)
    }

    /// Removes members from a group. The members are removed immediately. However the revoking of group-owned resources
    /// may take additional time. Use the groupsJobStatusGet to determine whether this process has completed. This
    /// method permits removing the only owner of a group, even in cases where this is not possible via the web
    /// client. Permission : Team member management.
    ///
    /// - scope: groups.write
    ///
    /// - returns: Through the response callback, the caller will receive a `Team.GroupMembersChangeResult` object on
    /// success or a `Team.GroupMembersRemoveError` object on failure.
    @objc
    @discardableResult public func groupsMembersRemove(group: DBXTeamGroupSelector, users: [DBXTeamUserSelectorArg]) -> DBXTeamGroupsMembersRemoveRpcRequest {
        let swift = swift.groupsMembersRemove(group: group.swift, users: users.map(\.swift))
        return DBXTeamGroupsMembersRemoveRpcRequest(swift: swift)
    }

    /// Sets a member's access type in a group. Permission : Team member management.
    ///
    /// - scope: groups.write
    ///
    /// - parameter accessType: New group access type the user will have.
    /// - parameter returnMembers: Whether to return the list of members in the group.  Note that the default value will
    /// cause all the group members  to be returned in the response. This may take a long time for large groups.
    ///
    /// - returns: Through the response callback, the caller will receive a `Array<Team.GroupsGetInfoItem>` object on
    /// success or a `Team.GroupMemberSetAccessTypeError` object on failure.
    @objc
    @discardableResult public func groupsMembersSetAccessType(
        group: DBXTeamGroupSelector,
        user: DBXTeamUserSelectorArg,
        accessType: DBXTeamGroupAccessType,
        returnMembers: NSNumber
    ) -> DBXTeamGroupsMembersSetAccessTypeRpcRequest {
        let swift = swift.groupsMembersSetAccessType(group: group.swift, user: user.swift, accessType: accessType.swift, returnMembers: returnMembers.boolValue)
        return DBXTeamGroupsMembersSetAccessTypeRpcRequest(swift: swift)
    }

    /// Sets a member's access type in a group. Permission : Team member management.
    ///
    /// - scope: groups.write
    ///
    /// - returns: Through the response callback, the caller will receive a `Array<Team.GroupsGetInfoItem>` object on
    /// success or a `Team.GroupMemberSetAccessTypeError` object on failure.
    @objc
    @discardableResult public func groupsMembersSetAccessType(
        group: DBXTeamGroupSelector,
        user: DBXTeamUserSelectorArg,
        accessType: DBXTeamGroupAccessType
    ) -> DBXTeamGroupsMembersSetAccessTypeRpcRequest {
        let swift = swift.groupsMembersSetAccessType(group: group.swift, user: user.swift, accessType: accessType.swift)
        return DBXTeamGroupsMembersSetAccessTypeRpcRequest(swift: swift)
    }

    /// Updates a group's name and/or external ID. Permission : Team member management.
    ///
    /// - scope: groups.write
    ///
    /// - parameter group: Specify a group.
    /// - parameter newGroupName: Optional argument. Set group name to this if provided.
    /// - parameter newGroupExternalId: Optional argument. New group external ID. If the argument is None, the group's
    /// external_id won't be updated. If the argument is empty string, the group's external id will be cleared.
    /// - parameter newGroupManagementType: Set new group management type, if provided.
    ///
    /// - returns: Through the response callback, the caller will receive a `Team.GroupFullInfo` object on success or a
    /// `Team.GroupUpdateError` object on failure.
    @objc
    @discardableResult public func groupsUpdate(
        group: DBXTeamGroupSelector,
        returnMembers: NSNumber,
        newGroupName: String?,
        newGroupExternalId: String?,
        newGroupManagementType: DBXTeamCommonGroupManagementType?
    ) -> DBXTeamGroupsUpdateRpcRequest {
        let swift = swift.groupsUpdate(
            group: group.swift,
            returnMembers: returnMembers.boolValue,
            newGroupName: newGroupName,
            newGroupExternalId: newGroupExternalId,
            newGroupManagementType: newGroupManagementType?.swift
        )
        return DBXTeamGroupsUpdateRpcRequest(swift: swift)
    }

    /// Updates a group's name and/or external ID. Permission : Team member management.
    ///
    /// - scope: groups.write
    ///
    /// - returns: Through the response callback, the caller will receive a `Team.GroupFullInfo` object on success or a
    /// `Team.GroupUpdateError` object on failure.
    @objc
    @discardableResult public func groupsUpdate(group: DBXTeamGroupSelector) -> DBXTeamGroupsUpdateRpcRequest {
        let swift = swift.groupsUpdate(group: group.swift)
        return DBXTeamGroupsUpdateRpcRequest(swift: swift)
    }

    /// Creates new legal hold policy. Note: Legal Holds is a paid add-on. Not all teams have the feature. Permission :
    /// Team member file access.
    ///
    /// - scope: team_data.governance.write
    ///
    /// - parameter name: Policy name.
    /// - parameter description_: A description of the legal hold policy.
    /// - parameter members: List of team member IDs added to the hold.
    /// - parameter startDate: start date of the legal hold policy.
    /// - parameter endDate: end date of the legal hold policy.
    ///
    /// - returns: Through the response callback, the caller will receive a `Team.LegalHoldPolicy` object on success or
    /// a `Team.LegalHoldsPolicyCreateError` object on failure.
    @objc
    @discardableResult public func legalHoldsCreatePolicy(
        name: String,
        members: [String],
        description_: String?,
        startDate: Date?,
        endDate: Date?
    ) -> DBXTeamLegalHoldsCreatePolicyRpcRequest {
        let swift = swift.legalHoldsCreatePolicy(name: name, members: members, description_: description_, startDate: startDate, endDate: endDate)
        return DBXTeamLegalHoldsCreatePolicyRpcRequest(swift: swift)
    }

    /// Creates new legal hold policy. Note: Legal Holds is a paid add-on. Not all teams have the feature. Permission :
    /// Team member file access.
    ///
    /// - scope: team_data.governance.write
    ///
    /// - returns: Through the response callback, the caller will receive a `Team.LegalHoldPolicy` object on success or
    /// a `Team.LegalHoldsPolicyCreateError` object on failure.
    @objc
    @discardableResult public func legalHoldsCreatePolicy(name: String, members: [String]) -> DBXTeamLegalHoldsCreatePolicyRpcRequest {
        let swift = swift.legalHoldsCreatePolicy(name: name, members: members)
        return DBXTeamLegalHoldsCreatePolicyRpcRequest(swift: swift)
    }

    /// Gets a legal hold by Id. Note: Legal Holds is a paid add-on. Not all teams have the feature. Permission : Team
    /// member file access.
    ///
    /// - scope: team_data.governance.write
    ///
    /// - parameter id: The legal hold Id.
    ///
    /// - returns: Through the response callback, the caller will receive a `Team.LegalHoldPolicy` object on success or
    /// a `Team.LegalHoldsGetPolicyError` object on failure.
    @objc
    @discardableResult public func legalHoldsGetPolicy(id: String) -> DBXTeamLegalHoldsGetPolicyRpcRequest {
        let swift = swift.legalHoldsGetPolicy(id: id)
        return DBXTeamLegalHoldsGetPolicyRpcRequest(swift: swift)
    }

    /// List the file metadata that's under the hold. Note: Legal Holds is a paid add-on. Not all teams have the
    /// feature. Permission : Team member file access.
    ///
    /// - scope: team_data.governance.write
    ///
    /// - parameter id: The legal hold Id.
    ///
    /// - returns: Through the response callback, the caller will receive a `Team.LegalHoldsListHeldRevisionResult`
    /// object on success or a `Team.LegalHoldsListHeldRevisionsError` object on failure.
    @objc
    @discardableResult public func legalHoldsListHeldRevisions(id: String) -> DBXTeamLegalHoldsListHeldRevisionsRpcRequest {
        let swift = swift.legalHoldsListHeldRevisions(id: id)
        return DBXTeamLegalHoldsListHeldRevisionsRpcRequest(swift: swift)
    }

    /// Continue listing the file metadata that's under the hold. Note: Legal Holds is a paid add-on. Not all teams have
    /// the feature. Permission : Team member file access.
    ///
    /// - scope: team_data.governance.write
    ///
    /// - parameter id: The legal hold Id.
    /// - parameter cursor: The cursor idicates where to continue reading file metadata entries for the next API call.
    /// When there are no more entries, the cursor will return none.
    ///
    /// - returns: Through the response callback, the caller will receive a `Team.LegalHoldsListHeldRevisionResult`
    /// object on success or a `Team.LegalHoldsListHeldRevisionsError` object on failure.
    @objc
    @discardableResult public func legalHoldsListHeldRevisionsContinue(id: String, cursor: String?) -> DBXTeamLegalHoldsListHeldRevisionsContinueRpcRequest {
        let swift = swift.legalHoldsListHeldRevisionsContinue(id: id, cursor: cursor)
        return DBXTeamLegalHoldsListHeldRevisionsContinueRpcRequest(swift: swift)
    }

    /// Continue listing the file metadata that's under the hold. Note: Legal Holds is a paid add-on. Not all teams have
    /// the feature. Permission : Team member file access.
    ///
    /// - scope: team_data.governance.write
    ///
    /// - returns: Through the response callback, the caller will receive a `Team.LegalHoldsListHeldRevisionResult`
    /// object on success or a `Team.LegalHoldsListHeldRevisionsError` object on failure.
    @objc
    @discardableResult public func legalHoldsListHeldRevisionsContinue(id: String) -> DBXTeamLegalHoldsListHeldRevisionsContinueRpcRequest {
        let swift = swift.legalHoldsListHeldRevisionsContinue(id: id)
        return DBXTeamLegalHoldsListHeldRevisionsContinueRpcRequest(swift: swift)
    }

    /// Lists legal holds on a team. Note: Legal Holds is a paid add-on. Not all teams have the feature. Permission :
    /// Team member file access.
    ///
    /// - scope: team_data.governance.write
    ///
    /// - parameter includeReleased: Whether to return holds that were released.
    ///
    /// - returns: Through the response callback, the caller will receive a `Team.LegalHoldsListPoliciesResult` object
    /// on success or a `Team.LegalHoldsListPoliciesError` object on failure.
    @objc
    @discardableResult public func legalHoldsListPolicies(includeReleased: NSNumber) -> DBXTeamLegalHoldsListPoliciesRpcRequest {
        let swift = swift.legalHoldsListPolicies(includeReleased: includeReleased.boolValue)
        return DBXTeamLegalHoldsListPoliciesRpcRequest(swift: swift)
    }

    /// Lists legal holds on a team. Note: Legal Holds is a paid add-on. Not all teams have the feature. Permission :
    /// Team member file access.
    ///
    /// - scope: team_data.governance.write
    ///
    /// - returns: Through the response callback, the caller will receive a `Team.LegalHoldsListPoliciesResult` object
    /// on success or a `Team.LegalHoldsListPoliciesError` object on failure.
    @objc
    @discardableResult public func legalHoldsListPolicies() -> DBXTeamLegalHoldsListPoliciesRpcRequest {
        let swift = swift.legalHoldsListPolicies()
        return DBXTeamLegalHoldsListPoliciesRpcRequest(swift: swift)
    }

    /// Releases a legal hold by Id. Note: Legal Holds is a paid add-on. Not all teams have the feature. Permission :
    /// Team member file access.
    ///
    /// - scope: team_data.governance.write
    ///
    /// - parameter id: The legal hold Id.
    ///
    /// - returns: Through the response callback, the caller will receive a `Void` object on success or a
    /// `Team.LegalHoldsPolicyReleaseError` object on failure.
    @objc
    @discardableResult public func legalHoldsReleasePolicy(id: String) -> DBXTeamLegalHoldsReleasePolicyRpcRequest {
        let swift = swift.legalHoldsReleasePolicy(id: id)
        return DBXTeamLegalHoldsReleasePolicyRpcRequest(swift: swift)
    }

    /// Updates a legal hold. Note: Legal Holds is a paid add-on. Not all teams have the feature. Permission : Team
    /// member file access.
    ///
    /// - scope: team_data.governance.write
    ///
    /// - parameter id: The legal hold Id.
    /// - parameter name: Policy new name.
    /// - parameter description_: Policy new description.
    /// - parameter members: List of team member IDs to apply the policy on.
    ///
    /// - returns: Through the response callback, the caller will receive a `Team.LegalHoldPolicy` object on success or
    /// a `Team.LegalHoldsPolicyUpdateError` object on failure.
    @objc
    @discardableResult public func legalHoldsUpdatePolicy(
        id: String,
        name: String?,
        description_: String?,
        members: [String]?
    ) -> DBXTeamLegalHoldsUpdatePolicyRpcRequest {
        let swift = swift.legalHoldsUpdatePolicy(id: id, name: name, description_: description_, members: members)
        return DBXTeamLegalHoldsUpdatePolicyRpcRequest(swift: swift)
    }

    /// Updates a legal hold. Note: Legal Holds is a paid add-on. Not all teams have the feature. Permission : Team
    /// member file access.
    ///
    /// - scope: team_data.governance.write
    ///
    /// - returns: Through the response callback, the caller will receive a `Team.LegalHoldPolicy` object on success or
    /// a `Team.LegalHoldsPolicyUpdateError` object on failure.
    @objc
    @discardableResult public func legalHoldsUpdatePolicy(id: String) -> DBXTeamLegalHoldsUpdatePolicyRpcRequest {
        let swift = swift.legalHoldsUpdatePolicy(id: id)
        return DBXTeamLegalHoldsUpdatePolicyRpcRequest(swift: swift)
    }

    /// List all linked applications of the team member. Note, this endpoint does not list any team-linked applications.
    ///
    /// - scope: sessions.list
    ///
    /// - parameter teamMemberId: The team member id.
    ///
    /// - returns: Through the response callback, the caller will receive a `Team.ListMemberAppsResult` object on
    /// success or a `Team.ListMemberAppsError` object on failure.
    @objc
    @discardableResult public func linkedAppsListMemberLinkedApps(teamMemberId: String) -> DBXTeamLinkedAppsListMemberLinkedAppsRpcRequest {
        let swift = swift.linkedAppsListMemberLinkedApps(teamMemberId: teamMemberId)
        return DBXTeamLinkedAppsListMemberLinkedAppsRpcRequest(swift: swift)
    }

    /// List all applications linked to the team members' accounts. Note, this endpoint does not list any team-linked
    /// applications.
    ///
    /// - scope: sessions.list
    ///
    /// - parameter cursor: At the first call to the linkedAppsListMembersLinkedApps the cursor shouldn't be passed.
    /// Then, if the result of the call includes a cursor, the following requests should include the received
    /// cursors in order to receive the next sub list of the team applications.
    ///
    /// - returns: Through the response callback, the caller will receive a `Team.ListMembersAppsResult` object on
    /// success or a `Team.ListMembersAppsError` object on failure.
    @objc
    @discardableResult public func linkedAppsListMembersLinkedApps(cursor: String?) -> DBXTeamLinkedAppsListMembersLinkedAppsRpcRequest {
        let swift = swift.linkedAppsListMembersLinkedApps(cursor: cursor)
        return DBXTeamLinkedAppsListMembersLinkedAppsRpcRequest(swift: swift)
    }

    /// List all applications linked to the team members' accounts. Note, this endpoint does not list any team-linked
    /// applications.
    ///
    /// - scope: sessions.list
    ///
    /// - returns: Through the response callback, the caller will receive a `Team.ListMembersAppsResult` object on
    /// success or a `Team.ListMembersAppsError` object on failure.
    @objc
    @discardableResult public func linkedAppsListMembersLinkedApps() -> DBXTeamLinkedAppsListMembersLinkedAppsRpcRequest {
        let swift = swift.linkedAppsListMembersLinkedApps()
        return DBXTeamLinkedAppsListMembersLinkedAppsRpcRequest(swift: swift)
    }

    /// Revoke a linked application of the team member.
    ///
    /// - scope: sessions.modify
    ///
    /// - parameter appId: The application's unique id.
    /// - parameter teamMemberId: The unique id of the member owning the device.
    /// - parameter keepAppFolder: This flag is not longer supported, the application dedicated folder (in case the
    /// application uses  one) will be kept.
    ///
    /// - returns: Through the response callback, the caller will receive a `Void` object on success or a
    /// `Team.RevokeLinkedAppError` object on failure.
    @objc
    @discardableResult public func linkedAppsRevokeLinkedApp(
        appId: String,
        teamMemberId: String,
        keepAppFolder: NSNumber
    ) -> DBXTeamLinkedAppsRevokeLinkedAppRpcRequest {
        let swift = swift.linkedAppsRevokeLinkedApp(appId: appId, teamMemberId: teamMemberId, keepAppFolder: keepAppFolder.boolValue)
        return DBXTeamLinkedAppsRevokeLinkedAppRpcRequest(swift: swift)
    }

    /// Revoke a linked application of the team member.
    ///
    /// - scope: sessions.modify
    ///
    /// - returns: Through the response callback, the caller will receive a `Void` object on success or a
    /// `Team.RevokeLinkedAppError` object on failure.
    @objc
    @discardableResult public func linkedAppsRevokeLinkedApp(appId: String, teamMemberId: String) -> DBXTeamLinkedAppsRevokeLinkedAppRpcRequest {
        let swift = swift.linkedAppsRevokeLinkedApp(appId: appId, teamMemberId: teamMemberId)
        return DBXTeamLinkedAppsRevokeLinkedAppRpcRequest(swift: swift)
    }

    /// Revoke a list of linked applications of the team members.
    ///
    /// - scope: sessions.modify
    ///
    ///
    /// - returns: Through the response callback, the caller will receive a `Team.RevokeLinkedAppBatchResult` object on
    /// success or a `Team.RevokeLinkedAppBatchError` object on failure.
    @objc
    @discardableResult public func linkedAppsRevokeLinkedAppBatch(revokeLinkedApp: [DBXTeamRevokeLinkedApiAppArg])
        -> DBXTeamLinkedAppsRevokeLinkedAppBatchRpcRequest {
        let swift = swift.linkedAppsRevokeLinkedAppBatch(revokeLinkedApp: revokeLinkedApp.map(\.swift))
        return DBXTeamLinkedAppsRevokeLinkedAppBatchRpcRequest(swift: swift)
    }

    /// Add users to member space limits excluded users list.
    ///
    /// - scope: members.write
    ///
    /// - parameter users: List of users to be added/removed.
    ///
    /// - returns: Through the response callback, the caller will receive a `Team.ExcludedUsersUpdateResult` object on
    /// success or a `Team.ExcludedUsersUpdateError` object on failure.
    @objc
    @discardableResult public func memberSpaceLimitsExcludedUsersAdd(users: [DBXTeamUserSelectorArg]?) -> DBXTeamMemberSpaceLimitsExcludedUsersAddRpcRequest {
        let swift = swift.memberSpaceLimitsExcludedUsersAdd(users: users?.map(\.swift))
        return DBXTeamMemberSpaceLimitsExcludedUsersAddRpcRequest(swift: swift)
    }

    /// Add users to member space limits excluded users list.
    ///
    /// - scope: members.write
    ///
    /// - returns: Through the response callback, the caller will receive a `Team.ExcludedUsersUpdateResult` object on
    /// success or a `Team.ExcludedUsersUpdateError` object on failure.
    @objc
    @discardableResult public func memberSpaceLimitsExcludedUsersAdd() -> DBXTeamMemberSpaceLimitsExcludedUsersAddRpcRequest {
        let swift = swift.memberSpaceLimitsExcludedUsersAdd()
        return DBXTeamMemberSpaceLimitsExcludedUsersAddRpcRequest(swift: swift)
    }

    /// List member space limits excluded users.
    ///
    /// - scope: members.read
    ///
    /// - parameter limit: Number of results to return per call.
    ///
    /// - returns: Through the response callback, the caller will receive a `Team.ExcludedUsersListResult` object on
    /// success or a `Team.ExcludedUsersListError` object on failure.
    @objc
    @discardableResult public func memberSpaceLimitsExcludedUsersList(limit: NSNumber) -> DBXTeamMemberSpaceLimitsExcludedUsersListRpcRequest {
        let swift = swift.memberSpaceLimitsExcludedUsersList(limit: limit.uint32Value)
        return DBXTeamMemberSpaceLimitsExcludedUsersListRpcRequest(swift: swift)
    }

    /// List member space limits excluded users.
    ///
    /// - scope: members.read
    ///
    /// - returns: Through the response callback, the caller will receive a `Team.ExcludedUsersListResult` object on
    /// success or a `Team.ExcludedUsersListError` object on failure.
    @objc
    @discardableResult public func memberSpaceLimitsExcludedUsersList() -> DBXTeamMemberSpaceLimitsExcludedUsersListRpcRequest {
        let swift = swift.memberSpaceLimitsExcludedUsersList()
        return DBXTeamMemberSpaceLimitsExcludedUsersListRpcRequest(swift: swift)
    }

    /// Continue listing member space limits excluded users.
    ///
    /// - scope: members.read
    ///
    /// - parameter cursor: Indicates from what point to get the next set of users.
    ///
    /// - returns: Through the response callback, the caller will receive a `Team.ExcludedUsersListResult` object on
    /// success or a `Team.ExcludedUsersListContinueError` object on failure.
    @objc
    @discardableResult public func memberSpaceLimitsExcludedUsersListContinue(cursor: String) -> DBXTeamMemberSpaceLimitsExcludedUsersListContinueRpcRequest {
        let swift = swift.memberSpaceLimitsExcludedUsersListContinue(cursor: cursor)
        return DBXTeamMemberSpaceLimitsExcludedUsersListContinueRpcRequest(swift: swift)
    }

    /// Remove users from member space limits excluded users list.
    ///
    /// - scope: members.write
    ///
    /// - parameter users: List of users to be added/removed.
    ///
    /// - returns: Through the response callback, the caller will receive a `Team.ExcludedUsersUpdateResult` object on
    /// success or a `Team.ExcludedUsersUpdateError` object on failure.
    @objc
    @discardableResult public func memberSpaceLimitsExcludedUsersRemove(users: [DBXTeamUserSelectorArg]?)
        -> DBXTeamMemberSpaceLimitsExcludedUsersRemoveRpcRequest {
        let swift = swift.memberSpaceLimitsExcludedUsersRemove(users: users?.map(\.swift))
        return DBXTeamMemberSpaceLimitsExcludedUsersRemoveRpcRequest(swift: swift)
    }

    /// Remove users from member space limits excluded users list.
    ///
    /// - scope: members.write
    ///
    /// - returns: Through the response callback, the caller will receive a `Team.ExcludedUsersUpdateResult` object on
    /// success or a `Team.ExcludedUsersUpdateError` object on failure.
    @objc
    @discardableResult public func memberSpaceLimitsExcludedUsersRemove() -> DBXTeamMemberSpaceLimitsExcludedUsersRemoveRpcRequest {
        let swift = swift.memberSpaceLimitsExcludedUsersRemove()
        return DBXTeamMemberSpaceLimitsExcludedUsersRemoveRpcRequest(swift: swift)
    }

    /// Get users custom quota. A maximum of 1000 members can be specified in a single call. Note: to apply a custom
    /// space limit, a team admin needs to set a member space limit for the team first. (the team admin can check
    /// the settings here: https://www.dropbox.com/team/admin/settings/space).
    ///
    /// - scope: members.read
    ///
    /// - parameter users: List of users.
    ///
    /// - returns: Through the response callback, the caller will receive a `Array<Team.CustomQuotaResult>` object on
    /// success or a `Team.CustomQuotaError` object on failure.
    @objc
    @discardableResult public func memberSpaceLimitsGetCustomQuota(users: [DBXTeamUserSelectorArg]) -> DBXTeamMemberSpaceLimitsGetCustomQuotaRpcRequest {
        let swift = swift.memberSpaceLimitsGetCustomQuota(users: users.map(\.swift))
        return DBXTeamMemberSpaceLimitsGetCustomQuotaRpcRequest(swift: swift)
    }

    /// Remove users custom quota. A maximum of 1000 members can be specified in a single call. Note: to apply a custom
    /// space limit, a team admin needs to set a member space limit for the team first. (the team admin can check
    /// the settings here: https://www.dropbox.com/team/admin/settings/space).
    ///
    /// - scope: members.write
    ///
    /// - parameter users: List of users.
    ///
    /// - returns: Through the response callback, the caller will receive a `Array<Team.RemoveCustomQuotaResult>` object
    /// on success or a `Team.CustomQuotaError` object on failure.
    @objc
    @discardableResult public func memberSpaceLimitsRemoveCustomQuota(users: [DBXTeamUserSelectorArg]) -> DBXTeamMemberSpaceLimitsRemoveCustomQuotaRpcRequest {
        let swift = swift.memberSpaceLimitsRemoveCustomQuota(users: users.map(\.swift))
        return DBXTeamMemberSpaceLimitsRemoveCustomQuotaRpcRequest(swift: swift)
    }

    /// Set users custom quota. Custom quota has to be at least 15GB. A maximum of 1000 members can be specified in a
    /// single call. Note: to apply a custom space limit, a team admin needs to set a member space limit for the
    /// team first. (the team admin can check the settings here: https://www.dropbox.com/team/admin/settings/space).
    ///
    /// - scope: members.read
    ///
    /// - parameter usersAndQuotas: List of users and their custom quotas.
    ///
    /// - returns: Through the response callback, the caller will receive a `Array<Team.CustomQuotaResult>` object on
    /// success or a `Team.SetCustomQuotaError` object on failure.
    @objc
    @discardableResult public func memberSpaceLimitsSetCustomQuota(usersAndQuotas: [DBXTeamUserCustomQuotaArg])
        -> DBXTeamMemberSpaceLimitsSetCustomQuotaRpcRequest {
        let swift = swift.memberSpaceLimitsSetCustomQuota(usersAndQuotas: usersAndQuotas.map(\.swift))
        return DBXTeamMemberSpaceLimitsSetCustomQuotaRpcRequest(swift: swift)
    }

    /// Adds members to a team. Permission : Team member management A maximum of 20 members can be specified in a single
    /// call. If no Dropbox account exists with the email address specified, a new Dropbox account will be created
    /// with the given email address, and that account will be invited to the team. If a personal Dropbox account
    /// exists with the email address specified in the call, this call will create a placeholder Dropbox account for
    /// the user on the team and send an email inviting the user to migrate their existing personal account onto the
    /// team. Team member management apps are required to set an initial given_name and surname for a user to use in
    /// the team invitation and for 'Perform as team member' actions taken on the user before they become 'active'.
    ///
    /// - scope: members.write
    ///
    /// - parameter newMembers: Details of new members to be added to the team.
    ///
    /// - returns: Through the response callback, the caller will receive a `Team.MembersAddLaunchV2Result` object on
    /// success or a `Void` object on failure.
    @objc
    @discardableResult public func membersAddV2(newMembers: [DBXTeamMemberAddV2Arg], forceAsync: NSNumber) -> DBXTeamMembersAddRpcRequestV2 {
        let swift = swift.membersAddV2(newMembers: newMembers.map(\.subSwift), forceAsync: forceAsync.boolValue)
        return DBXTeamMembersAddRpcRequestV2(swift: swift)
    }

    /// Adds members to a team. Permission : Team member management A maximum of 20 members can be specified in a single
    /// call. If no Dropbox account exists with the email address specified, a new Dropbox account will be created
    /// with the given email address, and that account will be invited to the team. If a personal Dropbox account
    /// exists with the email address specified in the call, this call will create a placeholder Dropbox account for
    /// the user on the team and send an email inviting the user to migrate their existing personal account onto the
    /// team. Team member management apps are required to set an initial given_name and surname for a user to use in
    /// the team invitation and for 'Perform as team member' actions taken on the user before they become 'active'.
    ///
    /// - scope: members.write
    ///
    /// - returns: Through the response callback, the caller will receive a `Team.MembersAddLaunchV2Result` object on
    /// success or a `Void` object on failure.
    @objc
    @discardableResult public func membersAddV2(newMembers: [DBXTeamMemberAddV2Arg]) -> DBXTeamMembersAddRpcRequestV2 {
        let swift = swift.membersAddV2(newMembers: newMembers.map(\.subSwift))
        return DBXTeamMembersAddRpcRequestV2(swift: swift)
    }

    /// Adds members to a team. Permission : Team member management A maximum of 20 members can be specified in a single
    /// call. If no Dropbox account exists with the email address specified, a new Dropbox account will be created
    /// with the given email address, and that account will be invited to the team. If a personal Dropbox account
    /// exists with the email address specified in the call, this call will create a placeholder Dropbox account for
    /// the user on the team and send an email inviting the user to migrate their existing personal account onto the
    /// team. Team member management apps are required to set an initial given_name and surname for a user to use in
    /// the team invitation and for 'Perform as team member' actions taken on the user before they become 'active'.
    ///
    /// - scope: members.write
    ///
    /// - parameter newMembers: Details of new members to be added to the team.
    ///
    /// - returns: Through the response callback, the caller will receive a `Team.MembersAddLaunch` object on success or
    /// a `Void` object on failure.
    @objc
    @discardableResult public func membersAdd(newMembers: [DBXTeamMemberAddArg], forceAsync: NSNumber) -> DBXTeamMembersAddRpcRequest {
        let swift = swift.membersAdd(newMembers: newMembers.map(\.subSwift), forceAsync: forceAsync.boolValue)
        return DBXTeamMembersAddRpcRequest(swift: swift)
    }

    /// Adds members to a team. Permission : Team member management A maximum of 20 members can be specified in a single
    /// call. If no Dropbox account exists with the email address specified, a new Dropbox account will be created
    /// with the given email address, and that account will be invited to the team. If a personal Dropbox account
    /// exists with the email address specified in the call, this call will create a placeholder Dropbox account for
    /// the user on the team and send an email inviting the user to migrate their existing personal account onto the
    /// team. Team member management apps are required to set an initial given_name and surname for a user to use in
    /// the team invitation and for 'Perform as team member' actions taken on the user before they become 'active'.
    ///
    /// - scope: members.write
    ///
    /// - returns: Through the response callback, the caller will receive a `Team.MembersAddLaunch` object on success or
    /// a `Void` object on failure.
    @objc
    @discardableResult public func membersAdd(newMembers: [DBXTeamMemberAddArg]) -> DBXTeamMembersAddRpcRequest {
        let swift = swift.membersAdd(newMembers: newMembers.map(\.subSwift))
        return DBXTeamMembersAddRpcRequest(swift: swift)
    }

    /// Once an async_job_id is returned from membersAddV2 , use this to poll the status of the asynchronous request.
    /// Permission : Team member management.
    ///
    /// - scope: members.write
    ///
    /// - parameter asyncJobId: Id of the asynchronous job. This is the value of a response returned from the method
    /// that launched the job.
    ///
    /// - returns: Through the response callback, the caller will receive a `Team.MembersAddJobStatusV2Result` object on
    /// success or a `Async.PollError` object on failure.
    @objc
    @discardableResult public func membersAddJobStatusGetV2(asyncJobId: String) -> DBXTeamMembersAddJobStatusGetRpcRequestV2 {
        let swift = swift.membersAddJobStatusGetV2(asyncJobId: asyncJobId)
        return DBXTeamMembersAddJobStatusGetRpcRequestV2(swift: swift)
    }

    /// Once an async_job_id is returned from membersAdd , use this to poll the status of the asynchronous request.
    /// Permission : Team member management.
    ///
    /// - scope: members.write
    ///
    /// - parameter asyncJobId: Id of the asynchronous job. This is the value of a response returned from the method
    /// that launched the job.
    ///
    /// - returns: Through the response callback, the caller will receive a `Team.MembersAddJobStatus` object on success
    /// or a `Async.PollError` object on failure.
    @objc
    @discardableResult public func membersAddJobStatusGet(asyncJobId: String) -> DBXTeamMembersAddJobStatusGetRpcRequest {
        let swift = swift.membersAddJobStatusGet(asyncJobId: asyncJobId)
        return DBXTeamMembersAddJobStatusGetRpcRequest(swift: swift)
    }

    /// Deletes a team member's profile photo. Permission : Team member management.
    ///
    /// - scope: members.write
    ///
    /// - parameter user: Identity of the user whose profile photo will be deleted.
    ///
    /// - returns: Through the response callback, the caller will receive a `Team.TeamMemberInfoV2Result` object on
    /// success or a `Team.MembersDeleteProfilePhotoError` object on failure.
    @objc
    @discardableResult public func membersDeleteProfilePhotoV2(user: DBXTeamUserSelectorArg) -> DBXTeamMembersDeleteProfilePhotoRpcRequestV2 {
        let swift = swift.membersDeleteProfilePhotoV2(user: user.swift)
        return DBXTeamMembersDeleteProfilePhotoRpcRequestV2(swift: swift)
    }

    /// Deletes a team member's profile photo. Permission : Team member management.
    ///
    /// - scope: members.write
    ///
    /// - parameter user: Identity of the user whose profile photo will be deleted.
    ///
    /// - returns: Through the response callback, the caller will receive a `Team.TeamMemberInfo` object on success or a
    /// `Team.MembersDeleteProfilePhotoError` object on failure.
    @objc
    @discardableResult public func membersDeleteProfilePhoto(user: DBXTeamUserSelectorArg) -> DBXTeamMembersDeleteProfilePhotoRpcRequest {
        let swift = swift.membersDeleteProfilePhoto(user: user.swift)
        return DBXTeamMembersDeleteProfilePhotoRpcRequest(swift: swift)
    }

    /// Get available TeamMemberRoles for the connected team. To be used with membersSetAdminPermissionsV2. Permission :
    /// Team member management.
    ///
    /// - scope: members.read
    ///
    ///
    /// - returns: Through the response callback, the caller will receive a
    /// `Team.MembersGetAvailableTeamMemberRolesResult` object on success or a `Void` object on failure.
    @objc
    @discardableResult public func membersGetAvailableTeamMemberRoles() -> DBXTeamMembersGetAvailableTeamMemberRolesRpcRequest {
        let swift = swift.membersGetAvailableTeamMemberRoles()
        return DBXTeamMembersGetAvailableTeamMemberRolesRpcRequest(swift: swift)
    }

    /// Returns information about multiple team members. Permission : Team information This endpoint will return
    /// idNotFound in MembersGetInfoItem, for IDs (or emails) that cannot be matched to a valid team member.
    ///
    /// - scope: members.read
    ///
    /// - parameter members: List of team members.
    ///
    /// - returns: Through the response callback, the caller will receive a `Team.MembersGetInfoV2Result` object on
    /// success or a `Team.MembersGetInfoError` object on failure.
    @objc
    @discardableResult public func membersGetInfoV2(members: [DBXTeamUserSelectorArg]) -> DBXTeamMembersGetInfoRpcRequestV2 {
        let swift = swift.membersGetInfoV2(members: members.map(\.swift))
        return DBXTeamMembersGetInfoRpcRequestV2(swift: swift)
    }

    /// Returns information about multiple team members. Permission : Team information This endpoint will return
    /// idNotFound in MembersGetInfoItem, for IDs (or emails) that cannot be matched to a valid team member.
    ///
    /// - scope: members.read
    ///
    /// - parameter members: List of team members.
    ///
    /// - returns: Through the response callback, the caller will receive a `Array<Team.MembersGetInfoItem>` object on
    /// success or a `Team.MembersGetInfoError` object on failure.
    @objc
    @discardableResult public func membersGetInfo(members: [DBXTeamUserSelectorArg]) -> DBXTeamMembersGetInfoRpcRequest {
        let swift = swift.membersGetInfo(members: members.map(\.swift))
        return DBXTeamMembersGetInfoRpcRequest(swift: swift)
    }

    /// Lists members of a team. Permission : Team information.
    ///
    /// - scope: members.read
    ///
    /// - parameter limit: Number of results to return per call.
    /// - parameter includeRemoved: Whether to return removed members.
    ///
    /// - returns: Through the response callback, the caller will receive a `Team.MembersListV2Result` object on success
    /// or a `Team.MembersListError` object on failure.
    @objc
    @discardableResult public func membersListV2(limit: NSNumber, includeRemoved: NSNumber) -> DBXTeamMembersListRpcRequestV2 {
        let swift = swift.membersListV2(limit: limit.uint32Value, includeRemoved: includeRemoved.boolValue)
        return DBXTeamMembersListRpcRequestV2(swift: swift)
    }

    /// Lists members of a team. Permission : Team information.
    ///
    /// - scope: members.read
    ///
    /// - returns: Through the response callback, the caller will receive a `Team.MembersListV2Result` object on success
    /// or a `Team.MembersListError` object on failure.
    @objc
    @discardableResult public func membersListV2() -> DBXTeamMembersListRpcRequestV2 {
        let swift = swift.membersListV2()
        return DBXTeamMembersListRpcRequestV2(swift: swift)
    }

    /// Lists members of a team. Permission : Team information.
    ///
    /// - scope: members.read
    ///
    /// - parameter limit: Number of results to return per call.
    /// - parameter includeRemoved: Whether to return removed members.
    ///
    /// - returns: Through the response callback, the caller will receive a `Team.MembersListResult` object on success
    /// or a `Team.MembersListError` object on failure.
    @objc
    @discardableResult public func membersList(limit: NSNumber, includeRemoved: NSNumber) -> DBXTeamMembersListRpcRequest {
        let swift = swift.membersList(limit: limit.uint32Value, includeRemoved: includeRemoved.boolValue)
        return DBXTeamMembersListRpcRequest(swift: swift)
    }

    /// Lists members of a team. Permission : Team information.
    ///
    /// - scope: members.read
    ///
    /// - returns: Through the response callback, the caller will receive a `Team.MembersListResult` object on success
    /// or a `Team.MembersListError` object on failure.
    @objc
    @discardableResult public func membersList() -> DBXTeamMembersListRpcRequest {
        let swift = swift.membersList()
        return DBXTeamMembersListRpcRequest(swift: swift)
    }

    /// Once a cursor has been retrieved from membersListV2, use this to paginate through all team members. Permission :
    /// Team information.
    ///
    /// - scope: members.read
    ///
    /// - parameter cursor: Indicates from what point to get the next set of members.
    ///
    /// - returns: Through the response callback, the caller will receive a `Team.MembersListV2Result` object on success
    /// or a `Team.MembersListContinueError` object on failure.
    @objc
    @discardableResult public func membersListContinueV2(cursor: String) -> DBXTeamMembersListContinueRpcRequestV2 {
        let swift = swift.membersListContinueV2(cursor: cursor)
        return DBXTeamMembersListContinueRpcRequestV2(swift: swift)
    }

    /// Once a cursor has been retrieved from membersList, use this to paginate through all team members. Permission :
    /// Team information.
    ///
    /// - scope: members.read
    ///
    /// - parameter cursor: Indicates from what point to get the next set of members.
    ///
    /// - returns: Through the response callback, the caller will receive a `Team.MembersListResult` object on success
    /// or a `Team.MembersListContinueError` object on failure.
    @objc
    @discardableResult public func membersListContinue(cursor: String) -> DBXTeamMembersListContinueRpcRequest {
        let swift = swift.membersListContinue(cursor: cursor)
        return DBXTeamMembersListContinueRpcRequest(swift: swift)
    }

    /// Moves removed member's files to a different member. This endpoint initiates an asynchronous job. To obtain the
    /// final result of the job, the client should periodically poll membersMoveFormerMemberFilesJobStatusCheck.
    /// Permission : Team member management.
    ///
    /// - scope: members.write
    ///
    /// - parameter transferDestId: Files from the deleted member account will be transferred to this user.
    /// - parameter transferAdminId: Errors during the transfer process will be sent via email to this user.
    ///
    /// - returns: Through the response callback, the caller will receive a `Async.LaunchEmptyResult` object on success
    /// or a `Team.MembersTransferFormerMembersFilesError` object on failure.
    @objc
    @discardableResult public func membersMoveFormerMemberFiles(
        user: DBXTeamUserSelectorArg,
        transferDestId: DBXTeamUserSelectorArg,
        transferAdminId: DBXTeamUserSelectorArg
    ) -> DBXTeamMembersMoveFormerMemberFilesRpcRequest {
        let swift = swift.membersMoveFormerMemberFiles(user: user.swift, transferDestId: transferDestId.swift, transferAdminId: transferAdminId.swift)
        return DBXTeamMembersMoveFormerMemberFilesRpcRequest(swift: swift)
    }

    /// Once an async_job_id is returned from membersMoveFormerMemberFiles , use this to poll the status of the
    /// asynchronous request. Permission : Team member management.
    ///
    /// - scope: members.write
    ///
    /// - parameter asyncJobId: Id of the asynchronous job. This is the value of a response returned from the method
    /// that launched the job.
    ///
    /// - returns: Through the response callback, the caller will receive a `Async.PollEmptyResult` object on success or
    /// a `Async.PollError` object on failure.
    @objc
    @discardableResult public func membersMoveFormerMemberFilesJobStatusCheck(asyncJobId: String)
        -> DBXTeamMembersMoveFormerMemberFilesJobStatusCheckRpcRequest {
        let swift = swift.membersMoveFormerMemberFilesJobStatusCheck(asyncJobId: asyncJobId)
        return DBXTeamMembersMoveFormerMemberFilesJobStatusCheckRpcRequest(swift: swift)
    }

    /// Recover a deleted member. Permission : Team member management Exactly one of team_member_id, email, or
    /// external_id must be provided to identify the user account.
    ///
    /// - scope: members.delete
    ///
    /// - parameter user: Identity of user to recover.
    ///
    /// - returns: Through the response callback, the caller will receive a `Void` object on success or a
    /// `Team.MembersRecoverError` object on failure.
    @objc
    @discardableResult public func membersRecover(user: DBXTeamUserSelectorArg) -> DBXTeamMembersRecoverRpcRequest {
        let swift = swift.membersRecover(user: user.swift)
        return DBXTeamMembersRecoverRpcRequest(swift: swift)
    }

    /// Removes a member from a team. Permission : Team member management Exactly one of team_member_id, email, or
    /// external_id must be provided to identify the user account. Accounts can be recovered via membersRecover for
    /// a 7 day period or until the account has been permanently deleted or transferred to another account
    /// (whichever comes first). Calling membersAdd while a user is still recoverable on your team will return with
    /// userAlreadyOnTeam in MemberAddResult. Accounts can have their files transferred via the admin console for a
    /// limited time, based on the version history length associated with the team (180 days for most teams). This
    /// endpoint may initiate an asynchronous job. To obtain the final result of the job, the client should
    /// periodically poll membersRemoveJobStatusGet.
    ///
    /// - scope: members.delete
    ///
    /// - parameter transferDestId: If provided, files from the deleted member account will be transferred to this user.
    /// - parameter transferAdminId: If provided, errors during the transfer process will be sent via email to this
    /// user. If the transfer_dest_id argument was provided, then this argument must be provided as well.
    /// - parameter keepAccount: Downgrade the member to a Basic account. The user will retain the email address
    /// associated with their Dropbox  account and data in their account that is not restricted to team members. In
    /// order to keep the account the argument wipeData should be set to false.
    /// - parameter retainTeamShares: If provided, allows removed users to keep access to Dropbox folders (not Dropbox
    /// Paper folders) already explicitly shared with them (not via a group) when they are downgraded to a Basic
    /// account. Users will not retain access to folders that do not allow external sharing. In order to keep the
    /// sharing relationships, the arguments wipeData should be set to false and keepAccount should be set to true.
    ///
    /// - returns: Through the response callback, the caller will receive a `Async.LaunchEmptyResult` object on success
    /// or a `Team.MembersRemoveError` object on failure.
    @objc
    @discardableResult public func membersRemove(
        user: DBXTeamUserSelectorArg,
        wipeData: NSNumber,
        transferDestId: DBXTeamUserSelectorArg?,
        transferAdminId: DBXTeamUserSelectorArg?,
        keepAccount: NSNumber,
        retainTeamShares: NSNumber
    ) -> DBXTeamMembersRemoveRpcRequest {
        let swift = swift.membersRemove(
            user: user.swift,
            wipeData: wipeData.boolValue,
            transferDestId: transferDestId?.swift,
            transferAdminId: transferAdminId?.swift,
            keepAccount: keepAccount.boolValue,
            retainTeamShares: retainTeamShares.boolValue
        )
        return DBXTeamMembersRemoveRpcRequest(swift: swift)
    }

    /// Removes a member from a team. Permission : Team member management Exactly one of team_member_id, email, or
    /// external_id must be provided to identify the user account. Accounts can be recovered via membersRecover for
    /// a 7 day period or until the account has been permanently deleted or transferred to another account
    /// (whichever comes first). Calling membersAdd while a user is still recoverable on your team will return with
    /// userAlreadyOnTeam in MemberAddResult. Accounts can have their files transferred via the admin console for a
    /// limited time, based on the version history length associated with the team (180 days for most teams). This
    /// endpoint may initiate an asynchronous job. To obtain the final result of the job, the client should
    /// periodically poll membersRemoveJobStatusGet.
    ///
    /// - scope: members.delete
    ///
    /// - returns: Through the response callback, the caller will receive a `Async.LaunchEmptyResult` object on success
    /// or a `Team.MembersRemoveError` object on failure.
    @objc
    @discardableResult public func membersRemove(user: DBXTeamUserSelectorArg) -> DBXTeamMembersRemoveRpcRequest {
        let swift = swift.membersRemove(user: user.swift)
        return DBXTeamMembersRemoveRpcRequest(swift: swift)
    }

    /// Once an async_job_id is returned from membersRemove , use this to poll the status of the asynchronous request.
    /// Permission : Team member management.
    ///
    /// - scope: members.delete
    ///
    /// - parameter asyncJobId: Id of the asynchronous job. This is the value of a response returned from the method
    /// that launched the job.
    ///
    /// - returns: Through the response callback, the caller will receive a `Async.PollEmptyResult` object on success or
    /// a `Async.PollError` object on failure.
    @objc
    @discardableResult public func membersRemoveJobStatusGet(asyncJobId: String) -> DBXTeamMembersRemoveJobStatusGetRpcRequest {
        let swift = swift.membersRemoveJobStatusGet(asyncJobId: asyncJobId)
        return DBXTeamMembersRemoveJobStatusGetRpcRequest(swift: swift)
    }

    /// Add secondary emails to users. Permission : Team member management. Emails that are on verified domains will be
    /// verified automatically. For each email address not on a verified domain a verification email will be sent.
    ///
    /// - scope: members.write
    ///
    /// - parameter newSecondaryEmails: List of users and secondary emails to add.
    ///
    /// - returns: Through the response callback, the caller will receive a `Team.AddSecondaryEmailsResult` object on
    /// success or a `Team.AddSecondaryEmailsError` object on failure.
    @objc
    @discardableResult public func membersSecondaryEmailsAdd(newSecondaryEmails: [DBXTeamUserSecondaryEmailsArg])
        -> DBXTeamMembersSecondaryEmailsAddRpcRequest {
        let swift = swift.membersSecondaryEmailsAdd(newSecondaryEmails: newSecondaryEmails.map(\.swift))
        return DBXTeamMembersSecondaryEmailsAddRpcRequest(swift: swift)
    }

    /// Delete secondary emails from users Permission : Team member management. Users will be notified of deletions of
    /// verified secondary emails at both the secondary email and their primary email.
    ///
    /// - scope: members.write
    ///
    /// - parameter emailsToDelete: List of users and their secondary emails to delete.
    ///
    /// - returns: Through the response callback, the caller will receive a `Team.DeleteSecondaryEmailsResult` object on
    /// success or a `Void` object on failure.
    @objc
    @discardableResult public func membersSecondaryEmailsDelete(emailsToDelete: [DBXTeamUserSecondaryEmailsArg])
        -> DBXTeamMembersSecondaryEmailsDeleteRpcRequest {
        let swift = swift.membersSecondaryEmailsDelete(emailsToDelete: emailsToDelete.map(\.swift))
        return DBXTeamMembersSecondaryEmailsDeleteRpcRequest(swift: swift)
    }

    /// Resend secondary email verification emails. Permission : Team member management.
    ///
    /// - scope: members.write
    ///
    /// - parameter emailsToResend: List of users and secondary emails to resend verification emails to.
    ///
    /// - returns: Through the response callback, the caller will receive a `Team.ResendVerificationEmailResult` object
    /// on success or a `Void` object on failure.
    @objc
    @discardableResult public func membersSecondaryEmailsResendVerificationEmails(emailsToResend: [DBXTeamUserSecondaryEmailsArg])
        -> DBXTeamMembersSecondaryEmailsResendVerificationEmailsRpcRequest {
        let swift = swift.membersSecondaryEmailsResendVerificationEmails(emailsToResend: emailsToResend.map(\.swift))
        return DBXTeamMembersSecondaryEmailsResendVerificationEmailsRpcRequest(swift: swift)
    }

    /// Sends welcome email to pending team member. Permission : Team member management Exactly one of team_member_id,
    /// email, or external_id must be provided to identify the user account. No-op if team member is not pending.
    ///
    /// - scope: members.write
    ///
    /// - parameter userSelectorArg: Argument for selecting a single user, either by team_member_id, external_id or
    /// email.
    ///
    /// - returns: Through the response callback, the caller will receive a `Void` object on success or a
    /// `Team.MembersSendWelcomeError` object on failure.
    @objc
    @discardableResult public func membersSendWelcomeEmail(userSelectorArg: DBXTeamUserSelectorArg) -> DBXTeamMembersSendWelcomeEmailRpcRequest {
        let swift = swift.membersSendWelcomeEmail(userSelectorArg: userSelectorArg.swift)
        return DBXTeamMembersSendWelcomeEmailRpcRequest(swift: swift)
    }

    /// Updates a team member's permissions. Permission : Team member management.
    ///
    /// - scope: members.write
    ///
    /// - parameter user: Identity of user whose role will be set.
    /// - parameter newRoles: The new roles for the member. Send empty list to make user member only. For now, only up
    /// to one role is allowed.
    ///
    /// - returns: Through the response callback, the caller will receive a `Team.MembersSetPermissions2Result` object
    /// on success or a `Team.MembersSetPermissions2Error` object on failure.
    @objc
    @discardableResult public func membersSetAdminPermissionsV2(
        user: DBXTeamUserSelectorArg,
        newRoles: [String]?
    ) -> DBXTeamMembersSetAdminPermissionsRpcRequestV2 {
        let swift = swift.membersSetAdminPermissionsV2(user: user.swift, newRoles: newRoles)
        return DBXTeamMembersSetAdminPermissionsRpcRequestV2(swift: swift)
    }

    /// Updates a team member's permissions. Permission : Team member management.
    ///
    /// - scope: members.write
    ///
    /// - returns: Through the response callback, the caller will receive a `Team.MembersSetPermissions2Result` object
    /// on success or a `Team.MembersSetPermissions2Error` object on failure.
    @objc
    @discardableResult public func membersSetAdminPermissionsV2(user: DBXTeamUserSelectorArg) -> DBXTeamMembersSetAdminPermissionsRpcRequestV2 {
        let swift = swift.membersSetAdminPermissionsV2(user: user.swift)
        return DBXTeamMembersSetAdminPermissionsRpcRequestV2(swift: swift)
    }

    /// Updates a team member's permissions. Permission : Team member management.
    ///
    /// - scope: members.write
    ///
    /// - parameter user: Identity of user whose role will be set.
    /// - parameter newRole: The new role of the member.
    ///
    /// - returns: Through the response callback, the caller will receive a `Team.MembersSetPermissionsResult` object on
    /// success or a `Team.MembersSetPermissionsError` object on failure.
    @objc
    @discardableResult public func membersSetAdminPermissions(
        user: DBXTeamUserSelectorArg,
        newRole: DBXTeamAdminTier
    ) -> DBXTeamMembersSetAdminPermissionsRpcRequest {
        let swift = swift.membersSetAdminPermissions(user: user.swift, newRole: newRole.swift)
        return DBXTeamMembersSetAdminPermissionsRpcRequest(swift: swift)
    }

    /// Updates a team member's profile. Permission : Team member management.
    ///
    /// - scope: members.write
    ///
    /// - parameter user: Identity of user whose profile will be set.
    /// - parameter newEmail: New email for member.
    /// - parameter newExternalId: New external ID for member.
    /// - parameter newGivenName: New given name for member.
    /// - parameter newSurname: New surname for member.
    /// - parameter newPersistentId: New persistent ID. This field only available to teams using persistent ID SAML
    /// configuration.
    /// - parameter newIsDirectoryRestricted: New value for whether the user is a directory restricted user.
    ///
    /// - returns: Through the response callback, the caller will receive a `Team.TeamMemberInfoV2Result` object on
    /// success or a `Team.MembersSetProfileError` object on failure.
    @objc
    @discardableResult public func membersSetProfileV2(
        user: DBXTeamUserSelectorArg,
        newEmail: String?,
        newExternalId: String?,
        newGivenName: String?,
        newSurname: String?,
        newPersistentId: String?,
        newIsDirectoryRestricted: NSNumber?
    ) -> DBXTeamMembersSetProfileRpcRequestV2 {
        let swift = swift.membersSetProfileV2(
            user: user.swift,
            newEmail: newEmail,
            newExternalId: newExternalId,
            newGivenName: newGivenName,
            newSurname: newSurname,
            newPersistentId: newPersistentId,
            newIsDirectoryRestricted: newIsDirectoryRestricted?.boolValue
        )
        return DBXTeamMembersSetProfileRpcRequestV2(swift: swift)
    }

    /// Updates a team member's profile. Permission : Team member management.
    ///
    /// - scope: members.write
    ///
    /// - returns: Through the response callback, the caller will receive a `Team.TeamMemberInfoV2Result` object on
    /// success or a `Team.MembersSetProfileError` object on failure.
    @objc
    @discardableResult public func membersSetProfileV2(user: DBXTeamUserSelectorArg) -> DBXTeamMembersSetProfileRpcRequestV2 {
        let swift = swift.membersSetProfileV2(user: user.swift)
        return DBXTeamMembersSetProfileRpcRequestV2(swift: swift)
    }

    /// Updates a team member's profile. Permission : Team member management.
    ///
    /// - scope: members.write
    ///
    /// - parameter user: Identity of user whose profile will be set.
    /// - parameter newEmail: New email for member.
    /// - parameter newExternalId: New external ID for member.
    /// - parameter newGivenName: New given name for member.
    /// - parameter newSurname: New surname for member.
    /// - parameter newPersistentId: New persistent ID. This field only available to teams using persistent ID SAML
    /// configuration.
    /// - parameter newIsDirectoryRestricted: New value for whether the user is a directory restricted user.
    ///
    /// - returns: Through the response callback, the caller will receive a `Team.TeamMemberInfo` object on success or a
    /// `Team.MembersSetProfileError` object on failure.
    @objc
    @discardableResult public func membersSetProfile(
        user: DBXTeamUserSelectorArg,
        newEmail: String?,
        newExternalId: String?,
        newGivenName: String?,
        newSurname: String?,
        newPersistentId: String?,
        newIsDirectoryRestricted: NSNumber?
    ) -> DBXTeamMembersSetProfileRpcRequest {
        let swift = swift.membersSetProfile(
            user: user.swift,
            newEmail: newEmail,
            newExternalId: newExternalId,
            newGivenName: newGivenName,
            newSurname: newSurname,
            newPersistentId: newPersistentId,
            newIsDirectoryRestricted: newIsDirectoryRestricted?.boolValue
        )
        return DBXTeamMembersSetProfileRpcRequest(swift: swift)
    }

    /// Updates a team member's profile. Permission : Team member management.
    ///
    /// - scope: members.write
    ///
    /// - returns: Through the response callback, the caller will receive a `Team.TeamMemberInfo` object on success or a
    /// `Team.MembersSetProfileError` object on failure.
    @objc
    @discardableResult public func membersSetProfile(user: DBXTeamUserSelectorArg) -> DBXTeamMembersSetProfileRpcRequest {
        let swift = swift.membersSetProfile(user: user.swift)
        return DBXTeamMembersSetProfileRpcRequest(swift: swift)
    }

    /// Updates a team member's profile photo. Permission : Team member management.
    ///
    /// - scope: members.write
    ///
    /// - parameter user: Identity of the user whose profile photo will be set.
    /// - parameter photo: Image to set as the member's new profile photo.
    ///
    /// - returns: Through the response callback, the caller will receive a `Team.TeamMemberInfoV2Result` object on
    /// success or a `Team.MembersSetProfilePhotoError` object on failure.
    @objc
    @discardableResult public func membersSetProfilePhotoV2(
        user: DBXTeamUserSelectorArg,
        photo: DBXAccountPhotoSourceArg
    ) -> DBXTeamMembersSetProfilePhotoRpcRequestV2 {
        let swift = swift.membersSetProfilePhotoV2(user: user.swift, photo: photo.swift)
        return DBXTeamMembersSetProfilePhotoRpcRequestV2(swift: swift)
    }

    /// Updates a team member's profile photo. Permission : Team member management.
    ///
    /// - scope: members.write
    ///
    /// - parameter user: Identity of the user whose profile photo will be set.
    /// - parameter photo: Image to set as the member's new profile photo.
    ///
    /// - returns: Through the response callback, the caller will receive a `Team.TeamMemberInfo` object on success or a
    /// `Team.MembersSetProfilePhotoError` object on failure.
    @objc
    @discardableResult public func membersSetProfilePhoto(
        user: DBXTeamUserSelectorArg,
        photo: DBXAccountPhotoSourceArg
    ) -> DBXTeamMembersSetProfilePhotoRpcRequest {
        let swift = swift.membersSetProfilePhoto(user: user.swift, photo: photo.swift)
        return DBXTeamMembersSetProfilePhotoRpcRequest(swift: swift)
    }

    /// Suspend a member from a team. Permission : Team member management Exactly one of team_member_id, email, or
    /// external_id must be provided to identify the user account.
    ///
    /// - scope: members.write
    ///
    /// - parameter wipeData: If provided, controls if the user's data will be deleted on their linked devices.
    ///
    /// - returns: Through the response callback, the caller will receive a `Void` object on success or a
    /// `Team.MembersSuspendError` object on failure.
    @objc
    @discardableResult public func membersSuspend(user: DBXTeamUserSelectorArg, wipeData: NSNumber) -> DBXTeamMembersSuspendRpcRequest {
        let swift = swift.membersSuspend(user: user.swift, wipeData: wipeData.boolValue)
        return DBXTeamMembersSuspendRpcRequest(swift: swift)
    }

    /// Suspend a member from a team. Permission : Team member management Exactly one of team_member_id, email, or
    /// external_id must be provided to identify the user account.
    ///
    /// - scope: members.write
    ///
    /// - returns: Through the response callback, the caller will receive a `Void` object on success or a
    /// `Team.MembersSuspendError` object on failure.
    @objc
    @discardableResult public func membersSuspend(user: DBXTeamUserSelectorArg) -> DBXTeamMembersSuspendRpcRequest {
        let swift = swift.membersSuspend(user: user.swift)
        return DBXTeamMembersSuspendRpcRequest(swift: swift)
    }

    /// Unsuspend a member from a team. Permission : Team member management Exactly one of team_member_id, email, or
    /// external_id must be provided to identify the user account.
    ///
    /// - scope: members.write
    ///
    /// - parameter user: Identity of user to unsuspend.
    ///
    /// - returns: Through the response callback, the caller will receive a `Void` object on success or a
    /// `Team.MembersUnsuspendError` object on failure.
    @objc
    @discardableResult public func membersUnsuspend(user: DBXTeamUserSelectorArg) -> DBXTeamMembersUnsuspendRpcRequest {
        let swift = swift.membersUnsuspend(user: user.swift)
        return DBXTeamMembersUnsuspendRpcRequest(swift: swift)
    }

    /// Returns a list of all team-accessible namespaces. This list includes team folders, shared folders containing
    /// team members, team members' home namespaces, and team members' app folders. Home namespaces and app folders
    /// are always owned by this team or members of the team, but shared folders may be owned by other users or
    /// other teams. Duplicates may occur in the list.
    ///
    /// - scope: team_data.member
    ///
    /// - parameter limit: Specifying a value here has no effect.
    ///
    /// - returns: Through the response callback, the caller will receive a `Team.TeamNamespacesListResult` object on
    /// success or a `Team.TeamNamespacesListError` object on failure.
    @objc
    @discardableResult public func namespacesList(limit: NSNumber) -> DBXTeamNamespacesListRpcRequest {
        let swift = swift.namespacesList(limit: limit.uint32Value)
        return DBXTeamNamespacesListRpcRequest(swift: swift)
    }

    /// Returns a list of all team-accessible namespaces. This list includes team folders, shared folders containing
    /// team members, team members' home namespaces, and team members' app folders. Home namespaces and app folders
    /// are always owned by this team or members of the team, but shared folders may be owned by other users or
    /// other teams. Duplicates may occur in the list.
    ///
    /// - scope: team_data.member
    ///
    /// - returns: Through the response callback, the caller will receive a `Team.TeamNamespacesListResult` object on
    /// success or a `Team.TeamNamespacesListError` object on failure.
    @objc
    @discardableResult public func namespacesList() -> DBXTeamNamespacesListRpcRequest {
        let swift = swift.namespacesList()
        return DBXTeamNamespacesListRpcRequest(swift: swift)
    }

    /// Once a cursor has been retrieved from namespacesList, use this to paginate through all team-accessible
    /// namespaces. Duplicates may occur in the list.
    ///
    /// - scope: team_data.member
    ///
    /// - parameter cursor: Indicates from what point to get the next set of team-accessible namespaces.
    ///
    /// - returns: Through the response callback, the caller will receive a `Team.TeamNamespacesListResult` object on
    /// success or a `Team.TeamNamespacesListContinueError` object on failure.
    @objc
    @discardableResult public func namespacesListContinue(cursor: String) -> DBXTeamNamespacesListContinueRpcRequest {
        let swift = swift.namespacesListContinue(cursor: cursor)
        return DBXTeamNamespacesListContinueRpcRequest(swift: swift)
    }

    /// Endpoint adds Approve List entries. Changes are effective immediately. Changes are committed in transaction. In
    /// case of single validation error - all entries are rejected. Valid domains (RFC-1034/5) and emails
    /// (RFC-5322/822) are accepted. Added entries cannot overflow limit of 10000 entries per team. Maximum 100
    /// entries per call is allowed.
    ///
    /// - scope: team_info.write
    ///
    /// - parameter domains: List of domains represented by valid string representation (RFC-1034/5).
    /// - parameter emails: List of emails represented by valid string representation (RFC-5322/822).
    ///
    /// - returns: Through the response callback, the caller will receive a `Team.SharingAllowlistAddResponse` object on
    /// success or a `Team.SharingAllowlistAddError` object on failure.
    @objc
    @discardableResult public func sharingAllowlistAdd(domains: [String]?, emails: [String]?) -> DBXTeamSharingAllowlistAddRpcRequest {
        let swift = swift.sharingAllowlistAdd(domains: domains, emails: emails)
        return DBXTeamSharingAllowlistAddRpcRequest(swift: swift)
    }

    /// Endpoint adds Approve List entries. Changes are effective immediately. Changes are committed in transaction. In
    /// case of single validation error - all entries are rejected. Valid domains (RFC-1034/5) and emails
    /// (RFC-5322/822) are accepted. Added entries cannot overflow limit of 10000 entries per team. Maximum 100
    /// entries per call is allowed.
    ///
    /// - scope: team_info.write
    ///
    /// - returns: Through the response callback, the caller will receive a `Team.SharingAllowlistAddResponse` object on
    /// success or a `Team.SharingAllowlistAddError` object on failure.
    @objc
    @discardableResult public func sharingAllowlistAdd() -> DBXTeamSharingAllowlistAddRpcRequest {
        let swift = swift.sharingAllowlistAdd()
        return DBXTeamSharingAllowlistAddRpcRequest(swift: swift)
    }

    /// Lists Approve List entries for given team, from newest to oldest, returning up to `limit` entries at a time. If
    /// there are more than `limit` entries associated with the current team, more can be fetched by passing the
    /// returned `cursor` to sharingAllowlistListContinue.
    ///
    /// - scope: team_info.read
    ///
    /// - parameter limit: The number of entries to fetch at one time.
    ///
    /// - returns: Through the response callback, the caller will receive a `Team.SharingAllowlistListResponse` object
    /// on success or a `Team.SharingAllowlistListError` object on failure.
    @objc
    @discardableResult public func sharingAllowlistList(limit: NSNumber) -> DBXTeamSharingAllowlistListRpcRequest {
        let swift = swift.sharingAllowlistList(limit: limit.uint32Value)
        return DBXTeamSharingAllowlistListRpcRequest(swift: swift)
    }

    /// Lists Approve List entries for given team, from newest to oldest, returning up to `limit` entries at a time. If
    /// there are more than `limit` entries associated with the current team, more can be fetched by passing the
    /// returned `cursor` to sharingAllowlistListContinue.
    ///
    /// - scope: team_info.read
    ///
    /// - returns: Through the response callback, the caller will receive a `Team.SharingAllowlistListResponse` object
    /// on success or a `Team.SharingAllowlistListError` object on failure.
    @objc
    @discardableResult public func sharingAllowlistList() -> DBXTeamSharingAllowlistListRpcRequest {
        let swift = swift.sharingAllowlistList()
        return DBXTeamSharingAllowlistListRpcRequest(swift: swift)
    }

    /// Lists entries associated with given team, starting from a the cursor. See sharingAllowlistList.
    ///
    /// - scope: team_info.read
    ///
    /// - parameter cursor: The cursor returned from a previous call to sharingAllowlistList or
    /// sharingAllowlistListContinue.
    ///
    /// - returns: Through the response callback, the caller will receive a `Team.SharingAllowlistListResponse` object
    /// on success or a `Team.SharingAllowlistListContinueError` object on failure.
    @objc
    @discardableResult public func sharingAllowlistListContinue(cursor: String) -> DBXTeamSharingAllowlistListContinueRpcRequest {
        let swift = swift.sharingAllowlistListContinue(cursor: cursor)
        return DBXTeamSharingAllowlistListContinueRpcRequest(swift: swift)
    }

    /// Endpoint removes Approve List entries. Changes are effective immediately. Changes are committed in transaction.
    /// In case of single validation error - all entries are rejected. Valid domains (RFC-1034/5) and emails
    /// (RFC-5322/822) are accepted. Entries being removed have to be present on the list. Maximum 1000 entries per
    /// call is allowed.
    ///
    /// - scope: team_info.write
    ///
    /// - parameter domains: List of domains represented by valid string representation (RFC-1034/5).
    /// - parameter emails: List of emails represented by valid string representation (RFC-5322/822).
    ///
    /// - returns: Through the response callback, the caller will receive a `Team.SharingAllowlistRemoveResponse` object
    /// on success or a `Team.SharingAllowlistRemoveError` object on failure.
    @objc
    @discardableResult public func sharingAllowlistRemove(domains: [String]?, emails: [String]?) -> DBXTeamSharingAllowlistRemoveRpcRequest {
        let swift = swift.sharingAllowlistRemove(domains: domains, emails: emails)
        return DBXTeamSharingAllowlistRemoveRpcRequest(swift: swift)
    }

    /// Endpoint removes Approve List entries. Changes are effective immediately. Changes are committed in transaction.
    /// In case of single validation error - all entries are rejected. Valid domains (RFC-1034/5) and emails
    /// (RFC-5322/822) are accepted. Entries being removed have to be present on the list. Maximum 1000 entries per
    /// call is allowed.
    ///
    /// - scope: team_info.write
    ///
    /// - returns: Through the response callback, the caller will receive a `Team.SharingAllowlistRemoveResponse` object
    /// on success or a `Team.SharingAllowlistRemoveError` object on failure.
    @objc
    @discardableResult public func sharingAllowlistRemove() -> DBXTeamSharingAllowlistRemoveRpcRequest {
        let swift = swift.sharingAllowlistRemove()
        return DBXTeamSharingAllowlistRemoveRpcRequest(swift: swift)
    }

    /// Sets an archived team folder's status to active. Permission : Team member file access.
    ///
    /// - scope: team_data.content.write
    ///
    /// - parameter teamFolderId: The ID of the team folder.
    ///
    /// - returns: Through the response callback, the caller will receive a `Team.TeamFolderMetadata` object on success
    /// or a `Team.TeamFolderActivateError` object on failure.
    @objc
    @discardableResult public func teamFolderActivate(teamFolderId: String) -> DBXTeamTeamFolderActivateRpcRequest {
        let swift = swift.teamFolderActivate(teamFolderId: teamFolderId)
        return DBXTeamTeamFolderActivateRpcRequest(swift: swift)
    }

    /// Sets an active team folder's status to archived and removes all folder and file members. This endpoint cannot be
    /// used for teams that have a shared team space. Permission : Team member file access.
    ///
    /// - scope: team_data.content.write
    ///
    /// - parameter forceAsyncOff: Whether to force the archive to happen synchronously.
    ///
    /// - returns: Through the response callback, the caller will receive a `Team.TeamFolderArchiveLaunch` object on
    /// success or a `Team.TeamFolderArchiveError` object on failure.
    @objc
    @discardableResult public func teamFolderArchive(teamFolderId: String, forceAsyncOff: NSNumber) -> DBXTeamTeamFolderArchiveRpcRequest {
        let swift = swift.teamFolderArchive(teamFolderId: teamFolderId, forceAsyncOff: forceAsyncOff.boolValue)
        return DBXTeamTeamFolderArchiveRpcRequest(swift: swift)
    }

    /// Sets an active team folder's status to archived and removes all folder and file members. This endpoint cannot be
    /// used for teams that have a shared team space. Permission : Team member file access.
    ///
    /// - scope: team_data.content.write
    ///
    /// - returns: Through the response callback, the caller will receive a `Team.TeamFolderArchiveLaunch` object on
    /// success or a `Team.TeamFolderArchiveError` object on failure.
    @objc
    @discardableResult public func teamFolderArchive(teamFolderId: String) -> DBXTeamTeamFolderArchiveRpcRequest {
        let swift = swift.teamFolderArchive(teamFolderId: teamFolderId)
        return DBXTeamTeamFolderArchiveRpcRequest(swift: swift)
    }

    /// Returns the status of an asynchronous job for archiving a team folder. Permission : Team member file access.
    ///
    /// - scope: team_data.content.write
    ///
    /// - parameter asyncJobId: Id of the asynchronous job. This is the value of a response returned from the method
    /// that launched the job.
    ///
    /// - returns: Through the response callback, the caller will receive a `Team.TeamFolderArchiveJobStatus` object on
    /// success or a `Async.PollError` object on failure.
    @objc
    @discardableResult public func teamFolderArchiveCheck(asyncJobId: String) -> DBXTeamTeamFolderArchiveCheckRpcRequest {
        let swift = swift.teamFolderArchiveCheck(asyncJobId: asyncJobId)
        return DBXTeamTeamFolderArchiveCheckRpcRequest(swift: swift)
    }

    /// Creates a new, active, team folder with no members. This endpoint can only be used for teams that do not already
    /// have a shared team space. Permission : Team member file access.
    ///
    /// - scope: team_data.content.write
    ///
    /// - parameter name: Name for the new team folder.
    /// - parameter syncSetting: The sync setting to apply to this team folder. Only permitted if the team has team
    /// selective sync enabled.
    ///
    /// - returns: Through the response callback, the caller will receive a `Team.TeamFolderMetadata` object on success
    /// or a `Team.TeamFolderCreateError` object on failure.
    @objc
    @discardableResult public func teamFolderCreate(name: String, syncSetting: DBXFilesSyncSettingArg?) -> DBXTeamTeamFolderCreateRpcRequest {
        let swift = swift.teamFolderCreate(name: name, syncSetting: syncSetting?.swift)
        return DBXTeamTeamFolderCreateRpcRequest(swift: swift)
    }

    /// Creates a new, active, team folder with no members. This endpoint can only be used for teams that do not already
    /// have a shared team space. Permission : Team member file access.
    ///
    /// - scope: team_data.content.write
    ///
    /// - returns: Through the response callback, the caller will receive a `Team.TeamFolderMetadata` object on success
    /// or a `Team.TeamFolderCreateError` object on failure.
    @objc
    @discardableResult public func teamFolderCreate(name: String) -> DBXTeamTeamFolderCreateRpcRequest {
        let swift = swift.teamFolderCreate(name: name)
        return DBXTeamTeamFolderCreateRpcRequest(swift: swift)
    }

    /// Retrieves metadata for team folders. Permission : Team member file access.
    ///
    /// - scope: team_data.content.read
    ///
    /// - parameter teamFolderIds: The list of team folder IDs.
    ///
    /// - returns: Through the response callback, the caller will receive a `Array<Team.TeamFolderGetInfoItem>` object
    /// on success or a `Void` object on failure.
    @objc
    @discardableResult public func teamFolderGetInfo(teamFolderIds: [String]) -> DBXTeamTeamFolderGetInfoRpcRequest {
        let swift = swift.teamFolderGetInfo(teamFolderIds: teamFolderIds)
        return DBXTeamTeamFolderGetInfoRpcRequest(swift: swift)
    }

    /// Lists all team folders. Permission : Team member file access.
    ///
    /// - scope: team_data.content.read
    ///
    /// - parameter limit: The maximum number of results to return per request.
    ///
    /// - returns: Through the response callback, the caller will receive a `Team.TeamFolderListResult` object on
    /// success or a `Team.TeamFolderListError` object on failure.
    @objc
    @discardableResult public func teamFolderList(limit: NSNumber) -> DBXTeamTeamFolderListRpcRequest {
        let swift = swift.teamFolderList(limit: limit.uint32Value)
        return DBXTeamTeamFolderListRpcRequest(swift: swift)
    }

    /// Lists all team folders. Permission : Team member file access.
    ///
    /// - scope: team_data.content.read
    ///
    /// - returns: Through the response callback, the caller will receive a `Team.TeamFolderListResult` object on
    /// success or a `Team.TeamFolderListError` object on failure.
    @objc
    @discardableResult public func teamFolderList() -> DBXTeamTeamFolderListRpcRequest {
        let swift = swift.teamFolderList()
        return DBXTeamTeamFolderListRpcRequest(swift: swift)
    }

    /// Once a cursor has been retrieved from teamFolderList, use this to paginate through all team folders. Permission
    /// : Team member file access.
    ///
    /// - scope: team_data.content.read
    ///
    /// - parameter cursor: Indicates from what point to get the next set of team folders.
    ///
    /// - returns: Through the response callback, the caller will receive a `Team.TeamFolderListResult` object on
    /// success or a `Team.TeamFolderListContinueError` object on failure.
    @objc
    @discardableResult public func teamFolderListContinue(cursor: String) -> DBXTeamTeamFolderListContinueRpcRequest {
        let swift = swift.teamFolderListContinue(cursor: cursor)
        return DBXTeamTeamFolderListContinueRpcRequest(swift: swift)
    }

    /// Permanently deletes an archived team folder. This endpoint cannot be used for teams that have a shared team
    /// space. Permission : Team member file access.
    ///
    /// - scope: team_data.content.write
    ///
    /// - parameter teamFolderId: The ID of the team folder.
    ///
    /// - returns: Through the response callback, the caller will receive a `Void` object on success or a
    /// `Team.TeamFolderPermanentlyDeleteError` object on failure.
    @objc
    @discardableResult public func teamFolderPermanentlyDelete(teamFolderId: String) -> DBXTeamTeamFolderPermanentlyDeleteRpcRequest {
        let swift = swift.teamFolderPermanentlyDelete(teamFolderId: teamFolderId)
        return DBXTeamTeamFolderPermanentlyDeleteRpcRequest(swift: swift)
    }

    /// Changes an active team folder's name. Permission : Team member file access.
    ///
    /// - scope: team_data.content.write
    ///
    /// - parameter name: New team folder name.
    ///
    /// - returns: Through the response callback, the caller will receive a `Team.TeamFolderMetadata` object on success
    /// or a `Team.TeamFolderRenameError` object on failure.
    @objc
    @discardableResult public func teamFolderRename(teamFolderId: String, name: String) -> DBXTeamTeamFolderRenameRpcRequest {
        let swift = swift.teamFolderRename(teamFolderId: teamFolderId, name: name)
        return DBXTeamTeamFolderRenameRpcRequest(swift: swift)
    }

    /// Updates the sync settings on a team folder or its contents.  Use of this endpoint requires that the team has
    /// team selective sync enabled.
    ///
    /// - scope: team_data.content.write
    ///
    /// - parameter syncSetting: Sync setting to apply to the team folder itself. Only meaningful if the team folder is
    /// not a shared team root.
    /// - parameter contentSyncSettings: Sync settings to apply to contents of this team folder.
    ///
    /// - returns: Through the response callback, the caller will receive a `Team.TeamFolderMetadata` object on success
    /// or a `Team.TeamFolderUpdateSyncSettingsError` object on failure.
    @objc
    @discardableResult public func teamFolderUpdateSyncSettings(
        teamFolderId: String,
        syncSetting: DBXFilesSyncSettingArg?,
        contentSyncSettings: [DBXFilesContentSyncSettingArg]?
    ) -> DBXTeamTeamFolderUpdateSyncSettingsRpcRequest {
        let swift = swift.teamFolderUpdateSyncSettings(
            teamFolderId: teamFolderId,
            syncSetting: syncSetting?.swift,
            contentSyncSettings: contentSyncSettings?.map(\.swift)
        )
        return DBXTeamTeamFolderUpdateSyncSettingsRpcRequest(swift: swift)
    }

    /// Updates the sync settings on a team folder or its contents.  Use of this endpoint requires that the team has
    /// team selective sync enabled.
    ///
    /// - scope: team_data.content.write
    ///
    /// - returns: Through the response callback, the caller will receive a `Team.TeamFolderMetadata` object on success
    /// or a `Team.TeamFolderUpdateSyncSettingsError` object on failure.
    @objc
    @discardableResult public func teamFolderUpdateSyncSettings(teamFolderId: String) -> DBXTeamTeamFolderUpdateSyncSettingsRpcRequest {
        let swift = swift.teamFolderUpdateSyncSettings(teamFolderId: teamFolderId)
        return DBXTeamTeamFolderUpdateSyncSettingsRpcRequest(swift: swift)
    }

    /// Returns the member profile of the admin who generated the team access token used to make the call.
    ///
    /// - scope: team_info.read
    ///
    ///
    /// - returns: Through the response callback, the caller will receive a `Team.TokenGetAuthenticatedAdminResult`
    /// object on success or a `Team.TokenGetAuthenticatedAdminError` object on failure.
    @objc
    @discardableResult public func tokenGetAuthenticatedAdmin() -> DBXTeamTokenGetAuthenticatedAdminRpcRequest {
        let swift = swift.tokenGetAuthenticatedAdmin()
        return DBXTeamTokenGetAuthenticatedAdminRpcRequest(swift: swift)
    }
}

@objc
public class DBXTeamDevicesListMemberDevicesRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Team.ListMemberDevicesResultSerializer, Team.ListMemberDevicesErrorSerializer>

    init(swift: RpcRequest<Team.ListMemberDevicesResultSerializer, Team.ListMemberDevicesErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXTeamListMemberDevicesResult?, DBXTeamListMemberDevicesError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXTeamListMemberDevicesResult?, DBXTeamListMemberDevicesError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXTeamListMemberDevicesError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXTeamListMemberDevicesError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXTeamListMemberDevicesResult?
            if let swift = result {
                objc = DBXTeamListMemberDevicesResult(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXTeamDevicesListMembersDevicesRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Team.ListMembersDevicesResultSerializer, Team.ListMembersDevicesErrorSerializer>

    init(swift: RpcRequest<Team.ListMembersDevicesResultSerializer, Team.ListMembersDevicesErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXTeamListMembersDevicesResult?, DBXTeamListMembersDevicesError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXTeamListMembersDevicesResult?, DBXTeamListMembersDevicesError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXTeamListMembersDevicesError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXTeamListMembersDevicesError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXTeamListMembersDevicesResult?
            if let swift = result {
                objc = DBXTeamListMembersDevicesResult(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXTeamDevicesListTeamDevicesRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Team.ListTeamDevicesResultSerializer, Team.ListTeamDevicesErrorSerializer>

    init(swift: RpcRequest<Team.ListTeamDevicesResultSerializer, Team.ListTeamDevicesErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXTeamListTeamDevicesResult?, DBXTeamListTeamDevicesError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXTeamListTeamDevicesResult?, DBXTeamListTeamDevicesError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXTeamListTeamDevicesError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXTeamListTeamDevicesError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXTeamListTeamDevicesResult?
            if let swift = result {
                objc = DBXTeamListTeamDevicesResult(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXTeamDevicesRevokeDeviceSessionRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<VoidSerializer, Team.RevokeDeviceSessionErrorSerializer>

    init(swift: RpcRequest<VoidSerializer, Team.RevokeDeviceSessionErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXTeamRevokeDeviceSessionError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXTeamRevokeDeviceSessionError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { _, error in
            var routeError: DBXTeamRevokeDeviceSessionError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXTeamRevokeDeviceSessionError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            completionHandler(routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXTeamDevicesRevokeDeviceSessionBatchRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Team.RevokeDeviceSessionBatchResultSerializer, Team.RevokeDeviceSessionBatchErrorSerializer>

    init(swift: RpcRequest<Team.RevokeDeviceSessionBatchResultSerializer, Team.RevokeDeviceSessionBatchErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXTeamRevokeDeviceSessionBatchResult?, DBXTeamRevokeDeviceSessionBatchError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXTeamRevokeDeviceSessionBatchResult?, DBXTeamRevokeDeviceSessionBatchError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXTeamRevokeDeviceSessionBatchError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXTeamRevokeDeviceSessionBatchError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXTeamRevokeDeviceSessionBatchResult?
            if let swift = result {
                objc = DBXTeamRevokeDeviceSessionBatchResult(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXTeamFeaturesGetValuesRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Team.FeaturesGetValuesBatchResultSerializer, Team.FeaturesGetValuesBatchErrorSerializer>

    init(swift: RpcRequest<Team.FeaturesGetValuesBatchResultSerializer, Team.FeaturesGetValuesBatchErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXTeamFeaturesGetValuesBatchResult?, DBXTeamFeaturesGetValuesBatchError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXTeamFeaturesGetValuesBatchResult?, DBXTeamFeaturesGetValuesBatchError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXTeamFeaturesGetValuesBatchError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXTeamFeaturesGetValuesBatchError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXTeamFeaturesGetValuesBatchResult?
            if let swift = result {
                objc = DBXTeamFeaturesGetValuesBatchResult(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXTeamGetInfoRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Team.TeamGetInfoResultSerializer, VoidSerializer>

    init(swift: RpcRequest<Team.TeamGetInfoResultSerializer, VoidSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXTeamTeamGetInfoResult?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXTeamTeamGetInfoResult?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var objc: DBXTeamTeamGetInfoResult?
            if let swift = result {
                objc = DBXTeamTeamGetInfoResult(swift: swift)
            }
            completionHandler(objc, error?.objc)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXTeamGroupsCreateRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Team.GroupFullInfoSerializer, Team.GroupCreateErrorSerializer>

    init(swift: RpcRequest<Team.GroupFullInfoSerializer, Team.GroupCreateErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXTeamGroupFullInfo?, DBXTeamGroupCreateError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXTeamGroupFullInfo?, DBXTeamGroupCreateError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXTeamGroupCreateError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXTeamGroupCreateError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXTeamGroupFullInfo?
            if let swift = result {
                objc = DBXTeamGroupFullInfo(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXTeamGroupsDeleteRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Async.LaunchEmptyResultSerializer, Team.GroupDeleteErrorSerializer>

    init(swift: RpcRequest<Async.LaunchEmptyResultSerializer, Team.GroupDeleteErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXAsyncLaunchEmptyResult?, DBXTeamGroupDeleteError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXAsyncLaunchEmptyResult?, DBXTeamGroupDeleteError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXTeamGroupDeleteError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXTeamGroupDeleteError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXAsyncLaunchEmptyResult?
            if let swift = result {
                objc = DBXAsyncLaunchEmptyResult.factory(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXTeamGroupsGetInfoRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<ArraySerializer<Team.GroupsGetInfoItemSerializer>, Team.GroupsGetInfoErrorSerializer>

    init(swift: RpcRequest<ArraySerializer<Team.GroupsGetInfoItemSerializer>, Team.GroupsGetInfoErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping ([DBXTeamGroupsGetInfoItem]?, DBXTeamGroupsGetInfoError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping ([DBXTeamGroupsGetInfoItem]?, DBXTeamGroupsGetInfoError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXTeamGroupsGetInfoError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXTeamGroupsGetInfoError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: [DBXTeamGroupsGetInfoItem]?
            if let swift = result {
                objc = swift.map { DBXTeamGroupsGetInfoItem.factory(swift: $0) }
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXTeamGroupsJobStatusGetRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Async.PollEmptyResultSerializer, Team.GroupsPollErrorSerializer>

    init(swift: RpcRequest<Async.PollEmptyResultSerializer, Team.GroupsPollErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXAsyncPollEmptyResult?, DBXTeamGroupsPollError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXAsyncPollEmptyResult?, DBXTeamGroupsPollError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXTeamGroupsPollError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXTeamGroupsPollError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXAsyncPollEmptyResult?
            if let swift = result {
                objc = DBXAsyncPollEmptyResult.factory(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXTeamGroupsListRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Team.GroupsListResultSerializer, VoidSerializer>

    init(swift: RpcRequest<Team.GroupsListResultSerializer, VoidSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXTeamGroupsListResult?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXTeamGroupsListResult?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var objc: DBXTeamGroupsListResult?
            if let swift = result {
                objc = DBXTeamGroupsListResult(swift: swift)
            }
            completionHandler(objc, error?.objc)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXTeamGroupsListContinueRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Team.GroupsListResultSerializer, Team.GroupsListContinueErrorSerializer>

    init(swift: RpcRequest<Team.GroupsListResultSerializer, Team.GroupsListContinueErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXTeamGroupsListResult?, DBXTeamGroupsListContinueError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXTeamGroupsListResult?, DBXTeamGroupsListContinueError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXTeamGroupsListContinueError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXTeamGroupsListContinueError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXTeamGroupsListResult?
            if let swift = result {
                objc = DBXTeamGroupsListResult(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXTeamGroupsMembersAddRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Team.GroupMembersChangeResultSerializer, Team.GroupMembersAddErrorSerializer>

    init(swift: RpcRequest<Team.GroupMembersChangeResultSerializer, Team.GroupMembersAddErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXTeamGroupMembersChangeResult?, DBXTeamGroupMembersAddError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXTeamGroupMembersChangeResult?, DBXTeamGroupMembersAddError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXTeamGroupMembersAddError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXTeamGroupMembersAddError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXTeamGroupMembersChangeResult?
            if let swift = result {
                objc = DBXTeamGroupMembersChangeResult(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXTeamGroupsMembersListRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Team.GroupsMembersListResultSerializer, Team.GroupSelectorErrorSerializer>

    init(swift: RpcRequest<Team.GroupsMembersListResultSerializer, Team.GroupSelectorErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXTeamGroupsMembersListResult?, DBXTeamGroupSelectorError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXTeamGroupsMembersListResult?, DBXTeamGroupSelectorError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXTeamGroupSelectorError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXTeamGroupSelectorError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXTeamGroupsMembersListResult?
            if let swift = result {
                objc = DBXTeamGroupsMembersListResult(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXTeamGroupsMembersListContinueRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Team.GroupsMembersListResultSerializer, Team.GroupsMembersListContinueErrorSerializer>

    init(swift: RpcRequest<Team.GroupsMembersListResultSerializer, Team.GroupsMembersListContinueErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXTeamGroupsMembersListResult?, DBXTeamGroupsMembersListContinueError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXTeamGroupsMembersListResult?, DBXTeamGroupsMembersListContinueError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXTeamGroupsMembersListContinueError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXTeamGroupsMembersListContinueError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXTeamGroupsMembersListResult?
            if let swift = result {
                objc = DBXTeamGroupsMembersListResult(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXTeamGroupsMembersRemoveRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Team.GroupMembersChangeResultSerializer, Team.GroupMembersRemoveErrorSerializer>

    init(swift: RpcRequest<Team.GroupMembersChangeResultSerializer, Team.GroupMembersRemoveErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXTeamGroupMembersChangeResult?, DBXTeamGroupMembersRemoveError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXTeamGroupMembersChangeResult?, DBXTeamGroupMembersRemoveError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXTeamGroupMembersRemoveError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXTeamGroupMembersRemoveError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXTeamGroupMembersChangeResult?
            if let swift = result {
                objc = DBXTeamGroupMembersChangeResult(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXTeamGroupsMembersSetAccessTypeRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<ArraySerializer<Team.GroupsGetInfoItemSerializer>, Team.GroupMemberSetAccessTypeErrorSerializer>

    init(swift: RpcRequest<ArraySerializer<Team.GroupsGetInfoItemSerializer>, Team.GroupMemberSetAccessTypeErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping ([DBXTeamGroupsGetInfoItem]?, DBXTeamGroupMemberSetAccessTypeError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping ([DBXTeamGroupsGetInfoItem]?, DBXTeamGroupMemberSetAccessTypeError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXTeamGroupMemberSetAccessTypeError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXTeamGroupMemberSetAccessTypeError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: [DBXTeamGroupsGetInfoItem]?
            if let swift = result {
                objc = swift.map { DBXTeamGroupsGetInfoItem.factory(swift: $0) }
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXTeamGroupsUpdateRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Team.GroupFullInfoSerializer, Team.GroupUpdateErrorSerializer>

    init(swift: RpcRequest<Team.GroupFullInfoSerializer, Team.GroupUpdateErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXTeamGroupFullInfo?, DBXTeamGroupUpdateError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXTeamGroupFullInfo?, DBXTeamGroupUpdateError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXTeamGroupUpdateError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXTeamGroupUpdateError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXTeamGroupFullInfo?
            if let swift = result {
                objc = DBXTeamGroupFullInfo(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXTeamLegalHoldsCreatePolicyRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Team.LegalHoldPolicySerializer, Team.LegalHoldsPolicyCreateErrorSerializer>

    init(swift: RpcRequest<Team.LegalHoldPolicySerializer, Team.LegalHoldsPolicyCreateErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXTeamLegalHoldPolicy?, DBXTeamLegalHoldsPolicyCreateError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXTeamLegalHoldPolicy?, DBXTeamLegalHoldsPolicyCreateError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXTeamLegalHoldsPolicyCreateError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXTeamLegalHoldsPolicyCreateError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXTeamLegalHoldPolicy?
            if let swift = result {
                objc = DBXTeamLegalHoldPolicy(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXTeamLegalHoldsGetPolicyRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Team.LegalHoldPolicySerializer, Team.LegalHoldsGetPolicyErrorSerializer>

    init(swift: RpcRequest<Team.LegalHoldPolicySerializer, Team.LegalHoldsGetPolicyErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXTeamLegalHoldPolicy?, DBXTeamLegalHoldsGetPolicyError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXTeamLegalHoldPolicy?, DBXTeamLegalHoldsGetPolicyError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXTeamLegalHoldsGetPolicyError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXTeamLegalHoldsGetPolicyError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXTeamLegalHoldPolicy?
            if let swift = result {
                objc = DBXTeamLegalHoldPolicy(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXTeamLegalHoldsListHeldRevisionsRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Team.LegalHoldsListHeldRevisionResultSerializer, Team.LegalHoldsListHeldRevisionsErrorSerializer>

    init(swift: RpcRequest<Team.LegalHoldsListHeldRevisionResultSerializer, Team.LegalHoldsListHeldRevisionsErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXTeamLegalHoldsListHeldRevisionResult?, DBXTeamLegalHoldsListHeldRevisionsError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXTeamLegalHoldsListHeldRevisionResult?, DBXTeamLegalHoldsListHeldRevisionsError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXTeamLegalHoldsListHeldRevisionsError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXTeamLegalHoldsListHeldRevisionsError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXTeamLegalHoldsListHeldRevisionResult?
            if let swift = result {
                objc = DBXTeamLegalHoldsListHeldRevisionResult(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXTeamLegalHoldsListHeldRevisionsContinueRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Team.LegalHoldsListHeldRevisionResultSerializer, Team.LegalHoldsListHeldRevisionsErrorSerializer>

    init(swift: RpcRequest<Team.LegalHoldsListHeldRevisionResultSerializer, Team.LegalHoldsListHeldRevisionsErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXTeamLegalHoldsListHeldRevisionResult?, DBXTeamLegalHoldsListHeldRevisionsError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXTeamLegalHoldsListHeldRevisionResult?, DBXTeamLegalHoldsListHeldRevisionsError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXTeamLegalHoldsListHeldRevisionsError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXTeamLegalHoldsListHeldRevisionsError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXTeamLegalHoldsListHeldRevisionResult?
            if let swift = result {
                objc = DBXTeamLegalHoldsListHeldRevisionResult(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXTeamLegalHoldsListPoliciesRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Team.LegalHoldsListPoliciesResultSerializer, Team.LegalHoldsListPoliciesErrorSerializer>

    init(swift: RpcRequest<Team.LegalHoldsListPoliciesResultSerializer, Team.LegalHoldsListPoliciesErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXTeamLegalHoldsListPoliciesResult?, DBXTeamLegalHoldsListPoliciesError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXTeamLegalHoldsListPoliciesResult?, DBXTeamLegalHoldsListPoliciesError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXTeamLegalHoldsListPoliciesError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXTeamLegalHoldsListPoliciesError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXTeamLegalHoldsListPoliciesResult?
            if let swift = result {
                objc = DBXTeamLegalHoldsListPoliciesResult(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXTeamLegalHoldsReleasePolicyRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<VoidSerializer, Team.LegalHoldsPolicyReleaseErrorSerializer>

    init(swift: RpcRequest<VoidSerializer, Team.LegalHoldsPolicyReleaseErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXTeamLegalHoldsPolicyReleaseError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXTeamLegalHoldsPolicyReleaseError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { _, error in
            var routeError: DBXTeamLegalHoldsPolicyReleaseError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXTeamLegalHoldsPolicyReleaseError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            completionHandler(routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXTeamLegalHoldsUpdatePolicyRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Team.LegalHoldPolicySerializer, Team.LegalHoldsPolicyUpdateErrorSerializer>

    init(swift: RpcRequest<Team.LegalHoldPolicySerializer, Team.LegalHoldsPolicyUpdateErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXTeamLegalHoldPolicy?, DBXTeamLegalHoldsPolicyUpdateError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXTeamLegalHoldPolicy?, DBXTeamLegalHoldsPolicyUpdateError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXTeamLegalHoldsPolicyUpdateError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXTeamLegalHoldsPolicyUpdateError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXTeamLegalHoldPolicy?
            if let swift = result {
                objc = DBXTeamLegalHoldPolicy(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXTeamLinkedAppsListMemberLinkedAppsRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Team.ListMemberAppsResultSerializer, Team.ListMemberAppsErrorSerializer>

    init(swift: RpcRequest<Team.ListMemberAppsResultSerializer, Team.ListMemberAppsErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXTeamListMemberAppsResult?, DBXTeamListMemberAppsError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXTeamListMemberAppsResult?, DBXTeamListMemberAppsError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXTeamListMemberAppsError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXTeamListMemberAppsError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXTeamListMemberAppsResult?
            if let swift = result {
                objc = DBXTeamListMemberAppsResult(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXTeamLinkedAppsListMembersLinkedAppsRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Team.ListMembersAppsResultSerializer, Team.ListMembersAppsErrorSerializer>

    init(swift: RpcRequest<Team.ListMembersAppsResultSerializer, Team.ListMembersAppsErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXTeamListMembersAppsResult?, DBXTeamListMembersAppsError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXTeamListMembersAppsResult?, DBXTeamListMembersAppsError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXTeamListMembersAppsError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXTeamListMembersAppsError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXTeamListMembersAppsResult?
            if let swift = result {
                objc = DBXTeamListMembersAppsResult(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXTeamLinkedAppsListTeamLinkedAppsRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Team.ListTeamAppsResultSerializer, Team.ListTeamAppsErrorSerializer>

    init(swift: RpcRequest<Team.ListTeamAppsResultSerializer, Team.ListTeamAppsErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXTeamListTeamAppsResult?, DBXTeamListTeamAppsError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXTeamListTeamAppsResult?, DBXTeamListTeamAppsError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXTeamListTeamAppsError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXTeamListTeamAppsError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXTeamListTeamAppsResult?
            if let swift = result {
                objc = DBXTeamListTeamAppsResult(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXTeamLinkedAppsRevokeLinkedAppRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<VoidSerializer, Team.RevokeLinkedAppErrorSerializer>

    init(swift: RpcRequest<VoidSerializer, Team.RevokeLinkedAppErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXTeamRevokeLinkedAppError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXTeamRevokeLinkedAppError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { _, error in
            var routeError: DBXTeamRevokeLinkedAppError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXTeamRevokeLinkedAppError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            completionHandler(routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXTeamLinkedAppsRevokeLinkedAppBatchRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Team.RevokeLinkedAppBatchResultSerializer, Team.RevokeLinkedAppBatchErrorSerializer>

    init(swift: RpcRequest<Team.RevokeLinkedAppBatchResultSerializer, Team.RevokeLinkedAppBatchErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXTeamRevokeLinkedAppBatchResult?, DBXTeamRevokeLinkedAppBatchError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXTeamRevokeLinkedAppBatchResult?, DBXTeamRevokeLinkedAppBatchError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXTeamRevokeLinkedAppBatchError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXTeamRevokeLinkedAppBatchError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXTeamRevokeLinkedAppBatchResult?
            if let swift = result {
                objc = DBXTeamRevokeLinkedAppBatchResult(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXTeamMemberSpaceLimitsExcludedUsersAddRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Team.ExcludedUsersUpdateResultSerializer, Team.ExcludedUsersUpdateErrorSerializer>

    init(swift: RpcRequest<Team.ExcludedUsersUpdateResultSerializer, Team.ExcludedUsersUpdateErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXTeamExcludedUsersUpdateResult?, DBXTeamExcludedUsersUpdateError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXTeamExcludedUsersUpdateResult?, DBXTeamExcludedUsersUpdateError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXTeamExcludedUsersUpdateError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXTeamExcludedUsersUpdateError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXTeamExcludedUsersUpdateResult?
            if let swift = result {
                objc = DBXTeamExcludedUsersUpdateResult(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXTeamMemberSpaceLimitsExcludedUsersListRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Team.ExcludedUsersListResultSerializer, Team.ExcludedUsersListErrorSerializer>

    init(swift: RpcRequest<Team.ExcludedUsersListResultSerializer, Team.ExcludedUsersListErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXTeamExcludedUsersListResult?, DBXTeamExcludedUsersListError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXTeamExcludedUsersListResult?, DBXTeamExcludedUsersListError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXTeamExcludedUsersListError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXTeamExcludedUsersListError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXTeamExcludedUsersListResult?
            if let swift = result {
                objc = DBXTeamExcludedUsersListResult(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXTeamMemberSpaceLimitsExcludedUsersListContinueRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Team.ExcludedUsersListResultSerializer, Team.ExcludedUsersListContinueErrorSerializer>

    init(swift: RpcRequest<Team.ExcludedUsersListResultSerializer, Team.ExcludedUsersListContinueErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXTeamExcludedUsersListResult?, DBXTeamExcludedUsersListContinueError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXTeamExcludedUsersListResult?, DBXTeamExcludedUsersListContinueError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXTeamExcludedUsersListContinueError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXTeamExcludedUsersListContinueError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXTeamExcludedUsersListResult?
            if let swift = result {
                objc = DBXTeamExcludedUsersListResult(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXTeamMemberSpaceLimitsExcludedUsersRemoveRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Team.ExcludedUsersUpdateResultSerializer, Team.ExcludedUsersUpdateErrorSerializer>

    init(swift: RpcRequest<Team.ExcludedUsersUpdateResultSerializer, Team.ExcludedUsersUpdateErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXTeamExcludedUsersUpdateResult?, DBXTeamExcludedUsersUpdateError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXTeamExcludedUsersUpdateResult?, DBXTeamExcludedUsersUpdateError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXTeamExcludedUsersUpdateError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXTeamExcludedUsersUpdateError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXTeamExcludedUsersUpdateResult?
            if let swift = result {
                objc = DBXTeamExcludedUsersUpdateResult(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXTeamMemberSpaceLimitsGetCustomQuotaRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<ArraySerializer<Team.CustomQuotaResultSerializer>, Team.CustomQuotaErrorSerializer>

    init(swift: RpcRequest<ArraySerializer<Team.CustomQuotaResultSerializer>, Team.CustomQuotaErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping ([DBXTeamCustomQuotaResult]?, DBXTeamCustomQuotaError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping ([DBXTeamCustomQuotaResult]?, DBXTeamCustomQuotaError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXTeamCustomQuotaError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXTeamCustomQuotaError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: [DBXTeamCustomQuotaResult]?
            if let swift = result {
                objc = swift.map { DBXTeamCustomQuotaResult.factory(swift: $0) }
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXTeamMemberSpaceLimitsRemoveCustomQuotaRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<ArraySerializer<Team.RemoveCustomQuotaResultSerializer>, Team.CustomQuotaErrorSerializer>

    init(swift: RpcRequest<ArraySerializer<Team.RemoveCustomQuotaResultSerializer>, Team.CustomQuotaErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping ([DBXTeamRemoveCustomQuotaResult]?, DBXTeamCustomQuotaError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping ([DBXTeamRemoveCustomQuotaResult]?, DBXTeamCustomQuotaError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXTeamCustomQuotaError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXTeamCustomQuotaError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: [DBXTeamRemoveCustomQuotaResult]?
            if let swift = result {
                objc = swift.map { DBXTeamRemoveCustomQuotaResult.factory(swift: $0) }
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXTeamMemberSpaceLimitsSetCustomQuotaRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<ArraySerializer<Team.CustomQuotaResultSerializer>, Team.SetCustomQuotaErrorSerializer>

    init(swift: RpcRequest<ArraySerializer<Team.CustomQuotaResultSerializer>, Team.SetCustomQuotaErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping ([DBXTeamCustomQuotaResult]?, DBXTeamSetCustomQuotaError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping ([DBXTeamCustomQuotaResult]?, DBXTeamSetCustomQuotaError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXTeamSetCustomQuotaError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXTeamSetCustomQuotaError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: [DBXTeamCustomQuotaResult]?
            if let swift = result {
                objc = swift.map { DBXTeamCustomQuotaResult.factory(swift: $0) }
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXTeamMembersAddRpcRequestV2: NSObject, DBXRequest {
    var swift: RpcRequest<Team.MembersAddLaunchV2ResultSerializer, VoidSerializer>

    init(swift: RpcRequest<Team.MembersAddLaunchV2ResultSerializer, VoidSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXTeamMembersAddLaunchV2Result?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXTeamMembersAddLaunchV2Result?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var objc: DBXTeamMembersAddLaunchV2Result?
            if let swift = result {
                objc = DBXTeamMembersAddLaunchV2Result.factory(swift: swift)
            }
            completionHandler(objc, error?.objc)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXTeamMembersAddRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Team.MembersAddLaunchSerializer, VoidSerializer>

    init(swift: RpcRequest<Team.MembersAddLaunchSerializer, VoidSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXTeamMembersAddLaunch?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXTeamMembersAddLaunch?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var objc: DBXTeamMembersAddLaunch?
            if let swift = result {
                objc = DBXTeamMembersAddLaunch.factory(swift: swift)
            }
            completionHandler(objc, error?.objc)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXTeamMembersAddJobStatusGetRpcRequestV2: NSObject, DBXRequest {
    var swift: RpcRequest<Team.MembersAddJobStatusV2ResultSerializer, Async.PollErrorSerializer>

    init(swift: RpcRequest<Team.MembersAddJobStatusV2ResultSerializer, Async.PollErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXTeamMembersAddJobStatusV2Result?, DBXAsyncPollError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXTeamMembersAddJobStatusV2Result?, DBXAsyncPollError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXAsyncPollError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXAsyncPollError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXTeamMembersAddJobStatusV2Result?
            if let swift = result {
                objc = DBXTeamMembersAddJobStatusV2Result.factory(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXTeamMembersAddJobStatusGetRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Team.MembersAddJobStatusSerializer, Async.PollErrorSerializer>

    init(swift: RpcRequest<Team.MembersAddJobStatusSerializer, Async.PollErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXTeamMembersAddJobStatus?, DBXAsyncPollError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXTeamMembersAddJobStatus?, DBXAsyncPollError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXAsyncPollError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXAsyncPollError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXTeamMembersAddJobStatus?
            if let swift = result {
                objc = DBXTeamMembersAddJobStatus.factory(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXTeamMembersDeleteProfilePhotoRpcRequestV2: NSObject, DBXRequest {
    var swift: RpcRequest<Team.TeamMemberInfoV2ResultSerializer, Team.MembersDeleteProfilePhotoErrorSerializer>

    init(swift: RpcRequest<Team.TeamMemberInfoV2ResultSerializer, Team.MembersDeleteProfilePhotoErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXTeamTeamMemberInfoV2Result?, DBXTeamMembersDeleteProfilePhotoError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXTeamTeamMemberInfoV2Result?, DBXTeamMembersDeleteProfilePhotoError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXTeamMembersDeleteProfilePhotoError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXTeamMembersDeleteProfilePhotoError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXTeamTeamMemberInfoV2Result?
            if let swift = result {
                objc = DBXTeamTeamMemberInfoV2Result(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXTeamMembersDeleteProfilePhotoRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Team.TeamMemberInfoSerializer, Team.MembersDeleteProfilePhotoErrorSerializer>

    init(swift: RpcRequest<Team.TeamMemberInfoSerializer, Team.MembersDeleteProfilePhotoErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXTeamTeamMemberInfo?, DBXTeamMembersDeleteProfilePhotoError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXTeamTeamMemberInfo?, DBXTeamMembersDeleteProfilePhotoError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXTeamMembersDeleteProfilePhotoError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXTeamMembersDeleteProfilePhotoError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXTeamTeamMemberInfo?
            if let swift = result {
                objc = DBXTeamTeamMemberInfo(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXTeamMembersGetAvailableTeamMemberRolesRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Team.MembersGetAvailableTeamMemberRolesResultSerializer, VoidSerializer>

    init(swift: RpcRequest<Team.MembersGetAvailableTeamMemberRolesResultSerializer, VoidSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXTeamMembersGetAvailableTeamMemberRolesResult?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXTeamMembersGetAvailableTeamMemberRolesResult?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var objc: DBXTeamMembersGetAvailableTeamMemberRolesResult?
            if let swift = result {
                objc = DBXTeamMembersGetAvailableTeamMemberRolesResult(swift: swift)
            }
            completionHandler(objc, error?.objc)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXTeamMembersGetInfoRpcRequestV2: NSObject, DBXRequest {
    var swift: RpcRequest<Team.MembersGetInfoV2ResultSerializer, Team.MembersGetInfoErrorSerializer>

    init(swift: RpcRequest<Team.MembersGetInfoV2ResultSerializer, Team.MembersGetInfoErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXTeamMembersGetInfoV2Result?, DBXTeamMembersGetInfoError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXTeamMembersGetInfoV2Result?, DBXTeamMembersGetInfoError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXTeamMembersGetInfoError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXTeamMembersGetInfoError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXTeamMembersGetInfoV2Result?
            if let swift = result {
                objc = DBXTeamMembersGetInfoV2Result(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXTeamMembersGetInfoRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<ArraySerializer<Team.MembersGetInfoItemSerializer>, Team.MembersGetInfoErrorSerializer>

    init(swift: RpcRequest<ArraySerializer<Team.MembersGetInfoItemSerializer>, Team.MembersGetInfoErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping ([DBXTeamMembersGetInfoItem]?, DBXTeamMembersGetInfoError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping ([DBXTeamMembersGetInfoItem]?, DBXTeamMembersGetInfoError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXTeamMembersGetInfoError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXTeamMembersGetInfoError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: [DBXTeamMembersGetInfoItem]?
            if let swift = result {
                objc = swift.map { DBXTeamMembersGetInfoItem.factory(swift: $0) }
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXTeamMembersListRpcRequestV2: NSObject, DBXRequest {
    var swift: RpcRequest<Team.MembersListV2ResultSerializer, Team.MembersListErrorSerializer>

    init(swift: RpcRequest<Team.MembersListV2ResultSerializer, Team.MembersListErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXTeamMembersListV2Result?, DBXTeamMembersListError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXTeamMembersListV2Result?, DBXTeamMembersListError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXTeamMembersListError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXTeamMembersListError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXTeamMembersListV2Result?
            if let swift = result {
                objc = DBXTeamMembersListV2Result(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXTeamMembersListRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Team.MembersListResultSerializer, Team.MembersListErrorSerializer>

    init(swift: RpcRequest<Team.MembersListResultSerializer, Team.MembersListErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXTeamMembersListResult?, DBXTeamMembersListError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXTeamMembersListResult?, DBXTeamMembersListError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXTeamMembersListError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXTeamMembersListError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXTeamMembersListResult?
            if let swift = result {
                objc = DBXTeamMembersListResult(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXTeamMembersListContinueRpcRequestV2: NSObject, DBXRequest {
    var swift: RpcRequest<Team.MembersListV2ResultSerializer, Team.MembersListContinueErrorSerializer>

    init(swift: RpcRequest<Team.MembersListV2ResultSerializer, Team.MembersListContinueErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXTeamMembersListV2Result?, DBXTeamMembersListContinueError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXTeamMembersListV2Result?, DBXTeamMembersListContinueError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXTeamMembersListContinueError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXTeamMembersListContinueError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXTeamMembersListV2Result?
            if let swift = result {
                objc = DBXTeamMembersListV2Result(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXTeamMembersListContinueRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Team.MembersListResultSerializer, Team.MembersListContinueErrorSerializer>

    init(swift: RpcRequest<Team.MembersListResultSerializer, Team.MembersListContinueErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXTeamMembersListResult?, DBXTeamMembersListContinueError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXTeamMembersListResult?, DBXTeamMembersListContinueError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXTeamMembersListContinueError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXTeamMembersListContinueError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXTeamMembersListResult?
            if let swift = result {
                objc = DBXTeamMembersListResult(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXTeamMembersMoveFormerMemberFilesRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Async.LaunchEmptyResultSerializer, Team.MembersTransferFormerMembersFilesErrorSerializer>

    init(swift: RpcRequest<Async.LaunchEmptyResultSerializer, Team.MembersTransferFormerMembersFilesErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXAsyncLaunchEmptyResult?, DBXTeamMembersTransferFormerMembersFilesError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXAsyncLaunchEmptyResult?, DBXTeamMembersTransferFormerMembersFilesError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXTeamMembersTransferFormerMembersFilesError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXTeamMembersTransferFormerMembersFilesError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXAsyncLaunchEmptyResult?
            if let swift = result {
                objc = DBXAsyncLaunchEmptyResult.factory(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXTeamMembersMoveFormerMemberFilesJobStatusCheckRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Async.PollEmptyResultSerializer, Async.PollErrorSerializer>

    init(swift: RpcRequest<Async.PollEmptyResultSerializer, Async.PollErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXAsyncPollEmptyResult?, DBXAsyncPollError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXAsyncPollEmptyResult?, DBXAsyncPollError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXAsyncPollError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXAsyncPollError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXAsyncPollEmptyResult?
            if let swift = result {
                objc = DBXAsyncPollEmptyResult.factory(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXTeamMembersRecoverRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<VoidSerializer, Team.MembersRecoverErrorSerializer>

    init(swift: RpcRequest<VoidSerializer, Team.MembersRecoverErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXTeamMembersRecoverError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXTeamMembersRecoverError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { _, error in
            var routeError: DBXTeamMembersRecoverError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXTeamMembersRecoverError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            completionHandler(routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXTeamMembersRemoveRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Async.LaunchEmptyResultSerializer, Team.MembersRemoveErrorSerializer>

    init(swift: RpcRequest<Async.LaunchEmptyResultSerializer, Team.MembersRemoveErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXAsyncLaunchEmptyResult?, DBXTeamMembersRemoveError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXAsyncLaunchEmptyResult?, DBXTeamMembersRemoveError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXTeamMembersRemoveError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXTeamMembersRemoveError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXAsyncLaunchEmptyResult?
            if let swift = result {
                objc = DBXAsyncLaunchEmptyResult.factory(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXTeamMembersRemoveJobStatusGetRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Async.PollEmptyResultSerializer, Async.PollErrorSerializer>

    init(swift: RpcRequest<Async.PollEmptyResultSerializer, Async.PollErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXAsyncPollEmptyResult?, DBXAsyncPollError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXAsyncPollEmptyResult?, DBXAsyncPollError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXAsyncPollError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXAsyncPollError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXAsyncPollEmptyResult?
            if let swift = result {
                objc = DBXAsyncPollEmptyResult.factory(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXTeamMembersSecondaryEmailsAddRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Team.AddSecondaryEmailsResultSerializer, Team.AddSecondaryEmailsErrorSerializer>

    init(swift: RpcRequest<Team.AddSecondaryEmailsResultSerializer, Team.AddSecondaryEmailsErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXTeamAddSecondaryEmailsResult?, DBXTeamAddSecondaryEmailsError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXTeamAddSecondaryEmailsResult?, DBXTeamAddSecondaryEmailsError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXTeamAddSecondaryEmailsError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXTeamAddSecondaryEmailsError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXTeamAddSecondaryEmailsResult?
            if let swift = result {
                objc = DBXTeamAddSecondaryEmailsResult(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXTeamMembersSecondaryEmailsDeleteRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Team.DeleteSecondaryEmailsResultSerializer, VoidSerializer>

    init(swift: RpcRequest<Team.DeleteSecondaryEmailsResultSerializer, VoidSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXTeamDeleteSecondaryEmailsResult?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXTeamDeleteSecondaryEmailsResult?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var objc: DBXTeamDeleteSecondaryEmailsResult?
            if let swift = result {
                objc = DBXTeamDeleteSecondaryEmailsResult(swift: swift)
            }
            completionHandler(objc, error?.objc)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXTeamMembersSecondaryEmailsResendVerificationEmailsRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Team.ResendVerificationEmailResultSerializer, VoidSerializer>

    init(swift: RpcRequest<Team.ResendVerificationEmailResultSerializer, VoidSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXTeamResendVerificationEmailResult?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXTeamResendVerificationEmailResult?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var objc: DBXTeamResendVerificationEmailResult?
            if let swift = result {
                objc = DBXTeamResendVerificationEmailResult(swift: swift)
            }
            completionHandler(objc, error?.objc)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXTeamMembersSendWelcomeEmailRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<VoidSerializer, Team.MembersSendWelcomeErrorSerializer>

    init(swift: RpcRequest<VoidSerializer, Team.MembersSendWelcomeErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXTeamMembersSendWelcomeError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXTeamMembersSendWelcomeError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { _, error in
            var routeError: DBXTeamMembersSendWelcomeError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXTeamMembersSendWelcomeError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            completionHandler(routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXTeamMembersSetAdminPermissionsRpcRequestV2: NSObject, DBXRequest {
    var swift: RpcRequest<Team.MembersSetPermissions2ResultSerializer, Team.MembersSetPermissions2ErrorSerializer>

    init(swift: RpcRequest<Team.MembersSetPermissions2ResultSerializer, Team.MembersSetPermissions2ErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXTeamMembersSetPermissions2Result?, DBXTeamMembersSetPermissions2Error?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXTeamMembersSetPermissions2Result?, DBXTeamMembersSetPermissions2Error?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXTeamMembersSetPermissions2Error?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXTeamMembersSetPermissions2Error(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXTeamMembersSetPermissions2Result?
            if let swift = result {
                objc = DBXTeamMembersSetPermissions2Result(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXTeamMembersSetAdminPermissionsRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Team.MembersSetPermissionsResultSerializer, Team.MembersSetPermissionsErrorSerializer>

    init(swift: RpcRequest<Team.MembersSetPermissionsResultSerializer, Team.MembersSetPermissionsErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXTeamMembersSetPermissionsResult?, DBXTeamMembersSetPermissionsError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXTeamMembersSetPermissionsResult?, DBXTeamMembersSetPermissionsError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXTeamMembersSetPermissionsError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXTeamMembersSetPermissionsError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXTeamMembersSetPermissionsResult?
            if let swift = result {
                objc = DBXTeamMembersSetPermissionsResult(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXTeamMembersSetProfileRpcRequestV2: NSObject, DBXRequest {
    var swift: RpcRequest<Team.TeamMemberInfoV2ResultSerializer, Team.MembersSetProfileErrorSerializer>

    init(swift: RpcRequest<Team.TeamMemberInfoV2ResultSerializer, Team.MembersSetProfileErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXTeamTeamMemberInfoV2Result?, DBXTeamMembersSetProfileError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXTeamTeamMemberInfoV2Result?, DBXTeamMembersSetProfileError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXTeamMembersSetProfileError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXTeamMembersSetProfileError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXTeamTeamMemberInfoV2Result?
            if let swift = result {
                objc = DBXTeamTeamMemberInfoV2Result(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXTeamMembersSetProfileRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Team.TeamMemberInfoSerializer, Team.MembersSetProfileErrorSerializer>

    init(swift: RpcRequest<Team.TeamMemberInfoSerializer, Team.MembersSetProfileErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXTeamTeamMemberInfo?, DBXTeamMembersSetProfileError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXTeamTeamMemberInfo?, DBXTeamMembersSetProfileError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXTeamMembersSetProfileError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXTeamMembersSetProfileError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXTeamTeamMemberInfo?
            if let swift = result {
                objc = DBXTeamTeamMemberInfo(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXTeamMembersSetProfilePhotoRpcRequestV2: NSObject, DBXRequest {
    var swift: RpcRequest<Team.TeamMemberInfoV2ResultSerializer, Team.MembersSetProfilePhotoErrorSerializer>

    init(swift: RpcRequest<Team.TeamMemberInfoV2ResultSerializer, Team.MembersSetProfilePhotoErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXTeamTeamMemberInfoV2Result?, DBXTeamMembersSetProfilePhotoError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXTeamTeamMemberInfoV2Result?, DBXTeamMembersSetProfilePhotoError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXTeamMembersSetProfilePhotoError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXTeamMembersSetProfilePhotoError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXTeamTeamMemberInfoV2Result?
            if let swift = result {
                objc = DBXTeamTeamMemberInfoV2Result(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXTeamMembersSetProfilePhotoRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Team.TeamMemberInfoSerializer, Team.MembersSetProfilePhotoErrorSerializer>

    init(swift: RpcRequest<Team.TeamMemberInfoSerializer, Team.MembersSetProfilePhotoErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXTeamTeamMemberInfo?, DBXTeamMembersSetProfilePhotoError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXTeamTeamMemberInfo?, DBXTeamMembersSetProfilePhotoError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXTeamMembersSetProfilePhotoError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXTeamMembersSetProfilePhotoError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXTeamTeamMemberInfo?
            if let swift = result {
                objc = DBXTeamTeamMemberInfo(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXTeamMembersSuspendRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<VoidSerializer, Team.MembersSuspendErrorSerializer>

    init(swift: RpcRequest<VoidSerializer, Team.MembersSuspendErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXTeamMembersSuspendError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXTeamMembersSuspendError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { _, error in
            var routeError: DBXTeamMembersSuspendError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXTeamMembersSuspendError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            completionHandler(routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXTeamMembersUnsuspendRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<VoidSerializer, Team.MembersUnsuspendErrorSerializer>

    init(swift: RpcRequest<VoidSerializer, Team.MembersUnsuspendErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXTeamMembersUnsuspendError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXTeamMembersUnsuspendError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { _, error in
            var routeError: DBXTeamMembersUnsuspendError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXTeamMembersUnsuspendError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            completionHandler(routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXTeamNamespacesListRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Team.TeamNamespacesListResultSerializer, Team.TeamNamespacesListErrorSerializer>

    init(swift: RpcRequest<Team.TeamNamespacesListResultSerializer, Team.TeamNamespacesListErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXTeamTeamNamespacesListResult?, DBXTeamTeamNamespacesListError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXTeamTeamNamespacesListResult?, DBXTeamTeamNamespacesListError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXTeamTeamNamespacesListError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXTeamTeamNamespacesListError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXTeamTeamNamespacesListResult?
            if let swift = result {
                objc = DBXTeamTeamNamespacesListResult(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXTeamNamespacesListContinueRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Team.TeamNamespacesListResultSerializer, Team.TeamNamespacesListContinueErrorSerializer>

    init(swift: RpcRequest<Team.TeamNamespacesListResultSerializer, Team.TeamNamespacesListContinueErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXTeamTeamNamespacesListResult?, DBXTeamTeamNamespacesListContinueError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXTeamTeamNamespacesListResult?, DBXTeamTeamNamespacesListContinueError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXTeamTeamNamespacesListContinueError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXTeamTeamNamespacesListContinueError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXTeamTeamNamespacesListResult?
            if let swift = result {
                objc = DBXTeamTeamNamespacesListResult(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXTeamPropertiesTemplateAddRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<FileProperties.AddTemplateResultSerializer, FileProperties.ModifyTemplateErrorSerializer>

    init(swift: RpcRequest<FileProperties.AddTemplateResultSerializer, FileProperties.ModifyTemplateErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXFilePropertiesAddTemplateResult?, DBXFilePropertiesModifyTemplateError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXFilePropertiesAddTemplateResult?, DBXFilePropertiesModifyTemplateError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXFilePropertiesModifyTemplateError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXFilePropertiesModifyTemplateError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXFilePropertiesAddTemplateResult?
            if let swift = result {
                objc = DBXFilePropertiesAddTemplateResult(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXTeamPropertiesTemplateGetRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<FileProperties.GetTemplateResultSerializer, FileProperties.TemplateErrorSerializer>

    init(swift: RpcRequest<FileProperties.GetTemplateResultSerializer, FileProperties.TemplateErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXFilePropertiesGetTemplateResult?, DBXFilePropertiesTemplateError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXFilePropertiesGetTemplateResult?, DBXFilePropertiesTemplateError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXFilePropertiesTemplateError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXFilePropertiesTemplateError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXFilePropertiesGetTemplateResult?
            if let swift = result {
                objc = DBXFilePropertiesGetTemplateResult(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXTeamPropertiesTemplateListRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<FileProperties.ListTemplateResultSerializer, FileProperties.TemplateErrorSerializer>

    init(swift: RpcRequest<FileProperties.ListTemplateResultSerializer, FileProperties.TemplateErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXFilePropertiesListTemplateResult?, DBXFilePropertiesTemplateError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXFilePropertiesListTemplateResult?, DBXFilePropertiesTemplateError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXFilePropertiesTemplateError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXFilePropertiesTemplateError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXFilePropertiesListTemplateResult?
            if let swift = result {
                objc = DBXFilePropertiesListTemplateResult(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXTeamPropertiesTemplateUpdateRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<FileProperties.UpdateTemplateResultSerializer, FileProperties.ModifyTemplateErrorSerializer>

    init(swift: RpcRequest<FileProperties.UpdateTemplateResultSerializer, FileProperties.ModifyTemplateErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXFilePropertiesUpdateTemplateResult?, DBXFilePropertiesModifyTemplateError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXFilePropertiesUpdateTemplateResult?, DBXFilePropertiesModifyTemplateError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXFilePropertiesModifyTemplateError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXFilePropertiesModifyTemplateError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXFilePropertiesUpdateTemplateResult?
            if let swift = result {
                objc = DBXFilePropertiesUpdateTemplateResult(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXTeamReportsGetActivityRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Team.GetActivityReportSerializer, Team.DateRangeErrorSerializer>

    init(swift: RpcRequest<Team.GetActivityReportSerializer, Team.DateRangeErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXTeamGetActivityReport?, DBXTeamDateRangeError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXTeamGetActivityReport?, DBXTeamDateRangeError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXTeamDateRangeError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXTeamDateRangeError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXTeamGetActivityReport?
            if let swift = result {
                objc = DBXTeamGetActivityReport(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXTeamReportsGetDevicesRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Team.GetDevicesReportSerializer, Team.DateRangeErrorSerializer>

    init(swift: RpcRequest<Team.GetDevicesReportSerializer, Team.DateRangeErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXTeamGetDevicesReport?, DBXTeamDateRangeError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXTeamGetDevicesReport?, DBXTeamDateRangeError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXTeamDateRangeError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXTeamDateRangeError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXTeamGetDevicesReport?
            if let swift = result {
                objc = DBXTeamGetDevicesReport(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXTeamReportsGetMembershipRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Team.GetMembershipReportSerializer, Team.DateRangeErrorSerializer>

    init(swift: RpcRequest<Team.GetMembershipReportSerializer, Team.DateRangeErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXTeamGetMembershipReport?, DBXTeamDateRangeError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXTeamGetMembershipReport?, DBXTeamDateRangeError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXTeamDateRangeError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXTeamDateRangeError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXTeamGetMembershipReport?
            if let swift = result {
                objc = DBXTeamGetMembershipReport(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXTeamReportsGetStorageRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Team.GetStorageReportSerializer, Team.DateRangeErrorSerializer>

    init(swift: RpcRequest<Team.GetStorageReportSerializer, Team.DateRangeErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXTeamGetStorageReport?, DBXTeamDateRangeError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXTeamGetStorageReport?, DBXTeamDateRangeError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXTeamDateRangeError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXTeamDateRangeError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXTeamGetStorageReport?
            if let swift = result {
                objc = DBXTeamGetStorageReport(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXTeamSharingAllowlistAddRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Team.SharingAllowlistAddResponseSerializer, Team.SharingAllowlistAddErrorSerializer>

    init(swift: RpcRequest<Team.SharingAllowlistAddResponseSerializer, Team.SharingAllowlistAddErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXTeamSharingAllowlistAddResponse?, DBXTeamSharingAllowlistAddError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXTeamSharingAllowlistAddResponse?, DBXTeamSharingAllowlistAddError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXTeamSharingAllowlistAddError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXTeamSharingAllowlistAddError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXTeamSharingAllowlistAddResponse?
            if let swift = result {
                objc = DBXTeamSharingAllowlistAddResponse(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXTeamSharingAllowlistListRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Team.SharingAllowlistListResponseSerializer, Team.SharingAllowlistListErrorSerializer>

    init(swift: RpcRequest<Team.SharingAllowlistListResponseSerializer, Team.SharingAllowlistListErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXTeamSharingAllowlistListResponse?, DBXTeamSharingAllowlistListError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXTeamSharingAllowlistListResponse?, DBXTeamSharingAllowlistListError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXTeamSharingAllowlistListError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXTeamSharingAllowlistListError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXTeamSharingAllowlistListResponse?
            if let swift = result {
                objc = DBXTeamSharingAllowlistListResponse(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXTeamSharingAllowlistListContinueRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Team.SharingAllowlistListResponseSerializer, Team.SharingAllowlistListContinueErrorSerializer>

    init(swift: RpcRequest<Team.SharingAllowlistListResponseSerializer, Team.SharingAllowlistListContinueErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXTeamSharingAllowlistListResponse?, DBXTeamSharingAllowlistListContinueError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXTeamSharingAllowlistListResponse?, DBXTeamSharingAllowlistListContinueError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXTeamSharingAllowlistListContinueError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXTeamSharingAllowlistListContinueError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXTeamSharingAllowlistListResponse?
            if let swift = result {
                objc = DBXTeamSharingAllowlistListResponse(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXTeamSharingAllowlistRemoveRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Team.SharingAllowlistRemoveResponseSerializer, Team.SharingAllowlistRemoveErrorSerializer>

    init(swift: RpcRequest<Team.SharingAllowlistRemoveResponseSerializer, Team.SharingAllowlistRemoveErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXTeamSharingAllowlistRemoveResponse?, DBXTeamSharingAllowlistRemoveError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXTeamSharingAllowlistRemoveResponse?, DBXTeamSharingAllowlistRemoveError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXTeamSharingAllowlistRemoveError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXTeamSharingAllowlistRemoveError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXTeamSharingAllowlistRemoveResponse?
            if let swift = result {
                objc = DBXTeamSharingAllowlistRemoveResponse(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXTeamTeamFolderActivateRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Team.TeamFolderMetadataSerializer, Team.TeamFolderActivateErrorSerializer>

    init(swift: RpcRequest<Team.TeamFolderMetadataSerializer, Team.TeamFolderActivateErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXTeamTeamFolderMetadata?, DBXTeamTeamFolderActivateError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXTeamTeamFolderMetadata?, DBXTeamTeamFolderActivateError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXTeamTeamFolderActivateError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXTeamTeamFolderActivateError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXTeamTeamFolderMetadata?
            if let swift = result {
                objc = DBXTeamTeamFolderMetadata(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXTeamTeamFolderArchiveRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Team.TeamFolderArchiveLaunchSerializer, Team.TeamFolderArchiveErrorSerializer>

    init(swift: RpcRequest<Team.TeamFolderArchiveLaunchSerializer, Team.TeamFolderArchiveErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXTeamTeamFolderArchiveLaunch?, DBXTeamTeamFolderArchiveError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXTeamTeamFolderArchiveLaunch?, DBXTeamTeamFolderArchiveError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXTeamTeamFolderArchiveError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXTeamTeamFolderArchiveError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXTeamTeamFolderArchiveLaunch?
            if let swift = result {
                objc = DBXTeamTeamFolderArchiveLaunch.factory(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXTeamTeamFolderArchiveCheckRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Team.TeamFolderArchiveJobStatusSerializer, Async.PollErrorSerializer>

    init(swift: RpcRequest<Team.TeamFolderArchiveJobStatusSerializer, Async.PollErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXTeamTeamFolderArchiveJobStatus?, DBXAsyncPollError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXTeamTeamFolderArchiveJobStatus?, DBXAsyncPollError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXAsyncPollError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXAsyncPollError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXTeamTeamFolderArchiveJobStatus?
            if let swift = result {
                objc = DBXTeamTeamFolderArchiveJobStatus.factory(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXTeamTeamFolderCreateRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Team.TeamFolderMetadataSerializer, Team.TeamFolderCreateErrorSerializer>

    init(swift: RpcRequest<Team.TeamFolderMetadataSerializer, Team.TeamFolderCreateErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXTeamTeamFolderMetadata?, DBXTeamTeamFolderCreateError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXTeamTeamFolderMetadata?, DBXTeamTeamFolderCreateError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXTeamTeamFolderCreateError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXTeamTeamFolderCreateError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXTeamTeamFolderMetadata?
            if let swift = result {
                objc = DBXTeamTeamFolderMetadata(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXTeamTeamFolderGetInfoRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<ArraySerializer<Team.TeamFolderGetInfoItemSerializer>, VoidSerializer>

    init(swift: RpcRequest<ArraySerializer<Team.TeamFolderGetInfoItemSerializer>, VoidSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping ([DBXTeamTeamFolderGetInfoItem]?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping ([DBXTeamTeamFolderGetInfoItem]?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var objc: [DBXTeamTeamFolderGetInfoItem]?
            if let swift = result {
                objc = swift.map { DBXTeamTeamFolderGetInfoItem.factory(swift: $0) }
            }
            completionHandler(objc, error?.objc)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXTeamTeamFolderListRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Team.TeamFolderListResultSerializer, Team.TeamFolderListErrorSerializer>

    init(swift: RpcRequest<Team.TeamFolderListResultSerializer, Team.TeamFolderListErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXTeamTeamFolderListResult?, DBXTeamTeamFolderListError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXTeamTeamFolderListResult?, DBXTeamTeamFolderListError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXTeamTeamFolderListError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXTeamTeamFolderListError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXTeamTeamFolderListResult?
            if let swift = result {
                objc = DBXTeamTeamFolderListResult(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXTeamTeamFolderListContinueRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Team.TeamFolderListResultSerializer, Team.TeamFolderListContinueErrorSerializer>

    init(swift: RpcRequest<Team.TeamFolderListResultSerializer, Team.TeamFolderListContinueErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXTeamTeamFolderListResult?, DBXTeamTeamFolderListContinueError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXTeamTeamFolderListResult?, DBXTeamTeamFolderListContinueError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXTeamTeamFolderListContinueError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXTeamTeamFolderListContinueError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXTeamTeamFolderListResult?
            if let swift = result {
                objc = DBXTeamTeamFolderListResult(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXTeamTeamFolderPermanentlyDeleteRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<VoidSerializer, Team.TeamFolderPermanentlyDeleteErrorSerializer>

    init(swift: RpcRequest<VoidSerializer, Team.TeamFolderPermanentlyDeleteErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXTeamTeamFolderPermanentlyDeleteError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXTeamTeamFolderPermanentlyDeleteError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { _, error in
            var routeError: DBXTeamTeamFolderPermanentlyDeleteError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXTeamTeamFolderPermanentlyDeleteError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            completionHandler(routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXTeamTeamFolderRenameRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Team.TeamFolderMetadataSerializer, Team.TeamFolderRenameErrorSerializer>

    init(swift: RpcRequest<Team.TeamFolderMetadataSerializer, Team.TeamFolderRenameErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXTeamTeamFolderMetadata?, DBXTeamTeamFolderRenameError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXTeamTeamFolderMetadata?, DBXTeamTeamFolderRenameError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXTeamTeamFolderRenameError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXTeamTeamFolderRenameError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXTeamTeamFolderMetadata?
            if let swift = result {
                objc = DBXTeamTeamFolderMetadata(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXTeamTeamFolderUpdateSyncSettingsRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Team.TeamFolderMetadataSerializer, Team.TeamFolderUpdateSyncSettingsErrorSerializer>

    init(swift: RpcRequest<Team.TeamFolderMetadataSerializer, Team.TeamFolderUpdateSyncSettingsErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXTeamTeamFolderMetadata?, DBXTeamTeamFolderUpdateSyncSettingsError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXTeamTeamFolderMetadata?, DBXTeamTeamFolderUpdateSyncSettingsError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXTeamTeamFolderUpdateSyncSettingsError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXTeamTeamFolderUpdateSyncSettingsError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXTeamTeamFolderMetadata?
            if let swift = result {
                objc = DBXTeamTeamFolderMetadata(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXTeamTokenGetAuthenticatedAdminRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Team.TokenGetAuthenticatedAdminResultSerializer, Team.TokenGetAuthenticatedAdminErrorSerializer>

    init(swift: RpcRequest<Team.TokenGetAuthenticatedAdminResultSerializer, Team.TokenGetAuthenticatedAdminErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXTeamTokenGetAuthenticatedAdminResult?, DBXTeamTokenGetAuthenticatedAdminError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXTeamTokenGetAuthenticatedAdminResult?, DBXTeamTokenGetAuthenticatedAdminError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXTeamTokenGetAuthenticatedAdminError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXTeamTokenGetAuthenticatedAdminError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXTeamTokenGetAuthenticatedAdminResult?
            if let swift = result {
                objc = DBXTeamTokenGetAuthenticatedAdminResult(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}
