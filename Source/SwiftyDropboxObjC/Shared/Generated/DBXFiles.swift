///
/// Copyright (c) 2022 Dropbox, Inc. All rights reserved.
///
/// Auto-generated by Stone, do not modify.
///

import Foundation
import SwiftyDropbox

/// Objective-C compatible datatypes for the files namespace
/// For Swift see files

/// Objective-C compatible AddTagArg struct
@objc
public class DBXFilesAddTagArg: NSObject {
    /// Path to the item to be tagged.
    @objc
    public var path: String { swift.path }
    /// The value of the tag to add. Will be automatically converted to lowercase letters.
    @objc
    public var tagText: String { swift.tagText }

    @objc
    public init(path: String, tagText: String) {
        self.swift = Files.AddTagArg(path: path, tagText: tagText)
    }

    let swift: Files.AddTagArg

    public init(swift: Files.AddTagArg) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible BaseTagError union
@objc
public class DBXFilesBaseTagError: NSObject {
    let swift: Files.BaseTagError

    public init(swift: Files.BaseTagError) {
        self.swift = swift
    }

    public static func factory(swift: Files.BaseTagError) -> DBXFilesBaseTagError {
        switch swift {
        case .path(let swiftArg):
            let arg = DBXFilesLookupError(swift: swiftArg)
            return DBXFilesBaseTagErrorPath(arg)
        case .other:
            return DBXFilesBaseTagErrorOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asPath: DBXFilesBaseTagErrorPath? {
        self as? DBXFilesBaseTagErrorPath
    }

    @objc
    public var asOther: DBXFilesBaseTagErrorOther? {
        self as? DBXFilesBaseTagErrorOther
    }
}

/// An unspecified error.
@objc
public class DBXFilesBaseTagErrorPath: DBXFilesBaseTagError {
    @objc
    public var path: DBXFilesLookupError

    @objc
    public init(_ arg: DBXFilesLookupError) {
        self.path = arg
        let swift = Files.BaseTagError.path(arg.swift)
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXFilesBaseTagErrorOther: DBXFilesBaseTagError {
    @objc
    public init() {
        let swift = Files.BaseTagError.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible AddTagError union
@objc
public class DBXFilesAddTagError: NSObject {
    let swift: Files.AddTagError

    public init(swift: Files.AddTagError) {
        self.swift = swift
    }

    public static func factory(swift: Files.AddTagError) -> DBXFilesAddTagError {
        switch swift {
        case .path(let swiftArg):
            let arg = DBXFilesLookupError(swift: swiftArg)
            return DBXFilesAddTagErrorPath(arg)
        case .other:
            return DBXFilesAddTagErrorOther()
        case .tooManyTags:
            return DBXFilesAddTagErrorTooManyTags()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asPath: DBXFilesAddTagErrorPath? {
        self as? DBXFilesAddTagErrorPath
    }

    @objc
    public var asOther: DBXFilesAddTagErrorOther? {
        self as? DBXFilesAddTagErrorOther
    }

    @objc
    public var asTooManyTags: DBXFilesAddTagErrorTooManyTags? {
        self as? DBXFilesAddTagErrorTooManyTags
    }
}

/// An unspecified error.
@objc
public class DBXFilesAddTagErrorPath: DBXFilesAddTagError {
    @objc
    public var path: DBXFilesLookupError

    @objc
    public init(_ arg: DBXFilesLookupError) {
        self.path = arg
        let swift = Files.AddTagError.path(arg.swift)
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXFilesAddTagErrorOther: DBXFilesAddTagError {
    @objc
    public init() {
        let swift = Files.AddTagError.other
        super.init(swift: swift)
    }
}

/// The item already has the maximum supported number of tags.
@objc
public class DBXFilesAddTagErrorTooManyTags: DBXFilesAddTagError {
    @objc
    public init() {
        let swift = Files.AddTagError.tooManyTags
        super.init(swift: swift)
    }
}

/// Objective-C compatible GetMetadataArg struct
@objc
public class DBXFilesGetMetadataArg: NSObject {
    /// The path of a file or folder on Dropbox.
    @objc
    public var path: String { swift.path }
    /// If true, mediaInfo in FileMetadata is set for photo and video.
    @objc
    public var includeMediaInfo: NSNumber { swift.includeMediaInfo as NSNumber }
    /// If true, DeletedMetadata will be returned for deleted file or folder, otherwise notFound in LookupError will
    /// be returned.
    @objc
    public var includeDeleted: NSNumber { swift.includeDeleted as NSNumber }
    /// If true, the results will include a flag for each file indicating whether or not  that file has any explicit
    /// members.
    @objc
    public var includeHasExplicitSharedMembers: NSNumber { swift.includeHasExplicitSharedMembers as NSNumber }
    /// If set to a valid list of template IDs, propertyGroups in FileMetadata is set if there exists property data
    /// associated with the file and each of the listed templates.
    @objc
    public var includePropertyGroups: DBXFilePropertiesTemplateFilterBase? { guard let swift = swift.includePropertyGroups else { return nil }
        return DBXFilePropertiesTemplateFilterBase(swift: swift)
    }

    @objc
    public init(
        path: String,
        includeMediaInfo: NSNumber,
        includeDeleted: NSNumber,
        includeHasExplicitSharedMembers: NSNumber,
        includePropertyGroups: DBXFilePropertiesTemplateFilterBase?
    ) {
        self.swift = Files.GetMetadataArg(
            path: path,
            includeMediaInfo: includeMediaInfo.boolValue,
            includeDeleted: includeDeleted.boolValue,
            includeHasExplicitSharedMembers: includeHasExplicitSharedMembers.boolValue,
            includePropertyGroups: includePropertyGroups?.swift
        )
    }

    let swift: Files.GetMetadataArg

    public init(swift: Files.GetMetadataArg) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible AlphaGetMetadataArg struct
@objc
public class DBXFilesAlphaGetMetadataArg: DBXFilesGetMetadataArg {
    /// If set to a valid list of template IDs, propertyGroups in FileMetadata is set for files with custom
    /// properties.
    @objc
    public var includePropertyTemplates: [String]? { subSwift.includePropertyTemplates }

    @objc
    public init(
        path: String,
        includeMediaInfo: NSNumber,
        includeDeleted: NSNumber,
        includeHasExplicitSharedMembers: NSNumber,
        includePropertyGroups: DBXFilePropertiesTemplateFilterBase?,
        includePropertyTemplates: [String]?
    ) {
        let swift = Files.AlphaGetMetadataArg(
            path: path,
            includeMediaInfo: includeMediaInfo.boolValue,
            includeDeleted: includeDeleted.boolValue,
            includeHasExplicitSharedMembers: includeHasExplicitSharedMembers.boolValue,
            includePropertyGroups: includePropertyGroups?.swift,
            includePropertyTemplates: includePropertyTemplates
        )
        self.subSwift = swift
        super.init(swift: swift)
    }

    let subSwift: Files.AlphaGetMetadataArg

    public init(swift: Files.AlphaGetMetadataArg) {
        self.subSwift = swift
        super.init(swift: swift)
    }

    @objc
    public override var description: String { subSwift.description }
}

/// Objective-C compatible GetMetadataError union
@objc
public class DBXFilesGetMetadataError: NSObject {
    let swift: Files.GetMetadataError

    public init(swift: Files.GetMetadataError) {
        self.swift = swift
    }

    public static func factory(swift: Files.GetMetadataError) -> DBXFilesGetMetadataError {
        switch swift {
        case .path(let swiftArg):
            let arg = DBXFilesLookupError(swift: swiftArg)
            return DBXFilesGetMetadataErrorPath(arg)
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asPath: DBXFilesGetMetadataErrorPath? {
        self as? DBXFilesGetMetadataErrorPath
    }
}

/// An unspecified error.
@objc
public class DBXFilesGetMetadataErrorPath: DBXFilesGetMetadataError {
    @objc
    public var path: DBXFilesLookupError

    @objc
    public init(_ arg: DBXFilesLookupError) {
        self.path = arg
        let swift = Files.GetMetadataError.path(arg.swift)
        super.init(swift: swift)
    }
}

/// Objective-C compatible AlphaGetMetadataError union
@objc
public class DBXFilesAlphaGetMetadataError: NSObject {
    let swift: Files.AlphaGetMetadataError

    public init(swift: Files.AlphaGetMetadataError) {
        self.swift = swift
    }

    public static func factory(swift: Files.AlphaGetMetadataError) -> DBXFilesAlphaGetMetadataError {
        switch swift {
        case .path(let swiftArg):
            let arg = DBXFilesLookupError(swift: swiftArg)
            return DBXFilesAlphaGetMetadataErrorPath(arg)
        case .propertiesError(let swiftArg):
            let arg = DBXFilePropertiesLookUpPropertiesError(swift: swiftArg)
            return DBXFilesAlphaGetMetadataErrorPropertiesError(arg)
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asPath: DBXFilesAlphaGetMetadataErrorPath? {
        self as? DBXFilesAlphaGetMetadataErrorPath
    }

    @objc
    public var asPropertiesError: DBXFilesAlphaGetMetadataErrorPropertiesError? {
        self as? DBXFilesAlphaGetMetadataErrorPropertiesError
    }
}

/// An unspecified error.
@objc
public class DBXFilesAlphaGetMetadataErrorPath: DBXFilesAlphaGetMetadataError {
    @objc
    public var path: DBXFilesLookupError

    @objc
    public init(_ arg: DBXFilesLookupError) {
        self.path = arg
        let swift = Files.AlphaGetMetadataError.path(arg.swift)
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXFilesAlphaGetMetadataErrorPropertiesError: DBXFilesAlphaGetMetadataError {
    @objc
    public var propertiesError: DBXFilePropertiesLookUpPropertiesError

    @objc
    public init(_ arg: DBXFilePropertiesLookUpPropertiesError) {
        self.propertiesError = arg
        let swift = Files.AlphaGetMetadataError.propertiesError(arg.swift)
        super.init(swift: swift)
    }
}

/// Objective-C compatible CommitInfo struct
@objc
public class DBXFilesCommitInfo: NSObject {
    /// Path in the user's Dropbox to save the file.
    @objc
    public var path: String { swift.path }
    /// Selects what to do if the file already exists.
    @objc
    public var mode: DBXFilesWriteMode { DBXFilesWriteMode(swift: swift.mode) }
    /// If there's a conflict, as determined by mode, have the Dropbox server try to autorename the file to avoid
    /// conflict.
    @objc
    public var autorename: NSNumber { swift.autorename as NSNumber }
    /// The value to store as the clientModified timestamp. Dropbox automatically records the time at which the file
    /// was written to the Dropbox servers. It can also record an additional timestamp, provided by Dropbox
    /// desktop clients, mobile clients, and API apps of when the file was actually created or modified.
    @objc
    public var clientModified: Date? { swift.clientModified }
    /// Normally, users are made aware of any file modifications in their Dropbox account via notifications in the
    /// client software. If true, this tells the clients that this modification shouldn't result in a user
    /// notification.
    @objc
    public var mute: NSNumber { swift.mute as NSNumber }
    /// List of custom properties to add to file.
    @objc
    public var propertyGroups: [DBXFilePropertiesPropertyGroup]? { swift.propertyGroups?.map { DBXFilePropertiesPropertyGroup(swift: $0) } }
    /// Be more strict about how each WriteMode detects conflict. For example, always return a conflict error when
    /// mode = update in WriteMode and the given "rev" doesn't match the existing file's "rev", even if the
    /// existing file has been deleted. This also forces a conflict even when the target path refers to a file
    /// with identical contents.
    @objc
    public var strictConflict: NSNumber { swift.strictConflict as NSNumber }

    @objc
    public init(
        path: String,
        mode: DBXFilesWriteMode,
        autorename: NSNumber,
        clientModified: Date?,
        mute: NSNumber,
        propertyGroups: [DBXFilePropertiesPropertyGroup]?,
        strictConflict: NSNumber
    ) {
        self.swift = Files.CommitInfo(
            path: path,
            mode: mode.swift,
            autorename: autorename.boolValue,
            clientModified: clientModified,
            mute: mute.boolValue,
            propertyGroups: propertyGroups?.map(\.swift),
            strictConflict: strictConflict.boolValue
        )
    }

    let swift: Files.CommitInfo

    public init(swift: Files.CommitInfo) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible ContentSyncSetting struct
@objc
public class DBXFilesContentSyncSetting: NSObject {
    /// Id of the item this setting is applied to.
    @objc
    public var id: String { swift.id }
    /// Setting for this item.
    @objc
    public var syncSetting: DBXFilesSyncSetting { DBXFilesSyncSetting(swift: swift.syncSetting) }

    @objc
    public init(id: String, syncSetting: DBXFilesSyncSetting) {
        self.swift = Files.ContentSyncSetting(id: id, syncSetting: syncSetting.swift)
    }

    let swift: Files.ContentSyncSetting

    public init(swift: Files.ContentSyncSetting) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible ContentSyncSettingArg struct
@objc
public class DBXFilesContentSyncSettingArg: NSObject {
    /// Id of the item this setting is applied to.
    @objc
    public var id: String { swift.id }
    /// Setting for this item.
    @objc
    public var syncSetting: DBXFilesSyncSettingArg { DBXFilesSyncSettingArg(swift: swift.syncSetting) }

    @objc
    public init(id: String, syncSetting: DBXFilesSyncSettingArg) {
        self.swift = Files.ContentSyncSettingArg(id: id, syncSetting: syncSetting.swift)
    }

    let swift: Files.ContentSyncSettingArg

    public init(swift: Files.ContentSyncSettingArg) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible CreateFolderArg struct
@objc
public class DBXFilesCreateFolderArg: NSObject {
    /// Path in the user's Dropbox to create.
    @objc
    public var path: String { swift.path }
    /// If there's a conflict, have the Dropbox server try to autorename the folder to avoid the conflict.
    @objc
    public var autorename: NSNumber { swift.autorename as NSNumber }

    @objc
    public init(path: String, autorename: NSNumber) {
        self.swift = Files.CreateFolderArg(path: path, autorename: autorename.boolValue)
    }

    let swift: Files.CreateFolderArg

    public init(swift: Files.CreateFolderArg) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible CreateFolderBatchArg struct
@objc
public class DBXFilesCreateFolderBatchArg: NSObject {
    /// List of paths to be created in the user's Dropbox. Duplicate path arguments in the batch are considered only
    /// once.
    @objc
    public var paths: [String] { swift.paths }
    /// If there's a conflict, have the Dropbox server try to autorename the folder to avoid the conflict.
    @objc
    public var autorename: NSNumber { swift.autorename as NSNumber }
    /// Whether to force the create to happen asynchronously.
    @objc
    public var forceAsync: NSNumber { swift.forceAsync as NSNumber }

    @objc
    public init(paths: [String], autorename: NSNumber, forceAsync: NSNumber) {
        self.swift = Files.CreateFolderBatchArg(paths: paths, autorename: autorename.boolValue, forceAsync: forceAsync.boolValue)
    }

    let swift: Files.CreateFolderBatchArg

    public init(swift: Files.CreateFolderBatchArg) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible CreateFolderBatchError union
@objc
public class DBXFilesCreateFolderBatchError: NSObject {
    let swift: Files.CreateFolderBatchError

    public init(swift: Files.CreateFolderBatchError) {
        self.swift = swift
    }

    public static func factory(swift: Files.CreateFolderBatchError) -> DBXFilesCreateFolderBatchError {
        switch swift {
        case .tooManyFiles:
            return DBXFilesCreateFolderBatchErrorTooManyFiles()
        case .other:
            return DBXFilesCreateFolderBatchErrorOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asTooManyFiles: DBXFilesCreateFolderBatchErrorTooManyFiles? {
        self as? DBXFilesCreateFolderBatchErrorTooManyFiles
    }

    @objc
    public var asOther: DBXFilesCreateFolderBatchErrorOther? {
        self as? DBXFilesCreateFolderBatchErrorOther
    }
}

/// The operation would involve too many files or folders.
@objc
public class DBXFilesCreateFolderBatchErrorTooManyFiles: DBXFilesCreateFolderBatchError {
    @objc
    public init() {
        let swift = Files.CreateFolderBatchError.tooManyFiles
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXFilesCreateFolderBatchErrorOther: DBXFilesCreateFolderBatchError {
    @objc
    public init() {
        let swift = Files.CreateFolderBatchError.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible CreateFolderBatchJobStatus union
@objc
public class DBXFilesCreateFolderBatchJobStatus: NSObject {
    let swift: Files.CreateFolderBatchJobStatus

    public init(swift: Files.CreateFolderBatchJobStatus) {
        self.swift = swift
    }

    public static func factory(swift: Files.CreateFolderBatchJobStatus) -> DBXFilesCreateFolderBatchJobStatus {
        switch swift {
        case .inProgress:
            return DBXFilesCreateFolderBatchJobStatusInProgress()
        case .complete(let swiftArg):
            let arg = DBXFilesCreateFolderBatchResult(swift: swiftArg)
            return DBXFilesCreateFolderBatchJobStatusComplete(arg)
        case .failed(let swiftArg):
            let arg = DBXFilesCreateFolderBatchError(swift: swiftArg)
            return DBXFilesCreateFolderBatchJobStatusFailed(arg)
        case .other:
            return DBXFilesCreateFolderBatchJobStatusOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asInProgress: DBXFilesCreateFolderBatchJobStatusInProgress? {
        self as? DBXFilesCreateFolderBatchJobStatusInProgress
    }

    @objc
    public var asComplete: DBXFilesCreateFolderBatchJobStatusComplete? {
        self as? DBXFilesCreateFolderBatchJobStatusComplete
    }

    @objc
    public var asFailed: DBXFilesCreateFolderBatchJobStatusFailed? {
        self as? DBXFilesCreateFolderBatchJobStatusFailed
    }

    @objc
    public var asOther: DBXFilesCreateFolderBatchJobStatusOther? {
        self as? DBXFilesCreateFolderBatchJobStatusOther
    }
}

/// The asynchronous job is still in progress.
@objc
public class DBXFilesCreateFolderBatchJobStatusInProgress: DBXFilesCreateFolderBatchJobStatus {
    @objc
    public init() {
        let swift = Files.CreateFolderBatchJobStatus.inProgress
        super.init(swift: swift)
    }
}

/// The batch create folder has finished.
@objc
public class DBXFilesCreateFolderBatchJobStatusComplete: DBXFilesCreateFolderBatchJobStatus {
    @objc
    public var complete: DBXFilesCreateFolderBatchResult

    @objc
    public init(_ arg: DBXFilesCreateFolderBatchResult) {
        self.complete = arg
        let swift = Files.CreateFolderBatchJobStatus.complete(arg.subSwift)
        super.init(swift: swift)
    }
}

/// The batch create folder has failed.
@objc
public class DBXFilesCreateFolderBatchJobStatusFailed: DBXFilesCreateFolderBatchJobStatus {
    @objc
    public var failed: DBXFilesCreateFolderBatchError

    @objc
    public init(_ arg: DBXFilesCreateFolderBatchError) {
        self.failed = arg
        let swift = Files.CreateFolderBatchJobStatus.failed(arg.swift)
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXFilesCreateFolderBatchJobStatusOther: DBXFilesCreateFolderBatchJobStatus {
    @objc
    public init() {
        let swift = Files.CreateFolderBatchJobStatus.other
        super.init(swift: swift)
    }
}

/// Result returned by createFolderBatch that may either launch an asynchronous job or complete synchronously.
@objc
public class DBXFilesCreateFolderBatchLaunch: NSObject {
    let swift: Files.CreateFolderBatchLaunch

    public init(swift: Files.CreateFolderBatchLaunch) {
        self.swift = swift
    }

    public static func factory(swift: Files.CreateFolderBatchLaunch) -> DBXFilesCreateFolderBatchLaunch {
        switch swift {
        case .asyncJobId(let swiftArg):
            let arg = swiftArg
            return DBXFilesCreateFolderBatchLaunchAsyncJobId(arg)
        case .complete(let swiftArg):
            let arg = DBXFilesCreateFolderBatchResult(swift: swiftArg)
            return DBXFilesCreateFolderBatchLaunchComplete(arg)
        case .other:
            return DBXFilesCreateFolderBatchLaunchOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asAsyncJobId: DBXFilesCreateFolderBatchLaunchAsyncJobId? {
        self as? DBXFilesCreateFolderBatchLaunchAsyncJobId
    }

    @objc
    public var asComplete: DBXFilesCreateFolderBatchLaunchComplete? {
        self as? DBXFilesCreateFolderBatchLaunchComplete
    }

    @objc
    public var asOther: DBXFilesCreateFolderBatchLaunchOther? {
        self as? DBXFilesCreateFolderBatchLaunchOther
    }
}

/// This response indicates that the processing is asynchronous. The string is an id that can be used to obtain
/// the status of the asynchronous job.
@objc
public class DBXFilesCreateFolderBatchLaunchAsyncJobId: DBXFilesCreateFolderBatchLaunch {
    @objc
    public var asyncJobId: String

    @objc
    public init(_ arg: String) {
        self.asyncJobId = arg
        let swift = Files.CreateFolderBatchLaunch.asyncJobId(arg)
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXFilesCreateFolderBatchLaunchComplete: DBXFilesCreateFolderBatchLaunch {
    @objc
    public var complete: DBXFilesCreateFolderBatchResult

    @objc
    public init(_ arg: DBXFilesCreateFolderBatchResult) {
        self.complete = arg
        let swift = Files.CreateFolderBatchLaunch.complete(arg.subSwift)
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXFilesCreateFolderBatchLaunchOther: DBXFilesCreateFolderBatchLaunch {
    @objc
    public init() {
        let swift = Files.CreateFolderBatchLaunch.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible FileOpsResult struct
@objc
public class DBXFilesFileOpsResult: NSObject {
    let swift: Files.FileOpsResult

    public init(swift: Files.FileOpsResult) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible CreateFolderBatchResult struct
@objc
public class DBXFilesCreateFolderBatchResult: DBXFilesFileOpsResult {
    /// Each entry in paths in CreateFolderBatchArg will appear at the same position inside entries in
    /// CreateFolderBatchResult.
    @objc
    public var entries: [DBXFilesCreateFolderBatchResultEntry] { subSwift.entries.map { DBXFilesCreateFolderBatchResultEntry(swift: $0) } }

    @objc
    public init(entries: [DBXFilesCreateFolderBatchResultEntry]) {
        let swift = Files.CreateFolderBatchResult(entries: entries.map(\.swift))
        self.subSwift = swift
        super.init(swift: swift)
    }

    let subSwift: Files.CreateFolderBatchResult

    public init(swift: Files.CreateFolderBatchResult) {
        self.subSwift = swift
        super.init(swift: swift)
    }

    @objc
    public override var description: String { subSwift.description }
}

/// Objective-C compatible CreateFolderBatchResultEntry union
@objc
public class DBXFilesCreateFolderBatchResultEntry: NSObject {
    let swift: Files.CreateFolderBatchResultEntry

    public init(swift: Files.CreateFolderBatchResultEntry) {
        self.swift = swift
    }

    public static func factory(swift: Files.CreateFolderBatchResultEntry) -> DBXFilesCreateFolderBatchResultEntry {
        switch swift {
        case .success(let swiftArg):
            let arg = DBXFilesCreateFolderEntryResult(swift: swiftArg)
            return DBXFilesCreateFolderBatchResultEntrySuccess(arg)
        case .failure(let swiftArg):
            let arg = DBXFilesCreateFolderEntryError(swift: swiftArg)
            return DBXFilesCreateFolderBatchResultEntryFailure(arg)
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asSuccess: DBXFilesCreateFolderBatchResultEntrySuccess? {
        self as? DBXFilesCreateFolderBatchResultEntrySuccess
    }

    @objc
    public var asFailure: DBXFilesCreateFolderBatchResultEntryFailure? {
        self as? DBXFilesCreateFolderBatchResultEntryFailure
    }
}

/// An unspecified error.
@objc
public class DBXFilesCreateFolderBatchResultEntrySuccess: DBXFilesCreateFolderBatchResultEntry {
    @objc
    public var success: DBXFilesCreateFolderEntryResult

    @objc
    public init(_ arg: DBXFilesCreateFolderEntryResult) {
        self.success = arg
        let swift = Files.CreateFolderBatchResultEntry.success(arg.swift)
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXFilesCreateFolderBatchResultEntryFailure: DBXFilesCreateFolderBatchResultEntry {
    @objc
    public var failure: DBXFilesCreateFolderEntryError

    @objc
    public init(_ arg: DBXFilesCreateFolderEntryError) {
        self.failure = arg
        let swift = Files.CreateFolderBatchResultEntry.failure(arg.swift)
        super.init(swift: swift)
    }
}

/// Objective-C compatible CreateFolderEntryError union
@objc
public class DBXFilesCreateFolderEntryError: NSObject {
    let swift: Files.CreateFolderEntryError

    public init(swift: Files.CreateFolderEntryError) {
        self.swift = swift
    }

    public static func factory(swift: Files.CreateFolderEntryError) -> DBXFilesCreateFolderEntryError {
        switch swift {
        case .path(let swiftArg):
            let arg = DBXFilesWriteError(swift: swiftArg)
            return DBXFilesCreateFolderEntryErrorPath(arg)
        case .other:
            return DBXFilesCreateFolderEntryErrorOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asPath: DBXFilesCreateFolderEntryErrorPath? {
        self as? DBXFilesCreateFolderEntryErrorPath
    }

    @objc
    public var asOther: DBXFilesCreateFolderEntryErrorOther? {
        self as? DBXFilesCreateFolderEntryErrorOther
    }
}

/// An unspecified error.
@objc
public class DBXFilesCreateFolderEntryErrorPath: DBXFilesCreateFolderEntryError {
    @objc
    public var path: DBXFilesWriteError

    @objc
    public init(_ arg: DBXFilesWriteError) {
        self.path = arg
        let swift = Files.CreateFolderEntryError.path(arg.swift)
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXFilesCreateFolderEntryErrorOther: DBXFilesCreateFolderEntryError {
    @objc
    public init() {
        let swift = Files.CreateFolderEntryError.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible CreateFolderEntryResult struct
@objc
public class DBXFilesCreateFolderEntryResult: NSObject {
    /// Metadata of the created folder.
    @objc
    public var metadata: DBXFilesFolderMetadata { DBXFilesFolderMetadata(swift: swift.metadata) }

    @objc
    public init(metadata: DBXFilesFolderMetadata) {
        self.swift = Files.CreateFolderEntryResult(metadata: metadata.subSwift)
    }

    let swift: Files.CreateFolderEntryResult

    public init(swift: Files.CreateFolderEntryResult) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible CreateFolderError union
@objc
public class DBXFilesCreateFolderError: NSObject {
    let swift: Files.CreateFolderError

    public init(swift: Files.CreateFolderError) {
        self.swift = swift
    }

    public static func factory(swift: Files.CreateFolderError) -> DBXFilesCreateFolderError {
        switch swift {
        case .path(let swiftArg):
            let arg = DBXFilesWriteError(swift: swiftArg)
            return DBXFilesCreateFolderErrorPath(arg)
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asPath: DBXFilesCreateFolderErrorPath? {
        self as? DBXFilesCreateFolderErrorPath
    }
}

/// An unspecified error.
@objc
public class DBXFilesCreateFolderErrorPath: DBXFilesCreateFolderError {
    @objc
    public var path: DBXFilesWriteError

    @objc
    public init(_ arg: DBXFilesWriteError) {
        self.path = arg
        let swift = Files.CreateFolderError.path(arg.swift)
        super.init(swift: swift)
    }
}

/// Objective-C compatible CreateFolderResult struct
@objc
public class DBXFilesCreateFolderResult: DBXFilesFileOpsResult {
    /// Metadata of the created folder.
    @objc
    public var metadata: DBXFilesFolderMetadata { DBXFilesFolderMetadata(swift: subSwift.metadata) }

    @objc
    public init(metadata: DBXFilesFolderMetadata) {
        let swift = Files.CreateFolderResult(metadata: metadata.subSwift)
        self.subSwift = swift
        super.init(swift: swift)
    }

    let subSwift: Files.CreateFolderResult

    public init(swift: Files.CreateFolderResult) {
        self.subSwift = swift
        super.init(swift: swift)
    }

    @objc
    public override var description: String { subSwift.description }
}

/// Objective-C compatible DeleteArg struct
@objc
public class DBXFilesDeleteArg: NSObject {
    /// Path in the user's Dropbox to delete.
    @objc
    public var path: String { swift.path }
    /// Perform delete if given "rev" matches the existing file's latest "rev". This field does not support deleting
    /// a folder.
    @objc
    public var parentRev: String? { swift.parentRev }

    @objc
    public init(path: String, parentRev: String?) {
        self.swift = Files.DeleteArg(path: path, parentRev: parentRev)
    }

    let swift: Files.DeleteArg

    public init(swift: Files.DeleteArg) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible DeleteBatchArg struct
@objc
public class DBXFilesDeleteBatchArg: NSObject {
    /// (no description)
    @objc
    public var entries: [DBXFilesDeleteArg] { swift.entries.map { DBXFilesDeleteArg(swift: $0) } }

    @objc
    public init(entries: [DBXFilesDeleteArg]) {
        self.swift = Files.DeleteBatchArg(entries: entries.map(\.swift))
    }

    let swift: Files.DeleteBatchArg

    public init(swift: Files.DeleteBatchArg) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible DeleteBatchError union
@objc
public class DBXFilesDeleteBatchError: NSObject {
    let swift: Files.DeleteBatchError

    public init(swift: Files.DeleteBatchError) {
        self.swift = swift
    }

    public static func factory(swift: Files.DeleteBatchError) -> DBXFilesDeleteBatchError {
        switch swift {
        case .tooManyWriteOperations:
            return DBXFilesDeleteBatchErrorTooManyWriteOperations()
        case .other:
            return DBXFilesDeleteBatchErrorOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asTooManyWriteOperations: DBXFilesDeleteBatchErrorTooManyWriteOperations? {
        self as? DBXFilesDeleteBatchErrorTooManyWriteOperations
    }

    @objc
    public var asOther: DBXFilesDeleteBatchErrorOther? {
        self as? DBXFilesDeleteBatchErrorOther
    }
}

/// Use tooManyWriteOperations in DeleteError. deleteBatch now provides smaller granularity about which entry
/// has failed because of this.
@objc
public class DBXFilesDeleteBatchErrorTooManyWriteOperations: DBXFilesDeleteBatchError {
    @objc
    public init() {
        let swift = Files.DeleteBatchError.tooManyWriteOperations
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXFilesDeleteBatchErrorOther: DBXFilesDeleteBatchError {
    @objc
    public init() {
        let swift = Files.DeleteBatchError.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible DeleteBatchJobStatus union
@objc
public class DBXFilesDeleteBatchJobStatus: NSObject {
    let swift: Files.DeleteBatchJobStatus

    public init(swift: Files.DeleteBatchJobStatus) {
        self.swift = swift
    }

    public static func factory(swift: Files.DeleteBatchJobStatus) -> DBXFilesDeleteBatchJobStatus {
        switch swift {
        case .inProgress:
            return DBXFilesDeleteBatchJobStatusInProgress()
        case .complete(let swiftArg):
            let arg = DBXFilesDeleteBatchResult(swift: swiftArg)
            return DBXFilesDeleteBatchJobStatusComplete(arg)
        case .failed(let swiftArg):
            let arg = DBXFilesDeleteBatchError(swift: swiftArg)
            return DBXFilesDeleteBatchJobStatusFailed(arg)
        case .other:
            return DBXFilesDeleteBatchJobStatusOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asInProgress: DBXFilesDeleteBatchJobStatusInProgress? {
        self as? DBXFilesDeleteBatchJobStatusInProgress
    }

    @objc
    public var asComplete: DBXFilesDeleteBatchJobStatusComplete? {
        self as? DBXFilesDeleteBatchJobStatusComplete
    }

    @objc
    public var asFailed: DBXFilesDeleteBatchJobStatusFailed? {
        self as? DBXFilesDeleteBatchJobStatusFailed
    }

    @objc
    public var asOther: DBXFilesDeleteBatchJobStatusOther? {
        self as? DBXFilesDeleteBatchJobStatusOther
    }
}

/// The asynchronous job is still in progress.
@objc
public class DBXFilesDeleteBatchJobStatusInProgress: DBXFilesDeleteBatchJobStatus {
    @objc
    public init() {
        let swift = Files.DeleteBatchJobStatus.inProgress
        super.init(swift: swift)
    }
}

/// The batch delete has finished.
@objc
public class DBXFilesDeleteBatchJobStatusComplete: DBXFilesDeleteBatchJobStatus {
    @objc
    public var complete: DBXFilesDeleteBatchResult

    @objc
    public init(_ arg: DBXFilesDeleteBatchResult) {
        self.complete = arg
        let swift = Files.DeleteBatchJobStatus.complete(arg.subSwift)
        super.init(swift: swift)
    }
}

/// The batch delete has failed.
@objc
public class DBXFilesDeleteBatchJobStatusFailed: DBXFilesDeleteBatchJobStatus {
    @objc
    public var failed: DBXFilesDeleteBatchError

    @objc
    public init(_ arg: DBXFilesDeleteBatchError) {
        self.failed = arg
        let swift = Files.DeleteBatchJobStatus.failed(arg.swift)
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXFilesDeleteBatchJobStatusOther: DBXFilesDeleteBatchJobStatus {
    @objc
    public init() {
        let swift = Files.DeleteBatchJobStatus.other
        super.init(swift: swift)
    }
}

/// Result returned by deleteBatch that may either launch an asynchronous job or complete synchronously.
@objc
public class DBXFilesDeleteBatchLaunch: NSObject {
    let swift: Files.DeleteBatchLaunch

    public init(swift: Files.DeleteBatchLaunch) {
        self.swift = swift
    }

    public static func factory(swift: Files.DeleteBatchLaunch) -> DBXFilesDeleteBatchLaunch {
        switch swift {
        case .asyncJobId(let swiftArg):
            let arg = swiftArg
            return DBXFilesDeleteBatchLaunchAsyncJobId(arg)
        case .complete(let swiftArg):
            let arg = DBXFilesDeleteBatchResult(swift: swiftArg)
            return DBXFilesDeleteBatchLaunchComplete(arg)
        case .other:
            return DBXFilesDeleteBatchLaunchOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asAsyncJobId: DBXFilesDeleteBatchLaunchAsyncJobId? {
        self as? DBXFilesDeleteBatchLaunchAsyncJobId
    }

    @objc
    public var asComplete: DBXFilesDeleteBatchLaunchComplete? {
        self as? DBXFilesDeleteBatchLaunchComplete
    }

    @objc
    public var asOther: DBXFilesDeleteBatchLaunchOther? {
        self as? DBXFilesDeleteBatchLaunchOther
    }
}

/// This response indicates that the processing is asynchronous. The string is an id that can be used to obtain
/// the status of the asynchronous job.
@objc
public class DBXFilesDeleteBatchLaunchAsyncJobId: DBXFilesDeleteBatchLaunch {
    @objc
    public var asyncJobId: String

    @objc
    public init(_ arg: String) {
        self.asyncJobId = arg
        let swift = Files.DeleteBatchLaunch.asyncJobId(arg)
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXFilesDeleteBatchLaunchComplete: DBXFilesDeleteBatchLaunch {
    @objc
    public var complete: DBXFilesDeleteBatchResult

    @objc
    public init(_ arg: DBXFilesDeleteBatchResult) {
        self.complete = arg
        let swift = Files.DeleteBatchLaunch.complete(arg.subSwift)
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXFilesDeleteBatchLaunchOther: DBXFilesDeleteBatchLaunch {
    @objc
    public init() {
        let swift = Files.DeleteBatchLaunch.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible DeleteBatchResult struct
@objc
public class DBXFilesDeleteBatchResult: DBXFilesFileOpsResult {
    /// Each entry in entries in DeleteBatchArg will appear at the same position inside entries in
    /// DeleteBatchResult.
    @objc
    public var entries: [DBXFilesDeleteBatchResultEntry] { subSwift.entries.map { DBXFilesDeleteBatchResultEntry(swift: $0) } }

    @objc
    public init(entries: [DBXFilesDeleteBatchResultEntry]) {
        let swift = Files.DeleteBatchResult(entries: entries.map(\.swift))
        self.subSwift = swift
        super.init(swift: swift)
    }

    let subSwift: Files.DeleteBatchResult

    public init(swift: Files.DeleteBatchResult) {
        self.subSwift = swift
        super.init(swift: swift)
    }

    @objc
    public override var description: String { subSwift.description }
}

/// Objective-C compatible DeleteBatchResultData struct
@objc
public class DBXFilesDeleteBatchResultData: NSObject {
    /// Metadata of the deleted object.
    @objc
    public var metadata: DBXFilesMetadata {
        DBXFilesMetadata.wrapPreservingSubtypes(swift: swift.metadata)
    }

    @objc
    public init(metadata: DBXFilesMetadata) {
        self.swift = Files.DeleteBatchResultData(metadata: metadata.swift)
    }

    let swift: Files.DeleteBatchResultData

    public init(swift: Files.DeleteBatchResultData) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible DeleteBatchResultEntry union
@objc
public class DBXFilesDeleteBatchResultEntry: NSObject {
    let swift: Files.DeleteBatchResultEntry

    public init(swift: Files.DeleteBatchResultEntry) {
        self.swift = swift
    }

    public static func factory(swift: Files.DeleteBatchResultEntry) -> DBXFilesDeleteBatchResultEntry {
        switch swift {
        case .success(let swiftArg):
            let arg = DBXFilesDeleteBatchResultData(swift: swiftArg)
            return DBXFilesDeleteBatchResultEntrySuccess(arg)
        case .failure(let swiftArg):
            let arg = DBXFilesDeleteError(swift: swiftArg)
            return DBXFilesDeleteBatchResultEntryFailure(arg)
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asSuccess: DBXFilesDeleteBatchResultEntrySuccess? {
        self as? DBXFilesDeleteBatchResultEntrySuccess
    }

    @objc
    public var asFailure: DBXFilesDeleteBatchResultEntryFailure? {
        self as? DBXFilesDeleteBatchResultEntryFailure
    }
}

/// An unspecified error.
@objc
public class DBXFilesDeleteBatchResultEntrySuccess: DBXFilesDeleteBatchResultEntry {
    @objc
    public var success: DBXFilesDeleteBatchResultData

    @objc
    public init(_ arg: DBXFilesDeleteBatchResultData) {
        self.success = arg
        let swift = Files.DeleteBatchResultEntry.success(arg.swift)
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXFilesDeleteBatchResultEntryFailure: DBXFilesDeleteBatchResultEntry {
    @objc
    public var failure: DBXFilesDeleteError

    @objc
    public init(_ arg: DBXFilesDeleteError) {
        self.failure = arg
        let swift = Files.DeleteBatchResultEntry.failure(arg.swift)
        super.init(swift: swift)
    }
}

/// Objective-C compatible DeleteError union
@objc
public class DBXFilesDeleteError: NSObject {
    let swift: Files.DeleteError

    public init(swift: Files.DeleteError) {
        self.swift = swift
    }

    public static func factory(swift: Files.DeleteError) -> DBXFilesDeleteError {
        switch swift {
        case .pathLookup(let swiftArg):
            let arg = DBXFilesLookupError(swift: swiftArg)
            return DBXFilesDeleteErrorPathLookup(arg)
        case .pathWrite(let swiftArg):
            let arg = DBXFilesWriteError(swift: swiftArg)
            return DBXFilesDeleteErrorPathWrite(arg)
        case .tooManyWriteOperations:
            return DBXFilesDeleteErrorTooManyWriteOperations()
        case .tooManyFiles:
            return DBXFilesDeleteErrorTooManyFiles()
        case .other:
            return DBXFilesDeleteErrorOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asPathLookup: DBXFilesDeleteErrorPathLookup? {
        self as? DBXFilesDeleteErrorPathLookup
    }

    @objc
    public var asPathWrite: DBXFilesDeleteErrorPathWrite? {
        self as? DBXFilesDeleteErrorPathWrite
    }

    @objc
    public var asTooManyWriteOperations: DBXFilesDeleteErrorTooManyWriteOperations? {
        self as? DBXFilesDeleteErrorTooManyWriteOperations
    }

    @objc
    public var asTooManyFiles: DBXFilesDeleteErrorTooManyFiles? {
        self as? DBXFilesDeleteErrorTooManyFiles
    }

    @objc
    public var asOther: DBXFilesDeleteErrorOther? {
        self as? DBXFilesDeleteErrorOther
    }
}

/// An unspecified error.
@objc
public class DBXFilesDeleteErrorPathLookup: DBXFilesDeleteError {
    @objc
    public var pathLookup: DBXFilesLookupError

    @objc
    public init(_ arg: DBXFilesLookupError) {
        self.pathLookup = arg
        let swift = Files.DeleteError.pathLookup(arg.swift)
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXFilesDeleteErrorPathWrite: DBXFilesDeleteError {
    @objc
    public var pathWrite: DBXFilesWriteError

    @objc
    public init(_ arg: DBXFilesWriteError) {
        self.pathWrite = arg
        let swift = Files.DeleteError.pathWrite(arg.swift)
        super.init(swift: swift)
    }
}

/// There are too many write operations in user's Dropbox. Please retry this request.
@objc
public class DBXFilesDeleteErrorTooManyWriteOperations: DBXFilesDeleteError {
    @objc
    public init() {
        let swift = Files.DeleteError.tooManyWriteOperations
        super.init(swift: swift)
    }
}

/// There are too many files in one request. Please retry with fewer files.
@objc
public class DBXFilesDeleteErrorTooManyFiles: DBXFilesDeleteError {
    @objc
    public init() {
        let swift = Files.DeleteError.tooManyFiles
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXFilesDeleteErrorOther: DBXFilesDeleteError {
    @objc
    public init() {
        let swift = Files.DeleteError.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible DeleteResult struct
@objc
public class DBXFilesDeleteResult: DBXFilesFileOpsResult {
    /// Metadata of the deleted object.
    @objc
    public var metadata: DBXFilesMetadata {
        DBXFilesMetadata.wrapPreservingSubtypes(swift: subSwift.metadata)
    }

    @objc
    public init(metadata: DBXFilesMetadata) {
        let swift = Files.DeleteResult(metadata: metadata.swift)
        self.subSwift = swift
        super.init(swift: swift)
    }

    let subSwift: Files.DeleteResult

    public init(swift: Files.DeleteResult) {
        self.subSwift = swift
        super.init(swift: swift)
    }

    @objc
    public override var description: String { subSwift.description }
}

/// Metadata for a file or folder.
@objc
public class DBXFilesMetadata: NSObject {
    /// The last component of the path (including extension). This never contains a slash.
    @objc
    public var name: String { swift.name }
    /// The lowercased full path in the user's Dropbox. This always starts with a slash. This field will be null if
    /// the file or folder is not mounted.
    @objc
    public var pathLower: String? { swift.pathLower }
    /// The cased path to be used for display purposes only. In rare instances the casing will not correctly match
    /// the user's filesystem, but this behavior will match the path provided in the Core API v1, and at least
    /// the last path component will have the correct casing. Changes to only the casing of paths won't be
    /// returned by listFolderContinue. This field will be null if the file or folder is not mounted.
    @objc
    public var pathDisplay: String? { swift.pathDisplay }
    /// Please use parentSharedFolderId in FileSharingInfo or parentSharedFolderId in FolderSharingInfo instead.
    @objc
    public var parentSharedFolderId: String? { swift.parentSharedFolderId }
    /// The preview URL of the file.
    @objc
    public var previewUrl: String? { swift.previewUrl }

    @objc
    public init(name: String, pathLower: String?, pathDisplay: String?, parentSharedFolderId: String?, previewUrl: String?) {
        self.swift = Files.Metadata(
            name: name,
            pathLower: pathLower,
            pathDisplay: pathDisplay,
            parentSharedFolderId: parentSharedFolderId,
            previewUrl: previewUrl
        )
    }

    let swift: Files.Metadata

    public init(swift: Files.Metadata) {
        self.swift = swift
    }

    public static func wrapPreservingSubtypes(swift: Files.Metadata) -> DBXFilesMetadata {
        switch swift {
        case let fileMetadata as Files.FileMetadata:
            return DBXFilesFileMetadata(swift: fileMetadata)
        case let folderMetadata as Files.FolderMetadata:
            return DBXFilesFolderMetadata(swift: folderMetadata)
        case let deletedMetadata as Files.DeletedMetadata:
            return DBXFilesDeletedMetadata(swift: deletedMetadata)
        default:
            return DBXFilesMetadata(swift: swift)
        }
    }

    @objc
    public override var description: String { swift.description }
}

/// Indicates that there used to be a file or folder at this path, but it no longer exists.
@objc
public class DBXFilesDeletedMetadata: DBXFilesMetadata {
    let subSwift: Files.DeletedMetadata

    public init(swift: Files.DeletedMetadata) {
        self.subSwift = swift
        super.init(swift: swift)
    }

    @objc
    public override var description: String { subSwift.description }
}

/// Dimensions for a photo or video.
@objc
public class DBXFilesDimensions: NSObject {
    /// Height of the photo/video.
    @objc
    public var height: NSNumber { swift.height as NSNumber }
    /// Width of the photo/video.
    @objc
    public var width: NSNumber { swift.width as NSNumber }

    @objc
    public init(height: NSNumber, width: NSNumber) {
        self.swift = Files.Dimensions(height: height.uint64Value, width: width.uint64Value)
    }

    let swift: Files.Dimensions

    public init(swift: Files.Dimensions) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible DownloadArg struct
@objc
public class DBXFilesDownloadArg: NSObject {
    /// The path of the file to download.
    @objc
    public var path: String { swift.path }
    /// Please specify revision in path instead.
    @objc
    public var rev: String? { swift.rev }

    @objc
    public init(path: String, rev: String?) {
        self.swift = Files.DownloadArg(path: path, rev: rev)
    }

    let swift: Files.DownloadArg

    public init(swift: Files.DownloadArg) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible DownloadError union
@objc
public class DBXFilesDownloadError: NSObject {
    let swift: Files.DownloadError

    public init(swift: Files.DownloadError) {
        self.swift = swift
    }

    public static func factory(swift: Files.DownloadError) -> DBXFilesDownloadError {
        switch swift {
        case .path(let swiftArg):
            let arg = DBXFilesLookupError(swift: swiftArg)
            return DBXFilesDownloadErrorPath(arg)
        case .unsupportedFile:
            return DBXFilesDownloadErrorUnsupportedFile()
        case .other:
            return DBXFilesDownloadErrorOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asPath: DBXFilesDownloadErrorPath? {
        self as? DBXFilesDownloadErrorPath
    }

    @objc
    public var asUnsupportedFile: DBXFilesDownloadErrorUnsupportedFile? {
        self as? DBXFilesDownloadErrorUnsupportedFile
    }

    @objc
    public var asOther: DBXFilesDownloadErrorOther? {
        self as? DBXFilesDownloadErrorOther
    }
}

/// An unspecified error.
@objc
public class DBXFilesDownloadErrorPath: DBXFilesDownloadError {
    @objc
    public var path: DBXFilesLookupError

    @objc
    public init(_ arg: DBXFilesLookupError) {
        self.path = arg
        let swift = Files.DownloadError.path(arg.swift)
        super.init(swift: swift)
    }
}

/// This file type cannot be downloaded directly; use export instead.
@objc
public class DBXFilesDownloadErrorUnsupportedFile: DBXFilesDownloadError {
    @objc
    public init() {
        let swift = Files.DownloadError.unsupportedFile
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXFilesDownloadErrorOther: DBXFilesDownloadError {
    @objc
    public init() {
        let swift = Files.DownloadError.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible DownloadZipArg struct
@objc
public class DBXFilesDownloadZipArg: NSObject {
    /// The path of the folder to download.
    @objc
    public var path: String { swift.path }

    @objc
    public init(path: String) {
        self.swift = Files.DownloadZipArg(path: path)
    }

    let swift: Files.DownloadZipArg

    public init(swift: Files.DownloadZipArg) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible DownloadZipError union
@objc
public class DBXFilesDownloadZipError: NSObject {
    let swift: Files.DownloadZipError

    public init(swift: Files.DownloadZipError) {
        self.swift = swift
    }

    public static func factory(swift: Files.DownloadZipError) -> DBXFilesDownloadZipError {
        switch swift {
        case .path(let swiftArg):
            let arg = DBXFilesLookupError(swift: swiftArg)
            return DBXFilesDownloadZipErrorPath(arg)
        case .tooLarge:
            return DBXFilesDownloadZipErrorTooLarge()
        case .tooManyFiles:
            return DBXFilesDownloadZipErrorTooManyFiles()
        case .other:
            return DBXFilesDownloadZipErrorOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asPath: DBXFilesDownloadZipErrorPath? {
        self as? DBXFilesDownloadZipErrorPath
    }

    @objc
    public var asTooLarge: DBXFilesDownloadZipErrorTooLarge? {
        self as? DBXFilesDownloadZipErrorTooLarge
    }

    @objc
    public var asTooManyFiles: DBXFilesDownloadZipErrorTooManyFiles? {
        self as? DBXFilesDownloadZipErrorTooManyFiles
    }

    @objc
    public var asOther: DBXFilesDownloadZipErrorOther? {
        self as? DBXFilesDownloadZipErrorOther
    }
}

/// An unspecified error.
@objc
public class DBXFilesDownloadZipErrorPath: DBXFilesDownloadZipError {
    @objc
    public var path: DBXFilesLookupError

    @objc
    public init(_ arg: DBXFilesLookupError) {
        self.path = arg
        let swift = Files.DownloadZipError.path(arg.swift)
        super.init(swift: swift)
    }
}

/// The folder or a file is too large to download.
@objc
public class DBXFilesDownloadZipErrorTooLarge: DBXFilesDownloadZipError {
    @objc
    public init() {
        let swift = Files.DownloadZipError.tooLarge
        super.init(swift: swift)
    }
}

/// The folder has too many files to download.
@objc
public class DBXFilesDownloadZipErrorTooManyFiles: DBXFilesDownloadZipError {
    @objc
    public init() {
        let swift = Files.DownloadZipError.tooManyFiles
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXFilesDownloadZipErrorOther: DBXFilesDownloadZipError {
    @objc
    public init() {
        let swift = Files.DownloadZipError.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible DownloadZipResult struct
@objc
public class DBXFilesDownloadZipResult: NSObject {
    /// (no description)
    @objc
    public var metadata: DBXFilesFolderMetadata { DBXFilesFolderMetadata(swift: swift.metadata) }

    @objc
    public init(metadata: DBXFilesFolderMetadata) {
        self.swift = Files.DownloadZipResult(metadata: metadata.subSwift)
    }

    let swift: Files.DownloadZipResult

    public init(swift: Files.DownloadZipResult) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible ExportArg struct
@objc
public class DBXFilesExportArg: NSObject {
    /// The path of the file to be exported.
    @objc
    public var path: String { swift.path }
    /// The file format to which the file should be exported. This must be one of the formats listed in the file's
    /// export_options returned by getMetadata. If none is specified, the default format (specified in export_as
    /// in file metadata) will be used.
    @objc
    public var exportFormat: String? { swift.exportFormat }

    @objc
    public init(path: String, exportFormat: String?) {
        self.swift = Files.ExportArg(path: path, exportFormat: exportFormat)
    }

    let swift: Files.ExportArg

    public init(swift: Files.ExportArg) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible ExportError union
@objc
public class DBXFilesExportError: NSObject {
    let swift: Files.ExportError

    public init(swift: Files.ExportError) {
        self.swift = swift
    }

    public static func factory(swift: Files.ExportError) -> DBXFilesExportError {
        switch swift {
        case .path(let swiftArg):
            let arg = DBXFilesLookupError(swift: swiftArg)
            return DBXFilesExportErrorPath(arg)
        case .nonExportable:
            return DBXFilesExportErrorNonExportable()
        case .invalidExportFormat:
            return DBXFilesExportErrorInvalidExportFormat()
        case .retryError:
            return DBXFilesExportErrorRetryError()
        case .other:
            return DBXFilesExportErrorOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asPath: DBXFilesExportErrorPath? {
        self as? DBXFilesExportErrorPath
    }

    @objc
    public var asNonExportable: DBXFilesExportErrorNonExportable? {
        self as? DBXFilesExportErrorNonExportable
    }

    @objc
    public var asInvalidExportFormat: DBXFilesExportErrorInvalidExportFormat? {
        self as? DBXFilesExportErrorInvalidExportFormat
    }

    @objc
    public var asRetryError: DBXFilesExportErrorRetryError? {
        self as? DBXFilesExportErrorRetryError
    }

    @objc
    public var asOther: DBXFilesExportErrorOther? {
        self as? DBXFilesExportErrorOther
    }
}

/// An unspecified error.
@objc
public class DBXFilesExportErrorPath: DBXFilesExportError {
    @objc
    public var path: DBXFilesLookupError

    @objc
    public init(_ arg: DBXFilesLookupError) {
        self.path = arg
        let swift = Files.ExportError.path(arg.swift)
        super.init(swift: swift)
    }
}

/// This file type cannot be exported. Use download instead.
@objc
public class DBXFilesExportErrorNonExportable: DBXFilesExportError {
    @objc
    public init() {
        let swift = Files.ExportError.nonExportable
        super.init(swift: swift)
    }
}

/// The specified export format is not a valid option for this file type.
@objc
public class DBXFilesExportErrorInvalidExportFormat: DBXFilesExportError {
    @objc
    public init() {
        let swift = Files.ExportError.invalidExportFormat
        super.init(swift: swift)
    }
}

/// The exportable content is not yet available. Please retry later.
@objc
public class DBXFilesExportErrorRetryError: DBXFilesExportError {
    @objc
    public init() {
        let swift = Files.ExportError.retryError
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXFilesExportErrorOther: DBXFilesExportError {
    @objc
    public init() {
        let swift = Files.ExportError.other
        super.init(swift: swift)
    }
}

/// Export information for a file.
@objc
public class DBXFilesExportInfo: NSObject {
    /// Format to which the file can be exported to.
    @objc
    public var exportAs: String? { swift.exportAs }
    /// Additional formats to which the file can be exported. These values can be specified as the export_format in
    /// /files/export.
    @objc
    public var exportOptions: [String]? { swift.exportOptions }

    @objc
    public init(exportAs: String?, exportOptions: [String]?) {
        self.swift = Files.ExportInfo(exportAs: exportAs, exportOptions: exportOptions)
    }

    let swift: Files.ExportInfo

    public init(swift: Files.ExportInfo) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible ExportMetadata struct
@objc
public class DBXFilesExportMetadata: NSObject {
    /// The last component of the path (including extension). This never contains a slash.
    @objc
    public var name: String { swift.name }
    /// The file size in bytes.
    @objc
    public var size: NSNumber { swift.size as NSNumber }
    /// A hash based on the exported file content. This field can be used to verify data integrity. Similar to
    /// content hash. For more information see our Content hash
    /// https://www.dropbox.com/developers/reference/content-hash page.
    @objc
    public var exportHash: String? { swift.exportHash }
    /// If the file is a Paper doc, this gives the latest doc revision which can be used in paperUpdate.
    @objc
    public var paperRevision: NSNumber? { swift.paperRevision as NSNumber? }

    @objc
    public init(name: String, size: NSNumber, exportHash: String?, paperRevision: NSNumber?) {
        self.swift = Files.ExportMetadata(name: name, size: size.uint64Value, exportHash: exportHash, paperRevision: paperRevision?.int64Value)
    }

    let swift: Files.ExportMetadata

    public init(swift: Files.ExportMetadata) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible ExportResult struct
@objc
public class DBXFilesExportResult: NSObject {
    /// Metadata for the exported version of the file.
    @objc
    public var exportMetadata: DBXFilesExportMetadata { DBXFilesExportMetadata(swift: swift.exportMetadata) }
    /// Metadata for the original file.
    @objc
    public var fileMetadata: DBXFilesFileMetadata { DBXFilesFileMetadata(swift: swift.fileMetadata) }

    @objc
    public init(exportMetadata: DBXFilesExportMetadata, fileMetadata: DBXFilesFileMetadata) {
        self.swift = Files.ExportResult(exportMetadata: exportMetadata.swift, fileMetadata: fileMetadata.subSwift)
    }

    let swift: Files.ExportResult

    public init(swift: Files.ExportResult) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible FileCategory union
@objc
public class DBXFilesFileCategory: NSObject {
    let swift: Files.FileCategory

    public init(swift: Files.FileCategory) {
        self.swift = swift
    }

    public static func factory(swift: Files.FileCategory) -> DBXFilesFileCategory {
        switch swift {
        case .image:
            return DBXFilesFileCategoryImage()
        case .document:
            return DBXFilesFileCategoryDocument()
        case .pdf:
            return DBXFilesFileCategoryPdf()
        case .spreadsheet:
            return DBXFilesFileCategorySpreadsheet()
        case .presentation:
            return DBXFilesFileCategoryPresentation()
        case .audio:
            return DBXFilesFileCategoryAudio()
        case .video:
            return DBXFilesFileCategoryVideo()
        case .folder:
            return DBXFilesFileCategoryFolder()
        case .paper:
            return DBXFilesFileCategoryPaper()
        case .others:
            return DBXFilesFileCategoryOthers()
        case .other:
            return DBXFilesFileCategoryOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asImage: DBXFilesFileCategoryImage? {
        self as? DBXFilesFileCategoryImage
    }

    @objc
    public var asDocument: DBXFilesFileCategoryDocument? {
        self as? DBXFilesFileCategoryDocument
    }

    @objc
    public var asPdf: DBXFilesFileCategoryPdf? {
        self as? DBXFilesFileCategoryPdf
    }

    @objc
    public var asSpreadsheet: DBXFilesFileCategorySpreadsheet? {
        self as? DBXFilesFileCategorySpreadsheet
    }

    @objc
    public var asPresentation: DBXFilesFileCategoryPresentation? {
        self as? DBXFilesFileCategoryPresentation
    }

    @objc
    public var asAudio: DBXFilesFileCategoryAudio? {
        self as? DBXFilesFileCategoryAudio
    }

    @objc
    public var asVideo: DBXFilesFileCategoryVideo? {
        self as? DBXFilesFileCategoryVideo
    }

    @objc
    public var asFolder: DBXFilesFileCategoryFolder? {
        self as? DBXFilesFileCategoryFolder
    }

    @objc
    public var asPaper: DBXFilesFileCategoryPaper? {
        self as? DBXFilesFileCategoryPaper
    }

    @objc
    public var asOthers: DBXFilesFileCategoryOthers? {
        self as? DBXFilesFileCategoryOthers
    }

    @objc
    public var asOther: DBXFilesFileCategoryOther? {
        self as? DBXFilesFileCategoryOther
    }
}

/// jpg, png, gif, and more.
@objc
public class DBXFilesFileCategoryImage: DBXFilesFileCategory {
    @objc
    public init() {
        let swift = Files.FileCategory.image
        super.init(swift: swift)
    }
}

/// doc, docx, txt, and more.
@objc
public class DBXFilesFileCategoryDocument: DBXFilesFileCategory {
    @objc
    public init() {
        let swift = Files.FileCategory.document
        super.init(swift: swift)
    }
}

/// pdf.
@objc
public class DBXFilesFileCategoryPdf: DBXFilesFileCategory {
    @objc
    public init() {
        let swift = Files.FileCategory.pdf
        super.init(swift: swift)
    }
}

/// xlsx, xls, csv, and more.
@objc
public class DBXFilesFileCategorySpreadsheet: DBXFilesFileCategory {
    @objc
    public init() {
        let swift = Files.FileCategory.spreadsheet
        super.init(swift: swift)
    }
}

/// ppt, pptx, key, and more.
@objc
public class DBXFilesFileCategoryPresentation: DBXFilesFileCategory {
    @objc
    public init() {
        let swift = Files.FileCategory.presentation
        super.init(swift: swift)
    }
}

/// mp3, wav, mid, and more.
@objc
public class DBXFilesFileCategoryAudio: DBXFilesFileCategory {
    @objc
    public init() {
        let swift = Files.FileCategory.audio
        super.init(swift: swift)
    }
}

/// mov, wmv, mp4, and more.
@objc
public class DBXFilesFileCategoryVideo: DBXFilesFileCategory {
    @objc
    public init() {
        let swift = Files.FileCategory.video
        super.init(swift: swift)
    }
}

/// dropbox folder.
@objc
public class DBXFilesFileCategoryFolder: DBXFilesFileCategory {
    @objc
    public init() {
        let swift = Files.FileCategory.folder
        super.init(swift: swift)
    }
}

/// dropbox paper doc.
@objc
public class DBXFilesFileCategoryPaper: DBXFilesFileCategory {
    @objc
    public init() {
        let swift = Files.FileCategory.paper
        super.init(swift: swift)
    }
}

/// any file not in one of the categories above.
@objc
public class DBXFilesFileCategoryOthers: DBXFilesFileCategory {
    @objc
    public init() {
        let swift = Files.FileCategory.others
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXFilesFileCategoryOther: DBXFilesFileCategory {
    @objc
    public init() {
        let swift = Files.FileCategory.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible FileLock struct
@objc
public class DBXFilesFileLock: NSObject {
    /// The lock description.
    @objc
    public var content: DBXFilesFileLockContent { DBXFilesFileLockContent(swift: swift.content) }

    @objc
    public init(content: DBXFilesFileLockContent) {
        self.swift = Files.FileLock(content: content.swift)
    }

    let swift: Files.FileLock

    public init(swift: Files.FileLock) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible FileLockContent union
@objc
public class DBXFilesFileLockContent: NSObject {
    let swift: Files.FileLockContent

    public init(swift: Files.FileLockContent) {
        self.swift = swift
    }

    public static func factory(swift: Files.FileLockContent) -> DBXFilesFileLockContent {
        switch swift {
        case .unlocked:
            return DBXFilesFileLockContentUnlocked()
        case .singleUser(let swiftArg):
            let arg = DBXFilesSingleUserLock(swift: swiftArg)
            return DBXFilesFileLockContentSingleUser(arg)
        case .other:
            return DBXFilesFileLockContentOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asUnlocked: DBXFilesFileLockContentUnlocked? {
        self as? DBXFilesFileLockContentUnlocked
    }

    @objc
    public var asSingleUser: DBXFilesFileLockContentSingleUser? {
        self as? DBXFilesFileLockContentSingleUser
    }

    @objc
    public var asOther: DBXFilesFileLockContentOther? {
        self as? DBXFilesFileLockContentOther
    }
}

/// Empty type to indicate no lock.
@objc
public class DBXFilesFileLockContentUnlocked: DBXFilesFileLockContent {
    @objc
    public init() {
        let swift = Files.FileLockContent.unlocked
        super.init(swift: swift)
    }
}

/// A lock held by a single user.
@objc
public class DBXFilesFileLockContentSingleUser: DBXFilesFileLockContent {
    @objc
    public var singleUser: DBXFilesSingleUserLock

    @objc
    public init(_ arg: DBXFilesSingleUserLock) {
        self.singleUser = arg
        let swift = Files.FileLockContent.singleUser(arg.swift)
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXFilesFileLockContentOther: DBXFilesFileLockContent {
    @objc
    public init() {
        let swift = Files.FileLockContent.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible FileLockMetadata struct
@objc
public class DBXFilesFileLockMetadata: NSObject {
    /// True if caller holds the file lock.
    @objc
    public var isLockholder: NSNumber? { swift.isLockholder as NSNumber? }
    /// The display name of the lock holder.
    @objc
    public var lockholderName: String? { swift.lockholderName }
    /// The account ID of the lock holder if known.
    @objc
    public var lockholderAccountId: String? { swift.lockholderAccountId }
    /// The timestamp of the lock was created.
    @objc
    public var created: Date? { swift.created }

    @objc
    public init(isLockholder: NSNumber?, lockholderName: String?, lockholderAccountId: String?, created: Date?) {
        self.swift = Files.FileLockMetadata(
            isLockholder: isLockholder?.boolValue,
            lockholderName: lockholderName,
            lockholderAccountId: lockholderAccountId,
            created: created
        )
    }

    let swift: Files.FileLockMetadata

    public init(swift: Files.FileLockMetadata) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible FileMetadata struct
@objc
public class DBXFilesFileMetadata: DBXFilesMetadata {
    /// A unique identifier for the file.
    @objc
    public var id: String { subSwift.id }
    /// For files, this is the modification time set by the desktop client when the file was added to Dropbox. Since
    /// this time is not verified (the Dropbox server stores whatever the desktop client sends up), this should
    /// only be used for display purposes (such as sorting) and not, for example, to determine if a file has
    /// changed or not.
    @objc
    public var clientModified: Date { subSwift.clientModified }
    /// The last time the file was modified on Dropbox.
    @objc
    public var serverModified: Date { subSwift.serverModified }
    /// A unique identifier for the current revision of a file. This field is the same rev as elsewhere in the API
    /// and can be used to detect changes and avoid conflicts.
    @objc
    public var rev: String { subSwift.rev }
    /// The file size in bytes.
    @objc
    public var size: NSNumber { subSwift.size as NSNumber }
    /// Additional information if the file is a photo or video. This field will not be set on entries returned by
    /// listFolder, listFolderContinue, or getThumbnailBatch, starting December 2, 2019.
    @objc
    public var mediaInfo: DBXFilesMediaInfo? { guard let swift = subSwift.mediaInfo else { return nil }
        return DBXFilesMediaInfo(swift: swift)
    }

    /// Set if this file is a symlink.
    @objc
    public var symlinkInfo: DBXFilesSymlinkInfo? { guard let swift = subSwift.symlinkInfo else { return nil }
        return DBXFilesSymlinkInfo(swift: swift)
    }

    /// Set if this file is contained in a shared folder.
    @objc
    public var sharingInfo: DBXFilesFileSharingInfo? { guard let swift = subSwift.sharingInfo else { return nil }
        return DBXFilesFileSharingInfo(swift: swift)
    }

    /// If true, file can be downloaded directly; else the file must be exported.
    @objc
    public var isDownloadable: NSNumber { subSwift.isDownloadable as NSNumber }
    /// Information about format this file can be exported to. This filed must be set if isDownloadable is set to
    /// false.
    @objc
    public var exportInfo: DBXFilesExportInfo? { guard let swift = subSwift.exportInfo else { return nil }
        return DBXFilesExportInfo(swift: swift)
    }

    /// Additional information if the file has custom properties with the property template specified.
    @objc
    public var propertyGroups: [DBXFilePropertiesPropertyGroup]? { subSwift.propertyGroups?.map { DBXFilePropertiesPropertyGroup(swift: $0) } }
    /// This flag will only be present if include_has_explicit_shared_members  is true in listFolder or getMetadata.
    /// If this  flag is present, it will be true if this file has any explicit shared  members. This is
    /// different from sharing_info in that this could be true  in the case where a file has explicit members
    /// but is not contained within  a shared folder.
    @objc
    public var hasExplicitSharedMembers: NSNumber? { subSwift.hasExplicitSharedMembers as NSNumber? }
    /// A hash of the file content. This field can be used to verify data integrity. For more information see our
    /// Content hash https://www.dropbox.com/developers/reference/content-hash page.
    @objc
    public var contentHash: String? { subSwift.contentHash }
    /// If present, the metadata associated with the file's current lock.
    @objc
    public var fileLockInfo: DBXFilesFileLockMetadata? { guard let swift = subSwift.fileLockInfo else { return nil }
        return DBXFilesFileLockMetadata(swift: swift)
    }

    @objc
    public init(
        name: String,
        id: String,
        clientModified: Date,
        serverModified: Date,
        rev: String,
        size: NSNumber,
        pathLower: String?,
        pathDisplay: String?,
        parentSharedFolderId: String?,
        previewUrl: String?,
        mediaInfo: DBXFilesMediaInfo?,
        symlinkInfo: DBXFilesSymlinkInfo?,
        sharingInfo: DBXFilesFileSharingInfo?,
        isDownloadable: NSNumber,
        exportInfo: DBXFilesExportInfo?,
        propertyGroups: [DBXFilePropertiesPropertyGroup]?,
        hasExplicitSharedMembers: NSNumber?,
        contentHash: String?,
        fileLockInfo: DBXFilesFileLockMetadata?
    ) {
        let swift = Files.FileMetadata(
            name: name,
            id: id,
            clientModified: clientModified,
            serverModified: serverModified,
            rev: rev,
            size: size.uint64Value,
            pathLower: pathLower,
            pathDisplay: pathDisplay,
            parentSharedFolderId: parentSharedFolderId,
            previewUrl: previewUrl,
            mediaInfo: mediaInfo?.swift,
            symlinkInfo: symlinkInfo?.swift,
            sharingInfo: sharingInfo?.subSwift,
            isDownloadable: isDownloadable.boolValue,
            exportInfo: exportInfo?.swift,
            propertyGroups: propertyGroups?.map(\.swift),
            hasExplicitSharedMembers: hasExplicitSharedMembers?.boolValue,
            contentHash: contentHash,
            fileLockInfo: fileLockInfo?.swift
        )
        self.subSwift = swift
        super.init(swift: swift)
    }

    let subSwift: Files.FileMetadata

    public init(swift: Files.FileMetadata) {
        self.subSwift = swift
        super.init(swift: swift)
    }

    @objc
    public override var description: String { subSwift.description }
}

/// Sharing info for a file or folder.
@objc
public class DBXFilesSharingInfo: NSObject {
    /// True if the file or folder is inside a read-only shared folder.
    @objc
    public var readOnly: NSNumber { swift.readOnly as NSNumber }

    @objc
    public init(readOnly: NSNumber) {
        self.swift = Files.SharingInfo(readOnly: readOnly.boolValue)
    }

    let swift: Files.SharingInfo

    public init(swift: Files.SharingInfo) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Sharing info for a file which is contained by a shared folder.
@objc
public class DBXFilesFileSharingInfo: DBXFilesSharingInfo {
    /// ID of shared folder that holds this file.
    @objc
    public var parentSharedFolderId: String { subSwift.parentSharedFolderId }
    /// The last user who modified the file. This field will be null if the user's account has been deleted.
    @objc
    public var modifiedBy: String? { subSwift.modifiedBy }

    @objc
    public init(readOnly: NSNumber, parentSharedFolderId: String, modifiedBy: String?) {
        let swift = Files.FileSharingInfo(readOnly: readOnly.boolValue, parentSharedFolderId: parentSharedFolderId, modifiedBy: modifiedBy)
        self.subSwift = swift
        super.init(swift: swift)
    }

    let subSwift: Files.FileSharingInfo

    public init(swift: Files.FileSharingInfo) {
        self.subSwift = swift
        super.init(swift: swift)
    }

    @objc
    public override var description: String { subSwift.description }
}

/// Objective-C compatible FileStatus union
@objc
public class DBXFilesFileStatus: NSObject {
    let swift: Files.FileStatus

    public init(swift: Files.FileStatus) {
        self.swift = swift
    }

    public static func factory(swift: Files.FileStatus) -> DBXFilesFileStatus {
        switch swift {
        case .active:
            return DBXFilesFileStatusActive()
        case .deleted:
            return DBXFilesFileStatusDeleted()
        case .other:
            return DBXFilesFileStatusOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asActive: DBXFilesFileStatusActive? {
        self as? DBXFilesFileStatusActive
    }

    @objc
    public var asDeleted: DBXFilesFileStatusDeleted? {
        self as? DBXFilesFileStatusDeleted
    }

    @objc
    public var asOther: DBXFilesFileStatusOther? {
        self as? DBXFilesFileStatusOther
    }
}

/// An unspecified error.
@objc
public class DBXFilesFileStatusActive: DBXFilesFileStatus {
    @objc
    public init() {
        let swift = Files.FileStatus.active
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXFilesFileStatusDeleted: DBXFilesFileStatus {
    @objc
    public init() {
        let swift = Files.FileStatus.deleted
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXFilesFileStatusOther: DBXFilesFileStatus {
    @objc
    public init() {
        let swift = Files.FileStatus.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible FolderMetadata struct
@objc
public class DBXFilesFolderMetadata: DBXFilesMetadata {
    /// A unique identifier for the folder.
    @objc
    public var id: String { subSwift.id }
    /// Please use sharingInfo instead.
    @objc
    public var sharedFolderId: String? { subSwift.sharedFolderId }
    /// Set if the folder is contained in a shared folder or is a shared folder mount point.
    @objc
    public var sharingInfo: DBXFilesFolderSharingInfo? { guard let swift = subSwift.sharingInfo else { return nil }
        return DBXFilesFolderSharingInfo(swift: swift)
    }

    /// Additional information if the file has custom properties with the property template specified. Note that
    /// only properties associated with user-owned templates, not team-owned templates, can be attached to
    /// folders.
    @objc
    public var propertyGroups: [DBXFilePropertiesPropertyGroup]? { subSwift.propertyGroups?.map { DBXFilePropertiesPropertyGroup(swift: $0) } }

    @objc
    public init(
        name: String,
        id: String,
        pathLower: String?,
        pathDisplay: String?,
        parentSharedFolderId: String?,
        previewUrl: String?,
        sharedFolderId: String?,
        sharingInfo: DBXFilesFolderSharingInfo?,
        propertyGroups: [DBXFilePropertiesPropertyGroup]?
    ) {
        let swift = Files.FolderMetadata(
            name: name,
            id: id,
            pathLower: pathLower,
            pathDisplay: pathDisplay,
            parentSharedFolderId: parentSharedFolderId,
            previewUrl: previewUrl,
            sharedFolderId: sharedFolderId,
            sharingInfo: sharingInfo?.subSwift,
            propertyGroups: propertyGroups?.map(\.swift)
        )
        self.subSwift = swift
        super.init(swift: swift)
    }

    let subSwift: Files.FolderMetadata

    public init(swift: Files.FolderMetadata) {
        self.subSwift = swift
        super.init(swift: swift)
    }

    @objc
    public override var description: String { subSwift.description }
}

/// Sharing info for a folder which is contained in a shared folder or is a shared folder mount point.
@objc
public class DBXFilesFolderSharingInfo: DBXFilesSharingInfo {
    /// Set if the folder is contained by a shared folder.
    @objc
    public var parentSharedFolderId: String? { subSwift.parentSharedFolderId }
    /// If this folder is a shared folder mount point, the ID of the shared folder mounted at this location.
    @objc
    public var sharedFolderId: String? { subSwift.sharedFolderId }
    /// Specifies that the folder can only be traversed and the user can only see a limited subset of the contents
    /// of this folder because they don't have read access to this folder. They do, however, have access to some
    /// sub folder.
    @objc
    public var traverseOnly: NSNumber { subSwift.traverseOnly as NSNumber }
    /// Specifies that the folder cannot be accessed by the user.
    @objc
    public var noAccess: NSNumber { subSwift.noAccess as NSNumber }

    @objc
    public init(readOnly: NSNumber, parentSharedFolderId: String?, sharedFolderId: String?, traverseOnly: NSNumber, noAccess: NSNumber) {
        let swift = Files.FolderSharingInfo(
            readOnly: readOnly.boolValue,
            parentSharedFolderId: parentSharedFolderId,
            sharedFolderId: sharedFolderId,
            traverseOnly: traverseOnly.boolValue,
            noAccess: noAccess.boolValue
        )
        self.subSwift = swift
        super.init(swift: swift)
    }

    let subSwift: Files.FolderSharingInfo

    public init(swift: Files.FolderSharingInfo) {
        self.subSwift = swift
        super.init(swift: swift)
    }

    @objc
    public override var description: String { subSwift.description }
}

/// Objective-C compatible GetCopyReferenceArg struct
@objc
public class DBXFilesGetCopyReferenceArg: NSObject {
    /// The path to the file or folder you want to get a copy reference to.
    @objc
    public var path: String { swift.path }

    @objc
    public init(path: String) {
        self.swift = Files.GetCopyReferenceArg(path: path)
    }

    let swift: Files.GetCopyReferenceArg

    public init(swift: Files.GetCopyReferenceArg) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible GetCopyReferenceError union
@objc
public class DBXFilesGetCopyReferenceError: NSObject {
    let swift: Files.GetCopyReferenceError

    public init(swift: Files.GetCopyReferenceError) {
        self.swift = swift
    }

    public static func factory(swift: Files.GetCopyReferenceError) -> DBXFilesGetCopyReferenceError {
        switch swift {
        case .path(let swiftArg):
            let arg = DBXFilesLookupError(swift: swiftArg)
            return DBXFilesGetCopyReferenceErrorPath(arg)
        case .other:
            return DBXFilesGetCopyReferenceErrorOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asPath: DBXFilesGetCopyReferenceErrorPath? {
        self as? DBXFilesGetCopyReferenceErrorPath
    }

    @objc
    public var asOther: DBXFilesGetCopyReferenceErrorOther? {
        self as? DBXFilesGetCopyReferenceErrorOther
    }
}

/// An unspecified error.
@objc
public class DBXFilesGetCopyReferenceErrorPath: DBXFilesGetCopyReferenceError {
    @objc
    public var path: DBXFilesLookupError

    @objc
    public init(_ arg: DBXFilesLookupError) {
        self.path = arg
        let swift = Files.GetCopyReferenceError.path(arg.swift)
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXFilesGetCopyReferenceErrorOther: DBXFilesGetCopyReferenceError {
    @objc
    public init() {
        let swift = Files.GetCopyReferenceError.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible GetCopyReferenceResult struct
@objc
public class DBXFilesGetCopyReferenceResult: NSObject {
    /// Metadata of the file or folder.
    @objc
    public var metadata: DBXFilesMetadata {
        DBXFilesMetadata.wrapPreservingSubtypes(swift: swift.metadata)
    }

    /// A copy reference to the file or folder.
    @objc
    public var copyReference: String { swift.copyReference }
    /// The expiration date of the copy reference. This value is currently set to be far enough in the future so
    /// that expiration is effectively not an issue.
    @objc
    public var expires: Date { swift.expires }

    @objc
    public init(metadata: DBXFilesMetadata, copyReference: String, expires: Date) {
        self.swift = Files.GetCopyReferenceResult(metadata: metadata.swift, copyReference: copyReference, expires: expires)
    }

    let swift: Files.GetCopyReferenceResult

    public init(swift: Files.GetCopyReferenceResult) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible GetTagsArg struct
@objc
public class DBXFilesGetTagsArg: NSObject {
    /// Path to the items.
    @objc
    public var paths: [String] { swift.paths }

    @objc
    public init(paths: [String]) {
        self.swift = Files.GetTagsArg(paths: paths)
    }

    let swift: Files.GetTagsArg

    public init(swift: Files.GetTagsArg) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible GetTagsResult struct
@objc
public class DBXFilesGetTagsResult: NSObject {
    /// List of paths and their corresponding tags.
    @objc
    public var pathsToTags: [DBXFilesPathToTags] { swift.pathsToTags.map { DBXFilesPathToTags(swift: $0) } }

    @objc
    public init(pathsToTags: [DBXFilesPathToTags]) {
        self.swift = Files.GetTagsResult(pathsToTags: pathsToTags.map(\.swift))
    }

    let swift: Files.GetTagsResult

    public init(swift: Files.GetTagsResult) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible GetTemporaryLinkArg struct
@objc
public class DBXFilesGetTemporaryLinkArg: NSObject {
    /// The path to the file you want a temporary link to.
    @objc
    public var path: String { swift.path }

    @objc
    public init(path: String) {
        self.swift = Files.GetTemporaryLinkArg(path: path)
    }

    let swift: Files.GetTemporaryLinkArg

    public init(swift: Files.GetTemporaryLinkArg) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible GetTemporaryLinkError union
@objc
public class DBXFilesGetTemporaryLinkError: NSObject {
    let swift: Files.GetTemporaryLinkError

    public init(swift: Files.GetTemporaryLinkError) {
        self.swift = swift
    }

    public static func factory(swift: Files.GetTemporaryLinkError) -> DBXFilesGetTemporaryLinkError {
        switch swift {
        case .path(let swiftArg):
            let arg = DBXFilesLookupError(swift: swiftArg)
            return DBXFilesGetTemporaryLinkErrorPath(arg)
        case .emailNotVerified:
            return DBXFilesGetTemporaryLinkErrorEmailNotVerified()
        case .unsupportedFile:
            return DBXFilesGetTemporaryLinkErrorUnsupportedFile()
        case .notAllowed:
            return DBXFilesGetTemporaryLinkErrorNotAllowed()
        case .other:
            return DBXFilesGetTemporaryLinkErrorOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asPath: DBXFilesGetTemporaryLinkErrorPath? {
        self as? DBXFilesGetTemporaryLinkErrorPath
    }

    @objc
    public var asEmailNotVerified: DBXFilesGetTemporaryLinkErrorEmailNotVerified? {
        self as? DBXFilesGetTemporaryLinkErrorEmailNotVerified
    }

    @objc
    public var asUnsupportedFile: DBXFilesGetTemporaryLinkErrorUnsupportedFile? {
        self as? DBXFilesGetTemporaryLinkErrorUnsupportedFile
    }

    @objc
    public var asNotAllowed: DBXFilesGetTemporaryLinkErrorNotAllowed? {
        self as? DBXFilesGetTemporaryLinkErrorNotAllowed
    }

    @objc
    public var asOther: DBXFilesGetTemporaryLinkErrorOther? {
        self as? DBXFilesGetTemporaryLinkErrorOther
    }
}

/// An unspecified error.
@objc
public class DBXFilesGetTemporaryLinkErrorPath: DBXFilesGetTemporaryLinkError {
    @objc
    public var path: DBXFilesLookupError

    @objc
    public init(_ arg: DBXFilesLookupError) {
        self.path = arg
        let swift = Files.GetTemporaryLinkError.path(arg.swift)
        super.init(swift: swift)
    }
}

/// This user's email address is not verified. This functionality is only available on accounts with a verified
/// email address. Users can verify their email address here https://www.dropbox.com/help/317.
@objc
public class DBXFilesGetTemporaryLinkErrorEmailNotVerified: DBXFilesGetTemporaryLinkError {
    @objc
    public init() {
        let swift = Files.GetTemporaryLinkError.emailNotVerified
        super.init(swift: swift)
    }
}

/// Cannot get temporary link to this file type; use export instead.
@objc
public class DBXFilesGetTemporaryLinkErrorUnsupportedFile: DBXFilesGetTemporaryLinkError {
    @objc
    public init() {
        let swift = Files.GetTemporaryLinkError.unsupportedFile
        super.init(swift: swift)
    }
}

/// The user is not allowed to request a temporary link to the specified file. For example, this can occur if
/// the file is restricted or if the user's links are banned
/// https://help.dropbox.com/files-folders/share/banned-links.
@objc
public class DBXFilesGetTemporaryLinkErrorNotAllowed: DBXFilesGetTemporaryLinkError {
    @objc
    public init() {
        let swift = Files.GetTemporaryLinkError.notAllowed
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXFilesGetTemporaryLinkErrorOther: DBXFilesGetTemporaryLinkError {
    @objc
    public init() {
        let swift = Files.GetTemporaryLinkError.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible GetTemporaryLinkResult struct
@objc
public class DBXFilesGetTemporaryLinkResult: NSObject {
    /// Metadata of the file.
    @objc
    public var metadata: DBXFilesFileMetadata { DBXFilesFileMetadata(swift: swift.metadata) }
    /// The temporary link which can be used to stream content the file.
    @objc
    public var link: String { swift.link }

    @objc
    public init(metadata: DBXFilesFileMetadata, link: String) {
        self.swift = Files.GetTemporaryLinkResult(metadata: metadata.subSwift, link: link)
    }

    let swift: Files.GetTemporaryLinkResult

    public init(swift: Files.GetTemporaryLinkResult) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible GetTemporaryUploadLinkArg struct
@objc
public class DBXFilesGetTemporaryUploadLinkArg: NSObject {
    /// Contains the path and other optional modifiers for the future upload commit. Equivalent to the parameters
    /// provided to upload.
    @objc
    public var commitInfo: DBXFilesCommitInfo { DBXFilesCommitInfo(swift: swift.commitInfo) }
    /// How long before this link expires, in seconds.  Attempting to start an upload with this link longer than
    /// this period  of time after link creation will result in an error.
    @objc
    public var duration: NSNumber { swift.duration as NSNumber }

    @objc
    public init(commitInfo: DBXFilesCommitInfo, duration: NSNumber) {
        self.swift = Files.GetTemporaryUploadLinkArg(commitInfo: commitInfo.swift, duration: duration.doubleValue)
    }

    let swift: Files.GetTemporaryUploadLinkArg

    public init(swift: Files.GetTemporaryUploadLinkArg) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible GetTemporaryUploadLinkResult struct
@objc
public class DBXFilesGetTemporaryUploadLinkResult: NSObject {
    /// The temporary link which can be used to stream a file to a Dropbox location.
    @objc
    public var link: String { swift.link }

    @objc
    public init(link: String) {
        self.swift = Files.GetTemporaryUploadLinkResult(link: link)
    }

    let swift: Files.GetTemporaryUploadLinkResult

    public init(swift: Files.GetTemporaryUploadLinkResult) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Arguments for getThumbnailBatch.
@objc
public class DBXFilesGetThumbnailBatchArg: NSObject {
    /// List of files to get thumbnails.
    @objc
    public var entries: [DBXFilesThumbnailArg] { swift.entries.map { DBXFilesThumbnailArg(swift: $0) } }

    @objc
    public init(entries: [DBXFilesThumbnailArg]) {
        self.swift = Files.GetThumbnailBatchArg(entries: entries.map(\.swift))
    }

    let swift: Files.GetThumbnailBatchArg

    public init(swift: Files.GetThumbnailBatchArg) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible GetThumbnailBatchError union
@objc
public class DBXFilesGetThumbnailBatchError: NSObject {
    let swift: Files.GetThumbnailBatchError

    public init(swift: Files.GetThumbnailBatchError) {
        self.swift = swift
    }

    public static func factory(swift: Files.GetThumbnailBatchError) -> DBXFilesGetThumbnailBatchError {
        switch swift {
        case .tooManyFiles:
            return DBXFilesGetThumbnailBatchErrorTooManyFiles()
        case .other:
            return DBXFilesGetThumbnailBatchErrorOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asTooManyFiles: DBXFilesGetThumbnailBatchErrorTooManyFiles? {
        self as? DBXFilesGetThumbnailBatchErrorTooManyFiles
    }

    @objc
    public var asOther: DBXFilesGetThumbnailBatchErrorOther? {
        self as? DBXFilesGetThumbnailBatchErrorOther
    }
}

/// The operation involves more than 25 files.
@objc
public class DBXFilesGetThumbnailBatchErrorTooManyFiles: DBXFilesGetThumbnailBatchError {
    @objc
    public init() {
        let swift = Files.GetThumbnailBatchError.tooManyFiles
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXFilesGetThumbnailBatchErrorOther: DBXFilesGetThumbnailBatchError {
    @objc
    public init() {
        let swift = Files.GetThumbnailBatchError.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible GetThumbnailBatchResult struct
@objc
public class DBXFilesGetThumbnailBatchResult: NSObject {
    /// List of files and their thumbnails.
    @objc
    public var entries: [DBXFilesGetThumbnailBatchResultEntry] { swift.entries.map { DBXFilesGetThumbnailBatchResultEntry(swift: $0) } }

    @objc
    public init(entries: [DBXFilesGetThumbnailBatchResultEntry]) {
        self.swift = Files.GetThumbnailBatchResult(entries: entries.map(\.swift))
    }

    let swift: Files.GetThumbnailBatchResult

    public init(swift: Files.GetThumbnailBatchResult) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible GetThumbnailBatchResultData struct
@objc
public class DBXFilesGetThumbnailBatchResultData: NSObject {
    /// (no description)
    @objc
    public var metadata: DBXFilesFileMetadata { DBXFilesFileMetadata(swift: swift.metadata) }
    /// A string containing the base64-encoded thumbnail data for this file.
    @objc
    public var thumbnail: String { swift.thumbnail }

    @objc
    public init(metadata: DBXFilesFileMetadata, thumbnail: String) {
        self.swift = Files.GetThumbnailBatchResultData(metadata: metadata.subSwift, thumbnail: thumbnail)
    }

    let swift: Files.GetThumbnailBatchResultData

    public init(swift: Files.GetThumbnailBatchResultData) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible GetThumbnailBatchResultEntry union
@objc
public class DBXFilesGetThumbnailBatchResultEntry: NSObject {
    let swift: Files.GetThumbnailBatchResultEntry

    public init(swift: Files.GetThumbnailBatchResultEntry) {
        self.swift = swift
    }

    public static func factory(swift: Files.GetThumbnailBatchResultEntry) -> DBXFilesGetThumbnailBatchResultEntry {
        switch swift {
        case .success(let swiftArg):
            let arg = DBXFilesGetThumbnailBatchResultData(swift: swiftArg)
            return DBXFilesGetThumbnailBatchResultEntrySuccess(arg)
        case .failure(let swiftArg):
            let arg = DBXFilesThumbnailError(swift: swiftArg)
            return DBXFilesGetThumbnailBatchResultEntryFailure(arg)
        case .other:
            return DBXFilesGetThumbnailBatchResultEntryOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asSuccess: DBXFilesGetThumbnailBatchResultEntrySuccess? {
        self as? DBXFilesGetThumbnailBatchResultEntrySuccess
    }

    @objc
    public var asFailure: DBXFilesGetThumbnailBatchResultEntryFailure? {
        self as? DBXFilesGetThumbnailBatchResultEntryFailure
    }

    @objc
    public var asOther: DBXFilesGetThumbnailBatchResultEntryOther? {
        self as? DBXFilesGetThumbnailBatchResultEntryOther
    }
}

/// An unspecified error.
@objc
public class DBXFilesGetThumbnailBatchResultEntrySuccess: DBXFilesGetThumbnailBatchResultEntry {
    @objc
    public var success: DBXFilesGetThumbnailBatchResultData

    @objc
    public init(_ arg: DBXFilesGetThumbnailBatchResultData) {
        self.success = arg
        let swift = Files.GetThumbnailBatchResultEntry.success(arg.swift)
        super.init(swift: swift)
    }
}

/// The result for this file if it was an error.
@objc
public class DBXFilesGetThumbnailBatchResultEntryFailure: DBXFilesGetThumbnailBatchResultEntry {
    @objc
    public var failure: DBXFilesThumbnailError

    @objc
    public init(_ arg: DBXFilesThumbnailError) {
        self.failure = arg
        let swift = Files.GetThumbnailBatchResultEntry.failure(arg.swift)
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXFilesGetThumbnailBatchResultEntryOther: DBXFilesGetThumbnailBatchResultEntry {
    @objc
    public init() {
        let swift = Files.GetThumbnailBatchResultEntry.other
        super.init(swift: swift)
    }
}

/// GPS coordinates for a photo or video.
@objc
public class DBXFilesGpsCoordinates: NSObject {
    /// Latitude of the GPS coordinates.
    @objc
    public var latitude: NSNumber { swift.latitude as NSNumber }
    /// Longitude of the GPS coordinates.
    @objc
    public var longitude: NSNumber { swift.longitude as NSNumber }

    @objc
    public init(latitude: NSNumber, longitude: NSNumber) {
        self.swift = Files.GpsCoordinates(latitude: latitude.doubleValue, longitude: longitude.doubleValue)
    }

    let swift: Files.GpsCoordinates

    public init(swift: Files.GpsCoordinates) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible HighlightSpan struct
@objc
public class DBXFilesHighlightSpan: NSObject {
    /// String to be determined whether it should be highlighted or not.
    @objc
    public var highlightStr: String { swift.highlightStr }
    /// The string should be highlighted or not.
    @objc
    public var isHighlighted: NSNumber { swift.isHighlighted as NSNumber }

    @objc
    public init(highlightStr: String, isHighlighted: NSNumber) {
        self.swift = Files.HighlightSpan(highlightStr: highlightStr, isHighlighted: isHighlighted.boolValue)
    }

    let swift: Files.HighlightSpan

    public init(swift: Files.HighlightSpan) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// The import format of the incoming Paper doc content.
@objc
public class DBXFilesImportFormat: NSObject {
    let swift: Files.ImportFormat

    public init(swift: Files.ImportFormat) {
        self.swift = swift
    }

    public static func factory(swift: Files.ImportFormat) -> DBXFilesImportFormat {
        switch swift {
        case .html:
            return DBXFilesImportFormatHtml()
        case .markdown:
            return DBXFilesImportFormatMarkdown()
        case .plainText:
            return DBXFilesImportFormatPlainText()
        case .other:
            return DBXFilesImportFormatOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asHtml: DBXFilesImportFormatHtml? {
        self as? DBXFilesImportFormatHtml
    }

    @objc
    public var asMarkdown: DBXFilesImportFormatMarkdown? {
        self as? DBXFilesImportFormatMarkdown
    }

    @objc
    public var asPlainText: DBXFilesImportFormatPlainText? {
        self as? DBXFilesImportFormatPlainText
    }

    @objc
    public var asOther: DBXFilesImportFormatOther? {
        self as? DBXFilesImportFormatOther
    }
}

/// The provided data is interpreted as standard HTML.
@objc
public class DBXFilesImportFormatHtml: DBXFilesImportFormat {
    @objc
    public init() {
        let swift = Files.ImportFormat.html
        super.init(swift: swift)
    }
}

/// The provided data is interpreted as markdown.
@objc
public class DBXFilesImportFormatMarkdown: DBXFilesImportFormat {
    @objc
    public init() {
        let swift = Files.ImportFormat.markdown
        super.init(swift: swift)
    }
}

/// The provided data is interpreted as plain text.
@objc
public class DBXFilesImportFormatPlainText: DBXFilesImportFormat {
    @objc
    public init() {
        let swift = Files.ImportFormat.plainText
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXFilesImportFormatOther: DBXFilesImportFormat {
    @objc
    public init() {
        let swift = Files.ImportFormat.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible ListFolderArg struct
@objc
public class DBXFilesListFolderArg: NSObject {
    /// A unique identifier for the file.
    @objc
    public var path: String { swift.path }
    /// If true, the list folder operation will be applied recursively to all subfolders and the response will
    /// contain contents of all subfolders.
    @objc
    public var recursive: NSNumber { swift.recursive as NSNumber }
    /// If true, mediaInfo in FileMetadata is set for photo and video. This parameter will no longer have an effect
    /// starting December 2, 2019.
    @objc
    public var includeMediaInfo: NSNumber { swift.includeMediaInfo as NSNumber }
    /// If true, the results will include entries for files and folders that used to exist but were deleted.
    @objc
    public var includeDeleted: NSNumber { swift.includeDeleted as NSNumber }
    /// If true, the results will include a flag for each file indicating whether or not  that file has any explicit
    /// members.
    @objc
    public var includeHasExplicitSharedMembers: NSNumber { swift.includeHasExplicitSharedMembers as NSNumber }
    /// If true, the results will include entries under mounted folders which includes app folder, shared folder and
    /// team folder.
    @objc
    public var includeMountedFolders: NSNumber { swift.includeMountedFolders as NSNumber }
    /// The maximum number of results to return per request. Note: This is an approximate number and there can be
    /// slightly more entries returned in some cases.
    @objc
    public var limit: NSNumber? { swift.limit as NSNumber? }
    /// A shared link to list the contents of. If the link is password-protected, the password must be provided. If
    /// this field is present, path in ListFolderArg will be relative to root of the shared link. Only
    /// non-recursive mode is supported for shared link.
    @objc
    public var sharedLink: DBXFilesSharedLink? { guard let swift = swift.sharedLink else { return nil }
        return DBXFilesSharedLink(swift: swift)
    }

    /// If set to a valid list of template IDs, propertyGroups in FileMetadata is set if there exists property data
    /// associated with the file and each of the listed templates.
    @objc
    public var includePropertyGroups: DBXFilePropertiesTemplateFilterBase? { guard let swift = swift.includePropertyGroups else { return nil }
        return DBXFilePropertiesTemplateFilterBase(swift: swift)
    }

    /// If true, include files that are not downloadable, i.e. Google Docs.
    @objc
    public var includeNonDownloadableFiles: NSNumber { swift.includeNonDownloadableFiles as NSNumber }

    @objc
    public init(
        path: String,
        recursive: NSNumber,
        includeMediaInfo: NSNumber,
        includeDeleted: NSNumber,
        includeHasExplicitSharedMembers: NSNumber,
        includeMountedFolders: NSNumber,
        limit: NSNumber?,
        sharedLink: DBXFilesSharedLink?,
        includePropertyGroups: DBXFilePropertiesTemplateFilterBase?,
        includeNonDownloadableFiles: NSNumber
    ) {
        self.swift = Files.ListFolderArg(
            path: path,
            recursive: recursive.boolValue,
            includeMediaInfo: includeMediaInfo.boolValue,
            includeDeleted: includeDeleted.boolValue,
            includeHasExplicitSharedMembers: includeHasExplicitSharedMembers.boolValue,
            includeMountedFolders: includeMountedFolders.boolValue,
            limit: limit?.uint32Value,
            sharedLink: sharedLink?.swift,
            includePropertyGroups: includePropertyGroups?.swift,
            includeNonDownloadableFiles: includeNonDownloadableFiles.boolValue
        )
    }

    let swift: Files.ListFolderArg

    public init(swift: Files.ListFolderArg) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible ListFolderContinueArg struct
@objc
public class DBXFilesListFolderContinueArg: NSObject {
    /// The cursor returned by your last call to listFolder or listFolderContinue.
    @objc
    public var cursor: String { swift.cursor }

    @objc
    public init(cursor: String) {
        self.swift = Files.ListFolderContinueArg(cursor: cursor)
    }

    let swift: Files.ListFolderContinueArg

    public init(swift: Files.ListFolderContinueArg) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible ListFolderContinueError union
@objc
public class DBXFilesListFolderContinueError: NSObject {
    let swift: Files.ListFolderContinueError

    public init(swift: Files.ListFolderContinueError) {
        self.swift = swift
    }

    public static func factory(swift: Files.ListFolderContinueError) -> DBXFilesListFolderContinueError {
        switch swift {
        case .path(let swiftArg):
            let arg = DBXFilesLookupError(swift: swiftArg)
            return DBXFilesListFolderContinueErrorPath(arg)
        case .reset:
            return DBXFilesListFolderContinueErrorReset()
        case .other:
            return DBXFilesListFolderContinueErrorOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asPath: DBXFilesListFolderContinueErrorPath? {
        self as? DBXFilesListFolderContinueErrorPath
    }

    @objc
    public var asReset: DBXFilesListFolderContinueErrorReset? {
        self as? DBXFilesListFolderContinueErrorReset
    }

    @objc
    public var asOther: DBXFilesListFolderContinueErrorOther? {
        self as? DBXFilesListFolderContinueErrorOther
    }
}

/// An unspecified error.
@objc
public class DBXFilesListFolderContinueErrorPath: DBXFilesListFolderContinueError {
    @objc
    public var path: DBXFilesLookupError

    @objc
    public init(_ arg: DBXFilesLookupError) {
        self.path = arg
        let swift = Files.ListFolderContinueError.path(arg.swift)
        super.init(swift: swift)
    }
}

/// Indicates that the cursor has been invalidated. Call listFolder to obtain a new cursor.
@objc
public class DBXFilesListFolderContinueErrorReset: DBXFilesListFolderContinueError {
    @objc
    public init() {
        let swift = Files.ListFolderContinueError.reset
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXFilesListFolderContinueErrorOther: DBXFilesListFolderContinueError {
    @objc
    public init() {
        let swift = Files.ListFolderContinueError.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible ListFolderError union
@objc
public class DBXFilesListFolderError: NSObject {
    let swift: Files.ListFolderError

    public init(swift: Files.ListFolderError) {
        self.swift = swift
    }

    public static func factory(swift: Files.ListFolderError) -> DBXFilesListFolderError {
        switch swift {
        case .path(let swiftArg):
            let arg = DBXFilesLookupError(swift: swiftArg)
            return DBXFilesListFolderErrorPath(arg)
        case .templateError(let swiftArg):
            let arg = DBXFilePropertiesTemplateError(swift: swiftArg)
            return DBXFilesListFolderErrorTemplateError(arg)
        case .other:
            return DBXFilesListFolderErrorOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asPath: DBXFilesListFolderErrorPath? {
        self as? DBXFilesListFolderErrorPath
    }

    @objc
    public var asTemplateError: DBXFilesListFolderErrorTemplateError? {
        self as? DBXFilesListFolderErrorTemplateError
    }

    @objc
    public var asOther: DBXFilesListFolderErrorOther? {
        self as? DBXFilesListFolderErrorOther
    }
}

/// An unspecified error.
@objc
public class DBXFilesListFolderErrorPath: DBXFilesListFolderError {
    @objc
    public var path: DBXFilesLookupError

    @objc
    public init(_ arg: DBXFilesLookupError) {
        self.path = arg
        let swift = Files.ListFolderError.path(arg.swift)
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXFilesListFolderErrorTemplateError: DBXFilesListFolderError {
    @objc
    public var templateError: DBXFilePropertiesTemplateError

    @objc
    public init(_ arg: DBXFilePropertiesTemplateError) {
        self.templateError = arg
        let swift = Files.ListFolderError.templateError(arg.swift)
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXFilesListFolderErrorOther: DBXFilesListFolderError {
    @objc
    public init() {
        let swift = Files.ListFolderError.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible ListFolderGetLatestCursorResult struct
@objc
public class DBXFilesListFolderGetLatestCursorResult: NSObject {
    /// Pass the cursor into listFolderContinue to see what's changed in the folder since your previous query.
    @objc
    public var cursor: String { swift.cursor }

    @objc
    public init(cursor: String) {
        self.swift = Files.ListFolderGetLatestCursorResult(cursor: cursor)
    }

    let swift: Files.ListFolderGetLatestCursorResult

    public init(swift: Files.ListFolderGetLatestCursorResult) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible ListFolderLongpollArg struct
@objc
public class DBXFilesListFolderLongpollArg: NSObject {
    /// A cursor as returned by listFolder or listFolderContinue. Cursors retrieved by setting includeMediaInfo in
    /// ListFolderArg to true are not supported.
    @objc
    public var cursor: String { swift.cursor }
    /// A timeout in seconds. The request will block for at most this length of time, plus up to 90 seconds of
    /// random jitter added to avoid the thundering herd problem. Care should be taken when using this
    /// parameter, as some network infrastructure does not support long timeouts.
    @objc
    public var timeout: NSNumber { swift.timeout as NSNumber }

    @objc
    public init(cursor: String, timeout: NSNumber) {
        self.swift = Files.ListFolderLongpollArg(cursor: cursor, timeout: timeout.uint64Value)
    }

    let swift: Files.ListFolderLongpollArg

    public init(swift: Files.ListFolderLongpollArg) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible ListFolderLongpollError union
@objc
public class DBXFilesListFolderLongpollError: NSObject {
    let swift: Files.ListFolderLongpollError

    public init(swift: Files.ListFolderLongpollError) {
        self.swift = swift
    }

    public static func factory(swift: Files.ListFolderLongpollError) -> DBXFilesListFolderLongpollError {
        switch swift {
        case .reset:
            return DBXFilesListFolderLongpollErrorReset()
        case .other:
            return DBXFilesListFolderLongpollErrorOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asReset: DBXFilesListFolderLongpollErrorReset? {
        self as? DBXFilesListFolderLongpollErrorReset
    }

    @objc
    public var asOther: DBXFilesListFolderLongpollErrorOther? {
        self as? DBXFilesListFolderLongpollErrorOther
    }
}

/// Indicates that the cursor has been invalidated. Call listFolder to obtain a new cursor.
@objc
public class DBXFilesListFolderLongpollErrorReset: DBXFilesListFolderLongpollError {
    @objc
    public init() {
        let swift = Files.ListFolderLongpollError.reset
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXFilesListFolderLongpollErrorOther: DBXFilesListFolderLongpollError {
    @objc
    public init() {
        let swift = Files.ListFolderLongpollError.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible ListFolderLongpollResult struct
@objc
public class DBXFilesListFolderLongpollResult: NSObject {
    /// Indicates whether new changes are available. If true, call listFolderContinue to retrieve the changes.
    @objc
    public var changes: NSNumber { swift.changes as NSNumber }
    /// If present, backoff for at least this many seconds before calling listFolderLongpoll again.
    @objc
    public var backoff: NSNumber? { swift.backoff as NSNumber? }

    @objc
    public init(changes: NSNumber, backoff: NSNumber?) {
        self.swift = Files.ListFolderLongpollResult(changes: changes.boolValue, backoff: backoff?.uint64Value)
    }

    let swift: Files.ListFolderLongpollResult

    public init(swift: Files.ListFolderLongpollResult) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible ListFolderResult struct
@objc
public class DBXFilesListFolderResult: NSObject {
    /// The files and (direct) subfolders in the folder.
    @objc
    public var entries: [DBXFilesMetadata] {
        swift.entries.map {
            DBXFilesMetadata.wrapPreservingSubtypes(swift: $0)
        }
    }

    /// Pass the cursor into listFolderContinue to see what's changed in the folder since your previous query.
    @objc
    public var cursor: String { swift.cursor }
    /// If true, then there are more entries available. Pass the cursor to listFolderContinue to retrieve the rest.
    @objc
    public var hasMore: NSNumber { swift.hasMore as NSNumber }

    @objc
    public init(entries: [DBXFilesMetadata], cursor: String, hasMore: NSNumber) {
        self.swift = Files.ListFolderResult(entries: entries.map(\.swift), cursor: cursor, hasMore: hasMore.boolValue)
    }

    let swift: Files.ListFolderResult

    public init(swift: Files.ListFolderResult) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible ListRevisionsArg struct
@objc
public class DBXFilesListRevisionsArg: NSObject {
    /// The path to the file you want to see the revisions of.
    @objc
    public var path: String { swift.path }
    /// Determines the behavior of the API in listing the revisions for a given file path or id.
    @objc
    public var mode: DBXFilesListRevisionsMode { DBXFilesListRevisionsMode(swift: swift.mode) }
    /// The maximum number of revision entries returned.
    @objc
    public var limit: NSNumber { swift.limit as NSNumber }

    @objc
    public init(path: String, mode: DBXFilesListRevisionsMode, limit: NSNumber) {
        self.swift = Files.ListRevisionsArg(path: path, mode: mode.swift, limit: limit.uint64Value)
    }

    let swift: Files.ListRevisionsArg

    public init(swift: Files.ListRevisionsArg) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible ListRevisionsError union
@objc
public class DBXFilesListRevisionsError: NSObject {
    let swift: Files.ListRevisionsError

    public init(swift: Files.ListRevisionsError) {
        self.swift = swift
    }

    public static func factory(swift: Files.ListRevisionsError) -> DBXFilesListRevisionsError {
        switch swift {
        case .path(let swiftArg):
            let arg = DBXFilesLookupError(swift: swiftArg)
            return DBXFilesListRevisionsErrorPath(arg)
        case .other:
            return DBXFilesListRevisionsErrorOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asPath: DBXFilesListRevisionsErrorPath? {
        self as? DBXFilesListRevisionsErrorPath
    }

    @objc
    public var asOther: DBXFilesListRevisionsErrorOther? {
        self as? DBXFilesListRevisionsErrorOther
    }
}

/// An unspecified error.
@objc
public class DBXFilesListRevisionsErrorPath: DBXFilesListRevisionsError {
    @objc
    public var path: DBXFilesLookupError

    @objc
    public init(_ arg: DBXFilesLookupError) {
        self.path = arg
        let swift = Files.ListRevisionsError.path(arg.swift)
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXFilesListRevisionsErrorOther: DBXFilesListRevisionsError {
    @objc
    public init() {
        let swift = Files.ListRevisionsError.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible ListRevisionsMode union
@objc
public class DBXFilesListRevisionsMode: NSObject {
    let swift: Files.ListRevisionsMode

    public init(swift: Files.ListRevisionsMode) {
        self.swift = swift
    }

    public static func factory(swift: Files.ListRevisionsMode) -> DBXFilesListRevisionsMode {
        switch swift {
        case .path:
            return DBXFilesListRevisionsModePath()
        case .id:
            return DBXFilesListRevisionsModeId()
        case .other:
            return DBXFilesListRevisionsModeOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asPath: DBXFilesListRevisionsModePath? {
        self as? DBXFilesListRevisionsModePath
    }

    @objc
    public var asId: DBXFilesListRevisionsModeId? {
        self as? DBXFilesListRevisionsModeId
    }

    @objc
    public var asOther: DBXFilesListRevisionsModeOther? {
        self as? DBXFilesListRevisionsModeOther
    }
}

/// Returns revisions with the same file path as identified by the latest file entry at the given file path or
/// id.
@objc
public class DBXFilesListRevisionsModePath: DBXFilesListRevisionsMode {
    @objc
    public init() {
        let swift = Files.ListRevisionsMode.path
        super.init(swift: swift)
    }
}

/// Returns revisions with the same file id as identified by the latest file entry at the given file path or id.
@objc
public class DBXFilesListRevisionsModeId: DBXFilesListRevisionsMode {
    @objc
    public init() {
        let swift = Files.ListRevisionsMode.id
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXFilesListRevisionsModeOther: DBXFilesListRevisionsMode {
    @objc
    public init() {
        let swift = Files.ListRevisionsMode.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible ListRevisionsResult struct
@objc
public class DBXFilesListRevisionsResult: NSObject {
    /// If the file identified by the latest revision in the response is either deleted or moved.
    @objc
    public var isDeleted: NSNumber { swift.isDeleted as NSNumber }
    /// The time of deletion if the file was deleted.
    @objc
    public var serverDeleted: Date? { swift.serverDeleted }
    /// The revisions for the file. Only revisions that are not deleted will show up here.
    @objc
    public var entries: [DBXFilesFileMetadata] { swift.entries.map { DBXFilesFileMetadata(swift: $0) } }

    @objc
    public init(isDeleted: NSNumber, entries: [DBXFilesFileMetadata], serverDeleted: Date?) {
        self.swift = Files.ListRevisionsResult(isDeleted: isDeleted.boolValue, entries: entries.map(\.subSwift), serverDeleted: serverDeleted)
    }

    let swift: Files.ListRevisionsResult

    public init(swift: Files.ListRevisionsResult) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible LockConflictError struct
@objc
public class DBXFilesLockConflictError: NSObject {
    /// The lock that caused the conflict.
    @objc
    public var lock: DBXFilesFileLock { DBXFilesFileLock(swift: swift.lock) }

    @objc
    public init(lock: DBXFilesFileLock) {
        self.swift = Files.LockConflictError(lock: lock.swift)
    }

    let swift: Files.LockConflictError

    public init(swift: Files.LockConflictError) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible LockFileArg struct
@objc
public class DBXFilesLockFileArg: NSObject {
    /// Path in the user's Dropbox to a file.
    @objc
    public var path: String { swift.path }

    @objc
    public init(path: String) {
        self.swift = Files.LockFileArg(path: path)
    }

    let swift: Files.LockFileArg

    public init(swift: Files.LockFileArg) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible LockFileBatchArg struct
@objc
public class DBXFilesLockFileBatchArg: NSObject {
    /// List of 'entries'. Each 'entry' contains a path of the file which will be locked or queried. Duplicate path
    /// arguments in the batch are considered only once.
    @objc
    public var entries: [DBXFilesLockFileArg] { swift.entries.map { DBXFilesLockFileArg(swift: $0) } }

    @objc
    public init(entries: [DBXFilesLockFileArg]) {
        self.swift = Files.LockFileBatchArg(entries: entries.map(\.swift))
    }

    let swift: Files.LockFileBatchArg

    public init(swift: Files.LockFileBatchArg) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible LockFileBatchResult struct
@objc
public class DBXFilesLockFileBatchResult: DBXFilesFileOpsResult {
    /// Each Entry in the 'entries' will have '.tag' with the operation status (e.g. success), the metadata for the
    /// file and the lock state after the operation.
    @objc
    public var entries: [DBXFilesLockFileResultEntry] { subSwift.entries.map { DBXFilesLockFileResultEntry(swift: $0) } }

    @objc
    public init(entries: [DBXFilesLockFileResultEntry]) {
        let swift = Files.LockFileBatchResult(entries: entries.map(\.swift))
        self.subSwift = swift
        super.init(swift: swift)
    }

    let subSwift: Files.LockFileBatchResult

    public init(swift: Files.LockFileBatchResult) {
        self.subSwift = swift
        super.init(swift: swift)
    }

    @objc
    public override var description: String { subSwift.description }
}

/// Objective-C compatible LockFileError union
@objc
public class DBXFilesLockFileError: NSObject {
    let swift: Files.LockFileError

    public init(swift: Files.LockFileError) {
        self.swift = swift
    }

    public static func factory(swift: Files.LockFileError) -> DBXFilesLockFileError {
        switch swift {
        case .pathLookup(let swiftArg):
            let arg = DBXFilesLookupError(swift: swiftArg)
            return DBXFilesLockFileErrorPathLookup(arg)
        case .tooManyWriteOperations:
            return DBXFilesLockFileErrorTooManyWriteOperations()
        case .tooManyFiles:
            return DBXFilesLockFileErrorTooManyFiles()
        case .noWritePermission:
            return DBXFilesLockFileErrorNoWritePermission()
        case .cannotBeLocked:
            return DBXFilesLockFileErrorCannotBeLocked()
        case .fileNotShared:
            return DBXFilesLockFileErrorFileNotShared()
        case .lockConflict(let swiftArg):
            let arg = DBXFilesLockConflictError(swift: swiftArg)
            return DBXFilesLockFileErrorLockConflict(arg)
        case .internalError:
            return DBXFilesLockFileErrorInternalError()
        case .other:
            return DBXFilesLockFileErrorOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asPathLookup: DBXFilesLockFileErrorPathLookup? {
        self as? DBXFilesLockFileErrorPathLookup
    }

    @objc
    public var asTooManyWriteOperations: DBXFilesLockFileErrorTooManyWriteOperations? {
        self as? DBXFilesLockFileErrorTooManyWriteOperations
    }

    @objc
    public var asTooManyFiles: DBXFilesLockFileErrorTooManyFiles? {
        self as? DBXFilesLockFileErrorTooManyFiles
    }

    @objc
    public var asNoWritePermission: DBXFilesLockFileErrorNoWritePermission? {
        self as? DBXFilesLockFileErrorNoWritePermission
    }

    @objc
    public var asCannotBeLocked: DBXFilesLockFileErrorCannotBeLocked? {
        self as? DBXFilesLockFileErrorCannotBeLocked
    }

    @objc
    public var asFileNotShared: DBXFilesLockFileErrorFileNotShared? {
        self as? DBXFilesLockFileErrorFileNotShared
    }

    @objc
    public var asLockConflict: DBXFilesLockFileErrorLockConflict? {
        self as? DBXFilesLockFileErrorLockConflict
    }

    @objc
    public var asInternalError: DBXFilesLockFileErrorInternalError? {
        self as? DBXFilesLockFileErrorInternalError
    }

    @objc
    public var asOther: DBXFilesLockFileErrorOther? {
        self as? DBXFilesLockFileErrorOther
    }
}

/// Could not find the specified resource.
@objc
public class DBXFilesLockFileErrorPathLookup: DBXFilesLockFileError {
    @objc
    public var pathLookup: DBXFilesLookupError

    @objc
    public init(_ arg: DBXFilesLookupError) {
        self.pathLookup = arg
        let swift = Files.LockFileError.pathLookup(arg.swift)
        super.init(swift: swift)
    }
}

/// There are too many write operations in user's Dropbox. Please retry this request.
@objc
public class DBXFilesLockFileErrorTooManyWriteOperations: DBXFilesLockFileError {
    @objc
    public init() {
        let swift = Files.LockFileError.tooManyWriteOperations
        super.init(swift: swift)
    }
}

/// There are too many files in one request. Please retry with fewer files.
@objc
public class DBXFilesLockFileErrorTooManyFiles: DBXFilesLockFileError {
    @objc
    public init() {
        let swift = Files.LockFileError.tooManyFiles
        super.init(swift: swift)
    }
}

/// The user does not have permissions to change the lock state or access the file.
@objc
public class DBXFilesLockFileErrorNoWritePermission: DBXFilesLockFileError {
    @objc
    public init() {
        let swift = Files.LockFileError.noWritePermission
        super.init(swift: swift)
    }
}

/// Item is a type that cannot be locked.
@objc
public class DBXFilesLockFileErrorCannotBeLocked: DBXFilesLockFileError {
    @objc
    public init() {
        let swift = Files.LockFileError.cannotBeLocked
        super.init(swift: swift)
    }
}

/// Requested file is not currently shared.
@objc
public class DBXFilesLockFileErrorFileNotShared: DBXFilesLockFileError {
    @objc
    public init() {
        let swift = Files.LockFileError.fileNotShared
        super.init(swift: swift)
    }
}

/// The user action conflicts with an existing lock on the file.
@objc
public class DBXFilesLockFileErrorLockConflict: DBXFilesLockFileError {
    @objc
    public var lockConflict: DBXFilesLockConflictError

    @objc
    public init(_ arg: DBXFilesLockConflictError) {
        self.lockConflict = arg
        let swift = Files.LockFileError.lockConflict(arg.swift)
        super.init(swift: swift)
    }
}

/// Something went wrong with the job on Dropbox's end. You'll need to verify that the action you were taking
/// succeeded, and if not, try again. This should happen very rarely.
@objc
public class DBXFilesLockFileErrorInternalError: DBXFilesLockFileError {
    @objc
    public init() {
        let swift = Files.LockFileError.internalError
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXFilesLockFileErrorOther: DBXFilesLockFileError {
    @objc
    public init() {
        let swift = Files.LockFileError.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible LockFileResult struct
@objc
public class DBXFilesLockFileResult: NSObject {
    /// Metadata of the file.
    @objc
    public var metadata: DBXFilesMetadata {
        DBXFilesMetadata.wrapPreservingSubtypes(swift: swift.metadata)
    }

    /// The file lock state after the operation.
    @objc
    public var lock: DBXFilesFileLock { DBXFilesFileLock(swift: swift.lock) }

    @objc
    public init(metadata: DBXFilesMetadata, lock: DBXFilesFileLock) {
        self.swift = Files.LockFileResult(metadata: metadata.swift, lock: lock.swift)
    }

    let swift: Files.LockFileResult

    public init(swift: Files.LockFileResult) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible LockFileResultEntry union
@objc
public class DBXFilesLockFileResultEntry: NSObject {
    let swift: Files.LockFileResultEntry

    public init(swift: Files.LockFileResultEntry) {
        self.swift = swift
    }

    public static func factory(swift: Files.LockFileResultEntry) -> DBXFilesLockFileResultEntry {
        switch swift {
        case .success(let swiftArg):
            let arg = DBXFilesLockFileResult(swift: swiftArg)
            return DBXFilesLockFileResultEntrySuccess(arg)
        case .failure(let swiftArg):
            let arg = DBXFilesLockFileError(swift: swiftArg)
            return DBXFilesLockFileResultEntryFailure(arg)
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asSuccess: DBXFilesLockFileResultEntrySuccess? {
        self as? DBXFilesLockFileResultEntrySuccess
    }

    @objc
    public var asFailure: DBXFilesLockFileResultEntryFailure? {
        self as? DBXFilesLockFileResultEntryFailure
    }
}

/// An unspecified error.
@objc
public class DBXFilesLockFileResultEntrySuccess: DBXFilesLockFileResultEntry {
    @objc
    public var success: DBXFilesLockFileResult

    @objc
    public init(_ arg: DBXFilesLockFileResult) {
        self.success = arg
        let swift = Files.LockFileResultEntry.success(arg.swift)
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXFilesLockFileResultEntryFailure: DBXFilesLockFileResultEntry {
    @objc
    public var failure: DBXFilesLockFileError

    @objc
    public init(_ arg: DBXFilesLockFileError) {
        self.failure = arg
        let swift = Files.LockFileResultEntry.failure(arg.swift)
        super.init(swift: swift)
    }
}

/// Objective-C compatible LookupError union
@objc
public class DBXFilesLookupError: NSObject {
    let swift: Files.LookupError

    public init(swift: Files.LookupError) {
        self.swift = swift
    }

    public static func factory(swift: Files.LookupError) -> DBXFilesLookupError {
        switch swift {
        case .malformedPath(let swiftArg):
            let arg = swiftArg
            return DBXFilesLookupErrorMalformedPath(arg)
        case .notFound:
            return DBXFilesLookupErrorNotFound()
        case .notFile:
            return DBXFilesLookupErrorNotFile()
        case .notFolder:
            return DBXFilesLookupErrorNotFolder()
        case .restrictedContent:
            return DBXFilesLookupErrorRestrictedContent()
        case .unsupportedContentType:
            return DBXFilesLookupErrorUnsupportedContentType()
        case .locked:
            return DBXFilesLookupErrorLocked()
        case .other:
            return DBXFilesLookupErrorOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asMalformedPath: DBXFilesLookupErrorMalformedPath? {
        self as? DBXFilesLookupErrorMalformedPath
    }

    @objc
    public var asNotFound: DBXFilesLookupErrorNotFound? {
        self as? DBXFilesLookupErrorNotFound
    }

    @objc
    public var asNotFile: DBXFilesLookupErrorNotFile? {
        self as? DBXFilesLookupErrorNotFile
    }

    @objc
    public var asNotFolder: DBXFilesLookupErrorNotFolder? {
        self as? DBXFilesLookupErrorNotFolder
    }

    @objc
    public var asRestrictedContent: DBXFilesLookupErrorRestrictedContent? {
        self as? DBXFilesLookupErrorRestrictedContent
    }

    @objc
    public var asUnsupportedContentType: DBXFilesLookupErrorUnsupportedContentType? {
        self as? DBXFilesLookupErrorUnsupportedContentType
    }

    @objc
    public var asLocked: DBXFilesLookupErrorLocked? {
        self as? DBXFilesLookupErrorLocked
    }

    @objc
    public var asOther: DBXFilesLookupErrorOther? {
        self as? DBXFilesLookupErrorOther
    }
}

/// The given path does not satisfy the required path format. Please refer to the Path formats documentation
/// https://www.dropbox.com/developers/documentation/http/documentation#path-formats for more
/// information.
@objc
public class DBXFilesLookupErrorMalformedPath: DBXFilesLookupError {
    @objc
    public var malformedPath: String?

    @objc
    public init(_ arg: String?) {
        self.malformedPath = arg
        let swift = Files.LookupError.malformedPath(arg)
        super.init(swift: swift)
    }
}

/// There is nothing at the given path.
@objc
public class DBXFilesLookupErrorNotFound: DBXFilesLookupError {
    @objc
    public init() {
        let swift = Files.LookupError.notFound
        super.init(swift: swift)
    }
}

/// We were expecting a file, but the given path refers to something that isn't a file.
@objc
public class DBXFilesLookupErrorNotFile: DBXFilesLookupError {
    @objc
    public init() {
        let swift = Files.LookupError.notFile
        super.init(swift: swift)
    }
}

/// We were expecting a folder, but the given path refers to something that isn't a folder.
@objc
public class DBXFilesLookupErrorNotFolder: DBXFilesLookupError {
    @objc
    public init() {
        let swift = Files.LookupError.notFolder
        super.init(swift: swift)
    }
}

/// The file cannot be transferred because the content is restricted. For example, we might restrict a file due
/// to legal requirements.
@objc
public class DBXFilesLookupErrorRestrictedContent: DBXFilesLookupError {
    @objc
    public init() {
        let swift = Files.LookupError.restrictedContent
        super.init(swift: swift)
    }
}

/// This operation is not supported for this content type.
@objc
public class DBXFilesLookupErrorUnsupportedContentType: DBXFilesLookupError {
    @objc
    public init() {
        let swift = Files.LookupError.unsupportedContentType
        super.init(swift: swift)
    }
}

/// The given path is locked.
@objc
public class DBXFilesLookupErrorLocked: DBXFilesLookupError {
    @objc
    public init() {
        let swift = Files.LookupError.locked
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXFilesLookupErrorOther: DBXFilesLookupError {
    @objc
    public init() {
        let swift = Files.LookupError.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible MediaInfo union
@objc
public class DBXFilesMediaInfo: NSObject {
    let swift: Files.MediaInfo

    public init(swift: Files.MediaInfo) {
        self.swift = swift
    }

    public static func factory(swift: Files.MediaInfo) -> DBXFilesMediaInfo {
        switch swift {
        case .pending:
            return DBXFilesMediaInfoPending()
        case .metadata(let swiftArg):
            let arg = DBXFilesMediaMetadata(swift: swiftArg)
            return DBXFilesMediaInfoMetadata(arg)
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asPending: DBXFilesMediaInfoPending? {
        self as? DBXFilesMediaInfoPending
    }

    @objc
    public var asMetadata: DBXFilesMediaInfoMetadata? {
        self as? DBXFilesMediaInfoMetadata
    }
}

/// Indicate the photo/video is still under processing and metadata is not available yet.
@objc
public class DBXFilesMediaInfoPending: DBXFilesMediaInfo {
    @objc
    public init() {
        let swift = Files.MediaInfo.pending
        super.init(swift: swift)
    }
}

/// The metadata for the photo/video.
@objc
public class DBXFilesMediaInfoMetadata: DBXFilesMediaInfo {
    @objc
    public var metadata: DBXFilesMediaMetadata

    @objc
    public init(_ arg: DBXFilesMediaMetadata) {
        self.metadata = arg
        let swift = Files.MediaInfo.metadata(arg.swift)
        super.init(swift: swift)
    }
}

/// Metadata for a photo or video.
@objc
public class DBXFilesMediaMetadata: NSObject {
    /// Dimension of the photo/video.
    @objc
    public var dimensions: DBXFilesDimensions? { guard let swift = swift.dimensions else { return nil }
        return DBXFilesDimensions(swift: swift)
    }

    /// The GPS coordinate of the photo/video.
    @objc
    public var location: DBXFilesGpsCoordinates? { guard let swift = swift.location else { return nil }
        return DBXFilesGpsCoordinates(swift: swift)
    }

    /// The timestamp when the photo/video is taken.
    @objc
    public var timeTaken: Date? { swift.timeTaken }

    @objc
    public init(dimensions: DBXFilesDimensions?, location: DBXFilesGpsCoordinates?, timeTaken: Date?) {
        self.swift = Files.MediaMetadata(dimensions: dimensions?.swift, location: location?.swift, timeTaken: timeTaken)
    }

    let swift: Files.MediaMetadata

    public init(swift: Files.MediaMetadata) {
        self.swift = swift
    }

    public static func wrapPreservingSubtypes(swift: Files.MediaMetadata) -> DBXFilesMediaMetadata {
        switch swift {
        case let photoMetadata as Files.PhotoMetadata:
            return DBXFilesPhotoMetadata(swift: photoMetadata)
        case let videoMetadata as Files.VideoMetadata:
            return DBXFilesVideoMetadata(swift: videoMetadata)
        default:
            return DBXFilesMediaMetadata(swift: swift)
        }
    }

    @objc
    public override var description: String { swift.description }
}

/// Metadata for a file, folder or other resource types.
@objc
public class DBXFilesMetadataV2: NSObject {
    let swift: Files.MetadataV2

    public init(swift: Files.MetadataV2) {
        self.swift = swift
    }

    public static func factory(swift: Files.MetadataV2) -> DBXFilesMetadataV2 {
        switch swift {
        case .metadata(let swiftArg):
            let arg = DBXFilesMetadata(swift: swiftArg)
            return DBXFilesMetadataV2Metadata(arg)
        case .other:
            return DBXFilesMetadataV2Other()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asMetadata: DBXFilesMetadataV2Metadata? {
        self as? DBXFilesMetadataV2Metadata
    }

    @objc
    public var asOther: DBXFilesMetadataV2Other? {
        self as? DBXFilesMetadataV2Other
    }
}

/// An unspecified error.
@objc
public class DBXFilesMetadataV2Metadata: DBXFilesMetadataV2 {
    @objc
    public var metadata: DBXFilesMetadata

    @objc
    public init(_ arg: DBXFilesMetadata) {
        self.metadata = arg
        let swift = Files.MetadataV2.metadata(arg.swift)
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXFilesMetadataV2Other: DBXFilesMetadataV2 {
    @objc
    public init() {
        let swift = Files.MetadataV2.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible MinimalFileLinkMetadata struct
@objc
public class DBXFilesMinimalFileLinkMetadata: NSObject {
    /// URL of the shared link.
    @objc
    public var url: String { swift.url }
    /// Unique identifier for the linked file.
    @objc
    public var id: String? { swift.id }
    /// Full path in the user's Dropbox. This always starts with a slash. This field will only be present only if
    /// the linked file is in the authenticated user's Dropbox.
    @objc
    public var path: String? { swift.path }
    /// A unique identifier for the current revision of a file. This field is the same rev as elsewhere in the API
    /// and can be used to detect changes and avoid conflicts.
    @objc
    public var rev: String { swift.rev }

    @objc
    public init(url: String, rev: String, id: String?, path: String?) {
        self.swift = Files.MinimalFileLinkMetadata(url: url, rev: rev, id: id, path: path)
    }

    let swift: Files.MinimalFileLinkMetadata

    public init(swift: Files.MinimalFileLinkMetadata) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible RelocationBatchArgBase struct
@objc
public class DBXFilesRelocationBatchArgBase: NSObject {
    /// List of entries to be moved or copied. Each entry is RelocationPath.
    @objc
    public var entries: [DBXFilesRelocationPath] { swift.entries.map { DBXFilesRelocationPath(swift: $0) } }
    /// If there's a conflict with any file, have the Dropbox server try to autorename that file to avoid the
    /// conflict.
    @objc
    public var autorename: NSNumber { swift.autorename as NSNumber }

    @objc
    public init(entries: [DBXFilesRelocationPath], autorename: NSNumber) {
        self.swift = Files.RelocationBatchArgBase(entries: entries.map(\.swift), autorename: autorename.boolValue)
    }

    let swift: Files.RelocationBatchArgBase

    public init(swift: Files.RelocationBatchArgBase) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible MoveBatchArg struct
@objc
public class DBXFilesMoveBatchArg: DBXFilesRelocationBatchArgBase {
    /// Allow moves by owner even if it would result in an ownership transfer for the content being moved. This does
    /// not apply to copies.
    @objc
    public var allowOwnershipTransfer: NSNumber { subSwift.allowOwnershipTransfer as NSNumber }

    @objc
    public init(entries: [DBXFilesRelocationPath], autorename: NSNumber, allowOwnershipTransfer: NSNumber) {
        let swift = Files.MoveBatchArg(
            entries: entries.map(\.swift),
            autorename: autorename.boolValue,
            allowOwnershipTransfer: allowOwnershipTransfer.boolValue
        )
        self.subSwift = swift
        super.init(swift: swift)
    }

    let subSwift: Files.MoveBatchArg

    public init(swift: Files.MoveBatchArg) {
        self.subSwift = swift
        super.init(swift: swift)
    }

    @objc
    public override var description: String { subSwift.description }
}

/// Objective-C compatible MoveIntoFamilyError union
@objc
public class DBXFilesMoveIntoFamilyError: NSObject {
    let swift: Files.MoveIntoFamilyError

    public init(swift: Files.MoveIntoFamilyError) {
        self.swift = swift
    }

    public static func factory(swift: Files.MoveIntoFamilyError) -> DBXFilesMoveIntoFamilyError {
        switch swift {
        case .isSharedFolder:
            return DBXFilesMoveIntoFamilyErrorIsSharedFolder()
        case .other:
            return DBXFilesMoveIntoFamilyErrorOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asIsSharedFolder: DBXFilesMoveIntoFamilyErrorIsSharedFolder? {
        self as? DBXFilesMoveIntoFamilyErrorIsSharedFolder
    }

    @objc
    public var asOther: DBXFilesMoveIntoFamilyErrorOther? {
        self as? DBXFilesMoveIntoFamilyErrorOther
    }
}

/// Moving shared folder into Family Room folder is not allowed.
@objc
public class DBXFilesMoveIntoFamilyErrorIsSharedFolder: DBXFilesMoveIntoFamilyError {
    @objc
    public init() {
        let swift = Files.MoveIntoFamilyError.isSharedFolder
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXFilesMoveIntoFamilyErrorOther: DBXFilesMoveIntoFamilyError {
    @objc
    public init() {
        let swift = Files.MoveIntoFamilyError.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible MoveIntoVaultError union
@objc
public class DBXFilesMoveIntoVaultError: NSObject {
    let swift: Files.MoveIntoVaultError

    public init(swift: Files.MoveIntoVaultError) {
        self.swift = swift
    }

    public static func factory(swift: Files.MoveIntoVaultError) -> DBXFilesMoveIntoVaultError {
        switch swift {
        case .isSharedFolder:
            return DBXFilesMoveIntoVaultErrorIsSharedFolder()
        case .other:
            return DBXFilesMoveIntoVaultErrorOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asIsSharedFolder: DBXFilesMoveIntoVaultErrorIsSharedFolder? {
        self as? DBXFilesMoveIntoVaultErrorIsSharedFolder
    }

    @objc
    public var asOther: DBXFilesMoveIntoVaultErrorOther? {
        self as? DBXFilesMoveIntoVaultErrorOther
    }
}

/// Moving shared folder into Vault is not allowed.
@objc
public class DBXFilesMoveIntoVaultErrorIsSharedFolder: DBXFilesMoveIntoVaultError {
    @objc
    public init() {
        let swift = Files.MoveIntoVaultError.isSharedFolder
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXFilesMoveIntoVaultErrorOther: DBXFilesMoveIntoVaultError {
    @objc
    public init() {
        let swift = Files.MoveIntoVaultError.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible PaperContentError union
@objc
public class DBXFilesPaperContentError: NSObject {
    let swift: Files.PaperContentError

    public init(swift: Files.PaperContentError) {
        self.swift = swift
    }

    public static func factory(swift: Files.PaperContentError) -> DBXFilesPaperContentError {
        switch swift {
        case .insufficientPermissions:
            return DBXFilesPaperContentErrorInsufficientPermissions()
        case .contentMalformed:
            return DBXFilesPaperContentErrorContentMalformed()
        case .docLengthExceeded:
            return DBXFilesPaperContentErrorDocLengthExceeded()
        case .imageSizeExceeded:
            return DBXFilesPaperContentErrorImageSizeExceeded()
        case .other:
            return DBXFilesPaperContentErrorOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asInsufficientPermissions: DBXFilesPaperContentErrorInsufficientPermissions? {
        self as? DBXFilesPaperContentErrorInsufficientPermissions
    }

    @objc
    public var asContentMalformed: DBXFilesPaperContentErrorContentMalformed? {
        self as? DBXFilesPaperContentErrorContentMalformed
    }

    @objc
    public var asDocLengthExceeded: DBXFilesPaperContentErrorDocLengthExceeded? {
        self as? DBXFilesPaperContentErrorDocLengthExceeded
    }

    @objc
    public var asImageSizeExceeded: DBXFilesPaperContentErrorImageSizeExceeded? {
        self as? DBXFilesPaperContentErrorImageSizeExceeded
    }

    @objc
    public var asOther: DBXFilesPaperContentErrorOther? {
        self as? DBXFilesPaperContentErrorOther
    }
}

/// Your account does not have permissions to edit Paper docs.
@objc
public class DBXFilesPaperContentErrorInsufficientPermissions: DBXFilesPaperContentError {
    @objc
    public init() {
        let swift = Files.PaperContentError.insufficientPermissions
        super.init(swift: swift)
    }
}

/// The provided content was malformed and cannot be imported to Paper.
@objc
public class DBXFilesPaperContentErrorContentMalformed: DBXFilesPaperContentError {
    @objc
    public init() {
        let swift = Files.PaperContentError.contentMalformed
        super.init(swift: swift)
    }
}

/// The Paper doc would be too large, split the content into multiple docs.
@objc
public class DBXFilesPaperContentErrorDocLengthExceeded: DBXFilesPaperContentError {
    @objc
    public init() {
        let swift = Files.PaperContentError.docLengthExceeded
        super.init(swift: swift)
    }
}

/// The imported document contains an image that is too large. The current limit is 1MB. This only applies to
/// HTML with data URI.
@objc
public class DBXFilesPaperContentErrorImageSizeExceeded: DBXFilesPaperContentError {
    @objc
    public init() {
        let swift = Files.PaperContentError.imageSizeExceeded
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXFilesPaperContentErrorOther: DBXFilesPaperContentError {
    @objc
    public init() {
        let swift = Files.PaperContentError.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible PaperCreateArg struct
@objc
public class DBXFilesPaperCreateArg: NSObject {
    /// The fully qualified path to the location in the user's Dropbox where the Paper Doc should be created. This
    /// should include the document's title and end with .paper.
    @objc
    public var path: String { swift.path }
    /// The format of the provided data.
    @objc
    public var importFormat: DBXFilesImportFormat { DBXFilesImportFormat(swift: swift.importFormat) }

    @objc
    public init(path: String, importFormat: DBXFilesImportFormat) {
        self.swift = Files.PaperCreateArg(path: path, importFormat: importFormat.swift)
    }

    let swift: Files.PaperCreateArg

    public init(swift: Files.PaperCreateArg) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible PaperCreateError union
@objc
public class DBXFilesPaperCreateError: NSObject {
    let swift: Files.PaperCreateError

    public init(swift: Files.PaperCreateError) {
        self.swift = swift
    }

    public static func factory(swift: Files.PaperCreateError) -> DBXFilesPaperCreateError {
        switch swift {
        case .insufficientPermissions:
            return DBXFilesPaperCreateErrorInsufficientPermissions()
        case .contentMalformed:
            return DBXFilesPaperCreateErrorContentMalformed()
        case .docLengthExceeded:
            return DBXFilesPaperCreateErrorDocLengthExceeded()
        case .imageSizeExceeded:
            return DBXFilesPaperCreateErrorImageSizeExceeded()
        case .other:
            return DBXFilesPaperCreateErrorOther()
        case .invalidPath:
            return DBXFilesPaperCreateErrorInvalidPath()
        case .emailUnverified:
            return DBXFilesPaperCreateErrorEmailUnverified()
        case .invalidFileExtension:
            return DBXFilesPaperCreateErrorInvalidFileExtension()
        case .paperDisabled:
            return DBXFilesPaperCreateErrorPaperDisabled()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asInsufficientPermissions: DBXFilesPaperCreateErrorInsufficientPermissions? {
        self as? DBXFilesPaperCreateErrorInsufficientPermissions
    }

    @objc
    public var asContentMalformed: DBXFilesPaperCreateErrorContentMalformed? {
        self as? DBXFilesPaperCreateErrorContentMalformed
    }

    @objc
    public var asDocLengthExceeded: DBXFilesPaperCreateErrorDocLengthExceeded? {
        self as? DBXFilesPaperCreateErrorDocLengthExceeded
    }

    @objc
    public var asImageSizeExceeded: DBXFilesPaperCreateErrorImageSizeExceeded? {
        self as? DBXFilesPaperCreateErrorImageSizeExceeded
    }

    @objc
    public var asOther: DBXFilesPaperCreateErrorOther? {
        self as? DBXFilesPaperCreateErrorOther
    }

    @objc
    public var asInvalidPath: DBXFilesPaperCreateErrorInvalidPath? {
        self as? DBXFilesPaperCreateErrorInvalidPath
    }

    @objc
    public var asEmailUnverified: DBXFilesPaperCreateErrorEmailUnverified? {
        self as? DBXFilesPaperCreateErrorEmailUnverified
    }

    @objc
    public var asInvalidFileExtension: DBXFilesPaperCreateErrorInvalidFileExtension? {
        self as? DBXFilesPaperCreateErrorInvalidFileExtension
    }

    @objc
    public var asPaperDisabled: DBXFilesPaperCreateErrorPaperDisabled? {
        self as? DBXFilesPaperCreateErrorPaperDisabled
    }
}

/// Your account does not have permissions to edit Paper docs.
@objc
public class DBXFilesPaperCreateErrorInsufficientPermissions: DBXFilesPaperCreateError {
    @objc
    public init() {
        let swift = Files.PaperCreateError.insufficientPermissions
        super.init(swift: swift)
    }
}

/// The provided content was malformed and cannot be imported to Paper.
@objc
public class DBXFilesPaperCreateErrorContentMalformed: DBXFilesPaperCreateError {
    @objc
    public init() {
        let swift = Files.PaperCreateError.contentMalformed
        super.init(swift: swift)
    }
}

/// The Paper doc would be too large, split the content into multiple docs.
@objc
public class DBXFilesPaperCreateErrorDocLengthExceeded: DBXFilesPaperCreateError {
    @objc
    public init() {
        let swift = Files.PaperCreateError.docLengthExceeded
        super.init(swift: swift)
    }
}

/// The imported document contains an image that is too large. The current limit is 1MB. This only applies to
/// HTML with data URI.
@objc
public class DBXFilesPaperCreateErrorImageSizeExceeded: DBXFilesPaperCreateError {
    @objc
    public init() {
        let swift = Files.PaperCreateError.imageSizeExceeded
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXFilesPaperCreateErrorOther: DBXFilesPaperCreateError {
    @objc
    public init() {
        let swift = Files.PaperCreateError.other
        super.init(swift: swift)
    }
}

/// The file could not be saved to the specified location.
@objc
public class DBXFilesPaperCreateErrorInvalidPath: DBXFilesPaperCreateError {
    @objc
    public init() {
        let swift = Files.PaperCreateError.invalidPath
        super.init(swift: swift)
    }
}

/// The user's email must be verified to create Paper docs.
@objc
public class DBXFilesPaperCreateErrorEmailUnverified: DBXFilesPaperCreateError {
    @objc
    public init() {
        let swift = Files.PaperCreateError.emailUnverified
        super.init(swift: swift)
    }
}

/// The file path must end in .paper.
@objc
public class DBXFilesPaperCreateErrorInvalidFileExtension: DBXFilesPaperCreateError {
    @objc
    public init() {
        let swift = Files.PaperCreateError.invalidFileExtension
        super.init(swift: swift)
    }
}

/// Paper is disabled for your team.
@objc
public class DBXFilesPaperCreateErrorPaperDisabled: DBXFilesPaperCreateError {
    @objc
    public init() {
        let swift = Files.PaperCreateError.paperDisabled
        super.init(swift: swift)
    }
}

/// Objective-C compatible PaperCreateResult struct
@objc
public class DBXFilesPaperCreateResult: NSObject {
    /// URL to open the Paper Doc.
    @objc
    public var url: String { swift.url }
    /// The fully qualified path the Paper Doc was actually created at.
    @objc
    public var resultPath: String { swift.resultPath }
    /// The id to use in Dropbox APIs when referencing the Paper Doc.
    @objc
    public var fileId: String { swift.fileId }
    /// The current doc revision.
    @objc
    public var paperRevision: NSNumber { swift.paperRevision as NSNumber }

    @objc
    public init(url: String, resultPath: String, fileId: String, paperRevision: NSNumber) {
        self.swift = Files.PaperCreateResult(url: url, resultPath: resultPath, fileId: fileId, paperRevision: paperRevision.int64Value)
    }

    let swift: Files.PaperCreateResult

    public init(swift: Files.PaperCreateResult) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible PaperDocUpdatePolicy union
@objc
public class DBXFilesPaperDocUpdatePolicy: NSObject {
    let swift: Files.PaperDocUpdatePolicy

    public init(swift: Files.PaperDocUpdatePolicy) {
        self.swift = swift
    }

    public static func factory(swift: Files.PaperDocUpdatePolicy) -> DBXFilesPaperDocUpdatePolicy {
        switch swift {
        case .update:
            return DBXFilesPaperDocUpdatePolicyUpdate()
        case .overwrite:
            return DBXFilesPaperDocUpdatePolicyOverwrite()
        case .prepend:
            return DBXFilesPaperDocUpdatePolicyPrepend()
        case .append:
            return DBXFilesPaperDocUpdatePolicyAppend()
        case .other:
            return DBXFilesPaperDocUpdatePolicyOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asUpdate: DBXFilesPaperDocUpdatePolicyUpdate? {
        self as? DBXFilesPaperDocUpdatePolicyUpdate
    }

    @objc
    public var asOverwrite: DBXFilesPaperDocUpdatePolicyOverwrite? {
        self as? DBXFilesPaperDocUpdatePolicyOverwrite
    }

    @objc
    public var asPrepend: DBXFilesPaperDocUpdatePolicyPrepend? {
        self as? DBXFilesPaperDocUpdatePolicyPrepend
    }

    @objc
    public var asAppend: DBXFilesPaperDocUpdatePolicyAppend? {
        self as? DBXFilesPaperDocUpdatePolicyAppend
    }

    @objc
    public var asOther: DBXFilesPaperDocUpdatePolicyOther? {
        self as? DBXFilesPaperDocUpdatePolicyOther
    }
}

/// Sets the doc content to the provided content if the provided paper_revision matches the latest doc revision.
/// Otherwise, returns an error.
@objc
public class DBXFilesPaperDocUpdatePolicyUpdate: DBXFilesPaperDocUpdatePolicy {
    @objc
    public init() {
        let swift = Files.PaperDocUpdatePolicy.update
        super.init(swift: swift)
    }
}

/// Sets the doc content to the provided content without checking paper_revision.
@objc
public class DBXFilesPaperDocUpdatePolicyOverwrite: DBXFilesPaperDocUpdatePolicy {
    @objc
    public init() {
        let swift = Files.PaperDocUpdatePolicy.overwrite
        super.init(swift: swift)
    }
}

/// Adds the provided content to the beginning of the doc without checking paper_revision.
@objc
public class DBXFilesPaperDocUpdatePolicyPrepend: DBXFilesPaperDocUpdatePolicy {
    @objc
    public init() {
        let swift = Files.PaperDocUpdatePolicy.prepend
        super.init(swift: swift)
    }
}

/// Adds the provided content to the end of the doc without checking paper_revision.
@objc
public class DBXFilesPaperDocUpdatePolicyAppend: DBXFilesPaperDocUpdatePolicy {
    @objc
    public init() {
        let swift = Files.PaperDocUpdatePolicy.append
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXFilesPaperDocUpdatePolicyOther: DBXFilesPaperDocUpdatePolicy {
    @objc
    public init() {
        let swift = Files.PaperDocUpdatePolicy.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible PaperUpdateArg struct
@objc
public class DBXFilesPaperUpdateArg: NSObject {
    /// Path in the user's Dropbox to update. The path must correspond to a Paper doc or an error will be returned.
    @objc
    public var path: String { swift.path }
    /// The format of the provided data.
    @objc
    public var importFormat: DBXFilesImportFormat { DBXFilesImportFormat(swift: swift.importFormat) }
    /// How the provided content should be applied to the doc.
    @objc
    public var docUpdatePolicy: DBXFilesPaperDocUpdatePolicy { DBXFilesPaperDocUpdatePolicy(swift: swift.docUpdatePolicy) }
    /// The latest doc revision. Required when doc_update_policy is update. This value must match the current
    /// revision of the doc or error revision_mismatch will be returned.
    @objc
    public var paperRevision: NSNumber? { swift.paperRevision as NSNumber? }

    @objc
    public init(path: String, importFormat: DBXFilesImportFormat, docUpdatePolicy: DBXFilesPaperDocUpdatePolicy, paperRevision: NSNumber?) {
        self.swift = Files.PaperUpdateArg(
            path: path,
            importFormat: importFormat.swift,
            docUpdatePolicy: docUpdatePolicy.swift,
            paperRevision: paperRevision?.int64Value
        )
    }

    let swift: Files.PaperUpdateArg

    public init(swift: Files.PaperUpdateArg) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible PaperUpdateError union
@objc
public class DBXFilesPaperUpdateError: NSObject {
    let swift: Files.PaperUpdateError

    public init(swift: Files.PaperUpdateError) {
        self.swift = swift
    }

    public static func factory(swift: Files.PaperUpdateError) -> DBXFilesPaperUpdateError {
        switch swift {
        case .insufficientPermissions:
            return DBXFilesPaperUpdateErrorInsufficientPermissions()
        case .contentMalformed:
            return DBXFilesPaperUpdateErrorContentMalformed()
        case .docLengthExceeded:
            return DBXFilesPaperUpdateErrorDocLengthExceeded()
        case .imageSizeExceeded:
            return DBXFilesPaperUpdateErrorImageSizeExceeded()
        case .other:
            return DBXFilesPaperUpdateErrorOther()
        case .path(let swiftArg):
            let arg = DBXFilesLookupError(swift: swiftArg)
            return DBXFilesPaperUpdateErrorPath(arg)
        case .revisionMismatch:
            return DBXFilesPaperUpdateErrorRevisionMismatch()
        case .docArchived:
            return DBXFilesPaperUpdateErrorDocArchived()
        case .docDeleted:
            return DBXFilesPaperUpdateErrorDocDeleted()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asInsufficientPermissions: DBXFilesPaperUpdateErrorInsufficientPermissions? {
        self as? DBXFilesPaperUpdateErrorInsufficientPermissions
    }

    @objc
    public var asContentMalformed: DBXFilesPaperUpdateErrorContentMalformed? {
        self as? DBXFilesPaperUpdateErrorContentMalformed
    }

    @objc
    public var asDocLengthExceeded: DBXFilesPaperUpdateErrorDocLengthExceeded? {
        self as? DBXFilesPaperUpdateErrorDocLengthExceeded
    }

    @objc
    public var asImageSizeExceeded: DBXFilesPaperUpdateErrorImageSizeExceeded? {
        self as? DBXFilesPaperUpdateErrorImageSizeExceeded
    }

    @objc
    public var asOther: DBXFilesPaperUpdateErrorOther? {
        self as? DBXFilesPaperUpdateErrorOther
    }

    @objc
    public var asPath: DBXFilesPaperUpdateErrorPath? {
        self as? DBXFilesPaperUpdateErrorPath
    }

    @objc
    public var asRevisionMismatch: DBXFilesPaperUpdateErrorRevisionMismatch? {
        self as? DBXFilesPaperUpdateErrorRevisionMismatch
    }

    @objc
    public var asDocArchived: DBXFilesPaperUpdateErrorDocArchived? {
        self as? DBXFilesPaperUpdateErrorDocArchived
    }

    @objc
    public var asDocDeleted: DBXFilesPaperUpdateErrorDocDeleted? {
        self as? DBXFilesPaperUpdateErrorDocDeleted
    }
}

/// Your account does not have permissions to edit Paper docs.
@objc
public class DBXFilesPaperUpdateErrorInsufficientPermissions: DBXFilesPaperUpdateError {
    @objc
    public init() {
        let swift = Files.PaperUpdateError.insufficientPermissions
        super.init(swift: swift)
    }
}

/// The provided content was malformed and cannot be imported to Paper.
@objc
public class DBXFilesPaperUpdateErrorContentMalformed: DBXFilesPaperUpdateError {
    @objc
    public init() {
        let swift = Files.PaperUpdateError.contentMalformed
        super.init(swift: swift)
    }
}

/// The Paper doc would be too large, split the content into multiple docs.
@objc
public class DBXFilesPaperUpdateErrorDocLengthExceeded: DBXFilesPaperUpdateError {
    @objc
    public init() {
        let swift = Files.PaperUpdateError.docLengthExceeded
        super.init(swift: swift)
    }
}

/// The imported document contains an image that is too large. The current limit is 1MB. This only applies to
/// HTML with data URI.
@objc
public class DBXFilesPaperUpdateErrorImageSizeExceeded: DBXFilesPaperUpdateError {
    @objc
    public init() {
        let swift = Files.PaperUpdateError.imageSizeExceeded
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXFilesPaperUpdateErrorOther: DBXFilesPaperUpdateError {
    @objc
    public init() {
        let swift = Files.PaperUpdateError.other
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXFilesPaperUpdateErrorPath: DBXFilesPaperUpdateError {
    @objc
    public var path: DBXFilesLookupError

    @objc
    public init(_ arg: DBXFilesLookupError) {
        self.path = arg
        let swift = Files.PaperUpdateError.path(arg.swift)
        super.init(swift: swift)
    }
}

/// The provided revision does not match the document head.
@objc
public class DBXFilesPaperUpdateErrorRevisionMismatch: DBXFilesPaperUpdateError {
    @objc
    public init() {
        let swift = Files.PaperUpdateError.revisionMismatch
        super.init(swift: swift)
    }
}

/// This operation is not allowed on archived Paper docs.
@objc
public class DBXFilesPaperUpdateErrorDocArchived: DBXFilesPaperUpdateError {
    @objc
    public init() {
        let swift = Files.PaperUpdateError.docArchived
        super.init(swift: swift)
    }
}

/// This operation is not allowed on deleted Paper docs.
@objc
public class DBXFilesPaperUpdateErrorDocDeleted: DBXFilesPaperUpdateError {
    @objc
    public init() {
        let swift = Files.PaperUpdateError.docDeleted
        super.init(swift: swift)
    }
}

/// Objective-C compatible PaperUpdateResult struct
@objc
public class DBXFilesPaperUpdateResult: NSObject {
    /// The current doc revision.
    @objc
    public var paperRevision: NSNumber { swift.paperRevision as NSNumber }

    @objc
    public init(paperRevision: NSNumber) {
        self.swift = Files.PaperUpdateResult(paperRevision: paperRevision.int64Value)
    }

    let swift: Files.PaperUpdateResult

    public init(swift: Files.PaperUpdateResult) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible PathOrLink union
@objc
public class DBXFilesPathOrLink: NSObject {
    let swift: Files.PathOrLink

    public init(swift: Files.PathOrLink) {
        self.swift = swift
    }

    public static func factory(swift: Files.PathOrLink) -> DBXFilesPathOrLink {
        switch swift {
        case .path(let swiftArg):
            let arg = swiftArg
            return DBXFilesPathOrLinkPath(arg)
        case .link(let swiftArg):
            let arg = DBXFilesSharedLinkFileInfo(swift: swiftArg)
            return DBXFilesPathOrLinkLink(arg)
        case .other:
            return DBXFilesPathOrLinkOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asPath: DBXFilesPathOrLinkPath? {
        self as? DBXFilesPathOrLinkPath
    }

    @objc
    public var asLink: DBXFilesPathOrLinkLink? {
        self as? DBXFilesPathOrLinkLink
    }

    @objc
    public var asOther: DBXFilesPathOrLinkOther? {
        self as? DBXFilesPathOrLinkOther
    }
}

/// An unspecified error.
@objc
public class DBXFilesPathOrLinkPath: DBXFilesPathOrLink {
    @objc
    public var path: String

    @objc
    public init(_ arg: String) {
        self.path = arg
        let swift = Files.PathOrLink.path(arg)
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXFilesPathOrLinkLink: DBXFilesPathOrLink {
    @objc
    public var link: DBXFilesSharedLinkFileInfo

    @objc
    public init(_ arg: DBXFilesSharedLinkFileInfo) {
        self.link = arg
        let swift = Files.PathOrLink.link(arg.swift)
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXFilesPathOrLinkOther: DBXFilesPathOrLink {
    @objc
    public init() {
        let swift = Files.PathOrLink.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible PathToTags struct
@objc
public class DBXFilesPathToTags: NSObject {
    /// Path of the item.
    @objc
    public var path: String { swift.path }
    /// Tags assigned to this item.
    @objc
    public var tags: [DBXFilesTag] { swift.tags.map { DBXFilesTag(swift: $0) } }

    @objc
    public init(path: String, tags: [DBXFilesTag]) {
        self.swift = Files.PathToTags(path: path, tags: tags.map(\.swift))
    }

    let swift: Files.PathToTags

    public init(swift: Files.PathToTags) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Metadata for a photo.
@objc
public class DBXFilesPhotoMetadata: DBXFilesMediaMetadata {
    let subSwift: Files.PhotoMetadata

    public init(swift: Files.PhotoMetadata) {
        self.subSwift = swift
        super.init(swift: swift)
    }

    @objc
    public override var description: String { subSwift.description }
}

/// Objective-C compatible PreviewArg struct
@objc
public class DBXFilesPreviewArg: NSObject {
    /// The path of the file to preview.
    @objc
    public var path: String { swift.path }
    /// Please specify revision in path instead.
    @objc
    public var rev: String? { swift.rev }

    @objc
    public init(path: String, rev: String?) {
        self.swift = Files.PreviewArg(path: path, rev: rev)
    }

    let swift: Files.PreviewArg

    public init(swift: Files.PreviewArg) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible PreviewError union
@objc
public class DBXFilesPreviewError: NSObject {
    let swift: Files.PreviewError

    public init(swift: Files.PreviewError) {
        self.swift = swift
    }

    public static func factory(swift: Files.PreviewError) -> DBXFilesPreviewError {
        switch swift {
        case .path(let swiftArg):
            let arg = DBXFilesLookupError(swift: swiftArg)
            return DBXFilesPreviewErrorPath(arg)
        case .inProgress:
            return DBXFilesPreviewErrorInProgress()
        case .unsupportedExtension:
            return DBXFilesPreviewErrorUnsupportedExtension()
        case .unsupportedContent:
            return DBXFilesPreviewErrorUnsupportedContent()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asPath: DBXFilesPreviewErrorPath? {
        self as? DBXFilesPreviewErrorPath
    }

    @objc
    public var asInProgress: DBXFilesPreviewErrorInProgress? {
        self as? DBXFilesPreviewErrorInProgress
    }

    @objc
    public var asUnsupportedExtension: DBXFilesPreviewErrorUnsupportedExtension? {
        self as? DBXFilesPreviewErrorUnsupportedExtension
    }

    @objc
    public var asUnsupportedContent: DBXFilesPreviewErrorUnsupportedContent? {
        self as? DBXFilesPreviewErrorUnsupportedContent
    }
}

/// An error occurs when downloading metadata for the file.
@objc
public class DBXFilesPreviewErrorPath: DBXFilesPreviewError {
    @objc
    public var path: DBXFilesLookupError

    @objc
    public init(_ arg: DBXFilesLookupError) {
        self.path = arg
        let swift = Files.PreviewError.path(arg.swift)
        super.init(swift: swift)
    }
}

/// This preview generation is still in progress and the file is not ready  for preview yet.
@objc
public class DBXFilesPreviewErrorInProgress: DBXFilesPreviewError {
    @objc
    public init() {
        let swift = Files.PreviewError.inProgress
        super.init(swift: swift)
    }
}

/// The file extension is not supported preview generation.
@objc
public class DBXFilesPreviewErrorUnsupportedExtension: DBXFilesPreviewError {
    @objc
    public init() {
        let swift = Files.PreviewError.unsupportedExtension
        super.init(swift: swift)
    }
}

/// The file content is not supported for preview generation.
@objc
public class DBXFilesPreviewErrorUnsupportedContent: DBXFilesPreviewError {
    @objc
    public init() {
        let swift = Files.PreviewError.unsupportedContent
        super.init(swift: swift)
    }
}

/// Objective-C compatible PreviewResult struct
@objc
public class DBXFilesPreviewResult: NSObject {
    /// Metadata corresponding to the file received as an argument. Will be populated if the endpoint is called with
    /// a path (ReadPath).
    @objc
    public var fileMetadata: DBXFilesFileMetadata? { guard let swift = swift.fileMetadata else { return nil }
        return DBXFilesFileMetadata(swift: swift)
    }

    /// Minimal metadata corresponding to the file received as an argument. Will be populated if the endpoint is
    /// called using a shared link (SharedLinkFileInfo).
    @objc
    public var linkMetadata: DBXFilesMinimalFileLinkMetadata? { guard let swift = swift.linkMetadata else { return nil }
        return DBXFilesMinimalFileLinkMetadata(swift: swift)
    }

    @objc
    public init(fileMetadata: DBXFilesFileMetadata?, linkMetadata: DBXFilesMinimalFileLinkMetadata?) {
        self.swift = Files.PreviewResult(fileMetadata: fileMetadata?.subSwift, linkMetadata: linkMetadata?.swift)
    }

    let swift: Files.PreviewResult

    public init(swift: Files.PreviewResult) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible RelocationPath struct
@objc
public class DBXFilesRelocationPath: NSObject {
    /// Path in the user's Dropbox to be copied or moved.
    @objc
    public var fromPath: String { swift.fromPath }
    /// Path in the user's Dropbox that is the destination.
    @objc
    public var toPath: String { swift.toPath }

    @objc
    public init(fromPath: String, toPath: String) {
        self.swift = Files.RelocationPath(fromPath: fromPath, toPath: toPath)
    }

    let swift: Files.RelocationPath

    public init(swift: Files.RelocationPath) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible RelocationArg struct
@objc
public class DBXFilesRelocationArg: DBXFilesRelocationPath {
    /// This flag has no effect.
    @objc
    public var allowSharedFolder: NSNumber { subSwift.allowSharedFolder as NSNumber }
    /// If there's a conflict, have the Dropbox server try to autorename the file to avoid the conflict.
    @objc
    public var autorename: NSNumber { subSwift.autorename as NSNumber }
    /// Allow moves by owner even if it would result in an ownership transfer for the content being moved. This does
    /// not apply to copies.
    @objc
    public var allowOwnershipTransfer: NSNumber { subSwift.allowOwnershipTransfer as NSNumber }

    @objc
    public init(fromPath: String, toPath: String, allowSharedFolder: NSNumber, autorename: NSNumber, allowOwnershipTransfer: NSNumber) {
        let swift = Files.RelocationArg(
            fromPath: fromPath,
            toPath: toPath,
            allowSharedFolder: allowSharedFolder.boolValue,
            autorename: autorename.boolValue,
            allowOwnershipTransfer: allowOwnershipTransfer.boolValue
        )
        self.subSwift = swift
        super.init(swift: swift)
    }

    let subSwift: Files.RelocationArg

    public init(swift: Files.RelocationArg) {
        self.subSwift = swift
        super.init(swift: swift)
    }

    @objc
    public override var description: String { subSwift.description }
}

/// Objective-C compatible RelocationBatchArg struct
@objc
public class DBXFilesRelocationBatchArg: DBXFilesRelocationBatchArgBase {
    /// This flag has no effect.
    @objc
    public var allowSharedFolder: NSNumber { subSwift.allowSharedFolder as NSNumber }
    /// Allow moves by owner even if it would result in an ownership transfer for the content being moved. This does
    /// not apply to copies.
    @objc
    public var allowOwnershipTransfer: NSNumber { subSwift.allowOwnershipTransfer as NSNumber }

    @objc
    public init(entries: [DBXFilesRelocationPath], autorename: NSNumber, allowSharedFolder: NSNumber, allowOwnershipTransfer: NSNumber) {
        let swift = Files.RelocationBatchArg(
            entries: entries.map(\.swift),
            autorename: autorename.boolValue,
            allowSharedFolder: allowSharedFolder.boolValue,
            allowOwnershipTransfer: allowOwnershipTransfer.boolValue
        )
        self.subSwift = swift
        super.init(swift: swift)
    }

    let subSwift: Files.RelocationBatchArg

    public init(swift: Files.RelocationBatchArg) {
        self.subSwift = swift
        super.init(swift: swift)
    }

    @objc
    public override var description: String { subSwift.description }
}

/// Objective-C compatible RelocationError union
@objc
public class DBXFilesRelocationError: NSObject {
    let swift: Files.RelocationError

    public init(swift: Files.RelocationError) {
        self.swift = swift
    }

    public static func factory(swift: Files.RelocationError) -> DBXFilesRelocationError {
        switch swift {
        case .fromLookup(let swiftArg):
            let arg = DBXFilesLookupError(swift: swiftArg)
            return DBXFilesRelocationErrorFromLookup(arg)
        case .fromWrite(let swiftArg):
            let arg = DBXFilesWriteError(swift: swiftArg)
            return DBXFilesRelocationErrorFromWrite(arg)
        case .to(let swiftArg):
            let arg = DBXFilesWriteError(swift: swiftArg)
            return DBXFilesRelocationErrorTo(arg)
        case .cantCopySharedFolder:
            return DBXFilesRelocationErrorCantCopySharedFolder()
        case .cantNestSharedFolder:
            return DBXFilesRelocationErrorCantNestSharedFolder()
        case .cantMoveFolderIntoItself:
            return DBXFilesRelocationErrorCantMoveFolderIntoItself()
        case .tooManyFiles:
            return DBXFilesRelocationErrorTooManyFiles()
        case .duplicatedOrNestedPaths:
            return DBXFilesRelocationErrorDuplicatedOrNestedPaths()
        case .cantTransferOwnership:
            return DBXFilesRelocationErrorCantTransferOwnership()
        case .insufficientQuota:
            return DBXFilesRelocationErrorInsufficientQuota()
        case .internalError:
            return DBXFilesRelocationErrorInternalError()
        case .cantMoveSharedFolder:
            return DBXFilesRelocationErrorCantMoveSharedFolder()
        case .cantMoveIntoVault(let swiftArg):
            let arg = DBXFilesMoveIntoVaultError(swift: swiftArg)
            return DBXFilesRelocationErrorCantMoveIntoVault(arg)
        case .cantMoveIntoFamily(let swiftArg):
            let arg = DBXFilesMoveIntoFamilyError(swift: swiftArg)
            return DBXFilesRelocationErrorCantMoveIntoFamily(arg)
        case .other:
            return DBXFilesRelocationErrorOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asFromLookup: DBXFilesRelocationErrorFromLookup? {
        self as? DBXFilesRelocationErrorFromLookup
    }

    @objc
    public var asFromWrite: DBXFilesRelocationErrorFromWrite? {
        self as? DBXFilesRelocationErrorFromWrite
    }

    @objc
    public var asTo: DBXFilesRelocationErrorTo? {
        self as? DBXFilesRelocationErrorTo
    }

    @objc
    public var asCantCopySharedFolder: DBXFilesRelocationErrorCantCopySharedFolder? {
        self as? DBXFilesRelocationErrorCantCopySharedFolder
    }

    @objc
    public var asCantNestSharedFolder: DBXFilesRelocationErrorCantNestSharedFolder? {
        self as? DBXFilesRelocationErrorCantNestSharedFolder
    }

    @objc
    public var asCantMoveFolderIntoItself: DBXFilesRelocationErrorCantMoveFolderIntoItself? {
        self as? DBXFilesRelocationErrorCantMoveFolderIntoItself
    }

    @objc
    public var asTooManyFiles: DBXFilesRelocationErrorTooManyFiles? {
        self as? DBXFilesRelocationErrorTooManyFiles
    }

    @objc
    public var asDuplicatedOrNestedPaths: DBXFilesRelocationErrorDuplicatedOrNestedPaths? {
        self as? DBXFilesRelocationErrorDuplicatedOrNestedPaths
    }

    @objc
    public var asCantTransferOwnership: DBXFilesRelocationErrorCantTransferOwnership? {
        self as? DBXFilesRelocationErrorCantTransferOwnership
    }

    @objc
    public var asInsufficientQuota: DBXFilesRelocationErrorInsufficientQuota? {
        self as? DBXFilesRelocationErrorInsufficientQuota
    }

    @objc
    public var asInternalError: DBXFilesRelocationErrorInternalError? {
        self as? DBXFilesRelocationErrorInternalError
    }

    @objc
    public var asCantMoveSharedFolder: DBXFilesRelocationErrorCantMoveSharedFolder? {
        self as? DBXFilesRelocationErrorCantMoveSharedFolder
    }

    @objc
    public var asCantMoveIntoVault: DBXFilesRelocationErrorCantMoveIntoVault? {
        self as? DBXFilesRelocationErrorCantMoveIntoVault
    }

    @objc
    public var asCantMoveIntoFamily: DBXFilesRelocationErrorCantMoveIntoFamily? {
        self as? DBXFilesRelocationErrorCantMoveIntoFamily
    }

    @objc
    public var asOther: DBXFilesRelocationErrorOther? {
        self as? DBXFilesRelocationErrorOther
    }
}

/// An unspecified error.
@objc
public class DBXFilesRelocationErrorFromLookup: DBXFilesRelocationError {
    @objc
    public var fromLookup: DBXFilesLookupError

    @objc
    public init(_ arg: DBXFilesLookupError) {
        self.fromLookup = arg
        let swift = Files.RelocationError.fromLookup(arg.swift)
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXFilesRelocationErrorFromWrite: DBXFilesRelocationError {
    @objc
    public var fromWrite: DBXFilesWriteError

    @objc
    public init(_ arg: DBXFilesWriteError) {
        self.fromWrite = arg
        let swift = Files.RelocationError.fromWrite(arg.swift)
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXFilesRelocationErrorTo: DBXFilesRelocationError {
    @objc
    public var to: DBXFilesWriteError

    @objc
    public init(_ arg: DBXFilesWriteError) {
        self.to = arg
        let swift = Files.RelocationError.to(arg.swift)
        super.init(swift: swift)
    }
}

/// Shared folders can't be copied.
@objc
public class DBXFilesRelocationErrorCantCopySharedFolder: DBXFilesRelocationError {
    @objc
    public init() {
        let swift = Files.RelocationError.cantCopySharedFolder
        super.init(swift: swift)
    }
}

/// Your move operation would result in nested shared folders.  This is not allowed.
@objc
public class DBXFilesRelocationErrorCantNestSharedFolder: DBXFilesRelocationError {
    @objc
    public init() {
        let swift = Files.RelocationError.cantNestSharedFolder
        super.init(swift: swift)
    }
}

/// You cannot move a folder into itself.
@objc
public class DBXFilesRelocationErrorCantMoveFolderIntoItself: DBXFilesRelocationError {
    @objc
    public init() {
        let swift = Files.RelocationError.cantMoveFolderIntoItself
        super.init(swift: swift)
    }
}

/// The operation would involve more than 10,000 files and folders.
@objc
public class DBXFilesRelocationErrorTooManyFiles: DBXFilesRelocationError {
    @objc
    public init() {
        let swift = Files.RelocationError.tooManyFiles
        super.init(swift: swift)
    }
}

/// There are duplicated/nested paths among fromPath in RelocationArg and toPath in RelocationArg.
@objc
public class DBXFilesRelocationErrorDuplicatedOrNestedPaths: DBXFilesRelocationError {
    @objc
    public init() {
        let swift = Files.RelocationError.duplicatedOrNestedPaths
        super.init(swift: swift)
    }
}

/// Your move operation would result in an ownership transfer. You may reissue the request with the field
/// allowOwnershipTransfer in RelocationArg to true.
@objc
public class DBXFilesRelocationErrorCantTransferOwnership: DBXFilesRelocationError {
    @objc
    public init() {
        let swift = Files.RelocationError.cantTransferOwnership
        super.init(swift: swift)
    }
}

/// The current user does not have enough space to move or copy the files.
@objc
public class DBXFilesRelocationErrorInsufficientQuota: DBXFilesRelocationError {
    @objc
    public init() {
        let swift = Files.RelocationError.insufficientQuota
        super.init(swift: swift)
    }
}

/// Something went wrong with the job on Dropbox's end. You'll need to verify that the action you were taking
/// succeeded, and if not, try again. This should happen very rarely.
@objc
public class DBXFilesRelocationErrorInternalError: DBXFilesRelocationError {
    @objc
    public init() {
        let swift = Files.RelocationError.internalError
        super.init(swift: swift)
    }
}

/// Can't move the shared folder to the given destination.
@objc
public class DBXFilesRelocationErrorCantMoveSharedFolder: DBXFilesRelocationError {
    @objc
    public init() {
        let swift = Files.RelocationError.cantMoveSharedFolder
        super.init(swift: swift)
    }
}

/// Some content cannot be moved into Vault under certain circumstances, see detailed error.
@objc
public class DBXFilesRelocationErrorCantMoveIntoVault: DBXFilesRelocationError {
    @objc
    public var cantMoveIntoVault: DBXFilesMoveIntoVaultError

    @objc
    public init(_ arg: DBXFilesMoveIntoVaultError) {
        self.cantMoveIntoVault = arg
        let swift = Files.RelocationError.cantMoveIntoVault(arg.swift)
        super.init(swift: swift)
    }
}

/// Some content cannot be moved into the Family Room folder under certain circumstances, see detailed error.
@objc
public class DBXFilesRelocationErrorCantMoveIntoFamily: DBXFilesRelocationError {
    @objc
    public var cantMoveIntoFamily: DBXFilesMoveIntoFamilyError

    @objc
    public init(_ arg: DBXFilesMoveIntoFamilyError) {
        self.cantMoveIntoFamily = arg
        let swift = Files.RelocationError.cantMoveIntoFamily(arg.swift)
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXFilesRelocationErrorOther: DBXFilesRelocationError {
    @objc
    public init() {
        let swift = Files.RelocationError.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible RelocationBatchError union
@objc
public class DBXFilesRelocationBatchError: NSObject {
    let swift: Files.RelocationBatchError

    public init(swift: Files.RelocationBatchError) {
        self.swift = swift
    }

    public static func factory(swift: Files.RelocationBatchError) -> DBXFilesRelocationBatchError {
        switch swift {
        case .fromLookup(let swiftArg):
            let arg = DBXFilesLookupError(swift: swiftArg)
            return DBXFilesRelocationBatchErrorFromLookup(arg)
        case .fromWrite(let swiftArg):
            let arg = DBXFilesWriteError(swift: swiftArg)
            return DBXFilesRelocationBatchErrorFromWrite(arg)
        case .to(let swiftArg):
            let arg = DBXFilesWriteError(swift: swiftArg)
            return DBXFilesRelocationBatchErrorTo(arg)
        case .cantCopySharedFolder:
            return DBXFilesRelocationBatchErrorCantCopySharedFolder()
        case .cantNestSharedFolder:
            return DBXFilesRelocationBatchErrorCantNestSharedFolder()
        case .cantMoveFolderIntoItself:
            return DBXFilesRelocationBatchErrorCantMoveFolderIntoItself()
        case .tooManyFiles:
            return DBXFilesRelocationBatchErrorTooManyFiles()
        case .duplicatedOrNestedPaths:
            return DBXFilesRelocationBatchErrorDuplicatedOrNestedPaths()
        case .cantTransferOwnership:
            return DBXFilesRelocationBatchErrorCantTransferOwnership()
        case .insufficientQuota:
            return DBXFilesRelocationBatchErrorInsufficientQuota()
        case .internalError:
            return DBXFilesRelocationBatchErrorInternalError()
        case .cantMoveSharedFolder:
            return DBXFilesRelocationBatchErrorCantMoveSharedFolder()
        case .cantMoveIntoVault(let swiftArg):
            let arg = DBXFilesMoveIntoVaultError(swift: swiftArg)
            return DBXFilesRelocationBatchErrorCantMoveIntoVault(arg)
        case .cantMoveIntoFamily(let swiftArg):
            let arg = DBXFilesMoveIntoFamilyError(swift: swiftArg)
            return DBXFilesRelocationBatchErrorCantMoveIntoFamily(arg)
        case .other:
            return DBXFilesRelocationBatchErrorOther()
        case .tooManyWriteOperations:
            return DBXFilesRelocationBatchErrorTooManyWriteOperations()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asFromLookup: DBXFilesRelocationBatchErrorFromLookup? {
        self as? DBXFilesRelocationBatchErrorFromLookup
    }

    @objc
    public var asFromWrite: DBXFilesRelocationBatchErrorFromWrite? {
        self as? DBXFilesRelocationBatchErrorFromWrite
    }

    @objc
    public var asTo: DBXFilesRelocationBatchErrorTo? {
        self as? DBXFilesRelocationBatchErrorTo
    }

    @objc
    public var asCantCopySharedFolder: DBXFilesRelocationBatchErrorCantCopySharedFolder? {
        self as? DBXFilesRelocationBatchErrorCantCopySharedFolder
    }

    @objc
    public var asCantNestSharedFolder: DBXFilesRelocationBatchErrorCantNestSharedFolder? {
        self as? DBXFilesRelocationBatchErrorCantNestSharedFolder
    }

    @objc
    public var asCantMoveFolderIntoItself: DBXFilesRelocationBatchErrorCantMoveFolderIntoItself? {
        self as? DBXFilesRelocationBatchErrorCantMoveFolderIntoItself
    }

    @objc
    public var asTooManyFiles: DBXFilesRelocationBatchErrorTooManyFiles? {
        self as? DBXFilesRelocationBatchErrorTooManyFiles
    }

    @objc
    public var asDuplicatedOrNestedPaths: DBXFilesRelocationBatchErrorDuplicatedOrNestedPaths? {
        self as? DBXFilesRelocationBatchErrorDuplicatedOrNestedPaths
    }

    @objc
    public var asCantTransferOwnership: DBXFilesRelocationBatchErrorCantTransferOwnership? {
        self as? DBXFilesRelocationBatchErrorCantTransferOwnership
    }

    @objc
    public var asInsufficientQuota: DBXFilesRelocationBatchErrorInsufficientQuota? {
        self as? DBXFilesRelocationBatchErrorInsufficientQuota
    }

    @objc
    public var asInternalError: DBXFilesRelocationBatchErrorInternalError? {
        self as? DBXFilesRelocationBatchErrorInternalError
    }

    @objc
    public var asCantMoveSharedFolder: DBXFilesRelocationBatchErrorCantMoveSharedFolder? {
        self as? DBXFilesRelocationBatchErrorCantMoveSharedFolder
    }

    @objc
    public var asCantMoveIntoVault: DBXFilesRelocationBatchErrorCantMoveIntoVault? {
        self as? DBXFilesRelocationBatchErrorCantMoveIntoVault
    }

    @objc
    public var asCantMoveIntoFamily: DBXFilesRelocationBatchErrorCantMoveIntoFamily? {
        self as? DBXFilesRelocationBatchErrorCantMoveIntoFamily
    }

    @objc
    public var asOther: DBXFilesRelocationBatchErrorOther? {
        self as? DBXFilesRelocationBatchErrorOther
    }

    @objc
    public var asTooManyWriteOperations: DBXFilesRelocationBatchErrorTooManyWriteOperations? {
        self as? DBXFilesRelocationBatchErrorTooManyWriteOperations
    }
}

/// An unspecified error.
@objc
public class DBXFilesRelocationBatchErrorFromLookup: DBXFilesRelocationBatchError {
    @objc
    public var fromLookup: DBXFilesLookupError

    @objc
    public init(_ arg: DBXFilesLookupError) {
        self.fromLookup = arg
        let swift = Files.RelocationBatchError.fromLookup(arg.swift)
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXFilesRelocationBatchErrorFromWrite: DBXFilesRelocationBatchError {
    @objc
    public var fromWrite: DBXFilesWriteError

    @objc
    public init(_ arg: DBXFilesWriteError) {
        self.fromWrite = arg
        let swift = Files.RelocationBatchError.fromWrite(arg.swift)
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXFilesRelocationBatchErrorTo: DBXFilesRelocationBatchError {
    @objc
    public var to: DBXFilesWriteError

    @objc
    public init(_ arg: DBXFilesWriteError) {
        self.to = arg
        let swift = Files.RelocationBatchError.to(arg.swift)
        super.init(swift: swift)
    }
}

/// Shared folders can't be copied.
@objc
public class DBXFilesRelocationBatchErrorCantCopySharedFolder: DBXFilesRelocationBatchError {
    @objc
    public init() {
        let swift = Files.RelocationBatchError.cantCopySharedFolder
        super.init(swift: swift)
    }
}

/// Your move operation would result in nested shared folders.  This is not allowed.
@objc
public class DBXFilesRelocationBatchErrorCantNestSharedFolder: DBXFilesRelocationBatchError {
    @objc
    public init() {
        let swift = Files.RelocationBatchError.cantNestSharedFolder
        super.init(swift: swift)
    }
}

/// You cannot move a folder into itself.
@objc
public class DBXFilesRelocationBatchErrorCantMoveFolderIntoItself: DBXFilesRelocationBatchError {
    @objc
    public init() {
        let swift = Files.RelocationBatchError.cantMoveFolderIntoItself
        super.init(swift: swift)
    }
}

/// The operation would involve more than 10,000 files and folders.
@objc
public class DBXFilesRelocationBatchErrorTooManyFiles: DBXFilesRelocationBatchError {
    @objc
    public init() {
        let swift = Files.RelocationBatchError.tooManyFiles
        super.init(swift: swift)
    }
}

/// There are duplicated/nested paths among fromPath in RelocationArg and toPath in RelocationArg.
@objc
public class DBXFilesRelocationBatchErrorDuplicatedOrNestedPaths: DBXFilesRelocationBatchError {
    @objc
    public init() {
        let swift = Files.RelocationBatchError.duplicatedOrNestedPaths
        super.init(swift: swift)
    }
}

/// Your move operation would result in an ownership transfer. You may reissue the request with the field
/// allowOwnershipTransfer in RelocationArg to true.
@objc
public class DBXFilesRelocationBatchErrorCantTransferOwnership: DBXFilesRelocationBatchError {
    @objc
    public init() {
        let swift = Files.RelocationBatchError.cantTransferOwnership
        super.init(swift: swift)
    }
}

/// The current user does not have enough space to move or copy the files.
@objc
public class DBXFilesRelocationBatchErrorInsufficientQuota: DBXFilesRelocationBatchError {
    @objc
    public init() {
        let swift = Files.RelocationBatchError.insufficientQuota
        super.init(swift: swift)
    }
}

/// Something went wrong with the job on Dropbox's end. You'll need to verify that the action you were taking
/// succeeded, and if not, try again. This should happen very rarely.
@objc
public class DBXFilesRelocationBatchErrorInternalError: DBXFilesRelocationBatchError {
    @objc
    public init() {
        let swift = Files.RelocationBatchError.internalError
        super.init(swift: swift)
    }
}

/// Can't move the shared folder to the given destination.
@objc
public class DBXFilesRelocationBatchErrorCantMoveSharedFolder: DBXFilesRelocationBatchError {
    @objc
    public init() {
        let swift = Files.RelocationBatchError.cantMoveSharedFolder
        super.init(swift: swift)
    }
}

/// Some content cannot be moved into Vault under certain circumstances, see detailed error.
@objc
public class DBXFilesRelocationBatchErrorCantMoveIntoVault: DBXFilesRelocationBatchError {
    @objc
    public var cantMoveIntoVault: DBXFilesMoveIntoVaultError

    @objc
    public init(_ arg: DBXFilesMoveIntoVaultError) {
        self.cantMoveIntoVault = arg
        let swift = Files.RelocationBatchError.cantMoveIntoVault(arg.swift)
        super.init(swift: swift)
    }
}

/// Some content cannot be moved into the Family Room folder under certain circumstances, see detailed error.
@objc
public class DBXFilesRelocationBatchErrorCantMoveIntoFamily: DBXFilesRelocationBatchError {
    @objc
    public var cantMoveIntoFamily: DBXFilesMoveIntoFamilyError

    @objc
    public init(_ arg: DBXFilesMoveIntoFamilyError) {
        self.cantMoveIntoFamily = arg
        let swift = Files.RelocationBatchError.cantMoveIntoFamily(arg.swift)
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXFilesRelocationBatchErrorOther: DBXFilesRelocationBatchError {
    @objc
    public init() {
        let swift = Files.RelocationBatchError.other
        super.init(swift: swift)
    }
}

/// There are too many write operations in user's Dropbox. Please retry this request.
@objc
public class DBXFilesRelocationBatchErrorTooManyWriteOperations: DBXFilesRelocationBatchError {
    @objc
    public init() {
        let swift = Files.RelocationBatchError.tooManyWriteOperations
        super.init(swift: swift)
    }
}

/// Objective-C compatible RelocationBatchErrorEntry union
@objc
public class DBXFilesRelocationBatchErrorEntry: NSObject {
    let swift: Files.RelocationBatchErrorEntry

    public init(swift: Files.RelocationBatchErrorEntry) {
        self.swift = swift
    }

    public static func factory(swift: Files.RelocationBatchErrorEntry) -> DBXFilesRelocationBatchErrorEntry {
        switch swift {
        case .relocationError(let swiftArg):
            let arg = DBXFilesRelocationError(swift: swiftArg)
            return DBXFilesRelocationBatchErrorEntryRelocationError(arg)
        case .internalError:
            return DBXFilesRelocationBatchErrorEntryInternalError()
        case .tooManyWriteOperations:
            return DBXFilesRelocationBatchErrorEntryTooManyWriteOperations()
        case .other:
            return DBXFilesRelocationBatchErrorEntryOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asRelocationError: DBXFilesRelocationBatchErrorEntryRelocationError? {
        self as? DBXFilesRelocationBatchErrorEntryRelocationError
    }

    @objc
    public var asInternalError: DBXFilesRelocationBatchErrorEntryInternalError? {
        self as? DBXFilesRelocationBatchErrorEntryInternalError
    }

    @objc
    public var asTooManyWriteOperations: DBXFilesRelocationBatchErrorEntryTooManyWriteOperations? {
        self as? DBXFilesRelocationBatchErrorEntryTooManyWriteOperations
    }

    @objc
    public var asOther: DBXFilesRelocationBatchErrorEntryOther? {
        self as? DBXFilesRelocationBatchErrorEntryOther
    }
}

/// User errors that retry won't help.
@objc
public class DBXFilesRelocationBatchErrorEntryRelocationError: DBXFilesRelocationBatchErrorEntry {
    @objc
    public var relocationError: DBXFilesRelocationError

    @objc
    public init(_ arg: DBXFilesRelocationError) {
        self.relocationError = arg
        let swift = Files.RelocationBatchErrorEntry.relocationError(arg.swift)
        super.init(swift: swift)
    }
}

/// Something went wrong with the job on Dropbox's end. You'll need to verify that the action you were taking
/// succeeded, and if not, try again. This should happen very rarely.
@objc
public class DBXFilesRelocationBatchErrorEntryInternalError: DBXFilesRelocationBatchErrorEntry {
    @objc
    public init() {
        let swift = Files.RelocationBatchErrorEntry.internalError
        super.init(swift: swift)
    }
}

/// There are too many write operations in user's Dropbox. Please retry this request.
@objc
public class DBXFilesRelocationBatchErrorEntryTooManyWriteOperations: DBXFilesRelocationBatchErrorEntry {
    @objc
    public init() {
        let swift = Files.RelocationBatchErrorEntry.tooManyWriteOperations
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXFilesRelocationBatchErrorEntryOther: DBXFilesRelocationBatchErrorEntry {
    @objc
    public init() {
        let swift = Files.RelocationBatchErrorEntry.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible RelocationBatchJobStatus union
@objc
public class DBXFilesRelocationBatchJobStatus: NSObject {
    let swift: Files.RelocationBatchJobStatus

    public init(swift: Files.RelocationBatchJobStatus) {
        self.swift = swift
    }

    public static func factory(swift: Files.RelocationBatchJobStatus) -> DBXFilesRelocationBatchJobStatus {
        switch swift {
        case .inProgress:
            return DBXFilesRelocationBatchJobStatusInProgress()
        case .complete(let swiftArg):
            let arg = DBXFilesRelocationBatchResult(swift: swiftArg)
            return DBXFilesRelocationBatchJobStatusComplete(arg)
        case .failed(let swiftArg):
            let arg = DBXFilesRelocationBatchError(swift: swiftArg)
            return DBXFilesRelocationBatchJobStatusFailed(arg)
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asInProgress: DBXFilesRelocationBatchJobStatusInProgress? {
        self as? DBXFilesRelocationBatchJobStatusInProgress
    }

    @objc
    public var asComplete: DBXFilesRelocationBatchJobStatusComplete? {
        self as? DBXFilesRelocationBatchJobStatusComplete
    }

    @objc
    public var asFailed: DBXFilesRelocationBatchJobStatusFailed? {
        self as? DBXFilesRelocationBatchJobStatusFailed
    }
}

/// The asynchronous job is still in progress.
@objc
public class DBXFilesRelocationBatchJobStatusInProgress: DBXFilesRelocationBatchJobStatus {
    @objc
    public init() {
        let swift = Files.RelocationBatchJobStatus.inProgress
        super.init(swift: swift)
    }
}

/// The copy or move batch job has finished.
@objc
public class DBXFilesRelocationBatchJobStatusComplete: DBXFilesRelocationBatchJobStatus {
    @objc
    public var complete: DBXFilesRelocationBatchResult

    @objc
    public init(_ arg: DBXFilesRelocationBatchResult) {
        self.complete = arg
        let swift = Files.RelocationBatchJobStatus.complete(arg.subSwift)
        super.init(swift: swift)
    }
}

/// The copy or move batch job has failed with exception.
@objc
public class DBXFilesRelocationBatchJobStatusFailed: DBXFilesRelocationBatchJobStatus {
    @objc
    public var failed: DBXFilesRelocationBatchError

    @objc
    public init(_ arg: DBXFilesRelocationBatchError) {
        self.failed = arg
        let swift = Files.RelocationBatchJobStatus.failed(arg.swift)
        super.init(swift: swift)
    }
}

/// Result returned by copyBatch or moveBatch that may either launch an asynchronous job or complete synchronously.
@objc
public class DBXFilesRelocationBatchLaunch: NSObject {
    let swift: Files.RelocationBatchLaunch

    public init(swift: Files.RelocationBatchLaunch) {
        self.swift = swift
    }

    public static func factory(swift: Files.RelocationBatchLaunch) -> DBXFilesRelocationBatchLaunch {
        switch swift {
        case .asyncJobId(let swiftArg):
            let arg = swiftArg
            return DBXFilesRelocationBatchLaunchAsyncJobId(arg)
        case .complete(let swiftArg):
            let arg = DBXFilesRelocationBatchResult(swift: swiftArg)
            return DBXFilesRelocationBatchLaunchComplete(arg)
        case .other:
            return DBXFilesRelocationBatchLaunchOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asAsyncJobId: DBXFilesRelocationBatchLaunchAsyncJobId? {
        self as? DBXFilesRelocationBatchLaunchAsyncJobId
    }

    @objc
    public var asComplete: DBXFilesRelocationBatchLaunchComplete? {
        self as? DBXFilesRelocationBatchLaunchComplete
    }

    @objc
    public var asOther: DBXFilesRelocationBatchLaunchOther? {
        self as? DBXFilesRelocationBatchLaunchOther
    }
}

/// This response indicates that the processing is asynchronous. The string is an id that can be used to obtain
/// the status of the asynchronous job.
@objc
public class DBXFilesRelocationBatchLaunchAsyncJobId: DBXFilesRelocationBatchLaunch {
    @objc
    public var asyncJobId: String

    @objc
    public init(_ arg: String) {
        self.asyncJobId = arg
        let swift = Files.RelocationBatchLaunch.asyncJobId(arg)
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXFilesRelocationBatchLaunchComplete: DBXFilesRelocationBatchLaunch {
    @objc
    public var complete: DBXFilesRelocationBatchResult

    @objc
    public init(_ arg: DBXFilesRelocationBatchResult) {
        self.complete = arg
        let swift = Files.RelocationBatchLaunch.complete(arg.subSwift)
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXFilesRelocationBatchLaunchOther: DBXFilesRelocationBatchLaunch {
    @objc
    public init() {
        let swift = Files.RelocationBatchLaunch.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible RelocationBatchResult struct
@objc
public class DBXFilesRelocationBatchResult: DBXFilesFileOpsResult {
    /// (no description)
    @objc
    public var entries: [DBXFilesRelocationBatchResultData] { subSwift.entries.map { DBXFilesRelocationBatchResultData(swift: $0) } }

    @objc
    public init(entries: [DBXFilesRelocationBatchResultData]) {
        let swift = Files.RelocationBatchResult(entries: entries.map(\.swift))
        self.subSwift = swift
        super.init(swift: swift)
    }

    let subSwift: Files.RelocationBatchResult

    public init(swift: Files.RelocationBatchResult) {
        self.subSwift = swift
        super.init(swift: swift)
    }

    @objc
    public override var description: String { subSwift.description }
}

/// Objective-C compatible RelocationBatchResultData struct
@objc
public class DBXFilesRelocationBatchResultData: NSObject {
    /// Metadata of the relocated object.
    @objc
    public var metadata: DBXFilesMetadata {
        DBXFilesMetadata.wrapPreservingSubtypes(swift: swift.metadata)
    }

    @objc
    public init(metadata: DBXFilesMetadata) {
        self.swift = Files.RelocationBatchResultData(metadata: metadata.swift)
    }

    let swift: Files.RelocationBatchResultData

    public init(swift: Files.RelocationBatchResultData) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible RelocationBatchResultEntry union
@objc
public class DBXFilesRelocationBatchResultEntry: NSObject {
    let swift: Files.RelocationBatchResultEntry

    public init(swift: Files.RelocationBatchResultEntry) {
        self.swift = swift
    }

    public static func factory(swift: Files.RelocationBatchResultEntry) -> DBXFilesRelocationBatchResultEntry {
        switch swift {
        case .success(let swiftArg):
            let arg = DBXFilesMetadata(swift: swiftArg)
            return DBXFilesRelocationBatchResultEntrySuccess(arg)
        case .failure(let swiftArg):
            let arg = DBXFilesRelocationBatchErrorEntry(swift: swiftArg)
            return DBXFilesRelocationBatchResultEntryFailure(arg)
        case .other:
            return DBXFilesRelocationBatchResultEntryOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asSuccess: DBXFilesRelocationBatchResultEntrySuccess? {
        self as? DBXFilesRelocationBatchResultEntrySuccess
    }

    @objc
    public var asFailure: DBXFilesRelocationBatchResultEntryFailure? {
        self as? DBXFilesRelocationBatchResultEntryFailure
    }

    @objc
    public var asOther: DBXFilesRelocationBatchResultEntryOther? {
        self as? DBXFilesRelocationBatchResultEntryOther
    }
}

/// An unspecified error.
@objc
public class DBXFilesRelocationBatchResultEntrySuccess: DBXFilesRelocationBatchResultEntry {
    @objc
    public var success: DBXFilesMetadata

    @objc
    public init(_ arg: DBXFilesMetadata) {
        self.success = arg
        let swift = Files.RelocationBatchResultEntry.success(arg.swift)
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXFilesRelocationBatchResultEntryFailure: DBXFilesRelocationBatchResultEntry {
    @objc
    public var failure: DBXFilesRelocationBatchErrorEntry

    @objc
    public init(_ arg: DBXFilesRelocationBatchErrorEntry) {
        self.failure = arg
        let swift = Files.RelocationBatchResultEntry.failure(arg.swift)
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXFilesRelocationBatchResultEntryOther: DBXFilesRelocationBatchResultEntry {
    @objc
    public init() {
        let swift = Files.RelocationBatchResultEntry.other
        super.init(swift: swift)
    }
}

/// Result returned by copyBatchCheckV2 or moveBatchCheckV2 that may either be in progress or completed with result
/// for each entry.
@objc
public class DBXFilesRelocationBatchV2JobStatus: NSObject {
    let swift: Files.RelocationBatchV2JobStatus

    public init(swift: Files.RelocationBatchV2JobStatus) {
        self.swift = swift
    }

    public static func factory(swift: Files.RelocationBatchV2JobStatus) -> DBXFilesRelocationBatchV2JobStatus {
        switch swift {
        case .inProgress:
            return DBXFilesRelocationBatchV2JobStatusInProgress()
        case .complete(let swiftArg):
            let arg = DBXFilesRelocationBatchV2Result(swift: swiftArg)
            return DBXFilesRelocationBatchV2JobStatusComplete(arg)
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asInProgress: DBXFilesRelocationBatchV2JobStatusInProgress? {
        self as? DBXFilesRelocationBatchV2JobStatusInProgress
    }

    @objc
    public var asComplete: DBXFilesRelocationBatchV2JobStatusComplete? {
        self as? DBXFilesRelocationBatchV2JobStatusComplete
    }
}

/// The asynchronous job is still in progress.
@objc
public class DBXFilesRelocationBatchV2JobStatusInProgress: DBXFilesRelocationBatchV2JobStatus {
    @objc
    public init() {
        let swift = Files.RelocationBatchV2JobStatus.inProgress
        super.init(swift: swift)
    }
}

/// The copy or move batch job has finished.
@objc
public class DBXFilesRelocationBatchV2JobStatusComplete: DBXFilesRelocationBatchV2JobStatus {
    @objc
    public var complete: DBXFilesRelocationBatchV2Result

    @objc
    public init(_ arg: DBXFilesRelocationBatchV2Result) {
        self.complete = arg
        let swift = Files.RelocationBatchV2JobStatus.complete(arg.subSwift)
        super.init(swift: swift)
    }
}

/// Result returned by copyBatchV2 or moveBatchV2 that may either launch an asynchronous job or complete
/// synchronously.
@objc
public class DBXFilesRelocationBatchV2Launch: NSObject {
    let swift: Files.RelocationBatchV2Launch

    public init(swift: Files.RelocationBatchV2Launch) {
        self.swift = swift
    }

    public static func factory(swift: Files.RelocationBatchV2Launch) -> DBXFilesRelocationBatchV2Launch {
        switch swift {
        case .asyncJobId(let swiftArg):
            let arg = swiftArg
            return DBXFilesRelocationBatchV2LaunchAsyncJobId(arg)
        case .complete(let swiftArg):
            let arg = DBXFilesRelocationBatchV2Result(swift: swiftArg)
            return DBXFilesRelocationBatchV2LaunchComplete(arg)
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asAsyncJobId: DBXFilesRelocationBatchV2LaunchAsyncJobId? {
        self as? DBXFilesRelocationBatchV2LaunchAsyncJobId
    }

    @objc
    public var asComplete: DBXFilesRelocationBatchV2LaunchComplete? {
        self as? DBXFilesRelocationBatchV2LaunchComplete
    }
}

/// This response indicates that the processing is asynchronous. The string is an id that can be used to obtain
/// the status of the asynchronous job.
@objc
public class DBXFilesRelocationBatchV2LaunchAsyncJobId: DBXFilesRelocationBatchV2Launch {
    @objc
    public var asyncJobId: String

    @objc
    public init(_ arg: String) {
        self.asyncJobId = arg
        let swift = Files.RelocationBatchV2Launch.asyncJobId(arg)
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXFilesRelocationBatchV2LaunchComplete: DBXFilesRelocationBatchV2Launch {
    @objc
    public var complete: DBXFilesRelocationBatchV2Result

    @objc
    public init(_ arg: DBXFilesRelocationBatchV2Result) {
        self.complete = arg
        let swift = Files.RelocationBatchV2Launch.complete(arg.subSwift)
        super.init(swift: swift)
    }
}

/// Objective-C compatible RelocationBatchV2Result struct
@objc
public class DBXFilesRelocationBatchV2Result: DBXFilesFileOpsResult {
    /// Each entry in CopyBatchArg.entries or entries in MoveBatchArg will appear at the same position inside
    /// entries in RelocationBatchV2Result.
    @objc
    public var entries: [DBXFilesRelocationBatchResultEntry] { subSwift.entries.map { DBXFilesRelocationBatchResultEntry(swift: $0) } }

    @objc
    public init(entries: [DBXFilesRelocationBatchResultEntry]) {
        let swift = Files.RelocationBatchV2Result(entries: entries.map(\.swift))
        self.subSwift = swift
        super.init(swift: swift)
    }

    let subSwift: Files.RelocationBatchV2Result

    public init(swift: Files.RelocationBatchV2Result) {
        self.subSwift = swift
        super.init(swift: swift)
    }

    @objc
    public override var description: String { subSwift.description }
}

/// Objective-C compatible RelocationResult struct
@objc
public class DBXFilesRelocationResult: DBXFilesFileOpsResult {
    /// Metadata of the relocated object.
    @objc
    public var metadata: DBXFilesMetadata {
        DBXFilesMetadata.wrapPreservingSubtypes(swift: subSwift.metadata)
    }

    @objc
    public init(metadata: DBXFilesMetadata) {
        let swift = Files.RelocationResult(metadata: metadata.swift)
        self.subSwift = swift
        super.init(swift: swift)
    }

    let subSwift: Files.RelocationResult

    public init(swift: Files.RelocationResult) {
        self.subSwift = swift
        super.init(swift: swift)
    }

    @objc
    public override var description: String { subSwift.description }
}

/// Objective-C compatible RemoveTagArg struct
@objc
public class DBXFilesRemoveTagArg: NSObject {
    /// Path to the item to tag.
    @objc
    public var path: String { swift.path }
    /// The tag to remove. Will be automatically converted to lowercase letters.
    @objc
    public var tagText: String { swift.tagText }

    @objc
    public init(path: String, tagText: String) {
        self.swift = Files.RemoveTagArg(path: path, tagText: tagText)
    }

    let swift: Files.RemoveTagArg

    public init(swift: Files.RemoveTagArg) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible RemoveTagError union
@objc
public class DBXFilesRemoveTagError: NSObject {
    let swift: Files.RemoveTagError

    public init(swift: Files.RemoveTagError) {
        self.swift = swift
    }

    public static func factory(swift: Files.RemoveTagError) -> DBXFilesRemoveTagError {
        switch swift {
        case .path(let swiftArg):
            let arg = DBXFilesLookupError(swift: swiftArg)
            return DBXFilesRemoveTagErrorPath(arg)
        case .other:
            return DBXFilesRemoveTagErrorOther()
        case .tagNotPresent:
            return DBXFilesRemoveTagErrorTagNotPresent()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asPath: DBXFilesRemoveTagErrorPath? {
        self as? DBXFilesRemoveTagErrorPath
    }

    @objc
    public var asOther: DBXFilesRemoveTagErrorOther? {
        self as? DBXFilesRemoveTagErrorOther
    }

    @objc
    public var asTagNotPresent: DBXFilesRemoveTagErrorTagNotPresent? {
        self as? DBXFilesRemoveTagErrorTagNotPresent
    }
}

/// An unspecified error.
@objc
public class DBXFilesRemoveTagErrorPath: DBXFilesRemoveTagError {
    @objc
    public var path: DBXFilesLookupError

    @objc
    public init(_ arg: DBXFilesLookupError) {
        self.path = arg
        let swift = Files.RemoveTagError.path(arg.swift)
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXFilesRemoveTagErrorOther: DBXFilesRemoveTagError {
    @objc
    public init() {
        let swift = Files.RemoveTagError.other
        super.init(swift: swift)
    }
}

/// That tag doesn't exist at this path.
@objc
public class DBXFilesRemoveTagErrorTagNotPresent: DBXFilesRemoveTagError {
    @objc
    public init() {
        let swift = Files.RemoveTagError.tagNotPresent
        super.init(swift: swift)
    }
}

/// Objective-C compatible RestoreArg struct
@objc
public class DBXFilesRestoreArg: NSObject {
    /// The path to save the restored file.
    @objc
    public var path: String { swift.path }
    /// The revision to restore.
    @objc
    public var rev: String { swift.rev }

    @objc
    public init(path: String, rev: String) {
        self.swift = Files.RestoreArg(path: path, rev: rev)
    }

    let swift: Files.RestoreArg

    public init(swift: Files.RestoreArg) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible RestoreError union
@objc
public class DBXFilesRestoreError: NSObject {
    let swift: Files.RestoreError

    public init(swift: Files.RestoreError) {
        self.swift = swift
    }

    public static func factory(swift: Files.RestoreError) -> DBXFilesRestoreError {
        switch swift {
        case .pathLookup(let swiftArg):
            let arg = DBXFilesLookupError(swift: swiftArg)
            return DBXFilesRestoreErrorPathLookup(arg)
        case .pathWrite(let swiftArg):
            let arg = DBXFilesWriteError(swift: swiftArg)
            return DBXFilesRestoreErrorPathWrite(arg)
        case .invalidRevision:
            return DBXFilesRestoreErrorInvalidRevision()
        case .inProgress:
            return DBXFilesRestoreErrorInProgress()
        case .other:
            return DBXFilesRestoreErrorOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asPathLookup: DBXFilesRestoreErrorPathLookup? {
        self as? DBXFilesRestoreErrorPathLookup
    }

    @objc
    public var asPathWrite: DBXFilesRestoreErrorPathWrite? {
        self as? DBXFilesRestoreErrorPathWrite
    }

    @objc
    public var asInvalidRevision: DBXFilesRestoreErrorInvalidRevision? {
        self as? DBXFilesRestoreErrorInvalidRevision
    }

    @objc
    public var asInProgress: DBXFilesRestoreErrorInProgress? {
        self as? DBXFilesRestoreErrorInProgress
    }

    @objc
    public var asOther: DBXFilesRestoreErrorOther? {
        self as? DBXFilesRestoreErrorOther
    }
}

/// An error occurs when downloading metadata for the file.
@objc
public class DBXFilesRestoreErrorPathLookup: DBXFilesRestoreError {
    @objc
    public var pathLookup: DBXFilesLookupError

    @objc
    public init(_ arg: DBXFilesLookupError) {
        self.pathLookup = arg
        let swift = Files.RestoreError.pathLookup(arg.swift)
        super.init(swift: swift)
    }
}

/// An error occurs when trying to restore the file to that path.
@objc
public class DBXFilesRestoreErrorPathWrite: DBXFilesRestoreError {
    @objc
    public var pathWrite: DBXFilesWriteError

    @objc
    public init(_ arg: DBXFilesWriteError) {
        self.pathWrite = arg
        let swift = Files.RestoreError.pathWrite(arg.swift)
        super.init(swift: swift)
    }
}

/// The revision is invalid. It may not exist or may point to a deleted file.
@objc
public class DBXFilesRestoreErrorInvalidRevision: DBXFilesRestoreError {
    @objc
    public init() {
        let swift = Files.RestoreError.invalidRevision
        super.init(swift: swift)
    }
}

/// The restore is currently executing, but has not yet completed.
@objc
public class DBXFilesRestoreErrorInProgress: DBXFilesRestoreError {
    @objc
    public init() {
        let swift = Files.RestoreError.inProgress
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXFilesRestoreErrorOther: DBXFilesRestoreError {
    @objc
    public init() {
        let swift = Files.RestoreError.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible SaveCopyReferenceArg struct
@objc
public class DBXFilesSaveCopyReferenceArg: NSObject {
    /// A copy reference returned by copyReferenceGet.
    @objc
    public var copyReference: String { swift.copyReference }
    /// Path in the user's Dropbox that is the destination.
    @objc
    public var path: String { swift.path }

    @objc
    public init(copyReference: String, path: String) {
        self.swift = Files.SaveCopyReferenceArg(copyReference: copyReference, path: path)
    }

    let swift: Files.SaveCopyReferenceArg

    public init(swift: Files.SaveCopyReferenceArg) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible SaveCopyReferenceError union
@objc
public class DBXFilesSaveCopyReferenceError: NSObject {
    let swift: Files.SaveCopyReferenceError

    public init(swift: Files.SaveCopyReferenceError) {
        self.swift = swift
    }

    public static func factory(swift: Files.SaveCopyReferenceError) -> DBXFilesSaveCopyReferenceError {
        switch swift {
        case .path(let swiftArg):
            let arg = DBXFilesWriteError(swift: swiftArg)
            return DBXFilesSaveCopyReferenceErrorPath(arg)
        case .invalidCopyReference:
            return DBXFilesSaveCopyReferenceErrorInvalidCopyReference()
        case .noPermission:
            return DBXFilesSaveCopyReferenceErrorNoPermission()
        case .notFound:
            return DBXFilesSaveCopyReferenceErrorNotFound()
        case .tooManyFiles:
            return DBXFilesSaveCopyReferenceErrorTooManyFiles()
        case .other:
            return DBXFilesSaveCopyReferenceErrorOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asPath: DBXFilesSaveCopyReferenceErrorPath? {
        self as? DBXFilesSaveCopyReferenceErrorPath
    }

    @objc
    public var asInvalidCopyReference: DBXFilesSaveCopyReferenceErrorInvalidCopyReference? {
        self as? DBXFilesSaveCopyReferenceErrorInvalidCopyReference
    }

    @objc
    public var asNoPermission: DBXFilesSaveCopyReferenceErrorNoPermission? {
        self as? DBXFilesSaveCopyReferenceErrorNoPermission
    }

    @objc
    public var asNotFound: DBXFilesSaveCopyReferenceErrorNotFound? {
        self as? DBXFilesSaveCopyReferenceErrorNotFound
    }

    @objc
    public var asTooManyFiles: DBXFilesSaveCopyReferenceErrorTooManyFiles? {
        self as? DBXFilesSaveCopyReferenceErrorTooManyFiles
    }

    @objc
    public var asOther: DBXFilesSaveCopyReferenceErrorOther? {
        self as? DBXFilesSaveCopyReferenceErrorOther
    }
}

/// An unspecified error.
@objc
public class DBXFilesSaveCopyReferenceErrorPath: DBXFilesSaveCopyReferenceError {
    @objc
    public var path: DBXFilesWriteError

    @objc
    public init(_ arg: DBXFilesWriteError) {
        self.path = arg
        let swift = Files.SaveCopyReferenceError.path(arg.swift)
        super.init(swift: swift)
    }
}

/// The copy reference is invalid.
@objc
public class DBXFilesSaveCopyReferenceErrorInvalidCopyReference: DBXFilesSaveCopyReferenceError {
    @objc
    public init() {
        let swift = Files.SaveCopyReferenceError.invalidCopyReference
        super.init(swift: swift)
    }
}

/// You don't have permission to save the given copy reference. Please make sure this app is same app which
/// created the copy reference and the source user is still linked to the app.
@objc
public class DBXFilesSaveCopyReferenceErrorNoPermission: DBXFilesSaveCopyReferenceError {
    @objc
    public init() {
        let swift = Files.SaveCopyReferenceError.noPermission
        super.init(swift: swift)
    }
}

/// The file referenced by the copy reference cannot be found.
@objc
public class DBXFilesSaveCopyReferenceErrorNotFound: DBXFilesSaveCopyReferenceError {
    @objc
    public init() {
        let swift = Files.SaveCopyReferenceError.notFound
        super.init(swift: swift)
    }
}

/// The operation would involve more than 10,000 files and folders.
@objc
public class DBXFilesSaveCopyReferenceErrorTooManyFiles: DBXFilesSaveCopyReferenceError {
    @objc
    public init() {
        let swift = Files.SaveCopyReferenceError.tooManyFiles
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXFilesSaveCopyReferenceErrorOther: DBXFilesSaveCopyReferenceError {
    @objc
    public init() {
        let swift = Files.SaveCopyReferenceError.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible SaveCopyReferenceResult struct
@objc
public class DBXFilesSaveCopyReferenceResult: NSObject {
    /// The metadata of the saved file or folder in the user's Dropbox.
    @objc
    public var metadata: DBXFilesMetadata {
        DBXFilesMetadata.wrapPreservingSubtypes(swift: swift.metadata)
    }

    @objc
    public init(metadata: DBXFilesMetadata) {
        self.swift = Files.SaveCopyReferenceResult(metadata: metadata.swift)
    }

    let swift: Files.SaveCopyReferenceResult

    public init(swift: Files.SaveCopyReferenceResult) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible SaveUrlArg struct
@objc
public class DBXFilesSaveUrlArg: NSObject {
    /// The path in Dropbox where the URL will be saved to.
    @objc
    public var path: String { swift.path }
    /// The URL to be saved.
    @objc
    public var url: String { swift.url }

    @objc
    public init(path: String, url: String) {
        self.swift = Files.SaveUrlArg(path: path, url: url)
    }

    let swift: Files.SaveUrlArg

    public init(swift: Files.SaveUrlArg) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible SaveUrlError union
@objc
public class DBXFilesSaveUrlError: NSObject {
    let swift: Files.SaveUrlError

    public init(swift: Files.SaveUrlError) {
        self.swift = swift
    }

    public static func factory(swift: Files.SaveUrlError) -> DBXFilesSaveUrlError {
        switch swift {
        case .path(let swiftArg):
            let arg = DBXFilesWriteError(swift: swiftArg)
            return DBXFilesSaveUrlErrorPath(arg)
        case .downloadFailed:
            return DBXFilesSaveUrlErrorDownloadFailed()
        case .invalidUrl:
            return DBXFilesSaveUrlErrorInvalidUrl()
        case .notFound:
            return DBXFilesSaveUrlErrorNotFound()
        case .other:
            return DBXFilesSaveUrlErrorOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asPath: DBXFilesSaveUrlErrorPath? {
        self as? DBXFilesSaveUrlErrorPath
    }

    @objc
    public var asDownloadFailed: DBXFilesSaveUrlErrorDownloadFailed? {
        self as? DBXFilesSaveUrlErrorDownloadFailed
    }

    @objc
    public var asInvalidUrl: DBXFilesSaveUrlErrorInvalidUrl? {
        self as? DBXFilesSaveUrlErrorInvalidUrl
    }

    @objc
    public var asNotFound: DBXFilesSaveUrlErrorNotFound? {
        self as? DBXFilesSaveUrlErrorNotFound
    }

    @objc
    public var asOther: DBXFilesSaveUrlErrorOther? {
        self as? DBXFilesSaveUrlErrorOther
    }
}

/// An unspecified error.
@objc
public class DBXFilesSaveUrlErrorPath: DBXFilesSaveUrlError {
    @objc
    public var path: DBXFilesWriteError

    @objc
    public init(_ arg: DBXFilesWriteError) {
        self.path = arg
        let swift = Files.SaveUrlError.path(arg.swift)
        super.init(swift: swift)
    }
}

/// Failed downloading the given URL. The URL may be  password-protected and the password provided was
/// incorrect,  or the link may be disabled.
@objc
public class DBXFilesSaveUrlErrorDownloadFailed: DBXFilesSaveUrlError {
    @objc
    public init() {
        let swift = Files.SaveUrlError.downloadFailed
        super.init(swift: swift)
    }
}

/// The given URL is invalid.
@objc
public class DBXFilesSaveUrlErrorInvalidUrl: DBXFilesSaveUrlError {
    @objc
    public init() {
        let swift = Files.SaveUrlError.invalidUrl
        super.init(swift: swift)
    }
}

/// The file where the URL is saved to no longer exists.
@objc
public class DBXFilesSaveUrlErrorNotFound: DBXFilesSaveUrlError {
    @objc
    public init() {
        let swift = Files.SaveUrlError.notFound
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXFilesSaveUrlErrorOther: DBXFilesSaveUrlError {
    @objc
    public init() {
        let swift = Files.SaveUrlError.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible SaveUrlJobStatus union
@objc
public class DBXFilesSaveUrlJobStatus: NSObject {
    let swift: Files.SaveUrlJobStatus

    public init(swift: Files.SaveUrlJobStatus) {
        self.swift = swift
    }

    public static func factory(swift: Files.SaveUrlJobStatus) -> DBXFilesSaveUrlJobStatus {
        switch swift {
        case .inProgress:
            return DBXFilesSaveUrlJobStatusInProgress()
        case .complete(let swiftArg):
            let arg = DBXFilesFileMetadata(swift: swiftArg)
            return DBXFilesSaveUrlJobStatusComplete(arg)
        case .failed(let swiftArg):
            let arg = DBXFilesSaveUrlError(swift: swiftArg)
            return DBXFilesSaveUrlJobStatusFailed(arg)
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asInProgress: DBXFilesSaveUrlJobStatusInProgress? {
        self as? DBXFilesSaveUrlJobStatusInProgress
    }

    @objc
    public var asComplete: DBXFilesSaveUrlJobStatusComplete? {
        self as? DBXFilesSaveUrlJobStatusComplete
    }

    @objc
    public var asFailed: DBXFilesSaveUrlJobStatusFailed? {
        self as? DBXFilesSaveUrlJobStatusFailed
    }
}

/// The asynchronous job is still in progress.
@objc
public class DBXFilesSaveUrlJobStatusInProgress: DBXFilesSaveUrlJobStatus {
    @objc
    public init() {
        let swift = Files.SaveUrlJobStatus.inProgress
        super.init(swift: swift)
    }
}

/// Metadata of the file where the URL is saved to.
@objc
public class DBXFilesSaveUrlJobStatusComplete: DBXFilesSaveUrlJobStatus {
    @objc
    public var complete: DBXFilesFileMetadata

    @objc
    public init(_ arg: DBXFilesFileMetadata) {
        self.complete = arg
        let swift = Files.SaveUrlJobStatus.complete(arg.subSwift)
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXFilesSaveUrlJobStatusFailed: DBXFilesSaveUrlJobStatus {
    @objc
    public var failed: DBXFilesSaveUrlError

    @objc
    public init(_ arg: DBXFilesSaveUrlError) {
        self.failed = arg
        let swift = Files.SaveUrlJobStatus.failed(arg.swift)
        super.init(swift: swift)
    }
}

/// Objective-C compatible SaveUrlResult union
@objc
public class DBXFilesSaveUrlResult: NSObject {
    let swift: Files.SaveUrlResult

    public init(swift: Files.SaveUrlResult) {
        self.swift = swift
    }

    public static func factory(swift: Files.SaveUrlResult) -> DBXFilesSaveUrlResult {
        switch swift {
        case .asyncJobId(let swiftArg):
            let arg = swiftArg
            return DBXFilesSaveUrlResultAsyncJobId(arg)
        case .complete(let swiftArg):
            let arg = DBXFilesFileMetadata(swift: swiftArg)
            return DBXFilesSaveUrlResultComplete(arg)
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asAsyncJobId: DBXFilesSaveUrlResultAsyncJobId? {
        self as? DBXFilesSaveUrlResultAsyncJobId
    }

    @objc
    public var asComplete: DBXFilesSaveUrlResultComplete? {
        self as? DBXFilesSaveUrlResultComplete
    }
}

/// This response indicates that the processing is asynchronous. The string is an id that can be used to obtain
/// the status of the asynchronous job.
@objc
public class DBXFilesSaveUrlResultAsyncJobId: DBXFilesSaveUrlResult {
    @objc
    public var asyncJobId: String

    @objc
    public init(_ arg: String) {
        self.asyncJobId = arg
        let swift = Files.SaveUrlResult.asyncJobId(arg)
        super.init(swift: swift)
    }
}

/// Metadata of the file where the URL is saved to.
@objc
public class DBXFilesSaveUrlResultComplete: DBXFilesSaveUrlResult {
    @objc
    public var complete: DBXFilesFileMetadata

    @objc
    public init(_ arg: DBXFilesFileMetadata) {
        self.complete = arg
        let swift = Files.SaveUrlResult.complete(arg.subSwift)
        super.init(swift: swift)
    }
}

/// Objective-C compatible SearchArg struct
@objc
public class DBXFilesSearchArg: NSObject {
    /// The path in the user's Dropbox to search. Should probably be a folder.
    @objc
    public var path: String { swift.path }
    /// The string to search for. Query string may be rewritten to improve relevance of results. The string is split
    /// on spaces into multiple tokens. For file name searching, the last token is used for prefix matching
    /// (i.e. "bat c" matches "bat cave" but not "batman car").
    @objc
    public var query: String { swift.query }
    /// The starting index within the search results (used for paging).
    @objc
    public var start: NSNumber { swift.start as NSNumber }
    /// The maximum number of search results to return.
    @objc
    public var maxResults: NSNumber { swift.maxResults as NSNumber }
    /// The search mode (filename, filename_and_content, or deleted_filename). Note that searching file content is
    /// only available for Dropbox Business accounts.
    @objc
    public var mode: DBXFilesSearchMode { DBXFilesSearchMode(swift: swift.mode) }

    @objc
    public init(path: String, query: String, start: NSNumber, maxResults: NSNumber, mode: DBXFilesSearchMode) {
        self.swift = Files.SearchArg(path: path, query: query, start: start.uint64Value, maxResults: maxResults.uint64Value, mode: mode.swift)
    }

    let swift: Files.SearchArg

    public init(swift: Files.SearchArg) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible SearchError union
@objc
public class DBXFilesSearchError: NSObject {
    let swift: Files.SearchError

    public init(swift: Files.SearchError) {
        self.swift = swift
    }

    public static func factory(swift: Files.SearchError) -> DBXFilesSearchError {
        switch swift {
        case .path(let swiftArg):
            let arg = DBXFilesLookupError(swift: swiftArg)
            return DBXFilesSearchErrorPath(arg)
        case .invalidArgument(let swiftArg):
            let arg = swiftArg
            return DBXFilesSearchErrorInvalidArgument(arg)
        case .internalError:
            return DBXFilesSearchErrorInternalError()
        case .other:
            return DBXFilesSearchErrorOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asPath: DBXFilesSearchErrorPath? {
        self as? DBXFilesSearchErrorPath
    }

    @objc
    public var asInvalidArgument: DBXFilesSearchErrorInvalidArgument? {
        self as? DBXFilesSearchErrorInvalidArgument
    }

    @objc
    public var asInternalError: DBXFilesSearchErrorInternalError? {
        self as? DBXFilesSearchErrorInternalError
    }

    @objc
    public var asOther: DBXFilesSearchErrorOther? {
        self as? DBXFilesSearchErrorOther
    }
}

/// An unspecified error.
@objc
public class DBXFilesSearchErrorPath: DBXFilesSearchError {
    @objc
    public var path: DBXFilesLookupError

    @objc
    public init(_ arg: DBXFilesLookupError) {
        self.path = arg
        let swift = Files.SearchError.path(arg.swift)
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXFilesSearchErrorInvalidArgument: DBXFilesSearchError {
    @objc
    public var invalidArgument: String?

    @objc
    public init(_ arg: String?) {
        self.invalidArgument = arg
        let swift = Files.SearchError.invalidArgument(arg)
        super.init(swift: swift)
    }
}

/// Something went wrong, please try again.
@objc
public class DBXFilesSearchErrorInternalError: DBXFilesSearchError {
    @objc
    public init() {
        let swift = Files.SearchError.internalError
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXFilesSearchErrorOther: DBXFilesSearchError {
    @objc
    public init() {
        let swift = Files.SearchError.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible SearchMatch struct
@objc
public class DBXFilesSearchMatch: NSObject {
    /// The type of the match.
    @objc
    public var matchType: DBXFilesSearchMatchType { DBXFilesSearchMatchType(swift: swift.matchType) }
    /// The metadata for the matched file or folder.
    @objc
    public var metadata: DBXFilesMetadata {
        DBXFilesMetadata.wrapPreservingSubtypes(swift: swift.metadata)
    }

    @objc
    public init(matchType: DBXFilesSearchMatchType, metadata: DBXFilesMetadata) {
        self.swift = Files.SearchMatch(matchType: matchType.swift, metadata: metadata.swift)
    }

    let swift: Files.SearchMatch

    public init(swift: Files.SearchMatch) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible SearchMatchFieldOptions struct
@objc
public class DBXFilesSearchMatchFieldOptions: NSObject {
    /// Whether to include highlight span from file title.
    @objc
    public var includeHighlights: NSNumber { swift.includeHighlights as NSNumber }

    @objc
    public init(includeHighlights: NSNumber) {
        self.swift = Files.SearchMatchFieldOptions(includeHighlights: includeHighlights.boolValue)
    }

    let swift: Files.SearchMatchFieldOptions

    public init(swift: Files.SearchMatchFieldOptions) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Indicates what type of match was found for a given item.
@objc
public class DBXFilesSearchMatchType: NSObject {
    let swift: Files.SearchMatchType

    public init(swift: Files.SearchMatchType) {
        self.swift = swift
    }

    public static func factory(swift: Files.SearchMatchType) -> DBXFilesSearchMatchType {
        switch swift {
        case .filename:
            return DBXFilesSearchMatchTypeFilename()
        case .content:
            return DBXFilesSearchMatchTypeContent()
        case .both:
            return DBXFilesSearchMatchTypeBoth()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asFilename: DBXFilesSearchMatchTypeFilename? {
        self as? DBXFilesSearchMatchTypeFilename
    }

    @objc
    public var asContent: DBXFilesSearchMatchTypeContent? {
        self as? DBXFilesSearchMatchTypeContent
    }

    @objc
    public var asBoth: DBXFilesSearchMatchTypeBoth? {
        self as? DBXFilesSearchMatchTypeBoth
    }
}

/// This item was matched on its file or folder name.
@objc
public class DBXFilesSearchMatchTypeFilename: DBXFilesSearchMatchType {
    @objc
    public init() {
        let swift = Files.SearchMatchType.filename
        super.init(swift: swift)
    }
}

/// This item was matched based on its file contents.
@objc
public class DBXFilesSearchMatchTypeContent: DBXFilesSearchMatchType {
    @objc
    public init() {
        let swift = Files.SearchMatchType.content
        super.init(swift: swift)
    }
}

/// This item was matched based on both its contents and its file name.
@objc
public class DBXFilesSearchMatchTypeBoth: DBXFilesSearchMatchType {
    @objc
    public init() {
        let swift = Files.SearchMatchType.both
        super.init(swift: swift)
    }
}

/// Indicates what type of match was found for a given item.
@objc
public class DBXFilesSearchMatchTypeV2: NSObject {
    let swift: Files.SearchMatchTypeV2

    public init(swift: Files.SearchMatchTypeV2) {
        self.swift = swift
    }

    public static func factory(swift: Files.SearchMatchTypeV2) -> DBXFilesSearchMatchTypeV2 {
        switch swift {
        case .filename:
            return DBXFilesSearchMatchTypeV2Filename()
        case .fileContent:
            return DBXFilesSearchMatchTypeV2FileContent()
        case .filenameAndContent:
            return DBXFilesSearchMatchTypeV2FilenameAndContent()
        case .imageContent:
            return DBXFilesSearchMatchTypeV2ImageContent()
        case .other:
            return DBXFilesSearchMatchTypeV2Other()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asFilename: DBXFilesSearchMatchTypeV2Filename? {
        self as? DBXFilesSearchMatchTypeV2Filename
    }

    @objc
    public var asFileContent: DBXFilesSearchMatchTypeV2FileContent? {
        self as? DBXFilesSearchMatchTypeV2FileContent
    }

    @objc
    public var asFilenameAndContent: DBXFilesSearchMatchTypeV2FilenameAndContent? {
        self as? DBXFilesSearchMatchTypeV2FilenameAndContent
    }

    @objc
    public var asImageContent: DBXFilesSearchMatchTypeV2ImageContent? {
        self as? DBXFilesSearchMatchTypeV2ImageContent
    }

    @objc
    public var asOther: DBXFilesSearchMatchTypeV2Other? {
        self as? DBXFilesSearchMatchTypeV2Other
    }
}

/// This item was matched on its file or folder name.
@objc
public class DBXFilesSearchMatchTypeV2Filename: DBXFilesSearchMatchTypeV2 {
    @objc
    public init() {
        let swift = Files.SearchMatchTypeV2.filename
        super.init(swift: swift)
    }
}

/// This item was matched based on its file contents.
@objc
public class DBXFilesSearchMatchTypeV2FileContent: DBXFilesSearchMatchTypeV2 {
    @objc
    public init() {
        let swift = Files.SearchMatchTypeV2.fileContent
        super.init(swift: swift)
    }
}

/// This item was matched based on both its contents and its file name.
@objc
public class DBXFilesSearchMatchTypeV2FilenameAndContent: DBXFilesSearchMatchTypeV2 {
    @objc
    public init() {
        let swift = Files.SearchMatchTypeV2.filenameAndContent
        super.init(swift: swift)
    }
}

/// This item was matched on image content.
@objc
public class DBXFilesSearchMatchTypeV2ImageContent: DBXFilesSearchMatchTypeV2 {
    @objc
    public init() {
        let swift = Files.SearchMatchTypeV2.imageContent
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXFilesSearchMatchTypeV2Other: DBXFilesSearchMatchTypeV2 {
    @objc
    public init() {
        let swift = Files.SearchMatchTypeV2.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible SearchMatchV2 struct
@objc
public class DBXFilesSearchMatchV2: NSObject {
    /// The metadata for the matched file or folder.
    @objc
    public var metadata: DBXFilesMetadataV2 { DBXFilesMetadataV2(swift: swift.metadata) }
    /// The type of the match.
    @objc
    public var matchType: DBXFilesSearchMatchTypeV2? { guard let swift = swift.matchType else { return nil }
        return DBXFilesSearchMatchTypeV2(swift: swift)
    }

    /// The list of HighlightSpan determines which parts of the file title should be highlighted.
    @objc
    public var highlightSpans: [DBXFilesHighlightSpan]? { swift.highlightSpans?.map { DBXFilesHighlightSpan(swift: $0) } }

    @objc
    public init(metadata: DBXFilesMetadataV2, matchType: DBXFilesSearchMatchTypeV2?, highlightSpans: [DBXFilesHighlightSpan]?) {
        self.swift = Files.SearchMatchV2(metadata: metadata.swift, matchType: matchType?.swift, highlightSpans: highlightSpans?.map(\.swift))
    }

    let swift: Files.SearchMatchV2

    public init(swift: Files.SearchMatchV2) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible SearchMode union
@objc
public class DBXFilesSearchMode: NSObject {
    let swift: Files.SearchMode

    public init(swift: Files.SearchMode) {
        self.swift = swift
    }

    public static func factory(swift: Files.SearchMode) -> DBXFilesSearchMode {
        switch swift {
        case .filename:
            return DBXFilesSearchModeFilename()
        case .filenameAndContent:
            return DBXFilesSearchModeFilenameAndContent()
        case .deletedFilename:
            return DBXFilesSearchModeDeletedFilename()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asFilename: DBXFilesSearchModeFilename? {
        self as? DBXFilesSearchModeFilename
    }

    @objc
    public var asFilenameAndContent: DBXFilesSearchModeFilenameAndContent? {
        self as? DBXFilesSearchModeFilenameAndContent
    }

    @objc
    public var asDeletedFilename: DBXFilesSearchModeDeletedFilename? {
        self as? DBXFilesSearchModeDeletedFilename
    }
}

/// Search file and folder names.
@objc
public class DBXFilesSearchModeFilename: DBXFilesSearchMode {
    @objc
    public init() {
        let swift = Files.SearchMode.filename
        super.init(swift: swift)
    }
}

/// Search file and folder names as well as file contents.
@objc
public class DBXFilesSearchModeFilenameAndContent: DBXFilesSearchMode {
    @objc
    public init() {
        let swift = Files.SearchMode.filenameAndContent
        super.init(swift: swift)
    }
}

/// Search for deleted file and folder names.
@objc
public class DBXFilesSearchModeDeletedFilename: DBXFilesSearchMode {
    @objc
    public init() {
        let swift = Files.SearchMode.deletedFilename
        super.init(swift: swift)
    }
}

/// Objective-C compatible SearchOptions struct
@objc
public class DBXFilesSearchOptions: NSObject {
    /// Scopes the search to a path in the user's Dropbox. Searches the entire Dropbox if not specified.
    @objc
    public var path: String? { swift.path }
    /// The maximum number of search results to return.
    @objc
    public var maxResults: NSNumber { swift.maxResults as NSNumber }
    /// Specified property of the order of search results. By default, results are sorted by relevance.
    @objc
    public var orderBy: DBXFilesSearchOrderBy? { guard let swift = swift.orderBy else { return nil }
        return DBXFilesSearchOrderBy(swift: swift)
    }

    /// Restricts search to the given file status.
    @objc
    public var fileStatus: DBXFilesFileStatus { DBXFilesFileStatus(swift: swift.fileStatus) }
    /// Restricts search to only match on filenames.
    @objc
    public var filenameOnly: NSNumber { swift.filenameOnly as NSNumber }
    /// Restricts search to only the extensions specified. Only supported for active file search.
    @objc
    public var fileExtensions: [String]? { swift.fileExtensions }
    /// Restricts search to only the file categories specified. Only supported for active file search.
    @objc
    public var fileCategories: [DBXFilesFileCategory]? { swift.fileCategories?.map { DBXFilesFileCategory(swift: $0) } }
    /// Restricts results to the given account id.
    @objc
    public var accountId: String? { swift.accountId }

    @objc
    public init(
        path: String?,
        maxResults: NSNumber,
        orderBy: DBXFilesSearchOrderBy?,
        fileStatus: DBXFilesFileStatus,
        filenameOnly: NSNumber,
        fileExtensions: [String]?,
        fileCategories: [DBXFilesFileCategory]?,
        accountId: String?
    ) {
        self.swift = Files.SearchOptions(
            path: path,
            maxResults: maxResults.uint64Value,
            orderBy: orderBy?.swift,
            fileStatus: fileStatus.swift,
            filenameOnly: filenameOnly.boolValue,
            fileExtensions: fileExtensions,
            fileCategories: fileCategories?.map(\.swift),
            accountId: accountId
        )
    }

    let swift: Files.SearchOptions

    public init(swift: Files.SearchOptions) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible SearchOrderBy union
@objc
public class DBXFilesSearchOrderBy: NSObject {
    let swift: Files.SearchOrderBy

    public init(swift: Files.SearchOrderBy) {
        self.swift = swift
    }

    public static func factory(swift: Files.SearchOrderBy) -> DBXFilesSearchOrderBy {
        switch swift {
        case .relevance:
            return DBXFilesSearchOrderByRelevance()
        case .lastModifiedTime:
            return DBXFilesSearchOrderByLastModifiedTime()
        case .other:
            return DBXFilesSearchOrderByOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asRelevance: DBXFilesSearchOrderByRelevance? {
        self as? DBXFilesSearchOrderByRelevance
    }

    @objc
    public var asLastModifiedTime: DBXFilesSearchOrderByLastModifiedTime? {
        self as? DBXFilesSearchOrderByLastModifiedTime
    }

    @objc
    public var asOther: DBXFilesSearchOrderByOther? {
        self as? DBXFilesSearchOrderByOther
    }
}

/// An unspecified error.
@objc
public class DBXFilesSearchOrderByRelevance: DBXFilesSearchOrderBy {
    @objc
    public init() {
        let swift = Files.SearchOrderBy.relevance
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXFilesSearchOrderByLastModifiedTime: DBXFilesSearchOrderBy {
    @objc
    public init() {
        let swift = Files.SearchOrderBy.lastModifiedTime
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXFilesSearchOrderByOther: DBXFilesSearchOrderBy {
    @objc
    public init() {
        let swift = Files.SearchOrderBy.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible SearchResult struct
@objc
public class DBXFilesSearchResult: NSObject {
    /// A list (possibly empty) of matches for the query.
    @objc
    public var matches: [DBXFilesSearchMatch] { swift.matches.map { DBXFilesSearchMatch(swift: $0) } }
    /// Used for paging. If true, indicates there is another page of results available that can be fetched by
    /// calling search again.
    @objc
    public var more: NSNumber { swift.more as NSNumber }
    /// Used for paging. Value to set the start argument to when calling search to fetch the next page of results.
    @objc
    public var start: NSNumber { swift.start as NSNumber }

    @objc
    public init(matches: [DBXFilesSearchMatch], more: NSNumber, start: NSNumber) {
        self.swift = Files.SearchResult(matches: matches.map(\.swift), more: more.boolValue, start: start.uint64Value)
    }

    let swift: Files.SearchResult

    public init(swift: Files.SearchResult) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible SearchV2Arg struct
@objc
public class DBXFilesSearchV2Arg: NSObject {
    /// The string to search for. May match across multiple fields based on the request arguments.
    @objc
    public var query: String { swift.query }
    /// Options for more targeted search results.
    @objc
    public var options: DBXFilesSearchOptions? { guard let swift = swift.options else { return nil }
        return DBXFilesSearchOptions(swift: swift)
    }

    /// Options for search results match fields.
    @objc
    public var matchFieldOptions: DBXFilesSearchMatchFieldOptions? { guard let swift = swift.matchFieldOptions else { return nil }
        return DBXFilesSearchMatchFieldOptions(swift: swift)
    }

    /// Deprecated and moved this option to SearchMatchFieldOptions.
    @objc
    public var includeHighlights: NSNumber? { swift.includeHighlights as NSNumber? }

    @objc
    public init(query: String, options: DBXFilesSearchOptions?, matchFieldOptions: DBXFilesSearchMatchFieldOptions?, includeHighlights: NSNumber?) {
        self.swift = Files.SearchV2Arg(
            query: query,
            options: options?.swift,
            matchFieldOptions: matchFieldOptions?.swift,
            includeHighlights: includeHighlights?.boolValue
        )
    }

    let swift: Files.SearchV2Arg

    public init(swift: Files.SearchV2Arg) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible SearchV2ContinueArg struct
@objc
public class DBXFilesSearchV2ContinueArg: NSObject {
    /// The cursor returned by your last call to searchV2. Used to fetch the next page of results.
    @objc
    public var cursor: String { swift.cursor }

    @objc
    public init(cursor: String) {
        self.swift = Files.SearchV2ContinueArg(cursor: cursor)
    }

    let swift: Files.SearchV2ContinueArg

    public init(swift: Files.SearchV2ContinueArg) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible SearchV2Result struct
@objc
public class DBXFilesSearchV2Result: NSObject {
    /// A list (possibly empty) of matches for the query.
    @objc
    public var matches: [DBXFilesSearchMatchV2] { swift.matches.map { DBXFilesSearchMatchV2(swift: $0) } }
    /// Used for paging. If true, indicates there is another page of results available that can be fetched by
    /// calling searchContinueV2 with the cursor.
    @objc
    public var hasMore: NSNumber { swift.hasMore as NSNumber }
    /// Pass the cursor into searchContinueV2 to fetch the next page of results.
    @objc
    public var cursor: String? { swift.cursor }

    @objc
    public init(matches: [DBXFilesSearchMatchV2], hasMore: NSNumber, cursor: String?) {
        self.swift = Files.SearchV2Result(matches: matches.map(\.swift), hasMore: hasMore.boolValue, cursor: cursor)
    }

    let swift: Files.SearchV2Result

    public init(swift: Files.SearchV2Result) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible SharedLink struct
@objc
public class DBXFilesSharedLink: NSObject {
    /// Shared link url.
    @objc
    public var url: String { swift.url }
    /// Password for the shared link.
    @objc
    public var password: String? { swift.password }

    @objc
    public init(url: String, password: String?) {
        self.swift = Files.SharedLink(url: url, password: password)
    }

    let swift: Files.SharedLink

    public init(swift: Files.SharedLink) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible SharedLinkFileInfo struct
@objc
public class DBXFilesSharedLinkFileInfo: NSObject {
    /// The shared link corresponding to either a file or shared link to a folder. If it is for a folder shared
    /// link, we use the path param to determine for which file in the folder the view is for.
    @objc
    public var url: String { swift.url }
    /// The path corresponding to a file in a shared link to a folder. Required for shared links to folders.
    @objc
    public var path: String? { swift.path }
    /// Password for the shared link. Required for password-protected shared links to files  unless it can be read
    /// from a cookie.
    @objc
    public var password: String? { swift.password }

    @objc
    public init(url: String, path: String?, password: String?) {
        self.swift = Files.SharedLinkFileInfo(url: url, path: path, password: password)
    }

    let swift: Files.SharedLinkFileInfo

    public init(swift: Files.SharedLinkFileInfo) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible SingleUserLock struct
@objc
public class DBXFilesSingleUserLock: NSObject {
    /// The time the lock was created.
    @objc
    public var created: Date { swift.created }
    /// The account ID of the lock holder if known.
    @objc
    public var lockHolderAccountId: String { swift.lockHolderAccountId }
    /// The id of the team of the account holder if it exists.
    @objc
    public var lockHolderTeamId: String? { swift.lockHolderTeamId }

    @objc
    public init(created: Date, lockHolderAccountId: String, lockHolderTeamId: String?) {
        self.swift = Files.SingleUserLock(created: created, lockHolderAccountId: lockHolderAccountId, lockHolderTeamId: lockHolderTeamId)
    }

    let swift: Files.SingleUserLock

    public init(swift: Files.SingleUserLock) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible SymlinkInfo struct
@objc
public class DBXFilesSymlinkInfo: NSObject {
    /// The target this symlink points to.
    @objc
    public var target: String { swift.target }

    @objc
    public init(target: String) {
        self.swift = Files.SymlinkInfo(target: target)
    }

    let swift: Files.SymlinkInfo

    public init(swift: Files.SymlinkInfo) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible SyncSetting union
@objc
public class DBXFilesSyncSetting: NSObject {
    let swift: Files.SyncSetting

    public init(swift: Files.SyncSetting) {
        self.swift = swift
    }

    public static func factory(swift: Files.SyncSetting) -> DBXFilesSyncSetting {
        switch swift {
        case .default_:
            return DBXFilesSyncSettingDefault_()
        case .notSynced:
            return DBXFilesSyncSettingNotSynced()
        case .notSyncedInactive:
            return DBXFilesSyncSettingNotSyncedInactive()
        case .other:
            return DBXFilesSyncSettingOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asDefault_: DBXFilesSyncSettingDefault_? {
        self as? DBXFilesSyncSettingDefault_
    }

    @objc
    public var asNotSynced: DBXFilesSyncSettingNotSynced? {
        self as? DBXFilesSyncSettingNotSynced
    }

    @objc
    public var asNotSyncedInactive: DBXFilesSyncSettingNotSyncedInactive? {
        self as? DBXFilesSyncSettingNotSyncedInactive
    }

    @objc
    public var asOther: DBXFilesSyncSettingOther? {
        self as? DBXFilesSyncSettingOther
    }
}

/// On first sync to members' computers, the specified folder will follow its parent folder's setting or
/// otherwise follow default sync behavior.
@objc
public class DBXFilesSyncSettingDefault_: DBXFilesSyncSetting {
    @objc
    public init() {
        let swift = Files.SyncSetting.default_
        super.init(swift: swift)
    }
}

/// On first sync to members' computers, the specified folder will be set to not sync with selective sync.
@objc
public class DBXFilesSyncSettingNotSynced: DBXFilesSyncSetting {
    @objc
    public init() {
        let swift = Files.SyncSetting.notSynced
        super.init(swift: swift)
    }
}

/// The specified folder's not_synced setting is inactive due to its location or other configuration changes. It
/// will follow its parent folder's setting.
@objc
public class DBXFilesSyncSettingNotSyncedInactive: DBXFilesSyncSetting {
    @objc
    public init() {
        let swift = Files.SyncSetting.notSyncedInactive
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXFilesSyncSettingOther: DBXFilesSyncSetting {
    @objc
    public init() {
        let swift = Files.SyncSetting.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible SyncSettingArg union
@objc
public class DBXFilesSyncSettingArg: NSObject {
    let swift: Files.SyncSettingArg

    public init(swift: Files.SyncSettingArg) {
        self.swift = swift
    }

    public static func factory(swift: Files.SyncSettingArg) -> DBXFilesSyncSettingArg {
        switch swift {
        case .default_:
            return DBXFilesSyncSettingArgDefault_()
        case .notSynced:
            return DBXFilesSyncSettingArgNotSynced()
        case .other:
            return DBXFilesSyncSettingArgOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asDefault_: DBXFilesSyncSettingArgDefault_? {
        self as? DBXFilesSyncSettingArgDefault_
    }

    @objc
    public var asNotSynced: DBXFilesSyncSettingArgNotSynced? {
        self as? DBXFilesSyncSettingArgNotSynced
    }

    @objc
    public var asOther: DBXFilesSyncSettingArgOther? {
        self as? DBXFilesSyncSettingArgOther
    }
}

/// On first sync to members' computers, the specified folder will follow its parent folder's setting or
/// otherwise follow default sync behavior.
@objc
public class DBXFilesSyncSettingArgDefault_: DBXFilesSyncSettingArg {
    @objc
    public init() {
        let swift = Files.SyncSettingArg.default_
        super.init(swift: swift)
    }
}

/// On first sync to members' computers, the specified folder will be set to not sync with selective sync.
@objc
public class DBXFilesSyncSettingArgNotSynced: DBXFilesSyncSettingArg {
    @objc
    public init() {
        let swift = Files.SyncSettingArg.notSynced
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXFilesSyncSettingArgOther: DBXFilesSyncSettingArg {
    @objc
    public init() {
        let swift = Files.SyncSettingArg.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible SyncSettingsError union
@objc
public class DBXFilesSyncSettingsError: NSObject {
    let swift: Files.SyncSettingsError

    public init(swift: Files.SyncSettingsError) {
        self.swift = swift
    }

    public static func factory(swift: Files.SyncSettingsError) -> DBXFilesSyncSettingsError {
        switch swift {
        case .path(let swiftArg):
            let arg = DBXFilesLookupError(swift: swiftArg)
            return DBXFilesSyncSettingsErrorPath(arg)
        case .unsupportedCombination:
            return DBXFilesSyncSettingsErrorUnsupportedCombination()
        case .unsupportedConfiguration:
            return DBXFilesSyncSettingsErrorUnsupportedConfiguration()
        case .other:
            return DBXFilesSyncSettingsErrorOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asPath: DBXFilesSyncSettingsErrorPath? {
        self as? DBXFilesSyncSettingsErrorPath
    }

    @objc
    public var asUnsupportedCombination: DBXFilesSyncSettingsErrorUnsupportedCombination? {
        self as? DBXFilesSyncSettingsErrorUnsupportedCombination
    }

    @objc
    public var asUnsupportedConfiguration: DBXFilesSyncSettingsErrorUnsupportedConfiguration? {
        self as? DBXFilesSyncSettingsErrorUnsupportedConfiguration
    }

    @objc
    public var asOther: DBXFilesSyncSettingsErrorOther? {
        self as? DBXFilesSyncSettingsErrorOther
    }
}

/// An unspecified error.
@objc
public class DBXFilesSyncSettingsErrorPath: DBXFilesSyncSettingsError {
    @objc
    public var path: DBXFilesLookupError

    @objc
    public init(_ arg: DBXFilesLookupError) {
        self.path = arg
        let swift = Files.SyncSettingsError.path(arg.swift)
        super.init(swift: swift)
    }
}

/// Setting this combination of sync settings simultaneously is not supported.
@objc
public class DBXFilesSyncSettingsErrorUnsupportedCombination: DBXFilesSyncSettingsError {
    @objc
    public init() {
        let swift = Files.SyncSettingsError.unsupportedCombination
        super.init(swift: swift)
    }
}

/// The specified configuration is not supported.
@objc
public class DBXFilesSyncSettingsErrorUnsupportedConfiguration: DBXFilesSyncSettingsError {
    @objc
    public init() {
        let swift = Files.SyncSettingsError.unsupportedConfiguration
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXFilesSyncSettingsErrorOther: DBXFilesSyncSettingsError {
    @objc
    public init() {
        let swift = Files.SyncSettingsError.other
        super.init(swift: swift)
    }
}

/// Tag that can be added in multiple ways.
@objc
public class DBXFilesTag: NSObject {
    let swift: Files.Tag

    public init(swift: Files.Tag) {
        self.swift = swift
    }

    public static func factory(swift: Files.Tag) -> DBXFilesTag {
        switch swift {
        case .userGeneratedTag(let swiftArg):
            let arg = DBXFilesUserGeneratedTag(swift: swiftArg)
            return DBXFilesTagUserGeneratedTag(arg)
        case .other:
            return DBXFilesTagOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asUserGeneratedTag: DBXFilesTagUserGeneratedTag? {
        self as? DBXFilesTagUserGeneratedTag
    }

    @objc
    public var asOther: DBXFilesTagOther? {
        self as? DBXFilesTagOther
    }
}

/// Tag generated by the user.
@objc
public class DBXFilesTagUserGeneratedTag: DBXFilesTag {
    @objc
    public var userGeneratedTag: DBXFilesUserGeneratedTag

    @objc
    public init(_ arg: DBXFilesUserGeneratedTag) {
        self.userGeneratedTag = arg
        let swift = Files.Tag.userGeneratedTag(arg.swift)
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXFilesTagOther: DBXFilesTag {
    @objc
    public init() {
        let swift = Files.Tag.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible ThumbnailArg struct
@objc
public class DBXFilesThumbnailArg: NSObject {
    /// The path to the image file you want to thumbnail.
    @objc
    public var path: String { swift.path }
    /// The format for the thumbnail image, jpeg (default) or png. For  images that are photos, jpeg should be
    /// preferred, while png is  better for screenshots and digital arts.
    @objc
    public var format: DBXFilesThumbnailFormat { DBXFilesThumbnailFormat(swift: swift.format) }
    /// The size for the thumbnail image.
    @objc
    public var size: DBXFilesThumbnailSize { DBXFilesThumbnailSize(swift: swift.size) }
    /// How to resize and crop the image to achieve the desired size.
    @objc
    public var mode: DBXFilesThumbnailMode { DBXFilesThumbnailMode(swift: swift.mode) }

    @objc
    public init(path: String, format: DBXFilesThumbnailFormat, size: DBXFilesThumbnailSize, mode: DBXFilesThumbnailMode) {
        self.swift = Files.ThumbnailArg(path: path, format: format.swift, size: size.swift, mode: mode.swift)
    }

    let swift: Files.ThumbnailArg

    public init(swift: Files.ThumbnailArg) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible ThumbnailError union
@objc
public class DBXFilesThumbnailError: NSObject {
    let swift: Files.ThumbnailError

    public init(swift: Files.ThumbnailError) {
        self.swift = swift
    }

    public static func factory(swift: Files.ThumbnailError) -> DBXFilesThumbnailError {
        switch swift {
        case .path(let swiftArg):
            let arg = DBXFilesLookupError(swift: swiftArg)
            return DBXFilesThumbnailErrorPath(arg)
        case .unsupportedExtension:
            return DBXFilesThumbnailErrorUnsupportedExtension()
        case .unsupportedImage:
            return DBXFilesThumbnailErrorUnsupportedImage()
        case .conversionError:
            return DBXFilesThumbnailErrorConversionError()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asPath: DBXFilesThumbnailErrorPath? {
        self as? DBXFilesThumbnailErrorPath
    }

    @objc
    public var asUnsupportedExtension: DBXFilesThumbnailErrorUnsupportedExtension? {
        self as? DBXFilesThumbnailErrorUnsupportedExtension
    }

    @objc
    public var asUnsupportedImage: DBXFilesThumbnailErrorUnsupportedImage? {
        self as? DBXFilesThumbnailErrorUnsupportedImage
    }

    @objc
    public var asConversionError: DBXFilesThumbnailErrorConversionError? {
        self as? DBXFilesThumbnailErrorConversionError
    }
}

/// An error occurs when downloading metadata for the image.
@objc
public class DBXFilesThumbnailErrorPath: DBXFilesThumbnailError {
    @objc
    public var path: DBXFilesLookupError

    @objc
    public init(_ arg: DBXFilesLookupError) {
        self.path = arg
        let swift = Files.ThumbnailError.path(arg.swift)
        super.init(swift: swift)
    }
}

/// The file extension doesn't allow conversion to a thumbnail.
@objc
public class DBXFilesThumbnailErrorUnsupportedExtension: DBXFilesThumbnailError {
    @objc
    public init() {
        let swift = Files.ThumbnailError.unsupportedExtension
        super.init(swift: swift)
    }
}

/// The image cannot be converted to a thumbnail.
@objc
public class DBXFilesThumbnailErrorUnsupportedImage: DBXFilesThumbnailError {
    @objc
    public init() {
        let swift = Files.ThumbnailError.unsupportedImage
        super.init(swift: swift)
    }
}

/// An error occurs during thumbnail conversion.
@objc
public class DBXFilesThumbnailErrorConversionError: DBXFilesThumbnailError {
    @objc
    public init() {
        let swift = Files.ThumbnailError.conversionError
        super.init(swift: swift)
    }
}

/// Objective-C compatible ThumbnailFormat union
@objc
public class DBXFilesThumbnailFormat: NSObject {
    let swift: Files.ThumbnailFormat

    public init(swift: Files.ThumbnailFormat) {
        self.swift = swift
    }

    public static func factory(swift: Files.ThumbnailFormat) -> DBXFilesThumbnailFormat {
        switch swift {
        case .jpeg:
            return DBXFilesThumbnailFormatJpeg()
        case .png:
            return DBXFilesThumbnailFormatPng()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asJpeg: DBXFilesThumbnailFormatJpeg? {
        self as? DBXFilesThumbnailFormatJpeg
    }

    @objc
    public var asPng: DBXFilesThumbnailFormatPng? {
        self as? DBXFilesThumbnailFormatPng
    }
}

/// An unspecified error.
@objc
public class DBXFilesThumbnailFormatJpeg: DBXFilesThumbnailFormat {
    @objc
    public init() {
        let swift = Files.ThumbnailFormat.jpeg
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXFilesThumbnailFormatPng: DBXFilesThumbnailFormat {
    @objc
    public init() {
        let swift = Files.ThumbnailFormat.png
        super.init(swift: swift)
    }
}

/// Objective-C compatible ThumbnailMode union
@objc
public class DBXFilesThumbnailMode: NSObject {
    let swift: Files.ThumbnailMode

    public init(swift: Files.ThumbnailMode) {
        self.swift = swift
    }

    public static func factory(swift: Files.ThumbnailMode) -> DBXFilesThumbnailMode {
        switch swift {
        case .strict:
            return DBXFilesThumbnailModeStrict()
        case .bestfit:
            return DBXFilesThumbnailModeBestfit()
        case .fitoneBestfit:
            return DBXFilesThumbnailModeFitoneBestfit()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asStrict: DBXFilesThumbnailModeStrict? {
        self as? DBXFilesThumbnailModeStrict
    }

    @objc
    public var asBestfit: DBXFilesThumbnailModeBestfit? {
        self as? DBXFilesThumbnailModeBestfit
    }

    @objc
    public var asFitoneBestfit: DBXFilesThumbnailModeFitoneBestfit? {
        self as? DBXFilesThumbnailModeFitoneBestfit
    }
}

/// Scale down the image to fit within the given size.
@objc
public class DBXFilesThumbnailModeStrict: DBXFilesThumbnailMode {
    @objc
    public init() {
        let swift = Files.ThumbnailMode.strict
        super.init(swift: swift)
    }
}

/// Scale down the image to fit within the given size or its transpose.
@objc
public class DBXFilesThumbnailModeBestfit: DBXFilesThumbnailMode {
    @objc
    public init() {
        let swift = Files.ThumbnailMode.bestfit
        super.init(swift: swift)
    }
}

/// Scale down the image to completely cover the given size or its transpose.
@objc
public class DBXFilesThumbnailModeFitoneBestfit: DBXFilesThumbnailMode {
    @objc
    public init() {
        let swift = Files.ThumbnailMode.fitoneBestfit
        super.init(swift: swift)
    }
}

/// Objective-C compatible ThumbnailSize union
@objc
public class DBXFilesThumbnailSize: NSObject {
    let swift: Files.ThumbnailSize

    public init(swift: Files.ThumbnailSize) {
        self.swift = swift
    }

    public static func factory(swift: Files.ThumbnailSize) -> DBXFilesThumbnailSize {
        switch swift {
        case .w32h32:
            return DBXFilesThumbnailSizeW32h32()
        case .w64h64:
            return DBXFilesThumbnailSizeW64h64()
        case .w128h128:
            return DBXFilesThumbnailSizeW128h128()
        case .w256h256:
            return DBXFilesThumbnailSizeW256h256()
        case .w480h320:
            return DBXFilesThumbnailSizeW480h320()
        case .w640h480:
            return DBXFilesThumbnailSizeW640h480()
        case .w960h640:
            return DBXFilesThumbnailSizeW960h640()
        case .w1024h768:
            return DBXFilesThumbnailSizeW1024h768()
        case .w2048h1536:
            return DBXFilesThumbnailSizeW2048h1536()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asW32h32: DBXFilesThumbnailSizeW32h32? {
        self as? DBXFilesThumbnailSizeW32h32
    }

    @objc
    public var asW64h64: DBXFilesThumbnailSizeW64h64? {
        self as? DBXFilesThumbnailSizeW64h64
    }

    @objc
    public var asW128h128: DBXFilesThumbnailSizeW128h128? {
        self as? DBXFilesThumbnailSizeW128h128
    }

    @objc
    public var asW256h256: DBXFilesThumbnailSizeW256h256? {
        self as? DBXFilesThumbnailSizeW256h256
    }

    @objc
    public var asW480h320: DBXFilesThumbnailSizeW480h320? {
        self as? DBXFilesThumbnailSizeW480h320
    }

    @objc
    public var asW640h480: DBXFilesThumbnailSizeW640h480? {
        self as? DBXFilesThumbnailSizeW640h480
    }

    @objc
    public var asW960h640: DBXFilesThumbnailSizeW960h640? {
        self as? DBXFilesThumbnailSizeW960h640
    }

    @objc
    public var asW1024h768: DBXFilesThumbnailSizeW1024h768? {
        self as? DBXFilesThumbnailSizeW1024h768
    }

    @objc
    public var asW2048h1536: DBXFilesThumbnailSizeW2048h1536? {
        self as? DBXFilesThumbnailSizeW2048h1536
    }
}

/// 32 by 32 px.
@objc
public class DBXFilesThumbnailSizeW32h32: DBXFilesThumbnailSize {
    @objc
    public init() {
        let swift = Files.ThumbnailSize.w32h32
        super.init(swift: swift)
    }
}

/// 64 by 64 px.
@objc
public class DBXFilesThumbnailSizeW64h64: DBXFilesThumbnailSize {
    @objc
    public init() {
        let swift = Files.ThumbnailSize.w64h64
        super.init(swift: swift)
    }
}

/// 128 by 128 px.
@objc
public class DBXFilesThumbnailSizeW128h128: DBXFilesThumbnailSize {
    @objc
    public init() {
        let swift = Files.ThumbnailSize.w128h128
        super.init(swift: swift)
    }
}

/// 256 by 256 px.
@objc
public class DBXFilesThumbnailSizeW256h256: DBXFilesThumbnailSize {
    @objc
    public init() {
        let swift = Files.ThumbnailSize.w256h256
        super.init(swift: swift)
    }
}

/// 480 by 320 px.
@objc
public class DBXFilesThumbnailSizeW480h320: DBXFilesThumbnailSize {
    @objc
    public init() {
        let swift = Files.ThumbnailSize.w480h320
        super.init(swift: swift)
    }
}

/// 640 by 480 px.
@objc
public class DBXFilesThumbnailSizeW640h480: DBXFilesThumbnailSize {
    @objc
    public init() {
        let swift = Files.ThumbnailSize.w640h480
        super.init(swift: swift)
    }
}

/// 960 by 640 px.
@objc
public class DBXFilesThumbnailSizeW960h640: DBXFilesThumbnailSize {
    @objc
    public init() {
        let swift = Files.ThumbnailSize.w960h640
        super.init(swift: swift)
    }
}

/// 1024 by 768 px.
@objc
public class DBXFilesThumbnailSizeW1024h768: DBXFilesThumbnailSize {
    @objc
    public init() {
        let swift = Files.ThumbnailSize.w1024h768
        super.init(swift: swift)
    }
}

/// 2048 by 1536 px.
@objc
public class DBXFilesThumbnailSizeW2048h1536: DBXFilesThumbnailSize {
    @objc
    public init() {
        let swift = Files.ThumbnailSize.w2048h1536
        super.init(swift: swift)
    }
}

/// Objective-C compatible ThumbnailV2Arg struct
@objc
public class DBXFilesThumbnailV2Arg: NSObject {
    /// Information specifying which file to preview. This could be a path to a file, a shared link pointing to a
    /// file, or a shared link pointing to a folder, with a relative path.
    @objc
    public var resource: DBXFilesPathOrLink { DBXFilesPathOrLink(swift: swift.resource) }
    /// The format for the thumbnail image, jpeg (default) or png. For  images that are photos, jpeg should be
    /// preferred, while png is  better for screenshots and digital arts.
    @objc
    public var format: DBXFilesThumbnailFormat { DBXFilesThumbnailFormat(swift: swift.format) }
    /// The size for the thumbnail image.
    @objc
    public var size: DBXFilesThumbnailSize { DBXFilesThumbnailSize(swift: swift.size) }
    /// How to resize and crop the image to achieve the desired size.
    @objc
    public var mode: DBXFilesThumbnailMode { DBXFilesThumbnailMode(swift: swift.mode) }

    @objc
    public init(resource: DBXFilesPathOrLink, format: DBXFilesThumbnailFormat, size: DBXFilesThumbnailSize, mode: DBXFilesThumbnailMode) {
        self.swift = Files.ThumbnailV2Arg(resource: resource.swift, format: format.swift, size: size.swift, mode: mode.swift)
    }

    let swift: Files.ThumbnailV2Arg

    public init(swift: Files.ThumbnailV2Arg) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible ThumbnailV2Error union
@objc
public class DBXFilesThumbnailV2Error: NSObject {
    let swift: Files.ThumbnailV2Error

    public init(swift: Files.ThumbnailV2Error) {
        self.swift = swift
    }

    public static func factory(swift: Files.ThumbnailV2Error) -> DBXFilesThumbnailV2Error {
        switch swift {
        case .path(let swiftArg):
            let arg = DBXFilesLookupError(swift: swiftArg)
            return DBXFilesThumbnailV2ErrorPath(arg)
        case .unsupportedExtension:
            return DBXFilesThumbnailV2ErrorUnsupportedExtension()
        case .unsupportedImage:
            return DBXFilesThumbnailV2ErrorUnsupportedImage()
        case .conversionError:
            return DBXFilesThumbnailV2ErrorConversionError()
        case .accessDenied:
            return DBXFilesThumbnailV2ErrorAccessDenied()
        case .notFound:
            return DBXFilesThumbnailV2ErrorNotFound()
        case .other:
            return DBXFilesThumbnailV2ErrorOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asPath: DBXFilesThumbnailV2ErrorPath? {
        self as? DBXFilesThumbnailV2ErrorPath
    }

    @objc
    public var asUnsupportedExtension: DBXFilesThumbnailV2ErrorUnsupportedExtension? {
        self as? DBXFilesThumbnailV2ErrorUnsupportedExtension
    }

    @objc
    public var asUnsupportedImage: DBXFilesThumbnailV2ErrorUnsupportedImage? {
        self as? DBXFilesThumbnailV2ErrorUnsupportedImage
    }

    @objc
    public var asConversionError: DBXFilesThumbnailV2ErrorConversionError? {
        self as? DBXFilesThumbnailV2ErrorConversionError
    }

    @objc
    public var asAccessDenied: DBXFilesThumbnailV2ErrorAccessDenied? {
        self as? DBXFilesThumbnailV2ErrorAccessDenied
    }

    @objc
    public var asNotFound: DBXFilesThumbnailV2ErrorNotFound? {
        self as? DBXFilesThumbnailV2ErrorNotFound
    }

    @objc
    public var asOther: DBXFilesThumbnailV2ErrorOther? {
        self as? DBXFilesThumbnailV2ErrorOther
    }
}

/// An error occurred when downloading metadata for the image.
@objc
public class DBXFilesThumbnailV2ErrorPath: DBXFilesThumbnailV2Error {
    @objc
    public var path: DBXFilesLookupError

    @objc
    public init(_ arg: DBXFilesLookupError) {
        self.path = arg
        let swift = Files.ThumbnailV2Error.path(arg.swift)
        super.init(swift: swift)
    }
}

/// The file extension doesn't allow conversion to a thumbnail.
@objc
public class DBXFilesThumbnailV2ErrorUnsupportedExtension: DBXFilesThumbnailV2Error {
    @objc
    public init() {
        let swift = Files.ThumbnailV2Error.unsupportedExtension
        super.init(swift: swift)
    }
}

/// The image cannot be converted to a thumbnail.
@objc
public class DBXFilesThumbnailV2ErrorUnsupportedImage: DBXFilesThumbnailV2Error {
    @objc
    public init() {
        let swift = Files.ThumbnailV2Error.unsupportedImage
        super.init(swift: swift)
    }
}

/// An error occurred during thumbnail conversion.
@objc
public class DBXFilesThumbnailV2ErrorConversionError: DBXFilesThumbnailV2Error {
    @objc
    public init() {
        let swift = Files.ThumbnailV2Error.conversionError
        super.init(swift: swift)
    }
}

/// Access to this shared link is forbidden.
@objc
public class DBXFilesThumbnailV2ErrorAccessDenied: DBXFilesThumbnailV2Error {
    @objc
    public init() {
        let swift = Files.ThumbnailV2Error.accessDenied
        super.init(swift: swift)
    }
}

/// The shared link does not exist.
@objc
public class DBXFilesThumbnailV2ErrorNotFound: DBXFilesThumbnailV2Error {
    @objc
    public init() {
        let swift = Files.ThumbnailV2Error.notFound
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXFilesThumbnailV2ErrorOther: DBXFilesThumbnailV2Error {
    @objc
    public init() {
        let swift = Files.ThumbnailV2Error.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible UnlockFileArg struct
@objc
public class DBXFilesUnlockFileArg: NSObject {
    /// Path in the user's Dropbox to a file.
    @objc
    public var path: String { swift.path }

    @objc
    public init(path: String) {
        self.swift = Files.UnlockFileArg(path: path)
    }

    let swift: Files.UnlockFileArg

    public init(swift: Files.UnlockFileArg) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible UnlockFileBatchArg struct
@objc
public class DBXFilesUnlockFileBatchArg: NSObject {
    /// List of 'entries'. Each 'entry' contains a path of the file which will be unlocked. Duplicate path arguments
    /// in the batch are considered only once.
    @objc
    public var entries: [DBXFilesUnlockFileArg] { swift.entries.map { DBXFilesUnlockFileArg(swift: $0) } }

    @objc
    public init(entries: [DBXFilesUnlockFileArg]) {
        self.swift = Files.UnlockFileBatchArg(entries: entries.map(\.swift))
    }

    let swift: Files.UnlockFileBatchArg

    public init(swift: Files.UnlockFileBatchArg) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible UploadArg struct
@objc
public class DBXFilesUploadArg: DBXFilesCommitInfo {
    /// A hash of the file content uploaded in this call. If provided and the uploaded content does not match this
    /// hash, an error will be returned. For more information see our Content hash
    /// https://www.dropbox.com/developers/reference/content-hash page.
    @objc
    public var contentHash: String? { subSwift.contentHash }

    @objc
    public init(
        path: String,
        mode: DBXFilesWriteMode,
        autorename: NSNumber,
        clientModified: Date?,
        mute: NSNumber,
        propertyGroups: [DBXFilePropertiesPropertyGroup]?,
        strictConflict: NSNumber,
        contentHash: String?
    ) {
        let swift = Files.UploadArg(
            path: path,
            mode: mode.swift,
            autorename: autorename.boolValue,
            clientModified: clientModified,
            mute: mute.boolValue,
            propertyGroups: propertyGroups?.map(\.swift),
            strictConflict: strictConflict.boolValue,
            contentHash: contentHash
        )
        self.subSwift = swift
        super.init(swift: swift)
    }

    let subSwift: Files.UploadArg

    public init(swift: Files.UploadArg) {
        self.subSwift = swift
        super.init(swift: swift)
    }

    @objc
    public override var description: String { subSwift.description }
}

/// Objective-C compatible UploadError union
@objc
public class DBXFilesUploadError: NSObject {
    let swift: Files.UploadError

    public init(swift: Files.UploadError) {
        self.swift = swift
    }

    public static func factory(swift: Files.UploadError) -> DBXFilesUploadError {
        switch swift {
        case .path(let swiftArg):
            let arg = DBXFilesUploadWriteFailed(swift: swiftArg)
            return DBXFilesUploadErrorPath(arg)
        case .propertiesError(let swiftArg):
            let arg = DBXFilePropertiesInvalidPropertyGroupError(swift: swiftArg)
            return DBXFilesUploadErrorPropertiesError(arg)
        case .payloadTooLarge:
            return DBXFilesUploadErrorPayloadTooLarge()
        case .contentHashMismatch:
            return DBXFilesUploadErrorContentHashMismatch()
        case .other:
            return DBXFilesUploadErrorOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asPath: DBXFilesUploadErrorPath? {
        self as? DBXFilesUploadErrorPath
    }

    @objc
    public var asPropertiesError: DBXFilesUploadErrorPropertiesError? {
        self as? DBXFilesUploadErrorPropertiesError
    }

    @objc
    public var asPayloadTooLarge: DBXFilesUploadErrorPayloadTooLarge? {
        self as? DBXFilesUploadErrorPayloadTooLarge
    }

    @objc
    public var asContentHashMismatch: DBXFilesUploadErrorContentHashMismatch? {
        self as? DBXFilesUploadErrorContentHashMismatch
    }

    @objc
    public var asOther: DBXFilesUploadErrorOther? {
        self as? DBXFilesUploadErrorOther
    }
}

/// Unable to save the uploaded contents to a file.
@objc
public class DBXFilesUploadErrorPath: DBXFilesUploadError {
    @objc
    public var path: DBXFilesUploadWriteFailed

    @objc
    public init(_ arg: DBXFilesUploadWriteFailed) {
        self.path = arg
        let swift = Files.UploadError.path(arg.swift)
        super.init(swift: swift)
    }
}

/// The supplied property group is invalid. The file has uploaded without property groups.
@objc
public class DBXFilesUploadErrorPropertiesError: DBXFilesUploadError {
    @objc
    public var propertiesError: DBXFilePropertiesInvalidPropertyGroupError

    @objc
    public init(_ arg: DBXFilePropertiesInvalidPropertyGroupError) {
        self.propertiesError = arg
        let swift = Files.UploadError.propertiesError(arg.swift)
        super.init(swift: swift)
    }
}

/// The request payload must be at most 150 MB.
@objc
public class DBXFilesUploadErrorPayloadTooLarge: DBXFilesUploadError {
    @objc
    public init() {
        let swift = Files.UploadError.payloadTooLarge
        super.init(swift: swift)
    }
}

/// The content received by the Dropbox server in this call does not match the provided content hash.
@objc
public class DBXFilesUploadErrorContentHashMismatch: DBXFilesUploadError {
    @objc
    public init() {
        let swift = Files.UploadError.contentHashMismatch
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXFilesUploadErrorOther: DBXFilesUploadError {
    @objc
    public init() {
        let swift = Files.UploadError.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible UploadSessionAppendArg struct
@objc
public class DBXFilesUploadSessionAppendArg: NSObject {
    /// Contains the upload session ID and the offset.
    @objc
    public var cursor: DBXFilesUploadSessionCursor { DBXFilesUploadSessionCursor(swift: swift.cursor) }
    /// If true, the current session will be closed, at which point you won't be able to call uploadSessionAppendV2
    /// anymore with the current session.
    @objc
    public var close: NSNumber { swift.close as NSNumber }
    /// A hash of the file content uploaded in this call. If provided and the uploaded content does not match this
    /// hash, an error will be returned. For more information see our Content hash
    /// https://www.dropbox.com/developers/reference/content-hash page.
    @objc
    public var contentHash: String? { swift.contentHash }

    @objc
    public init(cursor: DBXFilesUploadSessionCursor, close: NSNumber, contentHash: String?) {
        self.swift = Files.UploadSessionAppendArg(cursor: cursor.swift, close: close.boolValue, contentHash: contentHash)
    }

    let swift: Files.UploadSessionAppendArg

    public init(swift: Files.UploadSessionAppendArg) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible UploadSessionLookupError union
@objc
public class DBXFilesUploadSessionLookupError: NSObject {
    let swift: Files.UploadSessionLookupError

    public init(swift: Files.UploadSessionLookupError) {
        self.swift = swift
    }

    public static func factory(swift: Files.UploadSessionLookupError) -> DBXFilesUploadSessionLookupError {
        switch swift {
        case .notFound:
            return DBXFilesUploadSessionLookupErrorNotFound()
        case .incorrectOffset(let swiftArg):
            let arg = DBXFilesUploadSessionOffsetError(swift: swiftArg)
            return DBXFilesUploadSessionLookupErrorIncorrectOffset(arg)
        case .closed:
            return DBXFilesUploadSessionLookupErrorClosed()
        case .notClosed:
            return DBXFilesUploadSessionLookupErrorNotClosed()
        case .tooLarge:
            return DBXFilesUploadSessionLookupErrorTooLarge()
        case .concurrentSessionInvalidOffset:
            return DBXFilesUploadSessionLookupErrorConcurrentSessionInvalidOffset()
        case .concurrentSessionInvalidDataSize:
            return DBXFilesUploadSessionLookupErrorConcurrentSessionInvalidDataSize()
        case .payloadTooLarge:
            return DBXFilesUploadSessionLookupErrorPayloadTooLarge()
        case .other:
            return DBXFilesUploadSessionLookupErrorOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asNotFound: DBXFilesUploadSessionLookupErrorNotFound? {
        self as? DBXFilesUploadSessionLookupErrorNotFound
    }

    @objc
    public var asIncorrectOffset: DBXFilesUploadSessionLookupErrorIncorrectOffset? {
        self as? DBXFilesUploadSessionLookupErrorIncorrectOffset
    }

    @objc
    public var asClosed: DBXFilesUploadSessionLookupErrorClosed? {
        self as? DBXFilesUploadSessionLookupErrorClosed
    }

    @objc
    public var asNotClosed: DBXFilesUploadSessionLookupErrorNotClosed? {
        self as? DBXFilesUploadSessionLookupErrorNotClosed
    }

    @objc
    public var asTooLarge: DBXFilesUploadSessionLookupErrorTooLarge? {
        self as? DBXFilesUploadSessionLookupErrorTooLarge
    }

    @objc
    public var asConcurrentSessionInvalidOffset: DBXFilesUploadSessionLookupErrorConcurrentSessionInvalidOffset? {
        self as? DBXFilesUploadSessionLookupErrorConcurrentSessionInvalidOffset
    }

    @objc
    public var asConcurrentSessionInvalidDataSize: DBXFilesUploadSessionLookupErrorConcurrentSessionInvalidDataSize? {
        self as? DBXFilesUploadSessionLookupErrorConcurrentSessionInvalidDataSize
    }

    @objc
    public var asPayloadTooLarge: DBXFilesUploadSessionLookupErrorPayloadTooLarge? {
        self as? DBXFilesUploadSessionLookupErrorPayloadTooLarge
    }

    @objc
    public var asOther: DBXFilesUploadSessionLookupErrorOther? {
        self as? DBXFilesUploadSessionLookupErrorOther
    }
}

/// The upload session ID was not found or has expired. Upload sessions are valid for 7 days.
@objc
public class DBXFilesUploadSessionLookupErrorNotFound: DBXFilesUploadSessionLookupError {
    @objc
    public init() {
        let swift = Files.UploadSessionLookupError.notFound
        super.init(swift: swift)
    }
}

/// The specified offset was incorrect. See the value for the correct offset. This error may occur when a
/// previous request was received and processed successfully but the client did not receive the
/// response, e.g. due to a network error.
@objc
public class DBXFilesUploadSessionLookupErrorIncorrectOffset: DBXFilesUploadSessionLookupError {
    @objc
    public var incorrectOffset: DBXFilesUploadSessionOffsetError

    @objc
    public init(_ arg: DBXFilesUploadSessionOffsetError) {
        self.incorrectOffset = arg
        let swift = Files.UploadSessionLookupError.incorrectOffset(arg.swift)
        super.init(swift: swift)
    }
}

/// You are attempting to append data to an upload session that has already been closed (i.e. committed).
@objc
public class DBXFilesUploadSessionLookupErrorClosed: DBXFilesUploadSessionLookupError {
    @objc
    public init() {
        let swift = Files.UploadSessionLookupError.closed
        super.init(swift: swift)
    }
}

/// The session must be closed before calling upload_session/finish_batch.
@objc
public class DBXFilesUploadSessionLookupErrorNotClosed: DBXFilesUploadSessionLookupError {
    @objc
    public init() {
        let swift = Files.UploadSessionLookupError.notClosed
        super.init(swift: swift)
    }
}

/// You can not append to the upload session because the size of a file should not reach the max file size limit
/// (i.e. 350GB).
@objc
public class DBXFilesUploadSessionLookupErrorTooLarge: DBXFilesUploadSessionLookupError {
    @objc
    public init() {
        let swift = Files.UploadSessionLookupError.tooLarge
        super.init(swift: swift)
    }
}

/// For concurrent upload sessions, offset needs to be multiple of 4194304 bytes.
@objc
public class DBXFilesUploadSessionLookupErrorConcurrentSessionInvalidOffset: DBXFilesUploadSessionLookupError {
    @objc
    public init() {
        let swift = Files.UploadSessionLookupError.concurrentSessionInvalidOffset
        super.init(swift: swift)
    }
}

/// For concurrent upload sessions, only chunks with size multiple of 4194304 bytes can be uploaded.
@objc
public class DBXFilesUploadSessionLookupErrorConcurrentSessionInvalidDataSize: DBXFilesUploadSessionLookupError {
    @objc
    public init() {
        let swift = Files.UploadSessionLookupError.concurrentSessionInvalidDataSize
        super.init(swift: swift)
    }
}

/// The request payload must be at most 150 MB.
@objc
public class DBXFilesUploadSessionLookupErrorPayloadTooLarge: DBXFilesUploadSessionLookupError {
    @objc
    public init() {
        let swift = Files.UploadSessionLookupError.payloadTooLarge
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXFilesUploadSessionLookupErrorOther: DBXFilesUploadSessionLookupError {
    @objc
    public init() {
        let swift = Files.UploadSessionLookupError.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible UploadSessionAppendError union
@objc
public class DBXFilesUploadSessionAppendError: NSObject {
    let swift: Files.UploadSessionAppendError

    public init(swift: Files.UploadSessionAppendError) {
        self.swift = swift
    }

    public static func factory(swift: Files.UploadSessionAppendError) -> DBXFilesUploadSessionAppendError {
        switch swift {
        case .notFound:
            return DBXFilesUploadSessionAppendErrorNotFound()
        case .incorrectOffset(let swiftArg):
            let arg = DBXFilesUploadSessionOffsetError(swift: swiftArg)
            return DBXFilesUploadSessionAppendErrorIncorrectOffset(arg)
        case .closed:
            return DBXFilesUploadSessionAppendErrorClosed()
        case .notClosed:
            return DBXFilesUploadSessionAppendErrorNotClosed()
        case .tooLarge:
            return DBXFilesUploadSessionAppendErrorTooLarge()
        case .concurrentSessionInvalidOffset:
            return DBXFilesUploadSessionAppendErrorConcurrentSessionInvalidOffset()
        case .concurrentSessionInvalidDataSize:
            return DBXFilesUploadSessionAppendErrorConcurrentSessionInvalidDataSize()
        case .payloadTooLarge:
            return DBXFilesUploadSessionAppendErrorPayloadTooLarge()
        case .other:
            return DBXFilesUploadSessionAppendErrorOther()
        case .contentHashMismatch:
            return DBXFilesUploadSessionAppendErrorContentHashMismatch()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asNotFound: DBXFilesUploadSessionAppendErrorNotFound? {
        self as? DBXFilesUploadSessionAppendErrorNotFound
    }

    @objc
    public var asIncorrectOffset: DBXFilesUploadSessionAppendErrorIncorrectOffset? {
        self as? DBXFilesUploadSessionAppendErrorIncorrectOffset
    }

    @objc
    public var asClosed: DBXFilesUploadSessionAppendErrorClosed? {
        self as? DBXFilesUploadSessionAppendErrorClosed
    }

    @objc
    public var asNotClosed: DBXFilesUploadSessionAppendErrorNotClosed? {
        self as? DBXFilesUploadSessionAppendErrorNotClosed
    }

    @objc
    public var asTooLarge: DBXFilesUploadSessionAppendErrorTooLarge? {
        self as? DBXFilesUploadSessionAppendErrorTooLarge
    }

    @objc
    public var asConcurrentSessionInvalidOffset: DBXFilesUploadSessionAppendErrorConcurrentSessionInvalidOffset? {
        self as? DBXFilesUploadSessionAppendErrorConcurrentSessionInvalidOffset
    }

    @objc
    public var asConcurrentSessionInvalidDataSize: DBXFilesUploadSessionAppendErrorConcurrentSessionInvalidDataSize? {
        self as? DBXFilesUploadSessionAppendErrorConcurrentSessionInvalidDataSize
    }

    @objc
    public var asPayloadTooLarge: DBXFilesUploadSessionAppendErrorPayloadTooLarge? {
        self as? DBXFilesUploadSessionAppendErrorPayloadTooLarge
    }

    @objc
    public var asOther: DBXFilesUploadSessionAppendErrorOther? {
        self as? DBXFilesUploadSessionAppendErrorOther
    }

    @objc
    public var asContentHashMismatch: DBXFilesUploadSessionAppendErrorContentHashMismatch? {
        self as? DBXFilesUploadSessionAppendErrorContentHashMismatch
    }
}

/// The upload session ID was not found or has expired. Upload sessions are valid for 7 days.
@objc
public class DBXFilesUploadSessionAppendErrorNotFound: DBXFilesUploadSessionAppendError {
    @objc
    public init() {
        let swift = Files.UploadSessionAppendError.notFound
        super.init(swift: swift)
    }
}

/// The specified offset was incorrect. See the value for the correct offset. This error may occur when a
/// previous request was received and processed successfully but the client did not receive the
/// response, e.g. due to a network error.
@objc
public class DBXFilesUploadSessionAppendErrorIncorrectOffset: DBXFilesUploadSessionAppendError {
    @objc
    public var incorrectOffset: DBXFilesUploadSessionOffsetError

    @objc
    public init(_ arg: DBXFilesUploadSessionOffsetError) {
        self.incorrectOffset = arg
        let swift = Files.UploadSessionAppendError.incorrectOffset(arg.swift)
        super.init(swift: swift)
    }
}

/// You are attempting to append data to an upload session that has already been closed (i.e. committed).
@objc
public class DBXFilesUploadSessionAppendErrorClosed: DBXFilesUploadSessionAppendError {
    @objc
    public init() {
        let swift = Files.UploadSessionAppendError.closed
        super.init(swift: swift)
    }
}

/// The session must be closed before calling upload_session/finish_batch.
@objc
public class DBXFilesUploadSessionAppendErrorNotClosed: DBXFilesUploadSessionAppendError {
    @objc
    public init() {
        let swift = Files.UploadSessionAppendError.notClosed
        super.init(swift: swift)
    }
}

/// You can not append to the upload session because the size of a file should not reach the max file size limit
/// (i.e. 350GB).
@objc
public class DBXFilesUploadSessionAppendErrorTooLarge: DBXFilesUploadSessionAppendError {
    @objc
    public init() {
        let swift = Files.UploadSessionAppendError.tooLarge
        super.init(swift: swift)
    }
}

/// For concurrent upload sessions, offset needs to be multiple of 4194304 bytes.
@objc
public class DBXFilesUploadSessionAppendErrorConcurrentSessionInvalidOffset: DBXFilesUploadSessionAppendError {
    @objc
    public init() {
        let swift = Files.UploadSessionAppendError.concurrentSessionInvalidOffset
        super.init(swift: swift)
    }
}

/// For concurrent upload sessions, only chunks with size multiple of 4194304 bytes can be uploaded.
@objc
public class DBXFilesUploadSessionAppendErrorConcurrentSessionInvalidDataSize: DBXFilesUploadSessionAppendError {
    @objc
    public init() {
        let swift = Files.UploadSessionAppendError.concurrentSessionInvalidDataSize
        super.init(swift: swift)
    }
}

/// The request payload must be at most 150 MB.
@objc
public class DBXFilesUploadSessionAppendErrorPayloadTooLarge: DBXFilesUploadSessionAppendError {
    @objc
    public init() {
        let swift = Files.UploadSessionAppendError.payloadTooLarge
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXFilesUploadSessionAppendErrorOther: DBXFilesUploadSessionAppendError {
    @objc
    public init() {
        let swift = Files.UploadSessionAppendError.other
        super.init(swift: swift)
    }
}

/// The content received by the Dropbox server in this call does not match the provided content hash.
@objc
public class DBXFilesUploadSessionAppendErrorContentHashMismatch: DBXFilesUploadSessionAppendError {
    @objc
    public init() {
        let swift = Files.UploadSessionAppendError.contentHashMismatch
        super.init(swift: swift)
    }
}

/// Objective-C compatible UploadSessionCursor struct
@objc
public class DBXFilesUploadSessionCursor: NSObject {
    /// The upload session ID (returned by uploadSessionStart).
    @objc
    public var sessionId: String { swift.sessionId }
    /// Offset in bytes at which data should be appended. We use this to make sure upload data isn't lost or
    /// duplicated in the event of a network error.
    @objc
    public var offset: NSNumber { swift.offset as NSNumber }

    @objc
    public init(sessionId: String, offset: NSNumber) {
        self.swift = Files.UploadSessionCursor(sessionId: sessionId, offset: offset.uint64Value)
    }

    let swift: Files.UploadSessionCursor

    public init(swift: Files.UploadSessionCursor) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible UploadSessionFinishArg struct
@objc
public class DBXFilesUploadSessionFinishArg: NSObject {
    /// Contains the upload session ID and the offset.
    @objc
    public var cursor: DBXFilesUploadSessionCursor { DBXFilesUploadSessionCursor(swift: swift.cursor) }
    /// Contains the path and other optional modifiers for the commit.
    @objc
    public var commit: DBXFilesCommitInfo { DBXFilesCommitInfo(swift: swift.commit) }
    /// A hash of the file content uploaded in this call. If provided and the uploaded content does not match this
    /// hash, an error will be returned. For more information see our Content hash
    /// https://www.dropbox.com/developers/reference/content-hash page.
    @objc
    public var contentHash: String? { swift.contentHash }

    @objc
    public init(cursor: DBXFilesUploadSessionCursor, commit: DBXFilesCommitInfo, contentHash: String?) {
        self.swift = Files.UploadSessionFinishArg(cursor: cursor.swift, commit: commit.swift, contentHash: contentHash)
    }

    let swift: Files.UploadSessionFinishArg

    public init(swift: Files.UploadSessionFinishArg) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible UploadSessionFinishBatchArg struct
@objc
public class DBXFilesUploadSessionFinishBatchArg: NSObject {
    /// Commit information for each file in the batch.
    @objc
    public var entries: [DBXFilesUploadSessionFinishArg] { swift.entries.map { DBXFilesUploadSessionFinishArg(swift: $0) } }

    @objc
    public init(entries: [DBXFilesUploadSessionFinishArg]) {
        self.swift = Files.UploadSessionFinishBatchArg(entries: entries.map(\.swift))
    }

    let swift: Files.UploadSessionFinishBatchArg

    public init(swift: Files.UploadSessionFinishBatchArg) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible UploadSessionFinishBatchJobStatus union
@objc
public class DBXFilesUploadSessionFinishBatchJobStatus: NSObject {
    let swift: Files.UploadSessionFinishBatchJobStatus

    public init(swift: Files.UploadSessionFinishBatchJobStatus) {
        self.swift = swift
    }

    public static func factory(swift: Files.UploadSessionFinishBatchJobStatus) -> DBXFilesUploadSessionFinishBatchJobStatus {
        switch swift {
        case .inProgress:
            return DBXFilesUploadSessionFinishBatchJobStatusInProgress()
        case .complete(let swiftArg):
            let arg = DBXFilesUploadSessionFinishBatchResult(swift: swiftArg)
            return DBXFilesUploadSessionFinishBatchJobStatusComplete(arg)
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asInProgress: DBXFilesUploadSessionFinishBatchJobStatusInProgress? {
        self as? DBXFilesUploadSessionFinishBatchJobStatusInProgress
    }

    @objc
    public var asComplete: DBXFilesUploadSessionFinishBatchJobStatusComplete? {
        self as? DBXFilesUploadSessionFinishBatchJobStatusComplete
    }
}

/// The asynchronous job is still in progress.
@objc
public class DBXFilesUploadSessionFinishBatchJobStatusInProgress: DBXFilesUploadSessionFinishBatchJobStatus {
    @objc
    public init() {
        let swift = Files.UploadSessionFinishBatchJobStatus.inProgress
        super.init(swift: swift)
    }
}

/// The uploadSessionFinishBatch has finished.
@objc
public class DBXFilesUploadSessionFinishBatchJobStatusComplete: DBXFilesUploadSessionFinishBatchJobStatus {
    @objc
    public var complete: DBXFilesUploadSessionFinishBatchResult

    @objc
    public init(_ arg: DBXFilesUploadSessionFinishBatchResult) {
        self.complete = arg
        let swift = Files.UploadSessionFinishBatchJobStatus.complete(arg.swift)
        super.init(swift: swift)
    }
}

/// Result returned by uploadSessionFinishBatch that may either launch an asynchronous job or complete
/// synchronously.
@objc
public class DBXFilesUploadSessionFinishBatchLaunch: NSObject {
    let swift: Files.UploadSessionFinishBatchLaunch

    public init(swift: Files.UploadSessionFinishBatchLaunch) {
        self.swift = swift
    }

    public static func factory(swift: Files.UploadSessionFinishBatchLaunch) -> DBXFilesUploadSessionFinishBatchLaunch {
        switch swift {
        case .asyncJobId(let swiftArg):
            let arg = swiftArg
            return DBXFilesUploadSessionFinishBatchLaunchAsyncJobId(arg)
        case .complete(let swiftArg):
            let arg = DBXFilesUploadSessionFinishBatchResult(swift: swiftArg)
            return DBXFilesUploadSessionFinishBatchLaunchComplete(arg)
        case .other:
            return DBXFilesUploadSessionFinishBatchLaunchOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asAsyncJobId: DBXFilesUploadSessionFinishBatchLaunchAsyncJobId? {
        self as? DBXFilesUploadSessionFinishBatchLaunchAsyncJobId
    }

    @objc
    public var asComplete: DBXFilesUploadSessionFinishBatchLaunchComplete? {
        self as? DBXFilesUploadSessionFinishBatchLaunchComplete
    }

    @objc
    public var asOther: DBXFilesUploadSessionFinishBatchLaunchOther? {
        self as? DBXFilesUploadSessionFinishBatchLaunchOther
    }
}

/// This response indicates that the processing is asynchronous. The string is an id that can be used to obtain
/// the status of the asynchronous job.
@objc
public class DBXFilesUploadSessionFinishBatchLaunchAsyncJobId: DBXFilesUploadSessionFinishBatchLaunch {
    @objc
    public var asyncJobId: String

    @objc
    public init(_ arg: String) {
        self.asyncJobId = arg
        let swift = Files.UploadSessionFinishBatchLaunch.asyncJobId(arg)
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXFilesUploadSessionFinishBatchLaunchComplete: DBXFilesUploadSessionFinishBatchLaunch {
    @objc
    public var complete: DBXFilesUploadSessionFinishBatchResult

    @objc
    public init(_ arg: DBXFilesUploadSessionFinishBatchResult) {
        self.complete = arg
        let swift = Files.UploadSessionFinishBatchLaunch.complete(arg.swift)
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXFilesUploadSessionFinishBatchLaunchOther: DBXFilesUploadSessionFinishBatchLaunch {
    @objc
    public init() {
        let swift = Files.UploadSessionFinishBatchLaunch.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible UploadSessionFinishBatchResult struct
@objc
public class DBXFilesUploadSessionFinishBatchResult: NSObject {
    /// Each entry in entries in UploadSessionFinishBatchArg will appear at the same position inside entries in
    /// UploadSessionFinishBatchResult.
    @objc
    public var entries: [DBXFilesUploadSessionFinishBatchResultEntry] { swift.entries.map { DBXFilesUploadSessionFinishBatchResultEntry(swift: $0) } }

    @objc
    public init(entries: [DBXFilesUploadSessionFinishBatchResultEntry]) {
        self.swift = Files.UploadSessionFinishBatchResult(entries: entries.map(\.swift))
    }

    let swift: Files.UploadSessionFinishBatchResult

    public init(swift: Files.UploadSessionFinishBatchResult) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible UploadSessionFinishBatchResultEntry union
@objc
public class DBXFilesUploadSessionFinishBatchResultEntry: NSObject {
    let swift: Files.UploadSessionFinishBatchResultEntry

    public init(swift: Files.UploadSessionFinishBatchResultEntry) {
        self.swift = swift
    }

    public static func factory(swift: Files.UploadSessionFinishBatchResultEntry) -> DBXFilesUploadSessionFinishBatchResultEntry {
        switch swift {
        case .success(let swiftArg):
            let arg = DBXFilesFileMetadata(swift: swiftArg)
            return DBXFilesUploadSessionFinishBatchResultEntrySuccess(arg)
        case .failure(let swiftArg):
            let arg = DBXFilesUploadSessionFinishError(swift: swiftArg)
            return DBXFilesUploadSessionFinishBatchResultEntryFailure(arg)
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asSuccess: DBXFilesUploadSessionFinishBatchResultEntrySuccess? {
        self as? DBXFilesUploadSessionFinishBatchResultEntrySuccess
    }

    @objc
    public var asFailure: DBXFilesUploadSessionFinishBatchResultEntryFailure? {
        self as? DBXFilesUploadSessionFinishBatchResultEntryFailure
    }
}

/// An unspecified error.
@objc
public class DBXFilesUploadSessionFinishBatchResultEntrySuccess: DBXFilesUploadSessionFinishBatchResultEntry {
    @objc
    public var success: DBXFilesFileMetadata

    @objc
    public init(_ arg: DBXFilesFileMetadata) {
        self.success = arg
        let swift = Files.UploadSessionFinishBatchResultEntry.success(arg.subSwift)
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXFilesUploadSessionFinishBatchResultEntryFailure: DBXFilesUploadSessionFinishBatchResultEntry {
    @objc
    public var failure: DBXFilesUploadSessionFinishError

    @objc
    public init(_ arg: DBXFilesUploadSessionFinishError) {
        self.failure = arg
        let swift = Files.UploadSessionFinishBatchResultEntry.failure(arg.swift)
        super.init(swift: swift)
    }
}

/// Objective-C compatible UploadSessionFinishError union
@objc
public class DBXFilesUploadSessionFinishError: NSObject {
    let swift: Files.UploadSessionFinishError

    public init(swift: Files.UploadSessionFinishError) {
        self.swift = swift
    }

    public static func factory(swift: Files.UploadSessionFinishError) -> DBXFilesUploadSessionFinishError {
        switch swift {
        case .lookupFailed(let swiftArg):
            let arg = DBXFilesUploadSessionLookupError(swift: swiftArg)
            return DBXFilesUploadSessionFinishErrorLookupFailed(arg)
        case .path(let swiftArg):
            let arg = DBXFilesWriteError(swift: swiftArg)
            return DBXFilesUploadSessionFinishErrorPath(arg)
        case .propertiesError(let swiftArg):
            let arg = DBXFilePropertiesInvalidPropertyGroupError(swift: swiftArg)
            return DBXFilesUploadSessionFinishErrorPropertiesError(arg)
        case .tooManySharedFolderTargets:
            return DBXFilesUploadSessionFinishErrorTooManySharedFolderTargets()
        case .tooManyWriteOperations:
            return DBXFilesUploadSessionFinishErrorTooManyWriteOperations()
        case .concurrentSessionDataNotAllowed:
            return DBXFilesUploadSessionFinishErrorConcurrentSessionDataNotAllowed()
        case .concurrentSessionNotClosed:
            return DBXFilesUploadSessionFinishErrorConcurrentSessionNotClosed()
        case .concurrentSessionMissingData:
            return DBXFilesUploadSessionFinishErrorConcurrentSessionMissingData()
        case .payloadTooLarge:
            return DBXFilesUploadSessionFinishErrorPayloadTooLarge()
        case .contentHashMismatch:
            return DBXFilesUploadSessionFinishErrorContentHashMismatch()
        case .other:
            return DBXFilesUploadSessionFinishErrorOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asLookupFailed: DBXFilesUploadSessionFinishErrorLookupFailed? {
        self as? DBXFilesUploadSessionFinishErrorLookupFailed
    }

    @objc
    public var asPath: DBXFilesUploadSessionFinishErrorPath? {
        self as? DBXFilesUploadSessionFinishErrorPath
    }

    @objc
    public var asPropertiesError: DBXFilesUploadSessionFinishErrorPropertiesError? {
        self as? DBXFilesUploadSessionFinishErrorPropertiesError
    }

    @objc
    public var asTooManySharedFolderTargets: DBXFilesUploadSessionFinishErrorTooManySharedFolderTargets? {
        self as? DBXFilesUploadSessionFinishErrorTooManySharedFolderTargets
    }

    @objc
    public var asTooManyWriteOperations: DBXFilesUploadSessionFinishErrorTooManyWriteOperations? {
        self as? DBXFilesUploadSessionFinishErrorTooManyWriteOperations
    }

    @objc
    public var asConcurrentSessionDataNotAllowed: DBXFilesUploadSessionFinishErrorConcurrentSessionDataNotAllowed? {
        self as? DBXFilesUploadSessionFinishErrorConcurrentSessionDataNotAllowed
    }

    @objc
    public var asConcurrentSessionNotClosed: DBXFilesUploadSessionFinishErrorConcurrentSessionNotClosed? {
        self as? DBXFilesUploadSessionFinishErrorConcurrentSessionNotClosed
    }

    @objc
    public var asConcurrentSessionMissingData: DBXFilesUploadSessionFinishErrorConcurrentSessionMissingData? {
        self as? DBXFilesUploadSessionFinishErrorConcurrentSessionMissingData
    }

    @objc
    public var asPayloadTooLarge: DBXFilesUploadSessionFinishErrorPayloadTooLarge? {
        self as? DBXFilesUploadSessionFinishErrorPayloadTooLarge
    }

    @objc
    public var asContentHashMismatch: DBXFilesUploadSessionFinishErrorContentHashMismatch? {
        self as? DBXFilesUploadSessionFinishErrorContentHashMismatch
    }

    @objc
    public var asOther: DBXFilesUploadSessionFinishErrorOther? {
        self as? DBXFilesUploadSessionFinishErrorOther
    }
}

/// The session arguments are incorrect; the value explains the reason.
@objc
public class DBXFilesUploadSessionFinishErrorLookupFailed: DBXFilesUploadSessionFinishError {
    @objc
    public var lookupFailed: DBXFilesUploadSessionLookupError

    @objc
    public init(_ arg: DBXFilesUploadSessionLookupError) {
        self.lookupFailed = arg
        let swift = Files.UploadSessionFinishError.lookupFailed(arg.swift)
        super.init(swift: swift)
    }
}

/// Unable to save the uploaded contents to a file. Data has already been appended to the upload session. Please
/// retry with empty data body and updated offset.
@objc
public class DBXFilesUploadSessionFinishErrorPath: DBXFilesUploadSessionFinishError {
    @objc
    public var path: DBXFilesWriteError

    @objc
    public init(_ arg: DBXFilesWriteError) {
        self.path = arg
        let swift = Files.UploadSessionFinishError.path(arg.swift)
        super.init(swift: swift)
    }
}

/// The supplied property group is invalid. The file has uploaded without property groups.
@objc
public class DBXFilesUploadSessionFinishErrorPropertiesError: DBXFilesUploadSessionFinishError {
    @objc
    public var propertiesError: DBXFilePropertiesInvalidPropertyGroupError

    @objc
    public init(_ arg: DBXFilePropertiesInvalidPropertyGroupError) {
        self.propertiesError = arg
        let swift = Files.UploadSessionFinishError.propertiesError(arg.swift)
        super.init(swift: swift)
    }
}

/// The batch request commits files into too many different shared folders. Please limit your batch request to
/// files contained in a single shared folder.
@objc
public class DBXFilesUploadSessionFinishErrorTooManySharedFolderTargets: DBXFilesUploadSessionFinishError {
    @objc
    public init() {
        let swift = Files.UploadSessionFinishError.tooManySharedFolderTargets
        super.init(swift: swift)
    }
}

/// There are too many write operations happening in the user's Dropbox. You should retry uploading this file.
@objc
public class DBXFilesUploadSessionFinishErrorTooManyWriteOperations: DBXFilesUploadSessionFinishError {
    @objc
    public init() {
        let swift = Files.UploadSessionFinishError.tooManyWriteOperations
        super.init(swift: swift)
    }
}

/// Uploading data not allowed when finishing concurrent upload session.
@objc
public class DBXFilesUploadSessionFinishErrorConcurrentSessionDataNotAllowed: DBXFilesUploadSessionFinishError {
    @objc
    public init() {
        let swift = Files.UploadSessionFinishError.concurrentSessionDataNotAllowed
        super.init(swift: swift)
    }
}

/// Concurrent upload sessions need to be closed before finishing.
@objc
public class DBXFilesUploadSessionFinishErrorConcurrentSessionNotClosed: DBXFilesUploadSessionFinishError {
    @objc
    public init() {
        let swift = Files.UploadSessionFinishError.concurrentSessionNotClosed
        super.init(swift: swift)
    }
}

/// Not all pieces of data were uploaded before trying to finish the session.
@objc
public class DBXFilesUploadSessionFinishErrorConcurrentSessionMissingData: DBXFilesUploadSessionFinishError {
    @objc
    public init() {
        let swift = Files.UploadSessionFinishError.concurrentSessionMissingData
        super.init(swift: swift)
    }
}

/// The request payload must be at most 150 MB.
@objc
public class DBXFilesUploadSessionFinishErrorPayloadTooLarge: DBXFilesUploadSessionFinishError {
    @objc
    public init() {
        let swift = Files.UploadSessionFinishError.payloadTooLarge
        super.init(swift: swift)
    }
}

/// The content received by the Dropbox server in this call does not match the provided content hash.
@objc
public class DBXFilesUploadSessionFinishErrorContentHashMismatch: DBXFilesUploadSessionFinishError {
    @objc
    public init() {
        let swift = Files.UploadSessionFinishError.contentHashMismatch
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXFilesUploadSessionFinishErrorOther: DBXFilesUploadSessionFinishError {
    @objc
    public init() {
        let swift = Files.UploadSessionFinishError.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible UploadSessionOffsetError struct
@objc
public class DBXFilesUploadSessionOffsetError: NSObject {
    /// The offset up to which data has been collected.
    @objc
    public var correctOffset: NSNumber { swift.correctOffset as NSNumber }

    @objc
    public init(correctOffset: NSNumber) {
        self.swift = Files.UploadSessionOffsetError(correctOffset: correctOffset.uint64Value)
    }

    let swift: Files.UploadSessionOffsetError

    public init(swift: Files.UploadSessionOffsetError) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible UploadSessionStartArg struct
@objc
public class DBXFilesUploadSessionStartArg: NSObject {
    /// If true, the current session will be closed, at which point you won't be able to call uploadSessionAppendV2
    /// anymore with the current session.
    @objc
    public var close: NSNumber { swift.close as NSNumber }
    /// Type of upload session you want to start. If not specified, default is sequential in UploadSessionType.
    @objc
    public var sessionType: DBXFilesUploadSessionType? { guard let swift = swift.sessionType else { return nil }
        return DBXFilesUploadSessionType(swift: swift)
    }

    /// A hash of the file content uploaded in this call. If provided and the uploaded content does not match this
    /// hash, an error will be returned. For more information see our Content hash
    /// https://www.dropbox.com/developers/reference/content-hash page.
    @objc
    public var contentHash: String? { swift.contentHash }

    @objc
    public init(close: NSNumber, sessionType: DBXFilesUploadSessionType?, contentHash: String?) {
        self.swift = Files.UploadSessionStartArg(close: close.boolValue, sessionType: sessionType?.swift, contentHash: contentHash)
    }

    let swift: Files.UploadSessionStartArg

    public init(swift: Files.UploadSessionStartArg) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible UploadSessionStartBatchArg struct
@objc
public class DBXFilesUploadSessionStartBatchArg: NSObject {
    /// Type of upload session you want to start. If not specified, default is sequential in UploadSessionType.
    @objc
    public var sessionType: DBXFilesUploadSessionType? { guard let swift = swift.sessionType else { return nil }
        return DBXFilesUploadSessionType(swift: swift)
    }

    /// The number of upload sessions to start.
    @objc
    public var numSessions: NSNumber { swift.numSessions as NSNumber }

    @objc
    public init(numSessions: NSNumber, sessionType: DBXFilesUploadSessionType?) {
        self.swift = Files.UploadSessionStartBatchArg(numSessions: numSessions.uint64Value, sessionType: sessionType?.swift)
    }

    let swift: Files.UploadSessionStartBatchArg

    public init(swift: Files.UploadSessionStartBatchArg) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible UploadSessionStartBatchResult struct
@objc
public class DBXFilesUploadSessionStartBatchResult: NSObject {
    /// A List of unique identifiers for the upload session. Pass each session_id to uploadSessionAppendV2 and
    /// uploadSessionFinish.
    @objc
    public var sessionIds: [String] { swift.sessionIds }

    @objc
    public init(sessionIds: [String]) {
        self.swift = Files.UploadSessionStartBatchResult(sessionIds: sessionIds)
    }

    let swift: Files.UploadSessionStartBatchResult

    public init(swift: Files.UploadSessionStartBatchResult) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible UploadSessionStartError union
@objc
public class DBXFilesUploadSessionStartError: NSObject {
    let swift: Files.UploadSessionStartError

    public init(swift: Files.UploadSessionStartError) {
        self.swift = swift
    }

    public static func factory(swift: Files.UploadSessionStartError) -> DBXFilesUploadSessionStartError {
        switch swift {
        case .concurrentSessionDataNotAllowed:
            return DBXFilesUploadSessionStartErrorConcurrentSessionDataNotAllowed()
        case .concurrentSessionCloseNotAllowed:
            return DBXFilesUploadSessionStartErrorConcurrentSessionCloseNotAllowed()
        case .payloadTooLarge:
            return DBXFilesUploadSessionStartErrorPayloadTooLarge()
        case .contentHashMismatch:
            return DBXFilesUploadSessionStartErrorContentHashMismatch()
        case .other:
            return DBXFilesUploadSessionStartErrorOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asConcurrentSessionDataNotAllowed: DBXFilesUploadSessionStartErrorConcurrentSessionDataNotAllowed? {
        self as? DBXFilesUploadSessionStartErrorConcurrentSessionDataNotAllowed
    }

    @objc
    public var asConcurrentSessionCloseNotAllowed: DBXFilesUploadSessionStartErrorConcurrentSessionCloseNotAllowed? {
        self as? DBXFilesUploadSessionStartErrorConcurrentSessionCloseNotAllowed
    }

    @objc
    public var asPayloadTooLarge: DBXFilesUploadSessionStartErrorPayloadTooLarge? {
        self as? DBXFilesUploadSessionStartErrorPayloadTooLarge
    }

    @objc
    public var asContentHashMismatch: DBXFilesUploadSessionStartErrorContentHashMismatch? {
        self as? DBXFilesUploadSessionStartErrorContentHashMismatch
    }

    @objc
    public var asOther: DBXFilesUploadSessionStartErrorOther? {
        self as? DBXFilesUploadSessionStartErrorOther
    }
}

/// Uploading data not allowed when starting concurrent upload session.
@objc
public class DBXFilesUploadSessionStartErrorConcurrentSessionDataNotAllowed: DBXFilesUploadSessionStartError {
    @objc
    public init() {
        let swift = Files.UploadSessionStartError.concurrentSessionDataNotAllowed
        super.init(swift: swift)
    }
}

/// Can not start a closed concurrent upload session.
@objc
public class DBXFilesUploadSessionStartErrorConcurrentSessionCloseNotAllowed: DBXFilesUploadSessionStartError {
    @objc
    public init() {
        let swift = Files.UploadSessionStartError.concurrentSessionCloseNotAllowed
        super.init(swift: swift)
    }
}

/// The request payload must be at most 150 MB.
@objc
public class DBXFilesUploadSessionStartErrorPayloadTooLarge: DBXFilesUploadSessionStartError {
    @objc
    public init() {
        let swift = Files.UploadSessionStartError.payloadTooLarge
        super.init(swift: swift)
    }
}

/// The content received by the Dropbox server in this call does not match the provided content hash.
@objc
public class DBXFilesUploadSessionStartErrorContentHashMismatch: DBXFilesUploadSessionStartError {
    @objc
    public init() {
        let swift = Files.UploadSessionStartError.contentHashMismatch
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXFilesUploadSessionStartErrorOther: DBXFilesUploadSessionStartError {
    @objc
    public init() {
        let swift = Files.UploadSessionStartError.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible UploadSessionStartResult struct
@objc
public class DBXFilesUploadSessionStartResult: NSObject {
    /// A unique identifier for the upload session. Pass this to uploadSessionAppendV2 and uploadSessionFinish.
    @objc
    public var sessionId: String { swift.sessionId }

    @objc
    public init(sessionId: String) {
        self.swift = Files.UploadSessionStartResult(sessionId: sessionId)
    }

    let swift: Files.UploadSessionStartResult

    public init(swift: Files.UploadSessionStartResult) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible UploadSessionType union
@objc
public class DBXFilesUploadSessionType: NSObject {
    let swift: Files.UploadSessionType

    public init(swift: Files.UploadSessionType) {
        self.swift = swift
    }

    public static func factory(swift: Files.UploadSessionType) -> DBXFilesUploadSessionType {
        switch swift {
        case .sequential:
            return DBXFilesUploadSessionTypeSequential()
        case .concurrent:
            return DBXFilesUploadSessionTypeConcurrent()
        case .other:
            return DBXFilesUploadSessionTypeOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asSequential: DBXFilesUploadSessionTypeSequential? {
        self as? DBXFilesUploadSessionTypeSequential
    }

    @objc
    public var asConcurrent: DBXFilesUploadSessionTypeConcurrent? {
        self as? DBXFilesUploadSessionTypeConcurrent
    }

    @objc
    public var asOther: DBXFilesUploadSessionTypeOther? {
        self as? DBXFilesUploadSessionTypeOther
    }
}

/// Pieces of data are uploaded sequentially one after another. This is the default behavior.
@objc
public class DBXFilesUploadSessionTypeSequential: DBXFilesUploadSessionType {
    @objc
    public init() {
        let swift = Files.UploadSessionType.sequential
        super.init(swift: swift)
    }
}

/// Pieces of data can be uploaded in concurrent RPCs in any order.
@objc
public class DBXFilesUploadSessionTypeConcurrent: DBXFilesUploadSessionType {
    @objc
    public init() {
        let swift = Files.UploadSessionType.concurrent
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXFilesUploadSessionTypeOther: DBXFilesUploadSessionType {
    @objc
    public init() {
        let swift = Files.UploadSessionType.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible UploadWriteFailed struct
@objc
public class DBXFilesUploadWriteFailed: NSObject {
    /// The reason why the file couldn't be saved.
    @objc
    public var reason: DBXFilesWriteError { DBXFilesWriteError(swift: swift.reason) }
    /// The upload session ID; data has already been uploaded to the corresponding upload session and this ID may be
    /// used to retry the commit with uploadSessionFinish.
    @objc
    public var uploadSessionId: String { swift.uploadSessionId }

    @objc
    public init(reason: DBXFilesWriteError, uploadSessionId: String) {
        self.swift = Files.UploadWriteFailed(reason: reason.swift, uploadSessionId: uploadSessionId)
    }

    let swift: Files.UploadWriteFailed

    public init(swift: Files.UploadWriteFailed) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible UserGeneratedTag struct
@objc
public class DBXFilesUserGeneratedTag: NSObject {
    /// (no description)
    @objc
    public var tagText: String { swift.tagText }

    @objc
    public init(tagText: String) {
        self.swift = Files.UserGeneratedTag(tagText: tagText)
    }

    let swift: Files.UserGeneratedTag

    public init(swift: Files.UserGeneratedTag) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Metadata for a video.
@objc
public class DBXFilesVideoMetadata: DBXFilesMediaMetadata {
    /// The duration of the video in milliseconds.
    @objc
    public var duration: NSNumber? { subSwift.duration as NSNumber? }

    @objc
    public init(dimensions: DBXFilesDimensions?, location: DBXFilesGpsCoordinates?, timeTaken: Date?, duration: NSNumber?) {
        let swift = Files.VideoMetadata(dimensions: dimensions?.swift, location: location?.swift, timeTaken: timeTaken, duration: duration?.uint64Value)
        self.subSwift = swift
        super.init(swift: swift)
    }

    let subSwift: Files.VideoMetadata

    public init(swift: Files.VideoMetadata) {
        self.subSwift = swift
        super.init(swift: swift)
    }

    @objc
    public override var description: String { subSwift.description }
}

/// Objective-C compatible WriteConflictError union
@objc
public class DBXFilesWriteConflictError: NSObject {
    let swift: Files.WriteConflictError

    public init(swift: Files.WriteConflictError) {
        self.swift = swift
    }

    public static func factory(swift: Files.WriteConflictError) -> DBXFilesWriteConflictError {
        switch swift {
        case .file:
            return DBXFilesWriteConflictErrorFile()
        case .folder:
            return DBXFilesWriteConflictErrorFolder()
        case .fileAncestor:
            return DBXFilesWriteConflictErrorFileAncestor()
        case .other:
            return DBXFilesWriteConflictErrorOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asFile: DBXFilesWriteConflictErrorFile? {
        self as? DBXFilesWriteConflictErrorFile
    }

    @objc
    public var asFolder: DBXFilesWriteConflictErrorFolder? {
        self as? DBXFilesWriteConflictErrorFolder
    }

    @objc
    public var asFileAncestor: DBXFilesWriteConflictErrorFileAncestor? {
        self as? DBXFilesWriteConflictErrorFileAncestor
    }

    @objc
    public var asOther: DBXFilesWriteConflictErrorOther? {
        self as? DBXFilesWriteConflictErrorOther
    }
}

/// There's a file in the way.
@objc
public class DBXFilesWriteConflictErrorFile: DBXFilesWriteConflictError {
    @objc
    public init() {
        let swift = Files.WriteConflictError.file
        super.init(swift: swift)
    }
}

/// There's a folder in the way.
@objc
public class DBXFilesWriteConflictErrorFolder: DBXFilesWriteConflictError {
    @objc
    public init() {
        let swift = Files.WriteConflictError.folder
        super.init(swift: swift)
    }
}

/// There's a file at an ancestor path, so we couldn't create the required parent folders.
@objc
public class DBXFilesWriteConflictErrorFileAncestor: DBXFilesWriteConflictError {
    @objc
    public init() {
        let swift = Files.WriteConflictError.fileAncestor
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXFilesWriteConflictErrorOther: DBXFilesWriteConflictError {
    @objc
    public init() {
        let swift = Files.WriteConflictError.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible WriteError union
@objc
public class DBXFilesWriteError: NSObject {
    let swift: Files.WriteError

    public init(swift: Files.WriteError) {
        self.swift = swift
    }

    public static func factory(swift: Files.WriteError) -> DBXFilesWriteError {
        switch swift {
        case .malformedPath(let swiftArg):
            let arg = swiftArg
            return DBXFilesWriteErrorMalformedPath(arg)
        case .conflict(let swiftArg):
            let arg = DBXFilesWriteConflictError(swift: swiftArg)
            return DBXFilesWriteErrorConflict(arg)
        case .noWritePermission:
            return DBXFilesWriteErrorNoWritePermission()
        case .insufficientSpace:
            return DBXFilesWriteErrorInsufficientSpace()
        case .disallowedName:
            return DBXFilesWriteErrorDisallowedName()
        case .teamFolder:
            return DBXFilesWriteErrorTeamFolder()
        case .operationSuppressed:
            return DBXFilesWriteErrorOperationSuppressed()
        case .tooManyWriteOperations:
            return DBXFilesWriteErrorTooManyWriteOperations()
        case .other:
            return DBXFilesWriteErrorOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asMalformedPath: DBXFilesWriteErrorMalformedPath? {
        self as? DBXFilesWriteErrorMalformedPath
    }

    @objc
    public var asConflict: DBXFilesWriteErrorConflict? {
        self as? DBXFilesWriteErrorConflict
    }

    @objc
    public var asNoWritePermission: DBXFilesWriteErrorNoWritePermission? {
        self as? DBXFilesWriteErrorNoWritePermission
    }

    @objc
    public var asInsufficientSpace: DBXFilesWriteErrorInsufficientSpace? {
        self as? DBXFilesWriteErrorInsufficientSpace
    }

    @objc
    public var asDisallowedName: DBXFilesWriteErrorDisallowedName? {
        self as? DBXFilesWriteErrorDisallowedName
    }

    @objc
    public var asTeamFolder: DBXFilesWriteErrorTeamFolder? {
        self as? DBXFilesWriteErrorTeamFolder
    }

    @objc
    public var asOperationSuppressed: DBXFilesWriteErrorOperationSuppressed? {
        self as? DBXFilesWriteErrorOperationSuppressed
    }

    @objc
    public var asTooManyWriteOperations: DBXFilesWriteErrorTooManyWriteOperations? {
        self as? DBXFilesWriteErrorTooManyWriteOperations
    }

    @objc
    public var asOther: DBXFilesWriteErrorOther? {
        self as? DBXFilesWriteErrorOther
    }
}

/// The given path does not satisfy the required path format. Please refer to the Path formats documentation
/// https://www.dropbox.com/developers/documentation/http/documentation#path-formats for more
/// information.
@objc
public class DBXFilesWriteErrorMalformedPath: DBXFilesWriteError {
    @objc
    public var malformedPath: String?

    @objc
    public init(_ arg: String?) {
        self.malformedPath = arg
        let swift = Files.WriteError.malformedPath(arg)
        super.init(swift: swift)
    }
}

/// Couldn't write to the target path because there was something in the way.
@objc
public class DBXFilesWriteErrorConflict: DBXFilesWriteError {
    @objc
    public var conflict: DBXFilesWriteConflictError

    @objc
    public init(_ arg: DBXFilesWriteConflictError) {
        self.conflict = arg
        let swift = Files.WriteError.conflict(arg.swift)
        super.init(swift: swift)
    }
}

/// The user doesn't have permissions to write to the target location.
@objc
public class DBXFilesWriteErrorNoWritePermission: DBXFilesWriteError {
    @objc
    public init() {
        let swift = Files.WriteError.noWritePermission
        super.init(swift: swift)
    }
}

/// The user doesn't have enough available space (bytes) to write more data.
@objc
public class DBXFilesWriteErrorInsufficientSpace: DBXFilesWriteError {
    @objc
    public init() {
        let swift = Files.WriteError.insufficientSpace
        super.init(swift: swift)
    }
}

/// Dropbox will not save the file or folder because of its name.
@objc
public class DBXFilesWriteErrorDisallowedName: DBXFilesWriteError {
    @objc
    public init() {
        let swift = Files.WriteError.disallowedName
        super.init(swift: swift)
    }
}

/// This endpoint cannot move or delete team folders.
@objc
public class DBXFilesWriteErrorTeamFolder: DBXFilesWriteError {
    @objc
    public init() {
        let swift = Files.WriteError.teamFolder
        super.init(swift: swift)
    }
}

/// This file operation is not allowed at this path.
@objc
public class DBXFilesWriteErrorOperationSuppressed: DBXFilesWriteError {
    @objc
    public init() {
        let swift = Files.WriteError.operationSuppressed
        super.init(swift: swift)
    }
}

/// There are too many write operations in user's Dropbox. Please retry this request.
@objc
public class DBXFilesWriteErrorTooManyWriteOperations: DBXFilesWriteError {
    @objc
    public init() {
        let swift = Files.WriteError.tooManyWriteOperations
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXFilesWriteErrorOther: DBXFilesWriteError {
    @objc
    public init() {
        let swift = Files.WriteError.other
        super.init(swift: swift)
    }
}

/// Your intent when writing a file to some path. This is used to determine what constitutes a conflict and what the
/// autorename strategy is. In some situations, the conflict behavior is identical: (a) If the target path doesn't
/// refer to anything, the file is always written; no conflict. (b) If the target path refers to a folder, it's
/// always a conflict. (c) If the target path refers to a file with identical contents, nothing gets written; no
/// conflict. The conflict checking differs in the case where there's a file at the target path with contents
/// different from the contents you're trying to write.
@objc
public class DBXFilesWriteMode: NSObject {
    let swift: Files.WriteMode

    public init(swift: Files.WriteMode) {
        self.swift = swift
    }

    public static func factory(swift: Files.WriteMode) -> DBXFilesWriteMode {
        switch swift {
        case .add:
            return DBXFilesWriteModeAdd()
        case .overwrite:
            return DBXFilesWriteModeOverwrite()
        case .update(let swiftArg):
            let arg = swiftArg
            return DBXFilesWriteModeUpdate(arg)
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asAdd: DBXFilesWriteModeAdd? {
        self as? DBXFilesWriteModeAdd
    }

    @objc
    public var asOverwrite: DBXFilesWriteModeOverwrite? {
        self as? DBXFilesWriteModeOverwrite
    }

    @objc
    public var asUpdate: DBXFilesWriteModeUpdate? {
        self as? DBXFilesWriteModeUpdate
    }
}

/// Do not overwrite an existing file if there is a conflict. The autorename strategy is to append a number to
/// the file name. For example, "document.txt" might become "document (2).txt".
@objc
public class DBXFilesWriteModeAdd: DBXFilesWriteMode {
    @objc
    public init() {
        let swift = Files.WriteMode.add
        super.init(swift: swift)
    }
}

/// Always overwrite the existing file. The autorename strategy is the same as it is for add.
@objc
public class DBXFilesWriteModeOverwrite: DBXFilesWriteMode {
    @objc
    public init() {
        let swift = Files.WriteMode.overwrite
        super.init(swift: swift)
    }
}

/// Overwrite if the given "rev" matches the existing file's "rev". The supplied value should be the latest
/// known "rev" of the file, for example, from FileMetadata, from when the file was last downloaded by
/// the app. This will cause the file on the Dropbox servers to be overwritten if the given "rev"
/// matches the existing file's current "rev" on the Dropbox servers. The autorename strategy is to
/// append the string "conflicted copy" to the file name. For example, "document.txt" might become
/// "document (conflicted copy).txt" or "document (Panda's conflicted copy).txt".
@objc
public class DBXFilesWriteModeUpdate: DBXFilesWriteMode {
    @objc
    public var update: String

    @objc
    public init(_ arg: String) {
        self.update = arg
        let swift = Files.WriteMode.update(arg)
        super.init(swift: swift)
    }
}
