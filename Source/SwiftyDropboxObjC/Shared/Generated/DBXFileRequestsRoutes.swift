///
/// Copyright (c) 2022 Dropbox, Inc. All rights reserved.
///
/// Auto-generated by Stone, do not modify.
///

import Foundation
import SwiftyDropbox

/// Objective-C compatible routes for the file_requests namespace
/// For Swift routes see FileRequestsRoutes
@objc
public class DBXFileRequestsRoutes: NSObject {
    private let swift: FileRequestsRoutes
    init(swift: FileRequestsRoutes) {
        self.swift = swift
        self.client = swift.client.objc
    }

    public let client: DBXDropboxTransportClient

    /// Returns the total number of file requests owned by this user. Includes both open and closed file requests.
    ///
    /// - scope: file_requests.read
    ///
    ///
    /// - returns: Through the response callback, the caller will receive a `FileRequests.CountFileRequestsResult`
    /// object on success or a `FileRequests.CountFileRequestsError` object on failure.
    @objc
    @discardableResult public func count() -> DBXFileRequestsCountRpcRequest {
        let swift = swift.count()
        return DBXFileRequestsCountRpcRequest(swift: swift)
    }

    /// Creates a file request for this user.
    ///
    /// - scope: file_requests.write
    ///
    /// - parameter title: The title of the file request. Must not be empty.
    /// - parameter destination: The path of the folder in the Dropbox where uploaded files will be sent. For apps with
    /// the app folder permission, this will be relative to the app folder.
    /// - parameter deadline: The deadline for the file request. Deadlines can only be set by Professional and Business
    /// accounts.
    /// - parameter open: Whether or not the file request should be open. If the file request is closed, it will not
    /// accept any file submissions, but it can be opened later.
    /// - parameter description_: A description of the file request.
    ///
    /// - returns: Through the response callback, the caller will receive a `FileRequests.FileRequest` object on success
    /// or a `FileRequests.CreateFileRequestError` object on failure.
    @objc
    @discardableResult public func create(
        title: String,
        destination: String,
        deadline: DBXFileRequestsFileRequestDeadline?,
        open: NSNumber,
        description_: String?
    ) -> DBXFileRequestsCreateRpcRequest {
        let swift = swift.create(title: title, destination: destination, deadline: deadline?.swift, open: open.boolValue, description_: description_)
        return DBXFileRequestsCreateRpcRequest(swift: swift)
    }

    /// Creates a file request for this user.
    ///
    /// - scope: file_requests.write
    ///
    /// - returns: Through the response callback, the caller will receive a `FileRequests.FileRequest` object on success
    /// or a `FileRequests.CreateFileRequestError` object on failure.
    @objc
    @discardableResult public func create(title: String, destination: String) -> DBXFileRequestsCreateRpcRequest {
        let swift = swift.create(title: title, destination: destination)
        return DBXFileRequestsCreateRpcRequest(swift: swift)
    }

    /// Delete a batch of closed file requests.
    ///
    /// - scope: file_requests.write
    ///
    /// - parameter ids: List IDs of the file requests to delete.
    ///
    /// - returns: Through the response callback, the caller will receive a `FileRequests.DeleteFileRequestsResult`
    /// object on success or a `FileRequests.DeleteFileRequestError` object on failure.
    @objc
    @discardableResult public func delete(ids: [String]) -> DBXFileRequestsDeleteRpcRequest {
        let swift = swift.delete(ids: ids)
        return DBXFileRequestsDeleteRpcRequest(swift: swift)
    }

    /// Delete all closed file requests owned by this user.
    ///
    /// - scope: file_requests.write
    ///
    ///
    /// - returns: Through the response callback, the caller will receive a
    /// `FileRequests.DeleteAllClosedFileRequestsResult` object on success or a
    /// `FileRequests.DeleteAllClosedFileRequestsError` object on failure.
    @objc
    @discardableResult public func deleteAllClosed() -> DBXFileRequestsDeleteAllClosedRpcRequest {
        let swift = swift.deleteAllClosed()
        return DBXFileRequestsDeleteAllClosedRpcRequest(swift: swift)
    }

    /// Returns the specified file request.
    ///
    /// - scope: file_requests.read
    ///
    /// - parameter id: The ID of the file request to retrieve.
    ///
    /// - returns: Through the response callback, the caller will receive a `FileRequests.FileRequest` object on success
    /// or a `FileRequests.GetFileRequestError` object on failure.
    @objc
    @discardableResult public func get(id: String) -> DBXFileRequestsGetRpcRequest {
        let swift = swift.get(id: id)
        return DBXFileRequestsGetRpcRequest(swift: swift)
    }

    /// Returns a list of file requests owned by this user. For apps with the app folder permission, this will only
    /// return file requests with destinations in the app folder.
    ///
    /// - scope: file_requests.read
    ///
    ///
    /// - returns: Through the response callback, the caller will receive a `FileRequests.ListFileRequestsResult` object
    /// on success or a `FileRequests.ListFileRequestsError` object on failure.
    @objc
    @discardableResult public func list_() -> DBXFileRequestsList_RpcRequest {
        let swift = swift.list_()
        return DBXFileRequestsList_RpcRequest(swift: swift)
    }

    /// Returns a list of file requests owned by this user. For apps with the app folder permission, this will only
    /// return file requests with destinations in the app folder.
    ///
    /// - scope: file_requests.read
    ///
    /// - parameter limit: The maximum number of file requests that should be returned per request.
    ///
    /// - returns: Through the response callback, the caller will receive a `FileRequests.ListFileRequestsV2Result`
    /// object on success or a `FileRequests.ListFileRequestsError` object on failure.
    @objc
    @discardableResult public func listV2(limit: NSNumber) -> DBXFileRequestsList_RpcRequestV2 {
        let swift = swift.listV2(limit: limit.uint64Value)
        return DBXFileRequestsList_RpcRequestV2(swift: swift)
    }

    /// Returns a list of file requests owned by this user. For apps with the app folder permission, this will only
    /// return file requests with destinations in the app folder.
    ///
    /// - scope: file_requests.read
    ///
    /// - returns: Through the response callback, the caller will receive a `FileRequests.ListFileRequestsV2Result`
    /// object on success or a `FileRequests.ListFileRequestsError` object on failure.
    @objc
    @discardableResult public func listV2() -> DBXFileRequestsList_RpcRequestV2 {
        let swift = swift.listV2()
        return DBXFileRequestsList_RpcRequestV2(swift: swift)
    }

    /// Once a cursor has been retrieved from listV2, use this to paginate through all file requests. The cursor must
    /// come from a previous call to listV2 or listContinue.
    ///
    /// - scope: file_requests.read
    ///
    /// - parameter cursor: The cursor returned by the previous API call specified in the endpoint description.
    ///
    /// - returns: Through the response callback, the caller will receive a `FileRequests.ListFileRequestsV2Result`
    /// object on success or a `FileRequests.ListFileRequestsContinueError` object on failure.
    @objc
    @discardableResult public func listContinue(cursor: String) -> DBXFileRequestsListContinueRpcRequest {
        let swift = swift.listContinue(cursor: cursor)
        return DBXFileRequestsListContinueRpcRequest(swift: swift)
    }

    /// Update a file request.
    ///
    /// - scope: file_requests.write
    ///
    /// - parameter id: The ID of the file request to update.
    /// - parameter title: The new title of the file request. Must not be empty.
    /// - parameter destination: The new path of the folder in the Dropbox where uploaded files will be sent. For apps
    /// with the app folder permission, this will be relative to the app folder.
    /// - parameter deadline: The new deadline for the file request. Deadlines can only be set by Professional and
    /// Business accounts.
    /// - parameter open: Whether to set this file request as open or closed.
    /// - parameter description_: The description of the file request.
    ///
    /// - returns: Through the response callback, the caller will receive a `FileRequests.FileRequest` object on success
    /// or a `FileRequests.UpdateFileRequestError` object on failure.
    @objc
    @discardableResult public func update(
        id: String,
        title: String?,
        destination: String?,
        deadline: DBXFileRequestsUpdateFileRequestDeadline,
        open: NSNumber?,
        description_: String?
    ) -> DBXFileRequestsUpdateRpcRequest {
        let swift = swift.update(id: id, title: title, destination: destination, deadline: deadline.swift, open: open?.boolValue, description_: description_)
        return DBXFileRequestsUpdateRpcRequest(swift: swift)
    }

    /// Update a file request.
    ///
    /// - scope: file_requests.write
    ///
    /// - returns: Through the response callback, the caller will receive a `FileRequests.FileRequest` object on success
    /// or a `FileRequests.UpdateFileRequestError` object on failure.
    @objc
    @discardableResult public func update(id: String) -> DBXFileRequestsUpdateRpcRequest {
        let swift = swift.update(id: id)
        return DBXFileRequestsUpdateRpcRequest(swift: swift)
    }
}

@objc
public class DBXFileRequestsCountRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<FileRequests.CountFileRequestsResultSerializer, FileRequests.CountFileRequestsErrorSerializer>

    init(swift: RpcRequest<FileRequests.CountFileRequestsResultSerializer, FileRequests.CountFileRequestsErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXFileRequestsCountFileRequestsResult?, DBXFileRequestsCountFileRequestsError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXFileRequestsCountFileRequestsResult?, DBXFileRequestsCountFileRequestsError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXFileRequestsCountFileRequestsError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXFileRequestsCountFileRequestsError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXFileRequestsCountFileRequestsResult?
            if let swift = result {
                objc = DBXFileRequestsCountFileRequestsResult(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXFileRequestsCreateRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<FileRequests.FileRequestSerializer, FileRequests.CreateFileRequestErrorSerializer>

    init(swift: RpcRequest<FileRequests.FileRequestSerializer, FileRequests.CreateFileRequestErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXFileRequestsFileRequest?, DBXFileRequestsCreateFileRequestError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXFileRequestsFileRequest?, DBXFileRequestsCreateFileRequestError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXFileRequestsCreateFileRequestError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXFileRequestsCreateFileRequestError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXFileRequestsFileRequest?
            if let swift = result {
                objc = DBXFileRequestsFileRequest(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXFileRequestsDeleteRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<FileRequests.DeleteFileRequestsResultSerializer, FileRequests.DeleteFileRequestErrorSerializer>

    init(swift: RpcRequest<FileRequests.DeleteFileRequestsResultSerializer, FileRequests.DeleteFileRequestErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXFileRequestsDeleteFileRequestsResult?, DBXFileRequestsDeleteFileRequestError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXFileRequestsDeleteFileRequestsResult?, DBXFileRequestsDeleteFileRequestError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXFileRequestsDeleteFileRequestError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXFileRequestsDeleteFileRequestError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXFileRequestsDeleteFileRequestsResult?
            if let swift = result {
                objc = DBXFileRequestsDeleteFileRequestsResult(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXFileRequestsDeleteAllClosedRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<FileRequests.DeleteAllClosedFileRequestsResultSerializer, FileRequests.DeleteAllClosedFileRequestsErrorSerializer>

    init(swift: RpcRequest<FileRequests.DeleteAllClosedFileRequestsResultSerializer, FileRequests.DeleteAllClosedFileRequestsErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXFileRequestsDeleteAllClosedFileRequestsResult?, DBXFileRequestsDeleteAllClosedFileRequestsError?, DBXCallError?)
            -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXFileRequestsDeleteAllClosedFileRequestsResult?, DBXFileRequestsDeleteAllClosedFileRequestsError?, DBXCallError?)
            -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXFileRequestsDeleteAllClosedFileRequestsError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXFileRequestsDeleteAllClosedFileRequestsError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXFileRequestsDeleteAllClosedFileRequestsResult?
            if let swift = result {
                objc = DBXFileRequestsDeleteAllClosedFileRequestsResult(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXFileRequestsGetRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<FileRequests.FileRequestSerializer, FileRequests.GetFileRequestErrorSerializer>

    init(swift: RpcRequest<FileRequests.FileRequestSerializer, FileRequests.GetFileRequestErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXFileRequestsFileRequest?, DBXFileRequestsGetFileRequestError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXFileRequestsFileRequest?, DBXFileRequestsGetFileRequestError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXFileRequestsGetFileRequestError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXFileRequestsGetFileRequestError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXFileRequestsFileRequest?
            if let swift = result {
                objc = DBXFileRequestsFileRequest(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXFileRequestsList_RpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<FileRequests.ListFileRequestsResultSerializer, FileRequests.ListFileRequestsErrorSerializer>

    init(swift: RpcRequest<FileRequests.ListFileRequestsResultSerializer, FileRequests.ListFileRequestsErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXFileRequestsListFileRequestsResult?, DBXFileRequestsListFileRequestsError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXFileRequestsListFileRequestsResult?, DBXFileRequestsListFileRequestsError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXFileRequestsListFileRequestsError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXFileRequestsListFileRequestsError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXFileRequestsListFileRequestsResult?
            if let swift = result {
                objc = DBXFileRequestsListFileRequestsResult(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXFileRequestsList_RpcRequestV2: NSObject, DBXRequest {
    var swift: RpcRequest<FileRequests.ListFileRequestsV2ResultSerializer, FileRequests.ListFileRequestsErrorSerializer>

    init(swift: RpcRequest<FileRequests.ListFileRequestsV2ResultSerializer, FileRequests.ListFileRequestsErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXFileRequestsListFileRequestsV2Result?, DBXFileRequestsListFileRequestsError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXFileRequestsListFileRequestsV2Result?, DBXFileRequestsListFileRequestsError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXFileRequestsListFileRequestsError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXFileRequestsListFileRequestsError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXFileRequestsListFileRequestsV2Result?
            if let swift = result {
                objc = DBXFileRequestsListFileRequestsV2Result(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXFileRequestsListContinueRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<FileRequests.ListFileRequestsV2ResultSerializer, FileRequests.ListFileRequestsContinueErrorSerializer>

    init(swift: RpcRequest<FileRequests.ListFileRequestsV2ResultSerializer, FileRequests.ListFileRequestsContinueErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXFileRequestsListFileRequestsV2Result?, DBXFileRequestsListFileRequestsContinueError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXFileRequestsListFileRequestsV2Result?, DBXFileRequestsListFileRequestsContinueError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXFileRequestsListFileRequestsContinueError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXFileRequestsListFileRequestsContinueError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXFileRequestsListFileRequestsV2Result?
            if let swift = result {
                objc = DBXFileRequestsListFileRequestsV2Result(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXFileRequestsUpdateRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<FileRequests.FileRequestSerializer, FileRequests.UpdateFileRequestErrorSerializer>

    init(swift: RpcRequest<FileRequests.FileRequestSerializer, FileRequests.UpdateFileRequestErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXFileRequestsFileRequest?, DBXFileRequestsUpdateFileRequestError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXFileRequestsFileRequest?, DBXFileRequestsUpdateFileRequestError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXFileRequestsUpdateFileRequestError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXFileRequestsUpdateFileRequestError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXFileRequestsFileRequest?
            if let swift = result {
                objc = DBXFileRequestsFileRequest(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}
