///
/// Copyright (c) 2022 Dropbox, Inc. All rights reserved.
///
/// Auto-generated by Stone, do not modify.
///

import Foundation
import SwiftyDropbox

/// Objective-C compatible routes for the file_properties namespace
/// For Swift routes see FilePropertiesRoutes
@objc
public class DBXFilePropertiesRoutes: NSObject {
    private let swift: FilePropertiesRoutes
    init(swift: FilePropertiesRoutes) {
        self.swift = swift
        self.client = swift.client.objc
    }

    public let client: DBXDropboxTransportClient

    /// Add property groups to a Dropbox file. See templatesAddForUser or templatesAddForTeam to create new templates.
    ///
    /// - scope: files.metadata.write
    ///
    /// - parameter path: A unique identifier for the file or folder.
    /// - parameter propertyGroups: The property groups which are to be added to a Dropbox file. No two groups in the
    /// input should  refer to the same template.
    ///
    /// - returns: Through the response callback, the caller will receive a `Void` object on success or a
    /// `FileProperties.AddPropertiesError` object on failure.
    @objc
    @discardableResult public func propertiesAdd(path: String, propertyGroups: [DBXFilePropertiesPropertyGroup]) -> DBXFilePropertiesPropertiesAddRpcRequest {
        let swift = swift.propertiesAdd(path: path, propertyGroups: propertyGroups.map(\.swift))
        return DBXFilePropertiesPropertiesAddRpcRequest(swift: swift)
    }

    /// Overwrite property groups associated with a file. This endpoint should be used instead of propertiesUpdate when
    /// property groups are being updated via a "snapshot" instead of via a "delta". In other words, this endpoint
    /// will delete all omitted fields from a property group, whereas propertiesUpdate will only delete fields that
    /// are explicitly marked for deletion.
    ///
    /// - scope: files.metadata.write
    ///
    /// - parameter path: A unique identifier for the file or folder.
    /// - parameter propertyGroups: The property groups "snapshot" updates to force apply. No two groups in the input
    /// should  refer to the same template.
    ///
    /// - returns: Through the response callback, the caller will receive a `Void` object on success or a
    /// `FileProperties.InvalidPropertyGroupError` object on failure.
    @objc
    @discardableResult public func propertiesOverwrite(
        path: String,
        propertyGroups: [DBXFilePropertiesPropertyGroup]
    ) -> DBXFilePropertiesPropertiesOverwriteRpcRequest {
        let swift = swift.propertiesOverwrite(path: path, propertyGroups: propertyGroups.map(\.swift))
        return DBXFilePropertiesPropertiesOverwriteRpcRequest(swift: swift)
    }

    /// Permanently removes the specified property group from the file. To remove specific property field key value
    /// pairs, see propertiesUpdate. To update a template, see templatesUpdateForUser or templatesUpdateForTeam. To
    /// remove a template, see templatesRemoveForUser or templatesRemoveForTeam.
    ///
    /// - scope: files.metadata.write
    ///
    /// - parameter path: A unique identifier for the file or folder.
    /// - parameter propertyTemplateIds: A list of identifiers for a template created by templatesAddForUser or
    /// templatesAddForTeam.
    ///
    /// - returns: Through the response callback, the caller will receive a `Void` object on success or a
    /// `FileProperties.RemovePropertiesError` object on failure.
    @objc
    @discardableResult public func propertiesRemove(path: String, propertyTemplateIds: [String]) -> DBXFilePropertiesPropertiesRemoveRpcRequest {
        let swift = swift.propertiesRemove(path: path, propertyTemplateIds: propertyTemplateIds)
        return DBXFilePropertiesPropertiesRemoveRpcRequest(swift: swift)
    }

    /// Search across property templates for particular property field values.
    ///
    /// - scope: files.metadata.read
    ///
    /// - parameter queries: Queries to search.
    /// - parameter templateFilter: Filter results to contain only properties associated with these template IDs.
    ///
    /// - returns: Through the response callback, the caller will receive a `FileProperties.PropertiesSearchResult`
    /// object on success or a `FileProperties.PropertiesSearchError` object on failure.
    @objc
    @discardableResult public func propertiesSearch(
        queries: [DBXFilePropertiesPropertiesSearchQuery],
        templateFilter: DBXFilePropertiesTemplateFilter
    ) -> DBXFilePropertiesPropertiesSearchRpcRequest {
        let swift = swift.propertiesSearch(queries: queries.map(\.swift), templateFilter: templateFilter.swift)
        return DBXFilePropertiesPropertiesSearchRpcRequest(swift: swift)
    }

    /// Search across property templates for particular property field values.
    ///
    /// - scope: files.metadata.read
    ///
    /// - returns: Through the response callback, the caller will receive a `FileProperties.PropertiesSearchResult`
    /// object on success or a `FileProperties.PropertiesSearchError` object on failure.
    @objc
    @discardableResult public func propertiesSearch(queries: [DBXFilePropertiesPropertiesSearchQuery]) -> DBXFilePropertiesPropertiesSearchRpcRequest {
        let swift = swift.propertiesSearch(queries: queries.map(\.swift))
        return DBXFilePropertiesPropertiesSearchRpcRequest(swift: swift)
    }

    /// Once a cursor has been retrieved from propertiesSearch, use this to paginate through all search results.
    ///
    /// - scope: files.metadata.read
    ///
    /// - parameter cursor: The cursor returned by your last call to propertiesSearch or propertiesSearchContinue.
    ///
    /// - returns: Through the response callback, the caller will receive a `FileProperties.PropertiesSearchResult`
    /// object on success or a `FileProperties.PropertiesSearchContinueError` object on failure.
    @objc
    @discardableResult public func propertiesSearchContinue(cursor: String) -> DBXFilePropertiesPropertiesSearchContinueRpcRequest {
        let swift = swift.propertiesSearchContinue(cursor: cursor)
        return DBXFilePropertiesPropertiesSearchContinueRpcRequest(swift: swift)
    }

    /// Add, update or remove properties associated with the supplied file and templates. This endpoint should be used
    /// instead of propertiesOverwrite when property groups are being updated via a "delta" instead of via a
    /// "snapshot" . In other words, this endpoint will not delete any omitted fields from a property group, whereas
    /// propertiesOverwrite will delete any fields that are omitted from a property group.
    ///
    /// - scope: files.metadata.write
    ///
    /// - parameter path: A unique identifier for the file or folder.
    /// - parameter updatePropertyGroups: The property groups "delta" updates to apply.
    ///
    /// - returns: Through the response callback, the caller will receive a `Void` object on success or a
    /// `FileProperties.UpdatePropertiesError` object on failure.
    @objc
    @discardableResult public func propertiesUpdate(
        path: String,
        updatePropertyGroups: [DBXFilePropertiesPropertyGroupUpdate]
    ) -> DBXFilePropertiesPropertiesUpdateRpcRequest {
        let swift = swift.propertiesUpdate(path: path, updatePropertyGroups: updatePropertyGroups.map(\.swift))
        return DBXFilePropertiesPropertiesUpdateRpcRequest(swift: swift)
    }

    /// Add a template associated with a team. See propertiesAdd to add properties to a file or folder. Note: this
    /// endpoint will create team-owned templates.
    ///
    /// - scope: files.team_metadata.write
    ///
    ///
    /// - returns: Through the response callback, the caller will receive a `FileProperties.AddTemplateResult` object on
    /// success or a `FileProperties.ModifyTemplateError` object on failure.
    @objc
    @discardableResult public func templatesAddForTeam(
        name: String,
        description_: String,
        fields: [DBXFilePropertiesPropertyFieldTemplate]
    ) -> DBXFilePropertiesTemplatesAddForTeamRpcRequest {
        let swift = swift.templatesAddForTeam(name: name, description_: description_, fields: fields.map(\.swift))
        return DBXFilePropertiesTemplatesAddForTeamRpcRequest(swift: swift)
    }

    /// Add a template associated with a user. See propertiesAdd to add properties to a file. This endpoint can't be
    /// called on a team member or admin's behalf.
    ///
    /// - scope: files.metadata.write
    ///
    ///
    /// - returns: Through the response callback, the caller will receive a `FileProperties.AddTemplateResult` object on
    /// success or a `FileProperties.ModifyTemplateError` object on failure.
    @objc
    @discardableResult public func templatesAddForUser(
        name: String,
        description_: String,
        fields: [DBXFilePropertiesPropertyFieldTemplate]
    ) -> DBXFilePropertiesTemplatesAddForUserRpcRequest {
        let swift = swift.templatesAddForUser(name: name, description_: description_, fields: fields.map(\.swift))
        return DBXFilePropertiesTemplatesAddForUserRpcRequest(swift: swift)
    }

    /// Get the schema for a specified template.
    ///
    /// - scope: files.team_metadata.write
    ///
    /// - parameter templateId: An identifier for template added by route  See templatesAddForUser or
    /// templatesAddForTeam.
    ///
    /// - returns: Through the response callback, the caller will receive a `FileProperties.GetTemplateResult` object on
    /// success or a `FileProperties.TemplateError` object on failure.
    @objc
    @discardableResult public func templatesGetForTeam(templateId: String) -> DBXFilePropertiesTemplatesGetForTeamRpcRequest {
        let swift = swift.templatesGetForTeam(templateId: templateId)
        return DBXFilePropertiesTemplatesGetForTeamRpcRequest(swift: swift)
    }

    /// Get the schema for a specified template. This endpoint can't be called on a team member or admin's behalf.
    ///
    /// - scope: files.metadata.read
    ///
    /// - parameter templateId: An identifier for template added by route  See templatesAddForUser or
    /// templatesAddForTeam.
    ///
    /// - returns: Through the response callback, the caller will receive a `FileProperties.GetTemplateResult` object on
    /// success or a `FileProperties.TemplateError` object on failure.
    @objc
    @discardableResult public func templatesGetForUser(templateId: String) -> DBXFilePropertiesTemplatesGetForUserRpcRequest {
        let swift = swift.templatesGetForUser(templateId: templateId)
        return DBXFilePropertiesTemplatesGetForUserRpcRequest(swift: swift)
    }

    /// Get the template identifiers for a team. To get the schema of each template use templatesGetForTeam.
    ///
    /// - scope: files.team_metadata.write
    ///
    ///
    /// - returns: Through the response callback, the caller will receive a `FileProperties.ListTemplateResult` object
    /// on success or a `FileProperties.TemplateError` object on failure.
    @objc
    @discardableResult public func templatesListForTeam() -> DBXFilePropertiesTemplatesListForTeamRpcRequest {
        let swift = swift.templatesListForTeam()
        return DBXFilePropertiesTemplatesListForTeamRpcRequest(swift: swift)
    }

    /// Get the template identifiers for a team. To get the schema of each template use templatesGetForUser. This
    /// endpoint can't be called on a team member or admin's behalf.
    ///
    /// - scope: files.metadata.read
    ///
    ///
    /// - returns: Through the response callback, the caller will receive a `FileProperties.ListTemplateResult` object
    /// on success or a `FileProperties.TemplateError` object on failure.
    @objc
    @discardableResult public func templatesListForUser() -> DBXFilePropertiesTemplatesListForUserRpcRequest {
        let swift = swift.templatesListForUser()
        return DBXFilePropertiesTemplatesListForUserRpcRequest(swift: swift)
    }

    /// Permanently removes the specified template created from templatesAddForUser. All properties associated with the
    /// template will also be removed. This action cannot be undone.
    ///
    /// - scope: files.team_metadata.write
    ///
    /// - parameter templateId: An identifier for a template created by templatesAddForUser or templatesAddForTeam.
    ///
    /// - returns: Through the response callback, the caller will receive a `Void` object on success or a
    /// `FileProperties.TemplateError` object on failure.
    @objc
    @discardableResult public func templatesRemoveForTeam(templateId: String) -> DBXFilePropertiesTemplatesRemoveForTeamRpcRequest {
        let swift = swift.templatesRemoveForTeam(templateId: templateId)
        return DBXFilePropertiesTemplatesRemoveForTeamRpcRequest(swift: swift)
    }

    /// Permanently removes the specified template created from templatesAddForUser. All properties associated with the
    /// template will also be removed. This action cannot be undone.
    ///
    /// - scope: files.metadata.write
    ///
    /// - parameter templateId: An identifier for a template created by templatesAddForUser or templatesAddForTeam.
    ///
    /// - returns: Through the response callback, the caller will receive a `Void` object on success or a
    /// `FileProperties.TemplateError` object on failure.
    @objc
    @discardableResult public func templatesRemoveForUser(templateId: String) -> DBXFilePropertiesTemplatesRemoveForUserRpcRequest {
        let swift = swift.templatesRemoveForUser(templateId: templateId)
        return DBXFilePropertiesTemplatesRemoveForUserRpcRequest(swift: swift)
    }

    /// Update a template associated with a team. This route can update the template name, the template description and
    /// add optional properties to templates.
    ///
    /// - scope: files.team_metadata.write
    ///
    /// - parameter templateId: An identifier for template added by  See templatesAddForUser or templatesAddForTeam.
    /// - parameter name: A display name for the template. template names can be up to 256 bytes.
    /// - parameter description_: Description for the new template. Template descriptions can be up to 1024 bytes.
    /// - parameter addFields: Property field templates to be added to the group template. There can be up to 32
    /// properties in a single template.
    ///
    /// - returns: Through the response callback, the caller will receive a `FileProperties.UpdateTemplateResult` object
    /// on success or a `FileProperties.ModifyTemplateError` object on failure.
    @objc
    @discardableResult public func templatesUpdateForTeam(
        templateId: String,
        name: String?,
        description_: String?,
        addFields: [DBXFilePropertiesPropertyFieldTemplate]?
    ) -> DBXFilePropertiesTemplatesUpdateForTeamRpcRequest {
        let swift = swift.templatesUpdateForTeam(templateId: templateId, name: name, description_: description_, addFields: addFields?.map(\.swift))
        return DBXFilePropertiesTemplatesUpdateForTeamRpcRequest(swift: swift)
    }

    /// Update a template associated with a team. This route can update the template name, the template description and
    /// add optional properties to templates.
    ///
    /// - scope: files.team_metadata.write
    ///
    /// - returns: Through the response callback, the caller will receive a `FileProperties.UpdateTemplateResult` object
    /// on success or a `FileProperties.ModifyTemplateError` object on failure.
    @objc
    @discardableResult public func templatesUpdateForTeam(templateId: String) -> DBXFilePropertiesTemplatesUpdateForTeamRpcRequest {
        let swift = swift.templatesUpdateForTeam(templateId: templateId)
        return DBXFilePropertiesTemplatesUpdateForTeamRpcRequest(swift: swift)
    }

    /// Update a template associated with a user. This route can update the template name, the template description and
    /// add optional properties to templates. This endpoint can't be called on a team member or admin's behalf.
    ///
    /// - scope: files.metadata.write
    ///
    /// - parameter templateId: An identifier for template added by  See templatesAddForUser or templatesAddForTeam.
    /// - parameter name: A display name for the template. template names can be up to 256 bytes.
    /// - parameter description_: Description for the new template. Template descriptions can be up to 1024 bytes.
    /// - parameter addFields: Property field templates to be added to the group template. There can be up to 32
    /// properties in a single template.
    ///
    /// - returns: Through the response callback, the caller will receive a `FileProperties.UpdateTemplateResult` object
    /// on success or a `FileProperties.ModifyTemplateError` object on failure.
    @objc
    @discardableResult public func templatesUpdateForUser(
        templateId: String,
        name: String?,
        description_: String?,
        addFields: [DBXFilePropertiesPropertyFieldTemplate]?
    ) -> DBXFilePropertiesTemplatesUpdateForUserRpcRequest {
        let swift = swift.templatesUpdateForUser(templateId: templateId, name: name, description_: description_, addFields: addFields?.map(\.swift))
        return DBXFilePropertiesTemplatesUpdateForUserRpcRequest(swift: swift)
    }

    /// Update a template associated with a user. This route can update the template name, the template description and
    /// add optional properties to templates. This endpoint can't be called on a team member or admin's behalf.
    ///
    /// - scope: files.metadata.write
    ///
    /// - returns: Through the response callback, the caller will receive a `FileProperties.UpdateTemplateResult` object
    /// on success or a `FileProperties.ModifyTemplateError` object on failure.
    @objc
    @discardableResult public func templatesUpdateForUser(templateId: String) -> DBXFilePropertiesTemplatesUpdateForUserRpcRequest {
        let swift = swift.templatesUpdateForUser(templateId: templateId)
        return DBXFilePropertiesTemplatesUpdateForUserRpcRequest(swift: swift)
    }
}

@objc
public class DBXFilePropertiesPropertiesAddRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<VoidSerializer, FileProperties.AddPropertiesErrorSerializer>

    init(swift: RpcRequest<VoidSerializer, FileProperties.AddPropertiesErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXFilePropertiesAddPropertiesError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXFilePropertiesAddPropertiesError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { _, error in
            var routeError: DBXFilePropertiesAddPropertiesError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXFilePropertiesAddPropertiesError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            completionHandler(routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXFilePropertiesPropertiesOverwriteRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<VoidSerializer, FileProperties.InvalidPropertyGroupErrorSerializer>

    init(swift: RpcRequest<VoidSerializer, FileProperties.InvalidPropertyGroupErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXFilePropertiesInvalidPropertyGroupError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXFilePropertiesInvalidPropertyGroupError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { _, error in
            var routeError: DBXFilePropertiesInvalidPropertyGroupError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXFilePropertiesInvalidPropertyGroupError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            completionHandler(routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXFilePropertiesPropertiesRemoveRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<VoidSerializer, FileProperties.RemovePropertiesErrorSerializer>

    init(swift: RpcRequest<VoidSerializer, FileProperties.RemovePropertiesErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXFilePropertiesRemovePropertiesError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXFilePropertiesRemovePropertiesError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { _, error in
            var routeError: DBXFilePropertiesRemovePropertiesError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXFilePropertiesRemovePropertiesError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            completionHandler(routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXFilePropertiesPropertiesSearchRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<FileProperties.PropertiesSearchResultSerializer, FileProperties.PropertiesSearchErrorSerializer>

    init(swift: RpcRequest<FileProperties.PropertiesSearchResultSerializer, FileProperties.PropertiesSearchErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXFilePropertiesPropertiesSearchResult?, DBXFilePropertiesPropertiesSearchError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXFilePropertiesPropertiesSearchResult?, DBXFilePropertiesPropertiesSearchError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXFilePropertiesPropertiesSearchError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXFilePropertiesPropertiesSearchError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXFilePropertiesPropertiesSearchResult?
            if let swift = result {
                objc = DBXFilePropertiesPropertiesSearchResult(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXFilePropertiesPropertiesSearchContinueRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<FileProperties.PropertiesSearchResultSerializer, FileProperties.PropertiesSearchContinueErrorSerializer>

    init(swift: RpcRequest<FileProperties.PropertiesSearchResultSerializer, FileProperties.PropertiesSearchContinueErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXFilePropertiesPropertiesSearchResult?, DBXFilePropertiesPropertiesSearchContinueError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXFilePropertiesPropertiesSearchResult?, DBXFilePropertiesPropertiesSearchContinueError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXFilePropertiesPropertiesSearchContinueError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXFilePropertiesPropertiesSearchContinueError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXFilePropertiesPropertiesSearchResult?
            if let swift = result {
                objc = DBXFilePropertiesPropertiesSearchResult(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXFilePropertiesPropertiesUpdateRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<VoidSerializer, FileProperties.UpdatePropertiesErrorSerializer>

    init(swift: RpcRequest<VoidSerializer, FileProperties.UpdatePropertiesErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXFilePropertiesUpdatePropertiesError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXFilePropertiesUpdatePropertiesError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { _, error in
            var routeError: DBXFilePropertiesUpdatePropertiesError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXFilePropertiesUpdatePropertiesError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            completionHandler(routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXFilePropertiesTemplatesAddForTeamRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<FileProperties.AddTemplateResultSerializer, FileProperties.ModifyTemplateErrorSerializer>

    init(swift: RpcRequest<FileProperties.AddTemplateResultSerializer, FileProperties.ModifyTemplateErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXFilePropertiesAddTemplateResult?, DBXFilePropertiesModifyTemplateError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXFilePropertiesAddTemplateResult?, DBXFilePropertiesModifyTemplateError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXFilePropertiesModifyTemplateError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXFilePropertiesModifyTemplateError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXFilePropertiesAddTemplateResult?
            if let swift = result {
                objc = DBXFilePropertiesAddTemplateResult(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXFilePropertiesTemplatesAddForUserRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<FileProperties.AddTemplateResultSerializer, FileProperties.ModifyTemplateErrorSerializer>

    init(swift: RpcRequest<FileProperties.AddTemplateResultSerializer, FileProperties.ModifyTemplateErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXFilePropertiesAddTemplateResult?, DBXFilePropertiesModifyTemplateError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXFilePropertiesAddTemplateResult?, DBXFilePropertiesModifyTemplateError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXFilePropertiesModifyTemplateError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXFilePropertiesModifyTemplateError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXFilePropertiesAddTemplateResult?
            if let swift = result {
                objc = DBXFilePropertiesAddTemplateResult(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXFilePropertiesTemplatesGetForTeamRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<FileProperties.GetTemplateResultSerializer, FileProperties.TemplateErrorSerializer>

    init(swift: RpcRequest<FileProperties.GetTemplateResultSerializer, FileProperties.TemplateErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXFilePropertiesGetTemplateResult?, DBXFilePropertiesTemplateError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXFilePropertiesGetTemplateResult?, DBXFilePropertiesTemplateError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXFilePropertiesTemplateError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXFilePropertiesTemplateError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXFilePropertiesGetTemplateResult?
            if let swift = result {
                objc = DBXFilePropertiesGetTemplateResult(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXFilePropertiesTemplatesGetForUserRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<FileProperties.GetTemplateResultSerializer, FileProperties.TemplateErrorSerializer>

    init(swift: RpcRequest<FileProperties.GetTemplateResultSerializer, FileProperties.TemplateErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXFilePropertiesGetTemplateResult?, DBXFilePropertiesTemplateError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXFilePropertiesGetTemplateResult?, DBXFilePropertiesTemplateError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXFilePropertiesTemplateError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXFilePropertiesTemplateError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXFilePropertiesGetTemplateResult?
            if let swift = result {
                objc = DBXFilePropertiesGetTemplateResult(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXFilePropertiesTemplatesListForTeamRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<FileProperties.ListTemplateResultSerializer, FileProperties.TemplateErrorSerializer>

    init(swift: RpcRequest<FileProperties.ListTemplateResultSerializer, FileProperties.TemplateErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXFilePropertiesListTemplateResult?, DBXFilePropertiesTemplateError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXFilePropertiesListTemplateResult?, DBXFilePropertiesTemplateError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXFilePropertiesTemplateError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXFilePropertiesTemplateError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXFilePropertiesListTemplateResult?
            if let swift = result {
                objc = DBXFilePropertiesListTemplateResult(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXFilePropertiesTemplatesListForUserRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<FileProperties.ListTemplateResultSerializer, FileProperties.TemplateErrorSerializer>

    init(swift: RpcRequest<FileProperties.ListTemplateResultSerializer, FileProperties.TemplateErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXFilePropertiesListTemplateResult?, DBXFilePropertiesTemplateError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXFilePropertiesListTemplateResult?, DBXFilePropertiesTemplateError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXFilePropertiesTemplateError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXFilePropertiesTemplateError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXFilePropertiesListTemplateResult?
            if let swift = result {
                objc = DBXFilePropertiesListTemplateResult(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXFilePropertiesTemplatesRemoveForTeamRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<VoidSerializer, FileProperties.TemplateErrorSerializer>

    init(swift: RpcRequest<VoidSerializer, FileProperties.TemplateErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXFilePropertiesTemplateError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXFilePropertiesTemplateError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { _, error in
            var routeError: DBXFilePropertiesTemplateError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXFilePropertiesTemplateError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            completionHandler(routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXFilePropertiesTemplatesRemoveForUserRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<VoidSerializer, FileProperties.TemplateErrorSerializer>

    init(swift: RpcRequest<VoidSerializer, FileProperties.TemplateErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXFilePropertiesTemplateError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXFilePropertiesTemplateError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { _, error in
            var routeError: DBXFilePropertiesTemplateError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXFilePropertiesTemplateError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            completionHandler(routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXFilePropertiesTemplatesUpdateForTeamRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<FileProperties.UpdateTemplateResultSerializer, FileProperties.ModifyTemplateErrorSerializer>

    init(swift: RpcRequest<FileProperties.UpdateTemplateResultSerializer, FileProperties.ModifyTemplateErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXFilePropertiesUpdateTemplateResult?, DBXFilePropertiesModifyTemplateError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXFilePropertiesUpdateTemplateResult?, DBXFilePropertiesModifyTemplateError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXFilePropertiesModifyTemplateError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXFilePropertiesModifyTemplateError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXFilePropertiesUpdateTemplateResult?
            if let swift = result {
                objc = DBXFilePropertiesUpdateTemplateResult(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXFilePropertiesTemplatesUpdateForUserRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<FileProperties.UpdateTemplateResultSerializer, FileProperties.ModifyTemplateErrorSerializer>

    init(swift: RpcRequest<FileProperties.UpdateTemplateResultSerializer, FileProperties.ModifyTemplateErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXFilePropertiesUpdateTemplateResult?, DBXFilePropertiesModifyTemplateError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXFilePropertiesUpdateTemplateResult?, DBXFilePropertiesModifyTemplateError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXFilePropertiesModifyTemplateError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXFilePropertiesModifyTemplateError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXFilePropertiesUpdateTemplateResult?
            if let swift = result {
                objc = DBXFilePropertiesUpdateTemplateResult(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}
