///
/// Copyright (c) 2022 Dropbox, Inc. All rights reserved.
///
/// Auto-generated by Stone, do not modify.
///

import Foundation
import SwiftyDropbox

/// Objective-C compatible routes for the files namespace
/// For Swift routes see FilesRoutes
@objc
public class DBXFilesRoutes: NSObject {
    private let swift: FilesRoutes
    init(swift: FilesRoutes) {
        self.swift = swift
        self.client = swift.client.objc
    }

    public let client: DBXDropboxTransportClient

    /// Copy a file or folder to a different location in the user's Dropbox. If the source path is a folder all its
    /// contents will be copied.
    ///
    /// - scope: files.content.write
    ///
    /// - parameter allowSharedFolder: This flag has no effect.
    /// - parameter autorename: If there's a conflict, have the Dropbox server try to autorename the file to avoid the
    /// conflict.
    /// - parameter allowOwnershipTransfer: Allow moves by owner even if it would result in an ownership transfer for
    /// the content being moved. This does not apply to copies.
    ///
    /// - returns: Through the response callback, the caller will receive a `Files.RelocationResult` object on success
    /// or a `Files.RelocationError` object on failure.
    @objc
    @discardableResult public func copyV2(
        fromPath: String,
        toPath: String,
        allowSharedFolder: NSNumber,
        autorename: NSNumber,
        allowOwnershipTransfer: NSNumber
    ) -> DBXFilesCopyRpcRequestV2 {
        let swift = swift.copyV2(
            fromPath: fromPath,
            toPath: toPath,
            allowSharedFolder: allowSharedFolder.boolValue,
            autorename: autorename.boolValue,
            allowOwnershipTransfer: allowOwnershipTransfer.boolValue
        )
        return DBXFilesCopyRpcRequestV2(swift: swift)
    }

    /// Copy a file or folder to a different location in the user's Dropbox. If the source path is a folder all its
    /// contents will be copied.
    ///
    /// - scope: files.content.write
    ///
    /// - returns: Through the response callback, the caller will receive a `Files.RelocationResult` object on success
    /// or a `Files.RelocationError` object on failure.
    @objc
    @discardableResult public func copyV2(fromPath: String, toPath: String) -> DBXFilesCopyRpcRequestV2 {
        let swift = swift.copyV2(fromPath: fromPath, toPath: toPath)
        return DBXFilesCopyRpcRequestV2(swift: swift)
    }

    /// Copy multiple files or folders to different locations at once in the user's Dropbox. This route will replace
    /// copyBatch. The main difference is this route will return status for each entry, while copyBatch raises
    /// failure if any entry fails. This route will either finish synchronously, or return a job ID and do the async
    /// copy job in background. Please use copyBatchCheckV2 to check the job status.
    ///
    /// - scope: files.content.write
    ///
    /// - parameter entries: List of entries to be moved or copied. Each entry is RelocationPath.
    /// - parameter autorename: If there's a conflict with any file, have the Dropbox server try to autorename that file
    /// to avoid the conflict.
    ///
    /// - returns: Through the response callback, the caller will receive a `Files.RelocationBatchV2Launch` object on
    /// success or a `Void` object on failure.
    @objc
    @discardableResult public func copyBatchV2(entries: [DBXFilesRelocationPath], autorename: NSNumber) -> DBXFilesCopyBatchRpcRequestV2 {
        let swift = swift.copyBatchV2(entries: entries.map(\.swift), autorename: autorename.boolValue)
        return DBXFilesCopyBatchRpcRequestV2(swift: swift)
    }

    /// Copy multiple files or folders to different locations at once in the user's Dropbox. This route will replace
    /// copyBatch. The main difference is this route will return status for each entry, while copyBatch raises
    /// failure if any entry fails. This route will either finish synchronously, or return a job ID and do the async
    /// copy job in background. Please use copyBatchCheckV2 to check the job status.
    ///
    /// - scope: files.content.write
    ///
    /// - returns: Through the response callback, the caller will receive a `Files.RelocationBatchV2Launch` object on
    /// success or a `Void` object on failure.
    @objc
    @discardableResult public func copyBatchV2(entries: [DBXFilesRelocationPath]) -> DBXFilesCopyBatchRpcRequestV2 {
        let swift = swift.copyBatchV2(entries: entries.map(\.swift))
        return DBXFilesCopyBatchRpcRequestV2(swift: swift)
    }

    /// Returns the status of an asynchronous job for copyBatchV2. It returns list of results for each entry.
    ///
    /// - scope: files.content.write
    ///
    /// - parameter asyncJobId: Id of the asynchronous job. This is the value of a response returned from the method
    /// that launched the job.
    ///
    /// - returns: Through the response callback, the caller will receive a `Files.RelocationBatchV2JobStatus` object on
    /// success or a `Async.PollError` object on failure.
    @objc
    @discardableResult public func copyBatchCheckV2(asyncJobId: String) -> DBXFilesCopyBatchCheckRpcRequestV2 {
        let swift = swift.copyBatchCheckV2(asyncJobId: asyncJobId)
        return DBXFilesCopyBatchCheckRpcRequestV2(swift: swift)
    }

    /// Get a copy reference to a file or folder. This reference string can be used to save that file or folder to
    /// another user's Dropbox by passing it to copyReferenceSave.
    ///
    /// - scope: files.content.write
    ///
    /// - parameter path: The path to the file or folder you want to get a copy reference to.
    ///
    /// - returns: Through the response callback, the caller will receive a `Files.GetCopyReferenceResult` object on
    /// success or a `Files.GetCopyReferenceError` object on failure.
    @objc
    @discardableResult public func copyReferenceGet(path: String) -> DBXFilesCopyReferenceGetRpcRequest {
        let swift = swift.copyReferenceGet(path: path)
        return DBXFilesCopyReferenceGetRpcRequest(swift: swift)
    }

    /// Save a copy reference returned by copyReferenceGet to the user's Dropbox.
    ///
    /// - scope: files.content.write
    ///
    /// - parameter copyReference: A copy reference returned by copyReferenceGet.
    /// - parameter path: Path in the user's Dropbox that is the destination.
    ///
    /// - returns: Through the response callback, the caller will receive a `Files.SaveCopyReferenceResult` object on
    /// success or a `Files.SaveCopyReferenceError` object on failure.
    @objc
    @discardableResult public func copyReferenceSave(copyReference: String, path: String) -> DBXFilesCopyReferenceSaveRpcRequest {
        let swift = swift.copyReferenceSave(copyReference: copyReference, path: path)
        return DBXFilesCopyReferenceSaveRpcRequest(swift: swift)
    }

    /// Create a folder at a given path.
    ///
    /// - scope: files.content.write
    ///
    /// - parameter path: Path in the user's Dropbox to create.
    /// - parameter autorename: If there's a conflict, have the Dropbox server try to autorename the folder to avoid the
    /// conflict.
    ///
    /// - returns: Through the response callback, the caller will receive a `Files.CreateFolderResult` object on success
    /// or a `Files.CreateFolderError` object on failure.
    @objc
    @discardableResult public func createFolderV2(path: String, autorename: NSNumber) -> DBXFilesCreateFolderRpcRequestV2 {
        let swift = swift.createFolderV2(path: path, autorename: autorename.boolValue)
        return DBXFilesCreateFolderRpcRequestV2(swift: swift)
    }

    /// Create a folder at a given path.
    ///
    /// - scope: files.content.write
    ///
    /// - returns: Through the response callback, the caller will receive a `Files.CreateFolderResult` object on success
    /// or a `Files.CreateFolderError` object on failure.
    @objc
    @discardableResult public func createFolderV2(path: String) -> DBXFilesCreateFolderRpcRequestV2 {
        let swift = swift.createFolderV2(path: path)
        return DBXFilesCreateFolderRpcRequestV2(swift: swift)
    }

    /// Create multiple folders at once. This route is asynchronous for large batches, which returns a job ID
    /// immediately and runs the create folder batch asynchronously. Otherwise, creates the folders and returns the
    /// result synchronously for smaller inputs. You can force asynchronous behaviour by using the forceAsync in
    /// CreateFolderBatchArg flag.  Use createFolderBatchCheck to check the job status.
    ///
    /// - scope: files.content.write
    ///
    /// - parameter paths: List of paths to be created in the user's Dropbox. Duplicate path arguments in the batch are
    /// considered only once.
    /// - parameter autorename: If there's a conflict, have the Dropbox server try to autorename the folder to avoid the
    /// conflict.
    /// - parameter forceAsync: Whether to force the create to happen asynchronously.
    ///
    /// - returns: Through the response callback, the caller will receive a `Files.CreateFolderBatchLaunch` object on
    /// success or a `Void` object on failure.
    @objc
    @discardableResult public func createFolderBatch(paths: [String], autorename: NSNumber, forceAsync: NSNumber) -> DBXFilesCreateFolderBatchRpcRequest {
        let swift = swift.createFolderBatch(paths: paths, autorename: autorename.boolValue, forceAsync: forceAsync.boolValue)
        return DBXFilesCreateFolderBatchRpcRequest(swift: swift)
    }

    /// Create multiple folders at once. This route is asynchronous for large batches, which returns a job ID
    /// immediately and runs the create folder batch asynchronously. Otherwise, creates the folders and returns the
    /// result synchronously for smaller inputs. You can force asynchronous behaviour by using the forceAsync in
    /// CreateFolderBatchArg flag.  Use createFolderBatchCheck to check the job status.
    ///
    /// - scope: files.content.write
    ///
    /// - returns: Through the response callback, the caller will receive a `Files.CreateFolderBatchLaunch` object on
    /// success or a `Void` object on failure.
    @objc
    @discardableResult public func createFolderBatch(paths: [String]) -> DBXFilesCreateFolderBatchRpcRequest {
        let swift = swift.createFolderBatch(paths: paths)
        return DBXFilesCreateFolderBatchRpcRequest(swift: swift)
    }

    /// Returns the status of an asynchronous job for createFolderBatch. If success, it returns list of result for each
    /// entry.
    ///
    /// - scope: files.content.write
    ///
    /// - parameter asyncJobId: Id of the asynchronous job. This is the value of a response returned from the method
    /// that launched the job.
    ///
    /// - returns: Through the response callback, the caller will receive a `Files.CreateFolderBatchJobStatus` object on
    /// success or a `Async.PollError` object on failure.
    @objc
    @discardableResult public func createFolderBatchCheck(asyncJobId: String) -> DBXFilesCreateFolderBatchCheckRpcRequest {
        let swift = swift.createFolderBatchCheck(asyncJobId: asyncJobId)
        return DBXFilesCreateFolderBatchCheckRpcRequest(swift: swift)
    }

    /// Delete the file or folder at a given path. If the path is a folder, all its contents will be deleted too. A
    /// successful response indicates that the file or folder was deleted. The returned metadata will be the
    /// corresponding FileMetadata or FolderMetadata for the item at time of deletion, and not a DeletedMetadata
    /// object.
    ///
    /// - scope: files.content.write
    ///
    /// - parameter path: Path in the user's Dropbox to delete.
    /// - parameter parentRev: Perform delete if given "rev" matches the existing file's latest "rev". This field does
    /// not support deleting a folder.
    ///
    /// - returns: Through the response callback, the caller will receive a `Files.DeleteResult` object on success or a
    /// `Files.DeleteError` object on failure.
    @objc
    @discardableResult public func deleteV2(path: String, parentRev: String?) -> DBXFilesDeleteRpcRequestV2 {
        let swift = swift.deleteV2(path: path, parentRev: parentRev)
        return DBXFilesDeleteRpcRequestV2(swift: swift)
    }

    /// Delete the file or folder at a given path. If the path is a folder, all its contents will be deleted too. A
    /// successful response indicates that the file or folder was deleted. The returned metadata will be the
    /// corresponding FileMetadata or FolderMetadata for the item at time of deletion, and not a DeletedMetadata
    /// object.
    ///
    /// - scope: files.content.write
    ///
    /// - returns: Through the response callback, the caller will receive a `Files.DeleteResult` object on success or a
    /// `Files.DeleteError` object on failure.
    @objc
    @discardableResult public func deleteV2(path: String) -> DBXFilesDeleteRpcRequestV2 {
        let swift = swift.deleteV2(path: path)
        return DBXFilesDeleteRpcRequestV2(swift: swift)
    }

    /// Delete multiple files/folders at once. This route is asynchronous, which returns a job ID immediately and runs
    /// the delete batch asynchronously. Use deleteBatchCheck to check the job status.
    ///
    /// - scope: files.content.write
    ///
    ///
    /// - returns: Through the response callback, the caller will receive a `Files.DeleteBatchLaunch` object on success
    /// or a `Void` object on failure.
    @objc
    @discardableResult public func deleteBatch(entries: [DBXFilesDeleteArg]) -> DBXFilesDeleteBatchRpcRequest {
        let swift = swift.deleteBatch(entries: entries.map(\.swift))
        return DBXFilesDeleteBatchRpcRequest(swift: swift)
    }

    /// Returns the status of an asynchronous job for deleteBatch. If success, it returns list of result for each entry.
    ///
    /// - scope: files.content.write
    ///
    /// - parameter asyncJobId: Id of the asynchronous job. This is the value of a response returned from the method
    /// that launched the job.
    ///
    /// - returns: Through the response callback, the caller will receive a `Files.DeleteBatchJobStatus` object on
    /// success or a `Async.PollError` object on failure.
    @objc
    @discardableResult public func deleteBatchCheck(asyncJobId: String) -> DBXFilesDeleteBatchCheckRpcRequest {
        let swift = swift.deleteBatchCheck(asyncJobId: asyncJobId)
        return DBXFilesDeleteBatchCheckRpcRequest(swift: swift)
    }

    /// Download a file from a user's Dropbox.
    ///
    /// - scope: files.content.read
    ///
    /// - parameter path: The path of the file to download.
    /// - parameter rev: Please specify revision in path instead.
    /// - parameter overwrite: A boolean to set behavior in the event of a naming conflict. `True` will overwrite
    /// conflicting file at destination. `False` will take no action (but if left unhandled in destination closure,
    /// an NSError will be thrown).
    /// - parameter destination: The location to write the download to.
    ///
    /// - returns: Through the response callback, the caller will receive a `Files.FileMetadata` object on success or a
    /// `Files.DownloadError` object on failure.
    @objc
    @discardableResult public func downloadURL(path: String, rev: String?, overwrite: Bool, destination: URL) -> DBXFilesDownloadDownloadRequestFile {
        let swift = swift.download(path: path, rev: rev, overwrite: overwrite, destination: destination)
        return DBXFilesDownloadDownloadRequestFile(swift: swift)
    }

    /// Download a file from a user's Dropbox.
    ///
    /// - scope: files.content.read
    ///
    /// - returns: Through the response callback, the caller will receive a `Files.FileMetadata` object on success or a
    /// `Files.DownloadError` object on failure.
    @objc
    @discardableResult public func downloadURL(path: String, overwrite: Bool, destination: URL) -> DBXFilesDownloadDownloadRequestFile {
        let swift = swift.download(path: path, overwrite: overwrite, destination: destination)
        return DBXFilesDownloadDownloadRequestFile(swift: swift)
    }

    /// Download a file from a user's Dropbox.
    ///
    /// - scope: files.content.read
    ///
    /// - parameter path: The path of the file to download.
    /// - parameter rev: Please specify revision in path instead.
    ///
    /// - returns: Through the response callback, the caller will receive a `Files.FileMetadata` object on success or a
    /// `Files.DownloadError` object on failure.
    @objc
    @discardableResult public func download(path: String, rev: String?) -> DBXFilesDownloadDownloadRequestMemory {
        let swift = swift.download(path: path, rev: rev)
        return DBXFilesDownloadDownloadRequestMemory(swift: swift)
    }

    /// Download a file from a user's Dropbox.
    ///
    /// - scope: files.content.read
    ///
    /// - returns: Through the response callback, the caller will receive a `Files.FileMetadata` object on success or a
    /// `Files.DownloadError` object on failure.
    @objc
    @discardableResult public func download(path: String) -> DBXFilesDownloadDownloadRequestMemory {
        let swift = swift.download(path: path)
        return DBXFilesDownloadDownloadRequestMemory(swift: swift)
    }

    /// Download a folder from the user's Dropbox, as a zip file. The folder must be less than 20 GB in size and any
    /// single file within must be less than 4 GB in size. The resulting zip must have fewer than 10,000 total file
    /// and folder entries, including the top level folder. The input cannot be a single file. Note: this endpoint
    /// does not support HTTP range requests.
    ///
    /// - scope: files.content.read
    ///
    /// - parameter path: The path of the folder to download.
    /// - parameter overwrite: A boolean to set behavior in the event of a naming conflict. `True` will overwrite
    /// conflicting file at destination. `False` will take no action (but if left unhandled in destination closure,
    /// an NSError will be thrown).
    /// - parameter destination: The location to write the download to.
    ///
    /// - returns: Through the response callback, the caller will receive a `Files.DownloadZipResult` object on success
    /// or a `Files.DownloadZipError` object on failure.
    @objc
    @discardableResult public func downloadZipURL(path: String, overwrite: Bool, destination: URL) -> DBXFilesDownloadZipDownloadRequestFile {
        let swift = swift.downloadZip(path: path, overwrite: overwrite, destination: destination)
        return DBXFilesDownloadZipDownloadRequestFile(swift: swift)
    }

    /// Download a folder from the user's Dropbox, as a zip file. The folder must be less than 20 GB in size and any
    /// single file within must be less than 4 GB in size. The resulting zip must have fewer than 10,000 total file
    /// and folder entries, including the top level folder. The input cannot be a single file. Note: this endpoint
    /// does not support HTTP range requests.
    ///
    /// - scope: files.content.read
    ///
    /// - parameter path: The path of the folder to download.
    ///
    /// - returns: Through the response callback, the caller will receive a `Files.DownloadZipResult` object on success
    /// or a `Files.DownloadZipError` object on failure.
    @objc
    @discardableResult public func downloadZip(path: String) -> DBXFilesDownloadZipDownloadRequestMemory {
        let swift = swift.downloadZip(path: path)
        return DBXFilesDownloadZipDownloadRequestMemory(swift: swift)
    }

    /// Export a file from a user's Dropbox. This route only supports exporting files that cannot be downloaded directly
    /// and whose fileMetadata in ExportResult has exportAs in ExportInfo populated.
    ///
    /// - scope: files.content.read
    ///
    /// - parameter path: The path of the file to be exported.
    /// - parameter exportFormat: The file format to which the file should be exported. This must be one of the formats
    /// listed in the file's export_options returned by getMetadata. If none is specified, the default format
    /// (specified in export_as in file metadata) will be used.
    /// - parameter overwrite: A boolean to set behavior in the event of a naming conflict. `True` will overwrite
    /// conflicting file at destination. `False` will take no action (but if left unhandled in destination closure,
    /// an NSError will be thrown).
    /// - parameter destination: The location to write the download to.
    ///
    /// - returns: Through the response callback, the caller will receive a `Files.ExportResult` object on success or a
    /// `Files.ExportError` object on failure.
    @objc
    @discardableResult public func exportURL(path: String, exportFormat: String?, overwrite: Bool, destination: URL) -> DBXFilesExportDownloadRequestFile {
        let swift = swift.export(path: path, exportFormat: exportFormat, overwrite: overwrite, destination: destination)
        return DBXFilesExportDownloadRequestFile(swift: swift)
    }

    /// Export a file from a user's Dropbox. This route only supports exporting files that cannot be downloaded directly
    /// and whose fileMetadata in ExportResult has exportAs in ExportInfo populated.
    ///
    /// - scope: files.content.read
    ///
    /// - returns: Through the response callback, the caller will receive a `Files.ExportResult` object on success or a
    /// `Files.ExportError` object on failure.
    @objc
    @discardableResult public func exportURL(path: String, overwrite: Bool, destination: URL) -> DBXFilesExportDownloadRequestFile {
        let swift = swift.export(path: path, overwrite: overwrite, destination: destination)
        return DBXFilesExportDownloadRequestFile(swift: swift)
    }

    /// Export a file from a user's Dropbox. This route only supports exporting files that cannot be downloaded directly
    /// and whose fileMetadata in ExportResult has exportAs in ExportInfo populated.
    ///
    /// - scope: files.content.read
    ///
    /// - parameter path: The path of the file to be exported.
    /// - parameter exportFormat: The file format to which the file should be exported. This must be one of the formats
    /// listed in the file's export_options returned by getMetadata. If none is specified, the default format
    /// (specified in export_as in file metadata) will be used.
    ///
    /// - returns: Through the response callback, the caller will receive a `Files.ExportResult` object on success or a
    /// `Files.ExportError` object on failure.
    @objc
    @discardableResult public func export(path: String, exportFormat: String?) -> DBXFilesExportDownloadRequestMemory {
        let swift = swift.export(path: path, exportFormat: exportFormat)
        return DBXFilesExportDownloadRequestMemory(swift: swift)
    }

    /// Export a file from a user's Dropbox. This route only supports exporting files that cannot be downloaded directly
    /// and whose fileMetadata in ExportResult has exportAs in ExportInfo populated.
    ///
    /// - scope: files.content.read
    ///
    /// - returns: Through the response callback, the caller will receive a `Files.ExportResult` object on success or a
    /// `Files.ExportError` object on failure.
    @objc
    @discardableResult public func export(path: String) -> DBXFilesExportDownloadRequestMemory {
        let swift = swift.export(path: path)
        return DBXFilesExportDownloadRequestMemory(swift: swift)
    }

    /// Return the lock metadata for the given list of paths.
    ///
    /// - scope: files.content.read
    ///
    /// - parameter entries: List of 'entries'. Each 'entry' contains a path of the file which will be locked or
    /// queried. Duplicate path arguments in the batch are considered only once.
    ///
    /// - returns: Through the response callback, the caller will receive a `Files.LockFileBatchResult` object on
    /// success or a `Files.LockFileError` object on failure.
    @objc
    @discardableResult public func getFileLockBatch(entries: [DBXFilesLockFileArg]) -> DBXFilesGetFileLockBatchRpcRequest {
        let swift = swift.getFileLockBatch(entries: entries.map(\.swift))
        return DBXFilesGetFileLockBatchRpcRequest(swift: swift)
    }

    /// Returns the metadata for a file or folder. Note: Metadata for the root folder is unsupported.
    ///
    /// - scope: files.metadata.read
    ///
    /// - parameter path: The path of a file or folder on Dropbox.
    /// - parameter includeMediaInfo: If true, mediaInfo in FileMetadata is set for photo and video.
    /// - parameter includeDeleted: If true, DeletedMetadata will be returned for deleted file or folder, otherwise
    /// notFound in LookupError will be returned.
    /// - parameter includeHasExplicitSharedMembers: If true, the results will include a flag for each file indicating
    /// whether or not  that file has any explicit members.
    /// - parameter includePropertyGroups: If set to a valid list of template IDs, propertyGroups in FileMetadata is set
    /// if there exists property data associated with the file and each of the listed templates.
    ///
    /// - returns: Through the response callback, the caller will receive a `Files.Metadata` object on success or a
    /// `Files.GetMetadataError` object on failure.
    @objc
    @discardableResult public func getMetadata(
        path: String,
        includeMediaInfo: NSNumber,
        includeDeleted: NSNumber,
        includeHasExplicitSharedMembers: NSNumber,
        includePropertyGroups: DBXFilePropertiesTemplateFilterBase?
    ) -> DBXFilesGetMetadataRpcRequest {
        let swift = swift.getMetadata(
            path: path,
            includeMediaInfo: includeMediaInfo.boolValue,
            includeDeleted: includeDeleted.boolValue,
            includeHasExplicitSharedMembers: includeHasExplicitSharedMembers.boolValue,
            includePropertyGroups: includePropertyGroups?.swift
        )
        return DBXFilesGetMetadataRpcRequest(swift: swift)
    }

    /// Returns the metadata for a file or folder. Note: Metadata for the root folder is unsupported.
    ///
    /// - scope: files.metadata.read
    ///
    /// - returns: Through the response callback, the caller will receive a `Files.Metadata` object on success or a
    /// `Files.GetMetadataError` object on failure.
    @objc
    @discardableResult public func getMetadata(path: String) -> DBXFilesGetMetadataRpcRequest {
        let swift = swift.getMetadata(path: path)
        return DBXFilesGetMetadataRpcRequest(swift: swift)
    }

    /// Get a preview for a file. Currently, PDF previews are generated for files with the following extensions: .ai,
    /// .doc, .docm, .docx, .eps, .gdoc, .gslides, .odp, .odt, .pps, .ppsm, .ppsx, .ppt, .pptm, .pptx, .rtf. HTML
    /// previews are generated for files with the following extensions: .csv, .ods, .xls, .xlsm, .gsheet, .xlsx.
    /// Other formats will return an unsupported extension error.
    ///
    /// - scope: files.content.read
    ///
    /// - parameter path: The path of the file to preview.
    /// - parameter rev: Please specify revision in path instead.
    /// - parameter overwrite: A boolean to set behavior in the event of a naming conflict. `True` will overwrite
    /// conflicting file at destination. `False` will take no action (but if left unhandled in destination closure,
    /// an NSError will be thrown).
    /// - parameter destination: The location to write the download to.
    ///
    /// - returns: Through the response callback, the caller will receive a `Files.FileMetadata` object on success or a
    /// `Files.PreviewError` object on failure.
    @objc
    @discardableResult public func getPreviewURL(path: String, rev: String?, overwrite: Bool, destination: URL) -> DBXFilesGetPreviewDownloadRequestFile {
        let swift = swift.getPreview(path: path, rev: rev, overwrite: overwrite, destination: destination)
        return DBXFilesGetPreviewDownloadRequestFile(swift: swift)
    }

    /// Get a preview for a file. Currently, PDF previews are generated for files with the following extensions: .ai,
    /// .doc, .docm, .docx, .eps, .gdoc, .gslides, .odp, .odt, .pps, .ppsm, .ppsx, .ppt, .pptm, .pptx, .rtf. HTML
    /// previews are generated for files with the following extensions: .csv, .ods, .xls, .xlsm, .gsheet, .xlsx.
    /// Other formats will return an unsupported extension error.
    ///
    /// - scope: files.content.read
    ///
    /// - returns: Through the response callback, the caller will receive a `Files.FileMetadata` object on success or a
    /// `Files.PreviewError` object on failure.
    @objc
    @discardableResult public func getPreviewURL(path: String, overwrite: Bool, destination: URL) -> DBXFilesGetPreviewDownloadRequestFile {
        let swift = swift.getPreview(path: path, overwrite: overwrite, destination: destination)
        return DBXFilesGetPreviewDownloadRequestFile(swift: swift)
    }

    /// Get a preview for a file. Currently, PDF previews are generated for files with the following extensions: .ai,
    /// .doc, .docm, .docx, .eps, .gdoc, .gslides, .odp, .odt, .pps, .ppsm, .ppsx, .ppt, .pptm, .pptx, .rtf. HTML
    /// previews are generated for files with the following extensions: .csv, .ods, .xls, .xlsm, .gsheet, .xlsx.
    /// Other formats will return an unsupported extension error.
    ///
    /// - scope: files.content.read
    ///
    /// - parameter path: The path of the file to preview.
    /// - parameter rev: Please specify revision in path instead.
    ///
    /// - returns: Through the response callback, the caller will receive a `Files.FileMetadata` object on success or a
    /// `Files.PreviewError` object on failure.
    @objc
    @discardableResult public func getPreview(path: String, rev: String?) -> DBXFilesGetPreviewDownloadRequestMemory {
        let swift = swift.getPreview(path: path, rev: rev)
        return DBXFilesGetPreviewDownloadRequestMemory(swift: swift)
    }

    /// Get a preview for a file. Currently, PDF previews are generated for files with the following extensions: .ai,
    /// .doc, .docm, .docx, .eps, .gdoc, .gslides, .odp, .odt, .pps, .ppsm, .ppsx, .ppt, .pptm, .pptx, .rtf. HTML
    /// previews are generated for files with the following extensions: .csv, .ods, .xls, .xlsm, .gsheet, .xlsx.
    /// Other formats will return an unsupported extension error.
    ///
    /// - scope: files.content.read
    ///
    /// - returns: Through the response callback, the caller will receive a `Files.FileMetadata` object on success or a
    /// `Files.PreviewError` object on failure.
    @objc
    @discardableResult public func getPreview(path: String) -> DBXFilesGetPreviewDownloadRequestMemory {
        let swift = swift.getPreview(path: path)
        return DBXFilesGetPreviewDownloadRequestMemory(swift: swift)
    }

    /// Get a temporary link to stream content of a file. This link will expire in four hours and afterwards you will
    /// get 410 Gone. This URL should not be used to display content directly in the browser. The Content-Type of
    /// the link is determined automatically by the file's mime type.
    ///
    /// - scope: files.content.read
    ///
    /// - parameter path: The path to the file you want a temporary link to.
    ///
    /// - returns: Through the response callback, the caller will receive a `Files.GetTemporaryLinkResult` object on
    /// success or a `Files.GetTemporaryLinkError` object on failure.
    @objc
    @discardableResult public func getTemporaryLink(path: String) -> DBXFilesGetTemporaryLinkRpcRequest {
        let swift = swift.getTemporaryLink(path: path)
        return DBXFilesGetTemporaryLinkRpcRequest(swift: swift)
    }

    /// Get a one-time use temporary upload link to upload a file to a Dropbox location.  This endpoint acts as a
    /// delayed upload. The returned temporary upload link may be used to make a POST request with the data to be
    /// uploaded. The upload will then be perfomed with the CommitInfo previously provided to getTemporaryUploadLink
    /// but evaluated only upon consumption. Hence, errors stemming from invalid CommitInfo with respect to the
    /// state of the user's Dropbox will only be communicated at consumption time. Additionally, these errors are
    /// surfaced as generic HTTP 409 Conflict responses, potentially hiding issue details. The maximum temporary
    /// upload link duration is 4 hours. Upon consumption or expiration, a new link will have to be generated.
    /// Multiple links may exist for a specific upload path at any given time.  The POST request on the temporary
    /// upload link must have its Content-Type set to "application/octet-stream".  Example temporary upload link
    /// consumption request:  curl -X POST https://content.dropboxapi.com/apitul/1/bNi2uIYF51cVBND --header
    /// "Content-Type: application/octet-stream" --data-binary @local_file.txt  A successful temporary upload link
    /// consumption request returns the content hash of the uploaded data in JSON format.  Example successful
    /// temporary upload link consumption response: {"content-hash": "599d71033d700ac892a0e48fa61b125d2f5994"}  An
    /// unsuccessful temporary upload link consumption request returns any of the following status codes:  HTTP 400
    /// Bad Request: Content-Type is not one of application/octet-stream and text/plain or request is invalid. HTTP
    /// 409 Conflict: The temporary upload link does not exist or is currently unavailable, the upload failed, or
    /// another error happened. HTTP 410 Gone: The temporary upload link is expired or consumed.  Example
    /// unsuccessful temporary upload link consumption response: Temporary upload link has been recently consumed.
    ///
    /// - scope: files.content.write
    ///
    /// - parameter commitInfo: Contains the path and other optional modifiers for the future upload commit. Equivalent
    /// to the parameters provided to upload.
    /// - parameter duration: How long before this link expires, in seconds.  Attempting to start an upload with this
    /// link longer than this period  of time after link creation will result in an error.
    ///
    /// - returns: Through the response callback, the caller will receive a `Files.GetTemporaryUploadLinkResult` object
    /// on success or a `Void` object on failure.
    @objc
    @discardableResult public func getTemporaryUploadLink(commitInfo: DBXFilesCommitInfo, duration: NSNumber) -> DBXFilesGetTemporaryUploadLinkRpcRequest {
        let swift = swift.getTemporaryUploadLink(commitInfo: commitInfo.swift, duration: duration.doubleValue)
        return DBXFilesGetTemporaryUploadLinkRpcRequest(swift: swift)
    }

    /// Get a one-time use temporary upload link to upload a file to a Dropbox location.  This endpoint acts as a
    /// delayed upload. The returned temporary upload link may be used to make a POST request with the data to be
    /// uploaded. The upload will then be perfomed with the CommitInfo previously provided to getTemporaryUploadLink
    /// but evaluated only upon consumption. Hence, errors stemming from invalid CommitInfo with respect to the
    /// state of the user's Dropbox will only be communicated at consumption time. Additionally, these errors are
    /// surfaced as generic HTTP 409 Conflict responses, potentially hiding issue details. The maximum temporary
    /// upload link duration is 4 hours. Upon consumption or expiration, a new link will have to be generated.
    /// Multiple links may exist for a specific upload path at any given time.  The POST request on the temporary
    /// upload link must have its Content-Type set to "application/octet-stream".  Example temporary upload link
    /// consumption request:  curl -X POST https://content.dropboxapi.com/apitul/1/bNi2uIYF51cVBND --header
    /// "Content-Type: application/octet-stream" --data-binary @local_file.txt  A successful temporary upload link
    /// consumption request returns the content hash of the uploaded data in JSON format.  Example successful
    /// temporary upload link consumption response: {"content-hash": "599d71033d700ac892a0e48fa61b125d2f5994"}  An
    /// unsuccessful temporary upload link consumption request returns any of the following status codes:  HTTP 400
    /// Bad Request: Content-Type is not one of application/octet-stream and text/plain or request is invalid. HTTP
    /// 409 Conflict: The temporary upload link does not exist or is currently unavailable, the upload failed, or
    /// another error happened. HTTP 410 Gone: The temporary upload link is expired or consumed.  Example
    /// unsuccessful temporary upload link consumption response: Temporary upload link has been recently consumed.
    ///
    /// - scope: files.content.write
    ///
    /// - returns: Through the response callback, the caller will receive a `Files.GetTemporaryUploadLinkResult` object
    /// on success or a `Void` object on failure.
    @objc
    @discardableResult public func getTemporaryUploadLink(commitInfo: DBXFilesCommitInfo) -> DBXFilesGetTemporaryUploadLinkRpcRequest {
        let swift = swift.getTemporaryUploadLink(commitInfo: commitInfo.swift)
        return DBXFilesGetTemporaryUploadLinkRpcRequest(swift: swift)
    }

    /// Get a thumbnail for an image. This method currently supports files with the following file extensions: jpg,
    /// jpeg, png, tiff, tif, gif, webp, ppm and bmp. Photos that are larger than 20MB in size won't be converted to
    /// a thumbnail.
    ///
    /// - scope: files.content.read
    ///
    /// - parameter path: The path to the image file you want to thumbnail.
    /// - parameter format: The format for the thumbnail image, jpeg (default) or png. For  images that are photos, jpeg
    /// should be preferred, while png is  better for screenshots and digital arts.
    /// - parameter size: The size for the thumbnail image.
    /// - parameter mode: How to resize and crop the image to achieve the desired size.
    /// - parameter overwrite: A boolean to set behavior in the event of a naming conflict. `True` will overwrite
    /// conflicting file at destination. `False` will take no action (but if left unhandled in destination closure,
    /// an NSError will be thrown).
    /// - parameter destination: The location to write the download to.
    ///
    /// - returns: Through the response callback, the caller will receive a `Files.FileMetadata` object on success or a
    /// `Files.ThumbnailError` object on failure.
    @objc
    @discardableResult public func getThumbnailURL(
        path: String,
        format: DBXFilesThumbnailFormat,
        size: DBXFilesThumbnailSize,
        mode: DBXFilesThumbnailMode,
        overwrite: Bool,
        destination: URL
    ) -> DBXFilesGetThumbnailDownloadRequestFile {
        let swift = swift.getThumbnail(path: path, format: format.swift, size: size.swift, mode: mode.swift, overwrite: overwrite, destination: destination)
        return DBXFilesGetThumbnailDownloadRequestFile(swift: swift)
    }

    /// Get a thumbnail for an image. This method currently supports files with the following file extensions: jpg,
    /// jpeg, png, tiff, tif, gif, webp, ppm and bmp. Photos that are larger than 20MB in size won't be converted to
    /// a thumbnail.
    ///
    /// - scope: files.content.read
    ///
    /// - returns: Through the response callback, the caller will receive a `Files.FileMetadata` object on success or a
    /// `Files.ThumbnailError` object on failure.
    @objc
    @discardableResult public func getThumbnailURL(path: String, overwrite: Bool, destination: URL) -> DBXFilesGetThumbnailDownloadRequestFile {
        let swift = swift.getThumbnail(path: path, overwrite: overwrite, destination: destination)
        return DBXFilesGetThumbnailDownloadRequestFile(swift: swift)
    }

    /// Get a thumbnail for an image. This method currently supports files with the following file extensions: jpg,
    /// jpeg, png, tiff, tif, gif, webp, ppm and bmp. Photos that are larger than 20MB in size won't be converted to
    /// a thumbnail.
    ///
    /// - scope: files.content.read
    ///
    /// - parameter path: The path to the image file you want to thumbnail.
    /// - parameter format: The format for the thumbnail image, jpeg (default) or png. For  images that are photos, jpeg
    /// should be preferred, while png is  better for screenshots and digital arts.
    /// - parameter size: The size for the thumbnail image.
    /// - parameter mode: How to resize and crop the image to achieve the desired size.
    ///
    /// - returns: Through the response callback, the caller will receive a `Files.FileMetadata` object on success or a
    /// `Files.ThumbnailError` object on failure.
    @objc
    @discardableResult public func getThumbnail(
        path: String,
        format: DBXFilesThumbnailFormat,
        size: DBXFilesThumbnailSize,
        mode: DBXFilesThumbnailMode
    ) -> DBXFilesGetThumbnailDownloadRequestMemory {
        let swift = swift.getThumbnail(path: path, format: format.swift, size: size.swift, mode: mode.swift)
        return DBXFilesGetThumbnailDownloadRequestMemory(swift: swift)
    }

    /// Get a thumbnail for an image. This method currently supports files with the following file extensions: jpg,
    /// jpeg, png, tiff, tif, gif, webp, ppm and bmp. Photos that are larger than 20MB in size won't be converted to
    /// a thumbnail.
    ///
    /// - scope: files.content.read
    ///
    /// - returns: Through the response callback, the caller will receive a `Files.FileMetadata` object on success or a
    /// `Files.ThumbnailError` object on failure.
    @objc
    @discardableResult public func getThumbnail(path: String) -> DBXFilesGetThumbnailDownloadRequestMemory {
        let swift = swift.getThumbnail(path: path)
        return DBXFilesGetThumbnailDownloadRequestMemory(swift: swift)
    }

    /// Get a thumbnail for an image. This method currently supports files with the following file extensions: jpg,
    /// jpeg, png, tiff, tif, gif, webp, ppm and bmp. Photos that are larger than 20MB in size won't be converted to
    /// a thumbnail.
    ///
    /// - scope: files.content.read
    ///
    /// - parameter resource: Information specifying which file to preview. This could be a path to a file, a shared
    /// link pointing to a file, or a shared link pointing to a folder, with a relative path.
    /// - parameter format: The format for the thumbnail image, jpeg (default) or png. For  images that are photos, jpeg
    /// should be preferred, while png is  better for screenshots and digital arts.
    /// - parameter size: The size for the thumbnail image.
    /// - parameter mode: How to resize and crop the image to achieve the desired size.
    /// - parameter overwrite: A boolean to set behavior in the event of a naming conflict. `True` will overwrite
    /// conflicting file at destination. `False` will take no action (but if left unhandled in destination closure,
    /// an NSError will be thrown).
    /// - parameter destination: The location to write the download to.
    ///
    /// - returns: Through the response callback, the caller will receive a `Files.PreviewResult` object on success or a
    /// `Files.ThumbnailV2Error` object on failure.
    @objc
    @discardableResult public func getThumbnailV2URL(
        resource: DBXFilesPathOrLink,
        format: DBXFilesThumbnailFormat,
        size: DBXFilesThumbnailSize,
        mode: DBXFilesThumbnailMode,
        overwrite: Bool,
        destination: URL
    ) -> DBXFilesGetThumbnailDownloadRequestFileV2 {
        let swift = swift.getThumbnailV2(
            resource: resource.swift,
            format: format.swift,
            size: size.swift,
            mode: mode.swift,
            overwrite: overwrite,
            destination: destination
        )
        return DBXFilesGetThumbnailDownloadRequestFileV2(swift: swift)
    }

    /// Get a thumbnail for an image. This method currently supports files with the following file extensions: jpg,
    /// jpeg, png, tiff, tif, gif, webp, ppm and bmp. Photos that are larger than 20MB in size won't be converted to
    /// a thumbnail.
    ///
    /// - scope: files.content.read
    ///
    /// - returns: Through the response callback, the caller will receive a `Files.PreviewResult` object on success or a
    /// `Files.ThumbnailV2Error` object on failure.
    @objc
    @discardableResult public func getThumbnailV2URL(
        resource: DBXFilesPathOrLink,
        overwrite: Bool,
        destination: URL
    ) -> DBXFilesGetThumbnailDownloadRequestFileV2 {
        let swift = swift.getThumbnailV2(resource: resource.swift, overwrite: overwrite, destination: destination)
        return DBXFilesGetThumbnailDownloadRequestFileV2(swift: swift)
    }

    /// Get a thumbnail for an image. This method currently supports files with the following file extensions: jpg,
    /// jpeg, png, tiff, tif, gif, webp, ppm and bmp. Photos that are larger than 20MB in size won't be converted to
    /// a thumbnail.
    ///
    /// - scope: files.content.read
    ///
    /// - parameter resource: Information specifying which file to preview. This could be a path to a file, a shared
    /// link pointing to a file, or a shared link pointing to a folder, with a relative path.
    /// - parameter format: The format for the thumbnail image, jpeg (default) or png. For  images that are photos, jpeg
    /// should be preferred, while png is  better for screenshots and digital arts.
    /// - parameter size: The size for the thumbnail image.
    /// - parameter mode: How to resize and crop the image to achieve the desired size.
    ///
    /// - returns: Through the response callback, the caller will receive a `Files.PreviewResult` object on success or a
    /// `Files.ThumbnailV2Error` object on failure.
    @objc
    @discardableResult public func getThumbnailV2(
        resource: DBXFilesPathOrLink,
        format: DBXFilesThumbnailFormat,
        size: DBXFilesThumbnailSize,
        mode: DBXFilesThumbnailMode
    ) -> DBXFilesGetThumbnailDownloadRequestMemoryV2 {
        let swift = swift.getThumbnailV2(resource: resource.swift, format: format.swift, size: size.swift, mode: mode.swift)
        return DBXFilesGetThumbnailDownloadRequestMemoryV2(swift: swift)
    }

    /// Get a thumbnail for an image. This method currently supports files with the following file extensions: jpg,
    /// jpeg, png, tiff, tif, gif, webp, ppm and bmp. Photos that are larger than 20MB in size won't be converted to
    /// a thumbnail.
    ///
    /// - scope: files.content.read
    ///
    /// - returns: Through the response callback, the caller will receive a `Files.PreviewResult` object on success or a
    /// `Files.ThumbnailV2Error` object on failure.
    @objc
    @discardableResult public func getThumbnailV2(resource: DBXFilesPathOrLink) -> DBXFilesGetThumbnailDownloadRequestMemoryV2 {
        let swift = swift.getThumbnailV2(resource: resource.swift)
        return DBXFilesGetThumbnailDownloadRequestMemoryV2(swift: swift)
    }

    /// Get thumbnails for a list of images. We allow up to 25 thumbnails in a single batch. This method currently
    /// supports files with the following file extensions: jpg, jpeg, png, tiff, tif, gif, webp, ppm and bmp. Photos
    /// that are larger than 20MB in size won't be converted to a thumbnail.
    ///
    /// - scope: files.content.read
    ///
    /// - parameter entries: List of files to get thumbnails.
    ///
    /// - returns: Through the response callback, the caller will receive a `Files.GetThumbnailBatchResult` object on
    /// success or a `Files.GetThumbnailBatchError` object on failure.
    @objc
    @discardableResult public func getThumbnailBatch(entries: [DBXFilesThumbnailArg]) -> DBXFilesGetThumbnailBatchRpcRequest {
        let swift = swift.getThumbnailBatch(entries: entries.map(\.swift))
        return DBXFilesGetThumbnailBatchRpcRequest(swift: swift)
    }

    /// Starts returning the contents of a folder. If the result's hasMore in ListFolderResult field is true, call
    /// listFolderContinue with the returned cursor in ListFolderResult to retrieve more entries. If you're using
    /// recursive in ListFolderArg set to true to keep a local cache of the contents of a Dropbox account, iterate
    /// through each entry in order and process them as follows to keep your local state in sync: For each
    /// FileMetadata, store the new entry at the given path in your local state. If the required parent folders
    /// don't exist yet, create them. If there's already something else at the given path, replace it and remove all
    /// its children. For each FolderMetadata, store the new entry at the given path in your local state. If the
    /// required parent folders don't exist yet, create them. If there's already something else at the given path,
    /// replace it but leave the children as they are. Check the new entry's readOnly in FolderSharingInfo and set
    /// all its children's read-only statuses to match. For each DeletedMetadata, if your local state has something
    /// at the given path, remove it and all its children. If there's nothing at the given path, ignore this entry.
    /// Note: auth.RateLimitError may be returned if multiple listFolder or listFolderContinue calls with same
    /// parameters are made simultaneously by same API app for same user. If your app implements retry logic, please
    /// hold off the retry until the previous request finishes.
    ///
    /// - scope: files.metadata.read
    ///
    /// - parameter path: A unique identifier for the file.
    /// - parameter recursive: If true, the list folder operation will be applied recursively to all subfolders and the
    /// response will contain contents of all subfolders.
    /// - parameter includeMediaInfo: If true, mediaInfo in FileMetadata is set for photo and video. This parameter will
    /// no longer have an effect starting December 2, 2019.
    /// - parameter includeDeleted: If true, the results will include entries for files and folders that used to exist
    /// but were deleted.
    /// - parameter includeHasExplicitSharedMembers: If true, the results will include a flag for each file indicating
    /// whether or not  that file has any explicit members.
    /// - parameter includeMountedFolders: If true, the results will include entries under mounted folders which
    /// includes app folder, shared folder and team folder.
    /// - parameter limit: The maximum number of results to return per request. Note: This is an approximate number and
    /// there can be slightly more entries returned in some cases.
    /// - parameter sharedLink: A shared link to list the contents of. If the link is password-protected, the password
    /// must be provided. If this field is present, path in ListFolderArg will be relative to root of the shared
    /// link. Only non-recursive mode is supported for shared link.
    /// - parameter includePropertyGroups: If set to a valid list of template IDs, propertyGroups in FileMetadata is set
    /// if there exists property data associated with the file and each of the listed templates.
    /// - parameter includeNonDownloadableFiles: If true, include files that are not downloadable, i.e. Google Docs.
    ///
    /// - returns: Through the response callback, the caller will receive a `Files.ListFolderResult` object on success
    /// or a `Files.ListFolderError` object on failure.
    @objc
    @discardableResult public func listFolder(
        path: String,
        recursive: NSNumber,
        includeMediaInfo: NSNumber,
        includeDeleted: NSNumber,
        includeHasExplicitSharedMembers: NSNumber,
        includeMountedFolders: NSNumber,
        limit: NSNumber?,
        sharedLink: DBXFilesSharedLink?,
        includePropertyGroups: DBXFilePropertiesTemplateFilterBase?,
        includeNonDownloadableFiles: NSNumber
    ) -> DBXFilesListFolderRpcRequest {
        let swift = swift.listFolder(
            path: path,
            recursive: recursive.boolValue,
            includeMediaInfo: includeMediaInfo.boolValue,
            includeDeleted: includeDeleted.boolValue,
            includeHasExplicitSharedMembers: includeHasExplicitSharedMembers.boolValue,
            includeMountedFolders: includeMountedFolders.boolValue,
            limit: limit?.uint32Value,
            sharedLink: sharedLink?.swift,
            includePropertyGroups: includePropertyGroups?.swift,
            includeNonDownloadableFiles: includeNonDownloadableFiles.boolValue
        )
        return DBXFilesListFolderRpcRequest(swift: swift)
    }

    /// Starts returning the contents of a folder. If the result's hasMore in ListFolderResult field is true, call
    /// listFolderContinue with the returned cursor in ListFolderResult to retrieve more entries. If you're using
    /// recursive in ListFolderArg set to true to keep a local cache of the contents of a Dropbox account, iterate
    /// through each entry in order and process them as follows to keep your local state in sync: For each
    /// FileMetadata, store the new entry at the given path in your local state. If the required parent folders
    /// don't exist yet, create them. If there's already something else at the given path, replace it and remove all
    /// its children. For each FolderMetadata, store the new entry at the given path in your local state. If the
    /// required parent folders don't exist yet, create them. If there's already something else at the given path,
    /// replace it but leave the children as they are. Check the new entry's readOnly in FolderSharingInfo and set
    /// all its children's read-only statuses to match. For each DeletedMetadata, if your local state has something
    /// at the given path, remove it and all its children. If there's nothing at the given path, ignore this entry.
    /// Note: auth.RateLimitError may be returned if multiple listFolder or listFolderContinue calls with same
    /// parameters are made simultaneously by same API app for same user. If your app implements retry logic, please
    /// hold off the retry until the previous request finishes.
    ///
    /// - scope: files.metadata.read
    ///
    /// - returns: Through the response callback, the caller will receive a `Files.ListFolderResult` object on success
    /// or a `Files.ListFolderError` object on failure.
    @objc
    @discardableResult public func listFolder(path: String) -> DBXFilesListFolderRpcRequest {
        let swift = swift.listFolder(path: path)
        return DBXFilesListFolderRpcRequest(swift: swift)
    }

    /// Once a cursor has been retrieved from listFolder, use this to paginate through all files and retrieve updates to
    /// the folder, following the same rules as documented for listFolder.
    ///
    /// - scope: files.metadata.read
    ///
    /// - parameter cursor: The cursor returned by your last call to listFolder or listFolderContinue.
    ///
    /// - returns: Through the response callback, the caller will receive a `Files.ListFolderResult` object on success
    /// or a `Files.ListFolderContinueError` object on failure.
    @objc
    @discardableResult public func listFolderContinue(cursor: String) -> DBXFilesListFolderContinueRpcRequest {
        let swift = swift.listFolderContinue(cursor: cursor)
        return DBXFilesListFolderContinueRpcRequest(swift: swift)
    }

    /// A way to quickly get a cursor for the folder's state. Unlike listFolder, listFolderGetLatestCursor doesn't
    /// return any entries. This endpoint is for app which only needs to know about new files and modifications and
    /// doesn't need to know about files that already exist in Dropbox.
    ///
    /// - scope: files.metadata.read
    ///
    /// - parameter path: A unique identifier for the file.
    /// - parameter recursive: If true, the list folder operation will be applied recursively to all subfolders and the
    /// response will contain contents of all subfolders.
    /// - parameter includeMediaInfo: If true, mediaInfo in FileMetadata is set for photo and video. This parameter will
    /// no longer have an effect starting December 2, 2019.
    /// - parameter includeDeleted: If true, the results will include entries for files and folders that used to exist
    /// but were deleted.
    /// - parameter includeHasExplicitSharedMembers: If true, the results will include a flag for each file indicating
    /// whether or not  that file has any explicit members.
    /// - parameter includeMountedFolders: If true, the results will include entries under mounted folders which
    /// includes app folder, shared folder and team folder.
    /// - parameter limit: The maximum number of results to return per request. Note: This is an approximate number and
    /// there can be slightly more entries returned in some cases.
    /// - parameter sharedLink: A shared link to list the contents of. If the link is password-protected, the password
    /// must be provided. If this field is present, path in ListFolderArg will be relative to root of the shared
    /// link. Only non-recursive mode is supported for shared link.
    /// - parameter includePropertyGroups: If set to a valid list of template IDs, propertyGroups in FileMetadata is set
    /// if there exists property data associated with the file and each of the listed templates.
    /// - parameter includeNonDownloadableFiles: If true, include files that are not downloadable, i.e. Google Docs.
    ///
    /// - returns: Through the response callback, the caller will receive a `Files.ListFolderGetLatestCursorResult`
    /// object on success or a `Files.ListFolderError` object on failure.
    @objc
    @discardableResult public func listFolderGetLatestCursor(
        path: String,
        recursive: NSNumber,
        includeMediaInfo: NSNumber,
        includeDeleted: NSNumber,
        includeHasExplicitSharedMembers: NSNumber,
        includeMountedFolders: NSNumber,
        limit: NSNumber?,
        sharedLink: DBXFilesSharedLink?,
        includePropertyGroups: DBXFilePropertiesTemplateFilterBase?,
        includeNonDownloadableFiles: NSNumber
    ) -> DBXFilesListFolderGetLatestCursorRpcRequest {
        let swift = swift.listFolderGetLatestCursor(
            path: path,
            recursive: recursive.boolValue,
            includeMediaInfo: includeMediaInfo.boolValue,
            includeDeleted: includeDeleted.boolValue,
            includeHasExplicitSharedMembers: includeHasExplicitSharedMembers.boolValue,
            includeMountedFolders: includeMountedFolders.boolValue,
            limit: limit?.uint32Value,
            sharedLink: sharedLink?.swift,
            includePropertyGroups: includePropertyGroups?.swift,
            includeNonDownloadableFiles: includeNonDownloadableFiles.boolValue
        )
        return DBXFilesListFolderGetLatestCursorRpcRequest(swift: swift)
    }

    /// A way to quickly get a cursor for the folder's state. Unlike listFolder, listFolderGetLatestCursor doesn't
    /// return any entries. This endpoint is for app which only needs to know about new files and modifications and
    /// doesn't need to know about files that already exist in Dropbox.
    ///
    /// - scope: files.metadata.read
    ///
    /// - returns: Through the response callback, the caller will receive a `Files.ListFolderGetLatestCursorResult`
    /// object on success or a `Files.ListFolderError` object on failure.
    @objc
    @discardableResult public func listFolderGetLatestCursor(path: String) -> DBXFilesListFolderGetLatestCursorRpcRequest {
        let swift = swift.listFolderGetLatestCursor(path: path)
        return DBXFilesListFolderGetLatestCursorRpcRequest(swift: swift)
    }

    /// A longpoll endpoint to wait for changes on an account. In conjunction with listFolderContinue, this call gives
    /// you a low-latency way to monitor an account for file changes. The connection will block until there are
    /// changes available or a timeout occurs. This endpoint is useful mostly for client-side apps. If you're
    /// looking for server-side notifications, check out our webhooks documentation
    /// https://www.dropbox.com/developers/reference/webhooks.
    ///
    /// - scope: files.metadata.read
    ///
    /// - parameter cursor: A cursor as returned by listFolder or listFolderContinue. Cursors retrieved by setting
    /// includeMediaInfo in ListFolderArg to true are not supported.
    /// - parameter timeout: A timeout in seconds. The request will block for at most this length of time, plus up to 90
    /// seconds of random jitter added to avoid the thundering herd problem. Care should be taken when using this
    /// parameter, as some network infrastructure does not support long timeouts.
    ///
    /// - returns: Through the response callback, the caller will receive a `Files.ListFolderLongpollResult` object on
    /// success or a `Files.ListFolderLongpollError` object on failure.
    @objc
    @discardableResult public func listFolderLongpoll(cursor: String, timeout: NSNumber) -> DBXFilesListFolderLongpollRpcRequest {
        let swift = swift.listFolderLongpoll(cursor: cursor, timeout: timeout.uint64Value)
        return DBXFilesListFolderLongpollRpcRequest(swift: swift)
    }

    /// A longpoll endpoint to wait for changes on an account. In conjunction with listFolderContinue, this call gives
    /// you a low-latency way to monitor an account for file changes. The connection will block until there are
    /// changes available or a timeout occurs. This endpoint is useful mostly for client-side apps. If you're
    /// looking for server-side notifications, check out our webhooks documentation
    /// https://www.dropbox.com/developers/reference/webhooks.
    ///
    /// - scope: files.metadata.read
    ///
    /// - returns: Through the response callback, the caller will receive a `Files.ListFolderLongpollResult` object on
    /// success or a `Files.ListFolderLongpollError` object on failure.
    @objc
    @discardableResult public func listFolderLongpoll(cursor: String) -> DBXFilesListFolderLongpollRpcRequest {
        let swift = swift.listFolderLongpoll(cursor: cursor)
        return DBXFilesListFolderLongpollRpcRequest(swift: swift)
    }

    /// Returns revisions for files based on a file path or a file id. The file path or file id is identified from the
    /// latest file entry at the given file path or id. This end point allows your app to query either by file path
    /// or file id by setting the mode parameter appropriately. In the path in ListRevisionsMode (default) mode, all
    /// revisions at the same file path as the latest file entry are returned. If revisions with the same file id
    /// are desired, then mode must be set to id in ListRevisionsMode. The id in ListRevisionsMode mode is useful to
    /// retrieve revisions for a given file across moves or renames.
    ///
    /// - scope: files.metadata.read
    ///
    /// - parameter path: The path to the file you want to see the revisions of.
    /// - parameter mode: Determines the behavior of the API in listing the revisions for a given file path or id.
    /// - parameter limit: The maximum number of revision entries returned.
    ///
    /// - returns: Through the response callback, the caller will receive a `Files.ListRevisionsResult` object on
    /// success or a `Files.ListRevisionsError` object on failure.
    @objc
    @discardableResult public func listRevisions(path: String, mode: DBXFilesListRevisionsMode, limit: NSNumber) -> DBXFilesListRevisionsRpcRequest {
        let swift = swift.listRevisions(path: path, mode: mode.swift, limit: limit.uint64Value)
        return DBXFilesListRevisionsRpcRequest(swift: swift)
    }

    /// Returns revisions for files based on a file path or a file id. The file path or file id is identified from the
    /// latest file entry at the given file path or id. This end point allows your app to query either by file path
    /// or file id by setting the mode parameter appropriately. In the path in ListRevisionsMode (default) mode, all
    /// revisions at the same file path as the latest file entry are returned. If revisions with the same file id
    /// are desired, then mode must be set to id in ListRevisionsMode. The id in ListRevisionsMode mode is useful to
    /// retrieve revisions for a given file across moves or renames.
    ///
    /// - scope: files.metadata.read
    ///
    /// - returns: Through the response callback, the caller will receive a `Files.ListRevisionsResult` object on
    /// success or a `Files.ListRevisionsError` object on failure.
    @objc
    @discardableResult public func listRevisions(path: String) -> DBXFilesListRevisionsRpcRequest {
        let swift = swift.listRevisions(path: path)
        return DBXFilesListRevisionsRpcRequest(swift: swift)
    }

    /// Lock the files at the given paths. A locked file will be writable only by the lock holder. A successful response
    /// indicates that the file has been locked. Returns a list of the locked file paths and their metadata after
    /// this operation.
    ///
    /// - scope: files.content.write
    ///
    /// - parameter entries: List of 'entries'. Each 'entry' contains a path of the file which will be locked or
    /// queried. Duplicate path arguments in the batch are considered only once.
    ///
    /// - returns: Through the response callback, the caller will receive a `Files.LockFileBatchResult` object on
    /// success or a `Files.LockFileError` object on failure.
    @objc
    @discardableResult public func lockFileBatch(entries: [DBXFilesLockFileArg]) -> DBXFilesLockFileBatchRpcRequest {
        let swift = swift.lockFileBatch(entries: entries.map(\.swift))
        return DBXFilesLockFileBatchRpcRequest(swift: swift)
    }

    /// Move a file or folder to a different location in the user's Dropbox. If the source path is a folder all its
    /// contents will be moved. Note that we do not currently support case-only renaming.
    ///
    /// - scope: files.content.write
    ///
    /// - parameter allowSharedFolder: This flag has no effect.
    /// - parameter autorename: If there's a conflict, have the Dropbox server try to autorename the file to avoid the
    /// conflict.
    /// - parameter allowOwnershipTransfer: Allow moves by owner even if it would result in an ownership transfer for
    /// the content being moved. This does not apply to copies.
    ///
    /// - returns: Through the response callback, the caller will receive a `Files.RelocationResult` object on success
    /// or a `Files.RelocationError` object on failure.
    @objc
    @discardableResult public func moveV2(
        fromPath: String,
        toPath: String,
        allowSharedFolder: NSNumber,
        autorename: NSNumber,
        allowOwnershipTransfer: NSNumber
    ) -> DBXFilesMoveRpcRequestV2 {
        let swift = swift.moveV2(
            fromPath: fromPath,
            toPath: toPath,
            allowSharedFolder: allowSharedFolder.boolValue,
            autorename: autorename.boolValue,
            allowOwnershipTransfer: allowOwnershipTransfer.boolValue
        )
        return DBXFilesMoveRpcRequestV2(swift: swift)
    }

    /// Move a file or folder to a different location in the user's Dropbox. If the source path is a folder all its
    /// contents will be moved. Note that we do not currently support case-only renaming.
    ///
    /// - scope: files.content.write
    ///
    /// - returns: Through the response callback, the caller will receive a `Files.RelocationResult` object on success
    /// or a `Files.RelocationError` object on failure.
    @objc
    @discardableResult public func moveV2(fromPath: String, toPath: String) -> DBXFilesMoveRpcRequestV2 {
        let swift = swift.moveV2(fromPath: fromPath, toPath: toPath)
        return DBXFilesMoveRpcRequestV2(swift: swift)
    }

    /// Move multiple files or folders to different locations at once in the user's Dropbox. Note that we do not
    /// currently support case-only renaming. This route will replace moveBatch. The main difference is this route
    /// will return status for each entry, while moveBatch raises failure if any entry fails. This route will either
    /// finish synchronously, or return a job ID and do the async move job in background. Please use
    /// moveBatchCheckV2 to check the job status.
    ///
    /// - scope: files.content.write
    ///
    /// - parameter allowOwnershipTransfer: Allow moves by owner even if it would result in an ownership transfer for
    /// the content being moved. This does not apply to copies.
    ///
    /// - returns: Through the response callback, the caller will receive a `Files.RelocationBatchV2Launch` object on
    /// success or a `Void` object on failure.
    @objc
    @discardableResult public func moveBatchV2(
        entries: [DBXFilesRelocationPath],
        autorename: NSNumber,
        allowOwnershipTransfer: NSNumber
    ) -> DBXFilesMoveBatchRpcRequestV2 {
        let swift = swift.moveBatchV2(entries: entries.map(\.swift), autorename: autorename.boolValue, allowOwnershipTransfer: allowOwnershipTransfer.boolValue)
        return DBXFilesMoveBatchRpcRequestV2(swift: swift)
    }

    /// Move multiple files or folders to different locations at once in the user's Dropbox. Note that we do not
    /// currently support case-only renaming. This route will replace moveBatch. The main difference is this route
    /// will return status for each entry, while moveBatch raises failure if any entry fails. This route will either
    /// finish synchronously, or return a job ID and do the async move job in background. Please use
    /// moveBatchCheckV2 to check the job status.
    ///
    /// - scope: files.content.write
    ///
    /// - returns: Through the response callback, the caller will receive a `Files.RelocationBatchV2Launch` object on
    /// success or a `Void` object on failure.
    @objc
    @discardableResult public func moveBatchV2(entries: [DBXFilesRelocationPath]) -> DBXFilesMoveBatchRpcRequestV2 {
        let swift = swift.moveBatchV2(entries: entries.map(\.swift))
        return DBXFilesMoveBatchRpcRequestV2(swift: swift)
    }

    /// Returns the status of an asynchronous job for moveBatchV2. It returns list of results for each entry.
    ///
    /// - scope: files.content.write
    ///
    /// - parameter asyncJobId: Id of the asynchronous job. This is the value of a response returned from the method
    /// that launched the job.
    ///
    /// - returns: Through the response callback, the caller will receive a `Files.RelocationBatchV2JobStatus` object on
    /// success or a `Async.PollError` object on failure.
    @objc
    @discardableResult public func moveBatchCheckV2(asyncJobId: String) -> DBXFilesMoveBatchCheckRpcRequestV2 {
        let swift = swift.moveBatchCheckV2(asyncJobId: asyncJobId)
        return DBXFilesMoveBatchCheckRpcRequestV2(swift: swift)
    }

    /// Creates a new Paper doc with the provided content.
    ///
    /// - scope: files.content.write
    ///
    /// - parameter path: The fully qualified path to the location in the user's Dropbox where the Paper Doc should be
    /// created. This should include the document's title and end with .paper.
    /// - parameter importFormat: The format of the provided data.
    /// - parameter input: The file to upload, as an Data object.
    ///
    /// - returns: Through the response callback, the caller will receive a `Files.PaperCreateResult` object on success
    /// or a `Files.PaperCreateError` object on failure.
    @objc
    @discardableResult public func paperCreateData(path: String, importFormat: DBXFilesImportFormat, input: Data) -> DBXFilesPaperCreateUploadRequest {
        let swift = swift.paperCreate(path: path, importFormat: importFormat.swift, input: input)
        return DBXFilesPaperCreateUploadRequest(swift: swift)
    }

    /// Creates a new Paper doc with the provided content.
    ///
    /// - scope: files.content.write
    ///
    /// - parameter path: The fully qualified path to the location in the user's Dropbox where the Paper Doc should be
    /// created. This should include the document's title and end with .paper.
    /// - parameter importFormat: The format of the provided data.
    /// - parameter input: The file to upload, as an URL object.
    ///
    /// - returns: Through the response callback, the caller will receive a `Files.PaperCreateResult` object on success
    /// or a `Files.PaperCreateError` object on failure.
    @objc
    @discardableResult public func paperCreateURL(path: String, importFormat: DBXFilesImportFormat, input: URL) -> DBXFilesPaperCreateUploadRequest {
        let swift = swift.paperCreate(path: path, importFormat: importFormat.swift, input: input)
        return DBXFilesPaperCreateUploadRequest(swift: swift)
    }

    /// Creates a new Paper doc with the provided content.
    ///
    /// - scope: files.content.write
    ///
    /// - parameter path: The fully qualified path to the location in the user's Dropbox where the Paper Doc should be
    /// created. This should include the document's title and end with .paper.
    /// - parameter importFormat: The format of the provided data.
    /// - parameter input: The file to upload, as an InputStream object.
    ///
    /// - returns: Through the response callback, the caller will receive a `Files.PaperCreateResult` object on success
    /// or a `Files.PaperCreateError` object on failure.
    @objc
    @discardableResult public func paperCreateInputStream(
        path: String,
        importFormat: DBXFilesImportFormat,
        input: InputStream
    ) -> DBXFilesPaperCreateUploadRequest {
        let swift = swift.paperCreate(path: path, importFormat: importFormat.swift, input: input)
        return DBXFilesPaperCreateUploadRequest(swift: swift)
    }

    /// Updates an existing Paper doc with the provided content.
    ///
    /// - scope: files.content.write
    ///
    /// - parameter path: Path in the user's Dropbox to update. The path must correspond to a Paper doc or an error will
    /// be returned.
    /// - parameter importFormat: The format of the provided data.
    /// - parameter docUpdatePolicy: How the provided content should be applied to the doc.
    /// - parameter paperRevision: The latest doc revision. Required when doc_update_policy is update. This value must
    /// match the current revision of the doc or error revision_mismatch will be returned.
    /// - parameter input: The file to upload, as an Data object.
    ///
    /// - returns: Through the response callback, the caller will receive a `Files.PaperUpdateResult` object on success
    /// or a `Files.PaperUpdateError` object on failure.
    @objc
    @discardableResult public func paperUpdateData(
        path: String,
        importFormat: DBXFilesImportFormat,
        docUpdatePolicy: DBXFilesPaperDocUpdatePolicy,
        paperRevision: NSNumber?,
        input: Data
    ) -> DBXFilesPaperUpdateUploadRequest {
        let swift = swift.paperUpdate(
            path: path,
            importFormat: importFormat.swift,
            docUpdatePolicy: docUpdatePolicy.swift,
            paperRevision: paperRevision?.int64Value,
            input: input
        )
        return DBXFilesPaperUpdateUploadRequest(swift: swift)
    }

    /// Updates an existing Paper doc with the provided content.
    ///
    /// - scope: files.content.write
    ///
    /// - returns: Through the response callback, the caller will receive a `Files.PaperUpdateResult` object on success
    /// or a `Files.PaperUpdateError` object on failure.
    @objc
    @discardableResult public func paperUpdateData(
        path: String,
        importFormat: DBXFilesImportFormat,
        docUpdatePolicy: DBXFilesPaperDocUpdatePolicy,
        input: Data
    ) -> DBXFilesPaperUpdateUploadRequest {
        let swift = swift.paperUpdate(path: path, importFormat: importFormat.swift, docUpdatePolicy: docUpdatePolicy.swift, input: input)
        return DBXFilesPaperUpdateUploadRequest(swift: swift)
    }

    /// Updates an existing Paper doc with the provided content.
    ///
    /// - scope: files.content.write
    ///
    /// - parameter path: Path in the user's Dropbox to update. The path must correspond to a Paper doc or an error will
    /// be returned.
    /// - parameter importFormat: The format of the provided data.
    /// - parameter docUpdatePolicy: How the provided content should be applied to the doc.
    /// - parameter paperRevision: The latest doc revision. Required when doc_update_policy is update. This value must
    /// match the current revision of the doc or error revision_mismatch will be returned.
    /// - parameter input: The file to upload, as an URL object.
    ///
    /// - returns: Through the response callback, the caller will receive a `Files.PaperUpdateResult` object on success
    /// or a `Files.PaperUpdateError` object on failure.
    @objc
    @discardableResult public func paperUpdateURL(
        path: String,
        importFormat: DBXFilesImportFormat,
        docUpdatePolicy: DBXFilesPaperDocUpdatePolicy,
        paperRevision: NSNumber?,
        input: URL
    ) -> DBXFilesPaperUpdateUploadRequest {
        let swift = swift.paperUpdate(
            path: path,
            importFormat: importFormat.swift,
            docUpdatePolicy: docUpdatePolicy.swift,
            paperRevision: paperRevision?.int64Value,
            input: input
        )
        return DBXFilesPaperUpdateUploadRequest(swift: swift)
    }

    /// Updates an existing Paper doc with the provided content.
    ///
    /// - scope: files.content.write
    ///
    /// - returns: Through the response callback, the caller will receive a `Files.PaperUpdateResult` object on success
    /// or a `Files.PaperUpdateError` object on failure.
    @objc
    @discardableResult public func paperUpdateURL(
        path: String,
        importFormat: DBXFilesImportFormat,
        docUpdatePolicy: DBXFilesPaperDocUpdatePolicy,
        input: URL
    ) -> DBXFilesPaperUpdateUploadRequest {
        let swift = swift.paperUpdate(path: path, importFormat: importFormat.swift, docUpdatePolicy: docUpdatePolicy.swift, input: input)
        return DBXFilesPaperUpdateUploadRequest(swift: swift)
    }

    /// Updates an existing Paper doc with the provided content.
    ///
    /// - scope: files.content.write
    ///
    /// - parameter path: Path in the user's Dropbox to update. The path must correspond to a Paper doc or an error will
    /// be returned.
    /// - parameter importFormat: The format of the provided data.
    /// - parameter docUpdatePolicy: How the provided content should be applied to the doc.
    /// - parameter paperRevision: The latest doc revision. Required when doc_update_policy is update. This value must
    /// match the current revision of the doc or error revision_mismatch will be returned.
    /// - parameter input: The file to upload, as an InputStream object.
    ///
    /// - returns: Through the response callback, the caller will receive a `Files.PaperUpdateResult` object on success
    /// or a `Files.PaperUpdateError` object on failure.
    @objc
    @discardableResult public func paperUpdateInputStream(
        path: String,
        importFormat: DBXFilesImportFormat,
        docUpdatePolicy: DBXFilesPaperDocUpdatePolicy,
        paperRevision: NSNumber?,
        input: InputStream
    ) -> DBXFilesPaperUpdateUploadRequest {
        let swift = swift.paperUpdate(
            path: path,
            importFormat: importFormat.swift,
            docUpdatePolicy: docUpdatePolicy.swift,
            paperRevision: paperRevision?.int64Value,
            input: input
        )
        return DBXFilesPaperUpdateUploadRequest(swift: swift)
    }

    /// Updates an existing Paper doc with the provided content.
    ///
    /// - scope: files.content.write
    ///
    /// - returns: Through the response callback, the caller will receive a `Files.PaperUpdateResult` object on success
    /// or a `Files.PaperUpdateError` object on failure.
    @objc
    @discardableResult public func paperUpdateInputStream(
        path: String,
        importFormat: DBXFilesImportFormat,
        docUpdatePolicy: DBXFilesPaperDocUpdatePolicy,
        input: InputStream
    ) -> DBXFilesPaperUpdateUploadRequest {
        let swift = swift.paperUpdate(path: path, importFormat: importFormat.swift, docUpdatePolicy: docUpdatePolicy.swift, input: input)
        return DBXFilesPaperUpdateUploadRequest(swift: swift)
    }

    /// Permanently delete the file or folder at a given path (see https://www.dropbox.com/en/help/40). If the given
    /// file or folder is not yet deleted, this route will first delete it. It is possible for this route to
    /// successfully delete, then fail to permanently delete. Note: This endpoint is only available for Dropbox
    /// Business apps.
    ///
    /// - scope: files.permanent_delete
    ///
    /// - parameter path: Path in the user's Dropbox to delete.
    /// - parameter parentRev: Perform delete if given "rev" matches the existing file's latest "rev". This field does
    /// not support deleting a folder.
    ///
    /// - returns: Through the response callback, the caller will receive a `Void` object on success or a
    /// `Files.DeleteError` object on failure.
    @objc
    @discardableResult public func permanentlyDelete(path: String, parentRev: String?) -> DBXFilesPermanentlyDeleteRpcRequest {
        let swift = swift.permanentlyDelete(path: path, parentRev: parentRev)
        return DBXFilesPermanentlyDeleteRpcRequest(swift: swift)
    }

    /// Permanently delete the file or folder at a given path (see https://www.dropbox.com/en/help/40). If the given
    /// file or folder is not yet deleted, this route will first delete it. It is possible for this route to
    /// successfully delete, then fail to permanently delete. Note: This endpoint is only available for Dropbox
    /// Business apps.
    ///
    /// - scope: files.permanent_delete
    ///
    /// - returns: Through the response callback, the caller will receive a `Void` object on success or a
    /// `Files.DeleteError` object on failure.
    @objc
    @discardableResult public func permanentlyDelete(path: String) -> DBXFilesPermanentlyDeleteRpcRequest {
        let swift = swift.permanentlyDelete(path: path)
        return DBXFilesPermanentlyDeleteRpcRequest(swift: swift)
    }

    /// Restore a specific revision of a file to the given path.
    ///
    /// - scope: files.content.write
    ///
    /// - parameter path: The path to save the restored file.
    /// - parameter rev: The revision to restore.
    ///
    /// - returns: Through the response callback, the caller will receive a `Files.FileMetadata` object on success or a
    /// `Files.RestoreError` object on failure.
    @objc
    @discardableResult public func restore(path: String, rev: String) -> DBXFilesRestoreRpcRequest {
        let swift = swift.restore(path: path, rev: rev)
        return DBXFilesRestoreRpcRequest(swift: swift)
    }

    /// Save the data from a specified URL into a file in user's Dropbox. Note that the transfer from the URL must
    /// complete within 15 minutes, or the operation will time out and the job will fail. If the given path already
    /// exists, the file will be renamed to avoid the conflict (e.g. myfile (1).txt).
    ///
    /// - scope: files.content.write
    ///
    /// - parameter path: The path in Dropbox where the URL will be saved to.
    /// - parameter url: The URL to be saved.
    ///
    /// - returns: Through the response callback, the caller will receive a `Files.SaveUrlResult` object on success or a
    /// `Files.SaveUrlError` object on failure.
    @objc
    @discardableResult public func saveUrl(path: String, url: String) -> DBXFilesSaveUrlRpcRequest {
        let swift = swift.saveUrl(path: path, url: url)
        return DBXFilesSaveUrlRpcRequest(swift: swift)
    }

    /// Check the status of a saveUrl job.
    ///
    /// - scope: files.content.write
    ///
    /// - parameter asyncJobId: Id of the asynchronous job. This is the value of a response returned from the method
    /// that launched the job.
    ///
    /// - returns: Through the response callback, the caller will receive a `Files.SaveUrlJobStatus` object on success
    /// or a `Async.PollError` object on failure.
    @objc
    @discardableResult public func saveUrlCheckJobStatus(asyncJobId: String) -> DBXFilesSaveUrlCheckJobStatusRpcRequest {
        let swift = swift.saveUrlCheckJobStatus(asyncJobId: asyncJobId)
        return DBXFilesSaveUrlCheckJobStatusRpcRequest(swift: swift)
    }

    /// Searches for files and folders. Note: searchV2 along with searchContinueV2 can only be used to retrieve a
    /// maximum of 10,000 matches. Recent changes may not immediately be reflected in search results due to a short
    /// delay in indexing. Duplicate results may be returned across pages. Some results may not be returned.
    ///
    /// - scope: files.metadata.read
    ///
    /// - parameter query: The string to search for. May match across multiple fields based on the request arguments.
    /// - parameter options: Options for more targeted search results.
    /// - parameter matchFieldOptions: Options for search results match fields.
    /// - parameter includeHighlights: Deprecated and moved this option to SearchMatchFieldOptions.
    ///
    /// - returns: Through the response callback, the caller will receive a `Files.SearchV2Result` object on success or
    /// a `Files.SearchError` object on failure.
    @objc
    @discardableResult public func searchV2(
        query: String,
        options: DBXFilesSearchOptions?,
        matchFieldOptions: DBXFilesSearchMatchFieldOptions?,
        includeHighlights: NSNumber?
    ) -> DBXFilesSearchRpcRequestV2 {
        let swift = swift.searchV2(
            query: query,
            options: options?.swift,
            matchFieldOptions: matchFieldOptions?.swift,
            includeHighlights: includeHighlights?.boolValue
        )
        return DBXFilesSearchRpcRequestV2(swift: swift)
    }

    /// Searches for files and folders. Note: searchV2 along with searchContinueV2 can only be used to retrieve a
    /// maximum of 10,000 matches. Recent changes may not immediately be reflected in search results due to a short
    /// delay in indexing. Duplicate results may be returned across pages. Some results may not be returned.
    ///
    /// - scope: files.metadata.read
    ///
    /// - returns: Through the response callback, the caller will receive a `Files.SearchV2Result` object on success or
    /// a `Files.SearchError` object on failure.
    @objc
    @discardableResult public func searchV2(query: String) -> DBXFilesSearchRpcRequestV2 {
        let swift = swift.searchV2(query: query)
        return DBXFilesSearchRpcRequestV2(swift: swift)
    }

    /// Fetches the next page of search results returned from searchV2. Note: searchV2 along with searchContinueV2 can
    /// only be used to retrieve a maximum of 10,000 matches. Recent changes may not immediately be reflected in
    /// search results due to a short delay in indexing. Duplicate results may be returned across pages. Some
    /// results may not be returned.
    ///
    /// - scope: files.metadata.read
    ///
    /// - parameter cursor: The cursor returned by your last call to searchV2. Used to fetch the next page of results.
    ///
    /// - returns: Through the response callback, the caller will receive a `Files.SearchV2Result` object on success or
    /// a `Files.SearchError` object on failure.
    @objc
    @discardableResult public func searchContinueV2(cursor: String) -> DBXFilesSearchContinueRpcRequestV2 {
        let swift = swift.searchContinueV2(cursor: cursor)
        return DBXFilesSearchContinueRpcRequestV2(swift: swift)
    }

    /// Add a tag to an item. A tag is a string. The strings are automatically converted to lowercase letters. No more
    /// than 20 tags can be added to a given item.
    ///
    /// - scope: files.metadata.write
    ///
    /// - parameter path: Path to the item to be tagged.
    /// - parameter tagText: The value of the tag to add. Will be automatically converted to lowercase letters.
    ///
    /// - returns: Through the response callback, the caller will receive a `Void` object on success or a
    /// `Files.AddTagError` object on failure.
    @objc
    @discardableResult public func tagsAdd(path: String, tagText: String) -> DBXFilesTagsAddRpcRequest {
        let swift = swift.tagsAdd(path: path, tagText: tagText)
        return DBXFilesTagsAddRpcRequest(swift: swift)
    }

    /// Get list of tags assigned to items.
    ///
    /// - scope: files.metadata.read
    ///
    /// - parameter paths: Path to the items.
    ///
    /// - returns: Through the response callback, the caller will receive a `Files.GetTagsResult` object on success or a
    /// `Files.BaseTagError` object on failure.
    @objc
    @discardableResult public func tagsGet(paths: [String]) -> DBXFilesTagsGetRpcRequest {
        let swift = swift.tagsGet(paths: paths)
        return DBXFilesTagsGetRpcRequest(swift: swift)
    }

    /// Remove a tag from an item.
    ///
    /// - scope: files.metadata.write
    ///
    /// - parameter path: Path to the item to tag.
    /// - parameter tagText: The tag to remove. Will be automatically converted to lowercase letters.
    ///
    /// - returns: Through the response callback, the caller will receive a `Void` object on success or a
    /// `Files.RemoveTagError` object on failure.
    @objc
    @discardableResult public func tagsRemove(path: String, tagText: String) -> DBXFilesTagsRemoveRpcRequest {
        let swift = swift.tagsRemove(path: path, tagText: tagText)
        return DBXFilesTagsRemoveRpcRequest(swift: swift)
    }

    /// Unlock the files at the given paths. A locked file can only be unlocked by the lock holder or, if a business
    /// account, a team admin. A successful response indicates that the file has been unlocked. Returns a list of
    /// the unlocked file paths and their metadata after this operation.
    ///
    /// - scope: files.content.write
    ///
    /// - parameter entries: List of 'entries'. Each 'entry' contains a path of the file which will be unlocked.
    /// Duplicate path arguments in the batch are considered only once.
    ///
    /// - returns: Through the response callback, the caller will receive a `Files.LockFileBatchResult` object on
    /// success or a `Files.LockFileError` object on failure.
    @objc
    @discardableResult public func unlockFileBatch(entries: [DBXFilesUnlockFileArg]) -> DBXFilesUnlockFileBatchRpcRequest {
        let swift = swift.unlockFileBatch(entries: entries.map(\.swift))
        return DBXFilesUnlockFileBatchRpcRequest(swift: swift)
    }

    /// Create a new file with the contents provided in the request. Do not use this to upload a file larger than 150
    /// MB. Instead, create an upload session with uploadSessionStart. Calls to this endpoint will count as data
    /// transport calls for any Dropbox Business teams with a limit on the number of data transport calls allowed
    /// per month. For more information, see the Data transport limit page
    /// https://www.dropbox.com/developers/reference/data-transport-limit.
    ///
    /// - scope: files.content.write
    ///
    /// - parameter contentHash: A hash of the file content uploaded in this call. If provided and the uploaded content
    /// does not match this hash, an error will be returned. For more information see our Content hash
    /// https://www.dropbox.com/developers/reference/content-hash page.
    /// - parameter input: The file to upload, as an Data object.
    ///
    /// - returns: Through the response callback, the caller will receive a `Files.FileMetadata` object on success or a
    /// `Files.UploadError` object on failure.
    @objc
    @discardableResult public func uploadData(
        path: String,
        mode: DBXFilesWriteMode,
        autorename: NSNumber,
        clientModified: Date?,
        mute: NSNumber,
        propertyGroups: [DBXFilePropertiesPropertyGroup]?,
        strictConflict: NSNumber,
        contentHash: String?,
        input: Data
    ) -> DBXFilesUploadUploadRequest {
        let swift = swift.upload(
            path: path,
            mode: mode.swift,
            autorename: autorename.boolValue,
            clientModified: clientModified,
            mute: mute.boolValue,
            propertyGroups: propertyGroups?.map(\.swift),
            strictConflict: strictConflict.boolValue,
            contentHash: contentHash,
            input: input
        )
        return DBXFilesUploadUploadRequest(swift: swift)
    }

    /// Create a new file with the contents provided in the request. Do not use this to upload a file larger than 150
    /// MB. Instead, create an upload session with uploadSessionStart. Calls to this endpoint will count as data
    /// transport calls for any Dropbox Business teams with a limit on the number of data transport calls allowed
    /// per month. For more information, see the Data transport limit page
    /// https://www.dropbox.com/developers/reference/data-transport-limit.
    ///
    /// - scope: files.content.write
    ///
    /// - returns: Through the response callback, the caller will receive a `Files.FileMetadata` object on success or a
    /// `Files.UploadError` object on failure.
    @objc
    @discardableResult public func uploadData(path: String, input: Data) -> DBXFilesUploadUploadRequest {
        let swift = swift.upload(path: path, input: input)
        return DBXFilesUploadUploadRequest(swift: swift)
    }

    /// Create a new file with the contents provided in the request. Do not use this to upload a file larger than 150
    /// MB. Instead, create an upload session with uploadSessionStart. Calls to this endpoint will count as data
    /// transport calls for any Dropbox Business teams with a limit on the number of data transport calls allowed
    /// per month. For more information, see the Data transport limit page
    /// https://www.dropbox.com/developers/reference/data-transport-limit.
    ///
    /// - scope: files.content.write
    ///
    /// - parameter contentHash: A hash of the file content uploaded in this call. If provided and the uploaded content
    /// does not match this hash, an error will be returned. For more information see our Content hash
    /// https://www.dropbox.com/developers/reference/content-hash page.
    /// - parameter input: The file to upload, as an URL object.
    ///
    /// - returns: Through the response callback, the caller will receive a `Files.FileMetadata` object on success or a
    /// `Files.UploadError` object on failure.
    @objc
    @discardableResult public func uploadURL(
        path: String,
        mode: DBXFilesWriteMode,
        autorename: NSNumber,
        clientModified: Date?,
        mute: NSNumber,
        propertyGroups: [DBXFilePropertiesPropertyGroup]?,
        strictConflict: NSNumber,
        contentHash: String?,
        input: URL
    ) -> DBXFilesUploadUploadRequest {
        let swift = swift.upload(
            path: path,
            mode: mode.swift,
            autorename: autorename.boolValue,
            clientModified: clientModified,
            mute: mute.boolValue,
            propertyGroups: propertyGroups?.map(\.swift),
            strictConflict: strictConflict.boolValue,
            contentHash: contentHash,
            input: input
        )
        return DBXFilesUploadUploadRequest(swift: swift)
    }

    /// Create a new file with the contents provided in the request. Do not use this to upload a file larger than 150
    /// MB. Instead, create an upload session with uploadSessionStart. Calls to this endpoint will count as data
    /// transport calls for any Dropbox Business teams with a limit on the number of data transport calls allowed
    /// per month. For more information, see the Data transport limit page
    /// https://www.dropbox.com/developers/reference/data-transport-limit.
    ///
    /// - scope: files.content.write
    ///
    /// - returns: Through the response callback, the caller will receive a `Files.FileMetadata` object on success or a
    /// `Files.UploadError` object on failure.
    @objc
    @discardableResult public func uploadURL(path: String, input: URL) -> DBXFilesUploadUploadRequest {
        let swift = swift.upload(path: path, input: input)
        return DBXFilesUploadUploadRequest(swift: swift)
    }

    /// Create a new file with the contents provided in the request. Do not use this to upload a file larger than 150
    /// MB. Instead, create an upload session with uploadSessionStart. Calls to this endpoint will count as data
    /// transport calls for any Dropbox Business teams with a limit on the number of data transport calls allowed
    /// per month. For more information, see the Data transport limit page
    /// https://www.dropbox.com/developers/reference/data-transport-limit.
    ///
    /// - scope: files.content.write
    ///
    /// - parameter contentHash: A hash of the file content uploaded in this call. If provided and the uploaded content
    /// does not match this hash, an error will be returned. For more information see our Content hash
    /// https://www.dropbox.com/developers/reference/content-hash page.
    /// - parameter input: The file to upload, as an InputStream object.
    ///
    /// - returns: Through the response callback, the caller will receive a `Files.FileMetadata` object on success or a
    /// `Files.UploadError` object on failure.
    @objc
    @discardableResult public func uploadInputStream(
        path: String,
        mode: DBXFilesWriteMode,
        autorename: NSNumber,
        clientModified: Date?,
        mute: NSNumber,
        propertyGroups: [DBXFilePropertiesPropertyGroup]?,
        strictConflict: NSNumber,
        contentHash: String?,
        input: InputStream
    ) -> DBXFilesUploadUploadRequest {
        let swift = swift.upload(
            path: path,
            mode: mode.swift,
            autorename: autorename.boolValue,
            clientModified: clientModified,
            mute: mute.boolValue,
            propertyGroups: propertyGroups?.map(\.swift),
            strictConflict: strictConflict.boolValue,
            contentHash: contentHash,
            input: input
        )
        return DBXFilesUploadUploadRequest(swift: swift)
    }

    /// Create a new file with the contents provided in the request. Do not use this to upload a file larger than 150
    /// MB. Instead, create an upload session with uploadSessionStart. Calls to this endpoint will count as data
    /// transport calls for any Dropbox Business teams with a limit on the number of data transport calls allowed
    /// per month. For more information, see the Data transport limit page
    /// https://www.dropbox.com/developers/reference/data-transport-limit.
    ///
    /// - scope: files.content.write
    ///
    /// - returns: Through the response callback, the caller will receive a `Files.FileMetadata` object on success or a
    /// `Files.UploadError` object on failure.
    @objc
    @discardableResult public func uploadInputStream(path: String, input: InputStream) -> DBXFilesUploadUploadRequest {
        let swift = swift.upload(path: path, input: input)
        return DBXFilesUploadUploadRequest(swift: swift)
    }

    /// Append more data to an upload session. When the parameter close is set, this call will close the session. A
    /// single request should not upload more than 150 MB. The maximum size of a file one can upload to an upload
    /// session is 350 GB. Calls to this endpoint will count as data transport calls for any Dropbox Business teams
    /// with a limit on the number of data transport calls allowed per month. For more information, see the Data
    /// transport limit page https://www.dropbox.com/developers/reference/data-transport-limit.
    ///
    /// - scope: files.content.write
    ///
    /// - parameter cursor: Contains the upload session ID and the offset.
    /// - parameter close: If true, the current session will be closed, at which point you won't be able to call
    /// uploadSessionAppendV2 anymore with the current session.
    /// - parameter contentHash: A hash of the file content uploaded in this call. If provided and the uploaded content
    /// does not match this hash, an error will be returned. For more information see our Content hash
    /// https://www.dropbox.com/developers/reference/content-hash page.
    /// - parameter input: The file to upload, as an Data object.
    ///
    /// - returns: Through the response callback, the caller will receive a `Void` object on success or a
    /// `Files.UploadSessionAppendError` object on failure.
    @objc
    @discardableResult public func uploadSessionAppendV2Data(
        cursor: DBXFilesUploadSessionCursor,
        close: NSNumber,
        contentHash: String?,
        input: Data
    ) -> DBXFilesUploadSessionAppendUploadRequestV2 {
        let swift = swift.uploadSessionAppendV2(cursor: cursor.swift, close: close.boolValue, contentHash: contentHash, input: input)
        return DBXFilesUploadSessionAppendUploadRequestV2(swift: swift)
    }

    /// Append more data to an upload session. When the parameter close is set, this call will close the session. A
    /// single request should not upload more than 150 MB. The maximum size of a file one can upload to an upload
    /// session is 350 GB. Calls to this endpoint will count as data transport calls for any Dropbox Business teams
    /// with a limit on the number of data transport calls allowed per month. For more information, see the Data
    /// transport limit page https://www.dropbox.com/developers/reference/data-transport-limit.
    ///
    /// - scope: files.content.write
    ///
    /// - returns: Through the response callback, the caller will receive a `Void` object on success or a
    /// `Files.UploadSessionAppendError` object on failure.
    @objc
    @discardableResult public func uploadSessionAppendV2Data(cursor: DBXFilesUploadSessionCursor, input: Data) -> DBXFilesUploadSessionAppendUploadRequestV2 {
        let swift = swift.uploadSessionAppendV2(cursor: cursor.swift, input: input)
        return DBXFilesUploadSessionAppendUploadRequestV2(swift: swift)
    }

    /// Append more data to an upload session. When the parameter close is set, this call will close the session. A
    /// single request should not upload more than 150 MB. The maximum size of a file one can upload to an upload
    /// session is 350 GB. Calls to this endpoint will count as data transport calls for any Dropbox Business teams
    /// with a limit on the number of data transport calls allowed per month. For more information, see the Data
    /// transport limit page https://www.dropbox.com/developers/reference/data-transport-limit.
    ///
    /// - scope: files.content.write
    ///
    /// - parameter cursor: Contains the upload session ID and the offset.
    /// - parameter close: If true, the current session will be closed, at which point you won't be able to call
    /// uploadSessionAppendV2 anymore with the current session.
    /// - parameter contentHash: A hash of the file content uploaded in this call. If provided and the uploaded content
    /// does not match this hash, an error will be returned. For more information see our Content hash
    /// https://www.dropbox.com/developers/reference/content-hash page.
    /// - parameter input: The file to upload, as an URL object.
    ///
    /// - returns: Through the response callback, the caller will receive a `Void` object on success or a
    /// `Files.UploadSessionAppendError` object on failure.
    @objc
    @discardableResult public func uploadSessionAppendV2URL(
        cursor: DBXFilesUploadSessionCursor,
        close: NSNumber,
        contentHash: String?,
        input: URL
    ) -> DBXFilesUploadSessionAppendUploadRequestV2 {
        let swift = swift.uploadSessionAppendV2(cursor: cursor.swift, close: close.boolValue, contentHash: contentHash, input: input)
        return DBXFilesUploadSessionAppendUploadRequestV2(swift: swift)
    }

    /// Append more data to an upload session. When the parameter close is set, this call will close the session. A
    /// single request should not upload more than 150 MB. The maximum size of a file one can upload to an upload
    /// session is 350 GB. Calls to this endpoint will count as data transport calls for any Dropbox Business teams
    /// with a limit on the number of data transport calls allowed per month. For more information, see the Data
    /// transport limit page https://www.dropbox.com/developers/reference/data-transport-limit.
    ///
    /// - scope: files.content.write
    ///
    /// - returns: Through the response callback, the caller will receive a `Void` object on success or a
    /// `Files.UploadSessionAppendError` object on failure.
    @objc
    @discardableResult public func uploadSessionAppendV2URL(cursor: DBXFilesUploadSessionCursor, input: URL) -> DBXFilesUploadSessionAppendUploadRequestV2 {
        let swift = swift.uploadSessionAppendV2(cursor: cursor.swift, input: input)
        return DBXFilesUploadSessionAppendUploadRequestV2(swift: swift)
    }

    /// Append more data to an upload session. When the parameter close is set, this call will close the session. A
    /// single request should not upload more than 150 MB. The maximum size of a file one can upload to an upload
    /// session is 350 GB. Calls to this endpoint will count as data transport calls for any Dropbox Business teams
    /// with a limit on the number of data transport calls allowed per month. For more information, see the Data
    /// transport limit page https://www.dropbox.com/developers/reference/data-transport-limit.
    ///
    /// - scope: files.content.write
    ///
    /// - parameter cursor: Contains the upload session ID and the offset.
    /// - parameter close: If true, the current session will be closed, at which point you won't be able to call
    /// uploadSessionAppendV2 anymore with the current session.
    /// - parameter contentHash: A hash of the file content uploaded in this call. If provided and the uploaded content
    /// does not match this hash, an error will be returned. For more information see our Content hash
    /// https://www.dropbox.com/developers/reference/content-hash page.
    /// - parameter input: The file to upload, as an InputStream object.
    ///
    /// - returns: Through the response callback, the caller will receive a `Void` object on success or a
    /// `Files.UploadSessionAppendError` object on failure.
    @objc
    @discardableResult public func uploadSessionAppendV2InputStream(
        cursor: DBXFilesUploadSessionCursor,
        close: NSNumber,
        contentHash: String?,
        input: InputStream
    ) -> DBXFilesUploadSessionAppendUploadRequestV2 {
        let swift = swift.uploadSessionAppendV2(cursor: cursor.swift, close: close.boolValue, contentHash: contentHash, input: input)
        return DBXFilesUploadSessionAppendUploadRequestV2(swift: swift)
    }

    /// Append more data to an upload session. When the parameter close is set, this call will close the session. A
    /// single request should not upload more than 150 MB. The maximum size of a file one can upload to an upload
    /// session is 350 GB. Calls to this endpoint will count as data transport calls for any Dropbox Business teams
    /// with a limit on the number of data transport calls allowed per month. For more information, see the Data
    /// transport limit page https://www.dropbox.com/developers/reference/data-transport-limit.
    ///
    /// - scope: files.content.write
    ///
    /// - returns: Through the response callback, the caller will receive a `Void` object on success or a
    /// `Files.UploadSessionAppendError` object on failure.
    @objc
    @discardableResult public func uploadSessionAppendV2InputStream(
        cursor: DBXFilesUploadSessionCursor,
        input: InputStream
    ) -> DBXFilesUploadSessionAppendUploadRequestV2 {
        let swift = swift.uploadSessionAppendV2(cursor: cursor.swift, input: input)
        return DBXFilesUploadSessionAppendUploadRequestV2(swift: swift)
    }

    /// Finish an upload session and save the uploaded data to the given file path. A single request should not upload
    /// more than 150 MB. The maximum size of a file one can upload to an upload session is 350 GB. Calls to this
    /// endpoint will count as data transport calls for any Dropbox Business teams with a limit on the number of
    /// data transport calls allowed per month. For more information, see the Data transport limit page
    /// https://www.dropbox.com/developers/reference/data-transport-limit.
    ///
    /// - scope: files.content.write
    ///
    /// - parameter cursor: Contains the upload session ID and the offset.
    /// - parameter commit: Contains the path and other optional modifiers for the commit.
    /// - parameter contentHash: A hash of the file content uploaded in this call. If provided and the uploaded content
    /// does not match this hash, an error will be returned. For more information see our Content hash
    /// https://www.dropbox.com/developers/reference/content-hash page.
    /// - parameter input: The file to upload, as an Data object.
    ///
    /// - returns: Through the response callback, the caller will receive a `Files.FileMetadata` object on success or a
    /// `Files.UploadSessionFinishError` object on failure.
    @objc
    @discardableResult public func uploadSessionFinishData(
        cursor: DBXFilesUploadSessionCursor,
        commit: DBXFilesCommitInfo,
        contentHash: String?,
        input: Data
    ) -> DBXFilesUploadSessionFinishUploadRequest {
        let swift = swift.uploadSessionFinish(cursor: cursor.swift, commit: commit.swift, contentHash: contentHash, input: input)
        return DBXFilesUploadSessionFinishUploadRequest(swift: swift)
    }

    /// Finish an upload session and save the uploaded data to the given file path. A single request should not upload
    /// more than 150 MB. The maximum size of a file one can upload to an upload session is 350 GB. Calls to this
    /// endpoint will count as data transport calls for any Dropbox Business teams with a limit on the number of
    /// data transport calls allowed per month. For more information, see the Data transport limit page
    /// https://www.dropbox.com/developers/reference/data-transport-limit.
    ///
    /// - scope: files.content.write
    ///
    /// - returns: Through the response callback, the caller will receive a `Files.FileMetadata` object on success or a
    /// `Files.UploadSessionFinishError` object on failure.
    @objc
    @discardableResult public func uploadSessionFinishData(
        cursor: DBXFilesUploadSessionCursor,
        commit: DBXFilesCommitInfo,
        input: Data
    ) -> DBXFilesUploadSessionFinishUploadRequest {
        let swift = swift.uploadSessionFinish(cursor: cursor.swift, commit: commit.swift, input: input)
        return DBXFilesUploadSessionFinishUploadRequest(swift: swift)
    }

    /// Finish an upload session and save the uploaded data to the given file path. A single request should not upload
    /// more than 150 MB. The maximum size of a file one can upload to an upload session is 350 GB. Calls to this
    /// endpoint will count as data transport calls for any Dropbox Business teams with a limit on the number of
    /// data transport calls allowed per month. For more information, see the Data transport limit page
    /// https://www.dropbox.com/developers/reference/data-transport-limit.
    ///
    /// - scope: files.content.write
    ///
    /// - parameter cursor: Contains the upload session ID and the offset.
    /// - parameter commit: Contains the path and other optional modifiers for the commit.
    /// - parameter contentHash: A hash of the file content uploaded in this call. If provided and the uploaded content
    /// does not match this hash, an error will be returned. For more information see our Content hash
    /// https://www.dropbox.com/developers/reference/content-hash page.
    /// - parameter input: The file to upload, as an URL object.
    ///
    /// - returns: Through the response callback, the caller will receive a `Files.FileMetadata` object on success or a
    /// `Files.UploadSessionFinishError` object on failure.
    @objc
    @discardableResult public func uploadSessionFinishURL(
        cursor: DBXFilesUploadSessionCursor,
        commit: DBXFilesCommitInfo,
        contentHash: String?,
        input: URL
    ) -> DBXFilesUploadSessionFinishUploadRequest {
        let swift = swift.uploadSessionFinish(cursor: cursor.swift, commit: commit.swift, contentHash: contentHash, input: input)
        return DBXFilesUploadSessionFinishUploadRequest(swift: swift)
    }

    /// Finish an upload session and save the uploaded data to the given file path. A single request should not upload
    /// more than 150 MB. The maximum size of a file one can upload to an upload session is 350 GB. Calls to this
    /// endpoint will count as data transport calls for any Dropbox Business teams with a limit on the number of
    /// data transport calls allowed per month. For more information, see the Data transport limit page
    /// https://www.dropbox.com/developers/reference/data-transport-limit.
    ///
    /// - scope: files.content.write
    ///
    /// - returns: Through the response callback, the caller will receive a `Files.FileMetadata` object on success or a
    /// `Files.UploadSessionFinishError` object on failure.
    @objc
    @discardableResult public func uploadSessionFinishURL(
        cursor: DBXFilesUploadSessionCursor,
        commit: DBXFilesCommitInfo,
        input: URL
    ) -> DBXFilesUploadSessionFinishUploadRequest {
        let swift = swift.uploadSessionFinish(cursor: cursor.swift, commit: commit.swift, input: input)
        return DBXFilesUploadSessionFinishUploadRequest(swift: swift)
    }

    /// Finish an upload session and save the uploaded data to the given file path. A single request should not upload
    /// more than 150 MB. The maximum size of a file one can upload to an upload session is 350 GB. Calls to this
    /// endpoint will count as data transport calls for any Dropbox Business teams with a limit on the number of
    /// data transport calls allowed per month. For more information, see the Data transport limit page
    /// https://www.dropbox.com/developers/reference/data-transport-limit.
    ///
    /// - scope: files.content.write
    ///
    /// - parameter cursor: Contains the upload session ID and the offset.
    /// - parameter commit: Contains the path and other optional modifiers for the commit.
    /// - parameter contentHash: A hash of the file content uploaded in this call. If provided and the uploaded content
    /// does not match this hash, an error will be returned. For more information see our Content hash
    /// https://www.dropbox.com/developers/reference/content-hash page.
    /// - parameter input: The file to upload, as an InputStream object.
    ///
    /// - returns: Through the response callback, the caller will receive a `Files.FileMetadata` object on success or a
    /// `Files.UploadSessionFinishError` object on failure.
    @objc
    @discardableResult public func uploadSessionFinishInputStream(
        cursor: DBXFilesUploadSessionCursor,
        commit: DBXFilesCommitInfo,
        contentHash: String?,
        input: InputStream
    ) -> DBXFilesUploadSessionFinishUploadRequest {
        let swift = swift.uploadSessionFinish(cursor: cursor.swift, commit: commit.swift, contentHash: contentHash, input: input)
        return DBXFilesUploadSessionFinishUploadRequest(swift: swift)
    }

    /// Finish an upload session and save the uploaded data to the given file path. A single request should not upload
    /// more than 150 MB. The maximum size of a file one can upload to an upload session is 350 GB. Calls to this
    /// endpoint will count as data transport calls for any Dropbox Business teams with a limit on the number of
    /// data transport calls allowed per month. For more information, see the Data transport limit page
    /// https://www.dropbox.com/developers/reference/data-transport-limit.
    ///
    /// - scope: files.content.write
    ///
    /// - returns: Through the response callback, the caller will receive a `Files.FileMetadata` object on success or a
    /// `Files.UploadSessionFinishError` object on failure.
    @objc
    @discardableResult public func uploadSessionFinishInputStream(
        cursor: DBXFilesUploadSessionCursor,
        commit: DBXFilesCommitInfo,
        input: InputStream
    ) -> DBXFilesUploadSessionFinishUploadRequest {
        let swift = swift.uploadSessionFinish(cursor: cursor.swift, commit: commit.swift, input: input)
        return DBXFilesUploadSessionFinishUploadRequest(swift: swift)
    }

    /// This route helps you commit many files at once into a user's Dropbox. Use uploadSessionStart and
    /// uploadSessionAppendV2 to upload file contents. We recommend uploading many files in parallel to increase
    /// throughput. Once the file contents have been uploaded, rather than calling uploadSessionFinish, use this
    /// route to finish all your upload sessions in a single request. close in UploadSessionStartArg or close in
    /// UploadSessionAppendArg needs to be true for the last uploadSessionStart or uploadSessionAppendV2 call of
    /// each upload session. The maximum size of a file one can upload to an upload session is 350 GB. We allow up
    /// to 1000 entries in a single request. Calls to this endpoint will count as data transport calls for any
    /// Dropbox Business teams with a limit on the number of data transport calls allowed per month. For more
    /// information, see the Data transport limit page
    /// https://www.dropbox.com/developers/reference/data-transport-limit.
    ///
    /// - scope: files.content.write
    ///
    /// - parameter entries: Commit information for each file in the batch.
    ///
    /// - returns: Through the response callback, the caller will receive a `Files.UploadSessionFinishBatchResult`
    /// object on success or a `Void` object on failure.
    @objc
    @discardableResult public func uploadSessionFinishBatchV2(entries: [DBXFilesUploadSessionFinishArg]) -> DBXFilesUploadSessionFinishBatchRpcRequestV2 {
        let swift = swift.uploadSessionFinishBatchV2(entries: entries.map(\.swift))
        return DBXFilesUploadSessionFinishBatchRpcRequestV2(swift: swift)
    }

    /// Returns the status of an asynchronous job for uploadSessionFinishBatch. If success, it returns list of result
    /// for each entry.
    ///
    /// - scope: files.content.write
    ///
    /// - parameter asyncJobId: Id of the asynchronous job. This is the value of a response returned from the method
    /// that launched the job.
    ///
    /// - returns: Through the response callback, the caller will receive a `Files.UploadSessionFinishBatchJobStatus`
    /// object on success or a `Async.PollError` object on failure.
    @objc
    @discardableResult public func uploadSessionFinishBatchCheck(asyncJobId: String) -> DBXFilesUploadSessionFinishBatchCheckRpcRequest {
        let swift = swift.uploadSessionFinishBatchCheck(asyncJobId: asyncJobId)
        return DBXFilesUploadSessionFinishBatchCheckRpcRequest(swift: swift)
    }

    /// Upload sessions allow you to upload a single file in one or more requests, for example where the size of the
    /// file is greater than 150 MB.  This call starts a new upload session with the given data. You can then use
    /// uploadSessionAppendV2 to add more data and uploadSessionFinish to save all the data to a file in Dropbox. A
    /// single request should not upload more than 150 MB. The maximum size of a file one can upload to an upload
    /// session is 350 GB. An upload session can be used for a maximum of 7 days. Attempting to use an sessionId in
    /// UploadSessionStartResult with uploadSessionAppendV2 or uploadSessionFinish more than 7 days after its
    /// creation will return a notFound in UploadSessionLookupError. Calls to this endpoint will count as data
    /// transport calls for any Dropbox Business teams with a limit on the number of data transport calls allowed
    /// per month. For more information, see the Data transport limit page
    /// https://www.dropbox.com/developers/reference/data-transport-limit. By default, upload sessions require you
    /// to send content of the file in sequential order via consecutive uploadSessionStart, uploadSessionAppendV2,
    /// uploadSessionFinish calls. For better performance, you can instead optionally use a concurrent in
    /// UploadSessionType upload session. To start a new concurrent session, set sessionType in
    /// UploadSessionStartArg to concurrent in UploadSessionType. After that, you can send file data in concurrent
    /// uploadSessionAppendV2 requests. Finally finish the session with uploadSessionFinish. There are couple of
    /// constraints with concurrent sessions to make them work. You can not send data with uploadSessionStart or
    /// uploadSessionFinish call, only with uploadSessionAppendV2 call. Also data uploaded in uploadSessionAppendV2
    /// call must be multiple of 4194304 bytes (except for last uploadSessionAppendV2 with close in
    /// UploadSessionStartArg to true, that may contain any remaining data).
    ///
    /// - scope: files.content.write
    ///
    /// - parameter close: If true, the current session will be closed, at which point you won't be able to call
    /// uploadSessionAppendV2 anymore with the current session.
    /// - parameter sessionType: Type of upload session you want to start. If not specified, default is sequential in
    /// UploadSessionType.
    /// - parameter contentHash: A hash of the file content uploaded in this call. If provided and the uploaded content
    /// does not match this hash, an error will be returned. For more information see our Content hash
    /// https://www.dropbox.com/developers/reference/content-hash page.
    /// - parameter input: The file to upload, as an Data object.
    ///
    /// - returns: Through the response callback, the caller will receive a `Files.UploadSessionStartResult` object on
    /// success or a `Files.UploadSessionStartError` object on failure.
    @objc
    @discardableResult public func uploadSessionStartData(
        close: NSNumber,
        sessionType: DBXFilesUploadSessionType?,
        contentHash: String?,
        input: Data
    ) -> DBXFilesUploadSessionStartUploadRequest {
        let swift = swift.uploadSessionStart(close: close.boolValue, sessionType: sessionType?.swift, contentHash: contentHash, input: input)
        return DBXFilesUploadSessionStartUploadRequest(swift: swift)
    }

    /// Upload sessions allow you to upload a single file in one or more requests, for example where the size of the
    /// file is greater than 150 MB.  This call starts a new upload session with the given data. You can then use
    /// uploadSessionAppendV2 to add more data and uploadSessionFinish to save all the data to a file in Dropbox. A
    /// single request should not upload more than 150 MB. The maximum size of a file one can upload to an upload
    /// session is 350 GB. An upload session can be used for a maximum of 7 days. Attempting to use an sessionId in
    /// UploadSessionStartResult with uploadSessionAppendV2 or uploadSessionFinish more than 7 days after its
    /// creation will return a notFound in UploadSessionLookupError. Calls to this endpoint will count as data
    /// transport calls for any Dropbox Business teams with a limit on the number of data transport calls allowed
    /// per month. For more information, see the Data transport limit page
    /// https://www.dropbox.com/developers/reference/data-transport-limit. By default, upload sessions require you
    /// to send content of the file in sequential order via consecutive uploadSessionStart, uploadSessionAppendV2,
    /// uploadSessionFinish calls. For better performance, you can instead optionally use a concurrent in
    /// UploadSessionType upload session. To start a new concurrent session, set sessionType in
    /// UploadSessionStartArg to concurrent in UploadSessionType. After that, you can send file data in concurrent
    /// uploadSessionAppendV2 requests. Finally finish the session with uploadSessionFinish. There are couple of
    /// constraints with concurrent sessions to make them work. You can not send data with uploadSessionStart or
    /// uploadSessionFinish call, only with uploadSessionAppendV2 call. Also data uploaded in uploadSessionAppendV2
    /// call must be multiple of 4194304 bytes (except for last uploadSessionAppendV2 with close in
    /// UploadSessionStartArg to true, that may contain any remaining data).
    ///
    /// - scope: files.content.write
    ///
    /// - returns: Through the response callback, the caller will receive a `Files.UploadSessionStartResult` object on
    /// success or a `Files.UploadSessionStartError` object on failure.
    @objc
    @discardableResult public func uploadSessionStartData(input: Data) -> DBXFilesUploadSessionStartUploadRequest {
        let swift = swift.uploadSessionStart(input: input)
        return DBXFilesUploadSessionStartUploadRequest(swift: swift)
    }

    /// Upload sessions allow you to upload a single file in one or more requests, for example where the size of the
    /// file is greater than 150 MB.  This call starts a new upload session with the given data. You can then use
    /// uploadSessionAppendV2 to add more data and uploadSessionFinish to save all the data to a file in Dropbox. A
    /// single request should not upload more than 150 MB. The maximum size of a file one can upload to an upload
    /// session is 350 GB. An upload session can be used for a maximum of 7 days. Attempting to use an sessionId in
    /// UploadSessionStartResult with uploadSessionAppendV2 or uploadSessionFinish more than 7 days after its
    /// creation will return a notFound in UploadSessionLookupError. Calls to this endpoint will count as data
    /// transport calls for any Dropbox Business teams with a limit on the number of data transport calls allowed
    /// per month. For more information, see the Data transport limit page
    /// https://www.dropbox.com/developers/reference/data-transport-limit. By default, upload sessions require you
    /// to send content of the file in sequential order via consecutive uploadSessionStart, uploadSessionAppendV2,
    /// uploadSessionFinish calls. For better performance, you can instead optionally use a concurrent in
    /// UploadSessionType upload session. To start a new concurrent session, set sessionType in
    /// UploadSessionStartArg to concurrent in UploadSessionType. After that, you can send file data in concurrent
    /// uploadSessionAppendV2 requests. Finally finish the session with uploadSessionFinish. There are couple of
    /// constraints with concurrent sessions to make them work. You can not send data with uploadSessionStart or
    /// uploadSessionFinish call, only with uploadSessionAppendV2 call. Also data uploaded in uploadSessionAppendV2
    /// call must be multiple of 4194304 bytes (except for last uploadSessionAppendV2 with close in
    /// UploadSessionStartArg to true, that may contain any remaining data).
    ///
    /// - scope: files.content.write
    ///
    /// - parameter close: If true, the current session will be closed, at which point you won't be able to call
    /// uploadSessionAppendV2 anymore with the current session.
    /// - parameter sessionType: Type of upload session you want to start. If not specified, default is sequential in
    /// UploadSessionType.
    /// - parameter contentHash: A hash of the file content uploaded in this call. If provided and the uploaded content
    /// does not match this hash, an error will be returned. For more information see our Content hash
    /// https://www.dropbox.com/developers/reference/content-hash page.
    /// - parameter input: The file to upload, as an URL object.
    ///
    /// - returns: Through the response callback, the caller will receive a `Files.UploadSessionStartResult` object on
    /// success or a `Files.UploadSessionStartError` object on failure.
    @objc
    @discardableResult public func uploadSessionStartURL(
        close: NSNumber,
        sessionType: DBXFilesUploadSessionType?,
        contentHash: String?,
        input: URL
    ) -> DBXFilesUploadSessionStartUploadRequest {
        let swift = swift.uploadSessionStart(close: close.boolValue, sessionType: sessionType?.swift, contentHash: contentHash, input: input)
        return DBXFilesUploadSessionStartUploadRequest(swift: swift)
    }

    /// Upload sessions allow you to upload a single file in one or more requests, for example where the size of the
    /// file is greater than 150 MB.  This call starts a new upload session with the given data. You can then use
    /// uploadSessionAppendV2 to add more data and uploadSessionFinish to save all the data to a file in Dropbox. A
    /// single request should not upload more than 150 MB. The maximum size of a file one can upload to an upload
    /// session is 350 GB. An upload session can be used for a maximum of 7 days. Attempting to use an sessionId in
    /// UploadSessionStartResult with uploadSessionAppendV2 or uploadSessionFinish more than 7 days after its
    /// creation will return a notFound in UploadSessionLookupError. Calls to this endpoint will count as data
    /// transport calls for any Dropbox Business teams with a limit on the number of data transport calls allowed
    /// per month. For more information, see the Data transport limit page
    /// https://www.dropbox.com/developers/reference/data-transport-limit. By default, upload sessions require you
    /// to send content of the file in sequential order via consecutive uploadSessionStart, uploadSessionAppendV2,
    /// uploadSessionFinish calls. For better performance, you can instead optionally use a concurrent in
    /// UploadSessionType upload session. To start a new concurrent session, set sessionType in
    /// UploadSessionStartArg to concurrent in UploadSessionType. After that, you can send file data in concurrent
    /// uploadSessionAppendV2 requests. Finally finish the session with uploadSessionFinish. There are couple of
    /// constraints with concurrent sessions to make them work. You can not send data with uploadSessionStart or
    /// uploadSessionFinish call, only with uploadSessionAppendV2 call. Also data uploaded in uploadSessionAppendV2
    /// call must be multiple of 4194304 bytes (except for last uploadSessionAppendV2 with close in
    /// UploadSessionStartArg to true, that may contain any remaining data).
    ///
    /// - scope: files.content.write
    ///
    /// - returns: Through the response callback, the caller will receive a `Files.UploadSessionStartResult` object on
    /// success or a `Files.UploadSessionStartError` object on failure.
    @objc
    @discardableResult public func uploadSessionStartURL(input: URL) -> DBXFilesUploadSessionStartUploadRequest {
        let swift = swift.uploadSessionStart(input: input)
        return DBXFilesUploadSessionStartUploadRequest(swift: swift)
    }

    /// Upload sessions allow you to upload a single file in one or more requests, for example where the size of the
    /// file is greater than 150 MB.  This call starts a new upload session with the given data. You can then use
    /// uploadSessionAppendV2 to add more data and uploadSessionFinish to save all the data to a file in Dropbox. A
    /// single request should not upload more than 150 MB. The maximum size of a file one can upload to an upload
    /// session is 350 GB. An upload session can be used for a maximum of 7 days. Attempting to use an sessionId in
    /// UploadSessionStartResult with uploadSessionAppendV2 or uploadSessionFinish more than 7 days after its
    /// creation will return a notFound in UploadSessionLookupError. Calls to this endpoint will count as data
    /// transport calls for any Dropbox Business teams with a limit on the number of data transport calls allowed
    /// per month. For more information, see the Data transport limit page
    /// https://www.dropbox.com/developers/reference/data-transport-limit. By default, upload sessions require you
    /// to send content of the file in sequential order via consecutive uploadSessionStart, uploadSessionAppendV2,
    /// uploadSessionFinish calls. For better performance, you can instead optionally use a concurrent in
    /// UploadSessionType upload session. To start a new concurrent session, set sessionType in
    /// UploadSessionStartArg to concurrent in UploadSessionType. After that, you can send file data in concurrent
    /// uploadSessionAppendV2 requests. Finally finish the session with uploadSessionFinish. There are couple of
    /// constraints with concurrent sessions to make them work. You can not send data with uploadSessionStart or
    /// uploadSessionFinish call, only with uploadSessionAppendV2 call. Also data uploaded in uploadSessionAppendV2
    /// call must be multiple of 4194304 bytes (except for last uploadSessionAppendV2 with close in
    /// UploadSessionStartArg to true, that may contain any remaining data).
    ///
    /// - scope: files.content.write
    ///
    /// - parameter close: If true, the current session will be closed, at which point you won't be able to call
    /// uploadSessionAppendV2 anymore with the current session.
    /// - parameter sessionType: Type of upload session you want to start. If not specified, default is sequential in
    /// UploadSessionType.
    /// - parameter contentHash: A hash of the file content uploaded in this call. If provided and the uploaded content
    /// does not match this hash, an error will be returned. For more information see our Content hash
    /// https://www.dropbox.com/developers/reference/content-hash page.
    /// - parameter input: The file to upload, as an InputStream object.
    ///
    /// - returns: Through the response callback, the caller will receive a `Files.UploadSessionStartResult` object on
    /// success or a `Files.UploadSessionStartError` object on failure.
    @objc
    @discardableResult public func uploadSessionStartInputStream(
        close: NSNumber,
        sessionType: DBXFilesUploadSessionType?,
        contentHash: String?,
        input: InputStream
    ) -> DBXFilesUploadSessionStartUploadRequest {
        let swift = swift.uploadSessionStart(close: close.boolValue, sessionType: sessionType?.swift, contentHash: contentHash, input: input)
        return DBXFilesUploadSessionStartUploadRequest(swift: swift)
    }

    /// Upload sessions allow you to upload a single file in one or more requests, for example where the size of the
    /// file is greater than 150 MB.  This call starts a new upload session with the given data. You can then use
    /// uploadSessionAppendV2 to add more data and uploadSessionFinish to save all the data to a file in Dropbox. A
    /// single request should not upload more than 150 MB. The maximum size of a file one can upload to an upload
    /// session is 350 GB. An upload session can be used for a maximum of 7 days. Attempting to use an sessionId in
    /// UploadSessionStartResult with uploadSessionAppendV2 or uploadSessionFinish more than 7 days after its
    /// creation will return a notFound in UploadSessionLookupError. Calls to this endpoint will count as data
    /// transport calls for any Dropbox Business teams with a limit on the number of data transport calls allowed
    /// per month. For more information, see the Data transport limit page
    /// https://www.dropbox.com/developers/reference/data-transport-limit. By default, upload sessions require you
    /// to send content of the file in sequential order via consecutive uploadSessionStart, uploadSessionAppendV2,
    /// uploadSessionFinish calls. For better performance, you can instead optionally use a concurrent in
    /// UploadSessionType upload session. To start a new concurrent session, set sessionType in
    /// UploadSessionStartArg to concurrent in UploadSessionType. After that, you can send file data in concurrent
    /// uploadSessionAppendV2 requests. Finally finish the session with uploadSessionFinish. There are couple of
    /// constraints with concurrent sessions to make them work. You can not send data with uploadSessionStart or
    /// uploadSessionFinish call, only with uploadSessionAppendV2 call. Also data uploaded in uploadSessionAppendV2
    /// call must be multiple of 4194304 bytes (except for last uploadSessionAppendV2 with close in
    /// UploadSessionStartArg to true, that may contain any remaining data).
    ///
    /// - scope: files.content.write
    ///
    /// - returns: Through the response callback, the caller will receive a `Files.UploadSessionStartResult` object on
    /// success or a `Files.UploadSessionStartError` object on failure.
    @objc
    @discardableResult public func uploadSessionStartInputStream(input: InputStream) -> DBXFilesUploadSessionStartUploadRequest {
        let swift = swift.uploadSessionStart(input: input)
        return DBXFilesUploadSessionStartUploadRequest(swift: swift)
    }

    /// This route starts batch of upload_sessions. Please refer to `upload_session/start` usage. Calls to this endpoint
    /// will count as data transport calls for any Dropbox Business teams with a limit on the number of data
    /// transport calls allowed per month. For more information, see the Data transport limit page
    /// https://www.dropbox.com/developers/reference/data-transport-limit.
    ///
    /// - scope: files.content.write
    ///
    /// - parameter sessionType: Type of upload session you want to start. If not specified, default is sequential in
    /// UploadSessionType.
    /// - parameter numSessions: The number of upload sessions to start.
    ///
    /// - returns: Through the response callback, the caller will receive a `Files.UploadSessionStartBatchResult` object
    /// on success or a `Void` object on failure.
    @objc
    @discardableResult public func uploadSessionStartBatch(
        numSessions: NSNumber,
        sessionType: DBXFilesUploadSessionType?
    ) -> DBXFilesUploadSessionStartBatchRpcRequest {
        let swift = swift.uploadSessionStartBatch(numSessions: numSessions.uint64Value, sessionType: sessionType?.swift)
        return DBXFilesUploadSessionStartBatchRpcRequest(swift: swift)
    }

    /// This route starts batch of upload_sessions. Please refer to `upload_session/start` usage. Calls to this endpoint
    /// will count as data transport calls for any Dropbox Business teams with a limit on the number of data
    /// transport calls allowed per month. For more information, see the Data transport limit page
    /// https://www.dropbox.com/developers/reference/data-transport-limit.
    ///
    /// - scope: files.content.write
    ///
    /// - returns: Through the response callback, the caller will receive a `Files.UploadSessionStartBatchResult` object
    /// on success or a `Void` object on failure.
    @objc
    @discardableResult public func uploadSessionStartBatch(numSessions: NSNumber) -> DBXFilesUploadSessionStartBatchRpcRequest {
        let swift = swift.uploadSessionStartBatch(numSessions: numSessions.uint64Value)
        return DBXFilesUploadSessionStartBatchRpcRequest(swift: swift)
    }
}

@objc
public class DBXFilesAlphaGetMetadataRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Files.MetadataSerializer, Files.AlphaGetMetadataErrorSerializer>

    init(swift: RpcRequest<Files.MetadataSerializer, Files.AlphaGetMetadataErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXFilesMetadata?, DBXFilesAlphaGetMetadataError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXFilesMetadata?, DBXFilesAlphaGetMetadataError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXFilesAlphaGetMetadataError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXFilesAlphaGetMetadataError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXFilesMetadata?
            if let swift = result {
                objc = DBXFilesMetadata.wrapPreservingSubtypes(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXFilesAlphaUploadUploadRequest: NSObject, DBXRequest {
    var swift: UploadRequest<Files.FileMetadataSerializer, Files.UploadErrorSerializer>

    init(swift: UploadRequest<Files.FileMetadataSerializer, Files.UploadErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXFilesFileMetadata?, DBXFilesUploadError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXFilesFileMetadata?, DBXFilesUploadError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXFilesUploadError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXFilesUploadError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXFilesFileMetadata?
            if let swift = result {
                objc = DBXFilesFileMetadata(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public func progress(_ progressHandler: @escaping ((Progress) -> Void)) -> Self {
        swift.progress(progressHandler)
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXFilesCopyRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Files.MetadataSerializer, Files.RelocationErrorSerializer>

    init(swift: RpcRequest<Files.MetadataSerializer, Files.RelocationErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXFilesMetadata?, DBXFilesRelocationError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXFilesMetadata?, DBXFilesRelocationError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXFilesRelocationError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXFilesRelocationError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXFilesMetadata?
            if let swift = result {
                objc = DBXFilesMetadata.wrapPreservingSubtypes(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXFilesCopyRpcRequestV2: NSObject, DBXRequest {
    var swift: RpcRequest<Files.RelocationResultSerializer, Files.RelocationErrorSerializer>

    init(swift: RpcRequest<Files.RelocationResultSerializer, Files.RelocationErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXFilesRelocationResult?, DBXFilesRelocationError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXFilesRelocationResult?, DBXFilesRelocationError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXFilesRelocationError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXFilesRelocationError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXFilesRelocationResult?
            if let swift = result {
                objc = DBXFilesRelocationResult(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXFilesCopyBatchRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Files.RelocationBatchLaunchSerializer, VoidSerializer>

    init(swift: RpcRequest<Files.RelocationBatchLaunchSerializer, VoidSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXFilesRelocationBatchLaunch?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXFilesRelocationBatchLaunch?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var objc: DBXFilesRelocationBatchLaunch?
            if let swift = result {
                objc = DBXFilesRelocationBatchLaunch.factory(swift: swift)
            }
            completionHandler(objc, error?.objc)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXFilesCopyBatchRpcRequestV2: NSObject, DBXRequest {
    var swift: RpcRequest<Files.RelocationBatchV2LaunchSerializer, VoidSerializer>

    init(swift: RpcRequest<Files.RelocationBatchV2LaunchSerializer, VoidSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXFilesRelocationBatchV2Launch?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXFilesRelocationBatchV2Launch?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var objc: DBXFilesRelocationBatchV2Launch?
            if let swift = result {
                objc = DBXFilesRelocationBatchV2Launch.factory(swift: swift)
            }
            completionHandler(objc, error?.objc)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXFilesCopyBatchCheckRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Files.RelocationBatchJobStatusSerializer, Async.PollErrorSerializer>

    init(swift: RpcRequest<Files.RelocationBatchJobStatusSerializer, Async.PollErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXFilesRelocationBatchJobStatus?, DBXAsyncPollError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXFilesRelocationBatchJobStatus?, DBXAsyncPollError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXAsyncPollError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXAsyncPollError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXFilesRelocationBatchJobStatus?
            if let swift = result {
                objc = DBXFilesRelocationBatchJobStatus.factory(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXFilesCopyBatchCheckRpcRequestV2: NSObject, DBXRequest {
    var swift: RpcRequest<Files.RelocationBatchV2JobStatusSerializer, Async.PollErrorSerializer>

    init(swift: RpcRequest<Files.RelocationBatchV2JobStatusSerializer, Async.PollErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXFilesRelocationBatchV2JobStatus?, DBXAsyncPollError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXFilesRelocationBatchV2JobStatus?, DBXAsyncPollError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXAsyncPollError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXAsyncPollError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXFilesRelocationBatchV2JobStatus?
            if let swift = result {
                objc = DBXFilesRelocationBatchV2JobStatus.factory(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXFilesCopyReferenceGetRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Files.GetCopyReferenceResultSerializer, Files.GetCopyReferenceErrorSerializer>

    init(swift: RpcRequest<Files.GetCopyReferenceResultSerializer, Files.GetCopyReferenceErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXFilesGetCopyReferenceResult?, DBXFilesGetCopyReferenceError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXFilesGetCopyReferenceResult?, DBXFilesGetCopyReferenceError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXFilesGetCopyReferenceError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXFilesGetCopyReferenceError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXFilesGetCopyReferenceResult?
            if let swift = result {
                objc = DBXFilesGetCopyReferenceResult(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXFilesCopyReferenceSaveRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Files.SaveCopyReferenceResultSerializer, Files.SaveCopyReferenceErrorSerializer>

    init(swift: RpcRequest<Files.SaveCopyReferenceResultSerializer, Files.SaveCopyReferenceErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXFilesSaveCopyReferenceResult?, DBXFilesSaveCopyReferenceError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXFilesSaveCopyReferenceResult?, DBXFilesSaveCopyReferenceError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXFilesSaveCopyReferenceError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXFilesSaveCopyReferenceError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXFilesSaveCopyReferenceResult?
            if let swift = result {
                objc = DBXFilesSaveCopyReferenceResult(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXFilesCreateFolderRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Files.FolderMetadataSerializer, Files.CreateFolderErrorSerializer>

    init(swift: RpcRequest<Files.FolderMetadataSerializer, Files.CreateFolderErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXFilesFolderMetadata?, DBXFilesCreateFolderError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXFilesFolderMetadata?, DBXFilesCreateFolderError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXFilesCreateFolderError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXFilesCreateFolderError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXFilesFolderMetadata?
            if let swift = result {
                objc = DBXFilesFolderMetadata(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXFilesCreateFolderRpcRequestV2: NSObject, DBXRequest {
    var swift: RpcRequest<Files.CreateFolderResultSerializer, Files.CreateFolderErrorSerializer>

    init(swift: RpcRequest<Files.CreateFolderResultSerializer, Files.CreateFolderErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXFilesCreateFolderResult?, DBXFilesCreateFolderError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXFilesCreateFolderResult?, DBXFilesCreateFolderError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXFilesCreateFolderError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXFilesCreateFolderError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXFilesCreateFolderResult?
            if let swift = result {
                objc = DBXFilesCreateFolderResult(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXFilesCreateFolderBatchRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Files.CreateFolderBatchLaunchSerializer, VoidSerializer>

    init(swift: RpcRequest<Files.CreateFolderBatchLaunchSerializer, VoidSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXFilesCreateFolderBatchLaunch?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXFilesCreateFolderBatchLaunch?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var objc: DBXFilesCreateFolderBatchLaunch?
            if let swift = result {
                objc = DBXFilesCreateFolderBatchLaunch.factory(swift: swift)
            }
            completionHandler(objc, error?.objc)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXFilesCreateFolderBatchCheckRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Files.CreateFolderBatchJobStatusSerializer, Async.PollErrorSerializer>

    init(swift: RpcRequest<Files.CreateFolderBatchJobStatusSerializer, Async.PollErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXFilesCreateFolderBatchJobStatus?, DBXAsyncPollError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXFilesCreateFolderBatchJobStatus?, DBXAsyncPollError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXAsyncPollError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXAsyncPollError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXFilesCreateFolderBatchJobStatus?
            if let swift = result {
                objc = DBXFilesCreateFolderBatchJobStatus.factory(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXFilesDeleteRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Files.MetadataSerializer, Files.DeleteErrorSerializer>

    init(swift: RpcRequest<Files.MetadataSerializer, Files.DeleteErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXFilesMetadata?, DBXFilesDeleteError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXFilesMetadata?, DBXFilesDeleteError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXFilesDeleteError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXFilesDeleteError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXFilesMetadata?
            if let swift = result {
                objc = DBXFilesMetadata.wrapPreservingSubtypes(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXFilesDeleteRpcRequestV2: NSObject, DBXRequest {
    var swift: RpcRequest<Files.DeleteResultSerializer, Files.DeleteErrorSerializer>

    init(swift: RpcRequest<Files.DeleteResultSerializer, Files.DeleteErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXFilesDeleteResult?, DBXFilesDeleteError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXFilesDeleteResult?, DBXFilesDeleteError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXFilesDeleteError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXFilesDeleteError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXFilesDeleteResult?
            if let swift = result {
                objc = DBXFilesDeleteResult(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXFilesDeleteBatchRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Files.DeleteBatchLaunchSerializer, VoidSerializer>

    init(swift: RpcRequest<Files.DeleteBatchLaunchSerializer, VoidSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXFilesDeleteBatchLaunch?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXFilesDeleteBatchLaunch?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var objc: DBXFilesDeleteBatchLaunch?
            if let swift = result {
                objc = DBXFilesDeleteBatchLaunch.factory(swift: swift)
            }
            completionHandler(objc, error?.objc)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXFilesDeleteBatchCheckRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Files.DeleteBatchJobStatusSerializer, Async.PollErrorSerializer>

    init(swift: RpcRequest<Files.DeleteBatchJobStatusSerializer, Async.PollErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXFilesDeleteBatchJobStatus?, DBXAsyncPollError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXFilesDeleteBatchJobStatus?, DBXAsyncPollError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXAsyncPollError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXAsyncPollError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXFilesDeleteBatchJobStatus?
            if let swift = result {
                objc = DBXFilesDeleteBatchJobStatus.factory(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXFilesDownloadDownloadRequestFile: NSObject, DBXRequest {
    var swift: DownloadRequestFile<Files.FileMetadataSerializer, Files.DownloadErrorSerializer>

    init(swift: DownloadRequestFile<Files.FileMetadataSerializer, Files.DownloadErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXFilesFileMetadata?, URL?, DBXFilesDownloadError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXFilesFileMetadata?, URL?, DBXFilesDownloadError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXFilesDownloadError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXFilesDownloadError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXFilesFileMetadata?
            var destination: URL?
            if let swift = result {
                objc = DBXFilesFileMetadata(swift: swift.0)
                destination = swift.1
            }
            completionHandler(objc, destination, routeError, callError)
        }
        return self
    }

    @objc
    public func progress(_ progressHandler: @escaping ((Progress) -> Void)) -> Self {
        swift.progress(progressHandler)
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXFilesDownloadDownloadRequestMemory: NSObject, DBXRequest {
    var swift: DownloadRequestMemory<Files.FileMetadataSerializer, Files.DownloadErrorSerializer>

    init(swift: DownloadRequestMemory<Files.FileMetadataSerializer, Files.DownloadErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXFilesFileMetadata?, Data?, DBXFilesDownloadError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXFilesFileMetadata?, Data?, DBXFilesDownloadError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXFilesDownloadError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXFilesDownloadError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXFilesFileMetadata?
            var destination: Data?
            if let swift = result {
                objc = DBXFilesFileMetadata(swift: swift.0)
                destination = swift.1
            }
            completionHandler(objc, destination, routeError, callError)
        }
        return self
    }

    @objc
    public func progress(_ progressHandler: @escaping ((Progress) -> Void)) -> Self {
        swift.progress(progressHandler)
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXFilesDownloadZipDownloadRequestFile: NSObject, DBXRequest {
    var swift: DownloadRequestFile<Files.DownloadZipResultSerializer, Files.DownloadZipErrorSerializer>

    init(swift: DownloadRequestFile<Files.DownloadZipResultSerializer, Files.DownloadZipErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXFilesDownloadZipResult?, URL?, DBXFilesDownloadZipError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXFilesDownloadZipResult?, URL?, DBXFilesDownloadZipError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXFilesDownloadZipError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXFilesDownloadZipError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXFilesDownloadZipResult?
            var destination: URL?
            if let swift = result {
                objc = DBXFilesDownloadZipResult(swift: swift.0)
                destination = swift.1
            }
            completionHandler(objc, destination, routeError, callError)
        }
        return self
    }

    @objc
    public func progress(_ progressHandler: @escaping ((Progress) -> Void)) -> Self {
        swift.progress(progressHandler)
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXFilesDownloadZipDownloadRequestMemory: NSObject, DBXRequest {
    var swift: DownloadRequestMemory<Files.DownloadZipResultSerializer, Files.DownloadZipErrorSerializer>

    init(swift: DownloadRequestMemory<Files.DownloadZipResultSerializer, Files.DownloadZipErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXFilesDownloadZipResult?, Data?, DBXFilesDownloadZipError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXFilesDownloadZipResult?, Data?, DBXFilesDownloadZipError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXFilesDownloadZipError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXFilesDownloadZipError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXFilesDownloadZipResult?
            var destination: Data?
            if let swift = result {
                objc = DBXFilesDownloadZipResult(swift: swift.0)
                destination = swift.1
            }
            completionHandler(objc, destination, routeError, callError)
        }
        return self
    }

    @objc
    public func progress(_ progressHandler: @escaping ((Progress) -> Void)) -> Self {
        swift.progress(progressHandler)
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXFilesExportDownloadRequestFile: NSObject, DBXRequest {
    var swift: DownloadRequestFile<Files.ExportResultSerializer, Files.ExportErrorSerializer>

    init(swift: DownloadRequestFile<Files.ExportResultSerializer, Files.ExportErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXFilesExportResult?, URL?, DBXFilesExportError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXFilesExportResult?, URL?, DBXFilesExportError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXFilesExportError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXFilesExportError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXFilesExportResult?
            var destination: URL?
            if let swift = result {
                objc = DBXFilesExportResult(swift: swift.0)
                destination = swift.1
            }
            completionHandler(objc, destination, routeError, callError)
        }
        return self
    }

    @objc
    public func progress(_ progressHandler: @escaping ((Progress) -> Void)) -> Self {
        swift.progress(progressHandler)
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXFilesExportDownloadRequestMemory: NSObject, DBXRequest {
    var swift: DownloadRequestMemory<Files.ExportResultSerializer, Files.ExportErrorSerializer>

    init(swift: DownloadRequestMemory<Files.ExportResultSerializer, Files.ExportErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXFilesExportResult?, Data?, DBXFilesExportError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXFilesExportResult?, Data?, DBXFilesExportError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXFilesExportError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXFilesExportError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXFilesExportResult?
            var destination: Data?
            if let swift = result {
                objc = DBXFilesExportResult(swift: swift.0)
                destination = swift.1
            }
            completionHandler(objc, destination, routeError, callError)
        }
        return self
    }

    @objc
    public func progress(_ progressHandler: @escaping ((Progress) -> Void)) -> Self {
        swift.progress(progressHandler)
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXFilesGetFileLockBatchRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Files.LockFileBatchResultSerializer, Files.LockFileErrorSerializer>

    init(swift: RpcRequest<Files.LockFileBatchResultSerializer, Files.LockFileErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXFilesLockFileBatchResult?, DBXFilesLockFileError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXFilesLockFileBatchResult?, DBXFilesLockFileError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXFilesLockFileError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXFilesLockFileError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXFilesLockFileBatchResult?
            if let swift = result {
                objc = DBXFilesLockFileBatchResult(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXFilesGetMetadataRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Files.MetadataSerializer, Files.GetMetadataErrorSerializer>

    init(swift: RpcRequest<Files.MetadataSerializer, Files.GetMetadataErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXFilesMetadata?, DBXFilesGetMetadataError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXFilesMetadata?, DBXFilesGetMetadataError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXFilesGetMetadataError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXFilesGetMetadataError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXFilesMetadata?
            if let swift = result {
                objc = DBXFilesMetadata.wrapPreservingSubtypes(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXFilesGetPreviewDownloadRequestFile: NSObject, DBXRequest {
    var swift: DownloadRequestFile<Files.FileMetadataSerializer, Files.PreviewErrorSerializer>

    init(swift: DownloadRequestFile<Files.FileMetadataSerializer, Files.PreviewErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXFilesFileMetadata?, URL?, DBXFilesPreviewError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXFilesFileMetadata?, URL?, DBXFilesPreviewError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXFilesPreviewError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXFilesPreviewError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXFilesFileMetadata?
            var destination: URL?
            if let swift = result {
                objc = DBXFilesFileMetadata(swift: swift.0)
                destination = swift.1
            }
            completionHandler(objc, destination, routeError, callError)
        }
        return self
    }

    @objc
    public func progress(_ progressHandler: @escaping ((Progress) -> Void)) -> Self {
        swift.progress(progressHandler)
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXFilesGetPreviewDownloadRequestMemory: NSObject, DBXRequest {
    var swift: DownloadRequestMemory<Files.FileMetadataSerializer, Files.PreviewErrorSerializer>

    init(swift: DownloadRequestMemory<Files.FileMetadataSerializer, Files.PreviewErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXFilesFileMetadata?, Data?, DBXFilesPreviewError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXFilesFileMetadata?, Data?, DBXFilesPreviewError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXFilesPreviewError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXFilesPreviewError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXFilesFileMetadata?
            var destination: Data?
            if let swift = result {
                objc = DBXFilesFileMetadata(swift: swift.0)
                destination = swift.1
            }
            completionHandler(objc, destination, routeError, callError)
        }
        return self
    }

    @objc
    public func progress(_ progressHandler: @escaping ((Progress) -> Void)) -> Self {
        swift.progress(progressHandler)
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXFilesGetTemporaryLinkRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Files.GetTemporaryLinkResultSerializer, Files.GetTemporaryLinkErrorSerializer>

    init(swift: RpcRequest<Files.GetTemporaryLinkResultSerializer, Files.GetTemporaryLinkErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXFilesGetTemporaryLinkResult?, DBXFilesGetTemporaryLinkError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXFilesGetTemporaryLinkResult?, DBXFilesGetTemporaryLinkError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXFilesGetTemporaryLinkError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXFilesGetTemporaryLinkError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXFilesGetTemporaryLinkResult?
            if let swift = result {
                objc = DBXFilesGetTemporaryLinkResult(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXFilesGetTemporaryUploadLinkRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Files.GetTemporaryUploadLinkResultSerializer, VoidSerializer>

    init(swift: RpcRequest<Files.GetTemporaryUploadLinkResultSerializer, VoidSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXFilesGetTemporaryUploadLinkResult?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXFilesGetTemporaryUploadLinkResult?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var objc: DBXFilesGetTemporaryUploadLinkResult?
            if let swift = result {
                objc = DBXFilesGetTemporaryUploadLinkResult(swift: swift)
            }
            completionHandler(objc, error?.objc)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXFilesGetThumbnailDownloadRequestFile: NSObject, DBXRequest {
    var swift: DownloadRequestFile<Files.FileMetadataSerializer, Files.ThumbnailErrorSerializer>

    init(swift: DownloadRequestFile<Files.FileMetadataSerializer, Files.ThumbnailErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXFilesFileMetadata?, URL?, DBXFilesThumbnailError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXFilesFileMetadata?, URL?, DBXFilesThumbnailError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXFilesThumbnailError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXFilesThumbnailError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXFilesFileMetadata?
            var destination: URL?
            if let swift = result {
                objc = DBXFilesFileMetadata(swift: swift.0)
                destination = swift.1
            }
            completionHandler(objc, destination, routeError, callError)
        }
        return self
    }

    @objc
    public func progress(_ progressHandler: @escaping ((Progress) -> Void)) -> Self {
        swift.progress(progressHandler)
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXFilesGetThumbnailDownloadRequestMemory: NSObject, DBXRequest {
    var swift: DownloadRequestMemory<Files.FileMetadataSerializer, Files.ThumbnailErrorSerializer>

    init(swift: DownloadRequestMemory<Files.FileMetadataSerializer, Files.ThumbnailErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXFilesFileMetadata?, Data?, DBXFilesThumbnailError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXFilesFileMetadata?, Data?, DBXFilesThumbnailError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXFilesThumbnailError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXFilesThumbnailError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXFilesFileMetadata?
            var destination: Data?
            if let swift = result {
                objc = DBXFilesFileMetadata(swift: swift.0)
                destination = swift.1
            }
            completionHandler(objc, destination, routeError, callError)
        }
        return self
    }

    @objc
    public func progress(_ progressHandler: @escaping ((Progress) -> Void)) -> Self {
        swift.progress(progressHandler)
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXFilesGetThumbnailDownloadRequestFileV2: NSObject, DBXRequest {
    var swift: DownloadRequestFile<Files.PreviewResultSerializer, Files.ThumbnailV2ErrorSerializer>

    init(swift: DownloadRequestFile<Files.PreviewResultSerializer, Files.ThumbnailV2ErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXFilesPreviewResult?, URL?, DBXFilesThumbnailV2Error?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXFilesPreviewResult?, URL?, DBXFilesThumbnailV2Error?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXFilesThumbnailV2Error?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXFilesThumbnailV2Error(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXFilesPreviewResult?
            var destination: URL?
            if let swift = result {
                objc = DBXFilesPreviewResult(swift: swift.0)
                destination = swift.1
            }
            completionHandler(objc, destination, routeError, callError)
        }
        return self
    }

    @objc
    public func progress(_ progressHandler: @escaping ((Progress) -> Void)) -> Self {
        swift.progress(progressHandler)
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXFilesGetThumbnailDownloadRequestMemoryV2: NSObject, DBXRequest {
    var swift: DownloadRequestMemory<Files.PreviewResultSerializer, Files.ThumbnailV2ErrorSerializer>

    init(swift: DownloadRequestMemory<Files.PreviewResultSerializer, Files.ThumbnailV2ErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXFilesPreviewResult?, Data?, DBXFilesThumbnailV2Error?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXFilesPreviewResult?, Data?, DBXFilesThumbnailV2Error?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXFilesThumbnailV2Error?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXFilesThumbnailV2Error(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXFilesPreviewResult?
            var destination: Data?
            if let swift = result {
                objc = DBXFilesPreviewResult(swift: swift.0)
                destination = swift.1
            }
            completionHandler(objc, destination, routeError, callError)
        }
        return self
    }

    @objc
    public func progress(_ progressHandler: @escaping ((Progress) -> Void)) -> Self {
        swift.progress(progressHandler)
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXFilesGetThumbnailBatchRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Files.GetThumbnailBatchResultSerializer, Files.GetThumbnailBatchErrorSerializer>

    init(swift: RpcRequest<Files.GetThumbnailBatchResultSerializer, Files.GetThumbnailBatchErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXFilesGetThumbnailBatchResult?, DBXFilesGetThumbnailBatchError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXFilesGetThumbnailBatchResult?, DBXFilesGetThumbnailBatchError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXFilesGetThumbnailBatchError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXFilesGetThumbnailBatchError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXFilesGetThumbnailBatchResult?
            if let swift = result {
                objc = DBXFilesGetThumbnailBatchResult(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXFilesListFolderRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Files.ListFolderResultSerializer, Files.ListFolderErrorSerializer>

    init(swift: RpcRequest<Files.ListFolderResultSerializer, Files.ListFolderErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXFilesListFolderResult?, DBXFilesListFolderError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXFilesListFolderResult?, DBXFilesListFolderError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXFilesListFolderError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXFilesListFolderError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXFilesListFolderResult?
            if let swift = result {
                objc = DBXFilesListFolderResult(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXFilesListFolderContinueRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Files.ListFolderResultSerializer, Files.ListFolderContinueErrorSerializer>

    init(swift: RpcRequest<Files.ListFolderResultSerializer, Files.ListFolderContinueErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXFilesListFolderResult?, DBXFilesListFolderContinueError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXFilesListFolderResult?, DBXFilesListFolderContinueError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXFilesListFolderContinueError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXFilesListFolderContinueError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXFilesListFolderResult?
            if let swift = result {
                objc = DBXFilesListFolderResult(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXFilesListFolderGetLatestCursorRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Files.ListFolderGetLatestCursorResultSerializer, Files.ListFolderErrorSerializer>

    init(swift: RpcRequest<Files.ListFolderGetLatestCursorResultSerializer, Files.ListFolderErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXFilesListFolderGetLatestCursorResult?, DBXFilesListFolderError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXFilesListFolderGetLatestCursorResult?, DBXFilesListFolderError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXFilesListFolderError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXFilesListFolderError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXFilesListFolderGetLatestCursorResult?
            if let swift = result {
                objc = DBXFilesListFolderGetLatestCursorResult(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXFilesListFolderLongpollRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Files.ListFolderLongpollResultSerializer, Files.ListFolderLongpollErrorSerializer>

    init(swift: RpcRequest<Files.ListFolderLongpollResultSerializer, Files.ListFolderLongpollErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXFilesListFolderLongpollResult?, DBXFilesListFolderLongpollError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXFilesListFolderLongpollResult?, DBXFilesListFolderLongpollError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXFilesListFolderLongpollError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXFilesListFolderLongpollError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXFilesListFolderLongpollResult?
            if let swift = result {
                objc = DBXFilesListFolderLongpollResult(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXFilesListRevisionsRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Files.ListRevisionsResultSerializer, Files.ListRevisionsErrorSerializer>

    init(swift: RpcRequest<Files.ListRevisionsResultSerializer, Files.ListRevisionsErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXFilesListRevisionsResult?, DBXFilesListRevisionsError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXFilesListRevisionsResult?, DBXFilesListRevisionsError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXFilesListRevisionsError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXFilesListRevisionsError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXFilesListRevisionsResult?
            if let swift = result {
                objc = DBXFilesListRevisionsResult(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXFilesLockFileBatchRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Files.LockFileBatchResultSerializer, Files.LockFileErrorSerializer>

    init(swift: RpcRequest<Files.LockFileBatchResultSerializer, Files.LockFileErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXFilesLockFileBatchResult?, DBXFilesLockFileError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXFilesLockFileBatchResult?, DBXFilesLockFileError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXFilesLockFileError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXFilesLockFileError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXFilesLockFileBatchResult?
            if let swift = result {
                objc = DBXFilesLockFileBatchResult(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXFilesMoveRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Files.MetadataSerializer, Files.RelocationErrorSerializer>

    init(swift: RpcRequest<Files.MetadataSerializer, Files.RelocationErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXFilesMetadata?, DBXFilesRelocationError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXFilesMetadata?, DBXFilesRelocationError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXFilesRelocationError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXFilesRelocationError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXFilesMetadata?
            if let swift = result {
                objc = DBXFilesMetadata.wrapPreservingSubtypes(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXFilesMoveRpcRequestV2: NSObject, DBXRequest {
    var swift: RpcRequest<Files.RelocationResultSerializer, Files.RelocationErrorSerializer>

    init(swift: RpcRequest<Files.RelocationResultSerializer, Files.RelocationErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXFilesRelocationResult?, DBXFilesRelocationError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXFilesRelocationResult?, DBXFilesRelocationError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXFilesRelocationError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXFilesRelocationError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXFilesRelocationResult?
            if let swift = result {
                objc = DBXFilesRelocationResult(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXFilesMoveBatchRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Files.RelocationBatchLaunchSerializer, VoidSerializer>

    init(swift: RpcRequest<Files.RelocationBatchLaunchSerializer, VoidSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXFilesRelocationBatchLaunch?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXFilesRelocationBatchLaunch?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var objc: DBXFilesRelocationBatchLaunch?
            if let swift = result {
                objc = DBXFilesRelocationBatchLaunch.factory(swift: swift)
            }
            completionHandler(objc, error?.objc)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXFilesMoveBatchRpcRequestV2: NSObject, DBXRequest {
    var swift: RpcRequest<Files.RelocationBatchV2LaunchSerializer, VoidSerializer>

    init(swift: RpcRequest<Files.RelocationBatchV2LaunchSerializer, VoidSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXFilesRelocationBatchV2Launch?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXFilesRelocationBatchV2Launch?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var objc: DBXFilesRelocationBatchV2Launch?
            if let swift = result {
                objc = DBXFilesRelocationBatchV2Launch.factory(swift: swift)
            }
            completionHandler(objc, error?.objc)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXFilesMoveBatchCheckRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Files.RelocationBatchJobStatusSerializer, Async.PollErrorSerializer>

    init(swift: RpcRequest<Files.RelocationBatchJobStatusSerializer, Async.PollErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXFilesRelocationBatchJobStatus?, DBXAsyncPollError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXFilesRelocationBatchJobStatus?, DBXAsyncPollError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXAsyncPollError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXAsyncPollError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXFilesRelocationBatchJobStatus?
            if let swift = result {
                objc = DBXFilesRelocationBatchJobStatus.factory(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXFilesMoveBatchCheckRpcRequestV2: NSObject, DBXRequest {
    var swift: RpcRequest<Files.RelocationBatchV2JobStatusSerializer, Async.PollErrorSerializer>

    init(swift: RpcRequest<Files.RelocationBatchV2JobStatusSerializer, Async.PollErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXFilesRelocationBatchV2JobStatus?, DBXAsyncPollError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXFilesRelocationBatchV2JobStatus?, DBXAsyncPollError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXAsyncPollError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXAsyncPollError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXFilesRelocationBatchV2JobStatus?
            if let swift = result {
                objc = DBXFilesRelocationBatchV2JobStatus.factory(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXFilesPaperCreateUploadRequest: NSObject, DBXRequest {
    var swift: UploadRequest<Files.PaperCreateResultSerializer, Files.PaperCreateErrorSerializer>

    init(swift: UploadRequest<Files.PaperCreateResultSerializer, Files.PaperCreateErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXFilesPaperCreateResult?, DBXFilesPaperCreateError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXFilesPaperCreateResult?, DBXFilesPaperCreateError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXFilesPaperCreateError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXFilesPaperCreateError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXFilesPaperCreateResult?
            if let swift = result {
                objc = DBXFilesPaperCreateResult(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public func progress(_ progressHandler: @escaping ((Progress) -> Void)) -> Self {
        swift.progress(progressHandler)
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXFilesPaperUpdateUploadRequest: NSObject, DBXRequest {
    var swift: UploadRequest<Files.PaperUpdateResultSerializer, Files.PaperUpdateErrorSerializer>

    init(swift: UploadRequest<Files.PaperUpdateResultSerializer, Files.PaperUpdateErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXFilesPaperUpdateResult?, DBXFilesPaperUpdateError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXFilesPaperUpdateResult?, DBXFilesPaperUpdateError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXFilesPaperUpdateError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXFilesPaperUpdateError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXFilesPaperUpdateResult?
            if let swift = result {
                objc = DBXFilesPaperUpdateResult(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public func progress(_ progressHandler: @escaping ((Progress) -> Void)) -> Self {
        swift.progress(progressHandler)
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXFilesPermanentlyDeleteRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<VoidSerializer, Files.DeleteErrorSerializer>

    init(swift: RpcRequest<VoidSerializer, Files.DeleteErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXFilesDeleteError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXFilesDeleteError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { _, error in
            var routeError: DBXFilesDeleteError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXFilesDeleteError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            completionHandler(routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXFilesPropertiesAddRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<VoidSerializer, FileProperties.AddPropertiesErrorSerializer>

    init(swift: RpcRequest<VoidSerializer, FileProperties.AddPropertiesErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXFilePropertiesAddPropertiesError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXFilePropertiesAddPropertiesError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { _, error in
            var routeError: DBXFilePropertiesAddPropertiesError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXFilePropertiesAddPropertiesError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            completionHandler(routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXFilesPropertiesOverwriteRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<VoidSerializer, FileProperties.InvalidPropertyGroupErrorSerializer>

    init(swift: RpcRequest<VoidSerializer, FileProperties.InvalidPropertyGroupErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXFilePropertiesInvalidPropertyGroupError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXFilePropertiesInvalidPropertyGroupError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { _, error in
            var routeError: DBXFilePropertiesInvalidPropertyGroupError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXFilePropertiesInvalidPropertyGroupError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            completionHandler(routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXFilesPropertiesRemoveRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<VoidSerializer, FileProperties.RemovePropertiesErrorSerializer>

    init(swift: RpcRequest<VoidSerializer, FileProperties.RemovePropertiesErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXFilePropertiesRemovePropertiesError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXFilePropertiesRemovePropertiesError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { _, error in
            var routeError: DBXFilePropertiesRemovePropertiesError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXFilePropertiesRemovePropertiesError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            completionHandler(routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXFilesPropertiesTemplateGetRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<FileProperties.GetTemplateResultSerializer, FileProperties.TemplateErrorSerializer>

    init(swift: RpcRequest<FileProperties.GetTemplateResultSerializer, FileProperties.TemplateErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXFilePropertiesGetTemplateResult?, DBXFilePropertiesTemplateError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXFilePropertiesGetTemplateResult?, DBXFilePropertiesTemplateError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXFilePropertiesTemplateError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXFilePropertiesTemplateError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXFilePropertiesGetTemplateResult?
            if let swift = result {
                objc = DBXFilePropertiesGetTemplateResult(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXFilesPropertiesTemplateListRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<FileProperties.ListTemplateResultSerializer, FileProperties.TemplateErrorSerializer>

    init(swift: RpcRequest<FileProperties.ListTemplateResultSerializer, FileProperties.TemplateErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXFilePropertiesListTemplateResult?, DBXFilePropertiesTemplateError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXFilePropertiesListTemplateResult?, DBXFilePropertiesTemplateError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXFilePropertiesTemplateError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXFilePropertiesTemplateError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXFilePropertiesListTemplateResult?
            if let swift = result {
                objc = DBXFilePropertiesListTemplateResult(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXFilesPropertiesUpdateRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<VoidSerializer, FileProperties.UpdatePropertiesErrorSerializer>

    init(swift: RpcRequest<VoidSerializer, FileProperties.UpdatePropertiesErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXFilePropertiesUpdatePropertiesError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXFilePropertiesUpdatePropertiesError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { _, error in
            var routeError: DBXFilePropertiesUpdatePropertiesError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXFilePropertiesUpdatePropertiesError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            completionHandler(routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXFilesRestoreRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Files.FileMetadataSerializer, Files.RestoreErrorSerializer>

    init(swift: RpcRequest<Files.FileMetadataSerializer, Files.RestoreErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXFilesFileMetadata?, DBXFilesRestoreError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXFilesFileMetadata?, DBXFilesRestoreError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXFilesRestoreError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXFilesRestoreError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXFilesFileMetadata?
            if let swift = result {
                objc = DBXFilesFileMetadata(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXFilesSaveUrlRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Files.SaveUrlResultSerializer, Files.SaveUrlErrorSerializer>

    init(swift: RpcRequest<Files.SaveUrlResultSerializer, Files.SaveUrlErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXFilesSaveUrlResult?, DBXFilesSaveUrlError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXFilesSaveUrlResult?, DBXFilesSaveUrlError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXFilesSaveUrlError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXFilesSaveUrlError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXFilesSaveUrlResult?
            if let swift = result {
                objc = DBXFilesSaveUrlResult.factory(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXFilesSaveUrlCheckJobStatusRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Files.SaveUrlJobStatusSerializer, Async.PollErrorSerializer>

    init(swift: RpcRequest<Files.SaveUrlJobStatusSerializer, Async.PollErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXFilesSaveUrlJobStatus?, DBXAsyncPollError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXFilesSaveUrlJobStatus?, DBXAsyncPollError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXAsyncPollError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXAsyncPollError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXFilesSaveUrlJobStatus?
            if let swift = result {
                objc = DBXFilesSaveUrlJobStatus.factory(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXFilesSearchRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Files.SearchResultSerializer, Files.SearchErrorSerializer>

    init(swift: RpcRequest<Files.SearchResultSerializer, Files.SearchErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXFilesSearchResult?, DBXFilesSearchError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXFilesSearchResult?, DBXFilesSearchError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXFilesSearchError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXFilesSearchError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXFilesSearchResult?
            if let swift = result {
                objc = DBXFilesSearchResult(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXFilesSearchRpcRequestV2: NSObject, DBXRequest {
    var swift: RpcRequest<Files.SearchV2ResultSerializer, Files.SearchErrorSerializer>

    init(swift: RpcRequest<Files.SearchV2ResultSerializer, Files.SearchErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXFilesSearchV2Result?, DBXFilesSearchError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXFilesSearchV2Result?, DBXFilesSearchError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXFilesSearchError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXFilesSearchError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXFilesSearchV2Result?
            if let swift = result {
                objc = DBXFilesSearchV2Result(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXFilesSearchContinueRpcRequestV2: NSObject, DBXRequest {
    var swift: RpcRequest<Files.SearchV2ResultSerializer, Files.SearchErrorSerializer>

    init(swift: RpcRequest<Files.SearchV2ResultSerializer, Files.SearchErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXFilesSearchV2Result?, DBXFilesSearchError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXFilesSearchV2Result?, DBXFilesSearchError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXFilesSearchError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXFilesSearchError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXFilesSearchV2Result?
            if let swift = result {
                objc = DBXFilesSearchV2Result(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXFilesTagsAddRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<VoidSerializer, Files.AddTagErrorSerializer>

    init(swift: RpcRequest<VoidSerializer, Files.AddTagErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXFilesAddTagError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXFilesAddTagError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { _, error in
            var routeError: DBXFilesAddTagError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXFilesAddTagError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            completionHandler(routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXFilesTagsGetRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Files.GetTagsResultSerializer, Files.BaseTagErrorSerializer>

    init(swift: RpcRequest<Files.GetTagsResultSerializer, Files.BaseTagErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXFilesGetTagsResult?, DBXFilesBaseTagError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXFilesGetTagsResult?, DBXFilesBaseTagError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXFilesBaseTagError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXFilesBaseTagError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXFilesGetTagsResult?
            if let swift = result {
                objc = DBXFilesGetTagsResult(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXFilesTagsRemoveRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<VoidSerializer, Files.RemoveTagErrorSerializer>

    init(swift: RpcRequest<VoidSerializer, Files.RemoveTagErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXFilesRemoveTagError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXFilesRemoveTagError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { _, error in
            var routeError: DBXFilesRemoveTagError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXFilesRemoveTagError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            completionHandler(routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXFilesUnlockFileBatchRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Files.LockFileBatchResultSerializer, Files.LockFileErrorSerializer>

    init(swift: RpcRequest<Files.LockFileBatchResultSerializer, Files.LockFileErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXFilesLockFileBatchResult?, DBXFilesLockFileError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXFilesLockFileBatchResult?, DBXFilesLockFileError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXFilesLockFileError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXFilesLockFileError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXFilesLockFileBatchResult?
            if let swift = result {
                objc = DBXFilesLockFileBatchResult(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXFilesUploadUploadRequest: NSObject, DBXRequest {
    var swift: UploadRequest<Files.FileMetadataSerializer, Files.UploadErrorSerializer>

    init(swift: UploadRequest<Files.FileMetadataSerializer, Files.UploadErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXFilesFileMetadata?, DBXFilesUploadError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXFilesFileMetadata?, DBXFilesUploadError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXFilesUploadError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXFilesUploadError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXFilesFileMetadata?
            if let swift = result {
                objc = DBXFilesFileMetadata(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public func progress(_ progressHandler: @escaping ((Progress) -> Void)) -> Self {
        swift.progress(progressHandler)
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXFilesUploadSessionAppendUploadRequest: NSObject, DBXRequest {
    var swift: UploadRequest<VoidSerializer, Files.UploadSessionAppendErrorSerializer>

    init(swift: UploadRequest<VoidSerializer, Files.UploadSessionAppendErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXFilesUploadSessionAppendError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXFilesUploadSessionAppendError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { _, error in
            var routeError: DBXFilesUploadSessionAppendError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXFilesUploadSessionAppendError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            completionHandler(routeError, callError)
        }
        return self
    }

    @objc
    public func progress(_ progressHandler: @escaping ((Progress) -> Void)) -> Self {
        swift.progress(progressHandler)
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXFilesUploadSessionAppendUploadRequestV2: NSObject, DBXRequest {
    var swift: UploadRequest<VoidSerializer, Files.UploadSessionAppendErrorSerializer>

    init(swift: UploadRequest<VoidSerializer, Files.UploadSessionAppendErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXFilesUploadSessionAppendError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXFilesUploadSessionAppendError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { _, error in
            var routeError: DBXFilesUploadSessionAppendError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXFilesUploadSessionAppendError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            completionHandler(routeError, callError)
        }
        return self
    }

    @objc
    public func progress(_ progressHandler: @escaping ((Progress) -> Void)) -> Self {
        swift.progress(progressHandler)
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXFilesUploadSessionFinishUploadRequest: NSObject, DBXRequest {
    var swift: UploadRequest<Files.FileMetadataSerializer, Files.UploadSessionFinishErrorSerializer>

    init(swift: UploadRequest<Files.FileMetadataSerializer, Files.UploadSessionFinishErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXFilesFileMetadata?, DBXFilesUploadSessionFinishError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXFilesFileMetadata?, DBXFilesUploadSessionFinishError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXFilesUploadSessionFinishError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXFilesUploadSessionFinishError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXFilesFileMetadata?
            if let swift = result {
                objc = DBXFilesFileMetadata(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public func progress(_ progressHandler: @escaping ((Progress) -> Void)) -> Self {
        swift.progress(progressHandler)
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXFilesUploadSessionFinishBatchRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Files.UploadSessionFinishBatchLaunchSerializer, VoidSerializer>

    init(swift: RpcRequest<Files.UploadSessionFinishBatchLaunchSerializer, VoidSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXFilesUploadSessionFinishBatchLaunch?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXFilesUploadSessionFinishBatchLaunch?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var objc: DBXFilesUploadSessionFinishBatchLaunch?
            if let swift = result {
                objc = DBXFilesUploadSessionFinishBatchLaunch.factory(swift: swift)
            }
            completionHandler(objc, error?.objc)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXFilesUploadSessionFinishBatchRpcRequestV2: NSObject, DBXRequest {
    var swift: RpcRequest<Files.UploadSessionFinishBatchResultSerializer, VoidSerializer>

    init(swift: RpcRequest<Files.UploadSessionFinishBatchResultSerializer, VoidSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXFilesUploadSessionFinishBatchResult?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXFilesUploadSessionFinishBatchResult?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var objc: DBXFilesUploadSessionFinishBatchResult?
            if let swift = result {
                objc = DBXFilesUploadSessionFinishBatchResult(swift: swift)
            }
            completionHandler(objc, error?.objc)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXFilesUploadSessionFinishBatchCheckRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Files.UploadSessionFinishBatchJobStatusSerializer, Async.PollErrorSerializer>

    init(swift: RpcRequest<Files.UploadSessionFinishBatchJobStatusSerializer, Async.PollErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXFilesUploadSessionFinishBatchJobStatus?, DBXAsyncPollError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXFilesUploadSessionFinishBatchJobStatus?, DBXAsyncPollError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXAsyncPollError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXAsyncPollError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXFilesUploadSessionFinishBatchJobStatus?
            if let swift = result {
                objc = DBXFilesUploadSessionFinishBatchJobStatus.factory(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXFilesUploadSessionStartUploadRequest: NSObject, DBXRequest {
    var swift: UploadRequest<Files.UploadSessionStartResultSerializer, Files.UploadSessionStartErrorSerializer>

    init(swift: UploadRequest<Files.UploadSessionStartResultSerializer, Files.UploadSessionStartErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXFilesUploadSessionStartResult?, DBXFilesUploadSessionStartError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXFilesUploadSessionStartResult?, DBXFilesUploadSessionStartError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXFilesUploadSessionStartError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXFilesUploadSessionStartError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXFilesUploadSessionStartResult?
            if let swift = result {
                objc = DBXFilesUploadSessionStartResult(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public func progress(_ progressHandler: @escaping ((Progress) -> Void)) -> Self {
        swift.progress(progressHandler)
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXFilesUploadSessionStartBatchRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Files.UploadSessionStartBatchResultSerializer, VoidSerializer>

    init(swift: RpcRequest<Files.UploadSessionStartBatchResultSerializer, VoidSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXFilesUploadSessionStartBatchResult?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXFilesUploadSessionStartBatchResult?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var objc: DBXFilesUploadSessionStartBatchResult?
            if let swift = result {
                objc = DBXFilesUploadSessionStartBatchResult(swift: swift)
            }
            completionHandler(objc, error?.objc)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}
