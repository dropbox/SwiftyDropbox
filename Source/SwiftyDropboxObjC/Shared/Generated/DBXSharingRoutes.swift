///
/// Copyright (c) 2022 Dropbox, Inc. All rights reserved.
///
/// Auto-generated by Stone, do not modify.
///

import Foundation
import SwiftyDropbox

/// Objective-C compatible routes for the sharing namespace
/// For Swift routes see SharingRoutes
@objc
public class DBXSharingRoutes: NSObject {
    private let swift: SharingRoutes
    init(swift: SharingRoutes) {
        self.swift = swift
        self.client = swift.client.objc
    }

    public let client: DBXDropboxTransportClient

    /// Adds specified members to a file.
    ///
    /// - scope: sharing.write
    ///
    /// - parameter file: File to which to add members.
    /// - parameter members: Members to add. Note that even an email address is given, this may result in a user being
    /// directly added to the membership if that email is the user's main account email.
    /// - parameter customMessage: Message to send to added members in their invitation.
    /// - parameter quiet: Whether added members should be notified via email and device notifications of their
    /// invitation.
    /// - parameter accessLevel: AccessLevel union object, describing what access level we want to give new members.
    /// - parameter addMessageAsComment: If the custom message should be added as a comment on the file.
    ///
    /// - returns: Through the response callback, the caller will receive a `Array<Sharing.FileMemberActionResult>`
    /// object on success or a `Sharing.AddFileMemberError` object on failure.
    @objc
    @discardableResult public func addFileMember(
        file: String,
        members: [DBXSharingMemberSelector],
        customMessage: String?,
        quiet: NSNumber,
        accessLevel: DBXSharingAccessLevel,
        addMessageAsComment: NSNumber
    ) -> DBXSharingAddFileMemberRpcRequest {
        let swift = swift.addFileMember(
            file: file,
            members: members.map(\.swift),
            customMessage: customMessage,
            quiet: quiet.boolValue,
            accessLevel: accessLevel.swift,
            addMessageAsComment: addMessageAsComment.boolValue
        )
        return DBXSharingAddFileMemberRpcRequest(swift: swift)
    }

    /// Adds specified members to a file.
    ///
    /// - scope: sharing.write
    ///
    /// - returns: Through the response callback, the caller will receive a `Array<Sharing.FileMemberActionResult>`
    /// object on success or a `Sharing.AddFileMemberError` object on failure.
    @objc
    @discardableResult public func addFileMember(file: String, members: [DBXSharingMemberSelector]) -> DBXSharingAddFileMemberRpcRequest {
        let swift = swift.addFileMember(file: file, members: members.map(\.swift))
        return DBXSharingAddFileMemberRpcRequest(swift: swift)
    }

    /// Allows an owner or editor (if the ACL update policy allows) of a shared folder to add another member. For the
    /// new member to get access to all the functionality for this folder, you will need to call mountFolder on
    /// their behalf.
    ///
    /// - scope: sharing.write
    ///
    /// - parameter sharedFolderId: The ID for the shared folder.
    /// - parameter members: The intended list of members to add.  Added members will receive invites to join the shared
    /// folder.
    /// - parameter quiet: Whether added members should be notified via email and device notifications of their invite.
    /// - parameter customMessage: Optional message to display to added members in their invitation.
    ///
    /// - returns: Through the response callback, the caller will receive a `Void` object on success or a
    /// `Sharing.AddFolderMemberError` object on failure.
    @objc
    @discardableResult public func addFolderMember(
        sharedFolderId: String,
        members: [DBXSharingAddMember],
        quiet: NSNumber,
        customMessage: String?
    ) -> DBXSharingAddFolderMemberRpcRequest {
        let swift = swift.addFolderMember(sharedFolderId: sharedFolderId, members: members.map(\.swift), quiet: quiet.boolValue, customMessage: customMessage)
        return DBXSharingAddFolderMemberRpcRequest(swift: swift)
    }

    /// Allows an owner or editor (if the ACL update policy allows) of a shared folder to add another member. For the
    /// new member to get access to all the functionality for this folder, you will need to call mountFolder on
    /// their behalf.
    ///
    /// - scope: sharing.write
    ///
    /// - returns: Through the response callback, the caller will receive a `Void` object on success or a
    /// `Sharing.AddFolderMemberError` object on failure.
    @objc
    @discardableResult public func addFolderMember(sharedFolderId: String, members: [DBXSharingAddMember]) -> DBXSharingAddFolderMemberRpcRequest {
        let swift = swift.addFolderMember(sharedFolderId: sharedFolderId, members: members.map(\.swift))
        return DBXSharingAddFolderMemberRpcRequest(swift: swift)
    }

    /// Returns the status of an asynchronous job.
    ///
    /// - scope: sharing.write
    ///
    /// - parameter asyncJobId: Id of the asynchronous job. This is the value of a response returned from the method
    /// that launched the job.
    ///
    /// - returns: Through the response callback, the caller will receive a `Sharing.JobStatus` object on success or a
    /// `Async.PollError` object on failure.
    @objc
    @discardableResult public func checkJobStatus(asyncJobId: String) -> DBXSharingCheckJobStatusRpcRequest {
        let swift = swift.checkJobStatus(asyncJobId: asyncJobId)
        return DBXSharingCheckJobStatusRpcRequest(swift: swift)
    }

    /// Returns the status of an asynchronous job for sharing a folder.
    ///
    /// - scope: sharing.write
    ///
    /// - parameter asyncJobId: Id of the asynchronous job. This is the value of a response returned from the method
    /// that launched the job.
    ///
    /// - returns: Through the response callback, the caller will receive a `Sharing.RemoveMemberJobStatus` object on
    /// success or a `Async.PollError` object on failure.
    @objc
    @discardableResult public func checkRemoveMemberJobStatus(asyncJobId: String) -> DBXSharingCheckRemoveMemberJobStatusRpcRequest {
        let swift = swift.checkRemoveMemberJobStatus(asyncJobId: asyncJobId)
        return DBXSharingCheckRemoveMemberJobStatusRpcRequest(swift: swift)
    }

    /// Returns the status of an asynchronous job for sharing a folder.
    ///
    /// - scope: sharing.write
    ///
    /// - parameter asyncJobId: Id of the asynchronous job. This is the value of a response returned from the method
    /// that launched the job.
    ///
    /// - returns: Through the response callback, the caller will receive a `Sharing.ShareFolderJobStatus` object on
    /// success or a `Async.PollError` object on failure.
    @objc
    @discardableResult public func checkShareJobStatus(asyncJobId: String) -> DBXSharingCheckShareJobStatusRpcRequest {
        let swift = swift.checkShareJobStatus(asyncJobId: asyncJobId)
        return DBXSharingCheckShareJobStatusRpcRequest(swift: swift)
    }

    /// Create a shared link with custom settings. If no settings are given then the default visibility is public_ in
    /// RequestedVisibility (The resolved visibility, though, may depend on other aspects such as team and shared
    /// folder settings).
    ///
    /// - scope: sharing.write
    ///
    /// - parameter path: The path to be shared by the shared link.
    /// - parameter settings: The requested settings for the newly created shared link.
    ///
    /// - returns: Through the response callback, the caller will receive a `Sharing.SharedLinkMetadata` object on
    /// success or a `Sharing.CreateSharedLinkWithSettingsError` object on failure.
    @objc
    @discardableResult public func createSharedLinkWithSettings(
        path: String,
        settings: DBXSharingSharedLinkSettings?
    ) -> DBXSharingCreateSharedLinkWithSettingsRpcRequest {
        let swift = swift.createSharedLinkWithSettings(path: path, settings: settings?.swift)
        return DBXSharingCreateSharedLinkWithSettingsRpcRequest(swift: swift)
    }

    /// Create a shared link with custom settings. If no settings are given then the default visibility is public_ in
    /// RequestedVisibility (The resolved visibility, though, may depend on other aspects such as team and shared
    /// folder settings).
    ///
    /// - scope: sharing.write
    ///
    /// - returns: Through the response callback, the caller will receive a `Sharing.SharedLinkMetadata` object on
    /// success or a `Sharing.CreateSharedLinkWithSettingsError` object on failure.
    @objc
    @discardableResult public func createSharedLinkWithSettings(path: String) -> DBXSharingCreateSharedLinkWithSettingsRpcRequest {
        let swift = swift.createSharedLinkWithSettings(path: path)
        return DBXSharingCreateSharedLinkWithSettingsRpcRequest(swift: swift)
    }

    /// Returns shared file metadata.
    ///
    /// - scope: sharing.read
    ///
    /// - parameter file: The file to query.
    /// - parameter actions: A list of `FileAction`s corresponding to `FilePermission`s that should appear in the
    /// response's permissions in SharedFileMetadata field describing the actions the  authenticated user can
    /// perform on the file.
    ///
    /// - returns: Through the response callback, the caller will receive a `Sharing.SharedFileMetadata` object on
    /// success or a `Sharing.GetFileMetadataError` object on failure.
    @objc
    @discardableResult public func getFileMetadata(file: String, actions: [DBXSharingFileAction]?) -> DBXSharingGetFileMetadataRpcRequest {
        let swift = swift.getFileMetadata(file: file, actions: actions?.map(\.swift))
        return DBXSharingGetFileMetadataRpcRequest(swift: swift)
    }

    /// Returns shared file metadata.
    ///
    /// - scope: sharing.read
    ///
    /// - returns: Through the response callback, the caller will receive a `Sharing.SharedFileMetadata` object on
    /// success or a `Sharing.GetFileMetadataError` object on failure.
    @objc
    @discardableResult public func getFileMetadata(file: String) -> DBXSharingGetFileMetadataRpcRequest {
        let swift = swift.getFileMetadata(file: file)
        return DBXSharingGetFileMetadataRpcRequest(swift: swift)
    }

    /// Returns shared file metadata.
    ///
    /// - scope: sharing.read
    ///
    /// - parameter files: The files to query.
    /// - parameter actions: A list of `FileAction`s corresponding to `FilePermission`s that should appear in the
    /// response's permissions in SharedFileMetadata field describing the actions the  authenticated user can
    /// perform on the file.
    ///
    /// - returns: Through the response callback, the caller will receive a `Array<Sharing.GetFileMetadataBatchResult>`
    /// object on success or a `Sharing.SharingUserError` object on failure.
    @objc
    @discardableResult public func getFileMetadataBatch(files: [String], actions: [DBXSharingFileAction]?) -> DBXSharingGetFileMetadataBatchRpcRequest {
        let swift = swift.getFileMetadataBatch(files: files, actions: actions?.map(\.swift))
        return DBXSharingGetFileMetadataBatchRpcRequest(swift: swift)
    }

    /// Returns shared file metadata.
    ///
    /// - scope: sharing.read
    ///
    /// - returns: Through the response callback, the caller will receive a `Array<Sharing.GetFileMetadataBatchResult>`
    /// object on success or a `Sharing.SharingUserError` object on failure.
    @objc
    @discardableResult public func getFileMetadataBatch(files: [String]) -> DBXSharingGetFileMetadataBatchRpcRequest {
        let swift = swift.getFileMetadataBatch(files: files)
        return DBXSharingGetFileMetadataBatchRpcRequest(swift: swift)
    }

    /// Returns shared folder metadata by its folder ID.
    ///
    /// - scope: sharing.read
    ///
    /// - parameter sharedFolderId: The ID for the shared folder.
    /// - parameter actions: A list of `FolderAction`s corresponding to `FolderPermission`s that should appear in the
    /// response's permissions in SharedFolderMetadata field describing the actions the  authenticated user can
    /// perform on the folder.
    ///
    /// - returns: Through the response callback, the caller will receive a `Sharing.SharedFolderMetadata` object on
    /// success or a `Sharing.SharedFolderAccessError` object on failure.
    @objc
    @discardableResult public func getFolderMetadata(sharedFolderId: String, actions: [DBXSharingFolderAction]?) -> DBXSharingGetFolderMetadataRpcRequest {
        let swift = swift.getFolderMetadata(sharedFolderId: sharedFolderId, actions: actions?.map(\.swift))
        return DBXSharingGetFolderMetadataRpcRequest(swift: swift)
    }

    /// Returns shared folder metadata by its folder ID.
    ///
    /// - scope: sharing.read
    ///
    /// - returns: Through the response callback, the caller will receive a `Sharing.SharedFolderMetadata` object on
    /// success or a `Sharing.SharedFolderAccessError` object on failure.
    @objc
    @discardableResult public func getFolderMetadata(sharedFolderId: String) -> DBXSharingGetFolderMetadataRpcRequest {
        let swift = swift.getFolderMetadata(sharedFolderId: sharedFolderId)
        return DBXSharingGetFolderMetadataRpcRequest(swift: swift)
    }

    /// Download the shared link's file from a user's Dropbox.
    ///
    /// - scope: sharing.read
    ///
    /// - parameter url: URL of the shared link.
    /// - parameter path: If the shared link is to a folder, this parameter can be used to retrieve the metadata for a
    /// specific file or sub-folder in this folder. A relative path should be used.
    /// - parameter linkPassword: If the shared link has a password, this parameter can be used.
    /// - parameter overwrite: A boolean to set behavior in the event of a naming conflict. `True` will overwrite
    /// conflicting file at destination. `False` will take no action (but if left unhandled in destination closure,
    /// an NSError will be thrown).
    /// - parameter destination: The location to write the download to.
    ///
    /// - returns: Through the response callback, the caller will receive a `Sharing.SharedLinkMetadata` object on
    /// success or a `Sharing.GetSharedLinkFileError` object on failure.
    @objc
    @discardableResult public func getSharedLinkFileURL(
        url: String,
        path: String?,
        linkPassword: String?,
        overwrite: Bool,
        destination: URL
    ) -> DBXSharingGetSharedLinkFileDownloadRequestFile {
        let swift = swift.getSharedLinkFile(url: url, path: path, linkPassword: linkPassword, overwrite: overwrite, destination: destination)
        return DBXSharingGetSharedLinkFileDownloadRequestFile(swift: swift)
    }

    /// Download the shared link's file from a user's Dropbox.
    ///
    /// - scope: sharing.read
    ///
    /// - returns: Through the response callback, the caller will receive a `Sharing.SharedLinkMetadata` object on
    /// success or a `Sharing.GetSharedLinkFileError` object on failure.
    @objc
    @discardableResult public func getSharedLinkFileURL(url: String, overwrite: Bool, destination: URL) -> DBXSharingGetSharedLinkFileDownloadRequestFile {
        let swift = swift.getSharedLinkFile(url: url, overwrite: overwrite, destination: destination)
        return DBXSharingGetSharedLinkFileDownloadRequestFile(swift: swift)
    }

    /// Download the shared link's file from a user's Dropbox.
    ///
    /// - scope: sharing.read
    ///
    /// - parameter url: URL of the shared link.
    /// - parameter path: If the shared link is to a folder, this parameter can be used to retrieve the metadata for a
    /// specific file or sub-folder in this folder. A relative path should be used.
    /// - parameter linkPassword: If the shared link has a password, this parameter can be used.
    ///
    /// - returns: Through the response callback, the caller will receive a `Sharing.SharedLinkMetadata` object on
    /// success or a `Sharing.GetSharedLinkFileError` object on failure.
    @objc
    @discardableResult public func getSharedLinkFile(url: String, path: String?, linkPassword: String?) -> DBXSharingGetSharedLinkFileDownloadRequestMemory {
        let swift = swift.getSharedLinkFile(url: url, path: path, linkPassword: linkPassword)
        return DBXSharingGetSharedLinkFileDownloadRequestMemory(swift: swift)
    }

    /// Download the shared link's file from a user's Dropbox.
    ///
    /// - scope: sharing.read
    ///
    /// - returns: Through the response callback, the caller will receive a `Sharing.SharedLinkMetadata` object on
    /// success or a `Sharing.GetSharedLinkFileError` object on failure.
    @objc
    @discardableResult public func getSharedLinkFile(url: String) -> DBXSharingGetSharedLinkFileDownloadRequestMemory {
        let swift = swift.getSharedLinkFile(url: url)
        return DBXSharingGetSharedLinkFileDownloadRequestMemory(swift: swift)
    }

    /// Get the shared link's metadata.
    ///
    /// - scope: sharing.read
    ///
    /// - parameter url: URL of the shared link.
    /// - parameter path: If the shared link is to a folder, this parameter can be used to retrieve the metadata for a
    /// specific file or sub-folder in this folder. A relative path should be used.
    /// - parameter linkPassword: If the shared link has a password, this parameter can be used.
    ///
    /// - returns: Through the response callback, the caller will receive a `Sharing.SharedLinkMetadata` object on
    /// success or a `Sharing.SharedLinkError` object on failure.
    @objc
    @discardableResult public func getSharedLinkMetadata(url: String, path: String?, linkPassword: String?) -> DBXSharingGetSharedLinkMetadataRpcRequest {
        let swift = swift.getSharedLinkMetadata(url: url, path: path, linkPassword: linkPassword)
        return DBXSharingGetSharedLinkMetadataRpcRequest(swift: swift)
    }

    /// Get the shared link's metadata.
    ///
    /// - scope: sharing.read
    ///
    /// - returns: Through the response callback, the caller will receive a `Sharing.SharedLinkMetadata` object on
    /// success or a `Sharing.SharedLinkError` object on failure.
    @objc
    @discardableResult public func getSharedLinkMetadata(url: String) -> DBXSharingGetSharedLinkMetadataRpcRequest {
        let swift = swift.getSharedLinkMetadata(url: url)
        return DBXSharingGetSharedLinkMetadataRpcRequest(swift: swift)
    }

    /// Use to obtain the members who have been invited to a file, both inherited and uninherited members.
    ///
    /// - scope: sharing.read
    ///
    /// - parameter file: The file for which you want to see members.
    /// - parameter actions: The actions for which to return permissions on a member.
    /// - parameter includeInherited: Whether to include members who only have access from a parent shared folder.
    /// - parameter limit: Number of members to return max per query. Defaults to 100 if no limit is specified.
    ///
    /// - returns: Through the response callback, the caller will receive a `Sharing.SharedFileMembers` object on
    /// success or a `Sharing.ListFileMembersError` object on failure.
    @objc
    @discardableResult public func listFileMembers(
        file: String,
        actions: [DBXSharingMemberAction]?,
        includeInherited: NSNumber,
        limit: NSNumber
    ) -> DBXSharingListFileMembersRpcRequest {
        let swift = swift.listFileMembers(file: file, actions: actions?.map(\.swift), includeInherited: includeInherited.boolValue, limit: limit.uint32Value)
        return DBXSharingListFileMembersRpcRequest(swift: swift)
    }

    /// Use to obtain the members who have been invited to a file, both inherited and uninherited members.
    ///
    /// - scope: sharing.read
    ///
    /// - returns: Through the response callback, the caller will receive a `Sharing.SharedFileMembers` object on
    /// success or a `Sharing.ListFileMembersError` object on failure.
    @objc
    @discardableResult public func listFileMembers(file: String) -> DBXSharingListFileMembersRpcRequest {
        let swift = swift.listFileMembers(file: file)
        return DBXSharingListFileMembersRpcRequest(swift: swift)
    }

    /// Get members of multiple files at once. The arguments to this route are more limited, and the limit on query
    /// result size per file is more strict. To customize the results more, use the individual file endpoint.
    /// Inherited users and groups are not included in the result, and permissions are not returned for this
    /// endpoint.
    ///
    /// - scope: sharing.read
    ///
    /// - parameter files: Files for which to return members.
    /// - parameter limit: Number of members to return max per query. Defaults to 10 if no limit is specified.
    ///
    /// - returns: Through the response callback, the caller will receive a `Array<Sharing.ListFileMembersBatchResult>`
    /// object on success or a `Sharing.SharingUserError` object on failure.
    @objc
    @discardableResult public func listFileMembersBatch(files: [String], limit: NSNumber) -> DBXSharingListFileMembersBatchRpcRequest {
        let swift = swift.listFileMembersBatch(files: files, limit: limit.uint32Value)
        return DBXSharingListFileMembersBatchRpcRequest(swift: swift)
    }

    /// Get members of multiple files at once. The arguments to this route are more limited, and the limit on query
    /// result size per file is more strict. To customize the results more, use the individual file endpoint.
    /// Inherited users and groups are not included in the result, and permissions are not returned for this
    /// endpoint.
    ///
    /// - scope: sharing.read
    ///
    /// - returns: Through the response callback, the caller will receive a `Array<Sharing.ListFileMembersBatchResult>`
    /// object on success or a `Sharing.SharingUserError` object on failure.
    @objc
    @discardableResult public func listFileMembersBatch(files: [String]) -> DBXSharingListFileMembersBatchRpcRequest {
        let swift = swift.listFileMembersBatch(files: files)
        return DBXSharingListFileMembersBatchRpcRequest(swift: swift)
    }

    /// Once a cursor has been retrieved from listFileMembers or listFileMembersBatch, use this to paginate through all
    /// shared file members.
    ///
    /// - scope: sharing.read
    ///
    /// - parameter cursor: The cursor returned by your last call to listFileMembers, listFileMembersContinue, or
    /// listFileMembersBatch.
    ///
    /// - returns: Through the response callback, the caller will receive a `Sharing.SharedFileMembers` object on
    /// success or a `Sharing.ListFileMembersContinueError` object on failure.
    @objc
    @discardableResult public func listFileMembersContinue(cursor: String) -> DBXSharingListFileMembersContinueRpcRequest {
        let swift = swift.listFileMembersContinue(cursor: cursor)
        return DBXSharingListFileMembersContinueRpcRequest(swift: swift)
    }

    /// Returns shared folder membership by its folder ID.
    ///
    /// - scope: sharing.read
    ///
    /// - parameter sharedFolderId: The ID for the shared folder.
    ///
    /// - returns: Through the response callback, the caller will receive a `Sharing.SharedFolderMembers` object on
    /// success or a `Sharing.SharedFolderAccessError` object on failure.
    @objc
    @discardableResult public func listFolderMembers(
        sharedFolderId: String,
        actions: [DBXSharingMemberAction]?,
        limit: NSNumber
    ) -> DBXSharingListFolderMembersRpcRequest {
        let swift = swift.listFolderMembers(sharedFolderId: sharedFolderId, actions: actions?.map(\.swift), limit: limit.uint32Value)
        return DBXSharingListFolderMembersRpcRequest(swift: swift)
    }

    /// Returns shared folder membership by its folder ID.
    ///
    /// - scope: sharing.read
    ///
    /// - returns: Through the response callback, the caller will receive a `Sharing.SharedFolderMembers` object on
    /// success or a `Sharing.SharedFolderAccessError` object on failure.
    @objc
    @discardableResult public func listFolderMembers(sharedFolderId: String) -> DBXSharingListFolderMembersRpcRequest {
        let swift = swift.listFolderMembers(sharedFolderId: sharedFolderId)
        return DBXSharingListFolderMembersRpcRequest(swift: swift)
    }

    /// Once a cursor has been retrieved from listFolderMembers, use this to paginate through all shared folder members.
    ///
    /// - scope: sharing.read
    ///
    /// - parameter cursor: The cursor returned by your last call to listFolderMembers or listFolderMembersContinue.
    ///
    /// - returns: Through the response callback, the caller will receive a `Sharing.SharedFolderMembers` object on
    /// success or a `Sharing.ListFolderMembersContinueError` object on failure.
    @objc
    @discardableResult public func listFolderMembersContinue(cursor: String) -> DBXSharingListFolderMembersContinueRpcRequest {
        let swift = swift.listFolderMembersContinue(cursor: cursor)
        return DBXSharingListFolderMembersContinueRpcRequest(swift: swift)
    }

    /// Return the list of all shared folders the current user has access to.
    ///
    /// - scope: sharing.read
    ///
    /// - parameter limit: The maximum number of results to return per request.
    /// - parameter actions: A list of `FolderAction`s corresponding to `FolderPermission`s that should appear in the
    /// response's permissions in SharedFolderMetadata field describing the actions the  authenticated user can
    /// perform on the folder.
    ///
    /// - returns: Through the response callback, the caller will receive a `Sharing.ListFoldersResult` object on
    /// success or a `Void` object on failure.
    @objc
    @discardableResult public func listFolders(limit: NSNumber, actions: [DBXSharingFolderAction]?) -> DBXSharingListFoldersRpcRequest {
        let swift = swift.listFolders(limit: limit.uint32Value, actions: actions?.map(\.swift))
        return DBXSharingListFoldersRpcRequest(swift: swift)
    }

    /// Return the list of all shared folders the current user has access to.
    ///
    /// - scope: sharing.read
    ///
    /// - returns: Through the response callback, the caller will receive a `Sharing.ListFoldersResult` object on
    /// success or a `Void` object on failure.
    @objc
    @discardableResult public func listFolders() -> DBXSharingListFoldersRpcRequest {
        let swift = swift.listFolders()
        return DBXSharingListFoldersRpcRequest(swift: swift)
    }

    /// Once a cursor has been retrieved from listFolders, use this to paginate through all shared folders. The cursor
    /// must come from a previous call to listFolders or listFoldersContinue.
    ///
    /// - scope: sharing.read
    ///
    /// - parameter cursor: The cursor returned by the previous API call specified in the endpoint description.
    ///
    /// - returns: Through the response callback, the caller will receive a `Sharing.ListFoldersResult` object on
    /// success or a `Sharing.ListFoldersContinueError` object on failure.
    @objc
    @discardableResult public func listFoldersContinue(cursor: String) -> DBXSharingListFoldersContinueRpcRequest {
        let swift = swift.listFoldersContinue(cursor: cursor)
        return DBXSharingListFoldersContinueRpcRequest(swift: swift)
    }

    /// Return the list of all shared folders the current user can mount or unmount.
    ///
    /// - scope: sharing.read
    ///
    /// - parameter limit: The maximum number of results to return per request.
    /// - parameter actions: A list of `FolderAction`s corresponding to `FolderPermission`s that should appear in the
    /// response's permissions in SharedFolderMetadata field describing the actions the  authenticated user can
    /// perform on the folder.
    ///
    /// - returns: Through the response callback, the caller will receive a `Sharing.ListFoldersResult` object on
    /// success or a `Void` object on failure.
    @objc
    @discardableResult public func listMountableFolders(limit: NSNumber, actions: [DBXSharingFolderAction]?) -> DBXSharingListMountableFoldersRpcRequest {
        let swift = swift.listMountableFolders(limit: limit.uint32Value, actions: actions?.map(\.swift))
        return DBXSharingListMountableFoldersRpcRequest(swift: swift)
    }

    /// Return the list of all shared folders the current user can mount or unmount.
    ///
    /// - scope: sharing.read
    ///
    /// - returns: Through the response callback, the caller will receive a `Sharing.ListFoldersResult` object on
    /// success or a `Void` object on failure.
    @objc
    @discardableResult public func listMountableFolders() -> DBXSharingListMountableFoldersRpcRequest {
        let swift = swift.listMountableFolders()
        return DBXSharingListMountableFoldersRpcRequest(swift: swift)
    }

    /// Once a cursor has been retrieved from listMountableFolders, use this to paginate through all mountable shared
    /// folders. The cursor must come from a previous call to listMountableFolders or listMountableFoldersContinue.
    ///
    /// - scope: sharing.read
    ///
    /// - parameter cursor: The cursor returned by the previous API call specified in the endpoint description.
    ///
    /// - returns: Through the response callback, the caller will receive a `Sharing.ListFoldersResult` object on
    /// success or a `Sharing.ListFoldersContinueError` object on failure.
    @objc
    @discardableResult public func listMountableFoldersContinue(cursor: String) -> DBXSharingListMountableFoldersContinueRpcRequest {
        let swift = swift.listMountableFoldersContinue(cursor: cursor)
        return DBXSharingListMountableFoldersContinueRpcRequest(swift: swift)
    }

    /// Returns a list of all files shared with current user.  Does not include files the user has received via shared
    /// folders, and does  not include unclaimed invitations.
    ///
    /// - scope: sharing.read
    ///
    /// - parameter limit: Number of files to return max per query. Defaults to 100 if no limit is specified.
    /// - parameter actions: A list of `FileAction`s corresponding to `FilePermission`s that should appear in the
    /// response's permissions in SharedFileMetadata field describing the actions the  authenticated user can
    /// perform on the file.
    ///
    /// - returns: Through the response callback, the caller will receive a `Sharing.ListFilesResult` object on success
    /// or a `Sharing.SharingUserError` object on failure.
    @objc
    @discardableResult public func listReceivedFiles(limit: NSNumber, actions: [DBXSharingFileAction]?) -> DBXSharingListReceivedFilesRpcRequest {
        let swift = swift.listReceivedFiles(limit: limit.uint32Value, actions: actions?.map(\.swift))
        return DBXSharingListReceivedFilesRpcRequest(swift: swift)
    }

    /// Returns a list of all files shared with current user.  Does not include files the user has received via shared
    /// folders, and does  not include unclaimed invitations.
    ///
    /// - scope: sharing.read
    ///
    /// - returns: Through the response callback, the caller will receive a `Sharing.ListFilesResult` object on success
    /// or a `Sharing.SharingUserError` object on failure.
    @objc
    @discardableResult public func listReceivedFiles() -> DBXSharingListReceivedFilesRpcRequest {
        let swift = swift.listReceivedFiles()
        return DBXSharingListReceivedFilesRpcRequest(swift: swift)
    }

    /// Get more results with a cursor from listReceivedFiles.
    ///
    /// - scope: sharing.read
    ///
    /// - parameter cursor: Cursor in cursor in ListFilesResult.
    ///
    /// - returns: Through the response callback, the caller will receive a `Sharing.ListFilesResult` object on success
    /// or a `Sharing.ListFilesContinueError` object on failure.
    @objc
    @discardableResult public func listReceivedFilesContinue(cursor: String) -> DBXSharingListReceivedFilesContinueRpcRequest {
        let swift = swift.listReceivedFilesContinue(cursor: cursor)
        return DBXSharingListReceivedFilesContinueRpcRequest(swift: swift)
    }

    /// List shared links of this user. If no path is given, returns a list of all shared links for the current user.
    /// For members of business teams using team space and member folders, returns all shared links in the team
    /// member's home folder unless the team space ID is specified in the request header. For more information,
    /// refer to the Namespace Guide https://www.dropbox.com/developers/reference/namespace-guide. If a non-empty
    /// path is given, returns a list of all shared links that allow access to the given path - direct links to the
    /// given path and links to parent folders of the given path. Links to parent folders can be suppressed by
    /// setting direct_only to true.
    ///
    /// - scope: sharing.read
    ///
    /// - parameter path: See listSharedLinks description.
    /// - parameter cursor: The cursor returned by your last call to listSharedLinks.
    /// - parameter directOnly: See listSharedLinks description.
    ///
    /// - returns: Through the response callback, the caller will receive a `Sharing.ListSharedLinksResult` object on
    /// success or a `Sharing.ListSharedLinksError` object on failure.
    @objc
    @discardableResult public func listSharedLinks(path: String?, cursor: String?, directOnly: NSNumber?) -> DBXSharingListSharedLinksRpcRequest {
        let swift = swift.listSharedLinks(path: path, cursor: cursor, directOnly: directOnly?.boolValue)
        return DBXSharingListSharedLinksRpcRequest(swift: swift)
    }

    /// List shared links of this user. If no path is given, returns a list of all shared links for the current user.
    /// For members of business teams using team space and member folders, returns all shared links in the team
    /// member's home folder unless the team space ID is specified in the request header. For more information,
    /// refer to the Namespace Guide https://www.dropbox.com/developers/reference/namespace-guide. If a non-empty
    /// path is given, returns a list of all shared links that allow access to the given path - direct links to the
    /// given path and links to parent folders of the given path. Links to parent folders can be suppressed by
    /// setting direct_only to true.
    ///
    /// - scope: sharing.read
    ///
    /// - returns: Through the response callback, the caller will receive a `Sharing.ListSharedLinksResult` object on
    /// success or a `Sharing.ListSharedLinksError` object on failure.
    @objc
    @discardableResult public func listSharedLinks() -> DBXSharingListSharedLinksRpcRequest {
        let swift = swift.listSharedLinks()
        return DBXSharingListSharedLinksRpcRequest(swift: swift)
    }

    /// Modify the shared link's settings. If the requested visibility conflict with the shared links policy of the team
    /// or the shared folder (in case the linked file is part of a shared folder) then the resolvedVisibility in
    /// LinkPermissions of the returned SharedLinkMetadata will reflect the actual visibility of the shared link and
    /// the requestedVisibility in LinkPermissions will reflect the requested visibility.
    ///
    /// - scope: sharing.write
    ///
    /// - parameter url: URL of the shared link to change its settings.
    /// - parameter settings: Set of settings for the shared link.
    /// - parameter removeExpiration: If set to true, removes the expiration of the shared link.
    ///
    /// - returns: Through the response callback, the caller will receive a `Sharing.SharedLinkMetadata` object on
    /// success or a `Sharing.ModifySharedLinkSettingsError` object on failure.
    @objc
    @discardableResult public func modifySharedLinkSettings(
        url: String,
        settings: DBXSharingSharedLinkSettings,
        removeExpiration: NSNumber
    ) -> DBXSharingModifySharedLinkSettingsRpcRequest {
        let swift = swift.modifySharedLinkSettings(url: url, settings: settings.swift, removeExpiration: removeExpiration.boolValue)
        return DBXSharingModifySharedLinkSettingsRpcRequest(swift: swift)
    }

    /// Modify the shared link's settings. If the requested visibility conflict with the shared links policy of the team
    /// or the shared folder (in case the linked file is part of a shared folder) then the resolvedVisibility in
    /// LinkPermissions of the returned SharedLinkMetadata will reflect the actual visibility of the shared link and
    /// the requestedVisibility in LinkPermissions will reflect the requested visibility.
    ///
    /// - scope: sharing.write
    ///
    /// - returns: Through the response callback, the caller will receive a `Sharing.SharedLinkMetadata` object on
    /// success or a `Sharing.ModifySharedLinkSettingsError` object on failure.
    @objc
    @discardableResult public func modifySharedLinkSettings(
        url: String,
        settings: DBXSharingSharedLinkSettings
    ) -> DBXSharingModifySharedLinkSettingsRpcRequest {
        let swift = swift.modifySharedLinkSettings(url: url, settings: settings.swift)
        return DBXSharingModifySharedLinkSettingsRpcRequest(swift: swift)
    }

    /// The current user mounts the designated folder. Mount a shared folder for a user after they have been added as a
    /// member. Once mounted, the shared folder will appear in their Dropbox.
    ///
    /// - scope: sharing.write
    ///
    /// - parameter sharedFolderId: The ID of the shared folder to mount.
    ///
    /// - returns: Through the response callback, the caller will receive a `Sharing.SharedFolderMetadata` object on
    /// success or a `Sharing.MountFolderError` object on failure.
    @objc
    @discardableResult public func mountFolder(sharedFolderId: String) -> DBXSharingMountFolderRpcRequest {
        let swift = swift.mountFolder(sharedFolderId: sharedFolderId)
        return DBXSharingMountFolderRpcRequest(swift: swift)
    }

    /// The current user relinquishes their membership in the designated file. Note that the current user may still have
    /// inherited access to this file through the parent folder.
    ///
    /// - scope: sharing.write
    ///
    /// - parameter file: The path or id for the file.
    ///
    /// - returns: Through the response callback, the caller will receive a `Void` object on success or a
    /// `Sharing.RelinquishFileMembershipError` object on failure.
    @objc
    @discardableResult public func relinquishFileMembership(file: String) -> DBXSharingRelinquishFileMembershipRpcRequest {
        let swift = swift.relinquishFileMembership(file: file)
        return DBXSharingRelinquishFileMembershipRpcRequest(swift: swift)
    }

    /// The current user relinquishes their membership in the designated shared folder and will no longer have access to
    /// the folder.  A folder owner cannot relinquish membership in their own folder. This will run synchronously if
    /// leave_a_copy is false, and asynchronously if leave_a_copy is true.
    ///
    /// - scope: sharing.write
    ///
    /// - parameter sharedFolderId: The ID for the shared folder.
    /// - parameter leaveACopy: Keep a copy of the folder's contents upon relinquishing membership. This must be set to
    /// false when the folder is within a team folder or another shared folder.
    ///
    /// - returns: Through the response callback, the caller will receive a `Async.LaunchEmptyResult` object on success
    /// or a `Sharing.RelinquishFolderMembershipError` object on failure.
    @objc
    @discardableResult public func relinquishFolderMembership(sharedFolderId: String, leaveACopy: NSNumber) -> DBXSharingRelinquishFolderMembershipRpcRequest {
        let swift = swift.relinquishFolderMembership(sharedFolderId: sharedFolderId, leaveACopy: leaveACopy.boolValue)
        return DBXSharingRelinquishFolderMembershipRpcRequest(swift: swift)
    }

    /// The current user relinquishes their membership in the designated shared folder and will no longer have access to
    /// the folder.  A folder owner cannot relinquish membership in their own folder. This will run synchronously if
    /// leave_a_copy is false, and asynchronously if leave_a_copy is true.
    ///
    /// - scope: sharing.write
    ///
    /// - returns: Through the response callback, the caller will receive a `Async.LaunchEmptyResult` object on success
    /// or a `Sharing.RelinquishFolderMembershipError` object on failure.
    @objc
    @discardableResult public func relinquishFolderMembership(sharedFolderId: String) -> DBXSharingRelinquishFolderMembershipRpcRequest {
        let swift = swift.relinquishFolderMembership(sharedFolderId: sharedFolderId)
        return DBXSharingRelinquishFolderMembershipRpcRequest(swift: swift)
    }

    /// Removes a specified member from the file.
    ///
    /// - scope: sharing.write
    ///
    /// - parameter file: File from which to remove members.
    /// - parameter member: Member to remove from this file. Note that even if an email is specified, it may result in
    /// the removal of a user (not an invitee) if the user's main account corresponds to that email address.
    ///
    /// - returns: Through the response callback, the caller will receive a `Sharing.FileMemberRemoveActionResult`
    /// object on success or a `Sharing.RemoveFileMemberError` object on failure.
    @objc
    @discardableResult public func removeFileMember2(file: String, member: DBXSharingMemberSelector) -> DBXSharingRemoveFileMember2RpcRequest {
        let swift = swift.removeFileMember2(file: file, member: member.swift)
        return DBXSharingRemoveFileMember2RpcRequest(swift: swift)
    }

    /// Allows an owner or editor (if the ACL update policy allows) of a shared folder to remove another member.
    ///
    /// - scope: sharing.write
    ///
    /// - parameter sharedFolderId: The ID for the shared folder.
    /// - parameter member: The member to remove from the folder.
    /// - parameter leaveACopy: If true, the removed user will keep their copy of the folder after it's unshared,
    /// assuming it was mounted. Otherwise, it will be removed from their Dropbox. This must be set to false when
    /// removing a group, or when the folder is within a team folder or another shared folder.
    ///
    /// - returns: Through the response callback, the caller will receive a `Async.LaunchResultBase` object on success
    /// or a `Sharing.RemoveFolderMemberError` object on failure.
    @objc
    @discardableResult public func removeFolderMember(
        sharedFolderId: String,
        member: DBXSharingMemberSelector,
        leaveACopy: NSNumber
    ) -> DBXSharingRemoveFolderMemberRpcRequest {
        let swift = swift.removeFolderMember(sharedFolderId: sharedFolderId, member: member.swift, leaveACopy: leaveACopy.boolValue)
        return DBXSharingRemoveFolderMemberRpcRequest(swift: swift)
    }

    /// Revoke a shared link. Note that even after revoking a shared link to a file, the file may be accessible if there
    /// are shared links leading to any of the file parent folders. To list all shared links that enable access to a
    /// specific file, you can use the listSharedLinks with the file as the path in ListSharedLinksArg argument.
    ///
    /// - scope: sharing.write
    ///
    /// - parameter url: URL of the shared link.
    ///
    /// - returns: Through the response callback, the caller will receive a `Void` object on success or a
    /// `Sharing.RevokeSharedLinkError` object on failure.
    @objc
    @discardableResult public func revokeSharedLink(url: String) -> DBXSharingRevokeSharedLinkRpcRequest {
        let swift = swift.revokeSharedLink(url: url)
        return DBXSharingRevokeSharedLinkRpcRequest(swift: swift)
    }

    /// Change the inheritance policy of an existing Shared Folder. Only permitted for shared folders in a shared team
    /// root. If a asyncJobId in ShareFolderLaunch is returned, you'll need to call checkShareJobStatus until the
    /// action completes to get the metadata for the folder.
    ///
    /// - scope: sharing.write
    ///
    /// - parameter accessInheritance: The access inheritance settings for the folder.
    /// - parameter sharedFolderId: The ID for the shared folder.
    ///
    /// - returns: Through the response callback, the caller will receive a `Sharing.ShareFolderLaunch` object on
    /// success or a `Sharing.SetAccessInheritanceError` object on failure.
    @objc
    @discardableResult public func setAccessInheritance(
        sharedFolderId: String,
        accessInheritance: DBXSharingAccessInheritance
    ) -> DBXSharingSetAccessInheritanceRpcRequest {
        let swift = swift.setAccessInheritance(sharedFolderId: sharedFolderId, accessInheritance: accessInheritance.swift)
        return DBXSharingSetAccessInheritanceRpcRequest(swift: swift)
    }

    /// Change the inheritance policy of an existing Shared Folder. Only permitted for shared folders in a shared team
    /// root. If a asyncJobId in ShareFolderLaunch is returned, you'll need to call checkShareJobStatus until the
    /// action completes to get the metadata for the folder.
    ///
    /// - scope: sharing.write
    ///
    /// - returns: Through the response callback, the caller will receive a `Sharing.ShareFolderLaunch` object on
    /// success or a `Sharing.SetAccessInheritanceError` object on failure.
    @objc
    @discardableResult public func setAccessInheritance(sharedFolderId: String) -> DBXSharingSetAccessInheritanceRpcRequest {
        let swift = swift.setAccessInheritance(sharedFolderId: sharedFolderId)
        return DBXSharingSetAccessInheritanceRpcRequest(swift: swift)
    }

    /// Share a folder with collaborators. Most sharing will be completed synchronously. Large folders will be completed
    /// asynchronously. To make testing the async case repeatable, set `ShareFolderArg.force_async`. If a asyncJobId
    /// in ShareFolderLaunch is returned, you'll need to call checkShareJobStatus until the action completes to get
    /// the metadata for the folder.
    ///
    /// - scope: sharing.write
    ///
    /// - parameter actions: A list of `FolderAction`s corresponding to `FolderPermission`s that should appear in the
    /// response's permissions in SharedFolderMetadata field describing the actions the  authenticated user can
    /// perform on the folder.
    /// - parameter linkSettings: Settings on the link for this folder.
    ///
    /// - returns: Through the response callback, the caller will receive a `Sharing.ShareFolderLaunch` object on
    /// success or a `Sharing.ShareFolderError` object on failure.
    @objc
    @discardableResult public func shareFolder(
        path: String,
        aclUpdatePolicy: DBXSharingAclUpdatePolicy?,
        forceAsync: NSNumber,
        memberPolicy: DBXSharingMemberPolicy?,
        sharedLinkPolicy: DBXSharingSharedLinkPolicy?,
        viewerInfoPolicy: DBXSharingViewerInfoPolicy?,
        accessInheritance: DBXSharingAccessInheritance,
        actions: [DBXSharingFolderAction]?,
        linkSettings: DBXSharingLinkSettings?
    ) -> DBXSharingShareFolderRpcRequest {
        let swift = swift.shareFolder(
            path: path,
            aclUpdatePolicy: aclUpdatePolicy?.swift,
            forceAsync: forceAsync.boolValue,
            memberPolicy: memberPolicy?.swift,
            sharedLinkPolicy: sharedLinkPolicy?.swift,
            viewerInfoPolicy: viewerInfoPolicy?.swift,
            accessInheritance: accessInheritance.swift,
            actions: actions?.map(\.swift),
            linkSettings: linkSettings?.swift
        )
        return DBXSharingShareFolderRpcRequest(swift: swift)
    }

    /// Share a folder with collaborators. Most sharing will be completed synchronously. Large folders will be completed
    /// asynchronously. To make testing the async case repeatable, set `ShareFolderArg.force_async`. If a asyncJobId
    /// in ShareFolderLaunch is returned, you'll need to call checkShareJobStatus until the action completes to get
    /// the metadata for the folder.
    ///
    /// - scope: sharing.write
    ///
    /// - returns: Through the response callback, the caller will receive a `Sharing.ShareFolderLaunch` object on
    /// success or a `Sharing.ShareFolderError` object on failure.
    @objc
    @discardableResult public func shareFolder(path: String) -> DBXSharingShareFolderRpcRequest {
        let swift = swift.shareFolder(path: path)
        return DBXSharingShareFolderRpcRequest(swift: swift)
    }

    /// Transfer ownership of a shared folder to a member of the shared folder. User must have owner in AccessLevel
    /// access to the shared folder to perform a transfer.
    ///
    /// - scope: sharing.write
    ///
    /// - parameter sharedFolderId: The ID for the shared folder.
    /// - parameter toDropboxId: A account or team member ID to transfer ownership to.
    ///
    /// - returns: Through the response callback, the caller will receive a `Void` object on success or a
    /// `Sharing.TransferFolderError` object on failure.
    @objc
    @discardableResult public func transferFolder(sharedFolderId: String, toDropboxId: String) -> DBXSharingTransferFolderRpcRequest {
        let swift = swift.transferFolder(sharedFolderId: sharedFolderId, toDropboxId: toDropboxId)
        return DBXSharingTransferFolderRpcRequest(swift: swift)
    }

    /// The current user unmounts the designated folder. They can re-mount the folder at a later time using mountFolder.
    ///
    /// - scope: sharing.write
    ///
    /// - parameter sharedFolderId: The ID for the shared folder.
    ///
    /// - returns: Through the response callback, the caller will receive a `Void` object on success or a
    /// `Sharing.UnmountFolderError` object on failure.
    @objc
    @discardableResult public func unmountFolder(sharedFolderId: String) -> DBXSharingUnmountFolderRpcRequest {
        let swift = swift.unmountFolder(sharedFolderId: sharedFolderId)
        return DBXSharingUnmountFolderRpcRequest(swift: swift)
    }

    /// Remove all members from this file. Does not remove inherited members.
    ///
    /// - scope: sharing.write
    ///
    /// - parameter file: The file to unshare.
    ///
    /// - returns: Through the response callback, the caller will receive a `Void` object on success or a
    /// `Sharing.UnshareFileError` object on failure.
    @objc
    @discardableResult public func unshareFile(file: String) -> DBXSharingUnshareFileRpcRequest {
        let swift = swift.unshareFile(file: file)
        return DBXSharingUnshareFileRpcRequest(swift: swift)
    }

    /// Allows a shared folder owner to unshare the folder. You'll need to call checkJobStatus to determine if the
    /// action has completed successfully.
    ///
    /// - scope: sharing.write
    ///
    /// - parameter sharedFolderId: The ID for the shared folder.
    /// - parameter leaveACopy: If true, members of this shared folder will get a copy of this folder after it's
    /// unshared. Otherwise, it will be removed from their Dropbox. The current user, who is an owner, will always
    /// retain their copy.
    ///
    /// - returns: Through the response callback, the caller will receive a `Async.LaunchEmptyResult` object on success
    /// or a `Sharing.UnshareFolderError` object on failure.
    @objc
    @discardableResult public func unshareFolder(sharedFolderId: String, leaveACopy: NSNumber) -> DBXSharingUnshareFolderRpcRequest {
        let swift = swift.unshareFolder(sharedFolderId: sharedFolderId, leaveACopy: leaveACopy.boolValue)
        return DBXSharingUnshareFolderRpcRequest(swift: swift)
    }

    /// Allows a shared folder owner to unshare the folder. You'll need to call checkJobStatus to determine if the
    /// action has completed successfully.
    ///
    /// - scope: sharing.write
    ///
    /// - returns: Through the response callback, the caller will receive a `Async.LaunchEmptyResult` object on success
    /// or a `Sharing.UnshareFolderError` object on failure.
    @objc
    @discardableResult public func unshareFolder(sharedFolderId: String) -> DBXSharingUnshareFolderRpcRequest {
        let swift = swift.unshareFolder(sharedFolderId: sharedFolderId)
        return DBXSharingUnshareFolderRpcRequest(swift: swift)
    }

    /// Changes a member's access on a shared file.
    ///
    /// - scope: sharing.write
    ///
    /// - parameter file: File for which we are changing a member's access.
    /// - parameter member: The member whose access we are changing.
    /// - parameter accessLevel: The new access level for the member.
    ///
    /// - returns: Through the response callback, the caller will receive a `Sharing.MemberAccessLevelResult` object on
    /// success or a `Sharing.FileMemberActionError` object on failure.
    @objc
    @discardableResult public func updateFileMember(
        file: String,
        member: DBXSharingMemberSelector,
        accessLevel: DBXSharingAccessLevel
    ) -> DBXSharingUpdateFileMemberRpcRequest {
        let swift = swift.updateFileMember(file: file, member: member.swift, accessLevel: accessLevel.swift)
        return DBXSharingUpdateFileMemberRpcRequest(swift: swift)
    }

    /// Allows an owner or editor of a shared folder to update another member's permissions.
    ///
    /// - scope: sharing.write
    ///
    /// - parameter sharedFolderId: The ID for the shared folder.
    /// - parameter member: The member of the shared folder to update.  Only the dropboxId in MemberSelector may be set
    /// at this time.
    /// - parameter accessLevel: The new access level for member. owner in AccessLevel is disallowed.
    ///
    /// - returns: Through the response callback, the caller will receive a `Sharing.MemberAccessLevelResult` object on
    /// success or a `Sharing.UpdateFolderMemberError` object on failure.
    @objc
    @discardableResult public func updateFolderMember(
        sharedFolderId: String,
        member: DBXSharingMemberSelector,
        accessLevel: DBXSharingAccessLevel
    ) -> DBXSharingUpdateFolderMemberRpcRequest {
        let swift = swift.updateFolderMember(sharedFolderId: sharedFolderId, member: member.swift, accessLevel: accessLevel.swift)
        return DBXSharingUpdateFolderMemberRpcRequest(swift: swift)
    }

    /// Update the sharing policies for a shared folder. User must have owner in AccessLevel access to the shared folder
    /// to update its policies.
    ///
    /// - scope: sharing.write
    ///
    /// - parameter sharedFolderId: The ID for the shared folder.
    /// - parameter memberPolicy: Who can be a member of this shared folder. Only applicable if the current user is on a
    /// team.
    /// - parameter aclUpdatePolicy: Who can add and remove members of this shared folder.
    /// - parameter viewerInfoPolicy: Who can enable/disable viewer info for this shared folder.
    /// - parameter sharedLinkPolicy: The policy to apply to shared links created for content inside this shared folder.
    /// The current user must be on a team to set this policy to members in SharedLinkPolicy.
    /// - parameter linkSettings: Settings on the link for this folder.
    /// - parameter actions: A list of `FolderAction`s corresponding to `FolderPermission`s that should appear in the
    /// response's permissions in SharedFolderMetadata field describing the actions the  authenticated user can
    /// perform on the folder.
    ///
    /// - returns: Through the response callback, the caller will receive a `Sharing.SharedFolderMetadata` object on
    /// success or a `Sharing.UpdateFolderPolicyError` object on failure.
    @objc
    @discardableResult public func updateFolderPolicy(
        sharedFolderId: String,
        memberPolicy: DBXSharingMemberPolicy?,
        aclUpdatePolicy: DBXSharingAclUpdatePolicy?,
        viewerInfoPolicy: DBXSharingViewerInfoPolicy?,
        sharedLinkPolicy: DBXSharingSharedLinkPolicy?,
        linkSettings: DBXSharingLinkSettings?,
        actions: [DBXSharingFolderAction]?
    ) -> DBXSharingUpdateFolderPolicyRpcRequest {
        let swift = swift.updateFolderPolicy(
            sharedFolderId: sharedFolderId,
            memberPolicy: memberPolicy?.swift,
            aclUpdatePolicy: aclUpdatePolicy?.swift,
            viewerInfoPolicy: viewerInfoPolicy?.swift,
            sharedLinkPolicy: sharedLinkPolicy?.swift,
            linkSettings: linkSettings?.swift,
            actions: actions?.map(\.swift)
        )
        return DBXSharingUpdateFolderPolicyRpcRequest(swift: swift)
    }

    /// Update the sharing policies for a shared folder. User must have owner in AccessLevel access to the shared folder
    /// to update its policies.
    ///
    /// - scope: sharing.write
    ///
    /// - returns: Through the response callback, the caller will receive a `Sharing.SharedFolderMetadata` object on
    /// success or a `Sharing.UpdateFolderPolicyError` object on failure.
    @objc
    @discardableResult public func updateFolderPolicy(sharedFolderId: String) -> DBXSharingUpdateFolderPolicyRpcRequest {
        let swift = swift.updateFolderPolicy(sharedFolderId: sharedFolderId)
        return DBXSharingUpdateFolderPolicyRpcRequest(swift: swift)
    }
}

@objc
public class DBXSharingAddFileMemberRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<ArraySerializer<Sharing.FileMemberActionResultSerializer>, Sharing.AddFileMemberErrorSerializer>

    init(swift: RpcRequest<ArraySerializer<Sharing.FileMemberActionResultSerializer>, Sharing.AddFileMemberErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping ([DBXSharingFileMemberActionResult]?, DBXSharingAddFileMemberError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping ([DBXSharingFileMemberActionResult]?, DBXSharingAddFileMemberError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXSharingAddFileMemberError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXSharingAddFileMemberError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: [DBXSharingFileMemberActionResult]?
            if let swift = result {
                objc = swift.map { DBXSharingFileMemberActionResult(swift: $0) }
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXSharingAddFolderMemberRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<VoidSerializer, Sharing.AddFolderMemberErrorSerializer>

    init(swift: RpcRequest<VoidSerializer, Sharing.AddFolderMemberErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXSharingAddFolderMemberError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXSharingAddFolderMemberError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { _, error in
            var routeError: DBXSharingAddFolderMemberError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXSharingAddFolderMemberError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            completionHandler(routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXSharingCheckJobStatusRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Sharing.JobStatusSerializer, Async.PollErrorSerializer>

    init(swift: RpcRequest<Sharing.JobStatusSerializer, Async.PollErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXSharingJobStatus?, DBXAsyncPollError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXSharingJobStatus?, DBXAsyncPollError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXAsyncPollError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXAsyncPollError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXSharingJobStatus?
            if let swift = result {
                objc = DBXSharingJobStatus.factory(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXSharingCheckRemoveMemberJobStatusRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Sharing.RemoveMemberJobStatusSerializer, Async.PollErrorSerializer>

    init(swift: RpcRequest<Sharing.RemoveMemberJobStatusSerializer, Async.PollErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXSharingRemoveMemberJobStatus?, DBXAsyncPollError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXSharingRemoveMemberJobStatus?, DBXAsyncPollError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXAsyncPollError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXAsyncPollError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXSharingRemoveMemberJobStatus?
            if let swift = result {
                objc = DBXSharingRemoveMemberJobStatus.factory(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXSharingCheckShareJobStatusRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Sharing.ShareFolderJobStatusSerializer, Async.PollErrorSerializer>

    init(swift: RpcRequest<Sharing.ShareFolderJobStatusSerializer, Async.PollErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXSharingShareFolderJobStatus?, DBXAsyncPollError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXSharingShareFolderJobStatus?, DBXAsyncPollError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXAsyncPollError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXAsyncPollError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXSharingShareFolderJobStatus?
            if let swift = result {
                objc = DBXSharingShareFolderJobStatus.factory(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXSharingCreateSharedLinkRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Sharing.PathLinkMetadataSerializer, Sharing.CreateSharedLinkErrorSerializer>

    init(swift: RpcRequest<Sharing.PathLinkMetadataSerializer, Sharing.CreateSharedLinkErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXSharingPathLinkMetadata?, DBXSharingCreateSharedLinkError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXSharingPathLinkMetadata?, DBXSharingCreateSharedLinkError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXSharingCreateSharedLinkError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXSharingCreateSharedLinkError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXSharingPathLinkMetadata?
            if let swift = result {
                objc = DBXSharingPathLinkMetadata(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXSharingCreateSharedLinkWithSettingsRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Sharing.SharedLinkMetadataSerializer, Sharing.CreateSharedLinkWithSettingsErrorSerializer>

    init(swift: RpcRequest<Sharing.SharedLinkMetadataSerializer, Sharing.CreateSharedLinkWithSettingsErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXSharingSharedLinkMetadata?, DBXSharingCreateSharedLinkWithSettingsError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXSharingSharedLinkMetadata?, DBXSharingCreateSharedLinkWithSettingsError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXSharingCreateSharedLinkWithSettingsError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXSharingCreateSharedLinkWithSettingsError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXSharingSharedLinkMetadata?
            if let swift = result {
                objc = DBXSharingSharedLinkMetadata.wrapPreservingSubtypes(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXSharingGetFileMetadataRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Sharing.SharedFileMetadataSerializer, Sharing.GetFileMetadataErrorSerializer>

    init(swift: RpcRequest<Sharing.SharedFileMetadataSerializer, Sharing.GetFileMetadataErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXSharingSharedFileMetadata?, DBXSharingGetFileMetadataError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXSharingSharedFileMetadata?, DBXSharingGetFileMetadataError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXSharingGetFileMetadataError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXSharingGetFileMetadataError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXSharingSharedFileMetadata?
            if let swift = result {
                objc = DBXSharingSharedFileMetadata(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXSharingGetFileMetadataBatchRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<ArraySerializer<Sharing.GetFileMetadataBatchResultSerializer>, Sharing.SharingUserErrorSerializer>

    init(swift: RpcRequest<ArraySerializer<Sharing.GetFileMetadataBatchResultSerializer>, Sharing.SharingUserErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping ([DBXSharingGetFileMetadataBatchResult]?, DBXSharingSharingUserError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping ([DBXSharingGetFileMetadataBatchResult]?, DBXSharingSharingUserError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXSharingSharingUserError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXSharingSharingUserError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: [DBXSharingGetFileMetadataBatchResult]?
            if let swift = result {
                objc = swift.map { DBXSharingGetFileMetadataBatchResult(swift: $0) }
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXSharingGetFolderMetadataRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Sharing.SharedFolderMetadataSerializer, Sharing.SharedFolderAccessErrorSerializer>

    init(swift: RpcRequest<Sharing.SharedFolderMetadataSerializer, Sharing.SharedFolderAccessErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXSharingSharedFolderMetadata?, DBXSharingSharedFolderAccessError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXSharingSharedFolderMetadata?, DBXSharingSharedFolderAccessError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXSharingSharedFolderAccessError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXSharingSharedFolderAccessError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXSharingSharedFolderMetadata?
            if let swift = result {
                objc = DBXSharingSharedFolderMetadata(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXSharingGetSharedLinkFileDownloadRequestFile: NSObject, DBXRequest {
    var swift: DownloadRequestFile<Sharing.SharedLinkMetadataSerializer, Sharing.GetSharedLinkFileErrorSerializer>

    init(swift: DownloadRequestFile<Sharing.SharedLinkMetadataSerializer, Sharing.GetSharedLinkFileErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXSharingSharedLinkMetadata?, URL?, DBXSharingGetSharedLinkFileError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXSharingSharedLinkMetadata?, URL?, DBXSharingGetSharedLinkFileError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXSharingGetSharedLinkFileError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXSharingGetSharedLinkFileError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXSharingSharedLinkMetadata?
            var destination: URL?
            if let swift = result {
                objc = DBXSharingSharedLinkMetadata.wrapPreservingSubtypes(swift: swift.0)
                destination = swift.1
            }
            completionHandler(objc, destination, routeError, callError)
        }
        return self
    }

    @objc
    public func progress(_ progressHandler: @escaping ((Progress) -> Void)) -> Self {
        swift.progress(progressHandler)
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXSharingGetSharedLinkFileDownloadRequestMemory: NSObject, DBXRequest {
    var swift: DownloadRequestMemory<Sharing.SharedLinkMetadataSerializer, Sharing.GetSharedLinkFileErrorSerializer>

    init(swift: DownloadRequestMemory<Sharing.SharedLinkMetadataSerializer, Sharing.GetSharedLinkFileErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXSharingSharedLinkMetadata?, Data?, DBXSharingGetSharedLinkFileError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXSharingSharedLinkMetadata?, Data?, DBXSharingGetSharedLinkFileError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXSharingGetSharedLinkFileError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXSharingGetSharedLinkFileError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXSharingSharedLinkMetadata?
            var destination: Data?
            if let swift = result {
                objc = DBXSharingSharedLinkMetadata.wrapPreservingSubtypes(swift: swift.0)
                destination = swift.1
            }
            completionHandler(objc, destination, routeError, callError)
        }
        return self
    }

    @objc
    public func progress(_ progressHandler: @escaping ((Progress) -> Void)) -> Self {
        swift.progress(progressHandler)
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXSharingGetSharedLinkMetadataRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Sharing.SharedLinkMetadataSerializer, Sharing.SharedLinkErrorSerializer>

    init(swift: RpcRequest<Sharing.SharedLinkMetadataSerializer, Sharing.SharedLinkErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXSharingSharedLinkMetadata?, DBXSharingSharedLinkError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXSharingSharedLinkMetadata?, DBXSharingSharedLinkError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXSharingSharedLinkError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXSharingSharedLinkError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXSharingSharedLinkMetadata?
            if let swift = result {
                objc = DBXSharingSharedLinkMetadata.wrapPreservingSubtypes(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXSharingGetSharedLinksRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Sharing.GetSharedLinksResultSerializer, Sharing.GetSharedLinksErrorSerializer>

    init(swift: RpcRequest<Sharing.GetSharedLinksResultSerializer, Sharing.GetSharedLinksErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXSharingGetSharedLinksResult?, DBXSharingGetSharedLinksError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXSharingGetSharedLinksResult?, DBXSharingGetSharedLinksError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXSharingGetSharedLinksError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXSharingGetSharedLinksError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXSharingGetSharedLinksResult?
            if let swift = result {
                objc = DBXSharingGetSharedLinksResult(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXSharingListFileMembersRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Sharing.SharedFileMembersSerializer, Sharing.ListFileMembersErrorSerializer>

    init(swift: RpcRequest<Sharing.SharedFileMembersSerializer, Sharing.ListFileMembersErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXSharingSharedFileMembers?, DBXSharingListFileMembersError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXSharingSharedFileMembers?, DBXSharingListFileMembersError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXSharingListFileMembersError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXSharingListFileMembersError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXSharingSharedFileMembers?
            if let swift = result {
                objc = DBXSharingSharedFileMembers(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXSharingListFileMembersBatchRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<ArraySerializer<Sharing.ListFileMembersBatchResultSerializer>, Sharing.SharingUserErrorSerializer>

    init(swift: RpcRequest<ArraySerializer<Sharing.ListFileMembersBatchResultSerializer>, Sharing.SharingUserErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping ([DBXSharingListFileMembersBatchResult]?, DBXSharingSharingUserError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping ([DBXSharingListFileMembersBatchResult]?, DBXSharingSharingUserError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXSharingSharingUserError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXSharingSharingUserError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: [DBXSharingListFileMembersBatchResult]?
            if let swift = result {
                objc = swift.map { DBXSharingListFileMembersBatchResult(swift: $0) }
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXSharingListFileMembersContinueRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Sharing.SharedFileMembersSerializer, Sharing.ListFileMembersContinueErrorSerializer>

    init(swift: RpcRequest<Sharing.SharedFileMembersSerializer, Sharing.ListFileMembersContinueErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXSharingSharedFileMembers?, DBXSharingListFileMembersContinueError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXSharingSharedFileMembers?, DBXSharingListFileMembersContinueError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXSharingListFileMembersContinueError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXSharingListFileMembersContinueError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXSharingSharedFileMembers?
            if let swift = result {
                objc = DBXSharingSharedFileMembers(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXSharingListFolderMembersRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Sharing.SharedFolderMembersSerializer, Sharing.SharedFolderAccessErrorSerializer>

    init(swift: RpcRequest<Sharing.SharedFolderMembersSerializer, Sharing.SharedFolderAccessErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXSharingSharedFolderMembers?, DBXSharingSharedFolderAccessError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXSharingSharedFolderMembers?, DBXSharingSharedFolderAccessError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXSharingSharedFolderAccessError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXSharingSharedFolderAccessError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXSharingSharedFolderMembers?
            if let swift = result {
                objc = DBXSharingSharedFolderMembers(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXSharingListFolderMembersContinueRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Sharing.SharedFolderMembersSerializer, Sharing.ListFolderMembersContinueErrorSerializer>

    init(swift: RpcRequest<Sharing.SharedFolderMembersSerializer, Sharing.ListFolderMembersContinueErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXSharingSharedFolderMembers?, DBXSharingListFolderMembersContinueError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXSharingSharedFolderMembers?, DBXSharingListFolderMembersContinueError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXSharingListFolderMembersContinueError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXSharingListFolderMembersContinueError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXSharingSharedFolderMembers?
            if let swift = result {
                objc = DBXSharingSharedFolderMembers(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXSharingListFoldersRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Sharing.ListFoldersResultSerializer, VoidSerializer>

    init(swift: RpcRequest<Sharing.ListFoldersResultSerializer, VoidSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXSharingListFoldersResult?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXSharingListFoldersResult?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var objc: DBXSharingListFoldersResult?
            if let swift = result {
                objc = DBXSharingListFoldersResult(swift: swift)
            }
            completionHandler(objc, error?.objc)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXSharingListFoldersContinueRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Sharing.ListFoldersResultSerializer, Sharing.ListFoldersContinueErrorSerializer>

    init(swift: RpcRequest<Sharing.ListFoldersResultSerializer, Sharing.ListFoldersContinueErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXSharingListFoldersResult?, DBXSharingListFoldersContinueError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXSharingListFoldersResult?, DBXSharingListFoldersContinueError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXSharingListFoldersContinueError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXSharingListFoldersContinueError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXSharingListFoldersResult?
            if let swift = result {
                objc = DBXSharingListFoldersResult(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXSharingListMountableFoldersRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Sharing.ListFoldersResultSerializer, VoidSerializer>

    init(swift: RpcRequest<Sharing.ListFoldersResultSerializer, VoidSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXSharingListFoldersResult?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXSharingListFoldersResult?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var objc: DBXSharingListFoldersResult?
            if let swift = result {
                objc = DBXSharingListFoldersResult(swift: swift)
            }
            completionHandler(objc, error?.objc)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXSharingListMountableFoldersContinueRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Sharing.ListFoldersResultSerializer, Sharing.ListFoldersContinueErrorSerializer>

    init(swift: RpcRequest<Sharing.ListFoldersResultSerializer, Sharing.ListFoldersContinueErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXSharingListFoldersResult?, DBXSharingListFoldersContinueError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXSharingListFoldersResult?, DBXSharingListFoldersContinueError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXSharingListFoldersContinueError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXSharingListFoldersContinueError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXSharingListFoldersResult?
            if let swift = result {
                objc = DBXSharingListFoldersResult(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXSharingListReceivedFilesRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Sharing.ListFilesResultSerializer, Sharing.SharingUserErrorSerializer>

    init(swift: RpcRequest<Sharing.ListFilesResultSerializer, Sharing.SharingUserErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXSharingListFilesResult?, DBXSharingSharingUserError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXSharingListFilesResult?, DBXSharingSharingUserError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXSharingSharingUserError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXSharingSharingUserError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXSharingListFilesResult?
            if let swift = result {
                objc = DBXSharingListFilesResult(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXSharingListReceivedFilesContinueRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Sharing.ListFilesResultSerializer, Sharing.ListFilesContinueErrorSerializer>

    init(swift: RpcRequest<Sharing.ListFilesResultSerializer, Sharing.ListFilesContinueErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXSharingListFilesResult?, DBXSharingListFilesContinueError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXSharingListFilesResult?, DBXSharingListFilesContinueError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXSharingListFilesContinueError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXSharingListFilesContinueError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXSharingListFilesResult?
            if let swift = result {
                objc = DBXSharingListFilesResult(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXSharingListSharedLinksRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Sharing.ListSharedLinksResultSerializer, Sharing.ListSharedLinksErrorSerializer>

    init(swift: RpcRequest<Sharing.ListSharedLinksResultSerializer, Sharing.ListSharedLinksErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXSharingListSharedLinksResult?, DBXSharingListSharedLinksError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXSharingListSharedLinksResult?, DBXSharingListSharedLinksError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXSharingListSharedLinksError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXSharingListSharedLinksError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXSharingListSharedLinksResult?
            if let swift = result {
                objc = DBXSharingListSharedLinksResult(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXSharingModifySharedLinkSettingsRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Sharing.SharedLinkMetadataSerializer, Sharing.ModifySharedLinkSettingsErrorSerializer>

    init(swift: RpcRequest<Sharing.SharedLinkMetadataSerializer, Sharing.ModifySharedLinkSettingsErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXSharingSharedLinkMetadata?, DBXSharingModifySharedLinkSettingsError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXSharingSharedLinkMetadata?, DBXSharingModifySharedLinkSettingsError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXSharingModifySharedLinkSettingsError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXSharingModifySharedLinkSettingsError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXSharingSharedLinkMetadata?
            if let swift = result {
                objc = DBXSharingSharedLinkMetadata.wrapPreservingSubtypes(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXSharingMountFolderRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Sharing.SharedFolderMetadataSerializer, Sharing.MountFolderErrorSerializer>

    init(swift: RpcRequest<Sharing.SharedFolderMetadataSerializer, Sharing.MountFolderErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXSharingSharedFolderMetadata?, DBXSharingMountFolderError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXSharingSharedFolderMetadata?, DBXSharingMountFolderError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXSharingMountFolderError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXSharingMountFolderError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXSharingSharedFolderMetadata?
            if let swift = result {
                objc = DBXSharingSharedFolderMetadata(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXSharingRelinquishFileMembershipRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<VoidSerializer, Sharing.RelinquishFileMembershipErrorSerializer>

    init(swift: RpcRequest<VoidSerializer, Sharing.RelinquishFileMembershipErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXSharingRelinquishFileMembershipError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXSharingRelinquishFileMembershipError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { _, error in
            var routeError: DBXSharingRelinquishFileMembershipError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXSharingRelinquishFileMembershipError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            completionHandler(routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXSharingRelinquishFolderMembershipRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Async.LaunchEmptyResultSerializer, Sharing.RelinquishFolderMembershipErrorSerializer>

    init(swift: RpcRequest<Async.LaunchEmptyResultSerializer, Sharing.RelinquishFolderMembershipErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXAsyncLaunchEmptyResult?, DBXSharingRelinquishFolderMembershipError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXAsyncLaunchEmptyResult?, DBXSharingRelinquishFolderMembershipError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXSharingRelinquishFolderMembershipError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXSharingRelinquishFolderMembershipError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXAsyncLaunchEmptyResult?
            if let swift = result {
                objc = DBXAsyncLaunchEmptyResult.factory(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXSharingRemoveFileMemberRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Sharing.FileMemberActionIndividualResultSerializer, Sharing.RemoveFileMemberErrorSerializer>

    init(swift: RpcRequest<Sharing.FileMemberActionIndividualResultSerializer, Sharing.RemoveFileMemberErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXSharingFileMemberActionIndividualResult?, DBXSharingRemoveFileMemberError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXSharingFileMemberActionIndividualResult?, DBXSharingRemoveFileMemberError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXSharingRemoveFileMemberError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXSharingRemoveFileMemberError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXSharingFileMemberActionIndividualResult?
            if let swift = result {
                objc = DBXSharingFileMemberActionIndividualResult.factory(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXSharingRemoveFileMember2RpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Sharing.FileMemberRemoveActionResultSerializer, Sharing.RemoveFileMemberErrorSerializer>

    init(swift: RpcRequest<Sharing.FileMemberRemoveActionResultSerializer, Sharing.RemoveFileMemberErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXSharingFileMemberRemoveActionResult?, DBXSharingRemoveFileMemberError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXSharingFileMemberRemoveActionResult?, DBXSharingRemoveFileMemberError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXSharingRemoveFileMemberError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXSharingRemoveFileMemberError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXSharingFileMemberRemoveActionResult?
            if let swift = result {
                objc = DBXSharingFileMemberRemoveActionResult.factory(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXSharingRemoveFolderMemberRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Async.LaunchResultBaseSerializer, Sharing.RemoveFolderMemberErrorSerializer>

    init(swift: RpcRequest<Async.LaunchResultBaseSerializer, Sharing.RemoveFolderMemberErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXAsyncLaunchResultBase?, DBXSharingRemoveFolderMemberError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXAsyncLaunchResultBase?, DBXSharingRemoveFolderMemberError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXSharingRemoveFolderMemberError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXSharingRemoveFolderMemberError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXAsyncLaunchResultBase?
            if let swift = result {
                objc = DBXAsyncLaunchResultBase.factory(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXSharingRevokeSharedLinkRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<VoidSerializer, Sharing.RevokeSharedLinkErrorSerializer>

    init(swift: RpcRequest<VoidSerializer, Sharing.RevokeSharedLinkErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXSharingRevokeSharedLinkError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXSharingRevokeSharedLinkError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { _, error in
            var routeError: DBXSharingRevokeSharedLinkError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXSharingRevokeSharedLinkError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            completionHandler(routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXSharingSetAccessInheritanceRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Sharing.ShareFolderLaunchSerializer, Sharing.SetAccessInheritanceErrorSerializer>

    init(swift: RpcRequest<Sharing.ShareFolderLaunchSerializer, Sharing.SetAccessInheritanceErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXSharingShareFolderLaunch?, DBXSharingSetAccessInheritanceError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXSharingShareFolderLaunch?, DBXSharingSetAccessInheritanceError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXSharingSetAccessInheritanceError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXSharingSetAccessInheritanceError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXSharingShareFolderLaunch?
            if let swift = result {
                objc = DBXSharingShareFolderLaunch.factory(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXSharingShareFolderRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Sharing.ShareFolderLaunchSerializer, Sharing.ShareFolderErrorSerializer>

    init(swift: RpcRequest<Sharing.ShareFolderLaunchSerializer, Sharing.ShareFolderErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXSharingShareFolderLaunch?, DBXSharingShareFolderError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXSharingShareFolderLaunch?, DBXSharingShareFolderError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXSharingShareFolderError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXSharingShareFolderError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXSharingShareFolderLaunch?
            if let swift = result {
                objc = DBXSharingShareFolderLaunch.factory(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXSharingTransferFolderRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<VoidSerializer, Sharing.TransferFolderErrorSerializer>

    init(swift: RpcRequest<VoidSerializer, Sharing.TransferFolderErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXSharingTransferFolderError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXSharingTransferFolderError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { _, error in
            var routeError: DBXSharingTransferFolderError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXSharingTransferFolderError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            completionHandler(routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXSharingUnmountFolderRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<VoidSerializer, Sharing.UnmountFolderErrorSerializer>

    init(swift: RpcRequest<VoidSerializer, Sharing.UnmountFolderErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXSharingUnmountFolderError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXSharingUnmountFolderError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { _, error in
            var routeError: DBXSharingUnmountFolderError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXSharingUnmountFolderError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            completionHandler(routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXSharingUnshareFileRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<VoidSerializer, Sharing.UnshareFileErrorSerializer>

    init(swift: RpcRequest<VoidSerializer, Sharing.UnshareFileErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXSharingUnshareFileError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXSharingUnshareFileError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { _, error in
            var routeError: DBXSharingUnshareFileError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXSharingUnshareFileError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            completionHandler(routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXSharingUnshareFolderRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Async.LaunchEmptyResultSerializer, Sharing.UnshareFolderErrorSerializer>

    init(swift: RpcRequest<Async.LaunchEmptyResultSerializer, Sharing.UnshareFolderErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXAsyncLaunchEmptyResult?, DBXSharingUnshareFolderError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXAsyncLaunchEmptyResult?, DBXSharingUnshareFolderError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXSharingUnshareFolderError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXSharingUnshareFolderError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXAsyncLaunchEmptyResult?
            if let swift = result {
                objc = DBXAsyncLaunchEmptyResult.factory(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXSharingUpdateFileMemberRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Sharing.MemberAccessLevelResultSerializer, Sharing.FileMemberActionErrorSerializer>

    init(swift: RpcRequest<Sharing.MemberAccessLevelResultSerializer, Sharing.FileMemberActionErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXSharingMemberAccessLevelResult?, DBXSharingFileMemberActionError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXSharingMemberAccessLevelResult?, DBXSharingFileMemberActionError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXSharingFileMemberActionError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXSharingFileMemberActionError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXSharingMemberAccessLevelResult?
            if let swift = result {
                objc = DBXSharingMemberAccessLevelResult(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXSharingUpdateFolderMemberRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Sharing.MemberAccessLevelResultSerializer, Sharing.UpdateFolderMemberErrorSerializer>

    init(swift: RpcRequest<Sharing.MemberAccessLevelResultSerializer, Sharing.UpdateFolderMemberErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXSharingMemberAccessLevelResult?, DBXSharingUpdateFolderMemberError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXSharingMemberAccessLevelResult?, DBXSharingUpdateFolderMemberError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXSharingUpdateFolderMemberError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXSharingUpdateFolderMemberError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXSharingMemberAccessLevelResult?
            if let swift = result {
                objc = DBXSharingMemberAccessLevelResult(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXSharingUpdateFolderPolicyRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Sharing.SharedFolderMetadataSerializer, Sharing.UpdateFolderPolicyErrorSerializer>

    init(swift: RpcRequest<Sharing.SharedFolderMetadataSerializer, Sharing.UpdateFolderPolicyErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXSharingSharedFolderMetadata?, DBXSharingUpdateFolderPolicyError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXSharingSharedFolderMetadata?, DBXSharingUpdateFolderPolicyError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXSharingUpdateFolderPolicyError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXSharingUpdateFolderPolicyError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXSharingSharedFolderMetadata?
            if let swift = result {
                objc = DBXSharingSharedFolderMetadata(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}
