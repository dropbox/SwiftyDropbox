///
/// Copyright (c) 2022 Dropbox, Inc. All rights reserved.
///
/// Auto-generated by Stone, do not modify.
///

import Foundation
import SwiftyDropbox

/// Objective-C compatible routes for the users namespace
/// For Swift routes see UsersRoutes
@objc
public class DBXUsersRoutes: NSObject {
    private let swift: UsersRoutes
    init(swift: UsersRoutes) {
        self.swift = swift
        self.client = swift.client.objc
    }

    public let client: DBXDropboxTransportClient

    /// Get a list of feature values that may be configured for the current account.
    ///
    /// - scope: account_info.read
    ///
    /// - parameter features: A list of features in UserFeature. If the list is empty, this route will return
    /// UserFeaturesGetValuesBatchError.
    ///
    /// - returns: Through the response callback, the caller will receive a `Users.UserFeaturesGetValuesBatchResult`
    /// object on success or a `Users.UserFeaturesGetValuesBatchError` object on failure.
    @objc
    @discardableResult public func featuresGetValues(features: [DBXUsersUserFeature]) -> DBXUsersFeaturesGetValuesRpcRequest {
        let swift = swift.featuresGetValues(features: features.map(\.swift))
        return DBXUsersFeaturesGetValuesRpcRequest(swift: swift)
    }

    /// Get information about a user's account.
    ///
    /// - scope: sharing.read
    ///
    /// - parameter accountId: A user's account identifier.
    ///
    /// - returns: Through the response callback, the caller will receive a `Users.BasicAccount` object on success or a
    /// `Users.GetAccountError` object on failure.
    @objc
    @discardableResult public func getAccount(accountId: String) -> DBXUsersGetAccountRpcRequest {
        let swift = swift.getAccount(accountId: accountId)
        return DBXUsersGetAccountRpcRequest(swift: swift)
    }

    /// Get information about multiple user accounts.  At most 300 accounts may be queried per request.
    ///
    /// - scope: sharing.read
    ///
    /// - parameter accountIds: List of user account identifiers.  Should not contain any duplicate account IDs.
    ///
    /// - returns: Through the response callback, the caller will receive a `Array<Users.BasicAccount>` object on
    /// success or a `Users.GetAccountBatchError` object on failure.
    @objc
    @discardableResult public func getAccountBatch(accountIds: [String]) -> DBXUsersGetAccountBatchRpcRequest {
        let swift = swift.getAccountBatch(accountIds: accountIds)
        return DBXUsersGetAccountBatchRpcRequest(swift: swift)
    }

    /// Get information about the current user's account.
    ///
    /// - scope: account_info.read
    ///
    ///
    /// - returns: Through the response callback, the caller will receive a `Users.FullAccount` object on success or a
    /// `Void` object on failure.
    @objc
    @discardableResult public func getCurrentAccount() -> DBXUsersGetCurrentAccountRpcRequest {
        let swift = swift.getCurrentAccount()
        return DBXUsersGetCurrentAccountRpcRequest(swift: swift)
    }

    /// Get the space usage information for the current user's account.
    ///
    /// - scope: account_info.read
    ///
    ///
    /// - returns: Through the response callback, the caller will receive a `Users.SpaceUsage` object on success or a
    /// `Void` object on failure.
    @objc
    @discardableResult public func getSpaceUsage() -> DBXUsersGetSpaceUsageRpcRequest {
        let swift = swift.getSpaceUsage()
        return DBXUsersGetSpaceUsageRpcRequest(swift: swift)
    }
}

@objc
public class DBXUsersFeaturesGetValuesRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Users.UserFeaturesGetValuesBatchResultSerializer, Users.UserFeaturesGetValuesBatchErrorSerializer>

    init(swift: RpcRequest<Users.UserFeaturesGetValuesBatchResultSerializer, Users.UserFeaturesGetValuesBatchErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXUsersUserFeaturesGetValuesBatchResult?, DBXUsersUserFeaturesGetValuesBatchError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXUsersUserFeaturesGetValuesBatchResult?, DBXUsersUserFeaturesGetValuesBatchError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXUsersUserFeaturesGetValuesBatchError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXUsersUserFeaturesGetValuesBatchError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXUsersUserFeaturesGetValuesBatchResult?
            if let swift = result {
                objc = DBXUsersUserFeaturesGetValuesBatchResult(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXUsersGetAccountRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Users.BasicAccountSerializer, Users.GetAccountErrorSerializer>

    init(swift: RpcRequest<Users.BasicAccountSerializer, Users.GetAccountErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXUsersBasicAccount?, DBXUsersGetAccountError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXUsersBasicAccount?, DBXUsersGetAccountError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXUsersGetAccountError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXUsersGetAccountError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXUsersBasicAccount?
            if let swift = result {
                objc = DBXUsersBasicAccount(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXUsersGetAccountBatchRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<ArraySerializer<Users.BasicAccountSerializer>, Users.GetAccountBatchErrorSerializer>

    init(swift: RpcRequest<ArraySerializer<Users.BasicAccountSerializer>, Users.GetAccountBatchErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping ([DBXUsersBasicAccount]?, DBXUsersGetAccountBatchError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping ([DBXUsersBasicAccount]?, DBXUsersGetAccountBatchError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXUsersGetAccountBatchError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXUsersGetAccountBatchError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: [DBXUsersBasicAccount]?
            if let swift = result {
                objc = swift.map { DBXUsersBasicAccount(swift: $0) }
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXUsersGetCurrentAccountRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Users.FullAccountSerializer, VoidSerializer>

    init(swift: RpcRequest<Users.FullAccountSerializer, VoidSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXUsersFullAccount?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXUsersFullAccount?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var objc: DBXUsersFullAccount?
            if let swift = result {
                objc = DBXUsersFullAccount(swift: swift)
            }
            completionHandler(objc, error?.objc)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXUsersGetSpaceUsageRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<Users.SpaceUsageSerializer, VoidSerializer>

    init(swift: RpcRequest<Users.SpaceUsageSerializer, VoidSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXUsersSpaceUsage?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXUsersSpaceUsage?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var objc: DBXUsersSpaceUsage?
            if let swift = result {
                objc = DBXUsersSpaceUsage(swift: swift)
            }
            completionHandler(objc, error?.objc)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}
