///
/// Copyright (c) 2022 Dropbox, Inc. All rights reserved.
///
/// Auto-generated by Stone, do not modify.
///

import Foundation
import SwiftyDropbox

/// Objective-C compatible datatypes for the paper namespace
/// For Swift see paper

/// Objective-C compatible AddMember struct
@objc
public class DBXPaperAddMember: NSObject {
    /// Permission for the user.
    @objc
    public var permissionLevel: DBXPaperPaperDocPermissionLevel { DBXPaperPaperDocPermissionLevel(swift: swift.permissionLevel) }
    /// User which should be added to the Paper doc. Specify only email address or Dropbox account ID.
    @objc
    public var member: DBXSharingMemberSelector { DBXSharingMemberSelector(swift: swift.member) }

    @objc
    public init(member: DBXSharingMemberSelector, permissionLevel: DBXPaperPaperDocPermissionLevel) {
        self.swift = Paper.AddMember(member: member.swift, permissionLevel: permissionLevel.swift)
    }

    let swift: Paper.AddMember

    public init(swift: Paper.AddMember) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible RefPaperDoc struct
@objc
public class DBXPaperRefPaperDoc: NSObject {
    /// The Paper doc ID.
    @objc
    public var docId: String { swift.docId }

    @objc
    public init(docId: String) {
        self.swift = Paper.RefPaperDoc(docId: docId)
    }

    let swift: Paper.RefPaperDoc

    public init(swift: Paper.RefPaperDoc) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible AddPaperDocUser struct
@objc
public class DBXPaperAddPaperDocUser: DBXPaperRefPaperDoc {
    /// User which should be added to the Paper doc. Specify only email address or Dropbox account ID.
    @objc
    public var members: [DBXPaperAddMember] { subSwift.members.map { DBXPaperAddMember(swift: $0) } }
    /// A personal message that will be emailed to each successfully added member.
    @objc
    public var customMessage: String? { subSwift.customMessage }
    /// Clients should set this to true if no email message shall be sent to added users.
    @objc
    public var quiet: NSNumber { subSwift.quiet as NSNumber }

    @objc
    public init(docId: String, members: [DBXPaperAddMember], customMessage: String?, quiet: NSNumber) {
        let swift = Paper.AddPaperDocUser(docId: docId, members: members.map(\.swift), customMessage: customMessage, quiet: quiet.boolValue)
        self.subSwift = swift
        super.init(swift: swift)
    }

    let subSwift: Paper.AddPaperDocUser

    public init(swift: Paper.AddPaperDocUser) {
        self.subSwift = swift
        super.init(swift: swift)
    }

    @objc
    public override var description: String { subSwift.description }
}

/// Per-member result for docsUsersAdd.
@objc
public class DBXPaperAddPaperDocUserMemberResult: NSObject {
    /// One of specified input members.
    @objc
    public var member: DBXSharingMemberSelector { DBXSharingMemberSelector(swift: swift.member) }
    /// The outcome of the action on this member.
    @objc
    public var result: DBXPaperAddPaperDocUserResult { DBXPaperAddPaperDocUserResult(swift: swift.result) }

    @objc
    public init(member: DBXSharingMemberSelector, result: DBXPaperAddPaperDocUserResult) {
        self.swift = Paper.AddPaperDocUserMemberResult(member: member.swift, result: result.swift)
    }

    let swift: Paper.AddPaperDocUserMemberResult

    public init(swift: Paper.AddPaperDocUserMemberResult) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible AddPaperDocUserResult union
@objc
public class DBXPaperAddPaperDocUserResult: NSObject {
    let swift: Paper.AddPaperDocUserResult

    public init(swift: Paper.AddPaperDocUserResult) {
        self.swift = swift
    }

    public static func factory(swift: Paper.AddPaperDocUserResult) -> DBXPaperAddPaperDocUserResult {
        switch swift {
        case .success:
            return DBXPaperAddPaperDocUserResultSuccess()
        case .unknownError:
            return DBXPaperAddPaperDocUserResultUnknownError()
        case .sharingOutsideTeamDisabled:
            return DBXPaperAddPaperDocUserResultSharingOutsideTeamDisabled()
        case .dailyLimitReached:
            return DBXPaperAddPaperDocUserResultDailyLimitReached()
        case .userIsOwner:
            return DBXPaperAddPaperDocUserResultUserIsOwner()
        case .failedUserDataRetrieval:
            return DBXPaperAddPaperDocUserResultFailedUserDataRetrieval()
        case .permissionAlreadyGranted:
            return DBXPaperAddPaperDocUserResultPermissionAlreadyGranted()
        case .other:
            return DBXPaperAddPaperDocUserResultOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asSuccess: DBXPaperAddPaperDocUserResultSuccess? {
        self as? DBXPaperAddPaperDocUserResultSuccess
    }

    @objc
    public var asUnknownError: DBXPaperAddPaperDocUserResultUnknownError? {
        self as? DBXPaperAddPaperDocUserResultUnknownError
    }

    @objc
    public var asSharingOutsideTeamDisabled: DBXPaperAddPaperDocUserResultSharingOutsideTeamDisabled? {
        self as? DBXPaperAddPaperDocUserResultSharingOutsideTeamDisabled
    }

    @objc
    public var asDailyLimitReached: DBXPaperAddPaperDocUserResultDailyLimitReached? {
        self as? DBXPaperAddPaperDocUserResultDailyLimitReached
    }

    @objc
    public var asUserIsOwner: DBXPaperAddPaperDocUserResultUserIsOwner? {
        self as? DBXPaperAddPaperDocUserResultUserIsOwner
    }

    @objc
    public var asFailedUserDataRetrieval: DBXPaperAddPaperDocUserResultFailedUserDataRetrieval? {
        self as? DBXPaperAddPaperDocUserResultFailedUserDataRetrieval
    }

    @objc
    public var asPermissionAlreadyGranted: DBXPaperAddPaperDocUserResultPermissionAlreadyGranted? {
        self as? DBXPaperAddPaperDocUserResultPermissionAlreadyGranted
    }

    @objc
    public var asOther: DBXPaperAddPaperDocUserResultOther? {
        self as? DBXPaperAddPaperDocUserResultOther
    }
}

/// User was successfully added to the Paper doc.
@objc
public class DBXPaperAddPaperDocUserResultSuccess: DBXPaperAddPaperDocUserResult {
    @objc
    public init() {
        let swift = Paper.AddPaperDocUserResult.success
        super.init(swift: swift)
    }
}

/// Something unexpected happened when trying to add the user to the Paper doc.
@objc
public class DBXPaperAddPaperDocUserResultUnknownError: DBXPaperAddPaperDocUserResult {
    @objc
    public init() {
        let swift = Paper.AddPaperDocUserResult.unknownError
        super.init(swift: swift)
    }
}

/// The Paper doc can be shared only with team members.
@objc
public class DBXPaperAddPaperDocUserResultSharingOutsideTeamDisabled: DBXPaperAddPaperDocUserResult {
    @objc
    public init() {
        let swift = Paper.AddPaperDocUserResult.sharingOutsideTeamDisabled
        super.init(swift: swift)
    }
}

/// The daily limit of how many users can be added to the Paper doc was reached.
@objc
public class DBXPaperAddPaperDocUserResultDailyLimitReached: DBXPaperAddPaperDocUserResult {
    @objc
    public init() {
        let swift = Paper.AddPaperDocUserResult.dailyLimitReached
        super.init(swift: swift)
    }
}

/// Owner's permissions cannot be changed.
@objc
public class DBXPaperAddPaperDocUserResultUserIsOwner: DBXPaperAddPaperDocUserResult {
    @objc
    public init() {
        let swift = Paper.AddPaperDocUserResult.userIsOwner
        super.init(swift: swift)
    }
}

/// User data could not be retrieved. Clients should retry.
@objc
public class DBXPaperAddPaperDocUserResultFailedUserDataRetrieval: DBXPaperAddPaperDocUserResult {
    @objc
    public init() {
        let swift = Paper.AddPaperDocUserResult.failedUserDataRetrieval
        super.init(swift: swift)
    }
}

/// This user already has the correct permission to the Paper doc.
@objc
public class DBXPaperAddPaperDocUserResultPermissionAlreadyGranted: DBXPaperAddPaperDocUserResult {
    @objc
    public init() {
        let swift = Paper.AddPaperDocUserResult.permissionAlreadyGranted
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXPaperAddPaperDocUserResultOther: DBXPaperAddPaperDocUserResult {
    @objc
    public init() {
        let swift = Paper.AddPaperDocUserResult.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible Cursor struct
@objc
public class DBXPaperCursor: NSObject {
    /// The actual cursor value.
    @objc
    public var value: String { swift.value }
    /// Expiration time of value. Some cursors might have expiration time assigned. This is a UTC value after which
    /// the cursor is no longer valid and the API starts returning an error. If cursor expires a new one needs
    /// to be obtained and pagination needs to be restarted. Some cursors might be short-lived some cursors
    /// might be long-lived. This really depends on the sorting type and order, e.g.: 1. on one hand, listing
    /// docs created by the user, sorted by the created time ascending will have undefinite expiration because
    /// the results cannot change while the iteration is happening. This cursor would be suitable for long term
    /// polling. 2. on the other hand, listing docs sorted by the last modified time will have a very short
    /// expiration as docs do get modified very often and the modified time can be changed while the iteration
    /// is happening thus altering the results.
    @objc
    public var expiration: Date? { swift.expiration }

    @objc
    public init(value: String, expiration: Date?) {
        self.swift = Paper.Cursor(value: value, expiration: expiration)
    }

    let swift: Paper.Cursor

    public init(swift: Paper.Cursor) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible PaperApiBaseError union
@objc
public class DBXPaperPaperApiBaseError: NSObject {
    let swift: Paper.PaperApiBaseError

    public init(swift: Paper.PaperApiBaseError) {
        self.swift = swift
    }

    public static func factory(swift: Paper.PaperApiBaseError) -> DBXPaperPaperApiBaseError {
        switch swift {
        case .insufficientPermissions:
            return DBXPaperPaperApiBaseErrorInsufficientPermissions()
        case .other:
            return DBXPaperPaperApiBaseErrorOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asInsufficientPermissions: DBXPaperPaperApiBaseErrorInsufficientPermissions? {
        self as? DBXPaperPaperApiBaseErrorInsufficientPermissions
    }

    @objc
    public var asOther: DBXPaperPaperApiBaseErrorOther? {
        self as? DBXPaperPaperApiBaseErrorOther
    }
}

/// Your account does not have permissions to perform this action. This may be due to it only having access to
/// Paper as files in the Dropbox filesystem. For more information, refer to the Paper Migration Guide
/// https://www.dropbox.com/lp/developers/reference/paper-migration-guide.
@objc
public class DBXPaperPaperApiBaseErrorInsufficientPermissions: DBXPaperPaperApiBaseError {
    @objc
    public init() {
        let swift = Paper.PaperApiBaseError.insufficientPermissions
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXPaperPaperApiBaseErrorOther: DBXPaperPaperApiBaseError {
    @objc
    public init() {
        let swift = Paper.PaperApiBaseError.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible DocLookupError union
@objc
public class DBXPaperDocLookupError: NSObject {
    let swift: Paper.DocLookupError

    public init(swift: Paper.DocLookupError) {
        self.swift = swift
    }

    public static func factory(swift: Paper.DocLookupError) -> DBXPaperDocLookupError {
        switch swift {
        case .insufficientPermissions:
            return DBXPaperDocLookupErrorInsufficientPermissions()
        case .other:
            return DBXPaperDocLookupErrorOther()
        case .docNotFound:
            return DBXPaperDocLookupErrorDocNotFound()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asInsufficientPermissions: DBXPaperDocLookupErrorInsufficientPermissions? {
        self as? DBXPaperDocLookupErrorInsufficientPermissions
    }

    @objc
    public var asOther: DBXPaperDocLookupErrorOther? {
        self as? DBXPaperDocLookupErrorOther
    }

    @objc
    public var asDocNotFound: DBXPaperDocLookupErrorDocNotFound? {
        self as? DBXPaperDocLookupErrorDocNotFound
    }
}

/// Your account does not have permissions to perform this action. This may be due to it only having access to
/// Paper as files in the Dropbox filesystem. For more information, refer to the Paper Migration Guide
/// https://www.dropbox.com/lp/developers/reference/paper-migration-guide.
@objc
public class DBXPaperDocLookupErrorInsufficientPermissions: DBXPaperDocLookupError {
    @objc
    public init() {
        let swift = Paper.DocLookupError.insufficientPermissions
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXPaperDocLookupErrorOther: DBXPaperDocLookupError {
    @objc
    public init() {
        let swift = Paper.DocLookupError.other
        super.init(swift: swift)
    }
}

/// The required doc was not found.
@objc
public class DBXPaperDocLookupErrorDocNotFound: DBXPaperDocLookupError {
    @objc
    public init() {
        let swift = Paper.DocLookupError.docNotFound
        super.init(swift: swift)
    }
}

/// The subscription level of a Paper doc.
@objc
public class DBXPaperDocSubscriptionLevel: NSObject {
    let swift: Paper.DocSubscriptionLevel

    public init(swift: Paper.DocSubscriptionLevel) {
        self.swift = swift
    }

    public static func factory(swift: Paper.DocSubscriptionLevel) -> DBXPaperDocSubscriptionLevel {
        switch swift {
        case .default_:
            return DBXPaperDocSubscriptionLevelDefault_()
        case .ignore:
            return DBXPaperDocSubscriptionLevelIgnore()
        case .every:
            return DBXPaperDocSubscriptionLevelEvery()
        case .noEmail:
            return DBXPaperDocSubscriptionLevelNoEmail()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asDefault_: DBXPaperDocSubscriptionLevelDefault_? {
        self as? DBXPaperDocSubscriptionLevelDefault_
    }

    @objc
    public var asIgnore: DBXPaperDocSubscriptionLevelIgnore? {
        self as? DBXPaperDocSubscriptionLevelIgnore
    }

    @objc
    public var asEvery: DBXPaperDocSubscriptionLevelEvery? {
        self as? DBXPaperDocSubscriptionLevelEvery
    }

    @objc
    public var asNoEmail: DBXPaperDocSubscriptionLevelNoEmail? {
        self as? DBXPaperDocSubscriptionLevelNoEmail
    }
}

/// No change email messages unless you're the creator.
@objc
public class DBXPaperDocSubscriptionLevelDefault_: DBXPaperDocSubscriptionLevel {
    @objc
    public init() {
        let swift = Paper.DocSubscriptionLevel.default_
        super.init(swift: swift)
    }
}

/// Ignored: Not shown in pad lists or activity and no email message is sent.
@objc
public class DBXPaperDocSubscriptionLevelIgnore: DBXPaperDocSubscriptionLevel {
    @objc
    public init() {
        let swift = Paper.DocSubscriptionLevel.ignore
        super.init(swift: swift)
    }
}

/// Subscribed: Shown in pad lists and activity and change email messages are sent.
@objc
public class DBXPaperDocSubscriptionLevelEvery: DBXPaperDocSubscriptionLevel {
    @objc
    public init() {
        let swift = Paper.DocSubscriptionLevel.every
        super.init(swift: swift)
    }
}

/// Unsubscribed: Shown in pad lists, but not in activity and no change email messages are sent.
@objc
public class DBXPaperDocSubscriptionLevelNoEmail: DBXPaperDocSubscriptionLevel {
    @objc
    public init() {
        let swift = Paper.DocSubscriptionLevel.noEmail
        super.init(swift: swift)
    }
}

/// The desired export format of the Paper doc.
@objc
public class DBXPaperExportFormat: NSObject {
    let swift: Paper.ExportFormat

    public init(swift: Paper.ExportFormat) {
        self.swift = swift
    }

    public static func factory(swift: Paper.ExportFormat) -> DBXPaperExportFormat {
        switch swift {
        case .html:
            return DBXPaperExportFormatHtml()
        case .markdown:
            return DBXPaperExportFormatMarkdown()
        case .other:
            return DBXPaperExportFormatOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asHtml: DBXPaperExportFormatHtml? {
        self as? DBXPaperExportFormatHtml
    }

    @objc
    public var asMarkdown: DBXPaperExportFormatMarkdown? {
        self as? DBXPaperExportFormatMarkdown
    }

    @objc
    public var asOther: DBXPaperExportFormatOther? {
        self as? DBXPaperExportFormatOther
    }
}

/// The HTML export format.
@objc
public class DBXPaperExportFormatHtml: DBXPaperExportFormat {
    @objc
    public init() {
        let swift = Paper.ExportFormat.html
        super.init(swift: swift)
    }
}

/// The markdown export format.
@objc
public class DBXPaperExportFormatMarkdown: DBXPaperExportFormat {
    @objc
    public init() {
        let swift = Paper.ExportFormat.markdown
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXPaperExportFormatOther: DBXPaperExportFormat {
    @objc
    public init() {
        let swift = Paper.ExportFormat.other
        super.init(swift: swift)
    }
}

/// Data structure representing a Paper folder.
@objc
public class DBXPaperFolder: NSObject {
    /// Paper folder ID. This ID uniquely identifies the folder.
    @objc
    public var id: String { swift.id }
    /// Paper folder name.
    @objc
    public var name: String { swift.name }

    @objc
    public init(id: String, name: String) {
        self.swift = Paper.Folder(id: id, name: name)
    }

    let swift: Paper.Folder

    public init(swift: Paper.Folder) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// The sharing policy of a Paper folder. The sharing policy of subfolders is inherited from the root folder.
@objc
public class DBXPaperFolderSharingPolicyType: NSObject {
    let swift: Paper.FolderSharingPolicyType

    public init(swift: Paper.FolderSharingPolicyType) {
        self.swift = swift
    }

    public static func factory(swift: Paper.FolderSharingPolicyType) -> DBXPaperFolderSharingPolicyType {
        switch swift {
        case .team:
            return DBXPaperFolderSharingPolicyTypeTeam()
        case .inviteOnly:
            return DBXPaperFolderSharingPolicyTypeInviteOnly()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asTeam: DBXPaperFolderSharingPolicyTypeTeam? {
        self as? DBXPaperFolderSharingPolicyTypeTeam
    }

    @objc
    public var asInviteOnly: DBXPaperFolderSharingPolicyTypeInviteOnly? {
        self as? DBXPaperFolderSharingPolicyTypeInviteOnly
    }
}

/// Everyone in your team and anyone directly invited can access this folder.
@objc
public class DBXPaperFolderSharingPolicyTypeTeam: DBXPaperFolderSharingPolicyType {
    @objc
    public init() {
        let swift = Paper.FolderSharingPolicyType.team
        super.init(swift: swift)
    }
}

/// Only people directly invited can access this folder.
@objc
public class DBXPaperFolderSharingPolicyTypeInviteOnly: DBXPaperFolderSharingPolicyType {
    @objc
    public init() {
        let swift = Paper.FolderSharingPolicyType.inviteOnly
        super.init(swift: swift)
    }
}

/// The subscription level of a Paper folder.
@objc
public class DBXPaperFolderSubscriptionLevel: NSObject {
    let swift: Paper.FolderSubscriptionLevel

    public init(swift: Paper.FolderSubscriptionLevel) {
        self.swift = swift
    }

    public static func factory(swift: Paper.FolderSubscriptionLevel) -> DBXPaperFolderSubscriptionLevel {
        switch swift {
        case .none:
            return DBXPaperFolderSubscriptionLevelNone()
        case .activityOnly:
            return DBXPaperFolderSubscriptionLevelActivityOnly()
        case .dailyEmails:
            return DBXPaperFolderSubscriptionLevelDailyEmails()
        case .weeklyEmails:
            return DBXPaperFolderSubscriptionLevelWeeklyEmails()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asNone: DBXPaperFolderSubscriptionLevelNone? {
        self as? DBXPaperFolderSubscriptionLevelNone
    }

    @objc
    public var asActivityOnly: DBXPaperFolderSubscriptionLevelActivityOnly? {
        self as? DBXPaperFolderSubscriptionLevelActivityOnly
    }

    @objc
    public var asDailyEmails: DBXPaperFolderSubscriptionLevelDailyEmails? {
        self as? DBXPaperFolderSubscriptionLevelDailyEmails
    }

    @objc
    public var asWeeklyEmails: DBXPaperFolderSubscriptionLevelWeeklyEmails? {
        self as? DBXPaperFolderSubscriptionLevelWeeklyEmails
    }
}

/// Not shown in activity, no email messages.
@objc
public class DBXPaperFolderSubscriptionLevelNone: DBXPaperFolderSubscriptionLevel {
    @objc
    public init() {
        let swift = Paper.FolderSubscriptionLevel.none
        super.init(swift: swift)
    }
}

/// Shown in activity, no email messages.
@objc
public class DBXPaperFolderSubscriptionLevelActivityOnly: DBXPaperFolderSubscriptionLevel {
    @objc
    public init() {
        let swift = Paper.FolderSubscriptionLevel.activityOnly
        super.init(swift: swift)
    }
}

/// Shown in activity, daily email messages.
@objc
public class DBXPaperFolderSubscriptionLevelDailyEmails: DBXPaperFolderSubscriptionLevel {
    @objc
    public init() {
        let swift = Paper.FolderSubscriptionLevel.dailyEmails
        super.init(swift: swift)
    }
}

/// Shown in activity, weekly email messages.
@objc
public class DBXPaperFolderSubscriptionLevelWeeklyEmails: DBXPaperFolderSubscriptionLevel {
    @objc
    public init() {
        let swift = Paper.FolderSubscriptionLevel.weeklyEmails
        super.init(swift: swift)
    }
}

/// Metadata about Paper folders containing the specififed Paper doc.
@objc
public class DBXPaperFoldersContainingPaperDoc: NSObject {
    /// The sharing policy of the folder containing the Paper doc.
    @objc
    public var folderSharingPolicyType: DBXPaperFolderSharingPolicyType? { guard let swift = swift.folderSharingPolicyType else { return nil }
        return DBXPaperFolderSharingPolicyType(swift: swift)
    }

    /// The folder path. If present the first folder is the root folder.
    @objc
    public var folders: [DBXPaperFolder]? { swift.folders?.map { DBXPaperFolder(swift: $0) } }

    @objc
    public init(folderSharingPolicyType: DBXPaperFolderSharingPolicyType?, folders: [DBXPaperFolder]?) {
        self.swift = Paper.FoldersContainingPaperDoc(folderSharingPolicyType: folderSharingPolicyType?.swift, folders: folders?.map(\.swift))
    }

    let swift: Paper.FoldersContainingPaperDoc

    public init(swift: Paper.FoldersContainingPaperDoc) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// The import format of the incoming data.
@objc
public class DBXPaperImportFormat: NSObject {
    let swift: Paper.ImportFormat

    public init(swift: Paper.ImportFormat) {
        self.swift = swift
    }

    public static func factory(swift: Paper.ImportFormat) -> DBXPaperImportFormat {
        switch swift {
        case .html:
            return DBXPaperImportFormatHtml()
        case .markdown:
            return DBXPaperImportFormatMarkdown()
        case .plainText:
            return DBXPaperImportFormatPlainText()
        case .other:
            return DBXPaperImportFormatOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asHtml: DBXPaperImportFormatHtml? {
        self as? DBXPaperImportFormatHtml
    }

    @objc
    public var asMarkdown: DBXPaperImportFormatMarkdown? {
        self as? DBXPaperImportFormatMarkdown
    }

    @objc
    public var asPlainText: DBXPaperImportFormatPlainText? {
        self as? DBXPaperImportFormatPlainText
    }

    @objc
    public var asOther: DBXPaperImportFormatOther? {
        self as? DBXPaperImportFormatOther
    }
}

/// The provided data is interpreted as standard HTML.
@objc
public class DBXPaperImportFormatHtml: DBXPaperImportFormat {
    @objc
    public init() {
        let swift = Paper.ImportFormat.html
        super.init(swift: swift)
    }
}

/// The provided data is interpreted as markdown. The first line of the provided document will be used as the
/// doc title.
@objc
public class DBXPaperImportFormatMarkdown: DBXPaperImportFormat {
    @objc
    public init() {
        let swift = Paper.ImportFormat.markdown
        super.init(swift: swift)
    }
}

/// The provided data is interpreted as plain text. The first line of the provided document will be used as the
/// doc title.
@objc
public class DBXPaperImportFormatPlainText: DBXPaperImportFormat {
    @objc
    public init() {
        let swift = Paper.ImportFormat.plainText
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXPaperImportFormatOther: DBXPaperImportFormat {
    @objc
    public init() {
        let swift = Paper.ImportFormat.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible InviteeInfoWithPermissionLevel struct
@objc
public class DBXPaperInviteeInfoWithPermissionLevel: NSObject {
    /// Email address invited to the Paper doc.
    @objc
    public var invitee: DBXSharingInviteeInfo { DBXSharingInviteeInfo(swift: swift.invitee) }
    /// Permission level for the invitee.
    @objc
    public var permissionLevel: DBXPaperPaperDocPermissionLevel { DBXPaperPaperDocPermissionLevel(swift: swift.permissionLevel) }

    @objc
    public init(invitee: DBXSharingInviteeInfo, permissionLevel: DBXPaperPaperDocPermissionLevel) {
        self.swift = Paper.InviteeInfoWithPermissionLevel(invitee: invitee.swift, permissionLevel: permissionLevel.swift)
    }

    let swift: Paper.InviteeInfoWithPermissionLevel

    public init(swift: Paper.InviteeInfoWithPermissionLevel) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible ListDocsCursorError union
@objc
public class DBXPaperListDocsCursorError: NSObject {
    let swift: Paper.ListDocsCursorError

    public init(swift: Paper.ListDocsCursorError) {
        self.swift = swift
    }

    public static func factory(swift: Paper.ListDocsCursorError) -> DBXPaperListDocsCursorError {
        switch swift {
        case .cursorError(let swiftArg):
            let arg = DBXPaperPaperApiCursorError(swift: swiftArg)
            return DBXPaperListDocsCursorErrorCursorError(arg)
        case .other:
            return DBXPaperListDocsCursorErrorOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asCursorError: DBXPaperListDocsCursorErrorCursorError? {
        self as? DBXPaperListDocsCursorErrorCursorError
    }

    @objc
    public var asOther: DBXPaperListDocsCursorErrorOther? {
        self as? DBXPaperListDocsCursorErrorOther
    }
}

/// An unspecified error.
@objc
public class DBXPaperListDocsCursorErrorCursorError: DBXPaperListDocsCursorError {
    @objc
    public var cursorError: DBXPaperPaperApiCursorError

    @objc
    public init(_ arg: DBXPaperPaperApiCursorError) {
        self.cursorError = arg
        let swift = Paper.ListDocsCursorError.cursorError(arg.swift)
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXPaperListDocsCursorErrorOther: DBXPaperListDocsCursorError {
    @objc
    public init() {
        let swift = Paper.ListDocsCursorError.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible ListPaperDocsArgs struct
@objc
public class DBXPaperListPaperDocsArgs: NSObject {
    /// Allows user to specify how the Paper docs should be filtered.
    @objc
    public var filterBy: DBXPaperListPaperDocsFilterBy { DBXPaperListPaperDocsFilterBy(swift: swift.filterBy) }
    /// Allows user to specify how the Paper docs should be sorted.
    @objc
    public var sortBy: DBXPaperListPaperDocsSortBy { DBXPaperListPaperDocsSortBy(swift: swift.sortBy) }
    /// Allows user to specify the sort order of the result.
    @objc
    public var sortOrder: DBXPaperListPaperDocsSortOrder { DBXPaperListPaperDocsSortOrder(swift: swift.sortOrder) }
    /// Size limit per batch. The maximum number of docs that can be retrieved per batch is 1000. Higher value
    /// results in invalid arguments error.
    @objc
    public var limit: NSNumber { swift.limit as NSNumber }

    @objc
    public init(filterBy: DBXPaperListPaperDocsFilterBy, sortBy: DBXPaperListPaperDocsSortBy, sortOrder: DBXPaperListPaperDocsSortOrder, limit: NSNumber) {
        self.swift = Paper.ListPaperDocsArgs(filterBy: filterBy.swift, sortBy: sortBy.swift, sortOrder: sortOrder.swift, limit: limit.int32Value)
    }

    let swift: Paper.ListPaperDocsArgs

    public init(swift: Paper.ListPaperDocsArgs) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible ListPaperDocsContinueArgs struct
@objc
public class DBXPaperListPaperDocsContinueArgs: NSObject {
    /// The cursor obtained from docsList or docsListContinue. Allows for pagination.
    @objc
    public var cursor: String { swift.cursor }

    @objc
    public init(cursor: String) {
        self.swift = Paper.ListPaperDocsContinueArgs(cursor: cursor)
    }

    let swift: Paper.ListPaperDocsContinueArgs

    public init(swift: Paper.ListPaperDocsContinueArgs) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible ListPaperDocsFilterBy union
@objc
public class DBXPaperListPaperDocsFilterBy: NSObject {
    let swift: Paper.ListPaperDocsFilterBy

    public init(swift: Paper.ListPaperDocsFilterBy) {
        self.swift = swift
    }

    public static func factory(swift: Paper.ListPaperDocsFilterBy) -> DBXPaperListPaperDocsFilterBy {
        switch swift {
        case .docsAccessed:
            return DBXPaperListPaperDocsFilterByDocsAccessed()
        case .docsCreated:
            return DBXPaperListPaperDocsFilterByDocsCreated()
        case .other:
            return DBXPaperListPaperDocsFilterByOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asDocsAccessed: DBXPaperListPaperDocsFilterByDocsAccessed? {
        self as? DBXPaperListPaperDocsFilterByDocsAccessed
    }

    @objc
    public var asDocsCreated: DBXPaperListPaperDocsFilterByDocsCreated? {
        self as? DBXPaperListPaperDocsFilterByDocsCreated
    }

    @objc
    public var asOther: DBXPaperListPaperDocsFilterByOther? {
        self as? DBXPaperListPaperDocsFilterByOther
    }
}

/// Fetches all Paper doc IDs that the user has ever accessed.
@objc
public class DBXPaperListPaperDocsFilterByDocsAccessed: DBXPaperListPaperDocsFilterBy {
    @objc
    public init() {
        let swift = Paper.ListPaperDocsFilterBy.docsAccessed
        super.init(swift: swift)
    }
}

/// Fetches only the Paper doc IDs that the user has created.
@objc
public class DBXPaperListPaperDocsFilterByDocsCreated: DBXPaperListPaperDocsFilterBy {
    @objc
    public init() {
        let swift = Paper.ListPaperDocsFilterBy.docsCreated
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXPaperListPaperDocsFilterByOther: DBXPaperListPaperDocsFilterBy {
    @objc
    public init() {
        let swift = Paper.ListPaperDocsFilterBy.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible ListPaperDocsResponse struct
@objc
public class DBXPaperListPaperDocsResponse: NSObject {
    /// The list of Paper doc IDs that can be used to access the given Paper docs or supplied to other API methods.
    /// The list is sorted in the order specified by the initial call to docsList.
    @objc
    public var docIds: [String] { swift.docIds }
    /// Pass the cursor into docsListContinue to paginate through all files. The cursor preserves all properties as
    /// specified in the original call to docsList.
    @objc
    public var cursor: DBXPaperCursor { DBXPaperCursor(swift: swift.cursor) }
    /// Will be set to True if a subsequent call with the provided cursor to docsListContinue returns immediately
    /// with some results. If set to False please allow some delay before making another call to
    /// docsListContinue.
    @objc
    public var hasMore: NSNumber { swift.hasMore as NSNumber }

    @objc
    public init(docIds: [String], cursor: DBXPaperCursor, hasMore: NSNumber) {
        self.swift = Paper.ListPaperDocsResponse(docIds: docIds, cursor: cursor.swift, hasMore: hasMore.boolValue)
    }

    let swift: Paper.ListPaperDocsResponse

    public init(swift: Paper.ListPaperDocsResponse) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible ListPaperDocsSortBy union
@objc
public class DBXPaperListPaperDocsSortBy: NSObject {
    let swift: Paper.ListPaperDocsSortBy

    public init(swift: Paper.ListPaperDocsSortBy) {
        self.swift = swift
    }

    public static func factory(swift: Paper.ListPaperDocsSortBy) -> DBXPaperListPaperDocsSortBy {
        switch swift {
        case .accessed:
            return DBXPaperListPaperDocsSortByAccessed()
        case .modified:
            return DBXPaperListPaperDocsSortByModified()
        case .created:
            return DBXPaperListPaperDocsSortByCreated()
        case .other:
            return DBXPaperListPaperDocsSortByOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asAccessed: DBXPaperListPaperDocsSortByAccessed? {
        self as? DBXPaperListPaperDocsSortByAccessed
    }

    @objc
    public var asModified: DBXPaperListPaperDocsSortByModified? {
        self as? DBXPaperListPaperDocsSortByModified
    }

    @objc
    public var asCreated: DBXPaperListPaperDocsSortByCreated? {
        self as? DBXPaperListPaperDocsSortByCreated
    }

    @objc
    public var asOther: DBXPaperListPaperDocsSortByOther? {
        self as? DBXPaperListPaperDocsSortByOther
    }
}

/// Sorts the Paper docs by the time they were last accessed.
@objc
public class DBXPaperListPaperDocsSortByAccessed: DBXPaperListPaperDocsSortBy {
    @objc
    public init() {
        let swift = Paper.ListPaperDocsSortBy.accessed
        super.init(swift: swift)
    }
}

/// Sorts the Paper docs by the time they were last modified.
@objc
public class DBXPaperListPaperDocsSortByModified: DBXPaperListPaperDocsSortBy {
    @objc
    public init() {
        let swift = Paper.ListPaperDocsSortBy.modified
        super.init(swift: swift)
    }
}

/// Sorts the Paper docs by the creation time.
@objc
public class DBXPaperListPaperDocsSortByCreated: DBXPaperListPaperDocsSortBy {
    @objc
    public init() {
        let swift = Paper.ListPaperDocsSortBy.created
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXPaperListPaperDocsSortByOther: DBXPaperListPaperDocsSortBy {
    @objc
    public init() {
        let swift = Paper.ListPaperDocsSortBy.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible ListPaperDocsSortOrder union
@objc
public class DBXPaperListPaperDocsSortOrder: NSObject {
    let swift: Paper.ListPaperDocsSortOrder

    public init(swift: Paper.ListPaperDocsSortOrder) {
        self.swift = swift
    }

    public static func factory(swift: Paper.ListPaperDocsSortOrder) -> DBXPaperListPaperDocsSortOrder {
        switch swift {
        case .ascending:
            return DBXPaperListPaperDocsSortOrderAscending()
        case .descending:
            return DBXPaperListPaperDocsSortOrderDescending()
        case .other:
            return DBXPaperListPaperDocsSortOrderOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asAscending: DBXPaperListPaperDocsSortOrderAscending? {
        self as? DBXPaperListPaperDocsSortOrderAscending
    }

    @objc
    public var asDescending: DBXPaperListPaperDocsSortOrderDescending? {
        self as? DBXPaperListPaperDocsSortOrderDescending
    }

    @objc
    public var asOther: DBXPaperListPaperDocsSortOrderOther? {
        self as? DBXPaperListPaperDocsSortOrderOther
    }
}

/// Sorts the search result in ascending order.
@objc
public class DBXPaperListPaperDocsSortOrderAscending: DBXPaperListPaperDocsSortOrder {
    @objc
    public init() {
        let swift = Paper.ListPaperDocsSortOrder.ascending
        super.init(swift: swift)
    }
}

/// Sorts the search result in descending order.
@objc
public class DBXPaperListPaperDocsSortOrderDescending: DBXPaperListPaperDocsSortOrder {
    @objc
    public init() {
        let swift = Paper.ListPaperDocsSortOrder.descending
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXPaperListPaperDocsSortOrderOther: DBXPaperListPaperDocsSortOrder {
    @objc
    public init() {
        let swift = Paper.ListPaperDocsSortOrder.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible ListUsersCursorError union
@objc
public class DBXPaperListUsersCursorError: NSObject {
    let swift: Paper.ListUsersCursorError

    public init(swift: Paper.ListUsersCursorError) {
        self.swift = swift
    }

    public static func factory(swift: Paper.ListUsersCursorError) -> DBXPaperListUsersCursorError {
        switch swift {
        case .insufficientPermissions:
            return DBXPaperListUsersCursorErrorInsufficientPermissions()
        case .other:
            return DBXPaperListUsersCursorErrorOther()
        case .docNotFound:
            return DBXPaperListUsersCursorErrorDocNotFound()
        case .cursorError(let swiftArg):
            let arg = DBXPaperPaperApiCursorError(swift: swiftArg)
            return DBXPaperListUsersCursorErrorCursorError(arg)
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asInsufficientPermissions: DBXPaperListUsersCursorErrorInsufficientPermissions? {
        self as? DBXPaperListUsersCursorErrorInsufficientPermissions
    }

    @objc
    public var asOther: DBXPaperListUsersCursorErrorOther? {
        self as? DBXPaperListUsersCursorErrorOther
    }

    @objc
    public var asDocNotFound: DBXPaperListUsersCursorErrorDocNotFound? {
        self as? DBXPaperListUsersCursorErrorDocNotFound
    }

    @objc
    public var asCursorError: DBXPaperListUsersCursorErrorCursorError? {
        self as? DBXPaperListUsersCursorErrorCursorError
    }
}

/// Your account does not have permissions to perform this action. This may be due to it only having access to
/// Paper as files in the Dropbox filesystem. For more information, refer to the Paper Migration Guide
/// https://www.dropbox.com/lp/developers/reference/paper-migration-guide.
@objc
public class DBXPaperListUsersCursorErrorInsufficientPermissions: DBXPaperListUsersCursorError {
    @objc
    public init() {
        let swift = Paper.ListUsersCursorError.insufficientPermissions
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXPaperListUsersCursorErrorOther: DBXPaperListUsersCursorError {
    @objc
    public init() {
        let swift = Paper.ListUsersCursorError.other
        super.init(swift: swift)
    }
}

/// The required doc was not found.
@objc
public class DBXPaperListUsersCursorErrorDocNotFound: DBXPaperListUsersCursorError {
    @objc
    public init() {
        let swift = Paper.ListUsersCursorError.docNotFound
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXPaperListUsersCursorErrorCursorError: DBXPaperListUsersCursorError {
    @objc
    public var cursorError: DBXPaperPaperApiCursorError

    @objc
    public init(_ arg: DBXPaperPaperApiCursorError) {
        self.cursorError = arg
        let swift = Paper.ListUsersCursorError.cursorError(arg.swift)
        super.init(swift: swift)
    }
}

/// Objective-C compatible ListUsersOnFolderArgs struct
@objc
public class DBXPaperListUsersOnFolderArgs: DBXPaperRefPaperDoc {
    /// Size limit per batch. The maximum number of users that can be retrieved per batch is 1000. Higher value
    /// results in invalid arguments error.
    @objc
    public var limit: NSNumber { subSwift.limit as NSNumber }

    @objc
    public init(docId: String, limit: NSNumber) {
        let swift = Paper.ListUsersOnFolderArgs(docId: docId, limit: limit.int32Value)
        self.subSwift = swift
        super.init(swift: swift)
    }

    let subSwift: Paper.ListUsersOnFolderArgs

    public init(swift: Paper.ListUsersOnFolderArgs) {
        self.subSwift = swift
        super.init(swift: swift)
    }

    @objc
    public override var description: String { subSwift.description }
}

/// Objective-C compatible ListUsersOnFolderContinueArgs struct
@objc
public class DBXPaperListUsersOnFolderContinueArgs: DBXPaperRefPaperDoc {
    /// The cursor obtained from docsFolderUsersList or docsFolderUsersListContinue. Allows for pagination.
    @objc
    public var cursor: String { subSwift.cursor }

    @objc
    public init(docId: String, cursor: String) {
        let swift = Paper.ListUsersOnFolderContinueArgs(docId: docId, cursor: cursor)
        self.subSwift = swift
        super.init(swift: swift)
    }

    let subSwift: Paper.ListUsersOnFolderContinueArgs

    public init(swift: Paper.ListUsersOnFolderContinueArgs) {
        self.subSwift = swift
        super.init(swift: swift)
    }

    @objc
    public override var description: String { subSwift.description }
}

/// Objective-C compatible ListUsersOnFolderResponse struct
@objc
public class DBXPaperListUsersOnFolderResponse: NSObject {
    /// List of email addresses that are invited on the Paper folder.
    @objc
    public var invitees: [DBXSharingInviteeInfo] { swift.invitees.map { DBXSharingInviteeInfo(swift: $0) } }
    /// List of users that are invited on the Paper folder.
    @objc
    public var users: [DBXSharingUserInfo] { swift.users.map { DBXSharingUserInfo(swift: $0) } }
    /// Pass the cursor into docsFolderUsersListContinue to paginate through all users. The cursor preserves all
    /// properties as specified in the original call to docsFolderUsersList.
    @objc
    public var cursor: DBXPaperCursor { DBXPaperCursor(swift: swift.cursor) }
    /// Will be set to True if a subsequent call with the provided cursor to docsFolderUsersListContinue returns
    /// immediately with some results. If set to False please allow some delay before making another call to
    /// docsFolderUsersListContinue.
    @objc
    public var hasMore: NSNumber { swift.hasMore as NSNumber }

    @objc
    public init(invitees: [DBXSharingInviteeInfo], users: [DBXSharingUserInfo], cursor: DBXPaperCursor, hasMore: NSNumber) {
        self.swift = Paper.ListUsersOnFolderResponse(
            invitees: invitees.map(\.swift),
            users: users.map(\.swift),
            cursor: cursor.swift,
            hasMore: hasMore.boolValue
        )
    }

    let swift: Paper.ListUsersOnFolderResponse

    public init(swift: Paper.ListUsersOnFolderResponse) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible ListUsersOnPaperDocArgs struct
@objc
public class DBXPaperListUsersOnPaperDocArgs: DBXPaperRefPaperDoc {
    /// Size limit per batch. The maximum number of users that can be retrieved per batch is 1000. Higher value
    /// results in invalid arguments error.
    @objc
    public var limit: NSNumber { subSwift.limit as NSNumber }
    /// Specify this attribute if you want to obtain users that have already accessed the Paper doc.
    @objc
    public var filterBy: DBXPaperUserOnPaperDocFilter { DBXPaperUserOnPaperDocFilter(swift: subSwift.filterBy) }

    @objc
    public init(docId: String, limit: NSNumber, filterBy: DBXPaperUserOnPaperDocFilter) {
        let swift = Paper.ListUsersOnPaperDocArgs(docId: docId, limit: limit.int32Value, filterBy: filterBy.swift)
        self.subSwift = swift
        super.init(swift: swift)
    }

    let subSwift: Paper.ListUsersOnPaperDocArgs

    public init(swift: Paper.ListUsersOnPaperDocArgs) {
        self.subSwift = swift
        super.init(swift: swift)
    }

    @objc
    public override var description: String { subSwift.description }
}

/// Objective-C compatible ListUsersOnPaperDocContinueArgs struct
@objc
public class DBXPaperListUsersOnPaperDocContinueArgs: DBXPaperRefPaperDoc {
    /// The cursor obtained from docsUsersList or docsUsersListContinue. Allows for pagination.
    @objc
    public var cursor: String { subSwift.cursor }

    @objc
    public init(docId: String, cursor: String) {
        let swift = Paper.ListUsersOnPaperDocContinueArgs(docId: docId, cursor: cursor)
        self.subSwift = swift
        super.init(swift: swift)
    }

    let subSwift: Paper.ListUsersOnPaperDocContinueArgs

    public init(swift: Paper.ListUsersOnPaperDocContinueArgs) {
        self.subSwift = swift
        super.init(swift: swift)
    }

    @objc
    public override var description: String { subSwift.description }
}

/// Objective-C compatible ListUsersOnPaperDocResponse struct
@objc
public class DBXPaperListUsersOnPaperDocResponse: NSObject {
    /// List of email addresses with their respective permission levels that are invited on the Paper doc.
    @objc
    public var invitees: [DBXPaperInviteeInfoWithPermissionLevel] { swift.invitees.map { DBXPaperInviteeInfoWithPermissionLevel(swift: $0) } }
    /// List of users with their respective permission levels that are invited on the Paper folder.
    @objc
    public var users: [DBXPaperUserInfoWithPermissionLevel] { swift.users.map { DBXPaperUserInfoWithPermissionLevel(swift: $0) } }
    /// The Paper doc owner. This field is populated on every single response.
    @objc
    public var docOwner: DBXSharingUserInfo { DBXSharingUserInfo(swift: swift.docOwner) }
    /// Pass the cursor into docsUsersListContinue to paginate through all users. The cursor preserves all
    /// properties as specified in the original call to docsUsersList.
    @objc
    public var cursor: DBXPaperCursor { DBXPaperCursor(swift: swift.cursor) }
    /// Will be set to True if a subsequent call with the provided cursor to docsUsersListContinue returns
    /// immediately with some results. If set to False please allow some delay before making another call to
    /// docsUsersListContinue.
    @objc
    public var hasMore: NSNumber { swift.hasMore as NSNumber }

    @objc
    public init(
        invitees: [DBXPaperInviteeInfoWithPermissionLevel],
        users: [DBXPaperUserInfoWithPermissionLevel],
        docOwner: DBXSharingUserInfo,
        cursor: DBXPaperCursor,
        hasMore: NSNumber
    ) {
        self.swift = Paper.ListUsersOnPaperDocResponse(
            invitees: invitees.map(\.swift),
            users: users.map(\.swift),
            docOwner: docOwner.swift,
            cursor: cursor.swift,
            hasMore: hasMore.boolValue
        )
    }

    let swift: Paper.ListUsersOnPaperDocResponse

    public init(swift: Paper.ListUsersOnPaperDocResponse) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible PaperApiCursorError union
@objc
public class DBXPaperPaperApiCursorError: NSObject {
    let swift: Paper.PaperApiCursorError

    public init(swift: Paper.PaperApiCursorError) {
        self.swift = swift
    }

    public static func factory(swift: Paper.PaperApiCursorError) -> DBXPaperPaperApiCursorError {
        switch swift {
        case .expiredCursor:
            return DBXPaperPaperApiCursorErrorExpiredCursor()
        case .invalidCursor:
            return DBXPaperPaperApiCursorErrorInvalidCursor()
        case .wrongUserInCursor:
            return DBXPaperPaperApiCursorErrorWrongUserInCursor()
        case .reset:
            return DBXPaperPaperApiCursorErrorReset()
        case .other:
            return DBXPaperPaperApiCursorErrorOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asExpiredCursor: DBXPaperPaperApiCursorErrorExpiredCursor? {
        self as? DBXPaperPaperApiCursorErrorExpiredCursor
    }

    @objc
    public var asInvalidCursor: DBXPaperPaperApiCursorErrorInvalidCursor? {
        self as? DBXPaperPaperApiCursorErrorInvalidCursor
    }

    @objc
    public var asWrongUserInCursor: DBXPaperPaperApiCursorErrorWrongUserInCursor? {
        self as? DBXPaperPaperApiCursorErrorWrongUserInCursor
    }

    @objc
    public var asReset: DBXPaperPaperApiCursorErrorReset? {
        self as? DBXPaperPaperApiCursorErrorReset
    }

    @objc
    public var asOther: DBXPaperPaperApiCursorErrorOther? {
        self as? DBXPaperPaperApiCursorErrorOther
    }
}

/// The provided cursor is expired.
@objc
public class DBXPaperPaperApiCursorErrorExpiredCursor: DBXPaperPaperApiCursorError {
    @objc
    public init() {
        let swift = Paper.PaperApiCursorError.expiredCursor
        super.init(swift: swift)
    }
}

/// The provided cursor is invalid.
@objc
public class DBXPaperPaperApiCursorErrorInvalidCursor: DBXPaperPaperApiCursorError {
    @objc
    public init() {
        let swift = Paper.PaperApiCursorError.invalidCursor
        super.init(swift: swift)
    }
}

/// The provided cursor contains invalid user.
@objc
public class DBXPaperPaperApiCursorErrorWrongUserInCursor: DBXPaperPaperApiCursorError {
    @objc
    public init() {
        let swift = Paper.PaperApiCursorError.wrongUserInCursor
        super.init(swift: swift)
    }
}

/// Indicates that the cursor has been invalidated. Call the corresponding non-continue endpoint to obtain a new
/// cursor.
@objc
public class DBXPaperPaperApiCursorErrorReset: DBXPaperPaperApiCursorError {
    @objc
    public init() {
        let swift = Paper.PaperApiCursorError.reset
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXPaperPaperApiCursorErrorOther: DBXPaperPaperApiCursorError {
    @objc
    public init() {
        let swift = Paper.PaperApiCursorError.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible PaperDocCreateArgs struct
@objc
public class DBXPaperPaperDocCreateArgs: NSObject {
    /// The Paper folder ID where the Paper document should be created. The API user has to have write access to
    /// this folder or error is thrown.
    @objc
    public var parentFolderId: String? { swift.parentFolderId }
    /// The format of provided data.
    @objc
    public var importFormat: DBXPaperImportFormat { DBXPaperImportFormat(swift: swift.importFormat) }

    @objc
    public init(importFormat: DBXPaperImportFormat, parentFolderId: String?) {
        self.swift = Paper.PaperDocCreateArgs(importFormat: importFormat.swift, parentFolderId: parentFolderId)
    }

    let swift: Paper.PaperDocCreateArgs

    public init(swift: Paper.PaperDocCreateArgs) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible PaperDocCreateError union
@objc
public class DBXPaperPaperDocCreateError: NSObject {
    let swift: Paper.PaperDocCreateError

    public init(swift: Paper.PaperDocCreateError) {
        self.swift = swift
    }

    public static func factory(swift: Paper.PaperDocCreateError) -> DBXPaperPaperDocCreateError {
        switch swift {
        case .insufficientPermissions:
            return DBXPaperPaperDocCreateErrorInsufficientPermissions()
        case .other:
            return DBXPaperPaperDocCreateErrorOther()
        case .contentMalformed:
            return DBXPaperPaperDocCreateErrorContentMalformed()
        case .folderNotFound:
            return DBXPaperPaperDocCreateErrorFolderNotFound()
        case .docLengthExceeded:
            return DBXPaperPaperDocCreateErrorDocLengthExceeded()
        case .imageSizeExceeded:
            return DBXPaperPaperDocCreateErrorImageSizeExceeded()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asInsufficientPermissions: DBXPaperPaperDocCreateErrorInsufficientPermissions? {
        self as? DBXPaperPaperDocCreateErrorInsufficientPermissions
    }

    @objc
    public var asOther: DBXPaperPaperDocCreateErrorOther? {
        self as? DBXPaperPaperDocCreateErrorOther
    }

    @objc
    public var asContentMalformed: DBXPaperPaperDocCreateErrorContentMalformed? {
        self as? DBXPaperPaperDocCreateErrorContentMalformed
    }

    @objc
    public var asFolderNotFound: DBXPaperPaperDocCreateErrorFolderNotFound? {
        self as? DBXPaperPaperDocCreateErrorFolderNotFound
    }

    @objc
    public var asDocLengthExceeded: DBXPaperPaperDocCreateErrorDocLengthExceeded? {
        self as? DBXPaperPaperDocCreateErrorDocLengthExceeded
    }

    @objc
    public var asImageSizeExceeded: DBXPaperPaperDocCreateErrorImageSizeExceeded? {
        self as? DBXPaperPaperDocCreateErrorImageSizeExceeded
    }
}

/// Your account does not have permissions to perform this action. This may be due to it only having access to
/// Paper as files in the Dropbox filesystem. For more information, refer to the Paper Migration Guide
/// https://www.dropbox.com/lp/developers/reference/paper-migration-guide.
@objc
public class DBXPaperPaperDocCreateErrorInsufficientPermissions: DBXPaperPaperDocCreateError {
    @objc
    public init() {
        let swift = Paper.PaperDocCreateError.insufficientPermissions
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXPaperPaperDocCreateErrorOther: DBXPaperPaperDocCreateError {
    @objc
    public init() {
        let swift = Paper.PaperDocCreateError.other
        super.init(swift: swift)
    }
}

/// The provided content was malformed and cannot be imported to Paper.
@objc
public class DBXPaperPaperDocCreateErrorContentMalformed: DBXPaperPaperDocCreateError {
    @objc
    public init() {
        let swift = Paper.PaperDocCreateError.contentMalformed
        super.init(swift: swift)
    }
}

/// The specified Paper folder is cannot be found.
@objc
public class DBXPaperPaperDocCreateErrorFolderNotFound: DBXPaperPaperDocCreateError {
    @objc
    public init() {
        let swift = Paper.PaperDocCreateError.folderNotFound
        super.init(swift: swift)
    }
}

/// The newly created Paper doc would be too large. Please split the content into multiple docs.
@objc
public class DBXPaperPaperDocCreateErrorDocLengthExceeded: DBXPaperPaperDocCreateError {
    @objc
    public init() {
        let swift = Paper.PaperDocCreateError.docLengthExceeded
        super.init(swift: swift)
    }
}

/// The imported document contains an image that is too large. The current limit is 1MB. This only applies to
/// HTML with data URI.
@objc
public class DBXPaperPaperDocCreateErrorImageSizeExceeded: DBXPaperPaperDocCreateError {
    @objc
    public init() {
        let swift = Paper.PaperDocCreateError.imageSizeExceeded
        super.init(swift: swift)
    }
}

/// Objective-C compatible PaperDocCreateUpdateResult struct
@objc
public class DBXPaperPaperDocCreateUpdateResult: NSObject {
    /// Doc ID of the newly created doc.
    @objc
    public var docId: String { swift.docId }
    /// The Paper doc revision. Simply an ever increasing number.
    @objc
    public var revision: NSNumber { swift.revision as NSNumber }
    /// The Paper doc title.
    @objc
    public var title: String { swift.title }

    @objc
    public init(docId: String, revision: NSNumber, title: String) {
        self.swift = Paper.PaperDocCreateUpdateResult(docId: docId, revision: revision.int64Value, title: title)
    }

    let swift: Paper.PaperDocCreateUpdateResult

    public init(swift: Paper.PaperDocCreateUpdateResult) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible PaperDocExport struct
@objc
public class DBXPaperPaperDocExport: DBXPaperRefPaperDoc {
    /// (no description)
    @objc
    public var exportFormat: DBXPaperExportFormat { DBXPaperExportFormat(swift: subSwift.exportFormat) }

    @objc
    public init(docId: String, exportFormat: DBXPaperExportFormat) {
        let swift = Paper.PaperDocExport(docId: docId, exportFormat: exportFormat.swift)
        self.subSwift = swift
        super.init(swift: swift)
    }

    let subSwift: Paper.PaperDocExport

    public init(swift: Paper.PaperDocExport) {
        self.subSwift = swift
        super.init(swift: swift)
    }

    @objc
    public override var description: String { subSwift.description }
}

/// Objective-C compatible PaperDocExportResult struct
@objc
public class DBXPaperPaperDocExportResult: NSObject {
    /// The Paper doc owner's email address.
    @objc
    public var owner: String { swift.owner }
    /// The Paper doc title.
    @objc
    public var title: String { swift.title }
    /// The Paper doc revision. Simply an ever increasing number.
    @objc
    public var revision: NSNumber { swift.revision as NSNumber }
    /// MIME type of the export. This corresponds to ExportFormat specified in the request.
    @objc
    public var mimeType: String { swift.mimeType }

    @objc
    public init(owner: String, title: String, revision: NSNumber, mimeType: String) {
        self.swift = Paper.PaperDocExportResult(owner: owner, title: title, revision: revision.int64Value, mimeType: mimeType)
    }

    let swift: Paper.PaperDocExportResult

    public init(swift: Paper.PaperDocExportResult) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible PaperDocPermissionLevel union
@objc
public class DBXPaperPaperDocPermissionLevel: NSObject {
    let swift: Paper.PaperDocPermissionLevel

    public init(swift: Paper.PaperDocPermissionLevel) {
        self.swift = swift
    }

    public static func factory(swift: Paper.PaperDocPermissionLevel) -> DBXPaperPaperDocPermissionLevel {
        switch swift {
        case .edit:
            return DBXPaperPaperDocPermissionLevelEdit()
        case .viewAndComment:
            return DBXPaperPaperDocPermissionLevelViewAndComment()
        case .other:
            return DBXPaperPaperDocPermissionLevelOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asEdit: DBXPaperPaperDocPermissionLevelEdit? {
        self as? DBXPaperPaperDocPermissionLevelEdit
    }

    @objc
    public var asViewAndComment: DBXPaperPaperDocPermissionLevelViewAndComment? {
        self as? DBXPaperPaperDocPermissionLevelViewAndComment
    }

    @objc
    public var asOther: DBXPaperPaperDocPermissionLevelOther? {
        self as? DBXPaperPaperDocPermissionLevelOther
    }
}

/// User will be granted edit permissions.
@objc
public class DBXPaperPaperDocPermissionLevelEdit: DBXPaperPaperDocPermissionLevel {
    @objc
    public init() {
        let swift = Paper.PaperDocPermissionLevel.edit
        super.init(swift: swift)
    }
}

/// User will be granted view and comment permissions.
@objc
public class DBXPaperPaperDocPermissionLevelViewAndComment: DBXPaperPaperDocPermissionLevel {
    @objc
    public init() {
        let swift = Paper.PaperDocPermissionLevel.viewAndComment
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXPaperPaperDocPermissionLevelOther: DBXPaperPaperDocPermissionLevel {
    @objc
    public init() {
        let swift = Paper.PaperDocPermissionLevel.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible PaperDocSharingPolicy struct
@objc
public class DBXPaperPaperDocSharingPolicy: DBXPaperRefPaperDoc {
    /// The default sharing policy to be set for the Paper doc.
    @objc
    public var sharingPolicy: DBXPaperSharingPolicy { DBXPaperSharingPolicy(swift: subSwift.sharingPolicy) }

    @objc
    public init(docId: String, sharingPolicy: DBXPaperSharingPolicy) {
        let swift = Paper.PaperDocSharingPolicy(docId: docId, sharingPolicy: sharingPolicy.swift)
        self.subSwift = swift
        super.init(swift: swift)
    }

    let subSwift: Paper.PaperDocSharingPolicy

    public init(swift: Paper.PaperDocSharingPolicy) {
        self.subSwift = swift
        super.init(swift: swift)
    }

    @objc
    public override var description: String { subSwift.description }
}

/// Objective-C compatible PaperDocUpdateArgs struct
@objc
public class DBXPaperPaperDocUpdateArgs: DBXPaperRefPaperDoc {
    /// The policy used for the current update call.
    @objc
    public var docUpdatePolicy: DBXPaperPaperDocUpdatePolicy { DBXPaperPaperDocUpdatePolicy(swift: subSwift.docUpdatePolicy) }
    /// The latest doc revision. This value must match the head revision or an error code will be returned. This is
    /// to prevent colliding writes.
    @objc
    public var revision: NSNumber { subSwift.revision as NSNumber }
    /// The format of provided data.
    @objc
    public var importFormat: DBXPaperImportFormat { DBXPaperImportFormat(swift: subSwift.importFormat) }

    @objc
    public init(docId: String, docUpdatePolicy: DBXPaperPaperDocUpdatePolicy, revision: NSNumber, importFormat: DBXPaperImportFormat) {
        let swift = Paper.PaperDocUpdateArgs(
            docId: docId,
            docUpdatePolicy: docUpdatePolicy.swift,
            revision: revision.int64Value,
            importFormat: importFormat.swift
        )
        self.subSwift = swift
        super.init(swift: swift)
    }

    let subSwift: Paper.PaperDocUpdateArgs

    public init(swift: Paper.PaperDocUpdateArgs) {
        self.subSwift = swift
        super.init(swift: swift)
    }

    @objc
    public override var description: String { subSwift.description }
}

/// Objective-C compatible PaperDocUpdateError union
@objc
public class DBXPaperPaperDocUpdateError: NSObject {
    let swift: Paper.PaperDocUpdateError

    public init(swift: Paper.PaperDocUpdateError) {
        self.swift = swift
    }

    public static func factory(swift: Paper.PaperDocUpdateError) -> DBXPaperPaperDocUpdateError {
        switch swift {
        case .insufficientPermissions:
            return DBXPaperPaperDocUpdateErrorInsufficientPermissions()
        case .other:
            return DBXPaperPaperDocUpdateErrorOther()
        case .docNotFound:
            return DBXPaperPaperDocUpdateErrorDocNotFound()
        case .contentMalformed:
            return DBXPaperPaperDocUpdateErrorContentMalformed()
        case .revisionMismatch:
            return DBXPaperPaperDocUpdateErrorRevisionMismatch()
        case .docLengthExceeded:
            return DBXPaperPaperDocUpdateErrorDocLengthExceeded()
        case .imageSizeExceeded:
            return DBXPaperPaperDocUpdateErrorImageSizeExceeded()
        case .docArchived:
            return DBXPaperPaperDocUpdateErrorDocArchived()
        case .docDeleted:
            return DBXPaperPaperDocUpdateErrorDocDeleted()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asInsufficientPermissions: DBXPaperPaperDocUpdateErrorInsufficientPermissions? {
        self as? DBXPaperPaperDocUpdateErrorInsufficientPermissions
    }

    @objc
    public var asOther: DBXPaperPaperDocUpdateErrorOther? {
        self as? DBXPaperPaperDocUpdateErrorOther
    }

    @objc
    public var asDocNotFound: DBXPaperPaperDocUpdateErrorDocNotFound? {
        self as? DBXPaperPaperDocUpdateErrorDocNotFound
    }

    @objc
    public var asContentMalformed: DBXPaperPaperDocUpdateErrorContentMalformed? {
        self as? DBXPaperPaperDocUpdateErrorContentMalformed
    }

    @objc
    public var asRevisionMismatch: DBXPaperPaperDocUpdateErrorRevisionMismatch? {
        self as? DBXPaperPaperDocUpdateErrorRevisionMismatch
    }

    @objc
    public var asDocLengthExceeded: DBXPaperPaperDocUpdateErrorDocLengthExceeded? {
        self as? DBXPaperPaperDocUpdateErrorDocLengthExceeded
    }

    @objc
    public var asImageSizeExceeded: DBXPaperPaperDocUpdateErrorImageSizeExceeded? {
        self as? DBXPaperPaperDocUpdateErrorImageSizeExceeded
    }

    @objc
    public var asDocArchived: DBXPaperPaperDocUpdateErrorDocArchived? {
        self as? DBXPaperPaperDocUpdateErrorDocArchived
    }

    @objc
    public var asDocDeleted: DBXPaperPaperDocUpdateErrorDocDeleted? {
        self as? DBXPaperPaperDocUpdateErrorDocDeleted
    }
}

/// Your account does not have permissions to perform this action. This may be due to it only having access to
/// Paper as files in the Dropbox filesystem. For more information, refer to the Paper Migration Guide
/// https://www.dropbox.com/lp/developers/reference/paper-migration-guide.
@objc
public class DBXPaperPaperDocUpdateErrorInsufficientPermissions: DBXPaperPaperDocUpdateError {
    @objc
    public init() {
        let swift = Paper.PaperDocUpdateError.insufficientPermissions
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXPaperPaperDocUpdateErrorOther: DBXPaperPaperDocUpdateError {
    @objc
    public init() {
        let swift = Paper.PaperDocUpdateError.other
        super.init(swift: swift)
    }
}

/// The required doc was not found.
@objc
public class DBXPaperPaperDocUpdateErrorDocNotFound: DBXPaperPaperDocUpdateError {
    @objc
    public init() {
        let swift = Paper.PaperDocUpdateError.docNotFound
        super.init(swift: swift)
    }
}

/// The provided content was malformed and cannot be imported to Paper.
@objc
public class DBXPaperPaperDocUpdateErrorContentMalformed: DBXPaperPaperDocUpdateError {
    @objc
    public init() {
        let swift = Paper.PaperDocUpdateError.contentMalformed
        super.init(swift: swift)
    }
}

/// The provided revision does not match the document head.
@objc
public class DBXPaperPaperDocUpdateErrorRevisionMismatch: DBXPaperPaperDocUpdateError {
    @objc
    public init() {
        let swift = Paper.PaperDocUpdateError.revisionMismatch
        super.init(swift: swift)
    }
}

/// The newly created Paper doc would be too large, split the content into multiple docs.
@objc
public class DBXPaperPaperDocUpdateErrorDocLengthExceeded: DBXPaperPaperDocUpdateError {
    @objc
    public init() {
        let swift = Paper.PaperDocUpdateError.docLengthExceeded
        super.init(swift: swift)
    }
}

/// The imported document contains an image that is too large. The current limit is 1MB. This only applies to
/// HTML with data URI.
@objc
public class DBXPaperPaperDocUpdateErrorImageSizeExceeded: DBXPaperPaperDocUpdateError {
    @objc
    public init() {
        let swift = Paper.PaperDocUpdateError.imageSizeExceeded
        super.init(swift: swift)
    }
}

/// This operation is not allowed on archived Paper docs.
@objc
public class DBXPaperPaperDocUpdateErrorDocArchived: DBXPaperPaperDocUpdateError {
    @objc
    public init() {
        let swift = Paper.PaperDocUpdateError.docArchived
        super.init(swift: swift)
    }
}

/// This operation is not allowed on deleted Paper docs.
@objc
public class DBXPaperPaperDocUpdateErrorDocDeleted: DBXPaperPaperDocUpdateError {
    @objc
    public init() {
        let swift = Paper.PaperDocUpdateError.docDeleted
        super.init(swift: swift)
    }
}

/// Objective-C compatible PaperDocUpdatePolicy union
@objc
public class DBXPaperPaperDocUpdatePolicy: NSObject {
    let swift: Paper.PaperDocUpdatePolicy

    public init(swift: Paper.PaperDocUpdatePolicy) {
        self.swift = swift
    }

    public static func factory(swift: Paper.PaperDocUpdatePolicy) -> DBXPaperPaperDocUpdatePolicy {
        switch swift {
        case .append:
            return DBXPaperPaperDocUpdatePolicyAppend()
        case .prepend:
            return DBXPaperPaperDocUpdatePolicyPrepend()
        case .overwriteAll:
            return DBXPaperPaperDocUpdatePolicyOverwriteAll()
        case .other:
            return DBXPaperPaperDocUpdatePolicyOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asAppend: DBXPaperPaperDocUpdatePolicyAppend? {
        self as? DBXPaperPaperDocUpdatePolicyAppend
    }

    @objc
    public var asPrepend: DBXPaperPaperDocUpdatePolicyPrepend? {
        self as? DBXPaperPaperDocUpdatePolicyPrepend
    }

    @objc
    public var asOverwriteAll: DBXPaperPaperDocUpdatePolicyOverwriteAll? {
        self as? DBXPaperPaperDocUpdatePolicyOverwriteAll
    }

    @objc
    public var asOther: DBXPaperPaperDocUpdatePolicyOther? {
        self as? DBXPaperPaperDocUpdatePolicyOther
    }
}

/// The content will be appended to the doc.
@objc
public class DBXPaperPaperDocUpdatePolicyAppend: DBXPaperPaperDocUpdatePolicy {
    @objc
    public init() {
        let swift = Paper.PaperDocUpdatePolicy.append
        super.init(swift: swift)
    }
}

/// The content will be prepended to the doc. The doc title will not be affected.
@objc
public class DBXPaperPaperDocUpdatePolicyPrepend: DBXPaperPaperDocUpdatePolicy {
    @objc
    public init() {
        let swift = Paper.PaperDocUpdatePolicy.prepend
        super.init(swift: swift)
    }
}

/// The document will be overwitten at the head with the provided content.
@objc
public class DBXPaperPaperDocUpdatePolicyOverwriteAll: DBXPaperPaperDocUpdatePolicy {
    @objc
    public init() {
        let swift = Paper.PaperDocUpdatePolicy.overwriteAll
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXPaperPaperDocUpdatePolicyOther: DBXPaperPaperDocUpdatePolicy {
    @objc
    public init() {
        let swift = Paper.PaperDocUpdatePolicy.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible PaperFolderCreateArg struct
@objc
public class DBXPaperPaperFolderCreateArg: NSObject {
    /// The name of the new Paper folder.
    @objc
    public var name: String { swift.name }
    /// The encrypted Paper folder Id where the new Paper folder should be created. The API user has to have write
    /// access to this folder or error is thrown. If not supplied, the new folder will be created at top level.
    @objc
    public var parentFolderId: String? { swift.parentFolderId }
    /// Whether the folder to be created should be a team folder. This value will be ignored if parent_folder_id is
    /// supplied, as the new folder will inherit the type (private or team folder) from its parent. We will by
    /// default create a top-level private folder if both parent_folder_id and is_team_folder are not supplied.
    @objc
    public var isTeamFolder: NSNumber? { swift.isTeamFolder as NSNumber? }

    @objc
    public init(name: String, parentFolderId: String?, isTeamFolder: NSNumber?) {
        self.swift = Paper.PaperFolderCreateArg(name: name, parentFolderId: parentFolderId, isTeamFolder: isTeamFolder?.boolValue)
    }

    let swift: Paper.PaperFolderCreateArg

    public init(swift: Paper.PaperFolderCreateArg) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible PaperFolderCreateError union
@objc
public class DBXPaperPaperFolderCreateError: NSObject {
    let swift: Paper.PaperFolderCreateError

    public init(swift: Paper.PaperFolderCreateError) {
        self.swift = swift
    }

    public static func factory(swift: Paper.PaperFolderCreateError) -> DBXPaperPaperFolderCreateError {
        switch swift {
        case .insufficientPermissions:
            return DBXPaperPaperFolderCreateErrorInsufficientPermissions()
        case .other:
            return DBXPaperPaperFolderCreateErrorOther()
        case .folderNotFound:
            return DBXPaperPaperFolderCreateErrorFolderNotFound()
        case .invalidFolderId:
            return DBXPaperPaperFolderCreateErrorInvalidFolderId()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asInsufficientPermissions: DBXPaperPaperFolderCreateErrorInsufficientPermissions? {
        self as? DBXPaperPaperFolderCreateErrorInsufficientPermissions
    }

    @objc
    public var asOther: DBXPaperPaperFolderCreateErrorOther? {
        self as? DBXPaperPaperFolderCreateErrorOther
    }

    @objc
    public var asFolderNotFound: DBXPaperPaperFolderCreateErrorFolderNotFound? {
        self as? DBXPaperPaperFolderCreateErrorFolderNotFound
    }

    @objc
    public var asInvalidFolderId: DBXPaperPaperFolderCreateErrorInvalidFolderId? {
        self as? DBXPaperPaperFolderCreateErrorInvalidFolderId
    }
}

/// Your account does not have permissions to perform this action. This may be due to it only having access to
/// Paper as files in the Dropbox filesystem. For more information, refer to the Paper Migration Guide
/// https://www.dropbox.com/lp/developers/reference/paper-migration-guide.
@objc
public class DBXPaperPaperFolderCreateErrorInsufficientPermissions: DBXPaperPaperFolderCreateError {
    @objc
    public init() {
        let swift = Paper.PaperFolderCreateError.insufficientPermissions
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXPaperPaperFolderCreateErrorOther: DBXPaperPaperFolderCreateError {
    @objc
    public init() {
        let swift = Paper.PaperFolderCreateError.other
        super.init(swift: swift)
    }
}

/// The specified parent Paper folder cannot be found.
@objc
public class DBXPaperPaperFolderCreateErrorFolderNotFound: DBXPaperPaperFolderCreateError {
    @objc
    public init() {
        let swift = Paper.PaperFolderCreateError.folderNotFound
        super.init(swift: swift)
    }
}

/// The folder id cannot be decrypted to valid folder id.
@objc
public class DBXPaperPaperFolderCreateErrorInvalidFolderId: DBXPaperPaperFolderCreateError {
    @objc
    public init() {
        let swift = Paper.PaperFolderCreateError.invalidFolderId
        super.init(swift: swift)
    }
}

/// Objective-C compatible PaperFolderCreateResult struct
@objc
public class DBXPaperPaperFolderCreateResult: NSObject {
    /// Folder ID of the newly created folder.
    @objc
    public var folderId: String { swift.folderId }

    @objc
    public init(folderId: String) {
        self.swift = Paper.PaperFolderCreateResult(folderId: folderId)
    }

    let swift: Paper.PaperFolderCreateResult

    public init(swift: Paper.PaperFolderCreateResult) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible RemovePaperDocUser struct
@objc
public class DBXPaperRemovePaperDocUser: DBXPaperRefPaperDoc {
    /// User which should be removed from the Paper doc. Specify only email address or Dropbox account ID.
    @objc
    public var member: DBXSharingMemberSelector { DBXSharingMemberSelector(swift: subSwift.member) }

    @objc
    public init(docId: String, member: DBXSharingMemberSelector) {
        let swift = Paper.RemovePaperDocUser(docId: docId, member: member.swift)
        self.subSwift = swift
        super.init(swift: swift)
    }

    let subSwift: Paper.RemovePaperDocUser

    public init(swift: Paper.RemovePaperDocUser) {
        self.subSwift = swift
        super.init(swift: swift)
    }

    @objc
    public override var description: String { subSwift.description }
}

/// Sharing policy of Paper doc.
@objc
public class DBXPaperSharingPolicy: NSObject {
    /// This value applies to the non-team members.
    @objc
    public var publicSharingPolicy: DBXPaperSharingPublicPolicyType? { guard let swift = swift.publicSharingPolicy else { return nil }
        return DBXPaperSharingPublicPolicyType(swift: swift)
    }

    /// This value applies to the team members only. The value is null for all personal accounts.
    @objc
    public var teamSharingPolicy: DBXPaperSharingTeamPolicyType? { guard let swift = swift.teamSharingPolicy else { return nil }
        return DBXPaperSharingTeamPolicyType(swift: swift)
    }

    @objc
    public init(publicSharingPolicy: DBXPaperSharingPublicPolicyType?, teamSharingPolicy: DBXPaperSharingTeamPolicyType?) {
        self.swift = Paper.SharingPolicy(publicSharingPolicy: publicSharingPolicy?.swift, teamSharingPolicy: teamSharingPolicy?.swift)
    }

    let swift: Paper.SharingPolicy

    public init(swift: Paper.SharingPolicy) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// The sharing policy type of the Paper doc.
@objc
public class DBXPaperSharingTeamPolicyType: NSObject {
    let swift: Paper.SharingTeamPolicyType

    public init(swift: Paper.SharingTeamPolicyType) {
        self.swift = swift
    }

    public static func factory(swift: Paper.SharingTeamPolicyType) -> DBXPaperSharingTeamPolicyType {
        switch swift {
        case .peopleWithLinkCanEdit:
            return DBXPaperSharingTeamPolicyTypePeopleWithLinkCanEdit()
        case .peopleWithLinkCanViewAndComment:
            return DBXPaperSharingTeamPolicyTypePeopleWithLinkCanViewAndComment()
        case .inviteOnly:
            return DBXPaperSharingTeamPolicyTypeInviteOnly()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asPeopleWithLinkCanEdit: DBXPaperSharingTeamPolicyTypePeopleWithLinkCanEdit? {
        self as? DBXPaperSharingTeamPolicyTypePeopleWithLinkCanEdit
    }

    @objc
    public var asPeopleWithLinkCanViewAndComment: DBXPaperSharingTeamPolicyTypePeopleWithLinkCanViewAndComment? {
        self as? DBXPaperSharingTeamPolicyTypePeopleWithLinkCanViewAndComment
    }

    @objc
    public var asInviteOnly: DBXPaperSharingTeamPolicyTypeInviteOnly? {
        self as? DBXPaperSharingTeamPolicyTypeInviteOnly
    }
}

/// Users who have a link to this doc can edit it.
@objc
public class DBXPaperSharingTeamPolicyTypePeopleWithLinkCanEdit: DBXPaperSharingTeamPolicyType {
    @objc
    public init() {
        let swift = Paper.SharingTeamPolicyType.peopleWithLinkCanEdit
        super.init(swift: swift)
    }
}

/// Users who have a link to this doc can view and comment on it.
@objc
public class DBXPaperSharingTeamPolicyTypePeopleWithLinkCanViewAndComment: DBXPaperSharingTeamPolicyType {
    @objc
    public init() {
        let swift = Paper.SharingTeamPolicyType.peopleWithLinkCanViewAndComment
        super.init(swift: swift)
    }
}

/// Users must be explicitly invited to this doc.
@objc
public class DBXPaperSharingTeamPolicyTypeInviteOnly: DBXPaperSharingTeamPolicyType {
    @objc
    public init() {
        let swift = Paper.SharingTeamPolicyType.inviteOnly
        super.init(swift: swift)
    }
}

/// Objective-C compatible SharingPublicPolicyType union
@objc
public class DBXPaperSharingPublicPolicyType: NSObject {
    let swift: Paper.SharingPublicPolicyType

    public init(swift: Paper.SharingPublicPolicyType) {
        self.swift = swift
    }

    public static func factory(swift: Paper.SharingPublicPolicyType) -> DBXPaperSharingPublicPolicyType {
        switch swift {
        case .peopleWithLinkCanEdit:
            return DBXPaperSharingPublicPolicyTypePeopleWithLinkCanEdit()
        case .peopleWithLinkCanViewAndComment:
            return DBXPaperSharingPublicPolicyTypePeopleWithLinkCanViewAndComment()
        case .inviteOnly:
            return DBXPaperSharingPublicPolicyTypeInviteOnly()
        case .disabled:
            return DBXPaperSharingPublicPolicyTypeDisabled()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asPeopleWithLinkCanEdit: DBXPaperSharingPublicPolicyTypePeopleWithLinkCanEdit? {
        self as? DBXPaperSharingPublicPolicyTypePeopleWithLinkCanEdit
    }

    @objc
    public var asPeopleWithLinkCanViewAndComment: DBXPaperSharingPublicPolicyTypePeopleWithLinkCanViewAndComment? {
        self as? DBXPaperSharingPublicPolicyTypePeopleWithLinkCanViewAndComment
    }

    @objc
    public var asInviteOnly: DBXPaperSharingPublicPolicyTypeInviteOnly? {
        self as? DBXPaperSharingPublicPolicyTypeInviteOnly
    }

    @objc
    public var asDisabled: DBXPaperSharingPublicPolicyTypeDisabled? {
        self as? DBXPaperSharingPublicPolicyTypeDisabled
    }
}

/// Users who have a link to this doc can edit it.
@objc
public class DBXPaperSharingPublicPolicyTypePeopleWithLinkCanEdit: DBXPaperSharingPublicPolicyType {
    @objc
    public init() {
        let swift = Paper.SharingPublicPolicyType.peopleWithLinkCanEdit
        super.init(swift: swift)
    }
}

/// Users who have a link to this doc can view and comment on it.
@objc
public class DBXPaperSharingPublicPolicyTypePeopleWithLinkCanViewAndComment: DBXPaperSharingPublicPolicyType {
    @objc
    public init() {
        let swift = Paper.SharingPublicPolicyType.peopleWithLinkCanViewAndComment
        super.init(swift: swift)
    }
}

/// Users must be explicitly invited to this doc.
@objc
public class DBXPaperSharingPublicPolicyTypeInviteOnly: DBXPaperSharingPublicPolicyType {
    @objc
    public init() {
        let swift = Paper.SharingPublicPolicyType.inviteOnly
        super.init(swift: swift)
    }
}

/// Value used to indicate that doc sharing is enabled only within team.
@objc
public class DBXPaperSharingPublicPolicyTypeDisabled: DBXPaperSharingPublicPolicyType {
    @objc
    public init() {
        let swift = Paper.SharingPublicPolicyType.disabled
        super.init(swift: swift)
    }
}

/// Objective-C compatible UserInfoWithPermissionLevel struct
@objc
public class DBXPaperUserInfoWithPermissionLevel: NSObject {
    /// User shared on the Paper doc.
    @objc
    public var user: DBXSharingUserInfo { DBXSharingUserInfo(swift: swift.user) }
    /// Permission level for the user.
    @objc
    public var permissionLevel: DBXPaperPaperDocPermissionLevel { DBXPaperPaperDocPermissionLevel(swift: swift.permissionLevel) }

    @objc
    public init(user: DBXSharingUserInfo, permissionLevel: DBXPaperPaperDocPermissionLevel) {
        self.swift = Paper.UserInfoWithPermissionLevel(user: user.swift, permissionLevel: permissionLevel.swift)
    }

    let swift: Paper.UserInfoWithPermissionLevel

    public init(swift: Paper.UserInfoWithPermissionLevel) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible UserOnPaperDocFilter union
@objc
public class DBXPaperUserOnPaperDocFilter: NSObject {
    let swift: Paper.UserOnPaperDocFilter

    public init(swift: Paper.UserOnPaperDocFilter) {
        self.swift = swift
    }

    public static func factory(swift: Paper.UserOnPaperDocFilter) -> DBXPaperUserOnPaperDocFilter {
        switch swift {
        case .visited:
            return DBXPaperUserOnPaperDocFilterVisited()
        case .shared:
            return DBXPaperUserOnPaperDocFilterShared()
        case .other:
            return DBXPaperUserOnPaperDocFilterOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asVisited: DBXPaperUserOnPaperDocFilterVisited? {
        self as? DBXPaperUserOnPaperDocFilterVisited
    }

    @objc
    public var asShared: DBXPaperUserOnPaperDocFilterShared? {
        self as? DBXPaperUserOnPaperDocFilterShared
    }

    @objc
    public var asOther: DBXPaperUserOnPaperDocFilterOther? {
        self as? DBXPaperUserOnPaperDocFilterOther
    }
}

/// all users who have visited the Paper doc.
@objc
public class DBXPaperUserOnPaperDocFilterVisited: DBXPaperUserOnPaperDocFilter {
    @objc
    public init() {
        let swift = Paper.UserOnPaperDocFilter.visited
        super.init(swift: swift)
    }
}

/// All uses who are shared on the Paper doc. This includes all users who have visited the Paper doc as well as
/// those who have not.
@objc
public class DBXPaperUserOnPaperDocFilterShared: DBXPaperUserOnPaperDocFilter {
    @objc
    public init() {
        let swift = Paper.UserOnPaperDocFilter.shared
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXPaperUserOnPaperDocFilterOther: DBXPaperUserOnPaperDocFilter {
    @objc
    public init() {
        let swift = Paper.UserOnPaperDocFilter.other
        super.init(swift: swift)
    }
}
