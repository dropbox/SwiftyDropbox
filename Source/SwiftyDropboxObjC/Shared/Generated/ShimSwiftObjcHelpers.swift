///
/// Copyright (c) 2024 Dropbox, Inc. All rights reserved.
///
/// Auto-generated by Stone, do not modify.
///

import Foundation
import stone_sdk_objc
import stone_sdk_swift
import stone_sdk_swift_objc

@objc
public class SDKShimHelpers: NSObject {
    // MARK: DBAPIRpcTask

    @objc
    @discardableResult public static func setResponseBlockRPC(
        block: @escaping DBRpcResponseBlockImpl,
        on task: DBXRequest,
        with queue: OperationQueue?,
        analyticsBlock: AnalyticsBlock?
    ) -> Bool {
        if let task = task as? DBXAccountSetProfilePhotoRpcRequest {
            task.response(analyticsBlock: analyticsBlock) { result, routeError, networkError in
                let mappedResult = mapDBXAccountSetProfilePhotoResultToDBOptional(object: result)
                let mappedError = mapDBXAccountSetProfilePhotoErrorToDBOptional(object: routeError)
                let mappedCallError = callErrorToDB(error: networkError)
                let wrappedBlock = { block(mappedResult, mappedError, mappedCallError) }
                Self.processCompletion(wrappedBlock, queue: queue)
            }
            return true
        }
        if let task = task as? DBXAuthTokenRevokeRpcRequest {
            task.response(analyticsBlock: analyticsBlock) { networkError in
                let mappedCallError = callErrorToDB(error: networkError)
                let wrappedBlock = { block(networkError == nil ? DBNilObject() : nil, nil, mappedCallError) }
                Self.processCompletion(wrappedBlock, queue: queue)
            }
            return true
        }
        if let task = task as? DBXCheckUserRpcRequest {
            task.response(analyticsBlock: analyticsBlock) { result, networkError in
                let mappedResult = mapDBXCheckEchoResultToDBOptional(object: result)
                let mappedCallError = callErrorToDB(error: networkError)
                let wrappedBlock = { block(mappedResult, nil, mappedCallError) }
                Self.processCompletion(wrappedBlock, queue: queue)
            }
            return true
        }
        if let task = task as? DBXContactsDeleteManualContactsRpcRequest {
            task.response(analyticsBlock: analyticsBlock) { networkError in
                let mappedCallError = callErrorToDB(error: networkError)
                let wrappedBlock = { block(networkError == nil ? DBNilObject() : nil, nil, mappedCallError) }
                Self.processCompletion(wrappedBlock, queue: queue)
            }
            return true
        }
        if let task = task as? DBXContactsDeleteManualContactsBatchRpcRequest {
            task.response(analyticsBlock: analyticsBlock) { routeError, networkError in
                let mappedError = mapDBXContactsDeleteManualContactsErrorToDBOptional(object: routeError)
                let mappedCallError = callErrorToDB(error: networkError)
                let wrappedBlock = { block((networkError == nil && routeError == nil) ? DBNilObject() : nil, mappedError, mappedCallError) }
                Self.processCompletion(wrappedBlock, queue: queue)
            }
            return true
        }
        if let task = task as? DBXFilePropertiesPropertiesAddRpcRequest {
            task.response(analyticsBlock: analyticsBlock) { routeError, networkError in
                let mappedError = mapDBXFilePropertiesAddPropertiesErrorToDBOptional(object: routeError)
                let mappedCallError = callErrorToDB(error: networkError)
                let wrappedBlock = { block((networkError == nil && routeError == nil) ? DBNilObject() : nil, mappedError, mappedCallError) }
                Self.processCompletion(wrappedBlock, queue: queue)
            }
            return true
        }
        if let task = task as? DBXFilePropertiesPropertiesOverwriteRpcRequest {
            task.response(analyticsBlock: analyticsBlock) { routeError, networkError in
                let mappedError = mapDBXFilePropertiesInvalidPropertyGroupErrorToDBOptional(object: routeError)
                let mappedCallError = callErrorToDB(error: networkError)
                let wrappedBlock = { block((networkError == nil && routeError == nil) ? DBNilObject() : nil, mappedError, mappedCallError) }
                Self.processCompletion(wrappedBlock, queue: queue)
            }
            return true
        }
        if let task = task as? DBXFilePropertiesPropertiesRemoveRpcRequest {
            task.response(analyticsBlock: analyticsBlock) { routeError, networkError in
                let mappedError = mapDBXFilePropertiesRemovePropertiesErrorToDBOptional(object: routeError)
                let mappedCallError = callErrorToDB(error: networkError)
                let wrappedBlock = { block((networkError == nil && routeError == nil) ? DBNilObject() : nil, mappedError, mappedCallError) }
                Self.processCompletion(wrappedBlock, queue: queue)
            }
            return true
        }
        if let task = task as? DBXFilePropertiesPropertiesSearchRpcRequest {
            task.response(analyticsBlock: analyticsBlock) { result, routeError, networkError in
                let mappedResult = mapDBXFilePropertiesPropertiesSearchResultToDBOptional(object: result)
                let mappedError = mapDBXFilePropertiesPropertiesSearchErrorToDBOptional(object: routeError)
                let mappedCallError = callErrorToDB(error: networkError)
                let wrappedBlock = { block(mappedResult, mappedError, mappedCallError) }
                Self.processCompletion(wrappedBlock, queue: queue)
            }
            return true
        }
        if let task = task as? DBXFilePropertiesPropertiesSearchContinueRpcRequest {
            task.response(analyticsBlock: analyticsBlock) { result, routeError, networkError in
                let mappedResult = mapDBXFilePropertiesPropertiesSearchResultToDBOptional(object: result)
                let mappedError = mapDBXFilePropertiesPropertiesSearchContinueErrorToDBOptional(object: routeError)
                let mappedCallError = callErrorToDB(error: networkError)
                let wrappedBlock = { block(mappedResult, mappedError, mappedCallError) }
                Self.processCompletion(wrappedBlock, queue: queue)
            }
            return true
        }
        if let task = task as? DBXFilePropertiesPropertiesUpdateRpcRequest {
            task.response(analyticsBlock: analyticsBlock) { routeError, networkError in
                let mappedError = mapDBXFilePropertiesUpdatePropertiesErrorToDBOptional(object: routeError)
                let mappedCallError = callErrorToDB(error: networkError)
                let wrappedBlock = { block((networkError == nil && routeError == nil) ? DBNilObject() : nil, mappedError, mappedCallError) }
                Self.processCompletion(wrappedBlock, queue: queue)
            }
            return true
        }
        if let task = task as? DBXFilePropertiesTemplatesAddForUserRpcRequest {
            task.response(analyticsBlock: analyticsBlock) { result, routeError, networkError in
                let mappedResult = mapDBXFilePropertiesAddTemplateResultToDBOptional(object: result)
                let mappedError = mapDBXFilePropertiesModifyTemplateErrorToDBOptional(object: routeError)
                let mappedCallError = callErrorToDB(error: networkError)
                let wrappedBlock = { block(mappedResult, mappedError, mappedCallError) }
                Self.processCompletion(wrappedBlock, queue: queue)
            }
            return true
        }
        if let task = task as? DBXFilePropertiesTemplatesGetForUserRpcRequest {
            task.response(analyticsBlock: analyticsBlock) { result, routeError, networkError in
                let mappedResult = mapDBXFilePropertiesGetTemplateResultToDBOptional(object: result)
                let mappedError = mapDBXFilePropertiesTemplateErrorToDBOptional(object: routeError)
                let mappedCallError = callErrorToDB(error: networkError)
                let wrappedBlock = { block(mappedResult, mappedError, mappedCallError) }
                Self.processCompletion(wrappedBlock, queue: queue)
            }
            return true
        }
        if let task = task as? DBXFilePropertiesTemplatesListForUserRpcRequest {
            task.response(analyticsBlock: analyticsBlock) { result, routeError, networkError in
                let mappedResult = mapDBXFilePropertiesListTemplateResultToDBOptional(object: result)
                let mappedError = mapDBXFilePropertiesTemplateErrorToDBOptional(object: routeError)
                let mappedCallError = callErrorToDB(error: networkError)
                let wrappedBlock = { block(mappedResult, mappedError, mappedCallError) }
                Self.processCompletion(wrappedBlock, queue: queue)
            }
            return true
        }
        if let task = task as? DBXFilePropertiesTemplatesRemoveForUserRpcRequest {
            task.response(analyticsBlock: analyticsBlock) { routeError, networkError in
                let mappedError = mapDBXFilePropertiesTemplateErrorToDBOptional(object: routeError)
                let mappedCallError = callErrorToDB(error: networkError)
                let wrappedBlock = { block((networkError == nil && routeError == nil) ? DBNilObject() : nil, mappedError, mappedCallError) }
                Self.processCompletion(wrappedBlock, queue: queue)
            }
            return true
        }
        if let task = task as? DBXFilePropertiesTemplatesUpdateForUserRpcRequest {
            task.response(analyticsBlock: analyticsBlock) { result, routeError, networkError in
                let mappedResult = mapDBXFilePropertiesUpdateTemplateResultToDBOptional(object: result)
                let mappedError = mapDBXFilePropertiesModifyTemplateErrorToDBOptional(object: routeError)
                let mappedCallError = callErrorToDB(error: networkError)
                let wrappedBlock = { block(mappedResult, mappedError, mappedCallError) }
                Self.processCompletion(wrappedBlock, queue: queue)
            }
            return true
        }
        if let task = task as? DBXFileRequestsCountRpcRequest {
            task.response(analyticsBlock: analyticsBlock) { result, routeError, networkError in
                let mappedResult = mapDBXFileRequestsCountFileRequestsResultToDBOptional(object: result)
                let mappedError = mapDBXFileRequestsCountFileRequestsErrorToDBOptional(object: routeError)
                let mappedCallError = callErrorToDB(error: networkError)
                let wrappedBlock = { block(mappedResult, mappedError, mappedCallError) }
                Self.processCompletion(wrappedBlock, queue: queue)
            }
            return true
        }
        if let task = task as? DBXFileRequestsCreateRpcRequest {
            task.response(analyticsBlock: analyticsBlock) { result, routeError, networkError in
                let mappedResult = mapDBXFileRequestsFileRequestToDBOptional(object: result)
                let mappedError = mapDBXFileRequestsCreateFileRequestErrorToDBOptional(object: routeError)
                let mappedCallError = callErrorToDB(error: networkError)
                let wrappedBlock = { block(mappedResult, mappedError, mappedCallError) }
                Self.processCompletion(wrappedBlock, queue: queue)
            }
            return true
        }
        if let task = task as? DBXFileRequestsDeleteRpcRequest {
            task.response(analyticsBlock: analyticsBlock) { result, routeError, networkError in
                let mappedResult = mapDBXFileRequestsDeleteFileRequestsResultToDBOptional(object: result)
                let mappedError = mapDBXFileRequestsDeleteFileRequestErrorToDBOptional(object: routeError)
                let mappedCallError = callErrorToDB(error: networkError)
                let wrappedBlock = { block(mappedResult, mappedError, mappedCallError) }
                Self.processCompletion(wrappedBlock, queue: queue)
            }
            return true
        }
        if let task = task as? DBXFileRequestsDeleteAllClosedRpcRequest {
            task.response(analyticsBlock: analyticsBlock) { result, routeError, networkError in
                let mappedResult = mapDBXFileRequestsDeleteAllClosedFileRequestsResultToDBOptional(object: result)
                let mappedError = mapDBXFileRequestsDeleteAllClosedFileRequestsErrorToDBOptional(object: routeError)
                let mappedCallError = callErrorToDB(error: networkError)
                let wrappedBlock = { block(mappedResult, mappedError, mappedCallError) }
                Self.processCompletion(wrappedBlock, queue: queue)
            }
            return true
        }
        if let task = task as? DBXFileRequestsGetRpcRequest {
            task.response(analyticsBlock: analyticsBlock) { result, routeError, networkError in
                let mappedResult = mapDBXFileRequestsFileRequestToDBOptional(object: result)
                let mappedError = mapDBXFileRequestsGetFileRequestErrorToDBOptional(object: routeError)
                let mappedCallError = callErrorToDB(error: networkError)
                let wrappedBlock = { block(mappedResult, mappedError, mappedCallError) }
                Self.processCompletion(wrappedBlock, queue: queue)
            }
            return true
        }
        if let task = task as? DBXFileRequestsList_RpcRequest {
            task.response(analyticsBlock: analyticsBlock) { result, routeError, networkError in
                let mappedResult = mapDBXFileRequestsListFileRequestsResultToDBOptional(object: result)
                let mappedError = mapDBXFileRequestsListFileRequestsErrorToDBOptional(object: routeError)
                let mappedCallError = callErrorToDB(error: networkError)
                let wrappedBlock = { block(mappedResult, mappedError, mappedCallError) }
                Self.processCompletion(wrappedBlock, queue: queue)
            }
            return true
        }
        if let task = task as? DBXFileRequestsList_RpcRequestV2 {
            task.response(analyticsBlock: analyticsBlock) { result, routeError, networkError in
                let mappedResult = mapDBXFileRequestsListFileRequestsV2ResultToDBOptional(object: result)
                let mappedError = mapDBXFileRequestsListFileRequestsErrorToDBOptional(object: routeError)
                let mappedCallError = callErrorToDB(error: networkError)
                let wrappedBlock = { block(mappedResult, mappedError, mappedCallError) }
                Self.processCompletion(wrappedBlock, queue: queue)
            }
            return true
        }
        if let task = task as? DBXFileRequestsListContinueRpcRequest {
            task.response(analyticsBlock: analyticsBlock) { result, routeError, networkError in
                let mappedResult = mapDBXFileRequestsListFileRequestsV2ResultToDBOptional(object: result)
                let mappedError = mapDBXFileRequestsListFileRequestsContinueErrorToDBOptional(object: routeError)
                let mappedCallError = callErrorToDB(error: networkError)
                let wrappedBlock = { block(mappedResult, mappedError, mappedCallError) }
                Self.processCompletion(wrappedBlock, queue: queue)
            }
            return true
        }
        if let task = task as? DBXFileRequestsUpdateRpcRequest {
            task.response(analyticsBlock: analyticsBlock) { result, routeError, networkError in
                let mappedResult = mapDBXFileRequestsFileRequestToDBOptional(object: result)
                let mappedError = mapDBXFileRequestsUpdateFileRequestErrorToDBOptional(object: routeError)
                let mappedCallError = callErrorToDB(error: networkError)
                let wrappedBlock = { block(mappedResult, mappedError, mappedCallError) }
                Self.processCompletion(wrappedBlock, queue: queue)
            }
            return true
        }
        if let task = task as? DBXFilesCopyRpcRequestV2 {
            task.response(analyticsBlock: analyticsBlock) { result, routeError, networkError in
                let mappedResult = mapDBXFilesRelocationResultToDBOptional(object: result)
                let mappedError = mapDBXFilesRelocationErrorToDBOptional(object: routeError)
                let mappedCallError = callErrorToDB(error: networkError)
                let wrappedBlock = { block(mappedResult, mappedError, mappedCallError) }
                Self.processCompletion(wrappedBlock, queue: queue)
            }
            return true
        }
        if let task = task as? DBXFilesCopyBatchRpcRequestV2 {
            task.response(analyticsBlock: analyticsBlock) { result, networkError in
                let mappedResult = mapDBXFilesRelocationBatchV2LaunchToDBOptional(object: result)
                let mappedCallError = callErrorToDB(error: networkError)
                let wrappedBlock = { block(mappedResult, nil, mappedCallError) }
                Self.processCompletion(wrappedBlock, queue: queue)
            }
            return true
        }
        if let task = task as? DBXFilesCopyBatchCheckRpcRequestV2 {
            task.response(analyticsBlock: analyticsBlock) { result, routeError, networkError in
                let mappedResult = mapDBXFilesRelocationBatchV2JobStatusToDBOptional(object: result)
                let mappedError = mapDBXAsyncPollErrorToDBOptional(object: routeError)
                let mappedCallError = callErrorToDB(error: networkError)
                let wrappedBlock = { block(mappedResult, mappedError, mappedCallError) }
                Self.processCompletion(wrappedBlock, queue: queue)
            }
            return true
        }
        if let task = task as? DBXFilesCopyReferenceGetRpcRequest {
            task.response(analyticsBlock: analyticsBlock) { result, routeError, networkError in
                let mappedResult = mapDBXFilesGetCopyReferenceResultToDBOptional(object: result)
                let mappedError = mapDBXFilesGetCopyReferenceErrorToDBOptional(object: routeError)
                let mappedCallError = callErrorToDB(error: networkError)
                let wrappedBlock = { block(mappedResult, mappedError, mappedCallError) }
                Self.processCompletion(wrappedBlock, queue: queue)
            }
            return true
        }
        if let task = task as? DBXFilesCopyReferenceSaveRpcRequest {
            task.response(analyticsBlock: analyticsBlock) { result, routeError, networkError in
                let mappedResult = mapDBXFilesSaveCopyReferenceResultToDBOptional(object: result)
                let mappedError = mapDBXFilesSaveCopyReferenceErrorToDBOptional(object: routeError)
                let mappedCallError = callErrorToDB(error: networkError)
                let wrappedBlock = { block(mappedResult, mappedError, mappedCallError) }
                Self.processCompletion(wrappedBlock, queue: queue)
            }
            return true
        }
        if let task = task as? DBXFilesCreateFolderRpcRequestV2 {
            task.response(analyticsBlock: analyticsBlock) { result, routeError, networkError in
                let mappedResult = mapDBXFilesCreateFolderResultToDBOptional(object: result)
                let mappedError = mapDBXFilesCreateFolderErrorToDBOptional(object: routeError)
                let mappedCallError = callErrorToDB(error: networkError)
                let wrappedBlock = { block(mappedResult, mappedError, mappedCallError) }
                Self.processCompletion(wrappedBlock, queue: queue)
            }
            return true
        }
        if let task = task as? DBXFilesCreateFolderBatchRpcRequest {
            task.response(analyticsBlock: analyticsBlock) { result, networkError in
                let mappedResult = mapDBXFilesCreateFolderBatchLaunchToDBOptional(object: result)
                let mappedCallError = callErrorToDB(error: networkError)
                let wrappedBlock = { block(mappedResult, nil, mappedCallError) }
                Self.processCompletion(wrappedBlock, queue: queue)
            }
            return true
        }
        if let task = task as? DBXFilesCreateFolderBatchCheckRpcRequest {
            task.response(analyticsBlock: analyticsBlock) { result, routeError, networkError in
                let mappedResult = mapDBXFilesCreateFolderBatchJobStatusToDBOptional(object: result)
                let mappedError = mapDBXAsyncPollErrorToDBOptional(object: routeError)
                let mappedCallError = callErrorToDB(error: networkError)
                let wrappedBlock = { block(mappedResult, mappedError, mappedCallError) }
                Self.processCompletion(wrappedBlock, queue: queue)
            }
            return true
        }
        if let task = task as? DBXFilesDeleteRpcRequestV2 {
            task.response(analyticsBlock: analyticsBlock) { result, routeError, networkError in
                let mappedResult = mapDBXFilesDeleteResultToDBOptional(object: result)
                let mappedError = mapDBXFilesDeleteErrorToDBOptional(object: routeError)
                let mappedCallError = callErrorToDB(error: networkError)
                let wrappedBlock = { block(mappedResult, mappedError, mappedCallError) }
                Self.processCompletion(wrappedBlock, queue: queue)
            }
            return true
        }
        if let task = task as? DBXFilesDeleteBatchRpcRequest {
            task.response(analyticsBlock: analyticsBlock) { result, networkError in
                let mappedResult = mapDBXFilesDeleteBatchLaunchToDBOptional(object: result)
                let mappedCallError = callErrorToDB(error: networkError)
                let wrappedBlock = { block(mappedResult, nil, mappedCallError) }
                Self.processCompletion(wrappedBlock, queue: queue)
            }
            return true
        }
        if let task = task as? DBXFilesDeleteBatchCheckRpcRequest {
            task.response(analyticsBlock: analyticsBlock) { result, routeError, networkError in
                let mappedResult = mapDBXFilesDeleteBatchJobStatusToDBOptional(object: result)
                let mappedError = mapDBXAsyncPollErrorToDBOptional(object: routeError)
                let mappedCallError = callErrorToDB(error: networkError)
                let wrappedBlock = { block(mappedResult, mappedError, mappedCallError) }
                Self.processCompletion(wrappedBlock, queue: queue)
            }
            return true
        }
        if let task = task as? DBXFilesGetFileLockBatchRpcRequest {
            task.response(analyticsBlock: analyticsBlock) { result, routeError, networkError in
                let mappedResult = mapDBXFilesLockFileBatchResultToDBOptional(object: result)
                let mappedError = mapDBXFilesLockFileErrorToDBOptional(object: routeError)
                let mappedCallError = callErrorToDB(error: networkError)
                let wrappedBlock = { block(mappedResult, mappedError, mappedCallError) }
                Self.processCompletion(wrappedBlock, queue: queue)
            }
            return true
        }
        if let task = task as? DBXFilesGetMetadataRpcRequest {
            task.response(analyticsBlock: analyticsBlock) { result, routeError, networkError in
                let mappedResult = mapDBXFilesMetadataToDBOptional(object: result)
                let mappedError = mapDBXFilesGetMetadataErrorToDBOptional(object: routeError)
                let mappedCallError = callErrorToDB(error: networkError)
                let wrappedBlock = { block(mappedResult, mappedError, mappedCallError) }
                Self.processCompletion(wrappedBlock, queue: queue)
            }
            return true
        }
        if let task = task as? DBXFilesGetTemporaryLinkRpcRequest {
            task.response(analyticsBlock: analyticsBlock) { result, routeError, networkError in
                let mappedResult = mapDBXFilesGetTemporaryLinkResultToDBOptional(object: result)
                let mappedError = mapDBXFilesGetTemporaryLinkErrorToDBOptional(object: routeError)
                let mappedCallError = callErrorToDB(error: networkError)
                let wrappedBlock = { block(mappedResult, mappedError, mappedCallError) }
                Self.processCompletion(wrappedBlock, queue: queue)
            }
            return true
        }
        if let task = task as? DBXFilesGetTemporaryUploadLinkRpcRequest {
            task.response(analyticsBlock: analyticsBlock) { result, networkError in
                let mappedResult = mapDBXFilesGetTemporaryUploadLinkResultToDBOptional(object: result)
                let mappedCallError = callErrorToDB(error: networkError)
                let wrappedBlock = { block(mappedResult, nil, mappedCallError) }
                Self.processCompletion(wrappedBlock, queue: queue)
            }
            return true
        }
        if let task = task as? DBXFilesGetThumbnailBatchRpcRequest {
            task.response(analyticsBlock: analyticsBlock) { result, routeError, networkError in
                let mappedResult = mapDBXFilesGetThumbnailBatchResultToDBOptional(object: result)
                let mappedError = mapDBXFilesGetThumbnailBatchErrorToDBOptional(object: routeError)
                let mappedCallError = callErrorToDB(error: networkError)
                let wrappedBlock = { block(mappedResult, mappedError, mappedCallError) }
                Self.processCompletion(wrappedBlock, queue: queue)
            }
            return true
        }
        if let task = task as? DBXFilesListFolderRpcRequest {
            task.response(analyticsBlock: analyticsBlock) { result, routeError, networkError in
                let mappedResult = mapDBXFilesListFolderResultToDBOptional(object: result)
                let mappedError = mapDBXFilesListFolderErrorToDBOptional(object: routeError)
                let mappedCallError = callErrorToDB(error: networkError)
                let wrappedBlock = { block(mappedResult, mappedError, mappedCallError) }
                Self.processCompletion(wrappedBlock, queue: queue)
            }
            return true
        }
        if let task = task as? DBXFilesListFolderContinueRpcRequest {
            task.response(analyticsBlock: analyticsBlock) { result, routeError, networkError in
                let mappedResult = mapDBXFilesListFolderResultToDBOptional(object: result)
                let mappedError = mapDBXFilesListFolderContinueErrorToDBOptional(object: routeError)
                let mappedCallError = callErrorToDB(error: networkError)
                let wrappedBlock = { block(mappedResult, mappedError, mappedCallError) }
                Self.processCompletion(wrappedBlock, queue: queue)
            }
            return true
        }
        if let task = task as? DBXFilesListFolderGetLatestCursorRpcRequest {
            task.response(analyticsBlock: analyticsBlock) { result, routeError, networkError in
                let mappedResult = mapDBXFilesListFolderGetLatestCursorResultToDBOptional(object: result)
                let mappedError = mapDBXFilesListFolderErrorToDBOptional(object: routeError)
                let mappedCallError = callErrorToDB(error: networkError)
                let wrappedBlock = { block(mappedResult, mappedError, mappedCallError) }
                Self.processCompletion(wrappedBlock, queue: queue)
            }
            return true
        }
        if let task = task as? DBXFilesListFolderLongpollRpcRequest {
            task.response(analyticsBlock: analyticsBlock) { result, routeError, networkError in
                let mappedResult = mapDBXFilesListFolderLongpollResultToDBOptional(object: result)
                let mappedError = mapDBXFilesListFolderLongpollErrorToDBOptional(object: routeError)
                let mappedCallError = callErrorToDB(error: networkError)
                let wrappedBlock = { block(mappedResult, mappedError, mappedCallError) }
                Self.processCompletion(wrappedBlock, queue: queue)
            }
            return true
        }
        if let task = task as? DBXFilesListRevisionsRpcRequest {
            task.response(analyticsBlock: analyticsBlock) { result, routeError, networkError in
                let mappedResult = mapDBXFilesListRevisionsResultToDBOptional(object: result)
                let mappedError = mapDBXFilesListRevisionsErrorToDBOptional(object: routeError)
                let mappedCallError = callErrorToDB(error: networkError)
                let wrappedBlock = { block(mappedResult, mappedError, mappedCallError) }
                Self.processCompletion(wrappedBlock, queue: queue)
            }
            return true
        }
        if let task = task as? DBXFilesLockFileBatchRpcRequest {
            task.response(analyticsBlock: analyticsBlock) { result, routeError, networkError in
                let mappedResult = mapDBXFilesLockFileBatchResultToDBOptional(object: result)
                let mappedError = mapDBXFilesLockFileErrorToDBOptional(object: routeError)
                let mappedCallError = callErrorToDB(error: networkError)
                let wrappedBlock = { block(mappedResult, mappedError, mappedCallError) }
                Self.processCompletion(wrappedBlock, queue: queue)
            }
            return true
        }
        if let task = task as? DBXFilesMoveRpcRequestV2 {
            task.response(analyticsBlock: analyticsBlock) { result, routeError, networkError in
                let mappedResult = mapDBXFilesRelocationResultToDBOptional(object: result)
                let mappedError = mapDBXFilesRelocationErrorToDBOptional(object: routeError)
                let mappedCallError = callErrorToDB(error: networkError)
                let wrappedBlock = { block(mappedResult, mappedError, mappedCallError) }
                Self.processCompletion(wrappedBlock, queue: queue)
            }
            return true
        }
        if let task = task as? DBXFilesMoveBatchRpcRequestV2 {
            task.response(analyticsBlock: analyticsBlock) { result, networkError in
                let mappedResult = mapDBXFilesRelocationBatchV2LaunchToDBOptional(object: result)
                let mappedCallError = callErrorToDB(error: networkError)
                let wrappedBlock = { block(mappedResult, nil, mappedCallError) }
                Self.processCompletion(wrappedBlock, queue: queue)
            }
            return true
        }
        if let task = task as? DBXFilesMoveBatchCheckRpcRequestV2 {
            task.response(analyticsBlock: analyticsBlock) { result, routeError, networkError in
                let mappedResult = mapDBXFilesRelocationBatchV2JobStatusToDBOptional(object: result)
                let mappedError = mapDBXAsyncPollErrorToDBOptional(object: routeError)
                let mappedCallError = callErrorToDB(error: networkError)
                let wrappedBlock = { block(mappedResult, mappedError, mappedCallError) }
                Self.processCompletion(wrappedBlock, queue: queue)
            }
            return true
        }
        if let task = task as? DBXFilesPermanentlyDeleteRpcRequest {
            task.response(analyticsBlock: analyticsBlock) { routeError, networkError in
                let mappedError = mapDBXFilesDeleteErrorToDBOptional(object: routeError)
                let mappedCallError = callErrorToDB(error: networkError)
                let wrappedBlock = { block((networkError == nil && routeError == nil) ? DBNilObject() : nil, mappedError, mappedCallError) }
                Self.processCompletion(wrappedBlock, queue: queue)
            }
            return true
        }
        if let task = task as? DBXFilesRestoreRpcRequest {
            task.response(analyticsBlock: analyticsBlock) { result, routeError, networkError in
                let mappedResult = mapDBXFilesFileMetadataToDBOptional(object: result)
                let mappedError = mapDBXFilesRestoreErrorToDBOptional(object: routeError)
                let mappedCallError = callErrorToDB(error: networkError)
                let wrappedBlock = { block(mappedResult, mappedError, mappedCallError) }
                Self.processCompletion(wrappedBlock, queue: queue)
            }
            return true
        }
        if let task = task as? DBXFilesSaveUrlRpcRequest {
            task.response(analyticsBlock: analyticsBlock) { result, routeError, networkError in
                let mappedResult = mapDBXFilesSaveUrlResultToDBOptional(object: result)
                let mappedError = mapDBXFilesSaveUrlErrorToDBOptional(object: routeError)
                let mappedCallError = callErrorToDB(error: networkError)
                let wrappedBlock = { block(mappedResult, mappedError, mappedCallError) }
                Self.processCompletion(wrappedBlock, queue: queue)
            }
            return true
        }
        if let task = task as? DBXFilesSaveUrlCheckJobStatusRpcRequest {
            task.response(analyticsBlock: analyticsBlock) { result, routeError, networkError in
                let mappedResult = mapDBXFilesSaveUrlJobStatusToDBOptional(object: result)
                let mappedError = mapDBXAsyncPollErrorToDBOptional(object: routeError)
                let mappedCallError = callErrorToDB(error: networkError)
                let wrappedBlock = { block(mappedResult, mappedError, mappedCallError) }
                Self.processCompletion(wrappedBlock, queue: queue)
            }
            return true
        }
        if let task = task as? DBXFilesSearchRpcRequestV2 {
            task.response(analyticsBlock: analyticsBlock) { result, routeError, networkError in
                let mappedResult = mapDBXFilesSearchV2ResultToDBOptional(object: result)
                let mappedError = mapDBXFilesSearchErrorToDBOptional(object: routeError)
                let mappedCallError = callErrorToDB(error: networkError)
                let wrappedBlock = { block(mappedResult, mappedError, mappedCallError) }
                Self.processCompletion(wrappedBlock, queue: queue)
            }
            return true
        }
        if let task = task as? DBXFilesSearchContinueRpcRequestV2 {
            task.response(analyticsBlock: analyticsBlock) { result, routeError, networkError in
                let mappedResult = mapDBXFilesSearchV2ResultToDBOptional(object: result)
                let mappedError = mapDBXFilesSearchErrorToDBOptional(object: routeError)
                let mappedCallError = callErrorToDB(error: networkError)
                let wrappedBlock = { block(mappedResult, mappedError, mappedCallError) }
                Self.processCompletion(wrappedBlock, queue: queue)
            }
            return true
        }
        if let task = task as? DBXFilesTagsAddRpcRequest {
            task.response(analyticsBlock: analyticsBlock) { routeError, networkError in
                let mappedError = mapDBXFilesAddTagErrorToDBOptional(object: routeError)
                let mappedCallError = callErrorToDB(error: networkError)
                let wrappedBlock = { block((networkError == nil && routeError == nil) ? DBNilObject() : nil, mappedError, mappedCallError) }
                Self.processCompletion(wrappedBlock, queue: queue)
            }
            return true
        }
        if let task = task as? DBXFilesTagsGetRpcRequest {
            task.response(analyticsBlock: analyticsBlock) { result, routeError, networkError in
                let mappedResult = mapDBXFilesGetTagsResultToDBOptional(object: result)
                let mappedError = mapDBXFilesBaseTagErrorToDBOptional(object: routeError)
                let mappedCallError = callErrorToDB(error: networkError)
                let wrappedBlock = { block(mappedResult, mappedError, mappedCallError) }
                Self.processCompletion(wrappedBlock, queue: queue)
            }
            return true
        }
        if let task = task as? DBXFilesTagsRemoveRpcRequest {
            task.response(analyticsBlock: analyticsBlock) { routeError, networkError in
                let mappedError = mapDBXFilesRemoveTagErrorToDBOptional(object: routeError)
                let mappedCallError = callErrorToDB(error: networkError)
                let wrappedBlock = { block((networkError == nil && routeError == nil) ? DBNilObject() : nil, mappedError, mappedCallError) }
                Self.processCompletion(wrappedBlock, queue: queue)
            }
            return true
        }
        if let task = task as? DBXFilesUnlockFileBatchRpcRequest {
            task.response(analyticsBlock: analyticsBlock) { result, routeError, networkError in
                let mappedResult = mapDBXFilesLockFileBatchResultToDBOptional(object: result)
                let mappedError = mapDBXFilesLockFileErrorToDBOptional(object: routeError)
                let mappedCallError = callErrorToDB(error: networkError)
                let wrappedBlock = { block(mappedResult, mappedError, mappedCallError) }
                Self.processCompletion(wrappedBlock, queue: queue)
            }
            return true
        }
        if let task = task as? DBXFilesUploadSessionFinishBatchRpcRequestV2 {
            task.response(analyticsBlock: analyticsBlock) { result, networkError in
                let mappedResult = mapDBXFilesUploadSessionFinishBatchResultToDBOptional(object: result)
                let mappedCallError = callErrorToDB(error: networkError)
                let wrappedBlock = { block(mappedResult, nil, mappedCallError) }
                Self.processCompletion(wrappedBlock, queue: queue)
            }
            return true
        }
        if let task = task as? DBXFilesUploadSessionFinishBatchCheckRpcRequest {
            task.response(analyticsBlock: analyticsBlock) { result, routeError, networkError in
                let mappedResult = mapDBXFilesUploadSessionFinishBatchJobStatusToDBOptional(object: result)
                let mappedError = mapDBXAsyncPollErrorToDBOptional(object: routeError)
                let mappedCallError = callErrorToDB(error: networkError)
                let wrappedBlock = { block(mappedResult, mappedError, mappedCallError) }
                Self.processCompletion(wrappedBlock, queue: queue)
            }
            return true
        }
        if let task = task as? DBXFilesUploadSessionStartBatchRpcRequest {
            task.response(analyticsBlock: analyticsBlock) { result, networkError in
                let mappedResult = mapDBXFilesUploadSessionStartBatchResultToDBOptional(object: result)
                let mappedCallError = callErrorToDB(error: networkError)
                let wrappedBlock = { block(mappedResult, nil, mappedCallError) }
                Self.processCompletion(wrappedBlock, queue: queue)
            }
            return true
        }
        if let task = task as? DBXOpenidUserinfoRpcRequest {
            task.response(analyticsBlock: analyticsBlock) { result, routeError, networkError in
                let mappedResult = mapDBXOpenidUserInfoResultToDBOptional(object: result)
                let mappedError = mapDBXOpenidUserInfoErrorToDBOptional(object: routeError)
                let mappedCallError = callErrorToDB(error: networkError)
                let wrappedBlock = { block(mappedResult, mappedError, mappedCallError) }
                Self.processCompletion(wrappedBlock, queue: queue)
            }
            return true
        }
        if let task = task as? DBXSharingAddFileMemberRpcRequest {
            task.response(analyticsBlock: analyticsBlock) { result, routeError, networkError in
                let mappedResult = result?.map { mapDBXSharingFileMemberActionResultToDBOptional(object: $0) }
                let mappedError = mapDBXSharingAddFileMemberErrorToDBOptional(object: routeError)
                let mappedCallError = callErrorToDB(error: networkError)
                let wrappedBlock = { block(mappedResult, mappedError, mappedCallError) }
                Self.processCompletion(wrappedBlock, queue: queue)
            }
            return true
        }
        if let task = task as? DBXSharingAddFolderMemberRpcRequest {
            task.response(analyticsBlock: analyticsBlock) { routeError, networkError in
                let mappedError = mapDBXSharingAddFolderMemberErrorToDBOptional(object: routeError)
                let mappedCallError = callErrorToDB(error: networkError)
                let wrappedBlock = { block((networkError == nil && routeError == nil) ? DBNilObject() : nil, mappedError, mappedCallError) }
                Self.processCompletion(wrappedBlock, queue: queue)
            }
            return true
        }
        if let task = task as? DBXSharingCheckJobStatusRpcRequest {
            task.response(analyticsBlock: analyticsBlock) { result, routeError, networkError in
                let mappedResult = mapDBXSharingJobStatusToDBOptional(object: result)
                let mappedError = mapDBXAsyncPollErrorToDBOptional(object: routeError)
                let mappedCallError = callErrorToDB(error: networkError)
                let wrappedBlock = { block(mappedResult, mappedError, mappedCallError) }
                Self.processCompletion(wrappedBlock, queue: queue)
            }
            return true
        }
        if let task = task as? DBXSharingCheckRemoveMemberJobStatusRpcRequest {
            task.response(analyticsBlock: analyticsBlock) { result, routeError, networkError in
                let mappedResult = mapDBXSharingRemoveMemberJobStatusToDBOptional(object: result)
                let mappedError = mapDBXAsyncPollErrorToDBOptional(object: routeError)
                let mappedCallError = callErrorToDB(error: networkError)
                let wrappedBlock = { block(mappedResult, mappedError, mappedCallError) }
                Self.processCompletion(wrappedBlock, queue: queue)
            }
            return true
        }
        if let task = task as? DBXSharingCheckShareJobStatusRpcRequest {
            task.response(analyticsBlock: analyticsBlock) { result, routeError, networkError in
                let mappedResult = mapDBXSharingShareFolderJobStatusToDBOptional(object: result)
                let mappedError = mapDBXAsyncPollErrorToDBOptional(object: routeError)
                let mappedCallError = callErrorToDB(error: networkError)
                let wrappedBlock = { block(mappedResult, mappedError, mappedCallError) }
                Self.processCompletion(wrappedBlock, queue: queue)
            }
            return true
        }
        if let task = task as? DBXSharingCreateSharedLinkWithSettingsRpcRequest {
            task.response(analyticsBlock: analyticsBlock) { result, routeError, networkError in
                let mappedResult = mapDBXSharingSharedLinkMetadataToDBOptional(object: result)
                let mappedError = mapDBXSharingCreateSharedLinkWithSettingsErrorToDBOptional(object: routeError)
                let mappedCallError = callErrorToDB(error: networkError)
                let wrappedBlock = { block(mappedResult, mappedError, mappedCallError) }
                Self.processCompletion(wrappedBlock, queue: queue)
            }
            return true
        }
        if let task = task as? DBXSharingGetFileMetadataRpcRequest {
            task.response(analyticsBlock: analyticsBlock) { result, routeError, networkError in
                let mappedResult = mapDBXSharingSharedFileMetadataToDBOptional(object: result)
                let mappedError = mapDBXSharingGetFileMetadataErrorToDBOptional(object: routeError)
                let mappedCallError = callErrorToDB(error: networkError)
                let wrappedBlock = { block(mappedResult, mappedError, mappedCallError) }
                Self.processCompletion(wrappedBlock, queue: queue)
            }
            return true
        }
        if let task = task as? DBXSharingGetFileMetadataBatchRpcRequest {
            task.response(analyticsBlock: analyticsBlock) { result, routeError, networkError in
                let mappedResult = result?.map { mapDBXSharingGetFileMetadataBatchResultToDBOptional(object: $0) }
                let mappedError = mapDBXSharingSharingUserErrorToDBOptional(object: routeError)
                let mappedCallError = callErrorToDB(error: networkError)
                let wrappedBlock = { block(mappedResult, mappedError, mappedCallError) }
                Self.processCompletion(wrappedBlock, queue: queue)
            }
            return true
        }
        if let task = task as? DBXSharingGetFolderMetadataRpcRequest {
            task.response(analyticsBlock: analyticsBlock) { result, routeError, networkError in
                let mappedResult = mapDBXSharingSharedFolderMetadataToDBOptional(object: result)
                let mappedError = mapDBXSharingSharedFolderAccessErrorToDBOptional(object: routeError)
                let mappedCallError = callErrorToDB(error: networkError)
                let wrappedBlock = { block(mappedResult, mappedError, mappedCallError) }
                Self.processCompletion(wrappedBlock, queue: queue)
            }
            return true
        }
        if let task = task as? DBXSharingGetSharedLinkMetadataRpcRequest {
            task.response(analyticsBlock: analyticsBlock) { result, routeError, networkError in
                let mappedResult = mapDBXSharingSharedLinkMetadataToDBOptional(object: result)
                let mappedError = mapDBXSharingSharedLinkErrorToDBOptional(object: routeError)
                let mappedCallError = callErrorToDB(error: networkError)
                let wrappedBlock = { block(mappedResult, mappedError, mappedCallError) }
                Self.processCompletion(wrappedBlock, queue: queue)
            }
            return true
        }
        if let task = task as? DBXSharingListFileMembersRpcRequest {
            task.response(analyticsBlock: analyticsBlock) { result, routeError, networkError in
                let mappedResult = mapDBXSharingSharedFileMembersToDBOptional(object: result)
                let mappedError = mapDBXSharingListFileMembersErrorToDBOptional(object: routeError)
                let mappedCallError = callErrorToDB(error: networkError)
                let wrappedBlock = { block(mappedResult, mappedError, mappedCallError) }
                Self.processCompletion(wrappedBlock, queue: queue)
            }
            return true
        }
        if let task = task as? DBXSharingListFileMembersBatchRpcRequest {
            task.response(analyticsBlock: analyticsBlock) { result, routeError, networkError in
                let mappedResult = result?.map { mapDBXSharingListFileMembersBatchResultToDBOptional(object: $0) }
                let mappedError = mapDBXSharingSharingUserErrorToDBOptional(object: routeError)
                let mappedCallError = callErrorToDB(error: networkError)
                let wrappedBlock = { block(mappedResult, mappedError, mappedCallError) }
                Self.processCompletion(wrappedBlock, queue: queue)
            }
            return true
        }
        if let task = task as? DBXSharingListFileMembersContinueRpcRequest {
            task.response(analyticsBlock: analyticsBlock) { result, routeError, networkError in
                let mappedResult = mapDBXSharingSharedFileMembersToDBOptional(object: result)
                let mappedError = mapDBXSharingListFileMembersContinueErrorToDBOptional(object: routeError)
                let mappedCallError = callErrorToDB(error: networkError)
                let wrappedBlock = { block(mappedResult, mappedError, mappedCallError) }
                Self.processCompletion(wrappedBlock, queue: queue)
            }
            return true
        }
        if let task = task as? DBXSharingListFolderMembersRpcRequest {
            task.response(analyticsBlock: analyticsBlock) { result, routeError, networkError in
                let mappedResult = mapDBXSharingSharedFolderMembersToDBOptional(object: result)
                let mappedError = mapDBXSharingSharedFolderAccessErrorToDBOptional(object: routeError)
                let mappedCallError = callErrorToDB(error: networkError)
                let wrappedBlock = { block(mappedResult, mappedError, mappedCallError) }
                Self.processCompletion(wrappedBlock, queue: queue)
            }
            return true
        }
        if let task = task as? DBXSharingListFolderMembersContinueRpcRequest {
            task.response(analyticsBlock: analyticsBlock) { result, routeError, networkError in
                let mappedResult = mapDBXSharingSharedFolderMembersToDBOptional(object: result)
                let mappedError = mapDBXSharingListFolderMembersContinueErrorToDBOptional(object: routeError)
                let mappedCallError = callErrorToDB(error: networkError)
                let wrappedBlock = { block(mappedResult, mappedError, mappedCallError) }
                Self.processCompletion(wrappedBlock, queue: queue)
            }
            return true
        }
        if let task = task as? DBXSharingListFoldersRpcRequest {
            task.response(analyticsBlock: analyticsBlock) { result, networkError in
                let mappedResult = mapDBXSharingListFoldersResultToDBOptional(object: result)
                let mappedCallError = callErrorToDB(error: networkError)
                let wrappedBlock = { block(mappedResult, nil, mappedCallError) }
                Self.processCompletion(wrappedBlock, queue: queue)
            }
            return true
        }
        if let task = task as? DBXSharingListFoldersContinueRpcRequest {
            task.response(analyticsBlock: analyticsBlock) { result, routeError, networkError in
                let mappedResult = mapDBXSharingListFoldersResultToDBOptional(object: result)
                let mappedError = mapDBXSharingListFoldersContinueErrorToDBOptional(object: routeError)
                let mappedCallError = callErrorToDB(error: networkError)
                let wrappedBlock = { block(mappedResult, mappedError, mappedCallError) }
                Self.processCompletion(wrappedBlock, queue: queue)
            }
            return true
        }
        if let task = task as? DBXSharingListMountableFoldersRpcRequest {
            task.response(analyticsBlock: analyticsBlock) { result, networkError in
                let mappedResult = mapDBXSharingListFoldersResultToDBOptional(object: result)
                let mappedCallError = callErrorToDB(error: networkError)
                let wrappedBlock = { block(mappedResult, nil, mappedCallError) }
                Self.processCompletion(wrappedBlock, queue: queue)
            }
            return true
        }
        if let task = task as? DBXSharingListMountableFoldersContinueRpcRequest {
            task.response(analyticsBlock: analyticsBlock) { result, routeError, networkError in
                let mappedResult = mapDBXSharingListFoldersResultToDBOptional(object: result)
                let mappedError = mapDBXSharingListFoldersContinueErrorToDBOptional(object: routeError)
                let mappedCallError = callErrorToDB(error: networkError)
                let wrappedBlock = { block(mappedResult, mappedError, mappedCallError) }
                Self.processCompletion(wrappedBlock, queue: queue)
            }
            return true
        }
        if let task = task as? DBXSharingListReceivedFilesRpcRequest {
            task.response(analyticsBlock: analyticsBlock) { result, routeError, networkError in
                let mappedResult = mapDBXSharingListFilesResultToDBOptional(object: result)
                let mappedError = mapDBXSharingSharingUserErrorToDBOptional(object: routeError)
                let mappedCallError = callErrorToDB(error: networkError)
                let wrappedBlock = { block(mappedResult, mappedError, mappedCallError) }
                Self.processCompletion(wrappedBlock, queue: queue)
            }
            return true
        }
        if let task = task as? DBXSharingListReceivedFilesContinueRpcRequest {
            task.response(analyticsBlock: analyticsBlock) { result, routeError, networkError in
                let mappedResult = mapDBXSharingListFilesResultToDBOptional(object: result)
                let mappedError = mapDBXSharingListFilesContinueErrorToDBOptional(object: routeError)
                let mappedCallError = callErrorToDB(error: networkError)
                let wrappedBlock = { block(mappedResult, mappedError, mappedCallError) }
                Self.processCompletion(wrappedBlock, queue: queue)
            }
            return true
        }
        if let task = task as? DBXSharingListSharedLinksRpcRequest {
            task.response(analyticsBlock: analyticsBlock) { result, routeError, networkError in
                let mappedResult = mapDBXSharingListSharedLinksResultToDBOptional(object: result)
                let mappedError = mapDBXSharingListSharedLinksErrorToDBOptional(object: routeError)
                let mappedCallError = callErrorToDB(error: networkError)
                let wrappedBlock = { block(mappedResult, mappedError, mappedCallError) }
                Self.processCompletion(wrappedBlock, queue: queue)
            }
            return true
        }
        if let task = task as? DBXSharingModifySharedLinkSettingsRpcRequest {
            task.response(analyticsBlock: analyticsBlock) { result, routeError, networkError in
                let mappedResult = mapDBXSharingSharedLinkMetadataToDBOptional(object: result)
                let mappedError = mapDBXSharingModifySharedLinkSettingsErrorToDBOptional(object: routeError)
                let mappedCallError = callErrorToDB(error: networkError)
                let wrappedBlock = { block(mappedResult, mappedError, mappedCallError) }
                Self.processCompletion(wrappedBlock, queue: queue)
            }
            return true
        }
        if let task = task as? DBXSharingMountFolderRpcRequest {
            task.response(analyticsBlock: analyticsBlock) { result, routeError, networkError in
                let mappedResult = mapDBXSharingSharedFolderMetadataToDBOptional(object: result)
                let mappedError = mapDBXSharingMountFolderErrorToDBOptional(object: routeError)
                let mappedCallError = callErrorToDB(error: networkError)
                let wrappedBlock = { block(mappedResult, mappedError, mappedCallError) }
                Self.processCompletion(wrappedBlock, queue: queue)
            }
            return true
        }
        if let task = task as? DBXSharingRelinquishFileMembershipRpcRequest {
            task.response(analyticsBlock: analyticsBlock) { routeError, networkError in
                let mappedError = mapDBXSharingRelinquishFileMembershipErrorToDBOptional(object: routeError)
                let mappedCallError = callErrorToDB(error: networkError)
                let wrappedBlock = { block((networkError == nil && routeError == nil) ? DBNilObject() : nil, mappedError, mappedCallError) }
                Self.processCompletion(wrappedBlock, queue: queue)
            }
            return true
        }
        if let task = task as? DBXSharingRelinquishFolderMembershipRpcRequest {
            task.response(analyticsBlock: analyticsBlock) { result, routeError, networkError in
                let mappedResult = mapDBXAsyncLaunchEmptyResultToDBOptional(object: result)
                let mappedError = mapDBXSharingRelinquishFolderMembershipErrorToDBOptional(object: routeError)
                let mappedCallError = callErrorToDB(error: networkError)
                let wrappedBlock = { block(mappedResult, mappedError, mappedCallError) }
                Self.processCompletion(wrappedBlock, queue: queue)
            }
            return true
        }
        if let task = task as? DBXSharingRemoveFileMember2RpcRequest {
            task.response(analyticsBlock: analyticsBlock) { result, routeError, networkError in
                let mappedResult = mapDBXSharingFileMemberRemoveActionResultToDBOptional(object: result)
                let mappedError = mapDBXSharingRemoveFileMemberErrorToDBOptional(object: routeError)
                let mappedCallError = callErrorToDB(error: networkError)
                let wrappedBlock = { block(mappedResult, mappedError, mappedCallError) }
                Self.processCompletion(wrappedBlock, queue: queue)
            }
            return true
        }
        if let task = task as? DBXSharingRemoveFolderMemberRpcRequest {
            task.response(analyticsBlock: analyticsBlock) { result, routeError, networkError in
                let mappedResult = mapDBXAsyncLaunchResultBaseToDBOptional(object: result)
                let mappedError = mapDBXSharingRemoveFolderMemberErrorToDBOptional(object: routeError)
                let mappedCallError = callErrorToDB(error: networkError)
                let wrappedBlock = { block(mappedResult, mappedError, mappedCallError) }
                Self.processCompletion(wrappedBlock, queue: queue)
            }
            return true
        }
        if let task = task as? DBXSharingRevokeSharedLinkRpcRequest {
            task.response(analyticsBlock: analyticsBlock) { routeError, networkError in
                let mappedError = mapDBXSharingRevokeSharedLinkErrorToDBOptional(object: routeError)
                let mappedCallError = callErrorToDB(error: networkError)
                let wrappedBlock = { block((networkError == nil && routeError == nil) ? DBNilObject() : nil, mappedError, mappedCallError) }
                Self.processCompletion(wrappedBlock, queue: queue)
            }
            return true
        }
        if let task = task as? DBXSharingSetAccessInheritanceRpcRequest {
            task.response(analyticsBlock: analyticsBlock) { result, routeError, networkError in
                let mappedResult = mapDBXSharingShareFolderLaunchToDBOptional(object: result)
                let mappedError = mapDBXSharingSetAccessInheritanceErrorToDBOptional(object: routeError)
                let mappedCallError = callErrorToDB(error: networkError)
                let wrappedBlock = { block(mappedResult, mappedError, mappedCallError) }
                Self.processCompletion(wrappedBlock, queue: queue)
            }
            return true
        }
        if let task = task as? DBXSharingShareFolderRpcRequest {
            task.response(analyticsBlock: analyticsBlock) { result, routeError, networkError in
                let mappedResult = mapDBXSharingShareFolderLaunchToDBOptional(object: result)
                let mappedError = mapDBXSharingShareFolderErrorToDBOptional(object: routeError)
                let mappedCallError = callErrorToDB(error: networkError)
                let wrappedBlock = { block(mappedResult, mappedError, mappedCallError) }
                Self.processCompletion(wrappedBlock, queue: queue)
            }
            return true
        }
        if let task = task as? DBXSharingTransferFolderRpcRequest {
            task.response(analyticsBlock: analyticsBlock) { routeError, networkError in
                let mappedError = mapDBXSharingTransferFolderErrorToDBOptional(object: routeError)
                let mappedCallError = callErrorToDB(error: networkError)
                let wrappedBlock = { block((networkError == nil && routeError == nil) ? DBNilObject() : nil, mappedError, mappedCallError) }
                Self.processCompletion(wrappedBlock, queue: queue)
            }
            return true
        }
        if let task = task as? DBXSharingUnmountFolderRpcRequest {
            task.response(analyticsBlock: analyticsBlock) { routeError, networkError in
                let mappedError = mapDBXSharingUnmountFolderErrorToDBOptional(object: routeError)
                let mappedCallError = callErrorToDB(error: networkError)
                let wrappedBlock = { block((networkError == nil && routeError == nil) ? DBNilObject() : nil, mappedError, mappedCallError) }
                Self.processCompletion(wrappedBlock, queue: queue)
            }
            return true
        }
        if let task = task as? DBXSharingUnshareFileRpcRequest {
            task.response(analyticsBlock: analyticsBlock) { routeError, networkError in
                let mappedError = mapDBXSharingUnshareFileErrorToDBOptional(object: routeError)
                let mappedCallError = callErrorToDB(error: networkError)
                let wrappedBlock = { block((networkError == nil && routeError == nil) ? DBNilObject() : nil, mappedError, mappedCallError) }
                Self.processCompletion(wrappedBlock, queue: queue)
            }
            return true
        }
        if let task = task as? DBXSharingUnshareFolderRpcRequest {
            task.response(analyticsBlock: analyticsBlock) { result, routeError, networkError in
                let mappedResult = mapDBXAsyncLaunchEmptyResultToDBOptional(object: result)
                let mappedError = mapDBXSharingUnshareFolderErrorToDBOptional(object: routeError)
                let mappedCallError = callErrorToDB(error: networkError)
                let wrappedBlock = { block(mappedResult, mappedError, mappedCallError) }
                Self.processCompletion(wrappedBlock, queue: queue)
            }
            return true
        }
        if let task = task as? DBXSharingUpdateFileMemberRpcRequest {
            task.response(analyticsBlock: analyticsBlock) { result, routeError, networkError in
                let mappedResult = mapDBXSharingMemberAccessLevelResultToDBOptional(object: result)
                let mappedError = mapDBXSharingFileMemberActionErrorToDBOptional(object: routeError)
                let mappedCallError = callErrorToDB(error: networkError)
                let wrappedBlock = { block(mappedResult, mappedError, mappedCallError) }
                Self.processCompletion(wrappedBlock, queue: queue)
            }
            return true
        }
        if let task = task as? DBXSharingUpdateFolderMemberRpcRequest {
            task.response(analyticsBlock: analyticsBlock) { result, routeError, networkError in
                let mappedResult = mapDBXSharingMemberAccessLevelResultToDBOptional(object: result)
                let mappedError = mapDBXSharingUpdateFolderMemberErrorToDBOptional(object: routeError)
                let mappedCallError = callErrorToDB(error: networkError)
                let wrappedBlock = { block(mappedResult, mappedError, mappedCallError) }
                Self.processCompletion(wrappedBlock, queue: queue)
            }
            return true
        }
        if let task = task as? DBXSharingUpdateFolderPolicyRpcRequest {
            task.response(analyticsBlock: analyticsBlock) { result, routeError, networkError in
                let mappedResult = mapDBXSharingSharedFolderMetadataToDBOptional(object: result)
                let mappedError = mapDBXSharingUpdateFolderPolicyErrorToDBOptional(object: routeError)
                let mappedCallError = callErrorToDB(error: networkError)
                let wrappedBlock = { block(mappedResult, mappedError, mappedCallError) }
                Self.processCompletion(wrappedBlock, queue: queue)
            }
            return true
        }
        if let task = task as? DBXUsersFeaturesGetValuesRpcRequest {
            task.response(analyticsBlock: analyticsBlock) { result, routeError, networkError in
                let mappedResult = mapDBXUsersUserFeaturesGetValuesBatchResultToDBOptional(object: result)
                let mappedError = mapDBXUsersUserFeaturesGetValuesBatchErrorToDBOptional(object: routeError)
                let mappedCallError = callErrorToDB(error: networkError)
                let wrappedBlock = { block(mappedResult, mappedError, mappedCallError) }
                Self.processCompletion(wrappedBlock, queue: queue)
            }
            return true
        }
        if let task = task as? DBXUsersGetAccountRpcRequest {
            task.response(analyticsBlock: analyticsBlock) { result, routeError, networkError in
                let mappedResult = mapDBXUsersBasicAccountToDBOptional(object: result)
                let mappedError = mapDBXUsersGetAccountErrorToDBOptional(object: routeError)
                let mappedCallError = callErrorToDB(error: networkError)
                let wrappedBlock = { block(mappedResult, mappedError, mappedCallError) }
                Self.processCompletion(wrappedBlock, queue: queue)
            }
            return true
        }
        if let task = task as? DBXUsersGetAccountBatchRpcRequest {
            task.response(analyticsBlock: analyticsBlock) { result, routeError, networkError in
                let mappedResult = result?.map { mapDBXUsersBasicAccountToDBOptional(object: $0) }
                let mappedError = mapDBXUsersGetAccountBatchErrorToDBOptional(object: routeError)
                let mappedCallError = callErrorToDB(error: networkError)
                let wrappedBlock = { block(mappedResult, mappedError, mappedCallError) }
                Self.processCompletion(wrappedBlock, queue: queue)
            }
            return true
        }
        if let task = task as? DBXUsersGetCurrentAccountRpcRequest {
            task.response(analyticsBlock: analyticsBlock) { result, networkError in
                let mappedResult = mapDBXUsersFullAccountToDBOptional(object: result)
                let mappedCallError = callErrorToDB(error: networkError)
                let wrappedBlock = { block(mappedResult, nil, mappedCallError) }
                Self.processCompletion(wrappedBlock, queue: queue)
            }
            return true
        }
        if let task = task as? DBXUsersGetSpaceUsageRpcRequest {
            task.response(analyticsBlock: analyticsBlock) { result, networkError in
                let mappedResult = mapDBXUsersSpaceUsageToDBOptional(object: result)
                let mappedCallError = callErrorToDB(error: networkError)
                let wrappedBlock = { block(mappedResult, nil, mappedCallError) }
                Self.processCompletion(wrappedBlock, queue: queue)
            }
            return true
        }
        return false
    }

    private static func processCompletion(_ wrappedBlock: @escaping () -> Void, queue: OperationQueue?) {
        if let queue = queue {
            queue.addOperation(wrappedBlock)
        } else {
            wrappedBlock()
        }
    }

    // MARK: DBAPITransportClient

    @objc public static func rpcRequest(for route: DBRoute, args: DBSerializable, userId: String, client: DBXDropboxClient) -> DBXRequest? {
        // Make sure this handles versioned routes properly
        let qualifiedRouteName = route.namespace_ + "/" + route.name
        if qualifiedRouteName == "account/set_profile_photo", let args = args as? DBACCOUNTSetProfilePhotoArg {
            return client.account.setProfilePhoto(photo: mapDBACCOUNTPhotoSourceArgToDBX(object: args.photo))
        }
        if qualifiedRouteName == "auth/token/revoke" {
            return client.auth.tokenRevoke()
        }
        if qualifiedRouteName == "check/user", let args = args as? DBCHECKEchoArg {
            return client.check.user(query: args.query)
        }
        if qualifiedRouteName == "contacts/delete_manual_contacts" {
            return client.contacts.deleteManualContacts()
        }
        if qualifiedRouteName == "contacts/delete_manual_contacts_batch", let args = args as? DBCONTACTSDeleteManualContactsArg {
            return client.contacts.deleteManualContactsBatch(emailAddresses: args.emailAddresses)
        }
        if qualifiedRouteName == "file_properties/properties/add", let args = args as? DBFILEPROPERTIESAddPropertiesArg {
            return client.fileProperties.propertiesAdd(
                path: args.path,
                propertyGroups: args.propertyGroups.compactMap { mapDBFILEPROPERTIESPropertyGroupToDBX(object: $0) }
            )
        }
        if qualifiedRouteName == "file_properties/properties/overwrite", let args = args as? DBFILEPROPERTIESOverwritePropertyGroupArg {
            return client.fileProperties.propertiesOverwrite(
                path: args.path,
                propertyGroups: args.propertyGroups.compactMap { mapDBFILEPROPERTIESPropertyGroupToDBX(object: $0) }
            )
        }
        if qualifiedRouteName == "file_properties/properties/remove", let args = args as? DBFILEPROPERTIESRemovePropertiesArg {
            return client.fileProperties.propertiesRemove(path: args.path, propertyTemplateIds: args.propertyTemplateIds)
        }
        if qualifiedRouteName == "file_properties/properties/search", let args = args as? DBFILEPROPERTIESPropertiesSearchArg {
            return client.fileProperties.propertiesSearch(
                queries: args.queries.compactMap { mapDBFILEPROPERTIESPropertiesSearchQueryToDBX(object: $0) },
                templateFilter: mapDBFILEPROPERTIESTemplateFilterToDBX(object: args.templateFilter)
            )
        }
        if qualifiedRouteName == "file_properties/properties/search/continue", let args = args as? DBFILEPROPERTIESPropertiesSearchContinueArg {
            return client.fileProperties.propertiesSearchContinue(cursor: args.cursor)
        }
        if qualifiedRouteName == "file_properties/properties/update", let args = args as? DBFILEPROPERTIESUpdatePropertiesArg {
            return client.fileProperties.propertiesUpdate(
                path: args.path,
                updatePropertyGroups: args.updatePropertyGroups.compactMap { mapDBFILEPROPERTIESPropertyGroupUpdateToDBX(object: $0) }
            )
        }
        if qualifiedRouteName == "file_properties/templates/add_for_user" {
            return client.fileProperties.templatesAddForUser(
                name: args.name,
                description_: args.description_,
                fields: args.fields.compactMap { mapDBFILEPROPERTIESPropertyFieldTemplateToDBX(object: $0) }
            )
        }
        if qualifiedRouteName == "file_properties/templates/get_for_user", let args = args as? DBFILEPROPERTIESGetTemplateArg {
            return client.fileProperties.templatesGetForUser(templateId: args.templateId)
        }
        if qualifiedRouteName == "file_properties/templates/list_for_user" {
            return client.fileProperties.templatesListForUser()
        }
        if qualifiedRouteName == "file_properties/templates/remove_for_user", let args = args as? DBFILEPROPERTIESRemoveTemplateArg {
            return client.fileProperties.templatesRemoveForUser(templateId: args.templateId)
        }
        if qualifiedRouteName == "file_properties/templates/update_for_user", let args = args as? DBFILEPROPERTIESUpdateTemplateArg {
            return client.fileProperties.templatesUpdateForUser(
                templateId: args.templateId,
                name: args.name,
                description_: args.description_,
                addFields: args.addFields?.compactMap { mapDBFILEPROPERTIESPropertyFieldTemplateToDBX(object: $0) }
            )
        }
        if qualifiedRouteName == "file_requests/count" {
            return client.fileRequests.count()
        }
        if qualifiedRouteName == "file_requests/create", let args = args as? DBFILEREQUESTSCreateFileRequestArgs {
            return client.fileRequests.create(
                title: args.title,
                destination: args.destination,
                deadline: mapDBFILEREQUESTSFileRequestDeadlineToDBXOptional(object: args.deadline),
                open: args.open,
                description_: args.description_
            )
        }
        if qualifiedRouteName == "file_requests/delete", let args = args as? DBFILEREQUESTSDeleteFileRequestArgs {
            return client.fileRequests.delete(ids: args.ids)
        }
        if qualifiedRouteName == "file_requests/delete_all_closed" {
            return client.fileRequests.deleteAllClosed()
        }
        if qualifiedRouteName == "file_requests/get", let args = args as? DBFILEREQUESTSGetFileRequestArgs {
            return client.fileRequests.get(id: args.id_)
        }
        if qualifiedRouteName == "file_requests/list" {
            return client.fileRequests.list_()
        }
        if qualifiedRouteName == "file_requests/list_v2", let args = args as? DBFILEREQUESTSListFileRequestsArg {
            return client.fileRequests.listV2(limit: args.limit)
        }
        if qualifiedRouteName == "file_requests/list/continue", let args = args as? DBFILEREQUESTSListFileRequestsContinueArg {
            return client.fileRequests.listContinue(cursor: args.cursor)
        }
        if qualifiedRouteName == "file_requests/update", let args = args as? DBFILEREQUESTSUpdateFileRequestArgs {
            return client.fileRequests.update(
                id: args.id_,
                title: args.title,
                destination: args.destination,
                deadline: mapDBFILEREQUESTSUpdateFileRequestDeadlineToDBX(object: args.deadline),
                open: args.open,
                description_: args.description_
            )
        }
        if qualifiedRouteName == "files/copy_v2", let args = args as? DBFILESRelocationArg {
            return client.files.copyV2(
                fromPath: args.fromPath,
                toPath: args.toPath,
                allowSharedFolder: args.allowSharedFolder,
                autorename: args.autorename,
                allowOwnershipTransfer: args.allowOwnershipTransfer
            )
        }
        if qualifiedRouteName == "files/copy_batch_v2", let args = args as? DBFILESRelocationBatchArgBase {
            return client.files.copyBatchV2(entries: args.entries.compactMap { mapDBFILESRelocationPathToDBX(object: $0) }, autorename: args.autorename)
        }
        if qualifiedRouteName == "files/copy_batch/check_v2", let args = args as? DBASYNCPollArg {
            return client.files.copyBatchCheckV2(asyncJobId: args.asyncJobId)
        }
        if qualifiedRouteName == "files/copy_reference/get", let args = args as? DBFILESGetCopyReferenceArg {
            return client.files.copyReferenceGet(path: args.path)
        }
        if qualifiedRouteName == "files/copy_reference/save", let args = args as? DBFILESSaveCopyReferenceArg {
            return client.files.copyReferenceSave(copyReference: args.dCopyReference, path: args.path)
        }
        if qualifiedRouteName == "files/create_folder_v2", let args = args as? DBFILESCreateFolderArg {
            return client.files.createFolderV2(path: args.path, autorename: args.autorename)
        }
        if qualifiedRouteName == "files/create_folder_batch", let args = args as? DBFILESCreateFolderBatchArg {
            return client.files.createFolderBatch(paths: args.paths, autorename: args.autorename, forceAsync: args.forceAsync)
        }
        if qualifiedRouteName == "files/create_folder_batch/check", let args = args as? DBASYNCPollArg {
            return client.files.createFolderBatchCheck(asyncJobId: args.asyncJobId)
        }
        if qualifiedRouteName == "files/delete_v2", let args = args as? DBFILESDeleteArg {
            return client.files.deleteV2(path: args.path, parentRev: args.parentRev)
        }
        if qualifiedRouteName == "files/delete_batch", let args = args as? DBFILESDeleteBatchArg {
            return client.files.deleteBatch(entries: args.entries.compactMap { mapDBFILESDeleteArgToDBX(object: $0) })
        }
        if qualifiedRouteName == "files/delete_batch/check", let args = args as? DBASYNCPollArg {
            return client.files.deleteBatchCheck(asyncJobId: args.asyncJobId)
        }
        if qualifiedRouteName == "files/get_file_lock_batch", let args = args as? DBFILESLockFileBatchArg {
            return client.files.getFileLockBatch(entries: args.entries.compactMap { mapDBFILESLockFileArgToDBX(object: $0) })
        }
        if qualifiedRouteName == "files/get_metadata", let args = args as? DBFILESGetMetadataArg {
            return client.files.getMetadata(
                path: args.path,
                includeMediaInfo: args.includeMediaInfo,
                includeDeleted: args.includeDeleted,
                includeHasExplicitSharedMembers: args.includeHasExplicitSharedMembers,
                includePropertyGroups: mapDBFILEPROPERTIESTemplateFilterBaseToDBXOptional(object: args.includePropertyGroups)
            )
        }
        if qualifiedRouteName == "files/get_temporary_link", let args = args as? DBFILESGetTemporaryLinkArg {
            return client.files.getTemporaryLink(path: args.path)
        }
        if qualifiedRouteName == "files/get_temporary_upload_link", let args = args as? DBFILESGetTemporaryUploadLinkArg {
            return client.files.getTemporaryUploadLink(commitInfo: mapDBFILESCommitInfoToDBX(object: args.commitInfo), duration: args.duration)
        }
        if qualifiedRouteName == "files/get_thumbnail_batch", let args = args as? DBFILESGetThumbnailBatchArg {
            return client.files.getThumbnailBatch(entries: args.entries.compactMap { mapDBFILESThumbnailArgToDBX(object: $0) })
        }
        if qualifiedRouteName == "files/list_folder", let args = args as? DBFILESListFolderArg {
            return client.files.listFolder(
                path: args.path,
                recursive: args.recursive,
                includeMediaInfo: args.includeMediaInfo,
                includeDeleted: args.includeDeleted,
                includeHasExplicitSharedMembers: args.includeHasExplicitSharedMembers,
                includeMountedFolders: args.includeMountedFolders,
                limit: args.limit,
                sharedLink: mapDBFILESSharedLinkToDBXOptional(object: args.sharedLink),
                includePropertyGroups: mapDBFILEPROPERTIESTemplateFilterBaseToDBXOptional(object: args.includePropertyGroups),
                includeNonDownloadableFiles: args.includeNonDownloadableFiles
            )
        }
        if qualifiedRouteName == "files/list_folder/continue", let args = args as? DBFILESListFolderContinueArg {
            return client.files.listFolderContinue(cursor: args.cursor)
        }
        if qualifiedRouteName == "files/list_folder/get_latest_cursor", let args = args as? DBFILESListFolderArg {
            return client.files.listFolderGetLatestCursor(
                path: args.path,
                recursive: args.recursive,
                includeMediaInfo: args.includeMediaInfo,
                includeDeleted: args.includeDeleted,
                includeHasExplicitSharedMembers: args.includeHasExplicitSharedMembers,
                includeMountedFolders: args.includeMountedFolders,
                limit: args.limit,
                sharedLink: mapDBFILESSharedLinkToDBXOptional(object: args.sharedLink),
                includePropertyGroups: mapDBFILEPROPERTIESTemplateFilterBaseToDBXOptional(object: args.includePropertyGroups),
                includeNonDownloadableFiles: args.includeNonDownloadableFiles
            )
        }
        if qualifiedRouteName == "files/list_folder/longpoll", let args = args as? DBFILESListFolderLongpollArg {
            return client.files.listFolderLongpoll(cursor: args.cursor, timeout: args.timeout)
        }
        if qualifiedRouteName == "files/list_revisions", let args = args as? DBFILESListRevisionsArg {
            return client.files.listRevisions(path: args.path, mode: mapDBFILESListRevisionsModeToDBX(object: args.mode), limit: args.limit)
        }
        if qualifiedRouteName == "files/lock_file_batch", let args = args as? DBFILESLockFileBatchArg {
            return client.files.lockFileBatch(entries: args.entries.compactMap { mapDBFILESLockFileArgToDBX(object: $0) })
        }
        if qualifiedRouteName == "files/move_v2", let args = args as? DBFILESRelocationArg {
            return client.files.moveV2(
                fromPath: args.fromPath,
                toPath: args.toPath,
                allowSharedFolder: args.allowSharedFolder,
                autorename: args.autorename,
                allowOwnershipTransfer: args.allowOwnershipTransfer
            )
        }
        if qualifiedRouteName == "files/move_batch_v2", let args = args as? DBFILESMoveBatchArg {
            return client.files.moveBatchV2(
                entries: args.entries.compactMap { mapDBFILESRelocationPathToDBX(object: $0) },
                autorename: args.autorename,
                allowOwnershipTransfer: args.allowOwnershipTransfer
            )
        }
        if qualifiedRouteName == "files/move_batch/check_v2", let args = args as? DBASYNCPollArg {
            return client.files.moveBatchCheckV2(asyncJobId: args.asyncJobId)
        }
        if qualifiedRouteName == "files/permanently_delete", let args = args as? DBFILESDeleteArg {
            return client.files.permanentlyDelete(path: args.path, parentRev: args.parentRev)
        }
        if qualifiedRouteName == "files/restore", let args = args as? DBFILESRestoreArg {
            return client.files.restore(path: args.path, rev: args.rev)
        }
        if qualifiedRouteName == "files/save_url", let args = args as? DBFILESSaveUrlArg {
            return client.files.saveUrl(path: args.path, url: args.url)
        }
        if qualifiedRouteName == "files/save_url/check_job_status", let args = args as? DBASYNCPollArg {
            return client.files.saveUrlCheckJobStatus(asyncJobId: args.asyncJobId)
        }
        if qualifiedRouteName == "files/search_v2", let args = args as? DBFILESSearchV2Arg {
            return client.files.searchV2(
                query: args.query,
                options: mapDBFILESSearchOptionsToDBXOptional(object: args.options),
                matchFieldOptions: mapDBFILESSearchMatchFieldOptionsToDBXOptional(object: args.matchFieldOptions),
                includeHighlights: args.includeHighlights
            )
        }
        if qualifiedRouteName == "files/search/continue_v2", let args = args as? DBFILESSearchV2ContinueArg {
            return client.files.searchContinueV2(cursor: args.cursor)
        }
        if qualifiedRouteName == "files/tags/add", let args = args as? DBFILESAddTagArg {
            return client.files.tagsAdd(path: args.path, tagText: args.tagText)
        }
        if qualifiedRouteName == "files/tags/get", let args = args as? DBFILESGetTagsArg {
            return client.files.tagsGet(paths: args.paths)
        }
        if qualifiedRouteName == "files/tags/remove", let args = args as? DBFILESRemoveTagArg {
            return client.files.tagsRemove(path: args.path, tagText: args.tagText)
        }
        if qualifiedRouteName == "files/unlock_file_batch", let args = args as? DBFILESUnlockFileBatchArg {
            return client.files.unlockFileBatch(entries: args.entries.compactMap { mapDBFILESUnlockFileArgToDBX(object: $0) })
        }
        if qualifiedRouteName == "files/upload_session/finish_batch_v2", let args = args as? DBFILESUploadSessionFinishBatchArg {
            return client.files.uploadSessionFinishBatchV2(entries: args.entries.compactMap { mapDBFILESUploadSessionFinishArgToDBX(object: $0) })
        }
        if qualifiedRouteName == "files/upload_session/finish_batch/check", let args = args as? DBASYNCPollArg {
            return client.files.uploadSessionFinishBatchCheck(asyncJobId: args.asyncJobId)
        }
        if qualifiedRouteName == "files/upload_session/start_batch", let args = args as? DBFILESUploadSessionStartBatchArg {
            return client.files.uploadSessionStartBatch(
                numSessions: args.numSessions,
                sessionType: mapDBFILESUploadSessionTypeToDBXOptional(object: args.sessionType)
            )
        }
        if qualifiedRouteName == "openid/userinfo" {
            return client.openid.userinfo()
        }
        if qualifiedRouteName == "sharing/add_file_member", let args = args as? DBSHARINGAddFileMemberArgs {
            return client.sharing.addFileMember(
                file: args.file,
                members: args.members.compactMap { mapDBSHARINGMemberSelectorToDBX(object: $0) },
                customMessage: args.customMessage,
                quiet: args.quiet,
                accessLevel: mapDBSHARINGAccessLevelToDBX(object: args.accessLevel),
                addMessageAsComment: args.addMessageAsComment
            )
        }
        if qualifiedRouteName == "sharing/add_folder_member", let args = args as? DBSHARINGAddFolderMemberArg {
            return client.sharing.addFolderMember(
                sharedFolderId: args.sharedFolderId,
                members: args.members.compactMap { mapDBSHARINGAddMemberToDBX(object: $0) },
                quiet: args.quiet,
                customMessage: args.customMessage
            )
        }
        if qualifiedRouteName == "sharing/check_job_status", let args = args as? DBASYNCPollArg {
            return client.sharing.checkJobStatus(asyncJobId: args.asyncJobId)
        }
        if qualifiedRouteName == "sharing/check_remove_member_job_status", let args = args as? DBASYNCPollArg {
            return client.sharing.checkRemoveMemberJobStatus(asyncJobId: args.asyncJobId)
        }
        if qualifiedRouteName == "sharing/check_share_job_status", let args = args as? DBASYNCPollArg {
            return client.sharing.checkShareJobStatus(asyncJobId: args.asyncJobId)
        }
        if qualifiedRouteName == "sharing/create_shared_link_with_settings", let args = args as? DBSHARINGCreateSharedLinkWithSettingsArg {
            return client.sharing.createSharedLinkWithSettings(path: args.path, settings: mapDBSHARINGSharedLinkSettingsToDBXOptional(object: args.settings))
        }
        if qualifiedRouteName == "sharing/get_file_metadata", let args = args as? DBSHARINGGetFileMetadataArg {
            return client.sharing.getFileMetadata(file: args.file, actions: args.actions?.compactMap { mapDBSHARINGFileActionToDBX(object: $0) })
        }
        if qualifiedRouteName == "sharing/get_file_metadata/batch", let args = args as? DBSHARINGGetFileMetadataBatchArg {
            return client.sharing.getFileMetadataBatch(files: args.files, actions: args.actions?.compactMap { mapDBSHARINGFileActionToDBX(object: $0) })
        }
        if qualifiedRouteName == "sharing/get_folder_metadata", let args = args as? DBSHARINGGetMetadataArgs {
            return client.sharing.getFolderMetadata(
                sharedFolderId: args.sharedFolderId,
                actions: args.actions?.compactMap { mapDBSHARINGFolderActionToDBX(object: $0) }
            )
        }
        if qualifiedRouteName == "sharing/get_shared_link_metadata", let args = args as? DBSHARINGGetSharedLinkMetadataArg {
            return client.sharing.getSharedLinkMetadata(url: args.url, path: args.path, linkPassword: args.linkPassword)
        }
        if qualifiedRouteName == "sharing/list_file_members", let args = args as? DBSHARINGListFileMembersArg {
            return client.sharing.listFileMembers(
                file: args.file,
                actions: args.actions?.compactMap { mapDBSHARINGMemberActionToDBX(object: $0) },
                includeInherited: args.includeInherited,
                limit: args.limit
            )
        }
        if qualifiedRouteName == "sharing/list_file_members/batch", let args = args as? DBSHARINGListFileMembersBatchArg {
            return client.sharing.listFileMembersBatch(files: args.files, limit: args.limit)
        }
        if qualifiedRouteName == "sharing/list_file_members/continue", let args = args as? DBSHARINGListFileMembersContinueArg {
            return client.sharing.listFileMembersContinue(cursor: args.cursor)
        }
        if qualifiedRouteName == "sharing/list_folder_members", let args = args as? DBSHARINGListFolderMembersArgs {
            return client.sharing.listFolderMembers(
                sharedFolderId: args.sharedFolderId,
                actions: args.actions?.compactMap { mapDBSHARINGMemberActionToDBX(object: $0) },
                limit: args.limit
            )
        }
        if qualifiedRouteName == "sharing/list_folder_members/continue", let args = args as? DBSHARINGListFolderMembersContinueArg {
            return client.sharing.listFolderMembersContinue(cursor: args.cursor)
        }
        if qualifiedRouteName == "sharing/list_folders", let args = args as? DBSHARINGListFoldersArgs {
            return client.sharing.listFolders(limit: args.limit, actions: args.actions?.compactMap { mapDBSHARINGFolderActionToDBX(object: $0) })
        }
        if qualifiedRouteName == "sharing/list_folders/continue", let args = args as? DBSHARINGListFoldersContinueArg {
            return client.sharing.listFoldersContinue(cursor: args.cursor)
        }
        if qualifiedRouteName == "sharing/list_mountable_folders", let args = args as? DBSHARINGListFoldersArgs {
            return client.sharing.listMountableFolders(limit: args.limit, actions: args.actions?.compactMap { mapDBSHARINGFolderActionToDBX(object: $0) })
        }
        if qualifiedRouteName == "sharing/list_mountable_folders/continue", let args = args as? DBSHARINGListFoldersContinueArg {
            return client.sharing.listMountableFoldersContinue(cursor: args.cursor)
        }
        if qualifiedRouteName == "sharing/list_received_files", let args = args as? DBSHARINGListFilesArg {
            return client.sharing.listReceivedFiles(limit: args.limit, actions: args.actions?.compactMap { mapDBSHARINGFileActionToDBX(object: $0) })
        }
        if qualifiedRouteName == "sharing/list_received_files/continue", let args = args as? DBSHARINGListFilesContinueArg {
            return client.sharing.listReceivedFilesContinue(cursor: args.cursor)
        }
        if qualifiedRouteName == "sharing/list_shared_links", let args = args as? DBSHARINGListSharedLinksArg {
            return client.sharing.listSharedLinks(path: args.path, cursor: args.cursor, directOnly: args.directOnly)
        }
        if qualifiedRouteName == "sharing/modify_shared_link_settings", let args = args as? DBSHARINGModifySharedLinkSettingsArgs {
            return client.sharing.modifySharedLinkSettings(
                url: args.url,
                settings: mapDBSHARINGSharedLinkSettingsToDBX(object: args.settings),
                removeExpiration: args.removeExpiration
            )
        }
        if qualifiedRouteName == "sharing/mount_folder", let args = args as? DBSHARINGMountFolderArg {
            return client.sharing.mountFolder(sharedFolderId: args.sharedFolderId)
        }
        if qualifiedRouteName == "sharing/relinquish_file_membership", let args = args as? DBSHARINGRelinquishFileMembershipArg {
            return client.sharing.relinquishFileMembership(file: args.file)
        }
        if qualifiedRouteName == "sharing/relinquish_folder_membership", let args = args as? DBSHARINGRelinquishFolderMembershipArg {
            return client.sharing.relinquishFolderMembership(sharedFolderId: args.sharedFolderId, leaveACopy: args.leaveACopy)
        }
        if qualifiedRouteName == "sharing/remove_file_member_2", let args = args as? DBSHARINGRemoveFileMemberArg {
            return client.sharing.removeFileMember2(file: args.file, member: mapDBSHARINGMemberSelectorToDBX(object: args.member))
        }
        if qualifiedRouteName == "sharing/remove_folder_member", let args = args as? DBSHARINGRemoveFolderMemberArg {
            return client.sharing.removeFolderMember(
                sharedFolderId: args.sharedFolderId,
                member: mapDBSHARINGMemberSelectorToDBX(object: args.member),
                leaveACopy: args.leaveACopy
            )
        }
        if qualifiedRouteName == "sharing/revoke_shared_link", let args = args as? DBSHARINGRevokeSharedLinkArg {
            return client.sharing.revokeSharedLink(url: args.url)
        }
        if qualifiedRouteName == "sharing/set_access_inheritance", let args = args as? DBSHARINGSetAccessInheritanceArg {
            return client.sharing.setAccessInheritance(
                sharedFolderId: args.sharedFolderId,
                accessInheritance: mapDBSHARINGAccessInheritanceToDBX(object: args.accessInheritance)
            )
        }
        if qualifiedRouteName == "sharing/share_folder", let args = args as? DBSHARINGShareFolderArg {
            return client.sharing.shareFolder(
                path: args.path,
                aclUpdatePolicy: mapDBSHARINGAclUpdatePolicyToDBXOptional(object: args.aclUpdatePolicy),
                forceAsync: args.forceAsync,
                memberPolicy: mapDBSHARINGMemberPolicyToDBXOptional(object: args.memberPolicy),
                sharedLinkPolicy: mapDBSHARINGSharedLinkPolicyToDBXOptional(object: args.sharedLinkPolicy),
                viewerInfoPolicy: mapDBSHARINGViewerInfoPolicyToDBXOptional(object: args.viewerInfoPolicy),
                accessInheritance: mapDBSHARINGAccessInheritanceToDBX(object: args.accessInheritance),
                actions: args.actions?.compactMap { mapDBSHARINGFolderActionToDBX(object: $0) },
                linkSettings: mapDBSHARINGLinkSettingsToDBXOptional(object: args.linkSettings)
            )
        }
        if qualifiedRouteName == "sharing/transfer_folder", let args = args as? DBSHARINGTransferFolderArg {
            return client.sharing.transferFolder(sharedFolderId: args.sharedFolderId, toDropboxId: args.toDropboxId)
        }
        if qualifiedRouteName == "sharing/unmount_folder", let args = args as? DBSHARINGUnmountFolderArg {
            return client.sharing.unmountFolder(sharedFolderId: args.sharedFolderId)
        }
        if qualifiedRouteName == "sharing/unshare_file", let args = args as? DBSHARINGUnshareFileArg {
            return client.sharing.unshareFile(file: args.file)
        }
        if qualifiedRouteName == "sharing/unshare_folder", let args = args as? DBSHARINGUnshareFolderArg {
            return client.sharing.unshareFolder(sharedFolderId: args.sharedFolderId, leaveACopy: args.leaveACopy)
        }
        if qualifiedRouteName == "sharing/update_file_member", let args = args as? DBSHARINGUpdateFileMemberArgs {
            return client.sharing.updateFileMember(
                file: args.file,
                member: mapDBSHARINGMemberSelectorToDBX(object: args.member),
                accessLevel: mapDBSHARINGAccessLevelToDBX(object: args.accessLevel)
            )
        }
        if qualifiedRouteName == "sharing/update_folder_member", let args = args as? DBSHARINGUpdateFolderMemberArg {
            return client.sharing.updateFolderMember(
                sharedFolderId: args.sharedFolderId,
                member: mapDBSHARINGMemberSelectorToDBX(object: args.member),
                accessLevel: mapDBSHARINGAccessLevelToDBX(object: args.accessLevel)
            )
        }
        if qualifiedRouteName == "sharing/update_folder_policy", let args = args as? DBSHARINGUpdateFolderPolicyArg {
            return client.sharing.updateFolderPolicy(
                sharedFolderId: args.sharedFolderId,
                memberPolicy: mapDBSHARINGMemberPolicyToDBXOptional(object: args.memberPolicy),
                aclUpdatePolicy: mapDBSHARINGAclUpdatePolicyToDBXOptional(object: args.aclUpdatePolicy),
                viewerInfoPolicy: mapDBSHARINGViewerInfoPolicyToDBXOptional(object: args.viewerInfoPolicy),
                sharedLinkPolicy: mapDBSHARINGSharedLinkPolicyToDBXOptional(object: args.sharedLinkPolicy),
                linkSettings: mapDBSHARINGLinkSettingsToDBXOptional(object: args.linkSettings),
                actions: args.actions?.compactMap { mapDBSHARINGFolderActionToDBX(object: $0) }
            )
        }
        if qualifiedRouteName == "users/features/get_values", let args = args as? DBUSERSUserFeaturesGetValuesBatchArg {
            return client.users.featuresGetValues(features: args.features.compactMap { mapDBUSERSUserFeatureToDBX(object: $0) })
        }
        if qualifiedRouteName == "users/get_account", let args = args as? DBUSERSGetAccountArg {
            return client.users.getAccount(accountId: args.accountId)
        }
        if qualifiedRouteName == "users/get_account_batch", let args = args as? DBUSERSGetAccountBatchArg {
            return client.users.getAccountBatch(accountIds: args.accountIds)
        }
        if qualifiedRouteName == "users/get_current_account" {
            return client.users.getCurrentAccount()
        }
        if qualifiedRouteName == "users/get_space_usage" {
            return client.users.getSpaceUsage()
        }
        return nil
    }
}

private func callErrorToDB(error: DBXCallError?) -> DBRequestError? {
    if let error = error?.asInternalServerError {
        return DBRequestError(asInternalServerError: error.requestId, statusCode: NSNumber(value: error.code), errorContent: error.message, userMessage: nil)
    }
    if let error = error?.asBadInputError {
        return DBRequestError(asBadInputError: error.requestId, statusCode: NSNumber(value: 400), errorContent: nil, userMessage: nil)
    }
    if let error = error?.asAuthError {
        var localizedUserMessage: DBLocalizedUserMessage?
        if let lum = error.localizedUserMessage {
            localizedUserMessage = DBLocalizedUserMessage(text: lum.text, locale: lum.locale)
        }
        let structuredAuthError: DBAUTHAuthError = {
            if error.error.asInvalidAccessToken != nil {
                return DBAUTHAuthError(invalidAccessToken: ())
            } else if error.error.asInvalidSelectUser != nil {
                return DBAUTHAuthError(invalidSelectUser: ())
            } else if error.error.asInvalidSelectAdmin != nil {
                return DBAUTHAuthError(invalidSelectAdmin: ())
            } else if error.error.asUserSuspended != nil {
                return DBAUTHAuthError(userSuspended: ())
            } else if error.error.asExpiredAccessToken != nil {
                return DBAUTHAuthError(expiredAccessToken: ())
            } else if let error = error.error.asMissingScope {
                let scopeError = DBAUTHTokenScopeError(requiredScope: error.missingScope.requiredScope)
                return DBAUTHAuthError(missingScope: scopeError)
            } else if error.error.asRouteAccessDenied != nil {
                return DBAUTHAuthError(routeAccessDenied: ())
            } else if error.error.asNoTeamApiAccess != nil {
                return DBAUTHAuthError(noTeamApiAccess: ())
            } else if error.error.asInvalidTeamAuthHeader != nil {
                return DBAUTHAuthError(invalidTeamAuthHeader: ())
            } else if error.error.asFederationAccessDenied != nil {
                return DBAUTHAuthError(federationAccessDenied: ())
            } else {
                return DBAUTHAuthError(other: ())
            }
        }()
        return DBRequestError(
            asAuthError: error.requestId,
            statusCode: NSNumber(value: 401),
            errorContent: error.message,
            userMessage: localizedUserMessage,
            structuredAuthError: structuredAuthError
        )
    }
    if let error = error?.asAccessError {
        var localizedUserMessage: DBLocalizedUserMessage?
        if let lum = error.localizedUserMessage {
            localizedUserMessage = DBLocalizedUserMessage(text: lum.text, locale: lum.locale)
        }
        let structuredAccessError: DBAUTHAccessError = {
            if let error = error.error.asInvalidAccountType {
                let accountTypeError: DBAUTHInvalidAccountTypeError = {
                    if error.invalidAccountType.asFeature != nil {
                        return DBAUTHInvalidAccountTypeError(feature: ())
                    } else if error.invalidAccountType.asEndpoint != nil {
                        return DBAUTHInvalidAccountTypeError(endpoint: ())
                    } else {
                        return DBAUTHInvalidAccountTypeError(other: ())
                    }
                }()
                return DBAUTHAccessError(invalidAccountType: accountTypeError)
            } else if let error = error.error.asPaperAccessDenied {
                let paperAccessError: DBAUTHPaperAccessError = {
                    if error.paperAccessDenied.asNotPaperUser != nil {
                        return DBAUTHPaperAccessError(notPaperUser: ())
                    } else if error.paperAccessDenied.asPaperDisabled != nil {
                        return DBAUTHPaperAccessError(paperDisabled: ())
                    } else {
                        return DBAUTHPaperAccessError(other: ())
                    }
                }()
                return DBAUTHAccessError(paperAccessDenied: paperAccessError)
            } else if error.error.asTeamAccessDenied != nil {
                return DBAUTHAccessError(teamAccessDenied: ())
            } else if let error = error.error.asNoPermission {
                let noPermissionError: DBAUTHNoPermissionError = {
                    if let error = error.noPermission.asUnauthorizedAccountIdUsage {
                        let error: DBAUTHUnauthorizedAccountIdUsageError = .init(
                            unauthorizedAccountIds: error.unauthorizedAccountIdUsage
                                .unauthorizedAccountIds
                        )
                        return DBAUTHNoPermissionError(unauthorizedAccountIdUsage: error)
                    } else {
                        return DBAUTHNoPermissionError(other: ())
                    }
                }()
                return DBAUTHAccessError(noPermission: noPermissionError)
            } else if let error = error.error.asPpAccessDenied {
                return DBAUTHAccessError(ppAccessDenied: ())
            } else {
                return DBAUTHAccessError(other: ())
            }
        }()
        return DBRequestError(
            asAccessError: error.requestId,
            statusCode: NSNumber(value: 403),
            errorContent: error.message,
            userMessage: localizedUserMessage,
            structuredAccessError: structuredAccessError
        )
    }
    if let error = error?.asHttpError {
        return DBRequestError(asHttpError: error.requestId, statusCode: NSNumber(value: error.code), errorContent: error.message, userMessage: nil)
    }
    if let error = error?.asRateLimitError {
        var localizedUserMessage: DBLocalizedUserMessage?
        if let lum = error.localizedUserMessage {
            localizedUserMessage = DBLocalizedUserMessage(text: lum.text, locale: lum.locale)
        }
        var reason: DBAUTHRateLimitReason = {
            if let error = error.error.reason.asTooManyRequests {
                DBAUTHRateLimitReason(tooManyRequests: ())
            } else if let error = error.error.reason.asTooManyWriteOperations {
                DBAUTHRateLimitReason(tooManyWriteOperations: ())
            } else {
                DBAUTHRateLimitReason(other: ())
            }
        }()

        let structuredRateLimitError: DBAUTHRateLimitError = .init(reason: reason, retryAfter: error.error.retryAfter)

        return DBRequestError(
            asRateLimitError: error.requestId,
            statusCode: NSNumber(value: 429),
            errorContent: error.message,
            userMessage: localizedUserMessage,
            structuredRateLimitError: structuredRateLimitError,
            backoff: structuredRateLimitError.retryAfter
        )
    }
    if let error = error?.asSerializationError {
        return DBRequestError(asClientError: error.error)
    }
    if let error = error?.asReconnectionError {
        return DBRequestError(asClientError: error.error)
    }
    if let error = error?.asClientError {
        return DBRequestError(asClientError: error.error)
    }
    return nil
}