///
/// Copyright (c) 2022 Dropbox, Inc. All rights reserved.
///
/// Auto-generated by Stone, do not modify.
///

import Foundation
import SwiftyDropbox

/// Objective-C compatible datatypes for the sharing namespace
/// For Swift see sharing

/// Information about the inheritance policy of a shared folder.
@objc
public class DBXSharingAccessInheritance: NSObject {
    let swift: Sharing.AccessInheritance

    public init(swift: Sharing.AccessInheritance) {
        self.swift = swift
    }

    public static func factory(swift: Sharing.AccessInheritance) -> DBXSharingAccessInheritance {
        switch swift {
        case .inherit:
            return DBXSharingAccessInheritanceInherit()
        case .noInherit:
            return DBXSharingAccessInheritanceNoInherit()
        case .other:
            return DBXSharingAccessInheritanceOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asInherit: DBXSharingAccessInheritanceInherit? {
        self as? DBXSharingAccessInheritanceInherit
    }

    @objc
    public var asNoInherit: DBXSharingAccessInheritanceNoInherit? {
        self as? DBXSharingAccessInheritanceNoInherit
    }

    @objc
    public var asOther: DBXSharingAccessInheritanceOther? {
        self as? DBXSharingAccessInheritanceOther
    }
}

/// The shared folder inherits its members from the parent folder.
@objc
public class DBXSharingAccessInheritanceInherit: DBXSharingAccessInheritance {
    @objc
    public init() {
        let swift = Sharing.AccessInheritance.inherit
        super.init(swift: swift)
    }
}

/// The shared folder does not inherit its members from the parent folder.
@objc
public class DBXSharingAccessInheritanceNoInherit: DBXSharingAccessInheritance {
    @objc
    public init() {
        let swift = Sharing.AccessInheritance.noInherit
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXSharingAccessInheritanceOther: DBXSharingAccessInheritance {
    @objc
    public init() {
        let swift = Sharing.AccessInheritance.other
        super.init(swift: swift)
    }
}

/// Defines the access levels for collaborators.
@objc
public class DBXSharingAccessLevel: NSObject {
    let swift: Sharing.AccessLevel

    public init(swift: Sharing.AccessLevel) {
        self.swift = swift
    }

    public static func factory(swift: Sharing.AccessLevel) -> DBXSharingAccessLevel {
        switch swift {
        case .owner:
            return DBXSharingAccessLevelOwner()
        case .editor:
            return DBXSharingAccessLevelEditor()
        case .viewer:
            return DBXSharingAccessLevelViewer()
        case .viewerNoComment:
            return DBXSharingAccessLevelViewerNoComment()
        case .traverse:
            return DBXSharingAccessLevelTraverse()
        case .noAccess:
            return DBXSharingAccessLevelNoAccess()
        case .other:
            return DBXSharingAccessLevelOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asOwner: DBXSharingAccessLevelOwner? {
        self as? DBXSharingAccessLevelOwner
    }

    @objc
    public var asEditor: DBXSharingAccessLevelEditor? {
        self as? DBXSharingAccessLevelEditor
    }

    @objc
    public var asViewer: DBXSharingAccessLevelViewer? {
        self as? DBXSharingAccessLevelViewer
    }

    @objc
    public var asViewerNoComment: DBXSharingAccessLevelViewerNoComment? {
        self as? DBXSharingAccessLevelViewerNoComment
    }

    @objc
    public var asTraverse: DBXSharingAccessLevelTraverse? {
        self as? DBXSharingAccessLevelTraverse
    }

    @objc
    public var asNoAccess: DBXSharingAccessLevelNoAccess? {
        self as? DBXSharingAccessLevelNoAccess
    }

    @objc
    public var asOther: DBXSharingAccessLevelOther? {
        self as? DBXSharingAccessLevelOther
    }
}

/// The collaborator is the owner of the shared folder. Owners can view and edit the shared folder as well as
/// set the folder's policies using updateFolderPolicy.
@objc
public class DBXSharingAccessLevelOwner: DBXSharingAccessLevel {
    @objc
    public init() {
        let swift = Sharing.AccessLevel.owner
        super.init(swift: swift)
    }
}

/// The collaborator can both view and edit the shared folder.
@objc
public class DBXSharingAccessLevelEditor: DBXSharingAccessLevel {
    @objc
    public init() {
        let swift = Sharing.AccessLevel.editor
        super.init(swift: swift)
    }
}

/// The collaborator can only view the shared folder.
@objc
public class DBXSharingAccessLevelViewer: DBXSharingAccessLevel {
    @objc
    public init() {
        let swift = Sharing.AccessLevel.viewer
        super.init(swift: swift)
    }
}

/// The collaborator can only view the shared folder and does not have any access to comments.
@objc
public class DBXSharingAccessLevelViewerNoComment: DBXSharingAccessLevel {
    @objc
    public init() {
        let swift = Sharing.AccessLevel.viewerNoComment
        super.init(swift: swift)
    }
}

/// The collaborator can only view the shared folder that they have access to.
@objc
public class DBXSharingAccessLevelTraverse: DBXSharingAccessLevel {
    @objc
    public init() {
        let swift = Sharing.AccessLevel.traverse
        super.init(swift: swift)
    }
}

/// If there is a Righteous Link on the folder which grants access and the user has visited such link, they are
/// allowed to perform certain action (i.e. add themselves to the folder) via the link access even
/// though the user themselves are not a member on the shared folder yet.
@objc
public class DBXSharingAccessLevelNoAccess: DBXSharingAccessLevel {
    @objc
    public init() {
        let swift = Sharing.AccessLevel.noAccess
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXSharingAccessLevelOther: DBXSharingAccessLevel {
    @objc
    public init() {
        let swift = Sharing.AccessLevel.other
        super.init(swift: swift)
    }
}

/// Who can change a shared folder's access control list (ACL). In other words, who can add, remove, or change the
/// privileges of members.
@objc
public class DBXSharingAclUpdatePolicy: NSObject {
    let swift: Sharing.AclUpdatePolicy

    public init(swift: Sharing.AclUpdatePolicy) {
        self.swift = swift
    }

    public static func factory(swift: Sharing.AclUpdatePolicy) -> DBXSharingAclUpdatePolicy {
        switch swift {
        case .owner:
            return DBXSharingAclUpdatePolicyOwner()
        case .editors:
            return DBXSharingAclUpdatePolicyEditors()
        case .other:
            return DBXSharingAclUpdatePolicyOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asOwner: DBXSharingAclUpdatePolicyOwner? {
        self as? DBXSharingAclUpdatePolicyOwner
    }

    @objc
    public var asEditors: DBXSharingAclUpdatePolicyEditors? {
        self as? DBXSharingAclUpdatePolicyEditors
    }

    @objc
    public var asOther: DBXSharingAclUpdatePolicyOther? {
        self as? DBXSharingAclUpdatePolicyOther
    }
}

/// Only the owner can update the ACL.
@objc
public class DBXSharingAclUpdatePolicyOwner: DBXSharingAclUpdatePolicy {
    @objc
    public init() {
        let swift = Sharing.AclUpdatePolicy.owner
        super.init(swift: swift)
    }
}

/// Any editor can update the ACL. This may be further restricted to editors on the same team.
@objc
public class DBXSharingAclUpdatePolicyEditors: DBXSharingAclUpdatePolicy {
    @objc
    public init() {
        let swift = Sharing.AclUpdatePolicy.editors
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXSharingAclUpdatePolicyOther: DBXSharingAclUpdatePolicy {
    @objc
    public init() {
        let swift = Sharing.AclUpdatePolicy.other
        super.init(swift: swift)
    }
}

/// Arguments for addFileMember.
@objc
public class DBXSharingAddFileMemberArgs: NSObject {
    /// File to which to add members.
    @objc
    public var file: String { swift.file }
    /// Members to add. Note that even an email address is given, this may result in a user being directly added to
    /// the membership if that email is the user's main account email.
    @objc
    public var members: [DBXSharingMemberSelector] { swift.members.map { DBXSharingMemberSelector(swift: $0) } }
    /// Message to send to added members in their invitation.
    @objc
    public var customMessage: String? { swift.customMessage }
    /// Whether added members should be notified via email and device notifications of their invitation.
    @objc
    public var quiet: NSNumber { swift.quiet as NSNumber }
    /// AccessLevel union object, describing what access level we want to give new members.
    @objc
    public var accessLevel: DBXSharingAccessLevel { DBXSharingAccessLevel(swift: swift.accessLevel) }
    /// If the custom message should be added as a comment on the file.
    @objc
    public var addMessageAsComment: NSNumber { swift.addMessageAsComment as NSNumber }

    @objc
    public init(
        file: String,
        members: [DBXSharingMemberSelector],
        customMessage: String?,
        quiet: NSNumber,
        accessLevel: DBXSharingAccessLevel,
        addMessageAsComment: NSNumber
    ) {
        self.swift = Sharing.AddFileMemberArgs(
            file: file,
            members: members.map(\.swift),
            customMessage: customMessage,
            quiet: quiet.boolValue,
            accessLevel: accessLevel.swift,
            addMessageAsComment: addMessageAsComment.boolValue
        )
    }

    let swift: Sharing.AddFileMemberArgs

    public init(swift: Sharing.AddFileMemberArgs) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Errors for addFileMember.
@objc
public class DBXSharingAddFileMemberError: NSObject {
    let swift: Sharing.AddFileMemberError

    public init(swift: Sharing.AddFileMemberError) {
        self.swift = swift
    }

    public static func factory(swift: Sharing.AddFileMemberError) -> DBXSharingAddFileMemberError {
        switch swift {
        case .userError(let swiftArg):
            let arg = DBXSharingSharingUserError(swift: swiftArg)
            return DBXSharingAddFileMemberErrorUserError(arg)
        case .accessError(let swiftArg):
            let arg = DBXSharingSharingFileAccessError(swift: swiftArg)
            return DBXSharingAddFileMemberErrorAccessError(arg)
        case .rateLimit:
            return DBXSharingAddFileMemberErrorRateLimit()
        case .invalidComment:
            return DBXSharingAddFileMemberErrorInvalidComment()
        case .other:
            return DBXSharingAddFileMemberErrorOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asUserError: DBXSharingAddFileMemberErrorUserError? {
        self as? DBXSharingAddFileMemberErrorUserError
    }

    @objc
    public var asAccessError: DBXSharingAddFileMemberErrorAccessError? {
        self as? DBXSharingAddFileMemberErrorAccessError
    }

    @objc
    public var asRateLimit: DBXSharingAddFileMemberErrorRateLimit? {
        self as? DBXSharingAddFileMemberErrorRateLimit
    }

    @objc
    public var asInvalidComment: DBXSharingAddFileMemberErrorInvalidComment? {
        self as? DBXSharingAddFileMemberErrorInvalidComment
    }

    @objc
    public var asOther: DBXSharingAddFileMemberErrorOther? {
        self as? DBXSharingAddFileMemberErrorOther
    }
}

/// An unspecified error.
@objc
public class DBXSharingAddFileMemberErrorUserError: DBXSharingAddFileMemberError {
    @objc
    public var userError: DBXSharingSharingUserError

    @objc
    public init(_ arg: DBXSharingSharingUserError) {
        self.userError = arg
        let swift = Sharing.AddFileMemberError.userError(arg.swift)
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXSharingAddFileMemberErrorAccessError: DBXSharingAddFileMemberError {
    @objc
    public var accessError: DBXSharingSharingFileAccessError

    @objc
    public init(_ arg: DBXSharingSharingFileAccessError) {
        self.accessError = arg
        let swift = Sharing.AddFileMemberError.accessError(arg.swift)
        super.init(swift: swift)
    }
}

/// The user has reached the rate limit for invitations.
@objc
public class DBXSharingAddFileMemberErrorRateLimit: DBXSharingAddFileMemberError {
    @objc
    public init() {
        let swift = Sharing.AddFileMemberError.rateLimit
        super.init(swift: swift)
    }
}

/// The custom message did not pass comment permissions checks.
@objc
public class DBXSharingAddFileMemberErrorInvalidComment: DBXSharingAddFileMemberError {
    @objc
    public init() {
        let swift = Sharing.AddFileMemberError.invalidComment
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXSharingAddFileMemberErrorOther: DBXSharingAddFileMemberError {
    @objc
    public init() {
        let swift = Sharing.AddFileMemberError.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible AddFolderMemberArg struct
@objc
public class DBXSharingAddFolderMemberArg: NSObject {
    /// The ID for the shared folder.
    @objc
    public var sharedFolderId: String { swift.sharedFolderId }
    /// The intended list of members to add.  Added members will receive invites to join the shared folder.
    @objc
    public var members: [DBXSharingAddMember] { swift.members.map { DBXSharingAddMember(swift: $0) } }
    /// Whether added members should be notified via email and device notifications of their invite.
    @objc
    public var quiet: NSNumber { swift.quiet as NSNumber }
    /// Optional message to display to added members in their invitation.
    @objc
    public var customMessage: String? { swift.customMessage }

    @objc
    public init(sharedFolderId: String, members: [DBXSharingAddMember], quiet: NSNumber, customMessage: String?) {
        self.swift = Sharing.AddFolderMemberArg(
            sharedFolderId: sharedFolderId,
            members: members.map(\.swift),
            quiet: quiet.boolValue,
            customMessage: customMessage
        )
    }

    let swift: Sharing.AddFolderMemberArg

    public init(swift: Sharing.AddFolderMemberArg) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible AddFolderMemberError union
@objc
public class DBXSharingAddFolderMemberError: NSObject {
    let swift: Sharing.AddFolderMemberError

    public init(swift: Sharing.AddFolderMemberError) {
        self.swift = swift
    }

    public static func factory(swift: Sharing.AddFolderMemberError) -> DBXSharingAddFolderMemberError {
        switch swift {
        case .accessError(let swiftArg):
            let arg = DBXSharingSharedFolderAccessError(swift: swiftArg)
            return DBXSharingAddFolderMemberErrorAccessError(arg)
        case .emailUnverified:
            return DBXSharingAddFolderMemberErrorEmailUnverified()
        case .bannedMember:
            return DBXSharingAddFolderMemberErrorBannedMember()
        case .badMember(let swiftArg):
            let arg = DBXSharingAddMemberSelectorError(swift: swiftArg)
            return DBXSharingAddFolderMemberErrorBadMember(arg)
        case .cantShareOutsideTeam:
            return DBXSharingAddFolderMemberErrorCantShareOutsideTeam()
        case .tooManyMembers(let swiftArg):
            let arg = NSNumber(value: swiftArg)
            return DBXSharingAddFolderMemberErrorTooManyMembers(arg)
        case .tooManyPendingInvites(let swiftArg):
            let arg = NSNumber(value: swiftArg)
            return DBXSharingAddFolderMemberErrorTooManyPendingInvites(arg)
        case .rateLimit:
            return DBXSharingAddFolderMemberErrorRateLimit()
        case .tooManyInvitees:
            return DBXSharingAddFolderMemberErrorTooManyInvitees()
        case .insufficientPlan:
            return DBXSharingAddFolderMemberErrorInsufficientPlan()
        case .teamFolder:
            return DBXSharingAddFolderMemberErrorTeamFolder()
        case .noPermission:
            return DBXSharingAddFolderMemberErrorNoPermission()
        case .invalidSharedFolder:
            return DBXSharingAddFolderMemberErrorInvalidSharedFolder()
        case .other:
            return DBXSharingAddFolderMemberErrorOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asAccessError: DBXSharingAddFolderMemberErrorAccessError? {
        self as? DBXSharingAddFolderMemberErrorAccessError
    }

    @objc
    public var asEmailUnverified: DBXSharingAddFolderMemberErrorEmailUnverified? {
        self as? DBXSharingAddFolderMemberErrorEmailUnverified
    }

    @objc
    public var asBannedMember: DBXSharingAddFolderMemberErrorBannedMember? {
        self as? DBXSharingAddFolderMemberErrorBannedMember
    }

    @objc
    public var asBadMember: DBXSharingAddFolderMemberErrorBadMember? {
        self as? DBXSharingAddFolderMemberErrorBadMember
    }

    @objc
    public var asCantShareOutsideTeam: DBXSharingAddFolderMemberErrorCantShareOutsideTeam? {
        self as? DBXSharingAddFolderMemberErrorCantShareOutsideTeam
    }

    @objc
    public var asTooManyMembers: DBXSharingAddFolderMemberErrorTooManyMembers? {
        self as? DBXSharingAddFolderMemberErrorTooManyMembers
    }

    @objc
    public var asTooManyPendingInvites: DBXSharingAddFolderMemberErrorTooManyPendingInvites? {
        self as? DBXSharingAddFolderMemberErrorTooManyPendingInvites
    }

    @objc
    public var asRateLimit: DBXSharingAddFolderMemberErrorRateLimit? {
        self as? DBXSharingAddFolderMemberErrorRateLimit
    }

    @objc
    public var asTooManyInvitees: DBXSharingAddFolderMemberErrorTooManyInvitees? {
        self as? DBXSharingAddFolderMemberErrorTooManyInvitees
    }

    @objc
    public var asInsufficientPlan: DBXSharingAddFolderMemberErrorInsufficientPlan? {
        self as? DBXSharingAddFolderMemberErrorInsufficientPlan
    }

    @objc
    public var asTeamFolder: DBXSharingAddFolderMemberErrorTeamFolder? {
        self as? DBXSharingAddFolderMemberErrorTeamFolder
    }

    @objc
    public var asNoPermission: DBXSharingAddFolderMemberErrorNoPermission? {
        self as? DBXSharingAddFolderMemberErrorNoPermission
    }

    @objc
    public var asInvalidSharedFolder: DBXSharingAddFolderMemberErrorInvalidSharedFolder? {
        self as? DBXSharingAddFolderMemberErrorInvalidSharedFolder
    }

    @objc
    public var asOther: DBXSharingAddFolderMemberErrorOther? {
        self as? DBXSharingAddFolderMemberErrorOther
    }
}

/// Unable to access shared folder.
@objc
public class DBXSharingAddFolderMemberErrorAccessError: DBXSharingAddFolderMemberError {
    @objc
    public var accessError: DBXSharingSharedFolderAccessError

    @objc
    public init(_ arg: DBXSharingSharedFolderAccessError) {
        self.accessError = arg
        let swift = Sharing.AddFolderMemberError.accessError(arg.swift)
        super.init(swift: swift)
    }
}

/// This user's email address is not verified. This functionality is only available on accounts with a verified
/// email address. Users can verify their email address here https://www.dropbox.com/help/317.
@objc
public class DBXSharingAddFolderMemberErrorEmailUnverified: DBXSharingAddFolderMemberError {
    @objc
    public init() {
        let swift = Sharing.AddFolderMemberError.emailUnverified
        super.init(swift: swift)
    }
}

/// The current user has been banned.
@objc
public class DBXSharingAddFolderMemberErrorBannedMember: DBXSharingAddFolderMemberError {
    @objc
    public init() {
        let swift = Sharing.AddFolderMemberError.bannedMember
        super.init(swift: swift)
    }
}

/// members in AddFolderMemberArg contains a bad invitation recipient.
@objc
public class DBXSharingAddFolderMemberErrorBadMember: DBXSharingAddFolderMemberError {
    @objc
    public var badMember: DBXSharingAddMemberSelectorError

    @objc
    public init(_ arg: DBXSharingAddMemberSelectorError) {
        self.badMember = arg
        let swift = Sharing.AddFolderMemberError.badMember(arg.swift)
        super.init(swift: swift)
    }
}

/// Your team policy does not allow sharing outside of the team.
@objc
public class DBXSharingAddFolderMemberErrorCantShareOutsideTeam: DBXSharingAddFolderMemberError {
    @objc
    public init() {
        let swift = Sharing.AddFolderMemberError.cantShareOutsideTeam
        super.init(swift: swift)
    }
}

/// The value is the member limit that was reached.
@objc
public class DBXSharingAddFolderMemberErrorTooManyMembers: DBXSharingAddFolderMemberError {
    @objc
    public var tooManyMembers: NSNumber

    @objc
    public init(_ arg: NSNumber) {
        self.tooManyMembers = arg
        let swift = Sharing.AddFolderMemberError.tooManyMembers(arg.uint64Value)
        super.init(swift: swift)
    }
}

/// The value is the pending invite limit that was reached.
@objc
public class DBXSharingAddFolderMemberErrorTooManyPendingInvites: DBXSharingAddFolderMemberError {
    @objc
    public var tooManyPendingInvites: NSNumber

    @objc
    public init(_ arg: NSNumber) {
        self.tooManyPendingInvites = arg
        let swift = Sharing.AddFolderMemberError.tooManyPendingInvites(arg.uint64Value)
        super.init(swift: swift)
    }
}

/// The current user has hit the limit of invites they can send per day. Try again in 24 hours.
@objc
public class DBXSharingAddFolderMemberErrorRateLimit: DBXSharingAddFolderMemberError {
    @objc
    public init() {
        let swift = Sharing.AddFolderMemberError.rateLimit
        super.init(swift: swift)
    }
}

/// The current user is trying to share with too many people at once.
@objc
public class DBXSharingAddFolderMemberErrorTooManyInvitees: DBXSharingAddFolderMemberError {
    @objc
    public init() {
        let swift = Sharing.AddFolderMemberError.tooManyInvitees
        super.init(swift: swift)
    }
}

/// The current user's account doesn't support this action. An example of this is when adding a read-only
/// member. This action can only be performed by users that have upgraded to a Pro or Business plan.
@objc
public class DBXSharingAddFolderMemberErrorInsufficientPlan: DBXSharingAddFolderMemberError {
    @objc
    public init() {
        let swift = Sharing.AddFolderMemberError.insufficientPlan
        super.init(swift: swift)
    }
}

/// This action cannot be performed on a team shared folder.
@objc
public class DBXSharingAddFolderMemberErrorTeamFolder: DBXSharingAddFolderMemberError {
    @objc
    public init() {
        let swift = Sharing.AddFolderMemberError.teamFolder
        super.init(swift: swift)
    }
}

/// The current user does not have permission to perform this action.
@objc
public class DBXSharingAddFolderMemberErrorNoPermission: DBXSharingAddFolderMemberError {
    @objc
    public init() {
        let swift = Sharing.AddFolderMemberError.noPermission
        super.init(swift: swift)
    }
}

/// Invalid shared folder error will be returned as an access_error.
@objc
public class DBXSharingAddFolderMemberErrorInvalidSharedFolder: DBXSharingAddFolderMemberError {
    @objc
    public init() {
        let swift = Sharing.AddFolderMemberError.invalidSharedFolder
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXSharingAddFolderMemberErrorOther: DBXSharingAddFolderMemberError {
    @objc
    public init() {
        let swift = Sharing.AddFolderMemberError.other
        super.init(swift: swift)
    }
}

/// The member and type of access the member should have when added to a shared folder.
@objc
public class DBXSharingAddMember: NSObject {
    /// The member to add to the shared folder.
    @objc
    public var member: DBXSharingMemberSelector { DBXSharingMemberSelector(swift: swift.member) }
    /// The access level to grant member to the shared folder.  owner in AccessLevel is disallowed.
    @objc
    public var accessLevel: DBXSharingAccessLevel { DBXSharingAccessLevel(swift: swift.accessLevel) }

    @objc
    public init(member: DBXSharingMemberSelector, accessLevel: DBXSharingAccessLevel) {
        self.swift = Sharing.AddMember(member: member.swift, accessLevel: accessLevel.swift)
    }

    let swift: Sharing.AddMember

    public init(swift: Sharing.AddMember) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible AddMemberSelectorError union
@objc
public class DBXSharingAddMemberSelectorError: NSObject {
    let swift: Sharing.AddMemberSelectorError

    public init(swift: Sharing.AddMemberSelectorError) {
        self.swift = swift
    }

    public static func factory(swift: Sharing.AddMemberSelectorError) -> DBXSharingAddMemberSelectorError {
        switch swift {
        case .automaticGroup:
            return DBXSharingAddMemberSelectorErrorAutomaticGroup()
        case .invalidDropboxId(let swiftArg):
            let arg = swiftArg
            return DBXSharingAddMemberSelectorErrorInvalidDropboxId(arg)
        case .invalidEmail(let swiftArg):
            let arg = swiftArg
            return DBXSharingAddMemberSelectorErrorInvalidEmail(arg)
        case .unverifiedDropboxId(let swiftArg):
            let arg = swiftArg
            return DBXSharingAddMemberSelectorErrorUnverifiedDropboxId(arg)
        case .groupDeleted:
            return DBXSharingAddMemberSelectorErrorGroupDeleted()
        case .groupNotOnTeam:
            return DBXSharingAddMemberSelectorErrorGroupNotOnTeam()
        case .other:
            return DBXSharingAddMemberSelectorErrorOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asAutomaticGroup: DBXSharingAddMemberSelectorErrorAutomaticGroup? {
        self as? DBXSharingAddMemberSelectorErrorAutomaticGroup
    }

    @objc
    public var asInvalidDropboxId: DBXSharingAddMemberSelectorErrorInvalidDropboxId? {
        self as? DBXSharingAddMemberSelectorErrorInvalidDropboxId
    }

    @objc
    public var asInvalidEmail: DBXSharingAddMemberSelectorErrorInvalidEmail? {
        self as? DBXSharingAddMemberSelectorErrorInvalidEmail
    }

    @objc
    public var asUnverifiedDropboxId: DBXSharingAddMemberSelectorErrorUnverifiedDropboxId? {
        self as? DBXSharingAddMemberSelectorErrorUnverifiedDropboxId
    }

    @objc
    public var asGroupDeleted: DBXSharingAddMemberSelectorErrorGroupDeleted? {
        self as? DBXSharingAddMemberSelectorErrorGroupDeleted
    }

    @objc
    public var asGroupNotOnTeam: DBXSharingAddMemberSelectorErrorGroupNotOnTeam? {
        self as? DBXSharingAddMemberSelectorErrorGroupNotOnTeam
    }

    @objc
    public var asOther: DBXSharingAddMemberSelectorErrorOther? {
        self as? DBXSharingAddMemberSelectorErrorOther
    }
}

/// Automatically created groups can only be added to team folders.
@objc
public class DBXSharingAddMemberSelectorErrorAutomaticGroup: DBXSharingAddMemberSelectorError {
    @objc
    public init() {
        let swift = Sharing.AddMemberSelectorError.automaticGroup
        super.init(swift: swift)
    }
}

/// The value is the ID that could not be identified.
@objc
public class DBXSharingAddMemberSelectorErrorInvalidDropboxId: DBXSharingAddMemberSelectorError {
    @objc
    public var invalidDropboxId: String

    @objc
    public init(_ arg: String) {
        self.invalidDropboxId = arg
        let swift = Sharing.AddMemberSelectorError.invalidDropboxId(arg)
        super.init(swift: swift)
    }
}

/// The value is the e-email address that is malformed.
@objc
public class DBXSharingAddMemberSelectorErrorInvalidEmail: DBXSharingAddMemberSelectorError {
    @objc
    public var invalidEmail: String

    @objc
    public init(_ arg: String) {
        self.invalidEmail = arg
        let swift = Sharing.AddMemberSelectorError.invalidEmail(arg)
        super.init(swift: swift)
    }
}

/// The value is the ID of the Dropbox user with an unverified email address. Invite unverified users by email
/// address instead of by their Dropbox ID.
@objc
public class DBXSharingAddMemberSelectorErrorUnverifiedDropboxId: DBXSharingAddMemberSelectorError {
    @objc
    public var unverifiedDropboxId: String

    @objc
    public init(_ arg: String) {
        self.unverifiedDropboxId = arg
        let swift = Sharing.AddMemberSelectorError.unverifiedDropboxId(arg)
        super.init(swift: swift)
    }
}

/// At least one of the specified groups in members in AddFolderMemberArg is deleted.
@objc
public class DBXSharingAddMemberSelectorErrorGroupDeleted: DBXSharingAddMemberSelectorError {
    @objc
    public init() {
        let swift = Sharing.AddMemberSelectorError.groupDeleted
        super.init(swift: swift)
    }
}

/// Sharing to a group that is not on the current user's team.
@objc
public class DBXSharingAddMemberSelectorErrorGroupNotOnTeam: DBXSharingAddMemberSelectorError {
    @objc
    public init() {
        let swift = Sharing.AddMemberSelectorError.groupNotOnTeam
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXSharingAddMemberSelectorErrorOther: DBXSharingAddMemberSelectorError {
    @objc
    public init() {
        let swift = Sharing.AddMemberSelectorError.other
        super.init(swift: swift)
    }
}

/// The access permission that can be requested by the caller for the shared link. Note that the final resolved
/// visibility of the shared link takes into account other aspects, such as team and shared folder settings. Check
/// the ResolvedVisibility for more info on the possible resolved visibility values of shared links.
@objc
public class DBXSharingRequestedVisibility: NSObject {
    let swift: Sharing.RequestedVisibility

    public init(swift: Sharing.RequestedVisibility) {
        self.swift = swift
    }

    public static func factory(swift: Sharing.RequestedVisibility) -> DBXSharingRequestedVisibility {
        switch swift {
        case .public_:
            return DBXSharingRequestedVisibilityPublic_()
        case .teamOnly:
            return DBXSharingRequestedVisibilityTeamOnly()
        case .password:
            return DBXSharingRequestedVisibilityPassword()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asPublic_: DBXSharingRequestedVisibilityPublic_? {
        self as? DBXSharingRequestedVisibilityPublic_
    }

    @objc
    public var asTeamOnly: DBXSharingRequestedVisibilityTeamOnly? {
        self as? DBXSharingRequestedVisibilityTeamOnly
    }

    @objc
    public var asPassword: DBXSharingRequestedVisibilityPassword? {
        self as? DBXSharingRequestedVisibilityPassword
    }
}

/// Anyone who has received the link can access it. No login required.
@objc
public class DBXSharingRequestedVisibilityPublic_: DBXSharingRequestedVisibility {
    @objc
    public init() {
        let swift = Sharing.RequestedVisibility.public_
        super.init(swift: swift)
    }
}

/// Only members of the same team can access the link. Login is required.
@objc
public class DBXSharingRequestedVisibilityTeamOnly: DBXSharingRequestedVisibility {
    @objc
    public init() {
        let swift = Sharing.RequestedVisibility.teamOnly
        super.init(swift: swift)
    }
}

/// A link-specific password is required to access the link. Login is not required.
@objc
public class DBXSharingRequestedVisibilityPassword: DBXSharingRequestedVisibility {
    @objc
    public init() {
        let swift = Sharing.RequestedVisibility.password
        super.init(swift: swift)
    }
}

/// The actual access permissions values of shared links after taking into account user preferences and the team and
/// shared folder settings. Check the RequestedVisibility for more info on the possible visibility values that can
/// be set by the shared link's owner.
@objc
public class DBXSharingResolvedVisibility: NSObject {
    let swift: Sharing.ResolvedVisibility

    public init(swift: Sharing.ResolvedVisibility) {
        self.swift = swift
    }

    public static func factory(swift: Sharing.ResolvedVisibility) -> DBXSharingResolvedVisibility {
        switch swift {
        case .public_:
            return DBXSharingResolvedVisibilityPublic_()
        case .teamOnly:
            return DBXSharingResolvedVisibilityTeamOnly()
        case .password:
            return DBXSharingResolvedVisibilityPassword()
        case .teamAndPassword:
            return DBXSharingResolvedVisibilityTeamAndPassword()
        case .sharedFolderOnly:
            return DBXSharingResolvedVisibilitySharedFolderOnly()
        case .noOne:
            return DBXSharingResolvedVisibilityNoOne()
        case .onlyYou:
            return DBXSharingResolvedVisibilityOnlyYou()
        case .other:
            return DBXSharingResolvedVisibilityOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asPublic_: DBXSharingResolvedVisibilityPublic_? {
        self as? DBXSharingResolvedVisibilityPublic_
    }

    @objc
    public var asTeamOnly: DBXSharingResolvedVisibilityTeamOnly? {
        self as? DBXSharingResolvedVisibilityTeamOnly
    }

    @objc
    public var asPassword: DBXSharingResolvedVisibilityPassword? {
        self as? DBXSharingResolvedVisibilityPassword
    }

    @objc
    public var asTeamAndPassword: DBXSharingResolvedVisibilityTeamAndPassword? {
        self as? DBXSharingResolvedVisibilityTeamAndPassword
    }

    @objc
    public var asSharedFolderOnly: DBXSharingResolvedVisibilitySharedFolderOnly? {
        self as? DBXSharingResolvedVisibilitySharedFolderOnly
    }

    @objc
    public var asNoOne: DBXSharingResolvedVisibilityNoOne? {
        self as? DBXSharingResolvedVisibilityNoOne
    }

    @objc
    public var asOnlyYou: DBXSharingResolvedVisibilityOnlyYou? {
        self as? DBXSharingResolvedVisibilityOnlyYou
    }

    @objc
    public var asOther: DBXSharingResolvedVisibilityOther? {
        self as? DBXSharingResolvedVisibilityOther
    }
}

/// Anyone who has received the link can access it. No login required.
@objc
public class DBXSharingResolvedVisibilityPublic_: DBXSharingResolvedVisibility {
    @objc
    public init() {
        let swift = Sharing.ResolvedVisibility.public_
        super.init(swift: swift)
    }
}

/// Only members of the same team can access the link. Login is required.
@objc
public class DBXSharingResolvedVisibilityTeamOnly: DBXSharingResolvedVisibility {
    @objc
    public init() {
        let swift = Sharing.ResolvedVisibility.teamOnly
        super.init(swift: swift)
    }
}

/// A link-specific password is required to access the link. Login is not required.
@objc
public class DBXSharingResolvedVisibilityPassword: DBXSharingResolvedVisibility {
    @objc
    public init() {
        let swift = Sharing.ResolvedVisibility.password
        super.init(swift: swift)
    }
}

/// Only members of the same team who have the link-specific password can access the link. Login is required.
@objc
public class DBXSharingResolvedVisibilityTeamAndPassword: DBXSharingResolvedVisibility {
    @objc
    public init() {
        let swift = Sharing.ResolvedVisibility.teamAndPassword
        super.init(swift: swift)
    }
}

/// Only members of the shared folder containing the linked file can access the link. Login is required.
@objc
public class DBXSharingResolvedVisibilitySharedFolderOnly: DBXSharingResolvedVisibility {
    @objc
    public init() {
        let swift = Sharing.ResolvedVisibility.sharedFolderOnly
        super.init(swift: swift)
    }
}

/// The link merely points the user to the content, and does not grant any additional rights. Existing members
/// of the content who use this link can only access the content with their pre-existing access rights.
/// Either on the file directly, or inherited from a parent folder.
@objc
public class DBXSharingResolvedVisibilityNoOne: DBXSharingResolvedVisibility {
    @objc
    public init() {
        let swift = Sharing.ResolvedVisibility.noOne
        super.init(swift: swift)
    }
}

/// Only the current user can view this link.
@objc
public class DBXSharingResolvedVisibilityOnlyYou: DBXSharingResolvedVisibility {
    @objc
    public init() {
        let swift = Sharing.ResolvedVisibility.onlyYou
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXSharingResolvedVisibilityOther: DBXSharingResolvedVisibility {
    @objc
    public init() {
        let swift = Sharing.ResolvedVisibility.other
        super.init(swift: swift)
    }
}

/// check documentation for ResolvedVisibility.
@objc
public class DBXSharingAlphaResolvedVisibility: NSObject {
    let swift: Sharing.AlphaResolvedVisibility

    public init(swift: Sharing.AlphaResolvedVisibility) {
        self.swift = swift
    }

    public static func factory(swift: Sharing.AlphaResolvedVisibility) -> DBXSharingAlphaResolvedVisibility {
        switch swift {
        case .public_:
            return DBXSharingAlphaResolvedVisibilityPublic_()
        case .teamOnly:
            return DBXSharingAlphaResolvedVisibilityTeamOnly()
        case .password:
            return DBXSharingAlphaResolvedVisibilityPassword()
        case .teamAndPassword:
            return DBXSharingAlphaResolvedVisibilityTeamAndPassword()
        case .sharedFolderOnly:
            return DBXSharingAlphaResolvedVisibilitySharedFolderOnly()
        case .noOne:
            return DBXSharingAlphaResolvedVisibilityNoOne()
        case .onlyYou:
            return DBXSharingAlphaResolvedVisibilityOnlyYou()
        case .other:
            return DBXSharingAlphaResolvedVisibilityOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asPublic_: DBXSharingAlphaResolvedVisibilityPublic_? {
        self as? DBXSharingAlphaResolvedVisibilityPublic_
    }

    @objc
    public var asTeamOnly: DBXSharingAlphaResolvedVisibilityTeamOnly? {
        self as? DBXSharingAlphaResolvedVisibilityTeamOnly
    }

    @objc
    public var asPassword: DBXSharingAlphaResolvedVisibilityPassword? {
        self as? DBXSharingAlphaResolvedVisibilityPassword
    }

    @objc
    public var asTeamAndPassword: DBXSharingAlphaResolvedVisibilityTeamAndPassword? {
        self as? DBXSharingAlphaResolvedVisibilityTeamAndPassword
    }

    @objc
    public var asSharedFolderOnly: DBXSharingAlphaResolvedVisibilitySharedFolderOnly? {
        self as? DBXSharingAlphaResolvedVisibilitySharedFolderOnly
    }

    @objc
    public var asNoOne: DBXSharingAlphaResolvedVisibilityNoOne? {
        self as? DBXSharingAlphaResolvedVisibilityNoOne
    }

    @objc
    public var asOnlyYou: DBXSharingAlphaResolvedVisibilityOnlyYou? {
        self as? DBXSharingAlphaResolvedVisibilityOnlyYou
    }

    @objc
    public var asOther: DBXSharingAlphaResolvedVisibilityOther? {
        self as? DBXSharingAlphaResolvedVisibilityOther
    }
}

/// Anyone who has received the link can access it. No login required.
@objc
public class DBXSharingAlphaResolvedVisibilityPublic_: DBXSharingAlphaResolvedVisibility {
    @objc
    public init() {
        let swift = Sharing.AlphaResolvedVisibility.public_
        super.init(swift: swift)
    }
}

/// Only members of the same team can access the link. Login is required.
@objc
public class DBXSharingAlphaResolvedVisibilityTeamOnly: DBXSharingAlphaResolvedVisibility {
    @objc
    public init() {
        let swift = Sharing.AlphaResolvedVisibility.teamOnly
        super.init(swift: swift)
    }
}

/// A link-specific password is required to access the link. Login is not required.
@objc
public class DBXSharingAlphaResolvedVisibilityPassword: DBXSharingAlphaResolvedVisibility {
    @objc
    public init() {
        let swift = Sharing.AlphaResolvedVisibility.password
        super.init(swift: swift)
    }
}

/// Only members of the same team who have the link-specific password can access the link. Login is required.
@objc
public class DBXSharingAlphaResolvedVisibilityTeamAndPassword: DBXSharingAlphaResolvedVisibility {
    @objc
    public init() {
        let swift = Sharing.AlphaResolvedVisibility.teamAndPassword
        super.init(swift: swift)
    }
}

/// Only members of the shared folder containing the linked file can access the link. Login is required.
@objc
public class DBXSharingAlphaResolvedVisibilitySharedFolderOnly: DBXSharingAlphaResolvedVisibility {
    @objc
    public init() {
        let swift = Sharing.AlphaResolvedVisibility.sharedFolderOnly
        super.init(swift: swift)
    }
}

/// The link merely points the user to the content, and does not grant any additional rights. Existing members
/// of the content who use this link can only access the content with their pre-existing access rights.
/// Either on the file directly, or inherited from a parent folder.
@objc
public class DBXSharingAlphaResolvedVisibilityNoOne: DBXSharingAlphaResolvedVisibility {
    @objc
    public init() {
        let swift = Sharing.AlphaResolvedVisibility.noOne
        super.init(swift: swift)
    }
}

/// Only the current user can view this link.
@objc
public class DBXSharingAlphaResolvedVisibilityOnlyYou: DBXSharingAlphaResolvedVisibility {
    @objc
    public init() {
        let swift = Sharing.AlphaResolvedVisibility.onlyYou
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXSharingAlphaResolvedVisibilityOther: DBXSharingAlphaResolvedVisibility {
    @objc
    public init() {
        let swift = Sharing.AlphaResolvedVisibility.other
        super.init(swift: swift)
    }
}

/// Information about the content that has a link audience different than that of this folder.
@objc
public class DBXSharingAudienceExceptionContentInfo: NSObject {
    /// The name of the content, which is either a file or a folder.
    @objc
    public var name: String { swift.name }

    @objc
    public init(name: String) {
        self.swift = Sharing.AudienceExceptionContentInfo(name: name)
    }

    let swift: Sharing.AudienceExceptionContentInfo

    public init(swift: Sharing.AudienceExceptionContentInfo) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// The total count and truncated list of information of content inside this folder that has a different audience
/// than the link on this folder. This is only returned for folders.
@objc
public class DBXSharingAudienceExceptions: NSObject {
    /// (no description)
    @objc
    public var count: NSNumber { swift.count as NSNumber }
    /// A truncated list of some of the content that is an exception. The length of this list could be smaller than
    /// the count since it is only a sample but will not be empty as long as count is not 0.
    @objc
    public var exceptions: [DBXSharingAudienceExceptionContentInfo] { swift.exceptions.map { DBXSharingAudienceExceptionContentInfo(swift: $0) } }

    @objc
    public init(count: NSNumber, exceptions: [DBXSharingAudienceExceptionContentInfo]) {
        self.swift = Sharing.AudienceExceptions(count: count.uint32Value, exceptions: exceptions.map(\.swift))
    }

    let swift: Sharing.AudienceExceptions

    public init(swift: Sharing.AudienceExceptions) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Information about the shared folder that prevents the link audience for this link from being more restrictive.
@objc
public class DBXSharingAudienceRestrictingSharedFolder: NSObject {
    /// The ID of the shared folder.
    @objc
    public var sharedFolderId: String { swift.sharedFolderId }
    /// The name of the shared folder.
    @objc
    public var name: String { swift.name }
    /// The link audience of the shared folder.
    @objc
    public var audience: DBXSharingLinkAudience { DBXSharingLinkAudience(swift: swift.audience) }

    @objc
    public init(sharedFolderId: String, name: String, audience: DBXSharingLinkAudience) {
        self.swift = Sharing.AudienceRestrictingSharedFolder(sharedFolderId: sharedFolderId, name: name, audience: audience.swift)
    }

    let swift: Sharing.AudienceRestrictingSharedFolder

    public init(swift: Sharing.AudienceRestrictingSharedFolder) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Metadata for a shared link. This can be either a PathLinkMetadata or CollectionLinkMetadata.
@objc
public class DBXSharingLinkMetadata: NSObject {
    /// URL of the shared link.
    @objc
    public var url: String { swift.url }
    /// Who can access the link.
    @objc
    public var visibility: DBXSharingVisibility { DBXSharingVisibility(swift: swift.visibility) }
    /// Expiration time, if set. By default the link won't expire.
    @objc
    public var expires: Date? { swift.expires }

    @objc
    public init(url: String, visibility: DBXSharingVisibility, expires: Date?) {
        self.swift = Sharing.LinkMetadata(url: url, visibility: visibility.swift, expires: expires)
    }

    let swift: Sharing.LinkMetadata

    public init(swift: Sharing.LinkMetadata) {
        self.swift = swift
    }

    public static func wrapPreservingSubtypes(swift: Sharing.LinkMetadata) -> DBXSharingLinkMetadata {
        switch swift {
        case let pathLinkMetadata as Sharing.PathLinkMetadata:
            return DBXSharingPathLinkMetadata(swift: pathLinkMetadata)
        case let collectionLinkMetadata as Sharing.CollectionLinkMetadata:
            return DBXSharingCollectionLinkMetadata(swift: collectionLinkMetadata)
        default:
            return DBXSharingLinkMetadata(swift: swift)
        }
    }

    @objc
    public override var description: String { swift.description }
}

/// Metadata for a collection-based shared link.
@objc
public class DBXSharingCollectionLinkMetadata: DBXSharingLinkMetadata {
    let subSwift: Sharing.CollectionLinkMetadata

    public init(swift: Sharing.CollectionLinkMetadata) {
        self.subSwift = swift
        super.init(swift: swift)
    }

    @objc
    public override var description: String { subSwift.description }
}

/// Objective-C compatible CreateSharedLinkArg struct
@objc
public class DBXSharingCreateSharedLinkArg: NSObject {
    /// The path to share.
    @objc
    public var path: String { swift.path }
    /// (no description)
    @objc
    public var shortUrl: NSNumber { swift.shortUrl as NSNumber }
    /// If it's okay to share a path that does not yet exist, set this to either file in PendingUploadMode or folder
    /// in PendingUploadMode to indicate whether to assume it's a file or folder.
    @objc
    public var pendingUpload: DBXSharingPendingUploadMode? { guard let swift = swift.pendingUpload else { return nil }
        return DBXSharingPendingUploadMode(swift: swift)
    }

    @objc
    public init(path: String, shortUrl: NSNumber, pendingUpload: DBXSharingPendingUploadMode?) {
        self.swift = Sharing.CreateSharedLinkArg(path: path, shortUrl: shortUrl.boolValue, pendingUpload: pendingUpload?.swift)
    }

    let swift: Sharing.CreateSharedLinkArg

    public init(swift: Sharing.CreateSharedLinkArg) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible CreateSharedLinkError union
@objc
public class DBXSharingCreateSharedLinkError: NSObject {
    let swift: Sharing.CreateSharedLinkError

    public init(swift: Sharing.CreateSharedLinkError) {
        self.swift = swift
    }

    public static func factory(swift: Sharing.CreateSharedLinkError) -> DBXSharingCreateSharedLinkError {
        switch swift {
        case .path(let swiftArg):
            let arg = DBXFilesLookupError(swift: swiftArg)
            return DBXSharingCreateSharedLinkErrorPath(arg)
        case .other:
            return DBXSharingCreateSharedLinkErrorOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asPath: DBXSharingCreateSharedLinkErrorPath? {
        self as? DBXSharingCreateSharedLinkErrorPath
    }

    @objc
    public var asOther: DBXSharingCreateSharedLinkErrorOther? {
        self as? DBXSharingCreateSharedLinkErrorOther
    }
}

/// An unspecified error.
@objc
public class DBXSharingCreateSharedLinkErrorPath: DBXSharingCreateSharedLinkError {
    @objc
    public var path: DBXFilesLookupError

    @objc
    public init(_ arg: DBXFilesLookupError) {
        self.path = arg
        let swift = Sharing.CreateSharedLinkError.path(arg.swift)
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXSharingCreateSharedLinkErrorOther: DBXSharingCreateSharedLinkError {
    @objc
    public init() {
        let swift = Sharing.CreateSharedLinkError.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible CreateSharedLinkWithSettingsArg struct
@objc
public class DBXSharingCreateSharedLinkWithSettingsArg: NSObject {
    /// The path to be shared by the shared link.
    @objc
    public var path: String { swift.path }
    /// The requested settings for the newly created shared link.
    @objc
    public var settings: DBXSharingSharedLinkSettings? { guard let swift = swift.settings else { return nil }
        return DBXSharingSharedLinkSettings(swift: swift)
    }

    @objc
    public init(path: String, settings: DBXSharingSharedLinkSettings?) {
        self.swift = Sharing.CreateSharedLinkWithSettingsArg(path: path, settings: settings?.swift)
    }

    let swift: Sharing.CreateSharedLinkWithSettingsArg

    public init(swift: Sharing.CreateSharedLinkWithSettingsArg) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible CreateSharedLinkWithSettingsError union
@objc
public class DBXSharingCreateSharedLinkWithSettingsError: NSObject {
    let swift: Sharing.CreateSharedLinkWithSettingsError

    public init(swift: Sharing.CreateSharedLinkWithSettingsError) {
        self.swift = swift
    }

    public static func factory(swift: Sharing.CreateSharedLinkWithSettingsError) -> DBXSharingCreateSharedLinkWithSettingsError {
        switch swift {
        case .path(let swiftArg):
            let arg = DBXFilesLookupError(swift: swiftArg)
            return DBXSharingCreateSharedLinkWithSettingsErrorPath(arg)
        case .emailNotVerified:
            return DBXSharingCreateSharedLinkWithSettingsErrorEmailNotVerified()
        case .sharedLinkAlreadyExists(let swiftArg):
            guard let swiftArg = swiftArg else { return DBXSharingCreateSharedLinkWithSettingsErrorSharedLinkAlreadyExists(nil) }
            let arg = DBXSharingSharedLinkAlreadyExistsMetadata(swift: swiftArg)
            return DBXSharingCreateSharedLinkWithSettingsErrorSharedLinkAlreadyExists(arg)
        case .settingsError(let swiftArg):
            let arg = DBXSharingSharedLinkSettingsError(swift: swiftArg)
            return DBXSharingCreateSharedLinkWithSettingsErrorSettingsError(arg)
        case .accessDenied:
            return DBXSharingCreateSharedLinkWithSettingsErrorAccessDenied()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asPath: DBXSharingCreateSharedLinkWithSettingsErrorPath? {
        self as? DBXSharingCreateSharedLinkWithSettingsErrorPath
    }

    @objc
    public var asEmailNotVerified: DBXSharingCreateSharedLinkWithSettingsErrorEmailNotVerified? {
        self as? DBXSharingCreateSharedLinkWithSettingsErrorEmailNotVerified
    }

    @objc
    public var asSharedLinkAlreadyExists: DBXSharingCreateSharedLinkWithSettingsErrorSharedLinkAlreadyExists? {
        self as? DBXSharingCreateSharedLinkWithSettingsErrorSharedLinkAlreadyExists
    }

    @objc
    public var asSettingsError: DBXSharingCreateSharedLinkWithSettingsErrorSettingsError? {
        self as? DBXSharingCreateSharedLinkWithSettingsErrorSettingsError
    }

    @objc
    public var asAccessDenied: DBXSharingCreateSharedLinkWithSettingsErrorAccessDenied? {
        self as? DBXSharingCreateSharedLinkWithSettingsErrorAccessDenied
    }
}

/// An unspecified error.
@objc
public class DBXSharingCreateSharedLinkWithSettingsErrorPath: DBXSharingCreateSharedLinkWithSettingsError {
    @objc
    public var path: DBXFilesLookupError

    @objc
    public init(_ arg: DBXFilesLookupError) {
        self.path = arg
        let swift = Sharing.CreateSharedLinkWithSettingsError.path(arg.swift)
        super.init(swift: swift)
    }
}

/// This user's email address is not verified. This functionality is only available on accounts with a verified
/// email address. Users can verify their email address here https://www.dropbox.com/help/317.
@objc
public class DBXSharingCreateSharedLinkWithSettingsErrorEmailNotVerified: DBXSharingCreateSharedLinkWithSettingsError {
    @objc
    public init() {
        let swift = Sharing.CreateSharedLinkWithSettingsError.emailNotVerified
        super.init(swift: swift)
    }
}

/// The shared link already exists. You can call listSharedLinks to get the  existing link, or use the provided
/// metadata if it is returned.
@objc
public class DBXSharingCreateSharedLinkWithSettingsErrorSharedLinkAlreadyExists: DBXSharingCreateSharedLinkWithSettingsError {
    @objc
    public var sharedLinkAlreadyExists: DBXSharingSharedLinkAlreadyExistsMetadata?

    @objc
    public init(_ arg: DBXSharingSharedLinkAlreadyExistsMetadata?) {
        self.sharedLinkAlreadyExists = arg
        let swift = Sharing.CreateSharedLinkWithSettingsError.sharedLinkAlreadyExists(arg?.swift)
        super.init(swift: swift)
    }
}

/// There is an error with the given settings.
@objc
public class DBXSharingCreateSharedLinkWithSettingsErrorSettingsError: DBXSharingCreateSharedLinkWithSettingsError {
    @objc
    public var settingsError: DBXSharingSharedLinkSettingsError

    @objc
    public init(_ arg: DBXSharingSharedLinkSettingsError) {
        self.settingsError = arg
        let swift = Sharing.CreateSharedLinkWithSettingsError.settingsError(arg.swift)
        super.init(swift: swift)
    }
}

/// The user is not allowed to create a shared link to the specified file. For  example, this can occur if the
/// file is restricted or if the user's links are  banned
/// https://help.dropbox.com/files-folders/share/banned-links.
@objc
public class DBXSharingCreateSharedLinkWithSettingsErrorAccessDenied: DBXSharingCreateSharedLinkWithSettingsError {
    @objc
    public init() {
        let swift = Sharing.CreateSharedLinkWithSettingsError.accessDenied
        super.init(swift: swift)
    }
}

/// Objective-C compatible SharedContentLinkMetadataBase struct
@objc
public class DBXSharingSharedContentLinkMetadataBase: NSObject {
    /// The access level on the link for this file.
    @objc
    public var accessLevel: DBXSharingAccessLevel? { guard let swift = swift.accessLevel else { return nil }
        return DBXSharingAccessLevel(swift: swift)
    }

    /// The audience options that are available for the content. Some audience options may be unavailable. For
    /// example, team_only may be unavailable if the content is not owned by a user on a team. The 'default'
    /// audience option is always available if the user can modify link settings.
    @objc
    public var audienceOptions: [DBXSharingLinkAudience] { swift.audienceOptions.map { DBXSharingLinkAudience(swift: $0) } }
    /// The shared folder that prevents the link audience for this link from being more restrictive.
    @objc
    public var audienceRestrictingSharedFolder: DBXSharingAudienceRestrictingSharedFolder? {
        guard let swift = swift.audienceRestrictingSharedFolder else { return nil }
        return DBXSharingAudienceRestrictingSharedFolder(swift: swift)
    }

    /// The current audience of the link.
    @objc
    public var currentAudience: DBXSharingLinkAudience { DBXSharingLinkAudience(swift: swift.currentAudience) }
    /// Whether the link has an expiry set on it. A link with an expiry will have its  audience changed to members
    /// when the expiry is reached.
    @objc
    public var expiry: Date? { swift.expiry }
    /// A list of permissions for actions you can perform on the link.
    @objc
    public var linkPermissions: [DBXSharingLinkPermission] { swift.linkPermissions.map { DBXSharingLinkPermission(swift: $0) } }
    /// Whether the link is protected by a password.
    @objc
    public var passwordProtected: NSNumber { swift.passwordProtected as NSNumber }

    @objc
    public init(
        audienceOptions: [DBXSharingLinkAudience],
        currentAudience: DBXSharingLinkAudience,
        linkPermissions: [DBXSharingLinkPermission],
        passwordProtected: NSNumber,
        accessLevel: DBXSharingAccessLevel?,
        audienceRestrictingSharedFolder: DBXSharingAudienceRestrictingSharedFolder?,
        expiry: Date?
    ) {
        self.swift = Sharing.SharedContentLinkMetadataBase(
            audienceOptions: audienceOptions.map(\.swift),
            currentAudience: currentAudience.swift,
            linkPermissions: linkPermissions.map(\.swift),
            passwordProtected: passwordProtected.boolValue,
            accessLevel: accessLevel?.swift,
            audienceRestrictingSharedFolder: audienceRestrictingSharedFolder?.swift,
            expiry: expiry
        )
    }

    let swift: Sharing.SharedContentLinkMetadataBase

    public init(swift: Sharing.SharedContentLinkMetadataBase) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// The expected metadata of a shared link for a file or folder when a link is first created for the content. Absent
/// if the link already exists.
@objc
public class DBXSharingExpectedSharedContentLinkMetadata: DBXSharingSharedContentLinkMetadataBase {
    let subSwift: Sharing.ExpectedSharedContentLinkMetadata

    public init(swift: Sharing.ExpectedSharedContentLinkMetadata) {
        self.subSwift = swift
        super.init(swift: swift)
    }

    @objc
    public override var description: String { subSwift.description }
}

/// Sharing actions that may be taken on files.
@objc
public class DBXSharingFileAction: NSObject {
    let swift: Sharing.FileAction

    public init(swift: Sharing.FileAction) {
        self.swift = swift
    }

    public static func factory(swift: Sharing.FileAction) -> DBXSharingFileAction {
        switch swift {
        case .disableViewerInfo:
            return DBXSharingFileActionDisableViewerInfo()
        case .editContents:
            return DBXSharingFileActionEditContents()
        case .enableViewerInfo:
            return DBXSharingFileActionEnableViewerInfo()
        case .inviteViewer:
            return DBXSharingFileActionInviteViewer()
        case .inviteViewerNoComment:
            return DBXSharingFileActionInviteViewerNoComment()
        case .inviteEditor:
            return DBXSharingFileActionInviteEditor()
        case .unshare:
            return DBXSharingFileActionUnshare()
        case .relinquishMembership:
            return DBXSharingFileActionRelinquishMembership()
        case .shareLink:
            return DBXSharingFileActionShareLink()
        case .createLink:
            return DBXSharingFileActionCreateLink()
        case .createViewLink:
            return DBXSharingFileActionCreateViewLink()
        case .createEditLink:
            return DBXSharingFileActionCreateEditLink()
        case .other:
            return DBXSharingFileActionOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asDisableViewerInfo: DBXSharingFileActionDisableViewerInfo? {
        self as? DBXSharingFileActionDisableViewerInfo
    }

    @objc
    public var asEditContents: DBXSharingFileActionEditContents? {
        self as? DBXSharingFileActionEditContents
    }

    @objc
    public var asEnableViewerInfo: DBXSharingFileActionEnableViewerInfo? {
        self as? DBXSharingFileActionEnableViewerInfo
    }

    @objc
    public var asInviteViewer: DBXSharingFileActionInviteViewer? {
        self as? DBXSharingFileActionInviteViewer
    }

    @objc
    public var asInviteViewerNoComment: DBXSharingFileActionInviteViewerNoComment? {
        self as? DBXSharingFileActionInviteViewerNoComment
    }

    @objc
    public var asInviteEditor: DBXSharingFileActionInviteEditor? {
        self as? DBXSharingFileActionInviteEditor
    }

    @objc
    public var asUnshare: DBXSharingFileActionUnshare? {
        self as? DBXSharingFileActionUnshare
    }

    @objc
    public var asRelinquishMembership: DBXSharingFileActionRelinquishMembership? {
        self as? DBXSharingFileActionRelinquishMembership
    }

    @objc
    public var asShareLink: DBXSharingFileActionShareLink? {
        self as? DBXSharingFileActionShareLink
    }

    @objc
    public var asCreateLink: DBXSharingFileActionCreateLink? {
        self as? DBXSharingFileActionCreateLink
    }

    @objc
    public var asCreateViewLink: DBXSharingFileActionCreateViewLink? {
        self as? DBXSharingFileActionCreateViewLink
    }

    @objc
    public var asCreateEditLink: DBXSharingFileActionCreateEditLink? {
        self as? DBXSharingFileActionCreateEditLink
    }

    @objc
    public var asOther: DBXSharingFileActionOther? {
        self as? DBXSharingFileActionOther
    }
}

/// Disable viewer information on the file.
@objc
public class DBXSharingFileActionDisableViewerInfo: DBXSharingFileAction {
    @objc
    public init() {
        let swift = Sharing.FileAction.disableViewerInfo
        super.init(swift: swift)
    }
}

/// Change or edit contents of the file.
@objc
public class DBXSharingFileActionEditContents: DBXSharingFileAction {
    @objc
    public init() {
        let swift = Sharing.FileAction.editContents
        super.init(swift: swift)
    }
}

/// Enable viewer information on the file.
@objc
public class DBXSharingFileActionEnableViewerInfo: DBXSharingFileAction {
    @objc
    public init() {
        let swift = Sharing.FileAction.enableViewerInfo
        super.init(swift: swift)
    }
}

/// Add a member with view permissions.
@objc
public class DBXSharingFileActionInviteViewer: DBXSharingFileAction {
    @objc
    public init() {
        let swift = Sharing.FileAction.inviteViewer
        super.init(swift: swift)
    }
}

/// Add a member with view permissions but no comment permissions.
@objc
public class DBXSharingFileActionInviteViewerNoComment: DBXSharingFileAction {
    @objc
    public init() {
        let swift = Sharing.FileAction.inviteViewerNoComment
        super.init(swift: swift)
    }
}

/// Add a member with edit permissions.
@objc
public class DBXSharingFileActionInviteEditor: DBXSharingFileAction {
    @objc
    public init() {
        let swift = Sharing.FileAction.inviteEditor
        super.init(swift: swift)
    }
}

/// Stop sharing this file.
@objc
public class DBXSharingFileActionUnshare: DBXSharingFileAction {
    @objc
    public init() {
        let swift = Sharing.FileAction.unshare
        super.init(swift: swift)
    }
}

/// Relinquish one's own membership to the file.
@objc
public class DBXSharingFileActionRelinquishMembership: DBXSharingFileAction {
    @objc
    public init() {
        let swift = Sharing.FileAction.relinquishMembership
        super.init(swift: swift)
    }
}

/// Use create_view_link and create_edit_link instead.
@objc
public class DBXSharingFileActionShareLink: DBXSharingFileAction {
    @objc
    public init() {
        let swift = Sharing.FileAction.shareLink
        super.init(swift: swift)
    }
}

/// Use create_view_link and create_edit_link instead.
@objc
public class DBXSharingFileActionCreateLink: DBXSharingFileAction {
    @objc
    public init() {
        let swift = Sharing.FileAction.createLink
        super.init(swift: swift)
    }
}

/// Create a shared link to a file that only allows users to view the content.
@objc
public class DBXSharingFileActionCreateViewLink: DBXSharingFileAction {
    @objc
    public init() {
        let swift = Sharing.FileAction.createViewLink
        super.init(swift: swift)
    }
}

/// Create a shared link to a file that allows users to edit the content.
@objc
public class DBXSharingFileActionCreateEditLink: DBXSharingFileAction {
    @objc
    public init() {
        let swift = Sharing.FileAction.createEditLink
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXSharingFileActionOther: DBXSharingFileAction {
    @objc
    public init() {
        let swift = Sharing.FileAction.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible FileErrorResult union
@objc
public class DBXSharingFileErrorResult: NSObject {
    let swift: Sharing.FileErrorResult

    public init(swift: Sharing.FileErrorResult) {
        self.swift = swift
    }

    public static func factory(swift: Sharing.FileErrorResult) -> DBXSharingFileErrorResult {
        switch swift {
        case .fileNotFoundError(let swiftArg):
            let arg = swiftArg
            return DBXSharingFileErrorResultFileNotFoundError(arg)
        case .invalidFileActionError(let swiftArg):
            let arg = swiftArg
            return DBXSharingFileErrorResultInvalidFileActionError(arg)
        case .permissionDeniedError(let swiftArg):
            let arg = swiftArg
            return DBXSharingFileErrorResultPermissionDeniedError(arg)
        case .other:
            return DBXSharingFileErrorResultOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asFileNotFoundError: DBXSharingFileErrorResultFileNotFoundError? {
        self as? DBXSharingFileErrorResultFileNotFoundError
    }

    @objc
    public var asInvalidFileActionError: DBXSharingFileErrorResultInvalidFileActionError? {
        self as? DBXSharingFileErrorResultInvalidFileActionError
    }

    @objc
    public var asPermissionDeniedError: DBXSharingFileErrorResultPermissionDeniedError? {
        self as? DBXSharingFileErrorResultPermissionDeniedError
    }

    @objc
    public var asOther: DBXSharingFileErrorResultOther? {
        self as? DBXSharingFileErrorResultOther
    }
}

/// File specified by id was not found.
@objc
public class DBXSharingFileErrorResultFileNotFoundError: DBXSharingFileErrorResult {
    @objc
    public var fileNotFoundError: String

    @objc
    public init(_ arg: String) {
        self.fileNotFoundError = arg
        let swift = Sharing.FileErrorResult.fileNotFoundError(arg)
        super.init(swift: swift)
    }
}

/// User does not have permission to take the specified action on the file.
@objc
public class DBXSharingFileErrorResultInvalidFileActionError: DBXSharingFileErrorResult {
    @objc
    public var invalidFileActionError: String

    @objc
    public init(_ arg: String) {
        self.invalidFileActionError = arg
        let swift = Sharing.FileErrorResult.invalidFileActionError(arg)
        super.init(swift: swift)
    }
}

/// User does not have permission to access file specified by file.Id.
@objc
public class DBXSharingFileErrorResultPermissionDeniedError: DBXSharingFileErrorResult {
    @objc
    public var permissionDeniedError: String

    @objc
    public init(_ arg: String) {
        self.permissionDeniedError = arg
        let swift = Sharing.FileErrorResult.permissionDeniedError(arg)
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXSharingFileErrorResultOther: DBXSharingFileErrorResult {
    @objc
    public init() {
        let swift = Sharing.FileErrorResult.other
        super.init(swift: swift)
    }
}

/// The metadata of a shared link.
@objc
public class DBXSharingSharedLinkMetadata: NSObject {
    /// URL of the shared link.
    @objc
    public var url: String { swift.url }
    /// A unique identifier for the linked file.
    @objc
    public var id: String? { swift.id }
    /// The linked file name (including extension). This never contains a slash.
    @objc
    public var name: String { swift.name }
    /// Expiration time, if set. By default the link won't expire.
    @objc
    public var expires: Date? { swift.expires }
    /// The lowercased full path in the user's Dropbox. This always starts with a slash. This field will only be
    /// present only if the linked file is in the authenticated user's  dropbox.
    @objc
    public var pathLower: String? { swift.pathLower }
    /// The link's access permissions.
    @objc
    public var linkPermissions: DBXSharingLinkPermissions { DBXSharingLinkPermissions(swift: swift.linkPermissions) }
    /// The team membership information of the link's owner.  This field will only be present  if the link's owner
    /// is a team member.
    @objc
    public var teamMemberInfo: DBXSharingTeamMemberInfo? { guard let swift = swift.teamMemberInfo else { return nil }
        return DBXSharingTeamMemberInfo(swift: swift)
    }

    /// The team information of the content's owner. This field will only be present if the content's owner is a
    /// team member and the content's owner team is different from the link's owner team.
    @objc
    public var contentOwnerTeamInfo: DBXUsersTeam? { guard let swift = swift.contentOwnerTeamInfo else { return nil }
        return DBXUsersTeam(swift: swift)
    }

    @objc
    public init(
        url: String,
        name: String,
        linkPermissions: DBXSharingLinkPermissions,
        id: String?,
        expires: Date?,
        pathLower: String?,
        teamMemberInfo: DBXSharingTeamMemberInfo?,
        contentOwnerTeamInfo: DBXUsersTeam?
    ) {
        self.swift = Sharing.SharedLinkMetadata(
            url: url,
            name: name,
            linkPermissions: linkPermissions.swift,
            id: id,
            expires: expires,
            pathLower: pathLower,
            teamMemberInfo: teamMemberInfo?.swift,
            contentOwnerTeamInfo: contentOwnerTeamInfo?.swift
        )
    }

    let swift: Sharing.SharedLinkMetadata

    public init(swift: Sharing.SharedLinkMetadata) {
        self.swift = swift
    }

    public static func wrapPreservingSubtypes(swift: Sharing.SharedLinkMetadata) -> DBXSharingSharedLinkMetadata {
        switch swift {
        case let fileLinkMetadata as Sharing.FileLinkMetadata:
            return DBXSharingFileLinkMetadata(swift: fileLinkMetadata)
        case let folderLinkMetadata as Sharing.FolderLinkMetadata:
            return DBXSharingFolderLinkMetadata(swift: folderLinkMetadata)
        default:
            return DBXSharingSharedLinkMetadata(swift: swift)
        }
    }

    @objc
    public override var description: String { swift.description }
}

/// The metadata of a file shared link.
@objc
public class DBXSharingFileLinkMetadata: DBXSharingSharedLinkMetadata {
    /// The modification time set by the desktop client when the file was added to Dropbox. Since this time is not
    /// verified (the Dropbox server stores whatever the desktop client sends up), this should only be used for
    /// display purposes (such as sorting) and not, for example, to determine if a file has changed or not.
    @objc
    public var clientModified: Date { subSwift.clientModified }
    /// The last time the file was modified on Dropbox.
    @objc
    public var serverModified: Date { subSwift.serverModified }
    /// A unique identifier for the current revision of a file. This field is the same rev as elsewhere in the API
    /// and can be used to detect changes and avoid conflicts.
    @objc
    public var rev: String { subSwift.rev }
    /// The file size in bytes.
    @objc
    public var size: NSNumber { subSwift.size as NSNumber }

    @objc
    public init(
        url: String,
        name: String,
        linkPermissions: DBXSharingLinkPermissions,
        clientModified: Date,
        serverModified: Date,
        rev: String,
        size: NSNumber,
        id: String?,
        expires: Date?,
        pathLower: String?,
        teamMemberInfo: DBXSharingTeamMemberInfo?,
        contentOwnerTeamInfo: DBXUsersTeam?
    ) {
        let swift = Sharing.FileLinkMetadata(
            url: url,
            name: name,
            linkPermissions: linkPermissions.swift,
            clientModified: clientModified,
            serverModified: serverModified,
            rev: rev,
            size: size.uint64Value,
            id: id,
            expires: expires,
            pathLower: pathLower,
            teamMemberInfo: teamMemberInfo?.swift,
            contentOwnerTeamInfo: contentOwnerTeamInfo?.swift
        )
        self.subSwift = swift
        super.init(swift: swift)
    }

    let subSwift: Sharing.FileLinkMetadata

    public init(swift: Sharing.FileLinkMetadata) {
        self.subSwift = swift
        super.init(swift: swift)
    }

    @objc
    public override var description: String { subSwift.description }
}

/// Objective-C compatible FileMemberActionError union
@objc
public class DBXSharingFileMemberActionError: NSObject {
    let swift: Sharing.FileMemberActionError

    public init(swift: Sharing.FileMemberActionError) {
        self.swift = swift
    }

    public static func factory(swift: Sharing.FileMemberActionError) -> DBXSharingFileMemberActionError {
        switch swift {
        case .invalidMember:
            return DBXSharingFileMemberActionErrorInvalidMember()
        case .noPermission:
            return DBXSharingFileMemberActionErrorNoPermission()
        case .accessError(let swiftArg):
            let arg = DBXSharingSharingFileAccessError(swift: swiftArg)
            return DBXSharingFileMemberActionErrorAccessError(arg)
        case .noExplicitAccess(let swiftArg):
            let arg = DBXSharingMemberAccessLevelResult(swift: swiftArg)
            return DBXSharingFileMemberActionErrorNoExplicitAccess(arg)
        case .other:
            return DBXSharingFileMemberActionErrorOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asInvalidMember: DBXSharingFileMemberActionErrorInvalidMember? {
        self as? DBXSharingFileMemberActionErrorInvalidMember
    }

    @objc
    public var asNoPermission: DBXSharingFileMemberActionErrorNoPermission? {
        self as? DBXSharingFileMemberActionErrorNoPermission
    }

    @objc
    public var asAccessError: DBXSharingFileMemberActionErrorAccessError? {
        self as? DBXSharingFileMemberActionErrorAccessError
    }

    @objc
    public var asNoExplicitAccess: DBXSharingFileMemberActionErrorNoExplicitAccess? {
        self as? DBXSharingFileMemberActionErrorNoExplicitAccess
    }

    @objc
    public var asOther: DBXSharingFileMemberActionErrorOther? {
        self as? DBXSharingFileMemberActionErrorOther
    }
}

/// Specified member was not found.
@objc
public class DBXSharingFileMemberActionErrorInvalidMember: DBXSharingFileMemberActionError {
    @objc
    public init() {
        let swift = Sharing.FileMemberActionError.invalidMember
        super.init(swift: swift)
    }
}

/// User does not have permission to perform this action on this member.
@objc
public class DBXSharingFileMemberActionErrorNoPermission: DBXSharingFileMemberActionError {
    @objc
    public init() {
        let swift = Sharing.FileMemberActionError.noPermission
        super.init(swift: swift)
    }
}

/// Specified file was invalid or user does not have access.
@objc
public class DBXSharingFileMemberActionErrorAccessError: DBXSharingFileMemberActionError {
    @objc
    public var accessError: DBXSharingSharingFileAccessError

    @objc
    public init(_ arg: DBXSharingSharingFileAccessError) {
        self.accessError = arg
        let swift = Sharing.FileMemberActionError.accessError(arg.swift)
        super.init(swift: swift)
    }
}

/// The action cannot be completed because the target member does not have explicit access to the file. The
/// return value is the access that the member has to the file from a parent folder.
@objc
public class DBXSharingFileMemberActionErrorNoExplicitAccess: DBXSharingFileMemberActionError {
    @objc
    public var noExplicitAccess: DBXSharingMemberAccessLevelResult

    @objc
    public init(_ arg: DBXSharingMemberAccessLevelResult) {
        self.noExplicitAccess = arg
        let swift = Sharing.FileMemberActionError.noExplicitAccess(arg.swift)
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXSharingFileMemberActionErrorOther: DBXSharingFileMemberActionError {
    @objc
    public init() {
        let swift = Sharing.FileMemberActionError.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible FileMemberActionIndividualResult union
@objc
public class DBXSharingFileMemberActionIndividualResult: NSObject {
    let swift: Sharing.FileMemberActionIndividualResult

    public init(swift: Sharing.FileMemberActionIndividualResult) {
        self.swift = swift
    }

    public static func factory(swift: Sharing.FileMemberActionIndividualResult) -> DBXSharingFileMemberActionIndividualResult {
        switch swift {
        case .success(let swiftArg):
            guard let swiftArg = swiftArg else { return DBXSharingFileMemberActionIndividualResultSuccess(nil) }
            let arg = DBXSharingAccessLevel(swift: swiftArg)
            return DBXSharingFileMemberActionIndividualResultSuccess(arg)
        case .memberError(let swiftArg):
            let arg = DBXSharingFileMemberActionError(swift: swiftArg)
            return DBXSharingFileMemberActionIndividualResultMemberError(arg)
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asSuccess: DBXSharingFileMemberActionIndividualResultSuccess? {
        self as? DBXSharingFileMemberActionIndividualResultSuccess
    }

    @objc
    public var asMemberError: DBXSharingFileMemberActionIndividualResultMemberError? {
        self as? DBXSharingFileMemberActionIndividualResultMemberError
    }
}

/// Part of the response for both add_file_member and remove_file_member_v1 (deprecated). For add_file_member,
/// indicates giving access was successful and at what AccessLevel. For remove_file_member_v1, indicates
/// member was successfully removed from the file. If AccessLevel is given, the member still has access
/// via a parent shared folder.
@objc
public class DBXSharingFileMemberActionIndividualResultSuccess: DBXSharingFileMemberActionIndividualResult {
    @objc
    public var success: DBXSharingAccessLevel?

    @objc
    public init(_ arg: DBXSharingAccessLevel?) {
        self.success = arg
        let swift = Sharing.FileMemberActionIndividualResult.success(arg?.swift)
        super.init(swift: swift)
    }
}

/// User was not able to perform this action.
@objc
public class DBXSharingFileMemberActionIndividualResultMemberError: DBXSharingFileMemberActionIndividualResult {
    @objc
    public var memberError: DBXSharingFileMemberActionError

    @objc
    public init(_ arg: DBXSharingFileMemberActionError) {
        self.memberError = arg
        let swift = Sharing.FileMemberActionIndividualResult.memberError(arg.swift)
        super.init(swift: swift)
    }
}

/// Per-member result for addFileMember.
@objc
public class DBXSharingFileMemberActionResult: NSObject {
    /// One of specified input members.
    @objc
    public var member: DBXSharingMemberSelector { DBXSharingMemberSelector(swift: swift.member) }
    /// The outcome of the action on this member.
    @objc
    public var result: DBXSharingFileMemberActionIndividualResult { DBXSharingFileMemberActionIndividualResult(swift: swift.result) }
    /// The SHA-1 encrypted shared content key.
    @objc
    public var sckeySha1: String? { swift.sckeySha1 }
    /// The sharing sender-recipient invitation signatures for the input member_id. A member_id can be a group and
    /// thus have multiple users and multiple invitation signatures.
    @objc
    public var invitationSignature: [String]? { swift.invitationSignature }

    @objc
    public init(member: DBXSharingMemberSelector, result: DBXSharingFileMemberActionIndividualResult, sckeySha1: String?, invitationSignature: [String]?) {
        self.swift = Sharing.FileMemberActionResult(member: member.swift, result: result.swift, sckeySha1: sckeySha1, invitationSignature: invitationSignature)
    }

    let swift: Sharing.FileMemberActionResult

    public init(swift: Sharing.FileMemberActionResult) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible FileMemberRemoveActionResult union
@objc
public class DBXSharingFileMemberRemoveActionResult: NSObject {
    let swift: Sharing.FileMemberRemoveActionResult

    public init(swift: Sharing.FileMemberRemoveActionResult) {
        self.swift = swift
    }

    public static func factory(swift: Sharing.FileMemberRemoveActionResult) -> DBXSharingFileMemberRemoveActionResult {
        switch swift {
        case .success(let swiftArg):
            let arg = DBXSharingMemberAccessLevelResult(swift: swiftArg)
            return DBXSharingFileMemberRemoveActionResultSuccess(arg)
        case .memberError(let swiftArg):
            let arg = DBXSharingFileMemberActionError(swift: swiftArg)
            return DBXSharingFileMemberRemoveActionResultMemberError(arg)
        case .other:
            return DBXSharingFileMemberRemoveActionResultOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asSuccess: DBXSharingFileMemberRemoveActionResultSuccess? {
        self as? DBXSharingFileMemberRemoveActionResultSuccess
    }

    @objc
    public var asMemberError: DBXSharingFileMemberRemoveActionResultMemberError? {
        self as? DBXSharingFileMemberRemoveActionResultMemberError
    }

    @objc
    public var asOther: DBXSharingFileMemberRemoveActionResultOther? {
        self as? DBXSharingFileMemberRemoveActionResultOther
    }
}

/// Member was successfully removed from this file.
@objc
public class DBXSharingFileMemberRemoveActionResultSuccess: DBXSharingFileMemberRemoveActionResult {
    @objc
    public var success: DBXSharingMemberAccessLevelResult

    @objc
    public init(_ arg: DBXSharingMemberAccessLevelResult) {
        self.success = arg
        let swift = Sharing.FileMemberRemoveActionResult.success(arg.swift)
        super.init(swift: swift)
    }
}

/// User was not able to remove this member.
@objc
public class DBXSharingFileMemberRemoveActionResultMemberError: DBXSharingFileMemberRemoveActionResult {
    @objc
    public var memberError: DBXSharingFileMemberActionError

    @objc
    public init(_ arg: DBXSharingFileMemberActionError) {
        self.memberError = arg
        let swift = Sharing.FileMemberRemoveActionResult.memberError(arg.swift)
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXSharingFileMemberRemoveActionResultOther: DBXSharingFileMemberRemoveActionResult {
    @objc
    public init() {
        let swift = Sharing.FileMemberRemoveActionResult.other
        super.init(swift: swift)
    }
}

/// Whether the user is allowed to take the sharing action on the file.
@objc
public class DBXSharingFilePermission: NSObject {
    /// The action that the user may wish to take on the file.
    @objc
    public var action: DBXSharingFileAction { DBXSharingFileAction(swift: swift.action) }
    /// True if the user is allowed to take the action.
    @objc
    public var allow: NSNumber { swift.allow as NSNumber }
    /// The reason why the user is denied the permission. Not present if the action is allowed.
    @objc
    public var reason: DBXSharingPermissionDeniedReason? { guard let swift = swift.reason else { return nil }
        return DBXSharingPermissionDeniedReason(swift: swift)
    }

    @objc
    public init(action: DBXSharingFileAction, allow: NSNumber, reason: DBXSharingPermissionDeniedReason?) {
        self.swift = Sharing.FilePermission(action: action.swift, allow: allow.boolValue, reason: reason?.swift)
    }

    let swift: Sharing.FilePermission

    public init(swift: Sharing.FilePermission) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Actions that may be taken on shared folders.
@objc
public class DBXSharingFolderAction: NSObject {
    let swift: Sharing.FolderAction

    public init(swift: Sharing.FolderAction) {
        self.swift = swift
    }

    public static func factory(swift: Sharing.FolderAction) -> DBXSharingFolderAction {
        switch swift {
        case .changeOptions:
            return DBXSharingFolderActionChangeOptions()
        case .disableViewerInfo:
            return DBXSharingFolderActionDisableViewerInfo()
        case .editContents:
            return DBXSharingFolderActionEditContents()
        case .enableViewerInfo:
            return DBXSharingFolderActionEnableViewerInfo()
        case .inviteEditor:
            return DBXSharingFolderActionInviteEditor()
        case .inviteViewer:
            return DBXSharingFolderActionInviteViewer()
        case .inviteViewerNoComment:
            return DBXSharingFolderActionInviteViewerNoComment()
        case .relinquishMembership:
            return DBXSharingFolderActionRelinquishMembership()
        case .unmount:
            return DBXSharingFolderActionUnmount()
        case .unshare:
            return DBXSharingFolderActionUnshare()
        case .leaveACopy:
            return DBXSharingFolderActionLeaveACopy()
        case .shareLink:
            return DBXSharingFolderActionShareLink()
        case .createLink:
            return DBXSharingFolderActionCreateLink()
        case .setAccessInheritance:
            return DBXSharingFolderActionSetAccessInheritance()
        case .other:
            return DBXSharingFolderActionOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asChangeOptions: DBXSharingFolderActionChangeOptions? {
        self as? DBXSharingFolderActionChangeOptions
    }

    @objc
    public var asDisableViewerInfo: DBXSharingFolderActionDisableViewerInfo? {
        self as? DBXSharingFolderActionDisableViewerInfo
    }

    @objc
    public var asEditContents: DBXSharingFolderActionEditContents? {
        self as? DBXSharingFolderActionEditContents
    }

    @objc
    public var asEnableViewerInfo: DBXSharingFolderActionEnableViewerInfo? {
        self as? DBXSharingFolderActionEnableViewerInfo
    }

    @objc
    public var asInviteEditor: DBXSharingFolderActionInviteEditor? {
        self as? DBXSharingFolderActionInviteEditor
    }

    @objc
    public var asInviteViewer: DBXSharingFolderActionInviteViewer? {
        self as? DBXSharingFolderActionInviteViewer
    }

    @objc
    public var asInviteViewerNoComment: DBXSharingFolderActionInviteViewerNoComment? {
        self as? DBXSharingFolderActionInviteViewerNoComment
    }

    @objc
    public var asRelinquishMembership: DBXSharingFolderActionRelinquishMembership? {
        self as? DBXSharingFolderActionRelinquishMembership
    }

    @objc
    public var asUnmount: DBXSharingFolderActionUnmount? {
        self as? DBXSharingFolderActionUnmount
    }

    @objc
    public var asUnshare: DBXSharingFolderActionUnshare? {
        self as? DBXSharingFolderActionUnshare
    }

    @objc
    public var asLeaveACopy: DBXSharingFolderActionLeaveACopy? {
        self as? DBXSharingFolderActionLeaveACopy
    }

    @objc
    public var asShareLink: DBXSharingFolderActionShareLink? {
        self as? DBXSharingFolderActionShareLink
    }

    @objc
    public var asCreateLink: DBXSharingFolderActionCreateLink? {
        self as? DBXSharingFolderActionCreateLink
    }

    @objc
    public var asSetAccessInheritance: DBXSharingFolderActionSetAccessInheritance? {
        self as? DBXSharingFolderActionSetAccessInheritance
    }

    @objc
    public var asOther: DBXSharingFolderActionOther? {
        self as? DBXSharingFolderActionOther
    }
}

/// Change folder options, such as who can be invited to join the folder.
@objc
public class DBXSharingFolderActionChangeOptions: DBXSharingFolderAction {
    @objc
    public init() {
        let swift = Sharing.FolderAction.changeOptions
        super.init(swift: swift)
    }
}

/// Disable viewer information for this folder.
@objc
public class DBXSharingFolderActionDisableViewerInfo: DBXSharingFolderAction {
    @objc
    public init() {
        let swift = Sharing.FolderAction.disableViewerInfo
        super.init(swift: swift)
    }
}

/// Change or edit contents of the folder.
@objc
public class DBXSharingFolderActionEditContents: DBXSharingFolderAction {
    @objc
    public init() {
        let swift = Sharing.FolderAction.editContents
        super.init(swift: swift)
    }
}

/// Enable viewer information on the folder.
@objc
public class DBXSharingFolderActionEnableViewerInfo: DBXSharingFolderAction {
    @objc
    public init() {
        let swift = Sharing.FolderAction.enableViewerInfo
        super.init(swift: swift)
    }
}

/// Invite a user or group to join the folder with read and write permission.
@objc
public class DBXSharingFolderActionInviteEditor: DBXSharingFolderAction {
    @objc
    public init() {
        let swift = Sharing.FolderAction.inviteEditor
        super.init(swift: swift)
    }
}

/// Invite a user or group to join the folder with read permission.
@objc
public class DBXSharingFolderActionInviteViewer: DBXSharingFolderAction {
    @objc
    public init() {
        let swift = Sharing.FolderAction.inviteViewer
        super.init(swift: swift)
    }
}

/// Invite a user or group to join the folder with read permission but no comment permissions.
@objc
public class DBXSharingFolderActionInviteViewerNoComment: DBXSharingFolderAction {
    @objc
    public init() {
        let swift = Sharing.FolderAction.inviteViewerNoComment
        super.init(swift: swift)
    }
}

/// Relinquish one's own membership in the folder.
@objc
public class DBXSharingFolderActionRelinquishMembership: DBXSharingFolderAction {
    @objc
    public init() {
        let swift = Sharing.FolderAction.relinquishMembership
        super.init(swift: swift)
    }
}

/// Unmount the folder.
@objc
public class DBXSharingFolderActionUnmount: DBXSharingFolderAction {
    @objc
    public init() {
        let swift = Sharing.FolderAction.unmount
        super.init(swift: swift)
    }
}

/// Stop sharing this folder.
@objc
public class DBXSharingFolderActionUnshare: DBXSharingFolderAction {
    @objc
    public init() {
        let swift = Sharing.FolderAction.unshare
        super.init(swift: swift)
    }
}

/// Keep a copy of the contents upon leaving or being kicked from the folder.
@objc
public class DBXSharingFolderActionLeaveACopy: DBXSharingFolderAction {
    @objc
    public init() {
        let swift = Sharing.FolderAction.leaveACopy
        super.init(swift: swift)
    }
}

/// Use create_link instead.
@objc
public class DBXSharingFolderActionShareLink: DBXSharingFolderAction {
    @objc
    public init() {
        let swift = Sharing.FolderAction.shareLink
        super.init(swift: swift)
    }
}

/// Create a shared link for folder.
@objc
public class DBXSharingFolderActionCreateLink: DBXSharingFolderAction {
    @objc
    public init() {
        let swift = Sharing.FolderAction.createLink
        super.init(swift: swift)
    }
}

/// Set whether the folder inherits permissions from its parent.
@objc
public class DBXSharingFolderActionSetAccessInheritance: DBXSharingFolderAction {
    @objc
    public init() {
        let swift = Sharing.FolderAction.setAccessInheritance
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXSharingFolderActionOther: DBXSharingFolderAction {
    @objc
    public init() {
        let swift = Sharing.FolderAction.other
        super.init(swift: swift)
    }
}

/// The metadata of a folder shared link.
@objc
public class DBXSharingFolderLinkMetadata: DBXSharingSharedLinkMetadata {
    let subSwift: Sharing.FolderLinkMetadata

    public init(swift: Sharing.FolderLinkMetadata) {
        self.subSwift = swift
        super.init(swift: swift)
    }

    @objc
    public override var description: String { subSwift.description }
}

/// Whether the user is allowed to take the action on the shared folder.
@objc
public class DBXSharingFolderPermission: NSObject {
    /// The action that the user may wish to take on the folder.
    @objc
    public var action: DBXSharingFolderAction { DBXSharingFolderAction(swift: swift.action) }
    /// True if the user is allowed to take the action.
    @objc
    public var allow: NSNumber { swift.allow as NSNumber }
    /// The reason why the user is denied the permission. Not present if the action is allowed, or if no reason is
    /// available.
    @objc
    public var reason: DBXSharingPermissionDeniedReason? { guard let swift = swift.reason else { return nil }
        return DBXSharingPermissionDeniedReason(swift: swift)
    }

    @objc
    public init(action: DBXSharingFolderAction, allow: NSNumber, reason: DBXSharingPermissionDeniedReason?) {
        self.swift = Sharing.FolderPermission(action: action.swift, allow: allow.boolValue, reason: reason?.swift)
    }

    let swift: Sharing.FolderPermission

    public init(swift: Sharing.FolderPermission) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// A set of policies governing membership and privileges for a shared folder.
@objc
public class DBXSharingFolderPolicy: NSObject {
    /// Who can be a member of this shared folder, as set on the folder itself. The effective policy may differ from
    /// this value if the team-wide policy is more restrictive. Present only if the folder is owned by a team.
    @objc
    public var memberPolicy: DBXSharingMemberPolicy? { guard let swift = swift.memberPolicy else { return nil }
        return DBXSharingMemberPolicy(swift: swift)
    }

    /// Who can be a member of this shared folder, taking into account both the folder and the team-wide policy.
    /// This value may differ from that of member_policy if the team-wide policy is more restrictive than the
    /// folder policy. Present only if the folder is owned by a team.
    @objc
    public var resolvedMemberPolicy: DBXSharingMemberPolicy? { guard let swift = swift.resolvedMemberPolicy else { return nil }
        return DBXSharingMemberPolicy(swift: swift)
    }

    /// Who can add and remove members from this shared folder.
    @objc
    public var aclUpdatePolicy: DBXSharingAclUpdatePolicy { DBXSharingAclUpdatePolicy(swift: swift.aclUpdatePolicy) }
    /// Who links can be shared with.
    @objc
    public var sharedLinkPolicy: DBXSharingSharedLinkPolicy { DBXSharingSharedLinkPolicy(swift: swift.sharedLinkPolicy) }
    /// Who can enable/disable viewer info for this shared folder.
    @objc
    public var viewerInfoPolicy: DBXSharingViewerInfoPolicy? { guard let swift = swift.viewerInfoPolicy else { return nil }
        return DBXSharingViewerInfoPolicy(swift: swift)
    }

    @objc
    public init(
        aclUpdatePolicy: DBXSharingAclUpdatePolicy,
        sharedLinkPolicy: DBXSharingSharedLinkPolicy,
        memberPolicy: DBXSharingMemberPolicy?,
        resolvedMemberPolicy: DBXSharingMemberPolicy?,
        viewerInfoPolicy: DBXSharingViewerInfoPolicy?
    ) {
        self.swift = Sharing.FolderPolicy(
            aclUpdatePolicy: aclUpdatePolicy.swift,
            sharedLinkPolicy: sharedLinkPolicy.swift,
            memberPolicy: memberPolicy?.swift,
            resolvedMemberPolicy: resolvedMemberPolicy?.swift,
            viewerInfoPolicy: viewerInfoPolicy?.swift
        )
    }

    let swift: Sharing.FolderPolicy

    public init(swift: Sharing.FolderPolicy) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Arguments of getFileMetadata.
@objc
public class DBXSharingGetFileMetadataArg: NSObject {
    /// The file to query.
    @objc
    public var file: String { swift.file }
    /// A list of `FileAction`s corresponding to `FilePermission`s that should appear in the  response's permissions
    /// in SharedFileMetadata field describing the actions the  authenticated user can perform on the file.
    @objc
    public var actions: [DBXSharingFileAction]? { swift.actions?.map { DBXSharingFileAction(swift: $0) } }

    @objc
    public init(file: String, actions: [DBXSharingFileAction]?) {
        self.swift = Sharing.GetFileMetadataArg(file: file, actions: actions?.map(\.swift))
    }

    let swift: Sharing.GetFileMetadataArg

    public init(swift: Sharing.GetFileMetadataArg) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Arguments of getFileMetadataBatch.
@objc
public class DBXSharingGetFileMetadataBatchArg: NSObject {
    /// The files to query.
    @objc
    public var files: [String] { swift.files }
    /// A list of `FileAction`s corresponding to `FilePermission`s that should appear in the  response's permissions
    /// in SharedFileMetadata field describing the actions the  authenticated user can perform on the file.
    @objc
    public var actions: [DBXSharingFileAction]? { swift.actions?.map { DBXSharingFileAction(swift: $0) } }

    @objc
    public init(files: [String], actions: [DBXSharingFileAction]?) {
        self.swift = Sharing.GetFileMetadataBatchArg(files: files, actions: actions?.map(\.swift))
    }

    let swift: Sharing.GetFileMetadataBatchArg

    public init(swift: Sharing.GetFileMetadataBatchArg) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Per file results of getFileMetadataBatch.
@objc
public class DBXSharingGetFileMetadataBatchResult: NSObject {
    /// This is the input file identifier corresponding to one of files in GetFileMetadataBatchArg.
    @objc
    public var file: String { swift.file }
    /// The result for this particular file.
    @objc
    public var result: DBXSharingGetFileMetadataIndividualResult { DBXSharingGetFileMetadataIndividualResult(swift: swift.result) }

    @objc
    public init(file: String, result: DBXSharingGetFileMetadataIndividualResult) {
        self.swift = Sharing.GetFileMetadataBatchResult(file: file, result: result.swift)
    }

    let swift: Sharing.GetFileMetadataBatchResult

    public init(swift: Sharing.GetFileMetadataBatchResult) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Error result for getFileMetadata.
@objc
public class DBXSharingGetFileMetadataError: NSObject {
    let swift: Sharing.GetFileMetadataError

    public init(swift: Sharing.GetFileMetadataError) {
        self.swift = swift
    }

    public static func factory(swift: Sharing.GetFileMetadataError) -> DBXSharingGetFileMetadataError {
        switch swift {
        case .userError(let swiftArg):
            let arg = DBXSharingSharingUserError(swift: swiftArg)
            return DBXSharingGetFileMetadataErrorUserError(arg)
        case .accessError(let swiftArg):
            let arg = DBXSharingSharingFileAccessError(swift: swiftArg)
            return DBXSharingGetFileMetadataErrorAccessError(arg)
        case .other:
            return DBXSharingGetFileMetadataErrorOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asUserError: DBXSharingGetFileMetadataErrorUserError? {
        self as? DBXSharingGetFileMetadataErrorUserError
    }

    @objc
    public var asAccessError: DBXSharingGetFileMetadataErrorAccessError? {
        self as? DBXSharingGetFileMetadataErrorAccessError
    }

    @objc
    public var asOther: DBXSharingGetFileMetadataErrorOther? {
        self as? DBXSharingGetFileMetadataErrorOther
    }
}

/// An unspecified error.
@objc
public class DBXSharingGetFileMetadataErrorUserError: DBXSharingGetFileMetadataError {
    @objc
    public var userError: DBXSharingSharingUserError

    @objc
    public init(_ arg: DBXSharingSharingUserError) {
        self.userError = arg
        let swift = Sharing.GetFileMetadataError.userError(arg.swift)
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXSharingGetFileMetadataErrorAccessError: DBXSharingGetFileMetadataError {
    @objc
    public var accessError: DBXSharingSharingFileAccessError

    @objc
    public init(_ arg: DBXSharingSharingFileAccessError) {
        self.accessError = arg
        let swift = Sharing.GetFileMetadataError.accessError(arg.swift)
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXSharingGetFileMetadataErrorOther: DBXSharingGetFileMetadataError {
    @objc
    public init() {
        let swift = Sharing.GetFileMetadataError.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible GetFileMetadataIndividualResult union
@objc
public class DBXSharingGetFileMetadataIndividualResult: NSObject {
    let swift: Sharing.GetFileMetadataIndividualResult

    public init(swift: Sharing.GetFileMetadataIndividualResult) {
        self.swift = swift
    }

    public static func factory(swift: Sharing.GetFileMetadataIndividualResult) -> DBXSharingGetFileMetadataIndividualResult {
        switch swift {
        case .metadata(let swiftArg):
            let arg = DBXSharingSharedFileMetadata(swift: swiftArg)
            return DBXSharingGetFileMetadataIndividualResultMetadata(arg)
        case .accessError(let swiftArg):
            let arg = DBXSharingSharingFileAccessError(swift: swiftArg)
            return DBXSharingGetFileMetadataIndividualResultAccessError(arg)
        case .other:
            return DBXSharingGetFileMetadataIndividualResultOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asMetadata: DBXSharingGetFileMetadataIndividualResultMetadata? {
        self as? DBXSharingGetFileMetadataIndividualResultMetadata
    }

    @objc
    public var asAccessError: DBXSharingGetFileMetadataIndividualResultAccessError? {
        self as? DBXSharingGetFileMetadataIndividualResultAccessError
    }

    @objc
    public var asOther: DBXSharingGetFileMetadataIndividualResultOther? {
        self as? DBXSharingGetFileMetadataIndividualResultOther
    }
}

/// The result for this file if it was successful.
@objc
public class DBXSharingGetFileMetadataIndividualResultMetadata: DBXSharingGetFileMetadataIndividualResult {
    @objc
    public var metadata: DBXSharingSharedFileMetadata

    @objc
    public init(_ arg: DBXSharingSharedFileMetadata) {
        self.metadata = arg
        let swift = Sharing.GetFileMetadataIndividualResult.metadata(arg.swift)
        super.init(swift: swift)
    }
}

/// The result for this file if it was an error.
@objc
public class DBXSharingGetFileMetadataIndividualResultAccessError: DBXSharingGetFileMetadataIndividualResult {
    @objc
    public var accessError: DBXSharingSharingFileAccessError

    @objc
    public init(_ arg: DBXSharingSharingFileAccessError) {
        self.accessError = arg
        let swift = Sharing.GetFileMetadataIndividualResult.accessError(arg.swift)
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXSharingGetFileMetadataIndividualResultOther: DBXSharingGetFileMetadataIndividualResult {
    @objc
    public init() {
        let swift = Sharing.GetFileMetadataIndividualResult.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible GetMetadataArgs struct
@objc
public class DBXSharingGetMetadataArgs: NSObject {
    /// The ID for the shared folder.
    @objc
    public var sharedFolderId: String { swift.sharedFolderId }
    /// A list of `FolderAction`s corresponding to `FolderPermission`s that should appear in the  response's
    /// permissions in SharedFolderMetadata field describing the actions the  authenticated user can perform on
    /// the folder.
    @objc
    public var actions: [DBXSharingFolderAction]? { swift.actions?.map { DBXSharingFolderAction(swift: $0) } }

    @objc
    public init(sharedFolderId: String, actions: [DBXSharingFolderAction]?) {
        self.swift = Sharing.GetMetadataArgs(sharedFolderId: sharedFolderId, actions: actions?.map(\.swift))
    }

    let swift: Sharing.GetMetadataArgs

    public init(swift: Sharing.GetMetadataArgs) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible SharedLinkError union
@objc
public class DBXSharingSharedLinkError: NSObject {
    let swift: Sharing.SharedLinkError

    public init(swift: Sharing.SharedLinkError) {
        self.swift = swift
    }

    public static func factory(swift: Sharing.SharedLinkError) -> DBXSharingSharedLinkError {
        switch swift {
        case .sharedLinkNotFound:
            return DBXSharingSharedLinkErrorSharedLinkNotFound()
        case .sharedLinkAccessDenied:
            return DBXSharingSharedLinkErrorSharedLinkAccessDenied()
        case .unsupportedLinkType:
            return DBXSharingSharedLinkErrorUnsupportedLinkType()
        case .other:
            return DBXSharingSharedLinkErrorOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asSharedLinkNotFound: DBXSharingSharedLinkErrorSharedLinkNotFound? {
        self as? DBXSharingSharedLinkErrorSharedLinkNotFound
    }

    @objc
    public var asSharedLinkAccessDenied: DBXSharingSharedLinkErrorSharedLinkAccessDenied? {
        self as? DBXSharingSharedLinkErrorSharedLinkAccessDenied
    }

    @objc
    public var asUnsupportedLinkType: DBXSharingSharedLinkErrorUnsupportedLinkType? {
        self as? DBXSharingSharedLinkErrorUnsupportedLinkType
    }

    @objc
    public var asOther: DBXSharingSharedLinkErrorOther? {
        self as? DBXSharingSharedLinkErrorOther
    }
}

/// The shared link wasn't found.
@objc
public class DBXSharingSharedLinkErrorSharedLinkNotFound: DBXSharingSharedLinkError {
    @objc
    public init() {
        let swift = Sharing.SharedLinkError.sharedLinkNotFound
        super.init(swift: swift)
    }
}

/// The caller is not allowed to access this shared link.
@objc
public class DBXSharingSharedLinkErrorSharedLinkAccessDenied: DBXSharingSharedLinkError {
    @objc
    public init() {
        let swift = Sharing.SharedLinkError.sharedLinkAccessDenied
        super.init(swift: swift)
    }
}

/// This type of link is not supported; use files instead.
@objc
public class DBXSharingSharedLinkErrorUnsupportedLinkType: DBXSharingSharedLinkError {
    @objc
    public init() {
        let swift = Sharing.SharedLinkError.unsupportedLinkType
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXSharingSharedLinkErrorOther: DBXSharingSharedLinkError {
    @objc
    public init() {
        let swift = Sharing.SharedLinkError.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible GetSharedLinkFileError union
@objc
public class DBXSharingGetSharedLinkFileError: NSObject {
    let swift: Sharing.GetSharedLinkFileError

    public init(swift: Sharing.GetSharedLinkFileError) {
        self.swift = swift
    }

    public static func factory(swift: Sharing.GetSharedLinkFileError) -> DBXSharingGetSharedLinkFileError {
        switch swift {
        case .sharedLinkNotFound:
            return DBXSharingGetSharedLinkFileErrorSharedLinkNotFound()
        case .sharedLinkAccessDenied:
            return DBXSharingGetSharedLinkFileErrorSharedLinkAccessDenied()
        case .unsupportedLinkType:
            return DBXSharingGetSharedLinkFileErrorUnsupportedLinkType()
        case .other:
            return DBXSharingGetSharedLinkFileErrorOther()
        case .sharedLinkIsDirectory:
            return DBXSharingGetSharedLinkFileErrorSharedLinkIsDirectory()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asSharedLinkNotFound: DBXSharingGetSharedLinkFileErrorSharedLinkNotFound? {
        self as? DBXSharingGetSharedLinkFileErrorSharedLinkNotFound
    }

    @objc
    public var asSharedLinkAccessDenied: DBXSharingGetSharedLinkFileErrorSharedLinkAccessDenied? {
        self as? DBXSharingGetSharedLinkFileErrorSharedLinkAccessDenied
    }

    @objc
    public var asUnsupportedLinkType: DBXSharingGetSharedLinkFileErrorUnsupportedLinkType? {
        self as? DBXSharingGetSharedLinkFileErrorUnsupportedLinkType
    }

    @objc
    public var asOther: DBXSharingGetSharedLinkFileErrorOther? {
        self as? DBXSharingGetSharedLinkFileErrorOther
    }

    @objc
    public var asSharedLinkIsDirectory: DBXSharingGetSharedLinkFileErrorSharedLinkIsDirectory? {
        self as? DBXSharingGetSharedLinkFileErrorSharedLinkIsDirectory
    }
}

/// The shared link wasn't found.
@objc
public class DBXSharingGetSharedLinkFileErrorSharedLinkNotFound: DBXSharingGetSharedLinkFileError {
    @objc
    public init() {
        let swift = Sharing.GetSharedLinkFileError.sharedLinkNotFound
        super.init(swift: swift)
    }
}

/// The caller is not allowed to access this shared link.
@objc
public class DBXSharingGetSharedLinkFileErrorSharedLinkAccessDenied: DBXSharingGetSharedLinkFileError {
    @objc
    public init() {
        let swift = Sharing.GetSharedLinkFileError.sharedLinkAccessDenied
        super.init(swift: swift)
    }
}

/// This type of link is not supported; use files instead.
@objc
public class DBXSharingGetSharedLinkFileErrorUnsupportedLinkType: DBXSharingGetSharedLinkFileError {
    @objc
    public init() {
        let swift = Sharing.GetSharedLinkFileError.unsupportedLinkType
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXSharingGetSharedLinkFileErrorOther: DBXSharingGetSharedLinkFileError {
    @objc
    public init() {
        let swift = Sharing.GetSharedLinkFileError.other
        super.init(swift: swift)
    }
}

/// Directories cannot be retrieved by this endpoint.
@objc
public class DBXSharingGetSharedLinkFileErrorSharedLinkIsDirectory: DBXSharingGetSharedLinkFileError {
    @objc
    public init() {
        let swift = Sharing.GetSharedLinkFileError.sharedLinkIsDirectory
        super.init(swift: swift)
    }
}

/// Objective-C compatible GetSharedLinkMetadataArg struct
@objc
public class DBXSharingGetSharedLinkMetadataArg: NSObject {
    /// URL of the shared link.
    @objc
    public var url: String { swift.url }
    /// If the shared link is to a folder, this parameter can be used to retrieve the metadata for a specific file
    /// or sub-folder in this folder. A relative path should be used.
    @objc
    public var path: String? { swift.path }
    /// If the shared link has a password, this parameter can be used.
    @objc
    public var linkPassword: String? { swift.linkPassword }

    @objc
    public init(url: String, path: String?, linkPassword: String?) {
        self.swift = Sharing.GetSharedLinkMetadataArg(url: url, path: path, linkPassword: linkPassword)
    }

    let swift: Sharing.GetSharedLinkMetadataArg

    public init(swift: Sharing.GetSharedLinkMetadataArg) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible GetSharedLinksArg struct
@objc
public class DBXSharingGetSharedLinksArg: NSObject {
    /// See getSharedLinks description.
    @objc
    public var path: String? { swift.path }

    @objc
    public init(path: String?) {
        self.swift = Sharing.GetSharedLinksArg(path: path)
    }

    let swift: Sharing.GetSharedLinksArg

    public init(swift: Sharing.GetSharedLinksArg) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible GetSharedLinksError union
@objc
public class DBXSharingGetSharedLinksError: NSObject {
    let swift: Sharing.GetSharedLinksError

    public init(swift: Sharing.GetSharedLinksError) {
        self.swift = swift
    }

    public static func factory(swift: Sharing.GetSharedLinksError) -> DBXSharingGetSharedLinksError {
        switch swift {
        case .path(let swiftArg):
            let arg = swiftArg
            return DBXSharingGetSharedLinksErrorPath(arg)
        case .other:
            return DBXSharingGetSharedLinksErrorOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asPath: DBXSharingGetSharedLinksErrorPath? {
        self as? DBXSharingGetSharedLinksErrorPath
    }

    @objc
    public var asOther: DBXSharingGetSharedLinksErrorOther? {
        self as? DBXSharingGetSharedLinksErrorOther
    }
}

/// An unspecified error.
@objc
public class DBXSharingGetSharedLinksErrorPath: DBXSharingGetSharedLinksError {
    @objc
    public var path: String?

    @objc
    public init(_ arg: String?) {
        self.path = arg
        let swift = Sharing.GetSharedLinksError.path(arg)
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXSharingGetSharedLinksErrorOther: DBXSharingGetSharedLinksError {
    @objc
    public init() {
        let swift = Sharing.GetSharedLinksError.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible GetSharedLinksResult struct
@objc
public class DBXSharingGetSharedLinksResult: NSObject {
    /// Shared links applicable to the path argument.
    @objc
    public var links: [DBXSharingLinkMetadata] {
        swift.links.map {
            DBXSharingLinkMetadata.wrapPreservingSubtypes(swift: $0)
        }
    }

    @objc
    public init(links: [DBXSharingLinkMetadata]) {
        self.swift = Sharing.GetSharedLinksResult(links: links.map(\.swift))
    }

    let swift: Sharing.GetSharedLinksResult

    public init(swift: Sharing.GetSharedLinksResult) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// The information about a group. Groups is a way to manage a list of users  who need same access permission to the
/// shared folder.
@objc
public class DBXSharingGroupInfo: DBXTeamCommonGroupSummary {
    /// The type of group.
    @objc
    public var groupType: DBXTeamCommonGroupType { DBXTeamCommonGroupType(swift: subSwift.groupType) }
    /// If the current user is a member of the group.
    @objc
    public var isMember: NSNumber { subSwift.isMember as NSNumber }
    /// If the current user is an owner of the group.
    @objc
    public var isOwner: NSNumber { subSwift.isOwner as NSNumber }
    /// If the group is owned by the current user's team.
    @objc
    public var sameTeam: NSNumber { subSwift.sameTeam as NSNumber }

    @objc
    public init(
        groupName: String,
        groupId: String,
        groupManagementType: DBXTeamCommonGroupManagementType,
        groupType: DBXTeamCommonGroupType,
        isMember: NSNumber,
        isOwner: NSNumber,
        sameTeam: NSNumber,
        groupExternalId: String?,
        memberCount: NSNumber?
    ) {
        let swift = Sharing.GroupInfo(
            groupName: groupName,
            groupId: groupId,
            groupManagementType: groupManagementType.swift,
            groupType: groupType.swift,
            isMember: isMember.boolValue,
            isOwner: isOwner.boolValue,
            sameTeam: sameTeam.boolValue,
            groupExternalId: groupExternalId,
            memberCount: memberCount?.uint32Value
        )
        self.subSwift = swift
        super.init(swift: swift)
    }

    let subSwift: Sharing.GroupInfo

    public init(swift: Sharing.GroupInfo) {
        self.subSwift = swift
        super.init(swift: swift)
    }

    @objc
    public override var description: String { subSwift.description }
}

/// The information about a member of the shared content.
@objc
public class DBXSharingMembershipInfo: NSObject {
    /// The access type for this member. It contains inherited access type from parent folder, and acquired access
    /// type from this folder.
    @objc
    public var accessType: DBXSharingAccessLevel { DBXSharingAccessLevel(swift: swift.accessType) }
    /// The permissions that requesting user has on this member. The set of permissions corresponds to the
    /// MemberActions in the request.
    @objc
    public var permissions: [DBXSharingMemberPermission]? { swift.permissions?.map { DBXSharingMemberPermission(swift: $0) } }
    /// Never set.
    @objc
    public var initials: String? { swift.initials }
    /// True if the member has access from a parent folder.
    @objc
    public var isInherited: NSNumber { swift.isInherited as NSNumber }

    @objc
    public init(accessType: DBXSharingAccessLevel, permissions: [DBXSharingMemberPermission]?, initials: String?, isInherited: NSNumber) {
        self.swift = Sharing.MembershipInfo(
            accessType: accessType.swift,
            permissions: permissions?.map(\.swift),
            initials: initials,
            isInherited: isInherited.boolValue
        )
    }

    let swift: Sharing.MembershipInfo

    public init(swift: Sharing.MembershipInfo) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// The information about a group member of the shared content.
@objc
public class DBXSharingGroupMembershipInfo: DBXSharingMembershipInfo {
    /// The information about the membership group.
    @objc
    public var group: DBXSharingGroupInfo { DBXSharingGroupInfo(swift: subSwift.group) }

    @objc
    public init(
        accessType: DBXSharingAccessLevel,
        group: DBXSharingGroupInfo,
        permissions: [DBXSharingMemberPermission]?,
        initials: String?,
        isInherited: NSNumber
    ) {
        let swift = Sharing.GroupMembershipInfo(
            accessType: accessType.swift,
            group: group.subSwift,
            permissions: permissions?.map(\.swift),
            initials: initials,
            isInherited: isInherited.boolValue
        )
        self.subSwift = swift
        super.init(swift: swift)
    }

    let subSwift: Sharing.GroupMembershipInfo

    public init(swift: Sharing.GroupMembershipInfo) {
        self.subSwift = swift
        super.init(swift: swift)
    }

    @objc
    public override var description: String { subSwift.description }
}

/// Objective-C compatible InsufficientPlan struct
@objc
public class DBXSharingInsufficientPlan: NSObject {
    /// A message to tell the user to upgrade in order to support expected action.
    @objc
    public var message: String { swift.message }
    /// A URL to send the user to in order to obtain the account type they need, e.g. upgrading. Absent if there is
    /// no action the user can take to upgrade.
    @objc
    public var upsellUrl: String? { swift.upsellUrl }

    @objc
    public init(message: String, upsellUrl: String?) {
        self.swift = Sharing.InsufficientPlan(message: message, upsellUrl: upsellUrl)
    }

    let swift: Sharing.InsufficientPlan

    public init(swift: Sharing.InsufficientPlan) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible InsufficientQuotaAmounts struct
@objc
public class DBXSharingInsufficientQuotaAmounts: NSObject {
    /// The amount of space needed to add the item (the size of the item).
    @objc
    public var spaceNeeded: NSNumber { swift.spaceNeeded as NSNumber }
    /// The amount of extra space needed to add the item.
    @objc
    public var spaceShortage: NSNumber { swift.spaceShortage as NSNumber }
    /// The amount of space left in the user's Dropbox, less than space_needed.
    @objc
    public var spaceLeft: NSNumber { swift.spaceLeft as NSNumber }

    @objc
    public init(spaceNeeded: NSNumber, spaceShortage: NSNumber, spaceLeft: NSNumber) {
        self.swift = Sharing.InsufficientQuotaAmounts(
            spaceNeeded: spaceNeeded.uint64Value,
            spaceShortage: spaceShortage.uint64Value,
            spaceLeft: spaceLeft.uint64Value
        )
    }

    let swift: Sharing.InsufficientQuotaAmounts

    public init(swift: Sharing.InsufficientQuotaAmounts) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Information about the recipient of a shared content invitation.
@objc
public class DBXSharingInviteeInfo: NSObject {
    let swift: Sharing.InviteeInfo

    public init(swift: Sharing.InviteeInfo) {
        self.swift = swift
    }

    public static func factory(swift: Sharing.InviteeInfo) -> DBXSharingInviteeInfo {
        switch swift {
        case .email(let swiftArg):
            let arg = swiftArg
            return DBXSharingInviteeInfoEmail(arg)
        case .other:
            return DBXSharingInviteeInfoOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asEmail: DBXSharingInviteeInfoEmail? {
        self as? DBXSharingInviteeInfoEmail
    }

    @objc
    public var asOther: DBXSharingInviteeInfoOther? {
        self as? DBXSharingInviteeInfoOther
    }
}

/// Email address of invited user.
@objc
public class DBXSharingInviteeInfoEmail: DBXSharingInviteeInfo {
    @objc
    public var email: String

    @objc
    public init(_ arg: String) {
        self.email = arg
        let swift = Sharing.InviteeInfo.email(arg)
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXSharingInviteeInfoOther: DBXSharingInviteeInfo {
    @objc
    public init() {
        let swift = Sharing.InviteeInfo.other
        super.init(swift: swift)
    }
}

/// Information about an invited member of a shared content.
@objc
public class DBXSharingInviteeMembershipInfo: DBXSharingMembershipInfo {
    /// Recipient of the invitation.
    @objc
    public var invitee: DBXSharingInviteeInfo { DBXSharingInviteeInfo(swift: subSwift.invitee) }
    /// The user this invitation is tied to, if available.
    @objc
    public var user: DBXSharingUserInfo? { guard let swift = subSwift.user else { return nil }
        return DBXSharingUserInfo(swift: swift)
    }

    @objc
    public init(
        accessType: DBXSharingAccessLevel,
        invitee: DBXSharingInviteeInfo,
        permissions: [DBXSharingMemberPermission]?,
        initials: String?,
        isInherited: NSNumber,
        user: DBXSharingUserInfo?
    ) {
        let swift = Sharing.InviteeMembershipInfo(
            accessType: accessType.swift,
            invitee: invitee.swift,
            permissions: permissions?.map(\.swift),
            initials: initials,
            isInherited: isInherited.boolValue,
            user: user?.swift
        )
        self.subSwift = swift
        super.init(swift: swift)
    }

    let subSwift: Sharing.InviteeMembershipInfo

    public init(swift: Sharing.InviteeMembershipInfo) {
        self.subSwift = swift
        super.init(swift: swift)
    }

    @objc
    public override var description: String { subSwift.description }
}

/// Error occurred while performing an asynchronous job from unshareFolder or removeFolderMember.
@objc
public class DBXSharingJobError: NSObject {
    let swift: Sharing.JobError

    public init(swift: Sharing.JobError) {
        self.swift = swift
    }

    public static func factory(swift: Sharing.JobError) -> DBXSharingJobError {
        switch swift {
        case .unshareFolderError(let swiftArg):
            let arg = DBXSharingUnshareFolderError(swift: swiftArg)
            return DBXSharingJobErrorUnshareFolderError(arg)
        case .removeFolderMemberError(let swiftArg):
            let arg = DBXSharingRemoveFolderMemberError(swift: swiftArg)
            return DBXSharingJobErrorRemoveFolderMemberError(arg)
        case .relinquishFolderMembershipError(let swiftArg):
            let arg = DBXSharingRelinquishFolderMembershipError(swift: swiftArg)
            return DBXSharingJobErrorRelinquishFolderMembershipError(arg)
        case .other:
            return DBXSharingJobErrorOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asUnshareFolderError: DBXSharingJobErrorUnshareFolderError? {
        self as? DBXSharingJobErrorUnshareFolderError
    }

    @objc
    public var asRemoveFolderMemberError: DBXSharingJobErrorRemoveFolderMemberError? {
        self as? DBXSharingJobErrorRemoveFolderMemberError
    }

    @objc
    public var asRelinquishFolderMembershipError: DBXSharingJobErrorRelinquishFolderMembershipError? {
        self as? DBXSharingJobErrorRelinquishFolderMembershipError
    }

    @objc
    public var asOther: DBXSharingJobErrorOther? {
        self as? DBXSharingJobErrorOther
    }
}

/// Error occurred while performing unshareFolder action.
@objc
public class DBXSharingJobErrorUnshareFolderError: DBXSharingJobError {
    @objc
    public var unshareFolderError: DBXSharingUnshareFolderError

    @objc
    public init(_ arg: DBXSharingUnshareFolderError) {
        self.unshareFolderError = arg
        let swift = Sharing.JobError.unshareFolderError(arg.swift)
        super.init(swift: swift)
    }
}

/// Error occurred while performing removeFolderMember action.
@objc
public class DBXSharingJobErrorRemoveFolderMemberError: DBXSharingJobError {
    @objc
    public var removeFolderMemberError: DBXSharingRemoveFolderMemberError

    @objc
    public init(_ arg: DBXSharingRemoveFolderMemberError) {
        self.removeFolderMemberError = arg
        let swift = Sharing.JobError.removeFolderMemberError(arg.swift)
        super.init(swift: swift)
    }
}

/// Error occurred while performing relinquishFolderMembership action.
@objc
public class DBXSharingJobErrorRelinquishFolderMembershipError: DBXSharingJobError {
    @objc
    public var relinquishFolderMembershipError: DBXSharingRelinquishFolderMembershipError

    @objc
    public init(_ arg: DBXSharingRelinquishFolderMembershipError) {
        self.relinquishFolderMembershipError = arg
        let swift = Sharing.JobError.relinquishFolderMembershipError(arg.swift)
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXSharingJobErrorOther: DBXSharingJobError {
    @objc
    public init() {
        let swift = Sharing.JobError.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible JobStatus union
@objc
public class DBXSharingJobStatus: NSObject {
    let swift: Sharing.JobStatus

    public init(swift: Sharing.JobStatus) {
        self.swift = swift
    }

    public static func factory(swift: Sharing.JobStatus) -> DBXSharingJobStatus {
        switch swift {
        case .inProgress:
            return DBXSharingJobStatusInProgress()
        case .complete:
            return DBXSharingJobStatusComplete()
        case .failed(let swiftArg):
            let arg = DBXSharingJobError(swift: swiftArg)
            return DBXSharingJobStatusFailed(arg)
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asInProgress: DBXSharingJobStatusInProgress? {
        self as? DBXSharingJobStatusInProgress
    }

    @objc
    public var asComplete: DBXSharingJobStatusComplete? {
        self as? DBXSharingJobStatusComplete
    }

    @objc
    public var asFailed: DBXSharingJobStatusFailed? {
        self as? DBXSharingJobStatusFailed
    }
}

/// The asynchronous job is still in progress.
@objc
public class DBXSharingJobStatusInProgress: DBXSharingJobStatus {
    @objc
    public init() {
        let swift = Sharing.JobStatus.inProgress
        super.init(swift: swift)
    }
}

/// The asynchronous job has finished.
@objc
public class DBXSharingJobStatusComplete: DBXSharingJobStatus {
    @objc
    public init() {
        let swift = Sharing.JobStatus.complete
        super.init(swift: swift)
    }
}

/// The asynchronous job returned an error.
@objc
public class DBXSharingJobStatusFailed: DBXSharingJobStatus {
    @objc
    public var failed: DBXSharingJobError

    @objc
    public init(_ arg: DBXSharingJobError) {
        self.failed = arg
        let swift = Sharing.JobStatus.failed(arg.swift)
        super.init(swift: swift)
    }
}

/// Objective-C compatible LinkAccessLevel union
@objc
public class DBXSharingLinkAccessLevel: NSObject {
    let swift: Sharing.LinkAccessLevel

    public init(swift: Sharing.LinkAccessLevel) {
        self.swift = swift
    }

    public static func factory(swift: Sharing.LinkAccessLevel) -> DBXSharingLinkAccessLevel {
        switch swift {
        case .viewer:
            return DBXSharingLinkAccessLevelViewer()
        case .editor:
            return DBXSharingLinkAccessLevelEditor()
        case .other:
            return DBXSharingLinkAccessLevelOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asViewer: DBXSharingLinkAccessLevelViewer? {
        self as? DBXSharingLinkAccessLevelViewer
    }

    @objc
    public var asEditor: DBXSharingLinkAccessLevelEditor? {
        self as? DBXSharingLinkAccessLevelEditor
    }

    @objc
    public var asOther: DBXSharingLinkAccessLevelOther? {
        self as? DBXSharingLinkAccessLevelOther
    }
}

/// Users who use the link can view and comment on the content.
@objc
public class DBXSharingLinkAccessLevelViewer: DBXSharingLinkAccessLevel {
    @objc
    public init() {
        let swift = Sharing.LinkAccessLevel.viewer
        super.init(swift: swift)
    }
}

/// Users who use the link can edit, view and comment on the content.
@objc
public class DBXSharingLinkAccessLevelEditor: DBXSharingLinkAccessLevel {
    @objc
    public init() {
        let swift = Sharing.LinkAccessLevel.editor
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXSharingLinkAccessLevelOther: DBXSharingLinkAccessLevel {
    @objc
    public init() {
        let swift = Sharing.LinkAccessLevel.other
        super.init(swift: swift)
    }
}

/// Actions that can be performed on a link.
@objc
public class DBXSharingLinkAction: NSObject {
    let swift: Sharing.LinkAction

    public init(swift: Sharing.LinkAction) {
        self.swift = swift
    }

    public static func factory(swift: Sharing.LinkAction) -> DBXSharingLinkAction {
        switch swift {
        case .changeAccessLevel:
            return DBXSharingLinkActionChangeAccessLevel()
        case .changeAudience:
            return DBXSharingLinkActionChangeAudience()
        case .removeExpiry:
            return DBXSharingLinkActionRemoveExpiry()
        case .removePassword:
            return DBXSharingLinkActionRemovePassword()
        case .setExpiry:
            return DBXSharingLinkActionSetExpiry()
        case .setPassword:
            return DBXSharingLinkActionSetPassword()
        case .other:
            return DBXSharingLinkActionOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asChangeAccessLevel: DBXSharingLinkActionChangeAccessLevel? {
        self as? DBXSharingLinkActionChangeAccessLevel
    }

    @objc
    public var asChangeAudience: DBXSharingLinkActionChangeAudience? {
        self as? DBXSharingLinkActionChangeAudience
    }

    @objc
    public var asRemoveExpiry: DBXSharingLinkActionRemoveExpiry? {
        self as? DBXSharingLinkActionRemoveExpiry
    }

    @objc
    public var asRemovePassword: DBXSharingLinkActionRemovePassword? {
        self as? DBXSharingLinkActionRemovePassword
    }

    @objc
    public var asSetExpiry: DBXSharingLinkActionSetExpiry? {
        self as? DBXSharingLinkActionSetExpiry
    }

    @objc
    public var asSetPassword: DBXSharingLinkActionSetPassword? {
        self as? DBXSharingLinkActionSetPassword
    }

    @objc
    public var asOther: DBXSharingLinkActionOther? {
        self as? DBXSharingLinkActionOther
    }
}

/// Change the access level of the link.
@objc
public class DBXSharingLinkActionChangeAccessLevel: DBXSharingLinkAction {
    @objc
    public init() {
        let swift = Sharing.LinkAction.changeAccessLevel
        super.init(swift: swift)
    }
}

/// Change the audience of the link.
@objc
public class DBXSharingLinkActionChangeAudience: DBXSharingLinkAction {
    @objc
    public init() {
        let swift = Sharing.LinkAction.changeAudience
        super.init(swift: swift)
    }
}

/// Remove the expiry date of the link.
@objc
public class DBXSharingLinkActionRemoveExpiry: DBXSharingLinkAction {
    @objc
    public init() {
        let swift = Sharing.LinkAction.removeExpiry
        super.init(swift: swift)
    }
}

/// Remove the password of the link.
@objc
public class DBXSharingLinkActionRemovePassword: DBXSharingLinkAction {
    @objc
    public init() {
        let swift = Sharing.LinkAction.removePassword
        super.init(swift: swift)
    }
}

/// Create or modify the expiry date of the link.
@objc
public class DBXSharingLinkActionSetExpiry: DBXSharingLinkAction {
    @objc
    public init() {
        let swift = Sharing.LinkAction.setExpiry
        super.init(swift: swift)
    }
}

/// Create or modify the password of the link.
@objc
public class DBXSharingLinkActionSetPassword: DBXSharingLinkAction {
    @objc
    public init() {
        let swift = Sharing.LinkAction.setPassword
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXSharingLinkActionOther: DBXSharingLinkAction {
    @objc
    public init() {
        let swift = Sharing.LinkAction.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible LinkAudience union
@objc
public class DBXSharingLinkAudience: NSObject {
    let swift: Sharing.LinkAudience

    public init(swift: Sharing.LinkAudience) {
        self.swift = swift
    }

    public static func factory(swift: Sharing.LinkAudience) -> DBXSharingLinkAudience {
        switch swift {
        case .public_:
            return DBXSharingLinkAudiencePublic_()
        case .team:
            return DBXSharingLinkAudienceTeam()
        case .noOne:
            return DBXSharingLinkAudienceNoOne()
        case .password:
            return DBXSharingLinkAudiencePassword()
        case .members:
            return DBXSharingLinkAudienceMembers()
        case .other:
            return DBXSharingLinkAudienceOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asPublic_: DBXSharingLinkAudiencePublic_? {
        self as? DBXSharingLinkAudiencePublic_
    }

    @objc
    public var asTeam: DBXSharingLinkAudienceTeam? {
        self as? DBXSharingLinkAudienceTeam
    }

    @objc
    public var asNoOne: DBXSharingLinkAudienceNoOne? {
        self as? DBXSharingLinkAudienceNoOne
    }

    @objc
    public var asPassword: DBXSharingLinkAudiencePassword? {
        self as? DBXSharingLinkAudiencePassword
    }

    @objc
    public var asMembers: DBXSharingLinkAudienceMembers? {
        self as? DBXSharingLinkAudienceMembers
    }

    @objc
    public var asOther: DBXSharingLinkAudienceOther? {
        self as? DBXSharingLinkAudienceOther
    }
}

/// Link is accessible by anyone.
@objc
public class DBXSharingLinkAudiencePublic_: DBXSharingLinkAudience {
    @objc
    public init() {
        let swift = Sharing.LinkAudience.public_
        super.init(swift: swift)
    }
}

/// Link is accessible only by team members.
@objc
public class DBXSharingLinkAudienceTeam: DBXSharingLinkAudience {
    @objc
    public init() {
        let swift = Sharing.LinkAudience.team
        super.init(swift: swift)
    }
}

/// The link can be used by no one. The link merely points the user to the content, and does not grant
/// additional rights to the user. Members of the content who use this link can only access the content
/// with their pre-existing access rights.
@objc
public class DBXSharingLinkAudienceNoOne: DBXSharingLinkAudience {
    @objc
    public init() {
        let swift = Sharing.LinkAudience.noOne
        super.init(swift: swift)
    }
}

/// Use `require_password` instead. A link-specific password is required to access the link. Login is not
/// required.
@objc
public class DBXSharingLinkAudiencePassword: DBXSharingLinkAudience {
    @objc
    public init() {
        let swift = Sharing.LinkAudience.password
        super.init(swift: swift)
    }
}

/// Link is accessible only by members of the content.
@objc
public class DBXSharingLinkAudienceMembers: DBXSharingLinkAudience {
    @objc
    public init() {
        let swift = Sharing.LinkAudience.members
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXSharingLinkAudienceOther: DBXSharingLinkAudience {
    @objc
    public init() {
        let swift = Sharing.LinkAudience.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible VisibilityPolicyDisallowedReason union
@objc
public class DBXSharingVisibilityPolicyDisallowedReason: NSObject {
    let swift: Sharing.VisibilityPolicyDisallowedReason

    public init(swift: Sharing.VisibilityPolicyDisallowedReason) {
        self.swift = swift
    }

    public static func factory(swift: Sharing.VisibilityPolicyDisallowedReason) -> DBXSharingVisibilityPolicyDisallowedReason {
        switch swift {
        case .deleteAndRecreate:
            return DBXSharingVisibilityPolicyDisallowedReasonDeleteAndRecreate()
        case .restrictedBySharedFolder:
            return DBXSharingVisibilityPolicyDisallowedReasonRestrictedBySharedFolder()
        case .restrictedByTeam:
            return DBXSharingVisibilityPolicyDisallowedReasonRestrictedByTeam()
        case .userNotOnTeam:
            return DBXSharingVisibilityPolicyDisallowedReasonUserNotOnTeam()
        case .userAccountType:
            return DBXSharingVisibilityPolicyDisallowedReasonUserAccountType()
        case .permissionDenied:
            return DBXSharingVisibilityPolicyDisallowedReasonPermissionDenied()
        case .other:
            return DBXSharingVisibilityPolicyDisallowedReasonOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asDeleteAndRecreate: DBXSharingVisibilityPolicyDisallowedReasonDeleteAndRecreate? {
        self as? DBXSharingVisibilityPolicyDisallowedReasonDeleteAndRecreate
    }

    @objc
    public var asRestrictedBySharedFolder: DBXSharingVisibilityPolicyDisallowedReasonRestrictedBySharedFolder? {
        self as? DBXSharingVisibilityPolicyDisallowedReasonRestrictedBySharedFolder
    }

    @objc
    public var asRestrictedByTeam: DBXSharingVisibilityPolicyDisallowedReasonRestrictedByTeam? {
        self as? DBXSharingVisibilityPolicyDisallowedReasonRestrictedByTeam
    }

    @objc
    public var asUserNotOnTeam: DBXSharingVisibilityPolicyDisallowedReasonUserNotOnTeam? {
        self as? DBXSharingVisibilityPolicyDisallowedReasonUserNotOnTeam
    }

    @objc
    public var asUserAccountType: DBXSharingVisibilityPolicyDisallowedReasonUserAccountType? {
        self as? DBXSharingVisibilityPolicyDisallowedReasonUserAccountType
    }

    @objc
    public var asPermissionDenied: DBXSharingVisibilityPolicyDisallowedReasonPermissionDenied? {
        self as? DBXSharingVisibilityPolicyDisallowedReasonPermissionDenied
    }

    @objc
    public var asOther: DBXSharingVisibilityPolicyDisallowedReasonOther? {
        self as? DBXSharingVisibilityPolicyDisallowedReasonOther
    }
}

/// The user needs to delete and recreate the link to change the visibility policy.
@objc
public class DBXSharingVisibilityPolicyDisallowedReasonDeleteAndRecreate: DBXSharingVisibilityPolicyDisallowedReason {
    @objc
    public init() {
        let swift = Sharing.VisibilityPolicyDisallowedReason.deleteAndRecreate
        super.init(swift: swift)
    }
}

/// The parent shared folder restricts sharing of links outside the shared folder. To change the visibility
/// policy, remove the restriction from the parent shared folder.
@objc
public class DBXSharingVisibilityPolicyDisallowedReasonRestrictedBySharedFolder: DBXSharingVisibilityPolicyDisallowedReason {
    @objc
    public init() {
        let swift = Sharing.VisibilityPolicyDisallowedReason.restrictedBySharedFolder
        super.init(swift: swift)
    }
}

/// The team policy prevents links being shared outside the team.
@objc
public class DBXSharingVisibilityPolicyDisallowedReasonRestrictedByTeam: DBXSharingVisibilityPolicyDisallowedReason {
    @objc
    public init() {
        let swift = Sharing.VisibilityPolicyDisallowedReason.restrictedByTeam
        super.init(swift: swift)
    }
}

/// The user needs to be on a team to set this policy.
@objc
public class DBXSharingVisibilityPolicyDisallowedReasonUserNotOnTeam: DBXSharingVisibilityPolicyDisallowedReason {
    @objc
    public init() {
        let swift = Sharing.VisibilityPolicyDisallowedReason.userNotOnTeam
        super.init(swift: swift)
    }
}

/// The user is a basic user or is on a limited team.
@objc
public class DBXSharingVisibilityPolicyDisallowedReasonUserAccountType: DBXSharingVisibilityPolicyDisallowedReason {
    @objc
    public init() {
        let swift = Sharing.VisibilityPolicyDisallowedReason.userAccountType
        super.init(swift: swift)
    }
}

/// The user does not have permission.
@objc
public class DBXSharingVisibilityPolicyDisallowedReasonPermissionDenied: DBXSharingVisibilityPolicyDisallowedReason {
    @objc
    public init() {
        let swift = Sharing.VisibilityPolicyDisallowedReason.permissionDenied
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXSharingVisibilityPolicyDisallowedReasonOther: DBXSharingVisibilityPolicyDisallowedReason {
    @objc
    public init() {
        let swift = Sharing.VisibilityPolicyDisallowedReason.other
        super.init(swift: swift)
    }
}

/// check documentation for VisibilityPolicyDisallowedReason.
@objc
public class DBXSharingLinkAudienceDisallowedReason: NSObject {
    let swift: Sharing.LinkAudienceDisallowedReason

    public init(swift: Sharing.LinkAudienceDisallowedReason) {
        self.swift = swift
    }

    public static func factory(swift: Sharing.LinkAudienceDisallowedReason) -> DBXSharingLinkAudienceDisallowedReason {
        switch swift {
        case .deleteAndRecreate:
            return DBXSharingLinkAudienceDisallowedReasonDeleteAndRecreate()
        case .restrictedBySharedFolder:
            return DBXSharingLinkAudienceDisallowedReasonRestrictedBySharedFolder()
        case .restrictedByTeam:
            return DBXSharingLinkAudienceDisallowedReasonRestrictedByTeam()
        case .userNotOnTeam:
            return DBXSharingLinkAudienceDisallowedReasonUserNotOnTeam()
        case .userAccountType:
            return DBXSharingLinkAudienceDisallowedReasonUserAccountType()
        case .permissionDenied:
            return DBXSharingLinkAudienceDisallowedReasonPermissionDenied()
        case .other:
            return DBXSharingLinkAudienceDisallowedReasonOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asDeleteAndRecreate: DBXSharingLinkAudienceDisallowedReasonDeleteAndRecreate? {
        self as? DBXSharingLinkAudienceDisallowedReasonDeleteAndRecreate
    }

    @objc
    public var asRestrictedBySharedFolder: DBXSharingLinkAudienceDisallowedReasonRestrictedBySharedFolder? {
        self as? DBXSharingLinkAudienceDisallowedReasonRestrictedBySharedFolder
    }

    @objc
    public var asRestrictedByTeam: DBXSharingLinkAudienceDisallowedReasonRestrictedByTeam? {
        self as? DBXSharingLinkAudienceDisallowedReasonRestrictedByTeam
    }

    @objc
    public var asUserNotOnTeam: DBXSharingLinkAudienceDisallowedReasonUserNotOnTeam? {
        self as? DBXSharingLinkAudienceDisallowedReasonUserNotOnTeam
    }

    @objc
    public var asUserAccountType: DBXSharingLinkAudienceDisallowedReasonUserAccountType? {
        self as? DBXSharingLinkAudienceDisallowedReasonUserAccountType
    }

    @objc
    public var asPermissionDenied: DBXSharingLinkAudienceDisallowedReasonPermissionDenied? {
        self as? DBXSharingLinkAudienceDisallowedReasonPermissionDenied
    }

    @objc
    public var asOther: DBXSharingLinkAudienceDisallowedReasonOther? {
        self as? DBXSharingLinkAudienceDisallowedReasonOther
    }
}

/// The user needs to delete and recreate the link to change the visibility policy.
@objc
public class DBXSharingLinkAudienceDisallowedReasonDeleteAndRecreate: DBXSharingLinkAudienceDisallowedReason {
    @objc
    public init() {
        let swift = Sharing.LinkAudienceDisallowedReason.deleteAndRecreate
        super.init(swift: swift)
    }
}

/// The parent shared folder restricts sharing of links outside the shared folder. To change the visibility
/// policy, remove the restriction from the parent shared folder.
@objc
public class DBXSharingLinkAudienceDisallowedReasonRestrictedBySharedFolder: DBXSharingLinkAudienceDisallowedReason {
    @objc
    public init() {
        let swift = Sharing.LinkAudienceDisallowedReason.restrictedBySharedFolder
        super.init(swift: swift)
    }
}

/// The team policy prevents links being shared outside the team.
@objc
public class DBXSharingLinkAudienceDisallowedReasonRestrictedByTeam: DBXSharingLinkAudienceDisallowedReason {
    @objc
    public init() {
        let swift = Sharing.LinkAudienceDisallowedReason.restrictedByTeam
        super.init(swift: swift)
    }
}

/// The user needs to be on a team to set this policy.
@objc
public class DBXSharingLinkAudienceDisallowedReasonUserNotOnTeam: DBXSharingLinkAudienceDisallowedReason {
    @objc
    public init() {
        let swift = Sharing.LinkAudienceDisallowedReason.userNotOnTeam
        super.init(swift: swift)
    }
}

/// The user is a basic user or is on a limited team.
@objc
public class DBXSharingLinkAudienceDisallowedReasonUserAccountType: DBXSharingLinkAudienceDisallowedReason {
    @objc
    public init() {
        let swift = Sharing.LinkAudienceDisallowedReason.userAccountType
        super.init(swift: swift)
    }
}

/// The user does not have permission.
@objc
public class DBXSharingLinkAudienceDisallowedReasonPermissionDenied: DBXSharingLinkAudienceDisallowedReason {
    @objc
    public init() {
        let swift = Sharing.LinkAudienceDisallowedReason.permissionDenied
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXSharingLinkAudienceDisallowedReasonOther: DBXSharingLinkAudienceDisallowedReason {
    @objc
    public init() {
        let swift = Sharing.LinkAudienceDisallowedReason.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible LinkAudienceOption struct
@objc
public class DBXSharingLinkAudienceOption: NSObject {
    /// Specifies who can access the link.
    @objc
    public var audience: DBXSharingLinkAudience { DBXSharingLinkAudience(swift: swift.audience) }
    /// Whether the user calling this API can select this audience option.
    @objc
    public var allowed: NSNumber { swift.allowed as NSNumber }
    /// If allowed is false, this will provide the reason that the user is not permitted to set the visibility to
    /// this policy.
    @objc
    public var disallowedReason: DBXSharingLinkAudienceDisallowedReason? { guard let swift = swift.disallowedReason else { return nil }
        return DBXSharingLinkAudienceDisallowedReason(swift: swift)
    }

    @objc
    public init(audience: DBXSharingLinkAudience, allowed: NSNumber, disallowedReason: DBXSharingLinkAudienceDisallowedReason?) {
        self.swift = Sharing.LinkAudienceOption(audience: audience.swift, allowed: allowed.boolValue, disallowedReason: disallowedReason?.swift)
    }

    let swift: Sharing.LinkAudienceOption

    public init(swift: Sharing.LinkAudienceOption) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible LinkExpiry union
@objc
public class DBXSharingLinkExpiry: NSObject {
    let swift: Sharing.LinkExpiry

    public init(swift: Sharing.LinkExpiry) {
        self.swift = swift
    }

    public static func factory(swift: Sharing.LinkExpiry) -> DBXSharingLinkExpiry {
        switch swift {
        case .removeExpiry:
            return DBXSharingLinkExpiryRemoveExpiry()
        case .setExpiry(let swiftArg):
            let arg = swiftArg
            return DBXSharingLinkExpirySetExpiry(arg)
        case .other:
            return DBXSharingLinkExpiryOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asRemoveExpiry: DBXSharingLinkExpiryRemoveExpiry? {
        self as? DBXSharingLinkExpiryRemoveExpiry
    }

    @objc
    public var asSetExpiry: DBXSharingLinkExpirySetExpiry? {
        self as? DBXSharingLinkExpirySetExpiry
    }

    @objc
    public var asOther: DBXSharingLinkExpiryOther? {
        self as? DBXSharingLinkExpiryOther
    }
}

/// Remove the currently set expiry for the link.
@objc
public class DBXSharingLinkExpiryRemoveExpiry: DBXSharingLinkExpiry {
    @objc
    public init() {
        let swift = Sharing.LinkExpiry.removeExpiry
        super.init(swift: swift)
    }
}

/// Set a new expiry or change an existing expiry.
@objc
public class DBXSharingLinkExpirySetExpiry: DBXSharingLinkExpiry {
    @objc
    public var setExpiry: Date

    @objc
    public init(_ arg: Date) {
        self.setExpiry = arg
        let swift = Sharing.LinkExpiry.setExpiry(arg)
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXSharingLinkExpiryOther: DBXSharingLinkExpiry {
    @objc
    public init() {
        let swift = Sharing.LinkExpiry.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible LinkPassword union
@objc
public class DBXSharingLinkPassword: NSObject {
    let swift: Sharing.LinkPassword

    public init(swift: Sharing.LinkPassword) {
        self.swift = swift
    }

    public static func factory(swift: Sharing.LinkPassword) -> DBXSharingLinkPassword {
        switch swift {
        case .removePassword:
            return DBXSharingLinkPasswordRemovePassword()
        case .setPassword(let swiftArg):
            let arg = swiftArg
            return DBXSharingLinkPasswordSetPassword(arg)
        case .other:
            return DBXSharingLinkPasswordOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asRemovePassword: DBXSharingLinkPasswordRemovePassword? {
        self as? DBXSharingLinkPasswordRemovePassword
    }

    @objc
    public var asSetPassword: DBXSharingLinkPasswordSetPassword? {
        self as? DBXSharingLinkPasswordSetPassword
    }

    @objc
    public var asOther: DBXSharingLinkPasswordOther? {
        self as? DBXSharingLinkPasswordOther
    }
}

/// Remove the currently set password for the link.
@objc
public class DBXSharingLinkPasswordRemovePassword: DBXSharingLinkPassword {
    @objc
    public init() {
        let swift = Sharing.LinkPassword.removePassword
        super.init(swift: swift)
    }
}

/// Set a new password or change an existing password.
@objc
public class DBXSharingLinkPasswordSetPassword: DBXSharingLinkPassword {
    @objc
    public var setPassword: String

    @objc
    public init(_ arg: String) {
        self.setPassword = arg
        let swift = Sharing.LinkPassword.setPassword(arg)
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXSharingLinkPasswordOther: DBXSharingLinkPassword {
    @objc
    public init() {
        let swift = Sharing.LinkPassword.other
        super.init(swift: swift)
    }
}

/// Permissions for actions that can be performed on a link.
@objc
public class DBXSharingLinkPermission: NSObject {
    /// (no description)
    @objc
    public var action: DBXSharingLinkAction { DBXSharingLinkAction(swift: swift.action) }
    /// (no description)
    @objc
    public var allow: NSNumber { swift.allow as NSNumber }
    /// (no description)
    @objc
    public var reason: DBXSharingPermissionDeniedReason? { guard let swift = swift.reason else { return nil }
        return DBXSharingPermissionDeniedReason(swift: swift)
    }

    @objc
    public init(action: DBXSharingLinkAction, allow: NSNumber, reason: DBXSharingPermissionDeniedReason?) {
        self.swift = Sharing.LinkPermission(action: action.swift, allow: allow.boolValue, reason: reason?.swift)
    }

    let swift: Sharing.LinkPermission

    public init(swift: Sharing.LinkPermission) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible LinkPermissions struct
@objc
public class DBXSharingLinkPermissions: NSObject {
    /// The current visibility of the link after considering the shared links policies of the the team (in case the
    /// link's owner is part of a team) and the shared folder (in case the linked file is part of a shared
    /// folder). This field is shown only if the caller has access to this info (the link's owner always has
    /// access to this data). For some links, an effective_audience value is returned instead.
    @objc
    public var resolvedVisibility: DBXSharingResolvedVisibility? { guard let swift = swift.resolvedVisibility else { return nil }
        return DBXSharingResolvedVisibility(swift: swift)
    }

    /// The shared link's requested visibility. This can be overridden by the team and shared folder policies. The
    /// final visibility, after considering these policies, can be found in resolvedVisibility. This is shown
    /// only if the caller is the link's owner and resolved_visibility is returned instead of
    /// effective_audience.
    @objc
    public var requestedVisibility: DBXSharingRequestedVisibility? { guard let swift = swift.requestedVisibility else { return nil }
        return DBXSharingRequestedVisibility(swift: swift)
    }

    /// Whether the caller can revoke the shared link.
    @objc
    public var canRevoke: NSNumber { swift.canRevoke as NSNumber }
    /// The failure reason for revoking the link. This field will only be present if the canRevoke is false.
    @objc
    public var revokeFailureReason: DBXSharingSharedLinkAccessFailureReason? { guard let swift = swift.revokeFailureReason else { return nil }
        return DBXSharingSharedLinkAccessFailureReason(swift: swift)
    }

    /// The type of audience who can benefit from the access level specified by the `link_access_level` field.
    @objc
    public var effectiveAudience: DBXSharingLinkAudience? { guard let swift = swift.effectiveAudience else { return nil }
        return DBXSharingLinkAudience(swift: swift)
    }

    /// The access level that the link will grant to its users. A link can grant additional rights to a user beyond
    /// their current access level. For example, if a user was invited as a viewer to a file, and then opens a
    /// link with `link_access_level` set to `editor`, then they will gain editor privileges. The
    /// `link_access_level` is a property of the link, and does not depend on who is calling this API. In
    /// particular, `link_access_level` does not take into account the API caller's current permissions to the
    /// content.
    @objc
    public var linkAccessLevel: DBXSharingLinkAccessLevel? { guard let swift = swift.linkAccessLevel else { return nil }
        return DBXSharingLinkAccessLevel(swift: swift)
    }

    /// A list of policies that the user might be able to set for the visibility.
    @objc
    public var visibilityPolicies: [DBXSharingVisibilityPolicy] { swift.visibilityPolicies.map { DBXSharingVisibilityPolicy(swift: $0) } }
    /// Whether the user can set the expiry settings of the link. This refers to the ability to create a new expiry
    /// and modify an existing expiry.
    @objc
    public var canSetExpiry: NSNumber { swift.canSetExpiry as NSNumber }
    /// Whether the user can remove the expiry of the link.
    @objc
    public var canRemoveExpiry: NSNumber { swift.canRemoveExpiry as NSNumber }
    /// Whether the link can be downloaded or not.
    @objc
    public var allowDownload: NSNumber { swift.allowDownload as NSNumber }
    /// Whether the user can allow downloads via the link. This refers to the ability to remove a no-download
    /// restriction on the link.
    @objc
    public var canAllowDownload: NSNumber { swift.canAllowDownload as NSNumber }
    /// Whether the user can disallow downloads via the link. This refers to the ability to impose a no-download
    /// restriction on the link.
    @objc
    public var canDisallowDownload: NSNumber { swift.canDisallowDownload as NSNumber }
    /// Whether comments are enabled for the linked file. This takes the team commenting policy into account.
    @objc
    public var allowComments: NSNumber { swift.allowComments as NSNumber }
    /// Whether the team has disabled commenting globally.
    @objc
    public var teamRestrictsComments: NSNumber { swift.teamRestrictsComments as NSNumber }
    /// A list of link audience options the user might be able to set as the new audience.
    @objc
    public var audienceOptions: [DBXSharingLinkAudienceOption]? { swift.audienceOptions?.map { DBXSharingLinkAudienceOption(swift: $0) } }
    /// Whether the user can set a password for the link.
    @objc
    public var canSetPassword: NSNumber? { swift.canSetPassword as NSNumber? }
    /// Whether the user can remove the password of the link.
    @objc
    public var canRemovePassword: NSNumber? { swift.canRemovePassword as NSNumber? }
    /// Whether the user is required to provide a password to view the link.
    @objc
    public var requirePassword: NSNumber? { swift.requirePassword as NSNumber? }
    /// Whether the user can use extended sharing controls, based on their account type.
    @objc
    public var canUseExtendedSharingControls: NSNumber? { swift.canUseExtendedSharingControls as NSNumber? }

    @objc
    public init(
        canRevoke: NSNumber,
        visibilityPolicies: [DBXSharingVisibilityPolicy],
        canSetExpiry: NSNumber,
        canRemoveExpiry: NSNumber,
        allowDownload: NSNumber,
        canAllowDownload: NSNumber,
        canDisallowDownload: NSNumber,
        allowComments: NSNumber,
        teamRestrictsComments: NSNumber,
        resolvedVisibility: DBXSharingResolvedVisibility?,
        requestedVisibility: DBXSharingRequestedVisibility?,
        revokeFailureReason: DBXSharingSharedLinkAccessFailureReason?,
        effectiveAudience: DBXSharingLinkAudience?,
        linkAccessLevel: DBXSharingLinkAccessLevel?,
        audienceOptions: [DBXSharingLinkAudienceOption]?,
        canSetPassword: NSNumber?,
        canRemovePassword: NSNumber?,
        requirePassword: NSNumber?,
        canUseExtendedSharingControls: NSNumber?
    ) {
        self.swift = Sharing.LinkPermissions(
            canRevoke: canRevoke.boolValue,
            visibilityPolicies: visibilityPolicies.map(\.swift),
            canSetExpiry: canSetExpiry.boolValue,
            canRemoveExpiry: canRemoveExpiry.boolValue,
            allowDownload: allowDownload.boolValue,
            canAllowDownload: canAllowDownload.boolValue,
            canDisallowDownload: canDisallowDownload.boolValue,
            allowComments: allowComments.boolValue,
            teamRestrictsComments: teamRestrictsComments.boolValue,
            resolvedVisibility: resolvedVisibility?.swift,
            requestedVisibility: requestedVisibility?.swift,
            revokeFailureReason: revokeFailureReason?.swift,
            effectiveAudience: effectiveAudience?.swift,
            linkAccessLevel: linkAccessLevel?.swift,
            audienceOptions: audienceOptions?.map(\.swift),
            canSetPassword: canSetPassword?.boolValue,
            canRemovePassword: canRemovePassword?.boolValue,
            requirePassword: requirePassword?.boolValue,
            canUseExtendedSharingControls: canUseExtendedSharingControls?.boolValue
        )
    }

    let swift: Sharing.LinkPermissions

    public init(swift: Sharing.LinkPermissions) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Settings that apply to a link.
@objc
public class DBXSharingLinkSettings: NSObject {
    /// The access level on the link for this file. Currently, it only accepts 'viewer' and 'viewer_no_comment'.
    @objc
    public var accessLevel: DBXSharingAccessLevel? { guard let swift = swift.accessLevel else { return nil }
        return DBXSharingAccessLevel(swift: swift)
    }

    /// The type of audience on the link for this file.
    @objc
    public var audience: DBXSharingLinkAudience? { guard let swift = swift.audience else { return nil }
        return DBXSharingLinkAudience(swift: swift)
    }

    /// An expiry timestamp to set on a link.
    @objc
    public var expiry: DBXSharingLinkExpiry? { guard let swift = swift.expiry else { return nil }
        return DBXSharingLinkExpiry(swift: swift)
    }

    /// The password for the link.
    @objc
    public var password: DBXSharingLinkPassword? { guard let swift = swift.password else { return nil }
        return DBXSharingLinkPassword(swift: swift)
    }

    @objc
    public init(accessLevel: DBXSharingAccessLevel?, audience: DBXSharingLinkAudience?, expiry: DBXSharingLinkExpiry?, password: DBXSharingLinkPassword?) {
        self.swift = Sharing.LinkSettings(accessLevel: accessLevel?.swift, audience: audience?.swift, expiry: expiry?.swift, password: password?.swift)
    }

    let swift: Sharing.LinkSettings

    public init(swift: Sharing.LinkSettings) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Arguments for listFileMembers.
@objc
public class DBXSharingListFileMembersArg: NSObject {
    /// The file for which you want to see members.
    @objc
    public var file: String { swift.file }
    /// The actions for which to return permissions on a member.
    @objc
    public var actions: [DBXSharingMemberAction]? { swift.actions?.map { DBXSharingMemberAction(swift: $0) } }
    /// Whether to include members who only have access from a parent shared folder.
    @objc
    public var includeInherited: NSNumber { swift.includeInherited as NSNumber }
    /// Number of members to return max per query. Defaults to 100 if no limit is specified.
    @objc
    public var limit: NSNumber { swift.limit as NSNumber }

    @objc
    public init(file: String, actions: [DBXSharingMemberAction]?, includeInherited: NSNumber, limit: NSNumber) {
        self.swift = Sharing.ListFileMembersArg(
            file: file,
            actions: actions?.map(\.swift),
            includeInherited: includeInherited.boolValue,
            limit: limit.uint32Value
        )
    }

    let swift: Sharing.ListFileMembersArg

    public init(swift: Sharing.ListFileMembersArg) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Arguments for listFileMembersBatch.
@objc
public class DBXSharingListFileMembersBatchArg: NSObject {
    /// Files for which to return members.
    @objc
    public var files: [String] { swift.files }
    /// Number of members to return max per query. Defaults to 10 if no limit is specified.
    @objc
    public var limit: NSNumber { swift.limit as NSNumber }

    @objc
    public init(files: [String], limit: NSNumber) {
        self.swift = Sharing.ListFileMembersBatchArg(files: files, limit: limit.uint32Value)
    }

    let swift: Sharing.ListFileMembersBatchArg

    public init(swift: Sharing.ListFileMembersBatchArg) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Per-file result for listFileMembersBatch.
@objc
public class DBXSharingListFileMembersBatchResult: NSObject {
    /// This is the input file identifier, whether an ID or a path.
    @objc
    public var file: String { swift.file }
    /// The result for this particular file.
    @objc
    public var result: DBXSharingListFileMembersIndividualResult { DBXSharingListFileMembersIndividualResult(swift: swift.result) }

    @objc
    public init(file: String, result: DBXSharingListFileMembersIndividualResult) {
        self.swift = Sharing.ListFileMembersBatchResult(file: file, result: result.swift)
    }

    let swift: Sharing.ListFileMembersBatchResult

    public init(swift: Sharing.ListFileMembersBatchResult) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Arguments for listFileMembersContinue.
@objc
public class DBXSharingListFileMembersContinueArg: NSObject {
    /// The cursor returned by your last call to listFileMembers, listFileMembersContinue, or listFileMembersBatch.
    @objc
    public var cursor: String { swift.cursor }

    @objc
    public init(cursor: String) {
        self.swift = Sharing.ListFileMembersContinueArg(cursor: cursor)
    }

    let swift: Sharing.ListFileMembersContinueArg

    public init(swift: Sharing.ListFileMembersContinueArg) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Error for listFileMembersContinue.
@objc
public class DBXSharingListFileMembersContinueError: NSObject {
    let swift: Sharing.ListFileMembersContinueError

    public init(swift: Sharing.ListFileMembersContinueError) {
        self.swift = swift
    }

    public static func factory(swift: Sharing.ListFileMembersContinueError) -> DBXSharingListFileMembersContinueError {
        switch swift {
        case .userError(let swiftArg):
            let arg = DBXSharingSharingUserError(swift: swiftArg)
            return DBXSharingListFileMembersContinueErrorUserError(arg)
        case .accessError(let swiftArg):
            let arg = DBXSharingSharingFileAccessError(swift: swiftArg)
            return DBXSharingListFileMembersContinueErrorAccessError(arg)
        case .invalidCursor:
            return DBXSharingListFileMembersContinueErrorInvalidCursor()
        case .other:
            return DBXSharingListFileMembersContinueErrorOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asUserError: DBXSharingListFileMembersContinueErrorUserError? {
        self as? DBXSharingListFileMembersContinueErrorUserError
    }

    @objc
    public var asAccessError: DBXSharingListFileMembersContinueErrorAccessError? {
        self as? DBXSharingListFileMembersContinueErrorAccessError
    }

    @objc
    public var asInvalidCursor: DBXSharingListFileMembersContinueErrorInvalidCursor? {
        self as? DBXSharingListFileMembersContinueErrorInvalidCursor
    }

    @objc
    public var asOther: DBXSharingListFileMembersContinueErrorOther? {
        self as? DBXSharingListFileMembersContinueErrorOther
    }
}

/// An unspecified error.
@objc
public class DBXSharingListFileMembersContinueErrorUserError: DBXSharingListFileMembersContinueError {
    @objc
    public var userError: DBXSharingSharingUserError

    @objc
    public init(_ arg: DBXSharingSharingUserError) {
        self.userError = arg
        let swift = Sharing.ListFileMembersContinueError.userError(arg.swift)
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXSharingListFileMembersContinueErrorAccessError: DBXSharingListFileMembersContinueError {
    @objc
    public var accessError: DBXSharingSharingFileAccessError

    @objc
    public init(_ arg: DBXSharingSharingFileAccessError) {
        self.accessError = arg
        let swift = Sharing.ListFileMembersContinueError.accessError(arg.swift)
        super.init(swift: swift)
    }
}

/// cursor in ListFileMembersContinueArg is invalid.
@objc
public class DBXSharingListFileMembersContinueErrorInvalidCursor: DBXSharingListFileMembersContinueError {
    @objc
    public init() {
        let swift = Sharing.ListFileMembersContinueError.invalidCursor
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXSharingListFileMembersContinueErrorOther: DBXSharingListFileMembersContinueError {
    @objc
    public init() {
        let swift = Sharing.ListFileMembersContinueError.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible ListFileMembersCountResult struct
@objc
public class DBXSharingListFileMembersCountResult: NSObject {
    /// A list of members on this file.
    @objc
    public var members: DBXSharingSharedFileMembers { DBXSharingSharedFileMembers(swift: swift.members) }
    /// The number of members on this file. This does not include inherited members.
    @objc
    public var memberCount: NSNumber { swift.memberCount as NSNumber }

    @objc
    public init(members: DBXSharingSharedFileMembers, memberCount: NSNumber) {
        self.swift = Sharing.ListFileMembersCountResult(members: members.swift, memberCount: memberCount.uint32Value)
    }

    let swift: Sharing.ListFileMembersCountResult

    public init(swift: Sharing.ListFileMembersCountResult) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Error for listFileMembers.
@objc
public class DBXSharingListFileMembersError: NSObject {
    let swift: Sharing.ListFileMembersError

    public init(swift: Sharing.ListFileMembersError) {
        self.swift = swift
    }

    public static func factory(swift: Sharing.ListFileMembersError) -> DBXSharingListFileMembersError {
        switch swift {
        case .userError(let swiftArg):
            let arg = DBXSharingSharingUserError(swift: swiftArg)
            return DBXSharingListFileMembersErrorUserError(arg)
        case .accessError(let swiftArg):
            let arg = DBXSharingSharingFileAccessError(swift: swiftArg)
            return DBXSharingListFileMembersErrorAccessError(arg)
        case .other:
            return DBXSharingListFileMembersErrorOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asUserError: DBXSharingListFileMembersErrorUserError? {
        self as? DBXSharingListFileMembersErrorUserError
    }

    @objc
    public var asAccessError: DBXSharingListFileMembersErrorAccessError? {
        self as? DBXSharingListFileMembersErrorAccessError
    }

    @objc
    public var asOther: DBXSharingListFileMembersErrorOther? {
        self as? DBXSharingListFileMembersErrorOther
    }
}

/// An unspecified error.
@objc
public class DBXSharingListFileMembersErrorUserError: DBXSharingListFileMembersError {
    @objc
    public var userError: DBXSharingSharingUserError

    @objc
    public init(_ arg: DBXSharingSharingUserError) {
        self.userError = arg
        let swift = Sharing.ListFileMembersError.userError(arg.swift)
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXSharingListFileMembersErrorAccessError: DBXSharingListFileMembersError {
    @objc
    public var accessError: DBXSharingSharingFileAccessError

    @objc
    public init(_ arg: DBXSharingSharingFileAccessError) {
        self.accessError = arg
        let swift = Sharing.ListFileMembersError.accessError(arg.swift)
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXSharingListFileMembersErrorOther: DBXSharingListFileMembersError {
    @objc
    public init() {
        let swift = Sharing.ListFileMembersError.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible ListFileMembersIndividualResult union
@objc
public class DBXSharingListFileMembersIndividualResult: NSObject {
    let swift: Sharing.ListFileMembersIndividualResult

    public init(swift: Sharing.ListFileMembersIndividualResult) {
        self.swift = swift
    }

    public static func factory(swift: Sharing.ListFileMembersIndividualResult) -> DBXSharingListFileMembersIndividualResult {
        switch swift {
        case .result(let swiftArg):
            let arg = DBXSharingListFileMembersCountResult(swift: swiftArg)
            return DBXSharingListFileMembersIndividualResultResult(arg)
        case .accessError(let swiftArg):
            let arg = DBXSharingSharingFileAccessError(swift: swiftArg)
            return DBXSharingListFileMembersIndividualResultAccessError(arg)
        case .other:
            return DBXSharingListFileMembersIndividualResultOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asResult: DBXSharingListFileMembersIndividualResultResult? {
        self as? DBXSharingListFileMembersIndividualResultResult
    }

    @objc
    public var asAccessError: DBXSharingListFileMembersIndividualResultAccessError? {
        self as? DBXSharingListFileMembersIndividualResultAccessError
    }

    @objc
    public var asOther: DBXSharingListFileMembersIndividualResultOther? {
        self as? DBXSharingListFileMembersIndividualResultOther
    }
}

/// The results of the query for this file if it was successful.
@objc
public class DBXSharingListFileMembersIndividualResultResult: DBXSharingListFileMembersIndividualResult {
    @objc
    public var result: DBXSharingListFileMembersCountResult

    @objc
    public init(_ arg: DBXSharingListFileMembersCountResult) {
        self.result = arg
        let swift = Sharing.ListFileMembersIndividualResult.result(arg.swift)
        super.init(swift: swift)
    }
}

/// The result of the query for this file if it was an error.
@objc
public class DBXSharingListFileMembersIndividualResultAccessError: DBXSharingListFileMembersIndividualResult {
    @objc
    public var accessError: DBXSharingSharingFileAccessError

    @objc
    public init(_ arg: DBXSharingSharingFileAccessError) {
        self.accessError = arg
        let swift = Sharing.ListFileMembersIndividualResult.accessError(arg.swift)
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXSharingListFileMembersIndividualResultOther: DBXSharingListFileMembersIndividualResult {
    @objc
    public init() {
        let swift = Sharing.ListFileMembersIndividualResult.other
        super.init(swift: swift)
    }
}

/// Arguments for listReceivedFiles.
@objc
public class DBXSharingListFilesArg: NSObject {
    /// Number of files to return max per query. Defaults to 100 if no limit is specified.
    @objc
    public var limit: NSNumber { swift.limit as NSNumber }
    /// A list of `FileAction`s corresponding to `FilePermission`s that should appear in the  response's permissions
    /// in SharedFileMetadata field describing the actions the  authenticated user can perform on the file.
    @objc
    public var actions: [DBXSharingFileAction]? { swift.actions?.map { DBXSharingFileAction(swift: $0) } }

    @objc
    public init(limit: NSNumber, actions: [DBXSharingFileAction]?) {
        self.swift = Sharing.ListFilesArg(limit: limit.uint32Value, actions: actions?.map(\.swift))
    }

    let swift: Sharing.ListFilesArg

    public init(swift: Sharing.ListFilesArg) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Arguments for listReceivedFilesContinue.
@objc
public class DBXSharingListFilesContinueArg: NSObject {
    /// Cursor in cursor in ListFilesResult.
    @objc
    public var cursor: String { swift.cursor }

    @objc
    public init(cursor: String) {
        self.swift = Sharing.ListFilesContinueArg(cursor: cursor)
    }

    let swift: Sharing.ListFilesContinueArg

    public init(swift: Sharing.ListFilesContinueArg) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Error results for listReceivedFilesContinue.
@objc
public class DBXSharingListFilesContinueError: NSObject {
    let swift: Sharing.ListFilesContinueError

    public init(swift: Sharing.ListFilesContinueError) {
        self.swift = swift
    }

    public static func factory(swift: Sharing.ListFilesContinueError) -> DBXSharingListFilesContinueError {
        switch swift {
        case .userError(let swiftArg):
            let arg = DBXSharingSharingUserError(swift: swiftArg)
            return DBXSharingListFilesContinueErrorUserError(arg)
        case .invalidCursor:
            return DBXSharingListFilesContinueErrorInvalidCursor()
        case .other:
            return DBXSharingListFilesContinueErrorOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asUserError: DBXSharingListFilesContinueErrorUserError? {
        self as? DBXSharingListFilesContinueErrorUserError
    }

    @objc
    public var asInvalidCursor: DBXSharingListFilesContinueErrorInvalidCursor? {
        self as? DBXSharingListFilesContinueErrorInvalidCursor
    }

    @objc
    public var asOther: DBXSharingListFilesContinueErrorOther? {
        self as? DBXSharingListFilesContinueErrorOther
    }
}

/// User account had a problem.
@objc
public class DBXSharingListFilesContinueErrorUserError: DBXSharingListFilesContinueError {
    @objc
    public var userError: DBXSharingSharingUserError

    @objc
    public init(_ arg: DBXSharingSharingUserError) {
        self.userError = arg
        let swift = Sharing.ListFilesContinueError.userError(arg.swift)
        super.init(swift: swift)
    }
}

/// cursor in ListFilesContinueArg is invalid.
@objc
public class DBXSharingListFilesContinueErrorInvalidCursor: DBXSharingListFilesContinueError {
    @objc
    public init() {
        let swift = Sharing.ListFilesContinueError.invalidCursor
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXSharingListFilesContinueErrorOther: DBXSharingListFilesContinueError {
    @objc
    public init() {
        let swift = Sharing.ListFilesContinueError.other
        super.init(swift: swift)
    }
}

/// Success results for listReceivedFiles.
@objc
public class DBXSharingListFilesResult: NSObject {
    /// Information about the files shared with current user.
    @objc
    public var entries: [DBXSharingSharedFileMetadata] { swift.entries.map { DBXSharingSharedFileMetadata(swift: $0) } }
    /// Cursor used to obtain additional shared files.
    @objc
    public var cursor: String? { swift.cursor }

    @objc
    public init(entries: [DBXSharingSharedFileMetadata], cursor: String?) {
        self.swift = Sharing.ListFilesResult(entries: entries.map(\.swift), cursor: cursor)
    }

    let swift: Sharing.ListFilesResult

    public init(swift: Sharing.ListFilesResult) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible ListFolderMembersCursorArg struct
@objc
public class DBXSharingListFolderMembersCursorArg: NSObject {
    /// This is a list indicating whether each returned member will include a boolean value allow in
    /// MemberPermission that describes whether the current user can perform the MemberAction on the member.
    @objc
    public var actions: [DBXSharingMemberAction]? { swift.actions?.map { DBXSharingMemberAction(swift: $0) } }
    /// The maximum number of results that include members, groups and invitees to return per request.
    @objc
    public var limit: NSNumber { swift.limit as NSNumber }

    @objc
    public init(actions: [DBXSharingMemberAction]?, limit: NSNumber) {
        self.swift = Sharing.ListFolderMembersCursorArg(actions: actions?.map(\.swift), limit: limit.uint32Value)
    }

    let swift: Sharing.ListFolderMembersCursorArg

    public init(swift: Sharing.ListFolderMembersCursorArg) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible ListFolderMembersArgs struct
@objc
public class DBXSharingListFolderMembersArgs: DBXSharingListFolderMembersCursorArg {
    /// The ID for the shared folder.
    @objc
    public var sharedFolderId: String { subSwift.sharedFolderId }

    @objc
    public init(sharedFolderId: String, actions: [DBXSharingMemberAction]?, limit: NSNumber) {
        let swift = Sharing.ListFolderMembersArgs(sharedFolderId: sharedFolderId, actions: actions?.map(\.swift), limit: limit.uint32Value)
        self.subSwift = swift
        super.init(swift: swift)
    }

    let subSwift: Sharing.ListFolderMembersArgs

    public init(swift: Sharing.ListFolderMembersArgs) {
        self.subSwift = swift
        super.init(swift: swift)
    }

    @objc
    public override var description: String { subSwift.description }
}

/// Objective-C compatible ListFolderMembersContinueArg struct
@objc
public class DBXSharingListFolderMembersContinueArg: NSObject {
    /// The cursor returned by your last call to listFolderMembers or listFolderMembersContinue.
    @objc
    public var cursor: String { swift.cursor }

    @objc
    public init(cursor: String) {
        self.swift = Sharing.ListFolderMembersContinueArg(cursor: cursor)
    }

    let swift: Sharing.ListFolderMembersContinueArg

    public init(swift: Sharing.ListFolderMembersContinueArg) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible ListFolderMembersContinueError union
@objc
public class DBXSharingListFolderMembersContinueError: NSObject {
    let swift: Sharing.ListFolderMembersContinueError

    public init(swift: Sharing.ListFolderMembersContinueError) {
        self.swift = swift
    }

    public static func factory(swift: Sharing.ListFolderMembersContinueError) -> DBXSharingListFolderMembersContinueError {
        switch swift {
        case .accessError(let swiftArg):
            let arg = DBXSharingSharedFolderAccessError(swift: swiftArg)
            return DBXSharingListFolderMembersContinueErrorAccessError(arg)
        case .invalidCursor:
            return DBXSharingListFolderMembersContinueErrorInvalidCursor()
        case .other:
            return DBXSharingListFolderMembersContinueErrorOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asAccessError: DBXSharingListFolderMembersContinueErrorAccessError? {
        self as? DBXSharingListFolderMembersContinueErrorAccessError
    }

    @objc
    public var asInvalidCursor: DBXSharingListFolderMembersContinueErrorInvalidCursor? {
        self as? DBXSharingListFolderMembersContinueErrorInvalidCursor
    }

    @objc
    public var asOther: DBXSharingListFolderMembersContinueErrorOther? {
        self as? DBXSharingListFolderMembersContinueErrorOther
    }
}

/// An unspecified error.
@objc
public class DBXSharingListFolderMembersContinueErrorAccessError: DBXSharingListFolderMembersContinueError {
    @objc
    public var accessError: DBXSharingSharedFolderAccessError

    @objc
    public init(_ arg: DBXSharingSharedFolderAccessError) {
        self.accessError = arg
        let swift = Sharing.ListFolderMembersContinueError.accessError(arg.swift)
        super.init(swift: swift)
    }
}

/// cursor in ListFolderMembersContinueArg is invalid.
@objc
public class DBXSharingListFolderMembersContinueErrorInvalidCursor: DBXSharingListFolderMembersContinueError {
    @objc
    public init() {
        let swift = Sharing.ListFolderMembersContinueError.invalidCursor
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXSharingListFolderMembersContinueErrorOther: DBXSharingListFolderMembersContinueError {
    @objc
    public init() {
        let swift = Sharing.ListFolderMembersContinueError.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible ListFoldersArgs struct
@objc
public class DBXSharingListFoldersArgs: NSObject {
    /// The maximum number of results to return per request.
    @objc
    public var limit: NSNumber { swift.limit as NSNumber }
    /// A list of `FolderAction`s corresponding to `FolderPermission`s that should appear in the  response's
    /// permissions in SharedFolderMetadata field describing the actions the  authenticated user can perform on
    /// the folder.
    @objc
    public var actions: [DBXSharingFolderAction]? { swift.actions?.map { DBXSharingFolderAction(swift: $0) } }

    @objc
    public init(limit: NSNumber, actions: [DBXSharingFolderAction]?) {
        self.swift = Sharing.ListFoldersArgs(limit: limit.uint32Value, actions: actions?.map(\.swift))
    }

    let swift: Sharing.ListFoldersArgs

    public init(swift: Sharing.ListFoldersArgs) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible ListFoldersContinueArg struct
@objc
public class DBXSharingListFoldersContinueArg: NSObject {
    /// The cursor returned by the previous API call specified in the endpoint description.
    @objc
    public var cursor: String { swift.cursor }

    @objc
    public init(cursor: String) {
        self.swift = Sharing.ListFoldersContinueArg(cursor: cursor)
    }

    let swift: Sharing.ListFoldersContinueArg

    public init(swift: Sharing.ListFoldersContinueArg) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible ListFoldersContinueError union
@objc
public class DBXSharingListFoldersContinueError: NSObject {
    let swift: Sharing.ListFoldersContinueError

    public init(swift: Sharing.ListFoldersContinueError) {
        self.swift = swift
    }

    public static func factory(swift: Sharing.ListFoldersContinueError) -> DBXSharingListFoldersContinueError {
        switch swift {
        case .invalidCursor:
            return DBXSharingListFoldersContinueErrorInvalidCursor()
        case .other:
            return DBXSharingListFoldersContinueErrorOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asInvalidCursor: DBXSharingListFoldersContinueErrorInvalidCursor? {
        self as? DBXSharingListFoldersContinueErrorInvalidCursor
    }

    @objc
    public var asOther: DBXSharingListFoldersContinueErrorOther? {
        self as? DBXSharingListFoldersContinueErrorOther
    }
}

/// cursor in ListFoldersContinueArg is invalid.
@objc
public class DBXSharingListFoldersContinueErrorInvalidCursor: DBXSharingListFoldersContinueError {
    @objc
    public init() {
        let swift = Sharing.ListFoldersContinueError.invalidCursor
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXSharingListFoldersContinueErrorOther: DBXSharingListFoldersContinueError {
    @objc
    public init() {
        let swift = Sharing.ListFoldersContinueError.other
        super.init(swift: swift)
    }
}

/// Result for listFolders or listMountableFolders, depending on which endpoint was requested. Unmounted shared
/// folders can be identified by the absence of pathLower in SharedFolderMetadata.
@objc
public class DBXSharingListFoldersResult: NSObject {
    /// List of all shared folders the authenticated user has access to.
    @objc
    public var entries: [DBXSharingSharedFolderMetadata] { swift.entries.map { DBXSharingSharedFolderMetadata(swift: $0) } }
    /// Present if there are additional shared folders that have not been returned yet. Pass the cursor into the
    /// corresponding continue endpoint (either listFoldersContinue or listMountableFoldersContinue) to list
    /// additional folders.
    @objc
    public var cursor: String? { swift.cursor }

    @objc
    public init(entries: [DBXSharingSharedFolderMetadata], cursor: String?) {
        self.swift = Sharing.ListFoldersResult(entries: entries.map(\.subSwift), cursor: cursor)
    }

    let swift: Sharing.ListFoldersResult

    public init(swift: Sharing.ListFoldersResult) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible ListSharedLinksArg struct
@objc
public class DBXSharingListSharedLinksArg: NSObject {
    /// See listSharedLinks description.
    @objc
    public var path: String? { swift.path }
    /// The cursor returned by your last call to listSharedLinks.
    @objc
    public var cursor: String? { swift.cursor }
    /// See listSharedLinks description.
    @objc
    public var directOnly: NSNumber? { swift.directOnly as NSNumber? }

    @objc
    public init(path: String?, cursor: String?, directOnly: NSNumber?) {
        self.swift = Sharing.ListSharedLinksArg(path: path, cursor: cursor, directOnly: directOnly?.boolValue)
    }

    let swift: Sharing.ListSharedLinksArg

    public init(swift: Sharing.ListSharedLinksArg) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible ListSharedLinksError union
@objc
public class DBXSharingListSharedLinksError: NSObject {
    let swift: Sharing.ListSharedLinksError

    public init(swift: Sharing.ListSharedLinksError) {
        self.swift = swift
    }

    public static func factory(swift: Sharing.ListSharedLinksError) -> DBXSharingListSharedLinksError {
        switch swift {
        case .path(let swiftArg):
            let arg = DBXFilesLookupError(swift: swiftArg)
            return DBXSharingListSharedLinksErrorPath(arg)
        case .reset:
            return DBXSharingListSharedLinksErrorReset()
        case .other:
            return DBXSharingListSharedLinksErrorOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asPath: DBXSharingListSharedLinksErrorPath? {
        self as? DBXSharingListSharedLinksErrorPath
    }

    @objc
    public var asReset: DBXSharingListSharedLinksErrorReset? {
        self as? DBXSharingListSharedLinksErrorReset
    }

    @objc
    public var asOther: DBXSharingListSharedLinksErrorOther? {
        self as? DBXSharingListSharedLinksErrorOther
    }
}

/// An unspecified error.
@objc
public class DBXSharingListSharedLinksErrorPath: DBXSharingListSharedLinksError {
    @objc
    public var path: DBXFilesLookupError

    @objc
    public init(_ arg: DBXFilesLookupError) {
        self.path = arg
        let swift = Sharing.ListSharedLinksError.path(arg.swift)
        super.init(swift: swift)
    }
}

/// Indicates that the cursor has been invalidated. Call listSharedLinks to obtain a new cursor.
@objc
public class DBXSharingListSharedLinksErrorReset: DBXSharingListSharedLinksError {
    @objc
    public init() {
        let swift = Sharing.ListSharedLinksError.reset
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXSharingListSharedLinksErrorOther: DBXSharingListSharedLinksError {
    @objc
    public init() {
        let swift = Sharing.ListSharedLinksError.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible ListSharedLinksResult struct
@objc
public class DBXSharingListSharedLinksResult: NSObject {
    /// Shared links applicable to the path argument.
    @objc
    public var links: [DBXSharingSharedLinkMetadata] {
        swift.links.map {
            DBXSharingSharedLinkMetadata.wrapPreservingSubtypes(swift: $0)
        }
    }

    /// Is true if there are additional shared links that have not been returned yet. Pass the cursor into
    /// listSharedLinks to retrieve them.
    @objc
    public var hasMore: NSNumber { swift.hasMore as NSNumber }
    /// Pass the cursor into listSharedLinks to obtain the additional links. Cursor is returned only if no path is
    /// given.
    @objc
    public var cursor: String? { swift.cursor }

    @objc
    public init(links: [DBXSharingSharedLinkMetadata], hasMore: NSNumber, cursor: String?) {
        self.swift = Sharing.ListSharedLinksResult(links: links.map(\.swift), hasMore: hasMore.boolValue, cursor: cursor)
    }

    let swift: Sharing.ListSharedLinksResult

    public init(swift: Sharing.ListSharedLinksResult) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Contains information about a member's access level to content after an operation.
@objc
public class DBXSharingMemberAccessLevelResult: NSObject {
    /// The member still has this level of access to the content through a parent folder.
    @objc
    public var accessLevel: DBXSharingAccessLevel? { guard let swift = swift.accessLevel else { return nil }
        return DBXSharingAccessLevel(swift: swift)
    }

    /// A localized string with additional information about why the user has this access level to the content.
    @objc
    public var warning: String? { swift.warning }
    /// The parent folders that a member has access to. The field is present if the user has access to the first
    /// parent folder where the member gains access.
    @objc
    public var accessDetails: [DBXSharingParentFolderAccessInfo]? { swift.accessDetails?.map { DBXSharingParentFolderAccessInfo(swift: $0) } }

    @objc
    public init(accessLevel: DBXSharingAccessLevel?, warning: String?, accessDetails: [DBXSharingParentFolderAccessInfo]?) {
        self.swift = Sharing.MemberAccessLevelResult(accessLevel: accessLevel?.swift, warning: warning, accessDetails: accessDetails?.map(\.swift))
    }

    let swift: Sharing.MemberAccessLevelResult

    public init(swift: Sharing.MemberAccessLevelResult) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Actions that may be taken on members of a shared folder.
@objc
public class DBXSharingMemberAction: NSObject {
    let swift: Sharing.MemberAction

    public init(swift: Sharing.MemberAction) {
        self.swift = swift
    }

    public static func factory(swift: Sharing.MemberAction) -> DBXSharingMemberAction {
        switch swift {
        case .leaveACopy:
            return DBXSharingMemberActionLeaveACopy()
        case .makeEditor:
            return DBXSharingMemberActionMakeEditor()
        case .makeOwner:
            return DBXSharingMemberActionMakeOwner()
        case .makeViewer:
            return DBXSharingMemberActionMakeViewer()
        case .makeViewerNoComment:
            return DBXSharingMemberActionMakeViewerNoComment()
        case .remove:
            return DBXSharingMemberActionRemove()
        case .other:
            return DBXSharingMemberActionOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asLeaveACopy: DBXSharingMemberActionLeaveACopy? {
        self as? DBXSharingMemberActionLeaveACopy
    }

    @objc
    public var asMakeEditor: DBXSharingMemberActionMakeEditor? {
        self as? DBXSharingMemberActionMakeEditor
    }

    @objc
    public var asMakeOwner: DBXSharingMemberActionMakeOwner? {
        self as? DBXSharingMemberActionMakeOwner
    }

    @objc
    public var asMakeViewer: DBXSharingMemberActionMakeViewer? {
        self as? DBXSharingMemberActionMakeViewer
    }

    @objc
    public var asMakeViewerNoComment: DBXSharingMemberActionMakeViewerNoComment? {
        self as? DBXSharingMemberActionMakeViewerNoComment
    }

    @objc
    public var asRemove: DBXSharingMemberActionRemove? {
        self as? DBXSharingMemberActionRemove
    }

    @objc
    public var asOther: DBXSharingMemberActionOther? {
        self as? DBXSharingMemberActionOther
    }
}

/// Allow the member to keep a copy of the folder when removing.
@objc
public class DBXSharingMemberActionLeaveACopy: DBXSharingMemberAction {
    @objc
    public init() {
        let swift = Sharing.MemberAction.leaveACopy
        super.init(swift: swift)
    }
}

/// Make the member an editor of the folder.
@objc
public class DBXSharingMemberActionMakeEditor: DBXSharingMemberAction {
    @objc
    public init() {
        let swift = Sharing.MemberAction.makeEditor
        super.init(swift: swift)
    }
}

/// Make the member an owner of the folder.
@objc
public class DBXSharingMemberActionMakeOwner: DBXSharingMemberAction {
    @objc
    public init() {
        let swift = Sharing.MemberAction.makeOwner
        super.init(swift: swift)
    }
}

/// Make the member a viewer of the folder.
@objc
public class DBXSharingMemberActionMakeViewer: DBXSharingMemberAction {
    @objc
    public init() {
        let swift = Sharing.MemberAction.makeViewer
        super.init(swift: swift)
    }
}

/// Make the member a viewer of the folder without commenting permissions.
@objc
public class DBXSharingMemberActionMakeViewerNoComment: DBXSharingMemberAction {
    @objc
    public init() {
        let swift = Sharing.MemberAction.makeViewerNoComment
        super.init(swift: swift)
    }
}

/// Remove the member from the folder.
@objc
public class DBXSharingMemberActionRemove: DBXSharingMemberAction {
    @objc
    public init() {
        let swift = Sharing.MemberAction.remove
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXSharingMemberActionOther: DBXSharingMemberAction {
    @objc
    public init() {
        let swift = Sharing.MemberAction.other
        super.init(swift: swift)
    }
}

/// Whether the user is allowed to take the action on the associated member.
@objc
public class DBXSharingMemberPermission: NSObject {
    /// The action that the user may wish to take on the member.
    @objc
    public var action: DBXSharingMemberAction { DBXSharingMemberAction(swift: swift.action) }
    /// True if the user is allowed to take the action.
    @objc
    public var allow: NSNumber { swift.allow as NSNumber }
    /// The reason why the user is denied the permission. Not present if the action is allowed.
    @objc
    public var reason: DBXSharingPermissionDeniedReason? { guard let swift = swift.reason else { return nil }
        return DBXSharingPermissionDeniedReason(swift: swift)
    }

    @objc
    public init(action: DBXSharingMemberAction, allow: NSNumber, reason: DBXSharingPermissionDeniedReason?) {
        self.swift = Sharing.MemberPermission(action: action.swift, allow: allow.boolValue, reason: reason?.swift)
    }

    let swift: Sharing.MemberPermission

    public init(swift: Sharing.MemberPermission) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Policy governing who can be a member of a shared folder. Only applicable to folders owned by a user on a team.
@objc
public class DBXSharingMemberPolicy: NSObject {
    let swift: Sharing.MemberPolicy

    public init(swift: Sharing.MemberPolicy) {
        self.swift = swift
    }

    public static func factory(swift: Sharing.MemberPolicy) -> DBXSharingMemberPolicy {
        switch swift {
        case .team:
            return DBXSharingMemberPolicyTeam()
        case .anyone:
            return DBXSharingMemberPolicyAnyone()
        case .other:
            return DBXSharingMemberPolicyOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asTeam: DBXSharingMemberPolicyTeam? {
        self as? DBXSharingMemberPolicyTeam
    }

    @objc
    public var asAnyone: DBXSharingMemberPolicyAnyone? {
        self as? DBXSharingMemberPolicyAnyone
    }

    @objc
    public var asOther: DBXSharingMemberPolicyOther? {
        self as? DBXSharingMemberPolicyOther
    }
}

/// Only a teammate can become a member.
@objc
public class DBXSharingMemberPolicyTeam: DBXSharingMemberPolicy {
    @objc
    public init() {
        let swift = Sharing.MemberPolicy.team
        super.init(swift: swift)
    }
}

/// Anyone can become a member.
@objc
public class DBXSharingMemberPolicyAnyone: DBXSharingMemberPolicy {
    @objc
    public init() {
        let swift = Sharing.MemberPolicy.anyone
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXSharingMemberPolicyOther: DBXSharingMemberPolicy {
    @objc
    public init() {
        let swift = Sharing.MemberPolicy.other
        super.init(swift: swift)
    }
}

/// Includes different ways to identify a member of a shared folder.
@objc
public class DBXSharingMemberSelector: NSObject {
    let swift: Sharing.MemberSelector

    public init(swift: Sharing.MemberSelector) {
        self.swift = swift
    }

    public static func factory(swift: Sharing.MemberSelector) -> DBXSharingMemberSelector {
        switch swift {
        case .dropboxId(let swiftArg):
            let arg = swiftArg
            return DBXSharingMemberSelectorDropboxId(arg)
        case .email(let swiftArg):
            let arg = swiftArg
            return DBXSharingMemberSelectorEmail(arg)
        case .other:
            return DBXSharingMemberSelectorOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asDropboxId: DBXSharingMemberSelectorDropboxId? {
        self as? DBXSharingMemberSelectorDropboxId
    }

    @objc
    public var asEmail: DBXSharingMemberSelectorEmail? {
        self as? DBXSharingMemberSelectorEmail
    }

    @objc
    public var asOther: DBXSharingMemberSelectorOther? {
        self as? DBXSharingMemberSelectorOther
    }
}

/// Dropbox account, team member, or group ID of member.
@objc
public class DBXSharingMemberSelectorDropboxId: DBXSharingMemberSelector {
    @objc
    public var dropboxId: String

    @objc
    public init(_ arg: String) {
        self.dropboxId = arg
        let swift = Sharing.MemberSelector.dropboxId(arg)
        super.init(swift: swift)
    }
}

/// Email address of member.
@objc
public class DBXSharingMemberSelectorEmail: DBXSharingMemberSelector {
    @objc
    public var email: String

    @objc
    public init(_ arg: String) {
        self.email = arg
        let swift = Sharing.MemberSelector.email(arg)
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXSharingMemberSelectorOther: DBXSharingMemberSelector {
    @objc
    public init() {
        let swift = Sharing.MemberSelector.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible ModifySharedLinkSettingsArgs struct
@objc
public class DBXSharingModifySharedLinkSettingsArgs: NSObject {
    /// URL of the shared link to change its settings.
    @objc
    public var url: String { swift.url }
    /// Set of settings for the shared link.
    @objc
    public var settings: DBXSharingSharedLinkSettings { DBXSharingSharedLinkSettings(swift: swift.settings) }
    /// If set to true, removes the expiration of the shared link.
    @objc
    public var removeExpiration: NSNumber { swift.removeExpiration as NSNumber }

    @objc
    public init(url: String, settings: DBXSharingSharedLinkSettings, removeExpiration: NSNumber) {
        self.swift = Sharing.ModifySharedLinkSettingsArgs(url: url, settings: settings.swift, removeExpiration: removeExpiration.boolValue)
    }

    let swift: Sharing.ModifySharedLinkSettingsArgs

    public init(swift: Sharing.ModifySharedLinkSettingsArgs) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible ModifySharedLinkSettingsError union
@objc
public class DBXSharingModifySharedLinkSettingsError: NSObject {
    let swift: Sharing.ModifySharedLinkSettingsError

    public init(swift: Sharing.ModifySharedLinkSettingsError) {
        self.swift = swift
    }

    public static func factory(swift: Sharing.ModifySharedLinkSettingsError) -> DBXSharingModifySharedLinkSettingsError {
        switch swift {
        case .sharedLinkNotFound:
            return DBXSharingModifySharedLinkSettingsErrorSharedLinkNotFound()
        case .sharedLinkAccessDenied:
            return DBXSharingModifySharedLinkSettingsErrorSharedLinkAccessDenied()
        case .unsupportedLinkType:
            return DBXSharingModifySharedLinkSettingsErrorUnsupportedLinkType()
        case .other:
            return DBXSharingModifySharedLinkSettingsErrorOther()
        case .settingsError(let swiftArg):
            let arg = DBXSharingSharedLinkSettingsError(swift: swiftArg)
            return DBXSharingModifySharedLinkSettingsErrorSettingsError(arg)
        case .emailNotVerified:
            return DBXSharingModifySharedLinkSettingsErrorEmailNotVerified()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asSharedLinkNotFound: DBXSharingModifySharedLinkSettingsErrorSharedLinkNotFound? {
        self as? DBXSharingModifySharedLinkSettingsErrorSharedLinkNotFound
    }

    @objc
    public var asSharedLinkAccessDenied: DBXSharingModifySharedLinkSettingsErrorSharedLinkAccessDenied? {
        self as? DBXSharingModifySharedLinkSettingsErrorSharedLinkAccessDenied
    }

    @objc
    public var asUnsupportedLinkType: DBXSharingModifySharedLinkSettingsErrorUnsupportedLinkType? {
        self as? DBXSharingModifySharedLinkSettingsErrorUnsupportedLinkType
    }

    @objc
    public var asOther: DBXSharingModifySharedLinkSettingsErrorOther? {
        self as? DBXSharingModifySharedLinkSettingsErrorOther
    }

    @objc
    public var asSettingsError: DBXSharingModifySharedLinkSettingsErrorSettingsError? {
        self as? DBXSharingModifySharedLinkSettingsErrorSettingsError
    }

    @objc
    public var asEmailNotVerified: DBXSharingModifySharedLinkSettingsErrorEmailNotVerified? {
        self as? DBXSharingModifySharedLinkSettingsErrorEmailNotVerified
    }
}

/// The shared link wasn't found.
@objc
public class DBXSharingModifySharedLinkSettingsErrorSharedLinkNotFound: DBXSharingModifySharedLinkSettingsError {
    @objc
    public init() {
        let swift = Sharing.ModifySharedLinkSettingsError.sharedLinkNotFound
        super.init(swift: swift)
    }
}

/// The caller is not allowed to access this shared link.
@objc
public class DBXSharingModifySharedLinkSettingsErrorSharedLinkAccessDenied: DBXSharingModifySharedLinkSettingsError {
    @objc
    public init() {
        let swift = Sharing.ModifySharedLinkSettingsError.sharedLinkAccessDenied
        super.init(swift: swift)
    }
}

/// This type of link is not supported; use files instead.
@objc
public class DBXSharingModifySharedLinkSettingsErrorUnsupportedLinkType: DBXSharingModifySharedLinkSettingsError {
    @objc
    public init() {
        let swift = Sharing.ModifySharedLinkSettingsError.unsupportedLinkType
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXSharingModifySharedLinkSettingsErrorOther: DBXSharingModifySharedLinkSettingsError {
    @objc
    public init() {
        let swift = Sharing.ModifySharedLinkSettingsError.other
        super.init(swift: swift)
    }
}

/// There is an error with the given settings.
@objc
public class DBXSharingModifySharedLinkSettingsErrorSettingsError: DBXSharingModifySharedLinkSettingsError {
    @objc
    public var settingsError: DBXSharingSharedLinkSettingsError

    @objc
    public init(_ arg: DBXSharingSharedLinkSettingsError) {
        self.settingsError = arg
        let swift = Sharing.ModifySharedLinkSettingsError.settingsError(arg.swift)
        super.init(swift: swift)
    }
}

/// This user's email address is not verified. This functionality is only available on accounts with a verified
/// email address. Users can verify their email address here https://www.dropbox.com/help/317.
@objc
public class DBXSharingModifySharedLinkSettingsErrorEmailNotVerified: DBXSharingModifySharedLinkSettingsError {
    @objc
    public init() {
        let swift = Sharing.ModifySharedLinkSettingsError.emailNotVerified
        super.init(swift: swift)
    }
}

/// Objective-C compatible MountFolderArg struct
@objc
public class DBXSharingMountFolderArg: NSObject {
    /// The ID of the shared folder to mount.
    @objc
    public var sharedFolderId: String { swift.sharedFolderId }

    @objc
    public init(sharedFolderId: String) {
        self.swift = Sharing.MountFolderArg(sharedFolderId: sharedFolderId)
    }

    let swift: Sharing.MountFolderArg

    public init(swift: Sharing.MountFolderArg) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible MountFolderError union
@objc
public class DBXSharingMountFolderError: NSObject {
    let swift: Sharing.MountFolderError

    public init(swift: Sharing.MountFolderError) {
        self.swift = swift
    }

    public static func factory(swift: Sharing.MountFolderError) -> DBXSharingMountFolderError {
        switch swift {
        case .accessError(let swiftArg):
            let arg = DBXSharingSharedFolderAccessError(swift: swiftArg)
            return DBXSharingMountFolderErrorAccessError(arg)
        case .insideSharedFolder:
            return DBXSharingMountFolderErrorInsideSharedFolder()
        case .insufficientQuota(let swiftArg):
            let arg = DBXSharingInsufficientQuotaAmounts(swift: swiftArg)
            return DBXSharingMountFolderErrorInsufficientQuota(arg)
        case .alreadyMounted:
            return DBXSharingMountFolderErrorAlreadyMounted()
        case .noPermission:
            return DBXSharingMountFolderErrorNoPermission()
        case .notMountable:
            return DBXSharingMountFolderErrorNotMountable()
        case .other:
            return DBXSharingMountFolderErrorOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asAccessError: DBXSharingMountFolderErrorAccessError? {
        self as? DBXSharingMountFolderErrorAccessError
    }

    @objc
    public var asInsideSharedFolder: DBXSharingMountFolderErrorInsideSharedFolder? {
        self as? DBXSharingMountFolderErrorInsideSharedFolder
    }

    @objc
    public var asInsufficientQuota: DBXSharingMountFolderErrorInsufficientQuota? {
        self as? DBXSharingMountFolderErrorInsufficientQuota
    }

    @objc
    public var asAlreadyMounted: DBXSharingMountFolderErrorAlreadyMounted? {
        self as? DBXSharingMountFolderErrorAlreadyMounted
    }

    @objc
    public var asNoPermission: DBXSharingMountFolderErrorNoPermission? {
        self as? DBXSharingMountFolderErrorNoPermission
    }

    @objc
    public var asNotMountable: DBXSharingMountFolderErrorNotMountable? {
        self as? DBXSharingMountFolderErrorNotMountable
    }

    @objc
    public var asOther: DBXSharingMountFolderErrorOther? {
        self as? DBXSharingMountFolderErrorOther
    }
}

/// An unspecified error.
@objc
public class DBXSharingMountFolderErrorAccessError: DBXSharingMountFolderError {
    @objc
    public var accessError: DBXSharingSharedFolderAccessError

    @objc
    public init(_ arg: DBXSharingSharedFolderAccessError) {
        self.accessError = arg
        let swift = Sharing.MountFolderError.accessError(arg.swift)
        super.init(swift: swift)
    }
}

/// Mounting would cause a shared folder to be inside another, which is disallowed.
@objc
public class DBXSharingMountFolderErrorInsideSharedFolder: DBXSharingMountFolderError {
    @objc
    public init() {
        let swift = Sharing.MountFolderError.insideSharedFolder
        super.init(swift: swift)
    }
}

/// The current user does not have enough space to mount the shared folder.
@objc
public class DBXSharingMountFolderErrorInsufficientQuota: DBXSharingMountFolderError {
    @objc
    public var insufficientQuota: DBXSharingInsufficientQuotaAmounts

    @objc
    public init(_ arg: DBXSharingInsufficientQuotaAmounts) {
        self.insufficientQuota = arg
        let swift = Sharing.MountFolderError.insufficientQuota(arg.swift)
        super.init(swift: swift)
    }
}

/// The shared folder is already mounted.
@objc
public class DBXSharingMountFolderErrorAlreadyMounted: DBXSharingMountFolderError {
    @objc
    public init() {
        let swift = Sharing.MountFolderError.alreadyMounted
        super.init(swift: swift)
    }
}

/// The current user does not have permission to perform this action.
@objc
public class DBXSharingMountFolderErrorNoPermission: DBXSharingMountFolderError {
    @objc
    public init() {
        let swift = Sharing.MountFolderError.noPermission
        super.init(swift: swift)
    }
}

/// The shared folder is not mountable. One example where this can occur is when the shared folder belongs
/// within a team folder in the user's Dropbox.
@objc
public class DBXSharingMountFolderErrorNotMountable: DBXSharingMountFolderError {
    @objc
    public init() {
        let swift = Sharing.MountFolderError.notMountable
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXSharingMountFolderErrorOther: DBXSharingMountFolderError {
    @objc
    public init() {
        let swift = Sharing.MountFolderError.other
        super.init(swift: swift)
    }
}

/// Contains information about a parent folder that a member has access to.
@objc
public class DBXSharingParentFolderAccessInfo: NSObject {
    /// Display name for the folder.
    @objc
    public var folderName: String { swift.folderName }
    /// The identifier of the parent shared folder.
    @objc
    public var sharedFolderId: String { swift.sharedFolderId }
    /// The user's permissions for the parent shared folder.
    @objc
    public var permissions: [DBXSharingMemberPermission] { swift.permissions.map { DBXSharingMemberPermission(swift: $0) } }
    /// The full path to the parent shared folder relative to the acting user's root.
    @objc
    public var path: String { swift.path }

    @objc
    public init(folderName: String, sharedFolderId: String, permissions: [DBXSharingMemberPermission], path: String) {
        self.swift = Sharing.ParentFolderAccessInfo(folderName: folderName, sharedFolderId: sharedFolderId, permissions: permissions.map(\.swift), path: path)
    }

    let swift: Sharing.ParentFolderAccessInfo

    public init(swift: Sharing.ParentFolderAccessInfo) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Metadata for a path-based shared link.
@objc
public class DBXSharingPathLinkMetadata: DBXSharingLinkMetadata {
    /// Path in user's Dropbox.
    @objc
    public var path: String { subSwift.path }

    @objc
    public init(url: String, visibility: DBXSharingVisibility, path: String, expires: Date?) {
        let swift = Sharing.PathLinkMetadata(url: url, visibility: visibility.swift, path: path, expires: expires)
        self.subSwift = swift
        super.init(swift: swift)
    }

    let subSwift: Sharing.PathLinkMetadata

    public init(swift: Sharing.PathLinkMetadata) {
        self.subSwift = swift
        super.init(swift: swift)
    }

    @objc
    public override var description: String { subSwift.description }
}

/// Flag to indicate pending upload default (for linking to not-yet-existing paths).
@objc
public class DBXSharingPendingUploadMode: NSObject {
    let swift: Sharing.PendingUploadMode

    public init(swift: Sharing.PendingUploadMode) {
        self.swift = swift
    }

    public static func factory(swift: Sharing.PendingUploadMode) -> DBXSharingPendingUploadMode {
        switch swift {
        case .file:
            return DBXSharingPendingUploadModeFile()
        case .folder:
            return DBXSharingPendingUploadModeFolder()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asFile: DBXSharingPendingUploadModeFile? {
        self as? DBXSharingPendingUploadModeFile
    }

    @objc
    public var asFolder: DBXSharingPendingUploadModeFolder? {
        self as? DBXSharingPendingUploadModeFolder
    }
}

/// Assume pending uploads are files.
@objc
public class DBXSharingPendingUploadModeFile: DBXSharingPendingUploadMode {
    @objc
    public init() {
        let swift = Sharing.PendingUploadMode.file
        super.init(swift: swift)
    }
}

/// Assume pending uploads are folders.
@objc
public class DBXSharingPendingUploadModeFolder: DBXSharingPendingUploadMode {
    @objc
    public init() {
        let swift = Sharing.PendingUploadMode.folder
        super.init(swift: swift)
    }
}

/// Possible reasons the user is denied a permission.
@objc
public class DBXSharingPermissionDeniedReason: NSObject {
    let swift: Sharing.PermissionDeniedReason

    public init(swift: Sharing.PermissionDeniedReason) {
        self.swift = swift
    }

    public static func factory(swift: Sharing.PermissionDeniedReason) -> DBXSharingPermissionDeniedReason {
        switch swift {
        case .userNotSameTeamAsOwner:
            return DBXSharingPermissionDeniedReasonUserNotSameTeamAsOwner()
        case .userNotAllowedByOwner:
            return DBXSharingPermissionDeniedReasonUserNotAllowedByOwner()
        case .targetIsIndirectMember:
            return DBXSharingPermissionDeniedReasonTargetIsIndirectMember()
        case .targetIsOwner:
            return DBXSharingPermissionDeniedReasonTargetIsOwner()
        case .targetIsSelf:
            return DBXSharingPermissionDeniedReasonTargetIsSelf()
        case .targetNotActive:
            return DBXSharingPermissionDeniedReasonTargetNotActive()
        case .folderIsLimitedTeamFolder:
            return DBXSharingPermissionDeniedReasonFolderIsLimitedTeamFolder()
        case .ownerNotOnTeam:
            return DBXSharingPermissionDeniedReasonOwnerNotOnTeam()
        case .permissionDenied:
            return DBXSharingPermissionDeniedReasonPermissionDenied()
        case .restrictedByTeam:
            return DBXSharingPermissionDeniedReasonRestrictedByTeam()
        case .userAccountType:
            return DBXSharingPermissionDeniedReasonUserAccountType()
        case .userNotOnTeam:
            return DBXSharingPermissionDeniedReasonUserNotOnTeam()
        case .folderIsInsideSharedFolder:
            return DBXSharingPermissionDeniedReasonFolderIsInsideSharedFolder()
        case .restrictedByParentFolder:
            return DBXSharingPermissionDeniedReasonRestrictedByParentFolder()
        case .insufficientPlan(let swiftArg):
            let arg = DBXSharingInsufficientPlan(swift: swiftArg)
            return DBXSharingPermissionDeniedReasonInsufficientPlan(arg)
        case .other:
            return DBXSharingPermissionDeniedReasonOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asUserNotSameTeamAsOwner: DBXSharingPermissionDeniedReasonUserNotSameTeamAsOwner? {
        self as? DBXSharingPermissionDeniedReasonUserNotSameTeamAsOwner
    }

    @objc
    public var asUserNotAllowedByOwner: DBXSharingPermissionDeniedReasonUserNotAllowedByOwner? {
        self as? DBXSharingPermissionDeniedReasonUserNotAllowedByOwner
    }

    @objc
    public var asTargetIsIndirectMember: DBXSharingPermissionDeniedReasonTargetIsIndirectMember? {
        self as? DBXSharingPermissionDeniedReasonTargetIsIndirectMember
    }

    @objc
    public var asTargetIsOwner: DBXSharingPermissionDeniedReasonTargetIsOwner? {
        self as? DBXSharingPermissionDeniedReasonTargetIsOwner
    }

    @objc
    public var asTargetIsSelf: DBXSharingPermissionDeniedReasonTargetIsSelf? {
        self as? DBXSharingPermissionDeniedReasonTargetIsSelf
    }

    @objc
    public var asTargetNotActive: DBXSharingPermissionDeniedReasonTargetNotActive? {
        self as? DBXSharingPermissionDeniedReasonTargetNotActive
    }

    @objc
    public var asFolderIsLimitedTeamFolder: DBXSharingPermissionDeniedReasonFolderIsLimitedTeamFolder? {
        self as? DBXSharingPermissionDeniedReasonFolderIsLimitedTeamFolder
    }

    @objc
    public var asOwnerNotOnTeam: DBXSharingPermissionDeniedReasonOwnerNotOnTeam? {
        self as? DBXSharingPermissionDeniedReasonOwnerNotOnTeam
    }

    @objc
    public var asPermissionDenied: DBXSharingPermissionDeniedReasonPermissionDenied? {
        self as? DBXSharingPermissionDeniedReasonPermissionDenied
    }

    @objc
    public var asRestrictedByTeam: DBXSharingPermissionDeniedReasonRestrictedByTeam? {
        self as? DBXSharingPermissionDeniedReasonRestrictedByTeam
    }

    @objc
    public var asUserAccountType: DBXSharingPermissionDeniedReasonUserAccountType? {
        self as? DBXSharingPermissionDeniedReasonUserAccountType
    }

    @objc
    public var asUserNotOnTeam: DBXSharingPermissionDeniedReasonUserNotOnTeam? {
        self as? DBXSharingPermissionDeniedReasonUserNotOnTeam
    }

    @objc
    public var asFolderIsInsideSharedFolder: DBXSharingPermissionDeniedReasonFolderIsInsideSharedFolder? {
        self as? DBXSharingPermissionDeniedReasonFolderIsInsideSharedFolder
    }

    @objc
    public var asRestrictedByParentFolder: DBXSharingPermissionDeniedReasonRestrictedByParentFolder? {
        self as? DBXSharingPermissionDeniedReasonRestrictedByParentFolder
    }

    @objc
    public var asInsufficientPlan: DBXSharingPermissionDeniedReasonInsufficientPlan? {
        self as? DBXSharingPermissionDeniedReasonInsufficientPlan
    }

    @objc
    public var asOther: DBXSharingPermissionDeniedReasonOther? {
        self as? DBXSharingPermissionDeniedReasonOther
    }
}

/// User is not on the same team as the folder owner.
@objc
public class DBXSharingPermissionDeniedReasonUserNotSameTeamAsOwner: DBXSharingPermissionDeniedReason {
    @objc
    public init() {
        let swift = Sharing.PermissionDeniedReason.userNotSameTeamAsOwner
        super.init(swift: swift)
    }
}

/// User is prohibited by the owner from taking the action.
@objc
public class DBXSharingPermissionDeniedReasonUserNotAllowedByOwner: DBXSharingPermissionDeniedReason {
    @objc
    public init() {
        let swift = Sharing.PermissionDeniedReason.userNotAllowedByOwner
        super.init(swift: swift)
    }
}

/// Target is indirectly a member of the folder, for example by being part of a group.
@objc
public class DBXSharingPermissionDeniedReasonTargetIsIndirectMember: DBXSharingPermissionDeniedReason {
    @objc
    public init() {
        let swift = Sharing.PermissionDeniedReason.targetIsIndirectMember
        super.init(swift: swift)
    }
}

/// Target is the owner of the folder.
@objc
public class DBXSharingPermissionDeniedReasonTargetIsOwner: DBXSharingPermissionDeniedReason {
    @objc
    public init() {
        let swift = Sharing.PermissionDeniedReason.targetIsOwner
        super.init(swift: swift)
    }
}

/// Target is the user itself.
@objc
public class DBXSharingPermissionDeniedReasonTargetIsSelf: DBXSharingPermissionDeniedReason {
    @objc
    public init() {
        let swift = Sharing.PermissionDeniedReason.targetIsSelf
        super.init(swift: swift)
    }
}

/// Target is not an active member of the team.
@objc
public class DBXSharingPermissionDeniedReasonTargetNotActive: DBXSharingPermissionDeniedReason {
    @objc
    public init() {
        let swift = Sharing.PermissionDeniedReason.targetNotActive
        super.init(swift: swift)
    }
}

/// Folder is team folder for a limited team.
@objc
public class DBXSharingPermissionDeniedReasonFolderIsLimitedTeamFolder: DBXSharingPermissionDeniedReason {
    @objc
    public init() {
        let swift = Sharing.PermissionDeniedReason.folderIsLimitedTeamFolder
        super.init(swift: swift)
    }
}

/// The content owner needs to be on a Dropbox team to perform this action.
@objc
public class DBXSharingPermissionDeniedReasonOwnerNotOnTeam: DBXSharingPermissionDeniedReason {
    @objc
    public init() {
        let swift = Sharing.PermissionDeniedReason.ownerNotOnTeam
        super.init(swift: swift)
    }
}

/// The user does not have permission to perform this action on the link.
@objc
public class DBXSharingPermissionDeniedReasonPermissionDenied: DBXSharingPermissionDeniedReason {
    @objc
    public init() {
        let swift = Sharing.PermissionDeniedReason.permissionDenied
        super.init(swift: swift)
    }
}

/// The user's team policy prevents performing this action on the link.
@objc
public class DBXSharingPermissionDeniedReasonRestrictedByTeam: DBXSharingPermissionDeniedReason {
    @objc
    public init() {
        let swift = Sharing.PermissionDeniedReason.restrictedByTeam
        super.init(swift: swift)
    }
}

/// The user's account type does not support this action.
@objc
public class DBXSharingPermissionDeniedReasonUserAccountType: DBXSharingPermissionDeniedReason {
    @objc
    public init() {
        let swift = Sharing.PermissionDeniedReason.userAccountType
        super.init(swift: swift)
    }
}

/// The user needs to be on a Dropbox team to perform this action.
@objc
public class DBXSharingPermissionDeniedReasonUserNotOnTeam: DBXSharingPermissionDeniedReason {
    @objc
    public init() {
        let swift = Sharing.PermissionDeniedReason.userNotOnTeam
        super.init(swift: swift)
    }
}

/// Folder is inside of another shared folder.
@objc
public class DBXSharingPermissionDeniedReasonFolderIsInsideSharedFolder: DBXSharingPermissionDeniedReason {
    @objc
    public init() {
        let swift = Sharing.PermissionDeniedReason.folderIsInsideSharedFolder
        super.init(swift: swift)
    }
}

/// Policy cannot be changed due to restrictions from parent folder.
@objc
public class DBXSharingPermissionDeniedReasonRestrictedByParentFolder: DBXSharingPermissionDeniedReason {
    @objc
    public init() {
        let swift = Sharing.PermissionDeniedReason.restrictedByParentFolder
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXSharingPermissionDeniedReasonInsufficientPlan: DBXSharingPermissionDeniedReason {
    @objc
    public var insufficientPlan: DBXSharingInsufficientPlan

    @objc
    public init(_ arg: DBXSharingInsufficientPlan) {
        self.insufficientPlan = arg
        let swift = Sharing.PermissionDeniedReason.insufficientPlan(arg.swift)
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXSharingPermissionDeniedReasonOther: DBXSharingPermissionDeniedReason {
    @objc
    public init() {
        let swift = Sharing.PermissionDeniedReason.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible RelinquishFileMembershipArg struct
@objc
public class DBXSharingRelinquishFileMembershipArg: NSObject {
    /// The path or id for the file.
    @objc
    public var file: String { swift.file }

    @objc
    public init(file: String) {
        self.swift = Sharing.RelinquishFileMembershipArg(file: file)
    }

    let swift: Sharing.RelinquishFileMembershipArg

    public init(swift: Sharing.RelinquishFileMembershipArg) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible RelinquishFileMembershipError union
@objc
public class DBXSharingRelinquishFileMembershipError: NSObject {
    let swift: Sharing.RelinquishFileMembershipError

    public init(swift: Sharing.RelinquishFileMembershipError) {
        self.swift = swift
    }

    public static func factory(swift: Sharing.RelinquishFileMembershipError) -> DBXSharingRelinquishFileMembershipError {
        switch swift {
        case .accessError(let swiftArg):
            let arg = DBXSharingSharingFileAccessError(swift: swiftArg)
            return DBXSharingRelinquishFileMembershipErrorAccessError(arg)
        case .groupAccess:
            return DBXSharingRelinquishFileMembershipErrorGroupAccess()
        case .noPermission:
            return DBXSharingRelinquishFileMembershipErrorNoPermission()
        case .other:
            return DBXSharingRelinquishFileMembershipErrorOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asAccessError: DBXSharingRelinquishFileMembershipErrorAccessError? {
        self as? DBXSharingRelinquishFileMembershipErrorAccessError
    }

    @objc
    public var asGroupAccess: DBXSharingRelinquishFileMembershipErrorGroupAccess? {
        self as? DBXSharingRelinquishFileMembershipErrorGroupAccess
    }

    @objc
    public var asNoPermission: DBXSharingRelinquishFileMembershipErrorNoPermission? {
        self as? DBXSharingRelinquishFileMembershipErrorNoPermission
    }

    @objc
    public var asOther: DBXSharingRelinquishFileMembershipErrorOther? {
        self as? DBXSharingRelinquishFileMembershipErrorOther
    }
}

/// An unspecified error.
@objc
public class DBXSharingRelinquishFileMembershipErrorAccessError: DBXSharingRelinquishFileMembershipError {
    @objc
    public var accessError: DBXSharingSharingFileAccessError

    @objc
    public init(_ arg: DBXSharingSharingFileAccessError) {
        self.accessError = arg
        let swift = Sharing.RelinquishFileMembershipError.accessError(arg.swift)
        super.init(swift: swift)
    }
}

/// The current user has access to the shared file via a group.  You can't relinquish membership to a file
/// shared via groups.
@objc
public class DBXSharingRelinquishFileMembershipErrorGroupAccess: DBXSharingRelinquishFileMembershipError {
    @objc
    public init() {
        let swift = Sharing.RelinquishFileMembershipError.groupAccess
        super.init(swift: swift)
    }
}

/// The current user does not have permission to perform this action.
@objc
public class DBXSharingRelinquishFileMembershipErrorNoPermission: DBXSharingRelinquishFileMembershipError {
    @objc
    public init() {
        let swift = Sharing.RelinquishFileMembershipError.noPermission
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXSharingRelinquishFileMembershipErrorOther: DBXSharingRelinquishFileMembershipError {
    @objc
    public init() {
        let swift = Sharing.RelinquishFileMembershipError.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible RelinquishFolderMembershipArg struct
@objc
public class DBXSharingRelinquishFolderMembershipArg: NSObject {
    /// The ID for the shared folder.
    @objc
    public var sharedFolderId: String { swift.sharedFolderId }
    /// Keep a copy of the folder's contents upon relinquishing membership. This must be set to false when the
    /// folder is within a team folder or another shared folder.
    @objc
    public var leaveACopy: NSNumber { swift.leaveACopy as NSNumber }

    @objc
    public init(sharedFolderId: String, leaveACopy: NSNumber) {
        self.swift = Sharing.RelinquishFolderMembershipArg(sharedFolderId: sharedFolderId, leaveACopy: leaveACopy.boolValue)
    }

    let swift: Sharing.RelinquishFolderMembershipArg

    public init(swift: Sharing.RelinquishFolderMembershipArg) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible RelinquishFolderMembershipError union
@objc
public class DBXSharingRelinquishFolderMembershipError: NSObject {
    let swift: Sharing.RelinquishFolderMembershipError

    public init(swift: Sharing.RelinquishFolderMembershipError) {
        self.swift = swift
    }

    public static func factory(swift: Sharing.RelinquishFolderMembershipError) -> DBXSharingRelinquishFolderMembershipError {
        switch swift {
        case .accessError(let swiftArg):
            let arg = DBXSharingSharedFolderAccessError(swift: swiftArg)
            return DBXSharingRelinquishFolderMembershipErrorAccessError(arg)
        case .folderOwner:
            return DBXSharingRelinquishFolderMembershipErrorFolderOwner()
        case .mounted:
            return DBXSharingRelinquishFolderMembershipErrorMounted()
        case .groupAccess:
            return DBXSharingRelinquishFolderMembershipErrorGroupAccess()
        case .teamFolder:
            return DBXSharingRelinquishFolderMembershipErrorTeamFolder()
        case .noPermission:
            return DBXSharingRelinquishFolderMembershipErrorNoPermission()
        case .noExplicitAccess:
            return DBXSharingRelinquishFolderMembershipErrorNoExplicitAccess()
        case .other:
            return DBXSharingRelinquishFolderMembershipErrorOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asAccessError: DBXSharingRelinquishFolderMembershipErrorAccessError? {
        self as? DBXSharingRelinquishFolderMembershipErrorAccessError
    }

    @objc
    public var asFolderOwner: DBXSharingRelinquishFolderMembershipErrorFolderOwner? {
        self as? DBXSharingRelinquishFolderMembershipErrorFolderOwner
    }

    @objc
    public var asMounted: DBXSharingRelinquishFolderMembershipErrorMounted? {
        self as? DBXSharingRelinquishFolderMembershipErrorMounted
    }

    @objc
    public var asGroupAccess: DBXSharingRelinquishFolderMembershipErrorGroupAccess? {
        self as? DBXSharingRelinquishFolderMembershipErrorGroupAccess
    }

    @objc
    public var asTeamFolder: DBXSharingRelinquishFolderMembershipErrorTeamFolder? {
        self as? DBXSharingRelinquishFolderMembershipErrorTeamFolder
    }

    @objc
    public var asNoPermission: DBXSharingRelinquishFolderMembershipErrorNoPermission? {
        self as? DBXSharingRelinquishFolderMembershipErrorNoPermission
    }

    @objc
    public var asNoExplicitAccess: DBXSharingRelinquishFolderMembershipErrorNoExplicitAccess? {
        self as? DBXSharingRelinquishFolderMembershipErrorNoExplicitAccess
    }

    @objc
    public var asOther: DBXSharingRelinquishFolderMembershipErrorOther? {
        self as? DBXSharingRelinquishFolderMembershipErrorOther
    }
}

/// An unspecified error.
@objc
public class DBXSharingRelinquishFolderMembershipErrorAccessError: DBXSharingRelinquishFolderMembershipError {
    @objc
    public var accessError: DBXSharingSharedFolderAccessError

    @objc
    public init(_ arg: DBXSharingSharedFolderAccessError) {
        self.accessError = arg
        let swift = Sharing.RelinquishFolderMembershipError.accessError(arg.swift)
        super.init(swift: swift)
    }
}

/// The current user is the owner of the shared folder. Owners cannot relinquish membership to their own
/// folders. Try unsharing or transferring ownership first.
@objc
public class DBXSharingRelinquishFolderMembershipErrorFolderOwner: DBXSharingRelinquishFolderMembershipError {
    @objc
    public init() {
        let swift = Sharing.RelinquishFolderMembershipError.folderOwner
        super.init(swift: swift)
    }
}

/// The shared folder is currently mounted.  Unmount the shared folder before relinquishing membership.
@objc
public class DBXSharingRelinquishFolderMembershipErrorMounted: DBXSharingRelinquishFolderMembershipError {
    @objc
    public init() {
        let swift = Sharing.RelinquishFolderMembershipError.mounted
        super.init(swift: swift)
    }
}

/// The current user has access to the shared folder via a group.  You can't relinquish membership to folders
/// shared via groups.
@objc
public class DBXSharingRelinquishFolderMembershipErrorGroupAccess: DBXSharingRelinquishFolderMembershipError {
    @objc
    public init() {
        let swift = Sharing.RelinquishFolderMembershipError.groupAccess
        super.init(swift: swift)
    }
}

/// This action cannot be performed on a team shared folder.
@objc
public class DBXSharingRelinquishFolderMembershipErrorTeamFolder: DBXSharingRelinquishFolderMembershipError {
    @objc
    public init() {
        let swift = Sharing.RelinquishFolderMembershipError.teamFolder
        super.init(swift: swift)
    }
}

/// The current user does not have permission to perform this action.
@objc
public class DBXSharingRelinquishFolderMembershipErrorNoPermission: DBXSharingRelinquishFolderMembershipError {
    @objc
    public init() {
        let swift = Sharing.RelinquishFolderMembershipError.noPermission
        super.init(swift: swift)
    }
}

/// The current user only has inherited access to the shared folder.  You can't relinquish inherited membership
/// to folders.
@objc
public class DBXSharingRelinquishFolderMembershipErrorNoExplicitAccess: DBXSharingRelinquishFolderMembershipError {
    @objc
    public init() {
        let swift = Sharing.RelinquishFolderMembershipError.noExplicitAccess
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXSharingRelinquishFolderMembershipErrorOther: DBXSharingRelinquishFolderMembershipError {
    @objc
    public init() {
        let swift = Sharing.RelinquishFolderMembershipError.other
        super.init(swift: swift)
    }
}

/// Arguments for removeFileMember2.
@objc
public class DBXSharingRemoveFileMemberArg: NSObject {
    /// File from which to remove members.
    @objc
    public var file: String { swift.file }
    /// Member to remove from this file. Note that even if an email is specified, it may result in the removal of a
    /// user (not an invitee) if the user's main account corresponds to that email address.
    @objc
    public var member: DBXSharingMemberSelector { DBXSharingMemberSelector(swift: swift.member) }

    @objc
    public init(file: String, member: DBXSharingMemberSelector) {
        self.swift = Sharing.RemoveFileMemberArg(file: file, member: member.swift)
    }

    let swift: Sharing.RemoveFileMemberArg

    public init(swift: Sharing.RemoveFileMemberArg) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Errors for removeFileMember2.
@objc
public class DBXSharingRemoveFileMemberError: NSObject {
    let swift: Sharing.RemoveFileMemberError

    public init(swift: Sharing.RemoveFileMemberError) {
        self.swift = swift
    }

    public static func factory(swift: Sharing.RemoveFileMemberError) -> DBXSharingRemoveFileMemberError {
        switch swift {
        case .userError(let swiftArg):
            let arg = DBXSharingSharingUserError(swift: swiftArg)
            return DBXSharingRemoveFileMemberErrorUserError(arg)
        case .accessError(let swiftArg):
            let arg = DBXSharingSharingFileAccessError(swift: swiftArg)
            return DBXSharingRemoveFileMemberErrorAccessError(arg)
        case .noExplicitAccess(let swiftArg):
            let arg = DBXSharingMemberAccessLevelResult(swift: swiftArg)
            return DBXSharingRemoveFileMemberErrorNoExplicitAccess(arg)
        case .other:
            return DBXSharingRemoveFileMemberErrorOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asUserError: DBXSharingRemoveFileMemberErrorUserError? {
        self as? DBXSharingRemoveFileMemberErrorUserError
    }

    @objc
    public var asAccessError: DBXSharingRemoveFileMemberErrorAccessError? {
        self as? DBXSharingRemoveFileMemberErrorAccessError
    }

    @objc
    public var asNoExplicitAccess: DBXSharingRemoveFileMemberErrorNoExplicitAccess? {
        self as? DBXSharingRemoveFileMemberErrorNoExplicitAccess
    }

    @objc
    public var asOther: DBXSharingRemoveFileMemberErrorOther? {
        self as? DBXSharingRemoveFileMemberErrorOther
    }
}

/// An unspecified error.
@objc
public class DBXSharingRemoveFileMemberErrorUserError: DBXSharingRemoveFileMemberError {
    @objc
    public var userError: DBXSharingSharingUserError

    @objc
    public init(_ arg: DBXSharingSharingUserError) {
        self.userError = arg
        let swift = Sharing.RemoveFileMemberError.userError(arg.swift)
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXSharingRemoveFileMemberErrorAccessError: DBXSharingRemoveFileMemberError {
    @objc
    public var accessError: DBXSharingSharingFileAccessError

    @objc
    public init(_ arg: DBXSharingSharingFileAccessError) {
        self.accessError = arg
        let swift = Sharing.RemoveFileMemberError.accessError(arg.swift)
        super.init(swift: swift)
    }
}

/// This member does not have explicit access to the file and therefore cannot be removed. The return value is
/// the access that a user might have to the file from a parent folder.
@objc
public class DBXSharingRemoveFileMemberErrorNoExplicitAccess: DBXSharingRemoveFileMemberError {
    @objc
    public var noExplicitAccess: DBXSharingMemberAccessLevelResult

    @objc
    public init(_ arg: DBXSharingMemberAccessLevelResult) {
        self.noExplicitAccess = arg
        let swift = Sharing.RemoveFileMemberError.noExplicitAccess(arg.swift)
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXSharingRemoveFileMemberErrorOther: DBXSharingRemoveFileMemberError {
    @objc
    public init() {
        let swift = Sharing.RemoveFileMemberError.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible RemoveFolderMemberArg struct
@objc
public class DBXSharingRemoveFolderMemberArg: NSObject {
    /// The ID for the shared folder.
    @objc
    public var sharedFolderId: String { swift.sharedFolderId }
    /// The member to remove from the folder.
    @objc
    public var member: DBXSharingMemberSelector { DBXSharingMemberSelector(swift: swift.member) }
    /// If true, the removed user will keep their copy of the folder after it's unshared, assuming it was mounted.
    /// Otherwise, it will be removed from their Dropbox. This must be set to false when removing a group, or
    /// when the folder is within a team folder or another shared folder.
    @objc
    public var leaveACopy: NSNumber { swift.leaveACopy as NSNumber }

    @objc
    public init(sharedFolderId: String, member: DBXSharingMemberSelector, leaveACopy: NSNumber) {
        self.swift = Sharing.RemoveFolderMemberArg(sharedFolderId: sharedFolderId, member: member.swift, leaveACopy: leaveACopy.boolValue)
    }

    let swift: Sharing.RemoveFolderMemberArg

    public init(swift: Sharing.RemoveFolderMemberArg) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible RemoveFolderMemberError union
@objc
public class DBXSharingRemoveFolderMemberError: NSObject {
    let swift: Sharing.RemoveFolderMemberError

    public init(swift: Sharing.RemoveFolderMemberError) {
        self.swift = swift
    }

    public static func factory(swift: Sharing.RemoveFolderMemberError) -> DBXSharingRemoveFolderMemberError {
        switch swift {
        case .accessError(let swiftArg):
            let arg = DBXSharingSharedFolderAccessError(swift: swiftArg)
            return DBXSharingRemoveFolderMemberErrorAccessError(arg)
        case .memberError(let swiftArg):
            let arg = DBXSharingSharedFolderMemberError(swift: swiftArg)
            return DBXSharingRemoveFolderMemberErrorMemberError(arg)
        case .folderOwner:
            return DBXSharingRemoveFolderMemberErrorFolderOwner()
        case .groupAccess:
            return DBXSharingRemoveFolderMemberErrorGroupAccess()
        case .teamFolder:
            return DBXSharingRemoveFolderMemberErrorTeamFolder()
        case .noPermission:
            return DBXSharingRemoveFolderMemberErrorNoPermission()
        case .tooManyFiles:
            return DBXSharingRemoveFolderMemberErrorTooManyFiles()
        case .other:
            return DBXSharingRemoveFolderMemberErrorOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asAccessError: DBXSharingRemoveFolderMemberErrorAccessError? {
        self as? DBXSharingRemoveFolderMemberErrorAccessError
    }

    @objc
    public var asMemberError: DBXSharingRemoveFolderMemberErrorMemberError? {
        self as? DBXSharingRemoveFolderMemberErrorMemberError
    }

    @objc
    public var asFolderOwner: DBXSharingRemoveFolderMemberErrorFolderOwner? {
        self as? DBXSharingRemoveFolderMemberErrorFolderOwner
    }

    @objc
    public var asGroupAccess: DBXSharingRemoveFolderMemberErrorGroupAccess? {
        self as? DBXSharingRemoveFolderMemberErrorGroupAccess
    }

    @objc
    public var asTeamFolder: DBXSharingRemoveFolderMemberErrorTeamFolder? {
        self as? DBXSharingRemoveFolderMemberErrorTeamFolder
    }

    @objc
    public var asNoPermission: DBXSharingRemoveFolderMemberErrorNoPermission? {
        self as? DBXSharingRemoveFolderMemberErrorNoPermission
    }

    @objc
    public var asTooManyFiles: DBXSharingRemoveFolderMemberErrorTooManyFiles? {
        self as? DBXSharingRemoveFolderMemberErrorTooManyFiles
    }

    @objc
    public var asOther: DBXSharingRemoveFolderMemberErrorOther? {
        self as? DBXSharingRemoveFolderMemberErrorOther
    }
}

/// An unspecified error.
@objc
public class DBXSharingRemoveFolderMemberErrorAccessError: DBXSharingRemoveFolderMemberError {
    @objc
    public var accessError: DBXSharingSharedFolderAccessError

    @objc
    public init(_ arg: DBXSharingSharedFolderAccessError) {
        self.accessError = arg
        let swift = Sharing.RemoveFolderMemberError.accessError(arg.swift)
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXSharingRemoveFolderMemberErrorMemberError: DBXSharingRemoveFolderMemberError {
    @objc
    public var memberError: DBXSharingSharedFolderMemberError

    @objc
    public init(_ arg: DBXSharingSharedFolderMemberError) {
        self.memberError = arg
        let swift = Sharing.RemoveFolderMemberError.memberError(arg.swift)
        super.init(swift: swift)
    }
}

/// The target user is the owner of the shared folder. You can't remove this user until ownership has been
/// transferred to another member.
@objc
public class DBXSharingRemoveFolderMemberErrorFolderOwner: DBXSharingRemoveFolderMemberError {
    @objc
    public init() {
        let swift = Sharing.RemoveFolderMemberError.folderOwner
        super.init(swift: swift)
    }
}

/// The target user has access to the shared folder via a group.
@objc
public class DBXSharingRemoveFolderMemberErrorGroupAccess: DBXSharingRemoveFolderMemberError {
    @objc
    public init() {
        let swift = Sharing.RemoveFolderMemberError.groupAccess
        super.init(swift: swift)
    }
}

/// This action cannot be performed on a team shared folder.
@objc
public class DBXSharingRemoveFolderMemberErrorTeamFolder: DBXSharingRemoveFolderMemberError {
    @objc
    public init() {
        let swift = Sharing.RemoveFolderMemberError.teamFolder
        super.init(swift: swift)
    }
}

/// The current user does not have permission to perform this action.
@objc
public class DBXSharingRemoveFolderMemberErrorNoPermission: DBXSharingRemoveFolderMemberError {
    @objc
    public init() {
        let swift = Sharing.RemoveFolderMemberError.noPermission
        super.init(swift: swift)
    }
}

/// This shared folder has too many files for leaving a copy. You can still remove this user without leaving a
/// copy.
@objc
public class DBXSharingRemoveFolderMemberErrorTooManyFiles: DBXSharingRemoveFolderMemberError {
    @objc
    public init() {
        let swift = Sharing.RemoveFolderMemberError.tooManyFiles
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXSharingRemoveFolderMemberErrorOther: DBXSharingRemoveFolderMemberError {
    @objc
    public init() {
        let swift = Sharing.RemoveFolderMemberError.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible RemoveMemberJobStatus union
@objc
public class DBXSharingRemoveMemberJobStatus: NSObject {
    let swift: Sharing.RemoveMemberJobStatus

    public init(swift: Sharing.RemoveMemberJobStatus) {
        self.swift = swift
    }

    public static func factory(swift: Sharing.RemoveMemberJobStatus) -> DBXSharingRemoveMemberJobStatus {
        switch swift {
        case .inProgress:
            return DBXSharingRemoveMemberJobStatusInProgress()
        case .complete(let swiftArg):
            let arg = DBXSharingMemberAccessLevelResult(swift: swiftArg)
            return DBXSharingRemoveMemberJobStatusComplete(arg)
        case .failed(let swiftArg):
            let arg = DBXSharingRemoveFolderMemberError(swift: swiftArg)
            return DBXSharingRemoveMemberJobStatusFailed(arg)
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asInProgress: DBXSharingRemoveMemberJobStatusInProgress? {
        self as? DBXSharingRemoveMemberJobStatusInProgress
    }

    @objc
    public var asComplete: DBXSharingRemoveMemberJobStatusComplete? {
        self as? DBXSharingRemoveMemberJobStatusComplete
    }

    @objc
    public var asFailed: DBXSharingRemoveMemberJobStatusFailed? {
        self as? DBXSharingRemoveMemberJobStatusFailed
    }
}

/// The asynchronous job is still in progress.
@objc
public class DBXSharingRemoveMemberJobStatusInProgress: DBXSharingRemoveMemberJobStatus {
    @objc
    public init() {
        let swift = Sharing.RemoveMemberJobStatus.inProgress
        super.init(swift: swift)
    }
}

/// Removing the folder member has finished. The value is information about whether the member has another form
/// of access.
@objc
public class DBXSharingRemoveMemberJobStatusComplete: DBXSharingRemoveMemberJobStatus {
    @objc
    public var complete: DBXSharingMemberAccessLevelResult

    @objc
    public init(_ arg: DBXSharingMemberAccessLevelResult) {
        self.complete = arg
        let swift = Sharing.RemoveMemberJobStatus.complete(arg.swift)
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXSharingRemoveMemberJobStatusFailed: DBXSharingRemoveMemberJobStatus {
    @objc
    public var failed: DBXSharingRemoveFolderMemberError

    @objc
    public init(_ arg: DBXSharingRemoveFolderMemberError) {
        self.failed = arg
        let swift = Sharing.RemoveMemberJobStatus.failed(arg.swift)
        super.init(swift: swift)
    }
}

/// Objective-C compatible RequestedLinkAccessLevel union
@objc
public class DBXSharingRequestedLinkAccessLevel: NSObject {
    let swift: Sharing.RequestedLinkAccessLevel

    public init(swift: Sharing.RequestedLinkAccessLevel) {
        self.swift = swift
    }

    public static func factory(swift: Sharing.RequestedLinkAccessLevel) -> DBXSharingRequestedLinkAccessLevel {
        switch swift {
        case .viewer:
            return DBXSharingRequestedLinkAccessLevelViewer()
        case .editor:
            return DBXSharingRequestedLinkAccessLevelEditor()
        case .max:
            return DBXSharingRequestedLinkAccessLevelMax()
        case .default_:
            return DBXSharingRequestedLinkAccessLevelDefault_()
        case .other:
            return DBXSharingRequestedLinkAccessLevelOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asViewer: DBXSharingRequestedLinkAccessLevelViewer? {
        self as? DBXSharingRequestedLinkAccessLevelViewer
    }

    @objc
    public var asEditor: DBXSharingRequestedLinkAccessLevelEditor? {
        self as? DBXSharingRequestedLinkAccessLevelEditor
    }

    @objc
    public var asMax: DBXSharingRequestedLinkAccessLevelMax? {
        self as? DBXSharingRequestedLinkAccessLevelMax
    }

    @objc
    public var asDefault_: DBXSharingRequestedLinkAccessLevelDefault_? {
        self as? DBXSharingRequestedLinkAccessLevelDefault_
    }

    @objc
    public var asOther: DBXSharingRequestedLinkAccessLevelOther? {
        self as? DBXSharingRequestedLinkAccessLevelOther
    }
}

/// Users who use the link can view and comment on the content.
@objc
public class DBXSharingRequestedLinkAccessLevelViewer: DBXSharingRequestedLinkAccessLevel {
    @objc
    public init() {
        let swift = Sharing.RequestedLinkAccessLevel.viewer
        super.init(swift: swift)
    }
}

/// Users who use the link can edit, view and comment on the content. Note not all file types support edit links
/// yet.
@objc
public class DBXSharingRequestedLinkAccessLevelEditor: DBXSharingRequestedLinkAccessLevel {
    @objc
    public init() {
        let swift = Sharing.RequestedLinkAccessLevel.editor
        super.init(swift: swift)
    }
}

/// Request for the maximum access level you can set the link to.
@objc
public class DBXSharingRequestedLinkAccessLevelMax: DBXSharingRequestedLinkAccessLevel {
    @objc
    public init() {
        let swift = Sharing.RequestedLinkAccessLevel.max
        super.init(swift: swift)
    }
}

/// Request for the default access level the user has set.
@objc
public class DBXSharingRequestedLinkAccessLevelDefault_: DBXSharingRequestedLinkAccessLevel {
    @objc
    public init() {
        let swift = Sharing.RequestedLinkAccessLevel.default_
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXSharingRequestedLinkAccessLevelOther: DBXSharingRequestedLinkAccessLevel {
    @objc
    public init() {
        let swift = Sharing.RequestedLinkAccessLevel.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible RevokeSharedLinkArg struct
@objc
public class DBXSharingRevokeSharedLinkArg: NSObject {
    /// URL of the shared link.
    @objc
    public var url: String { swift.url }

    @objc
    public init(url: String) {
        self.swift = Sharing.RevokeSharedLinkArg(url: url)
    }

    let swift: Sharing.RevokeSharedLinkArg

    public init(swift: Sharing.RevokeSharedLinkArg) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible RevokeSharedLinkError union
@objc
public class DBXSharingRevokeSharedLinkError: NSObject {
    let swift: Sharing.RevokeSharedLinkError

    public init(swift: Sharing.RevokeSharedLinkError) {
        self.swift = swift
    }

    public static func factory(swift: Sharing.RevokeSharedLinkError) -> DBXSharingRevokeSharedLinkError {
        switch swift {
        case .sharedLinkNotFound:
            return DBXSharingRevokeSharedLinkErrorSharedLinkNotFound()
        case .sharedLinkAccessDenied:
            return DBXSharingRevokeSharedLinkErrorSharedLinkAccessDenied()
        case .unsupportedLinkType:
            return DBXSharingRevokeSharedLinkErrorUnsupportedLinkType()
        case .other:
            return DBXSharingRevokeSharedLinkErrorOther()
        case .sharedLinkMalformed:
            return DBXSharingRevokeSharedLinkErrorSharedLinkMalformed()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asSharedLinkNotFound: DBXSharingRevokeSharedLinkErrorSharedLinkNotFound? {
        self as? DBXSharingRevokeSharedLinkErrorSharedLinkNotFound
    }

    @objc
    public var asSharedLinkAccessDenied: DBXSharingRevokeSharedLinkErrorSharedLinkAccessDenied? {
        self as? DBXSharingRevokeSharedLinkErrorSharedLinkAccessDenied
    }

    @objc
    public var asUnsupportedLinkType: DBXSharingRevokeSharedLinkErrorUnsupportedLinkType? {
        self as? DBXSharingRevokeSharedLinkErrorUnsupportedLinkType
    }

    @objc
    public var asOther: DBXSharingRevokeSharedLinkErrorOther? {
        self as? DBXSharingRevokeSharedLinkErrorOther
    }

    @objc
    public var asSharedLinkMalformed: DBXSharingRevokeSharedLinkErrorSharedLinkMalformed? {
        self as? DBXSharingRevokeSharedLinkErrorSharedLinkMalformed
    }
}

/// The shared link wasn't found.
@objc
public class DBXSharingRevokeSharedLinkErrorSharedLinkNotFound: DBXSharingRevokeSharedLinkError {
    @objc
    public init() {
        let swift = Sharing.RevokeSharedLinkError.sharedLinkNotFound
        super.init(swift: swift)
    }
}

/// The caller is not allowed to access this shared link.
@objc
public class DBXSharingRevokeSharedLinkErrorSharedLinkAccessDenied: DBXSharingRevokeSharedLinkError {
    @objc
    public init() {
        let swift = Sharing.RevokeSharedLinkError.sharedLinkAccessDenied
        super.init(swift: swift)
    }
}

/// This type of link is not supported; use files instead.
@objc
public class DBXSharingRevokeSharedLinkErrorUnsupportedLinkType: DBXSharingRevokeSharedLinkError {
    @objc
    public init() {
        let swift = Sharing.RevokeSharedLinkError.unsupportedLinkType
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXSharingRevokeSharedLinkErrorOther: DBXSharingRevokeSharedLinkError {
    @objc
    public init() {
        let swift = Sharing.RevokeSharedLinkError.other
        super.init(swift: swift)
    }
}

/// Shared link is malformed.
@objc
public class DBXSharingRevokeSharedLinkErrorSharedLinkMalformed: DBXSharingRevokeSharedLinkError {
    @objc
    public init() {
        let swift = Sharing.RevokeSharedLinkError.sharedLinkMalformed
        super.init(swift: swift)
    }
}

/// Objective-C compatible SetAccessInheritanceArg struct
@objc
public class DBXSharingSetAccessInheritanceArg: NSObject {
    /// The access inheritance settings for the folder.
    @objc
    public var accessInheritance: DBXSharingAccessInheritance { DBXSharingAccessInheritance(swift: swift.accessInheritance) }
    /// The ID for the shared folder.
    @objc
    public var sharedFolderId: String { swift.sharedFolderId }

    @objc
    public init(sharedFolderId: String, accessInheritance: DBXSharingAccessInheritance) {
        self.swift = Sharing.SetAccessInheritanceArg(sharedFolderId: sharedFolderId, accessInheritance: accessInheritance.swift)
    }

    let swift: Sharing.SetAccessInheritanceArg

    public init(swift: Sharing.SetAccessInheritanceArg) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible SetAccessInheritanceError union
@objc
public class DBXSharingSetAccessInheritanceError: NSObject {
    let swift: Sharing.SetAccessInheritanceError

    public init(swift: Sharing.SetAccessInheritanceError) {
        self.swift = swift
    }

    public static func factory(swift: Sharing.SetAccessInheritanceError) -> DBXSharingSetAccessInheritanceError {
        switch swift {
        case .accessError(let swiftArg):
            let arg = DBXSharingSharedFolderAccessError(swift: swiftArg)
            return DBXSharingSetAccessInheritanceErrorAccessError(arg)
        case .noPermission:
            return DBXSharingSetAccessInheritanceErrorNoPermission()
        case .other:
            return DBXSharingSetAccessInheritanceErrorOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asAccessError: DBXSharingSetAccessInheritanceErrorAccessError? {
        self as? DBXSharingSetAccessInheritanceErrorAccessError
    }

    @objc
    public var asNoPermission: DBXSharingSetAccessInheritanceErrorNoPermission? {
        self as? DBXSharingSetAccessInheritanceErrorNoPermission
    }

    @objc
    public var asOther: DBXSharingSetAccessInheritanceErrorOther? {
        self as? DBXSharingSetAccessInheritanceErrorOther
    }
}

/// Unable to access shared folder.
@objc
public class DBXSharingSetAccessInheritanceErrorAccessError: DBXSharingSetAccessInheritanceError {
    @objc
    public var accessError: DBXSharingSharedFolderAccessError

    @objc
    public init(_ arg: DBXSharingSharedFolderAccessError) {
        self.accessError = arg
        let swift = Sharing.SetAccessInheritanceError.accessError(arg.swift)
        super.init(swift: swift)
    }
}

/// The current user does not have permission to perform this action.
@objc
public class DBXSharingSetAccessInheritanceErrorNoPermission: DBXSharingSetAccessInheritanceError {
    @objc
    public init() {
        let swift = Sharing.SetAccessInheritanceError.noPermission
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXSharingSetAccessInheritanceErrorOther: DBXSharingSetAccessInheritanceError {
    @objc
    public init() {
        let swift = Sharing.SetAccessInheritanceError.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible ShareFolderArgBase struct
@objc
public class DBXSharingShareFolderArgBase: NSObject {
    /// Who can add and remove members of this shared folder.
    @objc
    public var aclUpdatePolicy: DBXSharingAclUpdatePolicy? { guard let swift = swift.aclUpdatePolicy else { return nil }
        return DBXSharingAclUpdatePolicy(swift: swift)
    }

    /// Whether to force the share to happen asynchronously.
    @objc
    public var forceAsync: NSNumber { swift.forceAsync as NSNumber }
    /// Who can be a member of this shared folder. Only applicable if the current user is on a team.
    @objc
    public var memberPolicy: DBXSharingMemberPolicy? { guard let swift = swift.memberPolicy else { return nil }
        return DBXSharingMemberPolicy(swift: swift)
    }

    /// The path or the file id to the folder to share. If it does not exist, then a new one is created.
    @objc
    public var path: String { swift.path }
    /// The policy to apply to shared links created for content inside this shared folder.  The current user must be
    /// on a team to set this policy to members in SharedLinkPolicy.
    @objc
    public var sharedLinkPolicy: DBXSharingSharedLinkPolicy? { guard let swift = swift.sharedLinkPolicy else { return nil }
        return DBXSharingSharedLinkPolicy(swift: swift)
    }

    /// Who can enable/disable viewer info for this shared folder.
    @objc
    public var viewerInfoPolicy: DBXSharingViewerInfoPolicy? { guard let swift = swift.viewerInfoPolicy else { return nil }
        return DBXSharingViewerInfoPolicy(swift: swift)
    }

    /// The access inheritance settings for the folder.
    @objc
    public var accessInheritance: DBXSharingAccessInheritance { DBXSharingAccessInheritance(swift: swift.accessInheritance) }

    @objc
    public init(
        path: String,
        aclUpdatePolicy: DBXSharingAclUpdatePolicy?,
        forceAsync: NSNumber,
        memberPolicy: DBXSharingMemberPolicy?,
        sharedLinkPolicy: DBXSharingSharedLinkPolicy?,
        viewerInfoPolicy: DBXSharingViewerInfoPolicy?,
        accessInheritance: DBXSharingAccessInheritance
    ) {
        self.swift = Sharing.ShareFolderArgBase(
            path: path,
            aclUpdatePolicy: aclUpdatePolicy?.swift,
            forceAsync: forceAsync.boolValue,
            memberPolicy: memberPolicy?.swift,
            sharedLinkPolicy: sharedLinkPolicy?.swift,
            viewerInfoPolicy: viewerInfoPolicy?.swift,
            accessInheritance: accessInheritance.swift
        )
    }

    let swift: Sharing.ShareFolderArgBase

    public init(swift: Sharing.ShareFolderArgBase) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible ShareFolderArg struct
@objc
public class DBXSharingShareFolderArg: DBXSharingShareFolderArgBase {
    /// A list of `FolderAction`s corresponding to `FolderPermission`s that should appear in the  response's
    /// permissions in SharedFolderMetadata field describing the actions the  authenticated user can perform on
    /// the folder.
    @objc
    public var actions: [DBXSharingFolderAction]? { subSwift.actions?.map { DBXSharingFolderAction(swift: $0) } }
    /// Settings on the link for this folder.
    @objc
    public var linkSettings: DBXSharingLinkSettings? { guard let swift = subSwift.linkSettings else { return nil }
        return DBXSharingLinkSettings(swift: swift)
    }

    @objc
    public init(
        path: String,
        aclUpdatePolicy: DBXSharingAclUpdatePolicy?,
        forceAsync: NSNumber,
        memberPolicy: DBXSharingMemberPolicy?,
        sharedLinkPolicy: DBXSharingSharedLinkPolicy?,
        viewerInfoPolicy: DBXSharingViewerInfoPolicy?,
        accessInheritance: DBXSharingAccessInheritance,
        actions: [DBXSharingFolderAction]?,
        linkSettings: DBXSharingLinkSettings?
    ) {
        let swift = Sharing.ShareFolderArg(
            path: path,
            aclUpdatePolicy: aclUpdatePolicy?.swift,
            forceAsync: forceAsync.boolValue,
            memberPolicy: memberPolicy?.swift,
            sharedLinkPolicy: sharedLinkPolicy?.swift,
            viewerInfoPolicy: viewerInfoPolicy?.swift,
            accessInheritance: accessInheritance.swift,
            actions: actions?.map(\.swift),
            linkSettings: linkSettings?.swift
        )
        self.subSwift = swift
        super.init(swift: swift)
    }

    let subSwift: Sharing.ShareFolderArg

    public init(swift: Sharing.ShareFolderArg) {
        self.subSwift = swift
        super.init(swift: swift)
    }

    @objc
    public override var description: String { subSwift.description }
}

/// Objective-C compatible ShareFolderErrorBase union
@objc
public class DBXSharingShareFolderErrorBase: NSObject {
    let swift: Sharing.ShareFolderErrorBase

    public init(swift: Sharing.ShareFolderErrorBase) {
        self.swift = swift
    }

    public static func factory(swift: Sharing.ShareFolderErrorBase) -> DBXSharingShareFolderErrorBase {
        switch swift {
        case .emailUnverified:
            return DBXSharingShareFolderErrorBaseEmailUnverified()
        case .badPath(let swiftArg):
            let arg = DBXSharingSharePathError(swift: swiftArg)
            return DBXSharingShareFolderErrorBaseBadPath(arg)
        case .teamPolicyDisallowsMemberPolicy:
            return DBXSharingShareFolderErrorBaseTeamPolicyDisallowsMemberPolicy()
        case .disallowedSharedLinkPolicy:
            return DBXSharingShareFolderErrorBaseDisallowedSharedLinkPolicy()
        case .other:
            return DBXSharingShareFolderErrorBaseOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asEmailUnverified: DBXSharingShareFolderErrorBaseEmailUnverified? {
        self as? DBXSharingShareFolderErrorBaseEmailUnverified
    }

    @objc
    public var asBadPath: DBXSharingShareFolderErrorBaseBadPath? {
        self as? DBXSharingShareFolderErrorBaseBadPath
    }

    @objc
    public var asTeamPolicyDisallowsMemberPolicy: DBXSharingShareFolderErrorBaseTeamPolicyDisallowsMemberPolicy? {
        self as? DBXSharingShareFolderErrorBaseTeamPolicyDisallowsMemberPolicy
    }

    @objc
    public var asDisallowedSharedLinkPolicy: DBXSharingShareFolderErrorBaseDisallowedSharedLinkPolicy? {
        self as? DBXSharingShareFolderErrorBaseDisallowedSharedLinkPolicy
    }

    @objc
    public var asOther: DBXSharingShareFolderErrorBaseOther? {
        self as? DBXSharingShareFolderErrorBaseOther
    }
}

/// This user's email address is not verified. This functionality is only available on accounts with a verified
/// email address. Users can verify their email address here https://www.dropbox.com/help/317.
@objc
public class DBXSharingShareFolderErrorBaseEmailUnverified: DBXSharingShareFolderErrorBase {
    @objc
    public init() {
        let swift = Sharing.ShareFolderErrorBase.emailUnverified
        super.init(swift: swift)
    }
}

/// path in ShareFolderArg is invalid.
@objc
public class DBXSharingShareFolderErrorBaseBadPath: DBXSharingShareFolderErrorBase {
    @objc
    public var badPath: DBXSharingSharePathError

    @objc
    public init(_ arg: DBXSharingSharePathError) {
        self.badPath = arg
        let swift = Sharing.ShareFolderErrorBase.badPath(arg.swift)
        super.init(swift: swift)
    }
}

/// Team policy is more restrictive than memberPolicy in ShareFolderArg.
@objc
public class DBXSharingShareFolderErrorBaseTeamPolicyDisallowsMemberPolicy: DBXSharingShareFolderErrorBase {
    @objc
    public init() {
        let swift = Sharing.ShareFolderErrorBase.teamPolicyDisallowsMemberPolicy
        super.init(swift: swift)
    }
}

/// The current user's account is not allowed to select the specified sharedLinkPolicy in ShareFolderArg.
@objc
public class DBXSharingShareFolderErrorBaseDisallowedSharedLinkPolicy: DBXSharingShareFolderErrorBase {
    @objc
    public init() {
        let swift = Sharing.ShareFolderErrorBase.disallowedSharedLinkPolicy
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXSharingShareFolderErrorBaseOther: DBXSharingShareFolderErrorBase {
    @objc
    public init() {
        let swift = Sharing.ShareFolderErrorBase.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible ShareFolderError union
@objc
public class DBXSharingShareFolderError: NSObject {
    let swift: Sharing.ShareFolderError

    public init(swift: Sharing.ShareFolderError) {
        self.swift = swift
    }

    public static func factory(swift: Sharing.ShareFolderError) -> DBXSharingShareFolderError {
        switch swift {
        case .emailUnverified:
            return DBXSharingShareFolderErrorEmailUnverified()
        case .badPath(let swiftArg):
            let arg = DBXSharingSharePathError(swift: swiftArg)
            return DBXSharingShareFolderErrorBadPath(arg)
        case .teamPolicyDisallowsMemberPolicy:
            return DBXSharingShareFolderErrorTeamPolicyDisallowsMemberPolicy()
        case .disallowedSharedLinkPolicy:
            return DBXSharingShareFolderErrorDisallowedSharedLinkPolicy()
        case .other:
            return DBXSharingShareFolderErrorOther()
        case .noPermission:
            return DBXSharingShareFolderErrorNoPermission()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asEmailUnverified: DBXSharingShareFolderErrorEmailUnverified? {
        self as? DBXSharingShareFolderErrorEmailUnverified
    }

    @objc
    public var asBadPath: DBXSharingShareFolderErrorBadPath? {
        self as? DBXSharingShareFolderErrorBadPath
    }

    @objc
    public var asTeamPolicyDisallowsMemberPolicy: DBXSharingShareFolderErrorTeamPolicyDisallowsMemberPolicy? {
        self as? DBXSharingShareFolderErrorTeamPolicyDisallowsMemberPolicy
    }

    @objc
    public var asDisallowedSharedLinkPolicy: DBXSharingShareFolderErrorDisallowedSharedLinkPolicy? {
        self as? DBXSharingShareFolderErrorDisallowedSharedLinkPolicy
    }

    @objc
    public var asOther: DBXSharingShareFolderErrorOther? {
        self as? DBXSharingShareFolderErrorOther
    }

    @objc
    public var asNoPermission: DBXSharingShareFolderErrorNoPermission? {
        self as? DBXSharingShareFolderErrorNoPermission
    }
}

/// This user's email address is not verified. This functionality is only available on accounts with a verified
/// email address. Users can verify their email address here https://www.dropbox.com/help/317.
@objc
public class DBXSharingShareFolderErrorEmailUnverified: DBXSharingShareFolderError {
    @objc
    public init() {
        let swift = Sharing.ShareFolderError.emailUnverified
        super.init(swift: swift)
    }
}

/// path in ShareFolderArg is invalid.
@objc
public class DBXSharingShareFolderErrorBadPath: DBXSharingShareFolderError {
    @objc
    public var badPath: DBXSharingSharePathError

    @objc
    public init(_ arg: DBXSharingSharePathError) {
        self.badPath = arg
        let swift = Sharing.ShareFolderError.badPath(arg.swift)
        super.init(swift: swift)
    }
}

/// Team policy is more restrictive than memberPolicy in ShareFolderArg.
@objc
public class DBXSharingShareFolderErrorTeamPolicyDisallowsMemberPolicy: DBXSharingShareFolderError {
    @objc
    public init() {
        let swift = Sharing.ShareFolderError.teamPolicyDisallowsMemberPolicy
        super.init(swift: swift)
    }
}

/// The current user's account is not allowed to select the specified sharedLinkPolicy in ShareFolderArg.
@objc
public class DBXSharingShareFolderErrorDisallowedSharedLinkPolicy: DBXSharingShareFolderError {
    @objc
    public init() {
        let swift = Sharing.ShareFolderError.disallowedSharedLinkPolicy
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXSharingShareFolderErrorOther: DBXSharingShareFolderError {
    @objc
    public init() {
        let swift = Sharing.ShareFolderError.other
        super.init(swift: swift)
    }
}

/// The current user does not have permission to perform this action.
@objc
public class DBXSharingShareFolderErrorNoPermission: DBXSharingShareFolderError {
    @objc
    public init() {
        let swift = Sharing.ShareFolderError.noPermission
        super.init(swift: swift)
    }
}

/// Objective-C compatible ShareFolderJobStatus union
@objc
public class DBXSharingShareFolderJobStatus: NSObject {
    let swift: Sharing.ShareFolderJobStatus

    public init(swift: Sharing.ShareFolderJobStatus) {
        self.swift = swift
    }

    public static func factory(swift: Sharing.ShareFolderJobStatus) -> DBXSharingShareFolderJobStatus {
        switch swift {
        case .inProgress:
            return DBXSharingShareFolderJobStatusInProgress()
        case .complete(let swiftArg):
            let arg = DBXSharingSharedFolderMetadata(swift: swiftArg)
            return DBXSharingShareFolderJobStatusComplete(arg)
        case .failed(let swiftArg):
            let arg = DBXSharingShareFolderError(swift: swiftArg)
            return DBXSharingShareFolderJobStatusFailed(arg)
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asInProgress: DBXSharingShareFolderJobStatusInProgress? {
        self as? DBXSharingShareFolderJobStatusInProgress
    }

    @objc
    public var asComplete: DBXSharingShareFolderJobStatusComplete? {
        self as? DBXSharingShareFolderJobStatusComplete
    }

    @objc
    public var asFailed: DBXSharingShareFolderJobStatusFailed? {
        self as? DBXSharingShareFolderJobStatusFailed
    }
}

/// The asynchronous job is still in progress.
@objc
public class DBXSharingShareFolderJobStatusInProgress: DBXSharingShareFolderJobStatus {
    @objc
    public init() {
        let swift = Sharing.ShareFolderJobStatus.inProgress
        super.init(swift: swift)
    }
}

/// The share job has finished. The value is the metadata for the folder.
@objc
public class DBXSharingShareFolderJobStatusComplete: DBXSharingShareFolderJobStatus {
    @objc
    public var complete: DBXSharingSharedFolderMetadata

    @objc
    public init(_ arg: DBXSharingSharedFolderMetadata) {
        self.complete = arg
        let swift = Sharing.ShareFolderJobStatus.complete(arg.subSwift)
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXSharingShareFolderJobStatusFailed: DBXSharingShareFolderJobStatus {
    @objc
    public var failed: DBXSharingShareFolderError

    @objc
    public init(_ arg: DBXSharingShareFolderError) {
        self.failed = arg
        let swift = Sharing.ShareFolderJobStatus.failed(arg.swift)
        super.init(swift: swift)
    }
}

/// Objective-C compatible ShareFolderLaunch union
@objc
public class DBXSharingShareFolderLaunch: NSObject {
    let swift: Sharing.ShareFolderLaunch

    public init(swift: Sharing.ShareFolderLaunch) {
        self.swift = swift
    }

    public static func factory(swift: Sharing.ShareFolderLaunch) -> DBXSharingShareFolderLaunch {
        switch swift {
        case .asyncJobId(let swiftArg):
            let arg = swiftArg
            return DBXSharingShareFolderLaunchAsyncJobId(arg)
        case .complete(let swiftArg):
            let arg = DBXSharingSharedFolderMetadata(swift: swiftArg)
            return DBXSharingShareFolderLaunchComplete(arg)
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asAsyncJobId: DBXSharingShareFolderLaunchAsyncJobId? {
        self as? DBXSharingShareFolderLaunchAsyncJobId
    }

    @objc
    public var asComplete: DBXSharingShareFolderLaunchComplete? {
        self as? DBXSharingShareFolderLaunchComplete
    }
}

/// This response indicates that the processing is asynchronous. The string is an id that can be used to obtain
/// the status of the asynchronous job.
@objc
public class DBXSharingShareFolderLaunchAsyncJobId: DBXSharingShareFolderLaunch {
    @objc
    public var asyncJobId: String

    @objc
    public init(_ arg: String) {
        self.asyncJobId = arg
        let swift = Sharing.ShareFolderLaunch.asyncJobId(arg)
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXSharingShareFolderLaunchComplete: DBXSharingShareFolderLaunch {
    @objc
    public var complete: DBXSharingSharedFolderMetadata

    @objc
    public init(_ arg: DBXSharingSharedFolderMetadata) {
        self.complete = arg
        let swift = Sharing.ShareFolderLaunch.complete(arg.subSwift)
        super.init(swift: swift)
    }
}

/// Objective-C compatible SharePathError union
@objc
public class DBXSharingSharePathError: NSObject {
    let swift: Sharing.SharePathError

    public init(swift: Sharing.SharePathError) {
        self.swift = swift
    }

    public static func factory(swift: Sharing.SharePathError) -> DBXSharingSharePathError {
        switch swift {
        case .isFile:
            return DBXSharingSharePathErrorIsFile()
        case .insideSharedFolder:
            return DBXSharingSharePathErrorInsideSharedFolder()
        case .containsSharedFolder:
            return DBXSharingSharePathErrorContainsSharedFolder()
        case .containsAppFolder:
            return DBXSharingSharePathErrorContainsAppFolder()
        case .containsTeamFolder:
            return DBXSharingSharePathErrorContainsTeamFolder()
        case .isAppFolder:
            return DBXSharingSharePathErrorIsAppFolder()
        case .insideAppFolder:
            return DBXSharingSharePathErrorInsideAppFolder()
        case .isPublicFolder:
            return DBXSharingSharePathErrorIsPublicFolder()
        case .insidePublicFolder:
            return DBXSharingSharePathErrorInsidePublicFolder()
        case .alreadyShared(let swiftArg):
            let arg = DBXSharingSharedFolderMetadata(swift: swiftArg)
            return DBXSharingSharePathErrorAlreadyShared(arg)
        case .invalidPath:
            return DBXSharingSharePathErrorInvalidPath()
        case .isOsxPackage:
            return DBXSharingSharePathErrorIsOsxPackage()
        case .insideOsxPackage:
            return DBXSharingSharePathErrorInsideOsxPackage()
        case .isVault:
            return DBXSharingSharePathErrorIsVault()
        case .isVaultLocked:
            return DBXSharingSharePathErrorIsVaultLocked()
        case .isFamily:
            return DBXSharingSharePathErrorIsFamily()
        case .other:
            return DBXSharingSharePathErrorOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asIsFile: DBXSharingSharePathErrorIsFile? {
        self as? DBXSharingSharePathErrorIsFile
    }

    @objc
    public var asInsideSharedFolder: DBXSharingSharePathErrorInsideSharedFolder? {
        self as? DBXSharingSharePathErrorInsideSharedFolder
    }

    @objc
    public var asContainsSharedFolder: DBXSharingSharePathErrorContainsSharedFolder? {
        self as? DBXSharingSharePathErrorContainsSharedFolder
    }

    @objc
    public var asContainsAppFolder: DBXSharingSharePathErrorContainsAppFolder? {
        self as? DBXSharingSharePathErrorContainsAppFolder
    }

    @objc
    public var asContainsTeamFolder: DBXSharingSharePathErrorContainsTeamFolder? {
        self as? DBXSharingSharePathErrorContainsTeamFolder
    }

    @objc
    public var asIsAppFolder: DBXSharingSharePathErrorIsAppFolder? {
        self as? DBXSharingSharePathErrorIsAppFolder
    }

    @objc
    public var asInsideAppFolder: DBXSharingSharePathErrorInsideAppFolder? {
        self as? DBXSharingSharePathErrorInsideAppFolder
    }

    @objc
    public var asIsPublicFolder: DBXSharingSharePathErrorIsPublicFolder? {
        self as? DBXSharingSharePathErrorIsPublicFolder
    }

    @objc
    public var asInsidePublicFolder: DBXSharingSharePathErrorInsidePublicFolder? {
        self as? DBXSharingSharePathErrorInsidePublicFolder
    }

    @objc
    public var asAlreadyShared: DBXSharingSharePathErrorAlreadyShared? {
        self as? DBXSharingSharePathErrorAlreadyShared
    }

    @objc
    public var asInvalidPath: DBXSharingSharePathErrorInvalidPath? {
        self as? DBXSharingSharePathErrorInvalidPath
    }

    @objc
    public var asIsOsxPackage: DBXSharingSharePathErrorIsOsxPackage? {
        self as? DBXSharingSharePathErrorIsOsxPackage
    }

    @objc
    public var asInsideOsxPackage: DBXSharingSharePathErrorInsideOsxPackage? {
        self as? DBXSharingSharePathErrorInsideOsxPackage
    }

    @objc
    public var asIsVault: DBXSharingSharePathErrorIsVault? {
        self as? DBXSharingSharePathErrorIsVault
    }

    @objc
    public var asIsVaultLocked: DBXSharingSharePathErrorIsVaultLocked? {
        self as? DBXSharingSharePathErrorIsVaultLocked
    }

    @objc
    public var asIsFamily: DBXSharingSharePathErrorIsFamily? {
        self as? DBXSharingSharePathErrorIsFamily
    }

    @objc
    public var asOther: DBXSharingSharePathErrorOther? {
        self as? DBXSharingSharePathErrorOther
    }
}

/// A file is at the specified path.
@objc
public class DBXSharingSharePathErrorIsFile: DBXSharingSharePathError {
    @objc
    public init() {
        let swift = Sharing.SharePathError.isFile
        super.init(swift: swift)
    }
}

/// We do not support sharing a folder inside a shared folder.
@objc
public class DBXSharingSharePathErrorInsideSharedFolder: DBXSharingSharePathError {
    @objc
    public init() {
        let swift = Sharing.SharePathError.insideSharedFolder
        super.init(swift: swift)
    }
}

/// We do not support shared folders that contain shared folders.
@objc
public class DBXSharingSharePathErrorContainsSharedFolder: DBXSharingSharePathError {
    @objc
    public init() {
        let swift = Sharing.SharePathError.containsSharedFolder
        super.init(swift: swift)
    }
}

/// We do not support shared folders that contain app folders.
@objc
public class DBXSharingSharePathErrorContainsAppFolder: DBXSharingSharePathError {
    @objc
    public init() {
        let swift = Sharing.SharePathError.containsAppFolder
        super.init(swift: swift)
    }
}

/// We do not support shared folders that contain team folders.
@objc
public class DBXSharingSharePathErrorContainsTeamFolder: DBXSharingSharePathError {
    @objc
    public init() {
        let swift = Sharing.SharePathError.containsTeamFolder
        super.init(swift: swift)
    }
}

/// We do not support sharing an app folder.
@objc
public class DBXSharingSharePathErrorIsAppFolder: DBXSharingSharePathError {
    @objc
    public init() {
        let swift = Sharing.SharePathError.isAppFolder
        super.init(swift: swift)
    }
}

/// We do not support sharing a folder inside an app folder.
@objc
public class DBXSharingSharePathErrorInsideAppFolder: DBXSharingSharePathError {
    @objc
    public init() {
        let swift = Sharing.SharePathError.insideAppFolder
        super.init(swift: swift)
    }
}

/// A public folder can't be shared this way. Use a public link instead.
@objc
public class DBXSharingSharePathErrorIsPublicFolder: DBXSharingSharePathError {
    @objc
    public init() {
        let swift = Sharing.SharePathError.isPublicFolder
        super.init(swift: swift)
    }
}

/// A folder inside a public folder can't be shared this way. Use a public link instead.
@objc
public class DBXSharingSharePathErrorInsidePublicFolder: DBXSharingSharePathError {
    @objc
    public init() {
        let swift = Sharing.SharePathError.insidePublicFolder
        super.init(swift: swift)
    }
}

/// Folder is already shared. Contains metadata about the existing shared folder.
@objc
public class DBXSharingSharePathErrorAlreadyShared: DBXSharingSharePathError {
    @objc
    public var alreadyShared: DBXSharingSharedFolderMetadata

    @objc
    public init(_ arg: DBXSharingSharedFolderMetadata) {
        self.alreadyShared = arg
        let swift = Sharing.SharePathError.alreadyShared(arg.subSwift)
        super.init(swift: swift)
    }
}

/// Path is not valid.
@objc
public class DBXSharingSharePathErrorInvalidPath: DBXSharingSharePathError {
    @objc
    public init() {
        let swift = Sharing.SharePathError.invalidPath
        super.init(swift: swift)
    }
}

/// We do not support sharing a Mac OS X package.
@objc
public class DBXSharingSharePathErrorIsOsxPackage: DBXSharingSharePathError {
    @objc
    public init() {
        let swift = Sharing.SharePathError.isOsxPackage
        super.init(swift: swift)
    }
}

/// We do not support sharing a folder inside a Mac OS X package.
@objc
public class DBXSharingSharePathErrorInsideOsxPackage: DBXSharingSharePathError {
    @objc
    public init() {
        let swift = Sharing.SharePathError.insideOsxPackage
        super.init(swift: swift)
    }
}

/// We do not support sharing the Vault folder.
@objc
public class DBXSharingSharePathErrorIsVault: DBXSharingSharePathError {
    @objc
    public init() {
        let swift = Sharing.SharePathError.isVault
        super.init(swift: swift)
    }
}

/// We do not support sharing a folder inside a locked Vault.
@objc
public class DBXSharingSharePathErrorIsVaultLocked: DBXSharingSharePathError {
    @objc
    public init() {
        let swift = Sharing.SharePathError.isVaultLocked
        super.init(swift: swift)
    }
}

/// We do not support sharing the Family folder.
@objc
public class DBXSharingSharePathErrorIsFamily: DBXSharingSharePathError {
    @objc
    public init() {
        let swift = Sharing.SharePathError.isFamily
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXSharingSharePathErrorOther: DBXSharingSharePathError {
    @objc
    public init() {
        let swift = Sharing.SharePathError.other
        super.init(swift: swift)
    }
}

/// Metadata of a shared link for a file or folder.
@objc
public class DBXSharingSharedContentLinkMetadata: DBXSharingSharedContentLinkMetadataBase {
    /// The content inside this folder with link audience different than this folder's. This is only returned when
    /// an endpoint that returns metadata for a single shared folder is called, e.g. /get_folder_metadata.
    @objc
    public var audienceExceptions: DBXSharingAudienceExceptions? { guard let swift = subSwift.audienceExceptions else { return nil }
        return DBXSharingAudienceExceptions(swift: swift)
    }

    /// The URL of the link.
    @objc
    public var url: String { subSwift.url }

    @objc
    public init(
        audienceOptions: [DBXSharingLinkAudience],
        currentAudience: DBXSharingLinkAudience,
        linkPermissions: [DBXSharingLinkPermission],
        passwordProtected: NSNumber,
        url: String,
        accessLevel: DBXSharingAccessLevel?,
        audienceRestrictingSharedFolder: DBXSharingAudienceRestrictingSharedFolder?,
        expiry: Date?,
        audienceExceptions: DBXSharingAudienceExceptions?
    ) {
        let swift = Sharing.SharedContentLinkMetadata(
            audienceOptions: audienceOptions.map(\.swift),
            currentAudience: currentAudience.swift,
            linkPermissions: linkPermissions.map(\.swift),
            passwordProtected: passwordProtected.boolValue,
            url: url,
            accessLevel: accessLevel?.swift,
            audienceRestrictingSharedFolder: audienceRestrictingSharedFolder?.swift,
            expiry: expiry,
            audienceExceptions: audienceExceptions?.swift
        )
        self.subSwift = swift
        super.init(swift: swift)
    }

    let subSwift: Sharing.SharedContentLinkMetadata

    public init(swift: Sharing.SharedContentLinkMetadata) {
        self.subSwift = swift
        super.init(swift: swift)
    }

    @objc
    public override var description: String { subSwift.description }
}

/// Shared file user, group, and invitee membership. Used for the results of listFileMembers and
/// listFileMembersContinue, and used as part of the results for listFileMembersBatch.
@objc
public class DBXSharingSharedFileMembers: NSObject {
    /// The list of user members of the shared file.
    @objc
    public var users: [DBXSharingUserFileMembershipInfo] { swift.users.map { DBXSharingUserFileMembershipInfo(swift: $0) } }
    /// The list of group members of the shared file.
    @objc
    public var groups: [DBXSharingGroupMembershipInfo] { swift.groups.map { DBXSharingGroupMembershipInfo(swift: $0) } }
    /// The list of invited members of a file, but have not logged in and claimed this.
    @objc
    public var invitees: [DBXSharingInviteeMembershipInfo] { swift.invitees.map { DBXSharingInviteeMembershipInfo(swift: $0) } }
    /// Present if there are additional shared file members that have not been returned yet. Pass the cursor into
    /// listFileMembersContinue to list additional members.
    @objc
    public var cursor: String? { swift.cursor }

    @objc
    public init(
        users: [DBXSharingUserFileMembershipInfo],
        groups: [DBXSharingGroupMembershipInfo],
        invitees: [DBXSharingInviteeMembershipInfo],
        cursor: String?
    ) {
        self.swift = Sharing.SharedFileMembers(
            users: users.map(\.subSubSwift),
            groups: groups.map(\.subSwift),
            invitees: invitees.map(\.subSwift),
            cursor: cursor
        )
    }

    let swift: Sharing.SharedFileMembers

    public init(swift: Sharing.SharedFileMembers) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Properties of the shared file.
@objc
public class DBXSharingSharedFileMetadata: NSObject {
    /// The current user's access level for this shared file.
    @objc
    public var accessType: DBXSharingAccessLevel? { guard let swift = swift.accessType else { return nil }
        return DBXSharingAccessLevel(swift: swift)
    }

    /// The ID of the file.
    @objc
    public var id: String { swift.id }
    /// The expected metadata of the link associated for the file when it is first shared. Absent if the link
    /// already exists. This is for an unreleased feature so it may not be returned yet.
    @objc
    public var expectedLinkMetadata: DBXSharingExpectedSharedContentLinkMetadata? { guard let swift = swift.expectedLinkMetadata else { return nil }
        return DBXSharingExpectedSharedContentLinkMetadata(swift: swift)
    }

    /// The metadata of the link associated for the file. This is for an unreleased feature so it may not be
    /// returned yet.
    @objc
    public var linkMetadata: DBXSharingSharedContentLinkMetadata? { guard let swift = swift.linkMetadata else { return nil }
        return DBXSharingSharedContentLinkMetadata(swift: swift)
    }

    /// The name of this file.
    @objc
    public var name: String { swift.name }
    /// The display names of the users that own the file. If the file is part of a team folder, the display names of
    /// the team admins are also included. Absent if the owner display names cannot be fetched.
    @objc
    public var ownerDisplayNames: [String]? { swift.ownerDisplayNames }
    /// The team that owns the file. This field is not present if the file is not owned by a team.
    @objc
    public var ownerTeam: DBXUsersTeam? { guard let swift = swift.ownerTeam else { return nil }
        return DBXUsersTeam(swift: swift)
    }

    /// The ID of the parent shared folder. This field is present only if the file is contained within a shared
    /// folder.
    @objc
    public var parentSharedFolderId: String? { swift.parentSharedFolderId }
    /// The cased path to be used for display purposes only. In rare instances the casing will not correctly match
    /// the user's filesystem, but this behavior will match the path provided in the Core API v1. Absent for
    /// unmounted files.
    @objc
    public var pathDisplay: String? { swift.pathDisplay }
    /// The lower-case full path of this file. Absent for unmounted files.
    @objc
    public var pathLower: String? { swift.pathLower }
    /// The sharing permissions that requesting user has on this file. This corresponds to the entries given in
    /// actions in GetFileMetadataBatchArg or actions in GetFileMetadataArg.
    @objc
    public var permissions: [DBXSharingFilePermission]? { swift.permissions?.map { DBXSharingFilePermission(swift: $0) } }
    /// Policies governing this shared file.
    @objc
    public var policy: DBXSharingFolderPolicy { DBXSharingFolderPolicy(swift: swift.policy) }
    /// URL for displaying a web preview of the shared file.
    @objc
    public var previewUrl: String { swift.previewUrl }
    /// Timestamp indicating when the current user was invited to this shared file. If the user was not invited to
    /// the shared file, the timestamp will indicate when the user was invited to the parent shared folder. This
    /// value may be absent.
    @objc
    public var timeInvited: Date? { swift.timeInvited }

    @objc
    public init(
        id: String,
        name: String,
        policy: DBXSharingFolderPolicy,
        previewUrl: String,
        accessType: DBXSharingAccessLevel?,
        expectedLinkMetadata: DBXSharingExpectedSharedContentLinkMetadata?,
        linkMetadata: DBXSharingSharedContentLinkMetadata?,
        ownerDisplayNames: [String]?,
        ownerTeam: DBXUsersTeam?,
        parentSharedFolderId: String?,
        pathDisplay: String?,
        pathLower: String?,
        permissions: [DBXSharingFilePermission]?,
        timeInvited: Date?
    ) {
        self.swift = Sharing.SharedFileMetadata(
            id: id,
            name: name,
            policy: policy.swift,
            previewUrl: previewUrl,
            accessType: accessType?.swift,
            expectedLinkMetadata: expectedLinkMetadata?.subSwift,
            linkMetadata: linkMetadata?.subSwift,
            ownerDisplayNames: ownerDisplayNames,
            ownerTeam: ownerTeam?.swift,
            parentSharedFolderId: parentSharedFolderId,
            pathDisplay: pathDisplay,
            pathLower: pathLower,
            permissions: permissions?.map(\.swift),
            timeInvited: timeInvited
        )
    }

    let swift: Sharing.SharedFileMetadata

    public init(swift: Sharing.SharedFileMetadata) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// There is an error accessing the shared folder.
@objc
public class DBXSharingSharedFolderAccessError: NSObject {
    let swift: Sharing.SharedFolderAccessError

    public init(swift: Sharing.SharedFolderAccessError) {
        self.swift = swift
    }

    public static func factory(swift: Sharing.SharedFolderAccessError) -> DBXSharingSharedFolderAccessError {
        switch swift {
        case .invalidId:
            return DBXSharingSharedFolderAccessErrorInvalidId()
        case .notAMember:
            return DBXSharingSharedFolderAccessErrorNotAMember()
        case .invalidMember:
            return DBXSharingSharedFolderAccessErrorInvalidMember()
        case .emailUnverified:
            return DBXSharingSharedFolderAccessErrorEmailUnverified()
        case .unmounted:
            return DBXSharingSharedFolderAccessErrorUnmounted()
        case .other:
            return DBXSharingSharedFolderAccessErrorOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asInvalidId: DBXSharingSharedFolderAccessErrorInvalidId? {
        self as? DBXSharingSharedFolderAccessErrorInvalidId
    }

    @objc
    public var asNotAMember: DBXSharingSharedFolderAccessErrorNotAMember? {
        self as? DBXSharingSharedFolderAccessErrorNotAMember
    }

    @objc
    public var asInvalidMember: DBXSharingSharedFolderAccessErrorInvalidMember? {
        self as? DBXSharingSharedFolderAccessErrorInvalidMember
    }

    @objc
    public var asEmailUnverified: DBXSharingSharedFolderAccessErrorEmailUnverified? {
        self as? DBXSharingSharedFolderAccessErrorEmailUnverified
    }

    @objc
    public var asUnmounted: DBXSharingSharedFolderAccessErrorUnmounted? {
        self as? DBXSharingSharedFolderAccessErrorUnmounted
    }

    @objc
    public var asOther: DBXSharingSharedFolderAccessErrorOther? {
        self as? DBXSharingSharedFolderAccessErrorOther
    }
}

/// This shared folder ID is invalid.
@objc
public class DBXSharingSharedFolderAccessErrorInvalidId: DBXSharingSharedFolderAccessError {
    @objc
    public init() {
        let swift = Sharing.SharedFolderAccessError.invalidId
        super.init(swift: swift)
    }
}

/// The user is not a member of the shared folder thus cannot access it.
@objc
public class DBXSharingSharedFolderAccessErrorNotAMember: DBXSharingSharedFolderAccessError {
    @objc
    public init() {
        let swift = Sharing.SharedFolderAccessError.notAMember
        super.init(swift: swift)
    }
}

/// The user does not exist or their account is disabled.
@objc
public class DBXSharingSharedFolderAccessErrorInvalidMember: DBXSharingSharedFolderAccessError {
    @objc
    public init() {
        let swift = Sharing.SharedFolderAccessError.invalidMember
        super.init(swift: swift)
    }
}

/// Never set.
@objc
public class DBXSharingSharedFolderAccessErrorEmailUnverified: DBXSharingSharedFolderAccessError {
    @objc
    public init() {
        let swift = Sharing.SharedFolderAccessError.emailUnverified
        super.init(swift: swift)
    }
}

/// The shared folder is unmounted.
@objc
public class DBXSharingSharedFolderAccessErrorUnmounted: DBXSharingSharedFolderAccessError {
    @objc
    public init() {
        let swift = Sharing.SharedFolderAccessError.unmounted
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXSharingSharedFolderAccessErrorOther: DBXSharingSharedFolderAccessError {
    @objc
    public init() {
        let swift = Sharing.SharedFolderAccessError.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible SharedFolderMemberError union
@objc
public class DBXSharingSharedFolderMemberError: NSObject {
    let swift: Sharing.SharedFolderMemberError

    public init(swift: Sharing.SharedFolderMemberError) {
        self.swift = swift
    }

    public static func factory(swift: Sharing.SharedFolderMemberError) -> DBXSharingSharedFolderMemberError {
        switch swift {
        case .invalidDropboxId:
            return DBXSharingSharedFolderMemberErrorInvalidDropboxId()
        case .notAMember:
            return DBXSharingSharedFolderMemberErrorNotAMember()
        case .noExplicitAccess(let swiftArg):
            let arg = DBXSharingMemberAccessLevelResult(swift: swiftArg)
            return DBXSharingSharedFolderMemberErrorNoExplicitAccess(arg)
        case .other:
            return DBXSharingSharedFolderMemberErrorOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asInvalidDropboxId: DBXSharingSharedFolderMemberErrorInvalidDropboxId? {
        self as? DBXSharingSharedFolderMemberErrorInvalidDropboxId
    }

    @objc
    public var asNotAMember: DBXSharingSharedFolderMemberErrorNotAMember? {
        self as? DBXSharingSharedFolderMemberErrorNotAMember
    }

    @objc
    public var asNoExplicitAccess: DBXSharingSharedFolderMemberErrorNoExplicitAccess? {
        self as? DBXSharingSharedFolderMemberErrorNoExplicitAccess
    }

    @objc
    public var asOther: DBXSharingSharedFolderMemberErrorOther? {
        self as? DBXSharingSharedFolderMemberErrorOther
    }
}

/// The target dropbox_id is invalid.
@objc
public class DBXSharingSharedFolderMemberErrorInvalidDropboxId: DBXSharingSharedFolderMemberError {
    @objc
    public init() {
        let swift = Sharing.SharedFolderMemberError.invalidDropboxId
        super.init(swift: swift)
    }
}

/// The target dropbox_id is not a member of the shared folder.
@objc
public class DBXSharingSharedFolderMemberErrorNotAMember: DBXSharingSharedFolderMemberError {
    @objc
    public init() {
        let swift = Sharing.SharedFolderMemberError.notAMember
        super.init(swift: swift)
    }
}

/// The target member only has inherited access to the shared folder.
@objc
public class DBXSharingSharedFolderMemberErrorNoExplicitAccess: DBXSharingSharedFolderMemberError {
    @objc
    public var noExplicitAccess: DBXSharingMemberAccessLevelResult

    @objc
    public init(_ arg: DBXSharingMemberAccessLevelResult) {
        self.noExplicitAccess = arg
        let swift = Sharing.SharedFolderMemberError.noExplicitAccess(arg.swift)
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXSharingSharedFolderMemberErrorOther: DBXSharingSharedFolderMemberError {
    @objc
    public init() {
        let swift = Sharing.SharedFolderMemberError.other
        super.init(swift: swift)
    }
}

/// Shared folder user and group membership.
@objc
public class DBXSharingSharedFolderMembers: NSObject {
    /// The list of user members of the shared folder.
    @objc
    public var users: [DBXSharingUserMembershipInfo] { swift.users.map { DBXSharingUserMembershipInfo(swift: $0) } }
    /// The list of group members of the shared folder.
    @objc
    public var groups: [DBXSharingGroupMembershipInfo] { swift.groups.map { DBXSharingGroupMembershipInfo(swift: $0) } }
    /// The list of invitees to the shared folder.
    @objc
    public var invitees: [DBXSharingInviteeMembershipInfo] { swift.invitees.map { DBXSharingInviteeMembershipInfo(swift: $0) } }
    /// Present if there are additional shared folder members that have not been returned yet. Pass the cursor into
    /// listFolderMembersContinue to list additional members.
    @objc
    public var cursor: String? { swift.cursor }

    @objc
    public init(users: [DBXSharingUserMembershipInfo], groups: [DBXSharingGroupMembershipInfo], invitees: [DBXSharingInviteeMembershipInfo], cursor: String?) {
        self.swift = Sharing.SharedFolderMembers(
            users: users.map(\.subSwift),
            groups: groups.map(\.subSwift),
            invitees: invitees.map(\.subSwift),
            cursor: cursor
        )
    }

    let swift: Sharing.SharedFolderMembers

    public init(swift: Sharing.SharedFolderMembers) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Properties of the shared folder.
@objc
public class DBXSharingSharedFolderMetadataBase: NSObject {
    /// The current user's access level for this shared folder.
    @objc
    public var accessType: DBXSharingAccessLevel { DBXSharingAccessLevel(swift: swift.accessType) }
    /// Whether this folder is inside of a team folder.
    @objc
    public var isInsideTeamFolder: NSNumber { swift.isInsideTeamFolder as NSNumber }
    /// Whether this folder is a team folder https://www.dropbox.com/en/help/986.
    @objc
    public var isTeamFolder: NSNumber { swift.isTeamFolder as NSNumber }
    /// The display names of the users that own the folder. If the folder is part of a team folder, the display
    /// names of the team admins are also included. Absent if the owner display names cannot be fetched.
    @objc
    public var ownerDisplayNames: [String]? { swift.ownerDisplayNames }
    /// The team that owns the folder. This field is not present if the folder is not owned by a team.
    @objc
    public var ownerTeam: DBXUsersTeam? { guard let swift = swift.ownerTeam else { return nil }
        return DBXUsersTeam(swift: swift)
    }

    /// The ID of the parent shared folder. This field is present only if the folder is contained within another
    /// shared folder.
    @objc
    public var parentSharedFolderId: String? { swift.parentSharedFolderId }
    /// The full path of this shared folder. Absent for unmounted folders.
    @objc
    public var pathDisplay: String? { swift.pathDisplay }
    /// The lower-cased full path of this shared folder. Absent for unmounted folders.
    @objc
    public var pathLower: String? { swift.pathLower }
    /// Display name for the parent folder.
    @objc
    public var parentFolderName: String? { swift.parentFolderName }

    @objc
    public init(
        accessType: DBXSharingAccessLevel,
        isInsideTeamFolder: NSNumber,
        isTeamFolder: NSNumber,
        ownerDisplayNames: [String]?,
        ownerTeam: DBXUsersTeam?,
        parentSharedFolderId: String?,
        pathDisplay: String?,
        pathLower: String?,
        parentFolderName: String?
    ) {
        self.swift = Sharing.SharedFolderMetadataBase(
            accessType: accessType.swift,
            isInsideTeamFolder: isInsideTeamFolder.boolValue,
            isTeamFolder: isTeamFolder.boolValue,
            ownerDisplayNames: ownerDisplayNames,
            ownerTeam: ownerTeam?.swift,
            parentSharedFolderId: parentSharedFolderId,
            pathDisplay: pathDisplay,
            pathLower: pathLower,
            parentFolderName: parentFolderName
        )
    }

    let swift: Sharing.SharedFolderMetadataBase

    public init(swift: Sharing.SharedFolderMetadataBase) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// The metadata which includes basic information about the shared folder.
@objc
public class DBXSharingSharedFolderMetadata: DBXSharingSharedFolderMetadataBase {
    /// The metadata of the shared content link to this shared folder. Absent if there is no link on the folder.
    /// This is for an unreleased feature so it may not be returned yet.
    @objc
    public var linkMetadata: DBXSharingSharedContentLinkMetadata? { guard let swift = subSwift.linkMetadata else { return nil }
        return DBXSharingSharedContentLinkMetadata(swift: swift)
    }

    /// The name of the this shared folder.
    @objc
    public var name: String { subSwift.name }
    /// Actions the current user may perform on the folder and its contents. The set of permissions corresponds to
    /// the FolderActions in the request.
    @objc
    public var permissions: [DBXSharingFolderPermission]? { subSwift.permissions?.map { DBXSharingFolderPermission(swift: $0) } }
    /// Policies governing this shared folder.
    @objc
    public var policy: DBXSharingFolderPolicy { DBXSharingFolderPolicy(swift: subSwift.policy) }
    /// URL for displaying a web preview of the shared folder.
    @objc
    public var previewUrl: String { subSwift.previewUrl }
    /// The ID of the shared folder.
    @objc
    public var sharedFolderId: String { subSwift.sharedFolderId }
    /// Timestamp indicating when the current user was invited to this shared folder.
    @objc
    public var timeInvited: Date { subSwift.timeInvited }
    /// Whether the folder inherits its members from its parent.
    @objc
    public var accessInheritance: DBXSharingAccessInheritance { DBXSharingAccessInheritance(swift: subSwift.accessInheritance) }

    @objc
    public init(
        accessType: DBXSharingAccessLevel,
        isInsideTeamFolder: NSNumber,
        isTeamFolder: NSNumber,
        name: String,
        policy: DBXSharingFolderPolicy,
        previewUrl: String,
        sharedFolderId: String,
        timeInvited: Date,
        ownerDisplayNames: [String]?,
        ownerTeam: DBXUsersTeam?,
        parentSharedFolderId: String?,
        pathDisplay: String?,
        pathLower: String?,
        parentFolderName: String?,
        linkMetadata: DBXSharingSharedContentLinkMetadata?,
        permissions: [DBXSharingFolderPermission]?,
        accessInheritance: DBXSharingAccessInheritance
    ) {
        let swift = Sharing.SharedFolderMetadata(
            accessType: accessType.swift,
            isInsideTeamFolder: isInsideTeamFolder.boolValue,
            isTeamFolder: isTeamFolder.boolValue,
            name: name,
            policy: policy.swift,
            previewUrl: previewUrl,
            sharedFolderId: sharedFolderId,
            timeInvited: timeInvited,
            ownerDisplayNames: ownerDisplayNames,
            ownerTeam: ownerTeam?.swift,
            parentSharedFolderId: parentSharedFolderId,
            pathDisplay: pathDisplay,
            pathLower: pathLower,
            parentFolderName: parentFolderName,
            linkMetadata: linkMetadata?.subSwift,
            permissions: permissions?.map(\.swift),
            accessInheritance: accessInheritance.swift
        )
        self.subSwift = swift
        super.init(swift: swift)
    }

    let subSwift: Sharing.SharedFolderMetadata

    public init(swift: Sharing.SharedFolderMetadata) {
        self.subSwift = swift
        super.init(swift: swift)
    }

    @objc
    public override var description: String { subSwift.description }
}

/// Objective-C compatible SharedLinkAccessFailureReason union
@objc
public class DBXSharingSharedLinkAccessFailureReason: NSObject {
    let swift: Sharing.SharedLinkAccessFailureReason

    public init(swift: Sharing.SharedLinkAccessFailureReason) {
        self.swift = swift
    }

    public static func factory(swift: Sharing.SharedLinkAccessFailureReason) -> DBXSharingSharedLinkAccessFailureReason {
        switch swift {
        case .loginRequired:
            return DBXSharingSharedLinkAccessFailureReasonLoginRequired()
        case .emailVerifyRequired:
            return DBXSharingSharedLinkAccessFailureReasonEmailVerifyRequired()
        case .passwordRequired:
            return DBXSharingSharedLinkAccessFailureReasonPasswordRequired()
        case .teamOnly:
            return DBXSharingSharedLinkAccessFailureReasonTeamOnly()
        case .ownerOnly:
            return DBXSharingSharedLinkAccessFailureReasonOwnerOnly()
        case .other:
            return DBXSharingSharedLinkAccessFailureReasonOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asLoginRequired: DBXSharingSharedLinkAccessFailureReasonLoginRequired? {
        self as? DBXSharingSharedLinkAccessFailureReasonLoginRequired
    }

    @objc
    public var asEmailVerifyRequired: DBXSharingSharedLinkAccessFailureReasonEmailVerifyRequired? {
        self as? DBXSharingSharedLinkAccessFailureReasonEmailVerifyRequired
    }

    @objc
    public var asPasswordRequired: DBXSharingSharedLinkAccessFailureReasonPasswordRequired? {
        self as? DBXSharingSharedLinkAccessFailureReasonPasswordRequired
    }

    @objc
    public var asTeamOnly: DBXSharingSharedLinkAccessFailureReasonTeamOnly? {
        self as? DBXSharingSharedLinkAccessFailureReasonTeamOnly
    }

    @objc
    public var asOwnerOnly: DBXSharingSharedLinkAccessFailureReasonOwnerOnly? {
        self as? DBXSharingSharedLinkAccessFailureReasonOwnerOnly
    }

    @objc
    public var asOther: DBXSharingSharedLinkAccessFailureReasonOther? {
        self as? DBXSharingSharedLinkAccessFailureReasonOther
    }
}

/// User is not logged in.
@objc
public class DBXSharingSharedLinkAccessFailureReasonLoginRequired: DBXSharingSharedLinkAccessFailureReason {
    @objc
    public init() {
        let swift = Sharing.SharedLinkAccessFailureReason.loginRequired
        super.init(swift: swift)
    }
}

/// This user's email address is not verified. This functionality is only available on accounts with a verified
/// email address. Users can verify their email address here https://www.dropbox.com/help/317.
@objc
public class DBXSharingSharedLinkAccessFailureReasonEmailVerifyRequired: DBXSharingSharedLinkAccessFailureReason {
    @objc
    public init() {
        let swift = Sharing.SharedLinkAccessFailureReason.emailVerifyRequired
        super.init(swift: swift)
    }
}

/// The link is password protected.
@objc
public class DBXSharingSharedLinkAccessFailureReasonPasswordRequired: DBXSharingSharedLinkAccessFailureReason {
    @objc
    public init() {
        let swift = Sharing.SharedLinkAccessFailureReason.passwordRequired
        super.init(swift: swift)
    }
}

/// Access is allowed for team members only.
@objc
public class DBXSharingSharedLinkAccessFailureReasonTeamOnly: DBXSharingSharedLinkAccessFailureReason {
    @objc
    public init() {
        let swift = Sharing.SharedLinkAccessFailureReason.teamOnly
        super.init(swift: swift)
    }
}

/// Access is allowed for the shared link's owner only.
@objc
public class DBXSharingSharedLinkAccessFailureReasonOwnerOnly: DBXSharingSharedLinkAccessFailureReason {
    @objc
    public init() {
        let swift = Sharing.SharedLinkAccessFailureReason.ownerOnly
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXSharingSharedLinkAccessFailureReasonOther: DBXSharingSharedLinkAccessFailureReason {
    @objc
    public init() {
        let swift = Sharing.SharedLinkAccessFailureReason.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible SharedLinkAlreadyExistsMetadata union
@objc
public class DBXSharingSharedLinkAlreadyExistsMetadata: NSObject {
    let swift: Sharing.SharedLinkAlreadyExistsMetadata

    public init(swift: Sharing.SharedLinkAlreadyExistsMetadata) {
        self.swift = swift
    }

    public static func factory(swift: Sharing.SharedLinkAlreadyExistsMetadata) -> DBXSharingSharedLinkAlreadyExistsMetadata {
        switch swift {
        case .metadata(let swiftArg):
            let arg = DBXSharingSharedLinkMetadata(swift: swiftArg)
            return DBXSharingSharedLinkAlreadyExistsMetadataMetadata(arg)
        case .other:
            return DBXSharingSharedLinkAlreadyExistsMetadataOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asMetadata: DBXSharingSharedLinkAlreadyExistsMetadataMetadata? {
        self as? DBXSharingSharedLinkAlreadyExistsMetadataMetadata
    }

    @objc
    public var asOther: DBXSharingSharedLinkAlreadyExistsMetadataOther? {
        self as? DBXSharingSharedLinkAlreadyExistsMetadataOther
    }
}

/// Metadata of the shared link that already exists.
@objc
public class DBXSharingSharedLinkAlreadyExistsMetadataMetadata: DBXSharingSharedLinkAlreadyExistsMetadata {
    @objc
    public var metadata: DBXSharingSharedLinkMetadata

    @objc
    public init(_ arg: DBXSharingSharedLinkMetadata) {
        self.metadata = arg
        let swift = Sharing.SharedLinkAlreadyExistsMetadata.metadata(arg.swift)
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXSharingSharedLinkAlreadyExistsMetadataOther: DBXSharingSharedLinkAlreadyExistsMetadata {
    @objc
    public init() {
        let swift = Sharing.SharedLinkAlreadyExistsMetadata.other
        super.init(swift: swift)
    }
}

/// Who can view shared links in this folder.
@objc
public class DBXSharingSharedLinkPolicy: NSObject {
    let swift: Sharing.SharedLinkPolicy

    public init(swift: Sharing.SharedLinkPolicy) {
        self.swift = swift
    }

    public static func factory(swift: Sharing.SharedLinkPolicy) -> DBXSharingSharedLinkPolicy {
        switch swift {
        case .anyone:
            return DBXSharingSharedLinkPolicyAnyone()
        case .team:
            return DBXSharingSharedLinkPolicyTeam()
        case .members:
            return DBXSharingSharedLinkPolicyMembers()
        case .other:
            return DBXSharingSharedLinkPolicyOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asAnyone: DBXSharingSharedLinkPolicyAnyone? {
        self as? DBXSharingSharedLinkPolicyAnyone
    }

    @objc
    public var asTeam: DBXSharingSharedLinkPolicyTeam? {
        self as? DBXSharingSharedLinkPolicyTeam
    }

    @objc
    public var asMembers: DBXSharingSharedLinkPolicyMembers? {
        self as? DBXSharingSharedLinkPolicyMembers
    }

    @objc
    public var asOther: DBXSharingSharedLinkPolicyOther? {
        self as? DBXSharingSharedLinkPolicyOther
    }
}

/// Links can be shared with anyone.
@objc
public class DBXSharingSharedLinkPolicyAnyone: DBXSharingSharedLinkPolicy {
    @objc
    public init() {
        let swift = Sharing.SharedLinkPolicy.anyone
        super.init(swift: swift)
    }
}

/// Links can be shared with anyone on the same team as the owner.
@objc
public class DBXSharingSharedLinkPolicyTeam: DBXSharingSharedLinkPolicy {
    @objc
    public init() {
        let swift = Sharing.SharedLinkPolicy.team
        super.init(swift: swift)
    }
}

/// Links can only be shared among members of the shared folder.
@objc
public class DBXSharingSharedLinkPolicyMembers: DBXSharingSharedLinkPolicy {
    @objc
    public init() {
        let swift = Sharing.SharedLinkPolicy.members
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXSharingSharedLinkPolicyOther: DBXSharingSharedLinkPolicy {
    @objc
    public init() {
        let swift = Sharing.SharedLinkPolicy.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible SharedLinkSettings struct
@objc
public class DBXSharingSharedLinkSettings: NSObject {
    /// Boolean flag to enable or disable password protection.
    @objc
    public var requirePassword: NSNumber? { swift.requirePassword as NSNumber? }
    /// If requirePassword is true, this is needed to specify the password to access the link.
    @objc
    public var linkPassword: String? { swift.linkPassword }
    /// Expiration time of the shared link. By default the link won't expire.
    @objc
    public var expires: Date? { swift.expires }
    /// The new audience who can benefit from the access level specified by the link's access level specified in the
    /// `link_access_level` field of `LinkPermissions`. This is used in conjunction with team policies and
    /// shared folder policies to determine the final effective audience type in the `effective_audience` field
    /// of `LinkPermissions.
    @objc
    public var audience: DBXSharingLinkAudience? { guard let swift = swift.audience else { return nil }
        return DBXSharingLinkAudience(swift: swift)
    }

    /// Requested access level you want the audience to gain from this link. Note, modifying access level for an
    /// existing link is not supported.
    @objc
    public var access: DBXSharingRequestedLinkAccessLevel? { guard let swift = swift.access else { return nil }
        return DBXSharingRequestedLinkAccessLevel(swift: swift)
    }

    /// Use audience instead.  The requested access for this shared link.
    @objc
    public var requestedVisibility: DBXSharingRequestedVisibility? { guard let swift = swift.requestedVisibility else { return nil }
        return DBXSharingRequestedVisibility(swift: swift)
    }

    /// Boolean flag to allow or not download capabilities for shared links.
    @objc
    public var allowDownload: NSNumber? { swift.allowDownload as NSNumber? }

    @objc
    public init(
        requirePassword: NSNumber?,
        linkPassword: String?,
        expires: Date?,
        audience: DBXSharingLinkAudience?,
        access: DBXSharingRequestedLinkAccessLevel?,
        requestedVisibility: DBXSharingRequestedVisibility?,
        allowDownload: NSNumber?
    ) {
        self.swift = Sharing.SharedLinkSettings(
            requirePassword: requirePassword?.boolValue,
            linkPassword: linkPassword,
            expires: expires,
            audience: audience?.swift,
            access: access?.swift,
            requestedVisibility: requestedVisibility?.swift,
            allowDownload: allowDownload?.boolValue
        )
    }

    let swift: Sharing.SharedLinkSettings

    public init(swift: Sharing.SharedLinkSettings) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible SharedLinkSettingsError union
@objc
public class DBXSharingSharedLinkSettingsError: NSObject {
    let swift: Sharing.SharedLinkSettingsError

    public init(swift: Sharing.SharedLinkSettingsError) {
        self.swift = swift
    }

    public static func factory(swift: Sharing.SharedLinkSettingsError) -> DBXSharingSharedLinkSettingsError {
        switch swift {
        case .invalidSettings:
            return DBXSharingSharedLinkSettingsErrorInvalidSettings()
        case .notAuthorized:
            return DBXSharingSharedLinkSettingsErrorNotAuthorized()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asInvalidSettings: DBXSharingSharedLinkSettingsErrorInvalidSettings? {
        self as? DBXSharingSharedLinkSettingsErrorInvalidSettings
    }

    @objc
    public var asNotAuthorized: DBXSharingSharedLinkSettingsErrorNotAuthorized? {
        self as? DBXSharingSharedLinkSettingsErrorNotAuthorized
    }
}

/// The given settings are invalid (for example, all attributes of the SharedLinkSettings are empty, the
/// requested visibility is password in RequestedVisibility but the linkPassword in SharedLinkSettings
/// is missing, expires in SharedLinkSettings is set to the past, etc.).
@objc
public class DBXSharingSharedLinkSettingsErrorInvalidSettings: DBXSharingSharedLinkSettingsError {
    @objc
    public init() {
        let swift = Sharing.SharedLinkSettingsError.invalidSettings
        super.init(swift: swift)
    }
}

/// User is not allowed to modify the settings of this link. Note that basic users can only set public_ in
/// RequestedVisibility as the requestedVisibility in SharedLinkSettings and cannot set expires in
/// SharedLinkSettings.
@objc
public class DBXSharingSharedLinkSettingsErrorNotAuthorized: DBXSharingSharedLinkSettingsError {
    @objc
    public init() {
        let swift = Sharing.SharedLinkSettingsError.notAuthorized
        super.init(swift: swift)
    }
}

/// User could not access this file.
@objc
public class DBXSharingSharingFileAccessError: NSObject {
    let swift: Sharing.SharingFileAccessError

    public init(swift: Sharing.SharingFileAccessError) {
        self.swift = swift
    }

    public static func factory(swift: Sharing.SharingFileAccessError) -> DBXSharingSharingFileAccessError {
        switch swift {
        case .noPermission:
            return DBXSharingSharingFileAccessErrorNoPermission()
        case .invalidFile:
            return DBXSharingSharingFileAccessErrorInvalidFile()
        case .isFolder:
            return DBXSharingSharingFileAccessErrorIsFolder()
        case .insidePublicFolder:
            return DBXSharingSharingFileAccessErrorInsidePublicFolder()
        case .insideOsxPackage:
            return DBXSharingSharingFileAccessErrorInsideOsxPackage()
        case .other:
            return DBXSharingSharingFileAccessErrorOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asNoPermission: DBXSharingSharingFileAccessErrorNoPermission? {
        self as? DBXSharingSharingFileAccessErrorNoPermission
    }

    @objc
    public var asInvalidFile: DBXSharingSharingFileAccessErrorInvalidFile? {
        self as? DBXSharingSharingFileAccessErrorInvalidFile
    }

    @objc
    public var asIsFolder: DBXSharingSharingFileAccessErrorIsFolder? {
        self as? DBXSharingSharingFileAccessErrorIsFolder
    }

    @objc
    public var asInsidePublicFolder: DBXSharingSharingFileAccessErrorInsidePublicFolder? {
        self as? DBXSharingSharingFileAccessErrorInsidePublicFolder
    }

    @objc
    public var asInsideOsxPackage: DBXSharingSharingFileAccessErrorInsideOsxPackage? {
        self as? DBXSharingSharingFileAccessErrorInsideOsxPackage
    }

    @objc
    public var asOther: DBXSharingSharingFileAccessErrorOther? {
        self as? DBXSharingSharingFileAccessErrorOther
    }
}

/// Current user does not have sufficient privileges to perform the desired action.
@objc
public class DBXSharingSharingFileAccessErrorNoPermission: DBXSharingSharingFileAccessError {
    @objc
    public init() {
        let swift = Sharing.SharingFileAccessError.noPermission
        super.init(swift: swift)
    }
}

/// File specified was not found.
@objc
public class DBXSharingSharingFileAccessErrorInvalidFile: DBXSharingSharingFileAccessError {
    @objc
    public init() {
        let swift = Sharing.SharingFileAccessError.invalidFile
        super.init(swift: swift)
    }
}

/// A folder can't be shared this way. Use folder sharing or a shared link instead.
@objc
public class DBXSharingSharingFileAccessErrorIsFolder: DBXSharingSharingFileAccessError {
    @objc
    public init() {
        let swift = Sharing.SharingFileAccessError.isFolder
        super.init(swift: swift)
    }
}

/// A file inside a public folder can't be shared this way. Use a public link instead.
@objc
public class DBXSharingSharingFileAccessErrorInsidePublicFolder: DBXSharingSharingFileAccessError {
    @objc
    public init() {
        let swift = Sharing.SharingFileAccessError.insidePublicFolder
        super.init(swift: swift)
    }
}

/// A Mac OS X package can't be shared this way. Use a shared link instead.
@objc
public class DBXSharingSharingFileAccessErrorInsideOsxPackage: DBXSharingSharingFileAccessError {
    @objc
    public init() {
        let swift = Sharing.SharingFileAccessError.insideOsxPackage
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXSharingSharingFileAccessErrorOther: DBXSharingSharingFileAccessError {
    @objc
    public init() {
        let swift = Sharing.SharingFileAccessError.other
        super.init(swift: swift)
    }
}

/// User account had a problem preventing this action.
@objc
public class DBXSharingSharingUserError: NSObject {
    let swift: Sharing.SharingUserError

    public init(swift: Sharing.SharingUserError) {
        self.swift = swift
    }

    public static func factory(swift: Sharing.SharingUserError) -> DBXSharingSharingUserError {
        switch swift {
        case .emailUnverified:
            return DBXSharingSharingUserErrorEmailUnverified()
        case .other:
            return DBXSharingSharingUserErrorOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asEmailUnverified: DBXSharingSharingUserErrorEmailUnverified? {
        self as? DBXSharingSharingUserErrorEmailUnverified
    }

    @objc
    public var asOther: DBXSharingSharingUserErrorOther? {
        self as? DBXSharingSharingUserErrorOther
    }
}

/// This user's email address is not verified. This functionality is only available on accounts with a verified
/// email address. Users can verify their email address here https://www.dropbox.com/help/317.
@objc
public class DBXSharingSharingUserErrorEmailUnverified: DBXSharingSharingUserError {
    @objc
    public init() {
        let swift = Sharing.SharingUserError.emailUnverified
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXSharingSharingUserErrorOther: DBXSharingSharingUserError {
    @objc
    public init() {
        let swift = Sharing.SharingUserError.other
        super.init(swift: swift)
    }
}

/// Information about a team member.
@objc
public class DBXSharingTeamMemberInfo: NSObject {
    /// Information about the member's team.
    @objc
    public var teamInfo: DBXUsersTeam { DBXUsersTeam(swift: swift.teamInfo) }
    /// The display name of the user.
    @objc
    public var displayName: String { swift.displayName }
    /// ID of user as a member of a team. This field will only be present if the member is in the same team as
    /// current user.
    @objc
    public var memberId: String? { swift.memberId }

    @objc
    public init(teamInfo: DBXUsersTeam, displayName: String, memberId: String?) {
        self.swift = Sharing.TeamMemberInfo(teamInfo: teamInfo.swift, displayName: displayName, memberId: memberId)
    }

    let swift: Sharing.TeamMemberInfo

    public init(swift: Sharing.TeamMemberInfo) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible TransferFolderArg struct
@objc
public class DBXSharingTransferFolderArg: NSObject {
    /// The ID for the shared folder.
    @objc
    public var sharedFolderId: String { swift.sharedFolderId }
    /// A account or team member ID to transfer ownership to.
    @objc
    public var toDropboxId: String { swift.toDropboxId }

    @objc
    public init(sharedFolderId: String, toDropboxId: String) {
        self.swift = Sharing.TransferFolderArg(sharedFolderId: sharedFolderId, toDropboxId: toDropboxId)
    }

    let swift: Sharing.TransferFolderArg

    public init(swift: Sharing.TransferFolderArg) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible TransferFolderError union
@objc
public class DBXSharingTransferFolderError: NSObject {
    let swift: Sharing.TransferFolderError

    public init(swift: Sharing.TransferFolderError) {
        self.swift = swift
    }

    public static func factory(swift: Sharing.TransferFolderError) -> DBXSharingTransferFolderError {
        switch swift {
        case .accessError(let swiftArg):
            let arg = DBXSharingSharedFolderAccessError(swift: swiftArg)
            return DBXSharingTransferFolderErrorAccessError(arg)
        case .invalidDropboxId:
            return DBXSharingTransferFolderErrorInvalidDropboxId()
        case .newOwnerNotAMember:
            return DBXSharingTransferFolderErrorNewOwnerNotAMember()
        case .newOwnerUnmounted:
            return DBXSharingTransferFolderErrorNewOwnerUnmounted()
        case .newOwnerEmailUnverified:
            return DBXSharingTransferFolderErrorNewOwnerEmailUnverified()
        case .teamFolder:
            return DBXSharingTransferFolderErrorTeamFolder()
        case .noPermission:
            return DBXSharingTransferFolderErrorNoPermission()
        case .other:
            return DBXSharingTransferFolderErrorOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asAccessError: DBXSharingTransferFolderErrorAccessError? {
        self as? DBXSharingTransferFolderErrorAccessError
    }

    @objc
    public var asInvalidDropboxId: DBXSharingTransferFolderErrorInvalidDropboxId? {
        self as? DBXSharingTransferFolderErrorInvalidDropboxId
    }

    @objc
    public var asNewOwnerNotAMember: DBXSharingTransferFolderErrorNewOwnerNotAMember? {
        self as? DBXSharingTransferFolderErrorNewOwnerNotAMember
    }

    @objc
    public var asNewOwnerUnmounted: DBXSharingTransferFolderErrorNewOwnerUnmounted? {
        self as? DBXSharingTransferFolderErrorNewOwnerUnmounted
    }

    @objc
    public var asNewOwnerEmailUnverified: DBXSharingTransferFolderErrorNewOwnerEmailUnverified? {
        self as? DBXSharingTransferFolderErrorNewOwnerEmailUnverified
    }

    @objc
    public var asTeamFolder: DBXSharingTransferFolderErrorTeamFolder? {
        self as? DBXSharingTransferFolderErrorTeamFolder
    }

    @objc
    public var asNoPermission: DBXSharingTransferFolderErrorNoPermission? {
        self as? DBXSharingTransferFolderErrorNoPermission
    }

    @objc
    public var asOther: DBXSharingTransferFolderErrorOther? {
        self as? DBXSharingTransferFolderErrorOther
    }
}

/// An unspecified error.
@objc
public class DBXSharingTransferFolderErrorAccessError: DBXSharingTransferFolderError {
    @objc
    public var accessError: DBXSharingSharedFolderAccessError

    @objc
    public init(_ arg: DBXSharingSharedFolderAccessError) {
        self.accessError = arg
        let swift = Sharing.TransferFolderError.accessError(arg.swift)
        super.init(swift: swift)
    }
}

/// toDropboxId in TransferFolderArg is invalid.
@objc
public class DBXSharingTransferFolderErrorInvalidDropboxId: DBXSharingTransferFolderError {
    @objc
    public init() {
        let swift = Sharing.TransferFolderError.invalidDropboxId
        super.init(swift: swift)
    }
}

/// The new designated owner is not currently a member of the shared folder.
@objc
public class DBXSharingTransferFolderErrorNewOwnerNotAMember: DBXSharingTransferFolderError {
    @objc
    public init() {
        let swift = Sharing.TransferFolderError.newOwnerNotAMember
        super.init(swift: swift)
    }
}

/// The new designated owner has not added the folder to their Dropbox.
@objc
public class DBXSharingTransferFolderErrorNewOwnerUnmounted: DBXSharingTransferFolderError {
    @objc
    public init() {
        let swift = Sharing.TransferFolderError.newOwnerUnmounted
        super.init(swift: swift)
    }
}

/// The new designated owner's email address is not verified. This functionality is only available on accounts
/// with a verified email address. Users can verify their email address here
/// https://www.dropbox.com/help/317.
@objc
public class DBXSharingTransferFolderErrorNewOwnerEmailUnverified: DBXSharingTransferFolderError {
    @objc
    public init() {
        let swift = Sharing.TransferFolderError.newOwnerEmailUnverified
        super.init(swift: swift)
    }
}

/// This action cannot be performed on a team shared folder.
@objc
public class DBXSharingTransferFolderErrorTeamFolder: DBXSharingTransferFolderError {
    @objc
    public init() {
        let swift = Sharing.TransferFolderError.teamFolder
        super.init(swift: swift)
    }
}

/// The current user does not have permission to perform this action.
@objc
public class DBXSharingTransferFolderErrorNoPermission: DBXSharingTransferFolderError {
    @objc
    public init() {
        let swift = Sharing.TransferFolderError.noPermission
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXSharingTransferFolderErrorOther: DBXSharingTransferFolderError {
    @objc
    public init() {
        let swift = Sharing.TransferFolderError.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible UnmountFolderArg struct
@objc
public class DBXSharingUnmountFolderArg: NSObject {
    /// The ID for the shared folder.
    @objc
    public var sharedFolderId: String { swift.sharedFolderId }

    @objc
    public init(sharedFolderId: String) {
        self.swift = Sharing.UnmountFolderArg(sharedFolderId: sharedFolderId)
    }

    let swift: Sharing.UnmountFolderArg

    public init(swift: Sharing.UnmountFolderArg) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible UnmountFolderError union
@objc
public class DBXSharingUnmountFolderError: NSObject {
    let swift: Sharing.UnmountFolderError

    public init(swift: Sharing.UnmountFolderError) {
        self.swift = swift
    }

    public static func factory(swift: Sharing.UnmountFolderError) -> DBXSharingUnmountFolderError {
        switch swift {
        case .accessError(let swiftArg):
            let arg = DBXSharingSharedFolderAccessError(swift: swiftArg)
            return DBXSharingUnmountFolderErrorAccessError(arg)
        case .noPermission:
            return DBXSharingUnmountFolderErrorNoPermission()
        case .notUnmountable:
            return DBXSharingUnmountFolderErrorNotUnmountable()
        case .other:
            return DBXSharingUnmountFolderErrorOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asAccessError: DBXSharingUnmountFolderErrorAccessError? {
        self as? DBXSharingUnmountFolderErrorAccessError
    }

    @objc
    public var asNoPermission: DBXSharingUnmountFolderErrorNoPermission? {
        self as? DBXSharingUnmountFolderErrorNoPermission
    }

    @objc
    public var asNotUnmountable: DBXSharingUnmountFolderErrorNotUnmountable? {
        self as? DBXSharingUnmountFolderErrorNotUnmountable
    }

    @objc
    public var asOther: DBXSharingUnmountFolderErrorOther? {
        self as? DBXSharingUnmountFolderErrorOther
    }
}

/// An unspecified error.
@objc
public class DBXSharingUnmountFolderErrorAccessError: DBXSharingUnmountFolderError {
    @objc
    public var accessError: DBXSharingSharedFolderAccessError

    @objc
    public init(_ arg: DBXSharingSharedFolderAccessError) {
        self.accessError = arg
        let swift = Sharing.UnmountFolderError.accessError(arg.swift)
        super.init(swift: swift)
    }
}

/// The current user does not have permission to perform this action.
@objc
public class DBXSharingUnmountFolderErrorNoPermission: DBXSharingUnmountFolderError {
    @objc
    public init() {
        let swift = Sharing.UnmountFolderError.noPermission
        super.init(swift: swift)
    }
}

/// The shared folder can't be unmounted. One example where this can occur is when the shared folder's parent
/// folder is also a shared folder that resides in the current user's Dropbox.
@objc
public class DBXSharingUnmountFolderErrorNotUnmountable: DBXSharingUnmountFolderError {
    @objc
    public init() {
        let swift = Sharing.UnmountFolderError.notUnmountable
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXSharingUnmountFolderErrorOther: DBXSharingUnmountFolderError {
    @objc
    public init() {
        let swift = Sharing.UnmountFolderError.other
        super.init(swift: swift)
    }
}

/// Arguments for unshareFile.
@objc
public class DBXSharingUnshareFileArg: NSObject {
    /// The file to unshare.
    @objc
    public var file: String { swift.file }

    @objc
    public init(file: String) {
        self.swift = Sharing.UnshareFileArg(file: file)
    }

    let swift: Sharing.UnshareFileArg

    public init(swift: Sharing.UnshareFileArg) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Error result for unshareFile.
@objc
public class DBXSharingUnshareFileError: NSObject {
    let swift: Sharing.UnshareFileError

    public init(swift: Sharing.UnshareFileError) {
        self.swift = swift
    }

    public static func factory(swift: Sharing.UnshareFileError) -> DBXSharingUnshareFileError {
        switch swift {
        case .userError(let swiftArg):
            let arg = DBXSharingSharingUserError(swift: swiftArg)
            return DBXSharingUnshareFileErrorUserError(arg)
        case .accessError(let swiftArg):
            let arg = DBXSharingSharingFileAccessError(swift: swiftArg)
            return DBXSharingUnshareFileErrorAccessError(arg)
        case .other:
            return DBXSharingUnshareFileErrorOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asUserError: DBXSharingUnshareFileErrorUserError? {
        self as? DBXSharingUnshareFileErrorUserError
    }

    @objc
    public var asAccessError: DBXSharingUnshareFileErrorAccessError? {
        self as? DBXSharingUnshareFileErrorAccessError
    }

    @objc
    public var asOther: DBXSharingUnshareFileErrorOther? {
        self as? DBXSharingUnshareFileErrorOther
    }
}

/// An unspecified error.
@objc
public class DBXSharingUnshareFileErrorUserError: DBXSharingUnshareFileError {
    @objc
    public var userError: DBXSharingSharingUserError

    @objc
    public init(_ arg: DBXSharingSharingUserError) {
        self.userError = arg
        let swift = Sharing.UnshareFileError.userError(arg.swift)
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXSharingUnshareFileErrorAccessError: DBXSharingUnshareFileError {
    @objc
    public var accessError: DBXSharingSharingFileAccessError

    @objc
    public init(_ arg: DBXSharingSharingFileAccessError) {
        self.accessError = arg
        let swift = Sharing.UnshareFileError.accessError(arg.swift)
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXSharingUnshareFileErrorOther: DBXSharingUnshareFileError {
    @objc
    public init() {
        let swift = Sharing.UnshareFileError.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible UnshareFolderArg struct
@objc
public class DBXSharingUnshareFolderArg: NSObject {
    /// The ID for the shared folder.
    @objc
    public var sharedFolderId: String { swift.sharedFolderId }
    /// If true, members of this shared folder will get a copy of this folder after it's unshared. Otherwise, it
    /// will be removed from their Dropbox. The current user, who is an owner, will always retain their copy.
    @objc
    public var leaveACopy: NSNumber { swift.leaveACopy as NSNumber }

    @objc
    public init(sharedFolderId: String, leaveACopy: NSNumber) {
        self.swift = Sharing.UnshareFolderArg(sharedFolderId: sharedFolderId, leaveACopy: leaveACopy.boolValue)
    }

    let swift: Sharing.UnshareFolderArg

    public init(swift: Sharing.UnshareFolderArg) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible UnshareFolderError union
@objc
public class DBXSharingUnshareFolderError: NSObject {
    let swift: Sharing.UnshareFolderError

    public init(swift: Sharing.UnshareFolderError) {
        self.swift = swift
    }

    public static func factory(swift: Sharing.UnshareFolderError) -> DBXSharingUnshareFolderError {
        switch swift {
        case .accessError(let swiftArg):
            let arg = DBXSharingSharedFolderAccessError(swift: swiftArg)
            return DBXSharingUnshareFolderErrorAccessError(arg)
        case .teamFolder:
            return DBXSharingUnshareFolderErrorTeamFolder()
        case .noPermission:
            return DBXSharingUnshareFolderErrorNoPermission()
        case .tooManyFiles:
            return DBXSharingUnshareFolderErrorTooManyFiles()
        case .other:
            return DBXSharingUnshareFolderErrorOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asAccessError: DBXSharingUnshareFolderErrorAccessError? {
        self as? DBXSharingUnshareFolderErrorAccessError
    }

    @objc
    public var asTeamFolder: DBXSharingUnshareFolderErrorTeamFolder? {
        self as? DBXSharingUnshareFolderErrorTeamFolder
    }

    @objc
    public var asNoPermission: DBXSharingUnshareFolderErrorNoPermission? {
        self as? DBXSharingUnshareFolderErrorNoPermission
    }

    @objc
    public var asTooManyFiles: DBXSharingUnshareFolderErrorTooManyFiles? {
        self as? DBXSharingUnshareFolderErrorTooManyFiles
    }

    @objc
    public var asOther: DBXSharingUnshareFolderErrorOther? {
        self as? DBXSharingUnshareFolderErrorOther
    }
}

/// An unspecified error.
@objc
public class DBXSharingUnshareFolderErrorAccessError: DBXSharingUnshareFolderError {
    @objc
    public var accessError: DBXSharingSharedFolderAccessError

    @objc
    public init(_ arg: DBXSharingSharedFolderAccessError) {
        self.accessError = arg
        let swift = Sharing.UnshareFolderError.accessError(arg.swift)
        super.init(swift: swift)
    }
}

/// This action cannot be performed on a team shared folder.
@objc
public class DBXSharingUnshareFolderErrorTeamFolder: DBXSharingUnshareFolderError {
    @objc
    public init() {
        let swift = Sharing.UnshareFolderError.teamFolder
        super.init(swift: swift)
    }
}

/// The current user does not have permission to perform this action.
@objc
public class DBXSharingUnshareFolderErrorNoPermission: DBXSharingUnshareFolderError {
    @objc
    public init() {
        let swift = Sharing.UnshareFolderError.noPermission
        super.init(swift: swift)
    }
}

/// This shared folder has too many files to be unshared.
@objc
public class DBXSharingUnshareFolderErrorTooManyFiles: DBXSharingUnshareFolderError {
    @objc
    public init() {
        let swift = Sharing.UnshareFolderError.tooManyFiles
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXSharingUnshareFolderErrorOther: DBXSharingUnshareFolderError {
    @objc
    public init() {
        let swift = Sharing.UnshareFolderError.other
        super.init(swift: swift)
    }
}

/// Arguments for updateFileMember.
@objc
public class DBXSharingUpdateFileMemberArgs: NSObject {
    /// File for which we are changing a member's access.
    @objc
    public var file: String { swift.file }
    /// The member whose access we are changing.
    @objc
    public var member: DBXSharingMemberSelector { DBXSharingMemberSelector(swift: swift.member) }
    /// The new access level for the member.
    @objc
    public var accessLevel: DBXSharingAccessLevel { DBXSharingAccessLevel(swift: swift.accessLevel) }

    @objc
    public init(file: String, member: DBXSharingMemberSelector, accessLevel: DBXSharingAccessLevel) {
        self.swift = Sharing.UpdateFileMemberArgs(file: file, member: member.swift, accessLevel: accessLevel.swift)
    }

    let swift: Sharing.UpdateFileMemberArgs

    public init(swift: Sharing.UpdateFileMemberArgs) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible UpdateFolderMemberArg struct
@objc
public class DBXSharingUpdateFolderMemberArg: NSObject {
    /// The ID for the shared folder.
    @objc
    public var sharedFolderId: String { swift.sharedFolderId }
    /// The member of the shared folder to update.  Only the dropboxId in MemberSelector may be set at this time.
    @objc
    public var member: DBXSharingMemberSelector { DBXSharingMemberSelector(swift: swift.member) }
    /// The new access level for member. owner in AccessLevel is disallowed.
    @objc
    public var accessLevel: DBXSharingAccessLevel { DBXSharingAccessLevel(swift: swift.accessLevel) }

    @objc
    public init(sharedFolderId: String, member: DBXSharingMemberSelector, accessLevel: DBXSharingAccessLevel) {
        self.swift = Sharing.UpdateFolderMemberArg(sharedFolderId: sharedFolderId, member: member.swift, accessLevel: accessLevel.swift)
    }

    let swift: Sharing.UpdateFolderMemberArg

    public init(swift: Sharing.UpdateFolderMemberArg) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible UpdateFolderMemberError union
@objc
public class DBXSharingUpdateFolderMemberError: NSObject {
    let swift: Sharing.UpdateFolderMemberError

    public init(swift: Sharing.UpdateFolderMemberError) {
        self.swift = swift
    }

    public static func factory(swift: Sharing.UpdateFolderMemberError) -> DBXSharingUpdateFolderMemberError {
        switch swift {
        case .accessError(let swiftArg):
            let arg = DBXSharingSharedFolderAccessError(swift: swiftArg)
            return DBXSharingUpdateFolderMemberErrorAccessError(arg)
        case .memberError(let swiftArg):
            let arg = DBXSharingSharedFolderMemberError(swift: swiftArg)
            return DBXSharingUpdateFolderMemberErrorMemberError(arg)
        case .noExplicitAccess(let swiftArg):
            let arg = DBXSharingAddFolderMemberError(swift: swiftArg)
            return DBXSharingUpdateFolderMemberErrorNoExplicitAccess(arg)
        case .insufficientPlan:
            return DBXSharingUpdateFolderMemberErrorInsufficientPlan()
        case .noPermission:
            return DBXSharingUpdateFolderMemberErrorNoPermission()
        case .other:
            return DBXSharingUpdateFolderMemberErrorOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asAccessError: DBXSharingUpdateFolderMemberErrorAccessError? {
        self as? DBXSharingUpdateFolderMemberErrorAccessError
    }

    @objc
    public var asMemberError: DBXSharingUpdateFolderMemberErrorMemberError? {
        self as? DBXSharingUpdateFolderMemberErrorMemberError
    }

    @objc
    public var asNoExplicitAccess: DBXSharingUpdateFolderMemberErrorNoExplicitAccess? {
        self as? DBXSharingUpdateFolderMemberErrorNoExplicitAccess
    }

    @objc
    public var asInsufficientPlan: DBXSharingUpdateFolderMemberErrorInsufficientPlan? {
        self as? DBXSharingUpdateFolderMemberErrorInsufficientPlan
    }

    @objc
    public var asNoPermission: DBXSharingUpdateFolderMemberErrorNoPermission? {
        self as? DBXSharingUpdateFolderMemberErrorNoPermission
    }

    @objc
    public var asOther: DBXSharingUpdateFolderMemberErrorOther? {
        self as? DBXSharingUpdateFolderMemberErrorOther
    }
}

/// An unspecified error.
@objc
public class DBXSharingUpdateFolderMemberErrorAccessError: DBXSharingUpdateFolderMemberError {
    @objc
    public var accessError: DBXSharingSharedFolderAccessError

    @objc
    public init(_ arg: DBXSharingSharedFolderAccessError) {
        self.accessError = arg
        let swift = Sharing.UpdateFolderMemberError.accessError(arg.swift)
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXSharingUpdateFolderMemberErrorMemberError: DBXSharingUpdateFolderMemberError {
    @objc
    public var memberError: DBXSharingSharedFolderMemberError

    @objc
    public init(_ arg: DBXSharingSharedFolderMemberError) {
        self.memberError = arg
        let swift = Sharing.UpdateFolderMemberError.memberError(arg.swift)
        super.init(swift: swift)
    }
}

/// If updating the access type required the member to be added to the shared folder and there was an error when
/// adding the member.
@objc
public class DBXSharingUpdateFolderMemberErrorNoExplicitAccess: DBXSharingUpdateFolderMemberError {
    @objc
    public var noExplicitAccess: DBXSharingAddFolderMemberError

    @objc
    public init(_ arg: DBXSharingAddFolderMemberError) {
        self.noExplicitAccess = arg
        let swift = Sharing.UpdateFolderMemberError.noExplicitAccess(arg.swift)
        super.init(swift: swift)
    }
}

/// The current user's account doesn't support this action. An example of this is when downgrading a member from
/// editor to viewer. This action can only be performed by users that have upgraded to a Pro or Business
/// plan.
@objc
public class DBXSharingUpdateFolderMemberErrorInsufficientPlan: DBXSharingUpdateFolderMemberError {
    @objc
    public init() {
        let swift = Sharing.UpdateFolderMemberError.insufficientPlan
        super.init(swift: swift)
    }
}

/// The current user does not have permission to perform this action.
@objc
public class DBXSharingUpdateFolderMemberErrorNoPermission: DBXSharingUpdateFolderMemberError {
    @objc
    public init() {
        let swift = Sharing.UpdateFolderMemberError.noPermission
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXSharingUpdateFolderMemberErrorOther: DBXSharingUpdateFolderMemberError {
    @objc
    public init() {
        let swift = Sharing.UpdateFolderMemberError.other
        super.init(swift: swift)
    }
}

/// If any of the policies are unset, then they retain their current setting.
@objc
public class DBXSharingUpdateFolderPolicyArg: NSObject {
    /// The ID for the shared folder.
    @objc
    public var sharedFolderId: String { swift.sharedFolderId }
    /// Who can be a member of this shared folder. Only applicable if the current user is on a team.
    @objc
    public var memberPolicy: DBXSharingMemberPolicy? { guard let swift = swift.memberPolicy else { return nil }
        return DBXSharingMemberPolicy(swift: swift)
    }

    /// Who can add and remove members of this shared folder.
    @objc
    public var aclUpdatePolicy: DBXSharingAclUpdatePolicy? { guard let swift = swift.aclUpdatePolicy else { return nil }
        return DBXSharingAclUpdatePolicy(swift: swift)
    }

    /// Who can enable/disable viewer info for this shared folder.
    @objc
    public var viewerInfoPolicy: DBXSharingViewerInfoPolicy? { guard let swift = swift.viewerInfoPolicy else { return nil }
        return DBXSharingViewerInfoPolicy(swift: swift)
    }

    /// The policy to apply to shared links created for content inside this shared folder. The current user must be
    /// on a team to set this policy to members in SharedLinkPolicy.
    @objc
    public var sharedLinkPolicy: DBXSharingSharedLinkPolicy? { guard let swift = swift.sharedLinkPolicy else { return nil }
        return DBXSharingSharedLinkPolicy(swift: swift)
    }

    /// Settings on the link for this folder.
    @objc
    public var linkSettings: DBXSharingLinkSettings? { guard let swift = swift.linkSettings else { return nil }
        return DBXSharingLinkSettings(swift: swift)
    }

    /// A list of `FolderAction`s corresponding to `FolderPermission`s that should appear in the  response's
    /// permissions in SharedFolderMetadata field describing the actions the  authenticated user can perform on
    /// the folder.
    @objc
    public var actions: [DBXSharingFolderAction]? { swift.actions?.map { DBXSharingFolderAction(swift: $0) } }

    @objc
    public init(
        sharedFolderId: String,
        memberPolicy: DBXSharingMemberPolicy?,
        aclUpdatePolicy: DBXSharingAclUpdatePolicy?,
        viewerInfoPolicy: DBXSharingViewerInfoPolicy?,
        sharedLinkPolicy: DBXSharingSharedLinkPolicy?,
        linkSettings: DBXSharingLinkSettings?,
        actions: [DBXSharingFolderAction]?
    ) {
        self.swift = Sharing.UpdateFolderPolicyArg(
            sharedFolderId: sharedFolderId,
            memberPolicy: memberPolicy?.swift,
            aclUpdatePolicy: aclUpdatePolicy?.swift,
            viewerInfoPolicy: viewerInfoPolicy?.swift,
            sharedLinkPolicy: sharedLinkPolicy?.swift,
            linkSettings: linkSettings?.swift,
            actions: actions?.map(\.swift)
        )
    }

    let swift: Sharing.UpdateFolderPolicyArg

    public init(swift: Sharing.UpdateFolderPolicyArg) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible UpdateFolderPolicyError union
@objc
public class DBXSharingUpdateFolderPolicyError: NSObject {
    let swift: Sharing.UpdateFolderPolicyError

    public init(swift: Sharing.UpdateFolderPolicyError) {
        self.swift = swift
    }

    public static func factory(swift: Sharing.UpdateFolderPolicyError) -> DBXSharingUpdateFolderPolicyError {
        switch swift {
        case .accessError(let swiftArg):
            let arg = DBXSharingSharedFolderAccessError(swift: swiftArg)
            return DBXSharingUpdateFolderPolicyErrorAccessError(arg)
        case .notOnTeam:
            return DBXSharingUpdateFolderPolicyErrorNotOnTeam()
        case .teamPolicyDisallowsMemberPolicy:
            return DBXSharingUpdateFolderPolicyErrorTeamPolicyDisallowsMemberPolicy()
        case .disallowedSharedLinkPolicy:
            return DBXSharingUpdateFolderPolicyErrorDisallowedSharedLinkPolicy()
        case .noPermission:
            return DBXSharingUpdateFolderPolicyErrorNoPermission()
        case .teamFolder:
            return DBXSharingUpdateFolderPolicyErrorTeamFolder()
        case .other:
            return DBXSharingUpdateFolderPolicyErrorOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asAccessError: DBXSharingUpdateFolderPolicyErrorAccessError? {
        self as? DBXSharingUpdateFolderPolicyErrorAccessError
    }

    @objc
    public var asNotOnTeam: DBXSharingUpdateFolderPolicyErrorNotOnTeam? {
        self as? DBXSharingUpdateFolderPolicyErrorNotOnTeam
    }

    @objc
    public var asTeamPolicyDisallowsMemberPolicy: DBXSharingUpdateFolderPolicyErrorTeamPolicyDisallowsMemberPolicy? {
        self as? DBXSharingUpdateFolderPolicyErrorTeamPolicyDisallowsMemberPolicy
    }

    @objc
    public var asDisallowedSharedLinkPolicy: DBXSharingUpdateFolderPolicyErrorDisallowedSharedLinkPolicy? {
        self as? DBXSharingUpdateFolderPolicyErrorDisallowedSharedLinkPolicy
    }

    @objc
    public var asNoPermission: DBXSharingUpdateFolderPolicyErrorNoPermission? {
        self as? DBXSharingUpdateFolderPolicyErrorNoPermission
    }

    @objc
    public var asTeamFolder: DBXSharingUpdateFolderPolicyErrorTeamFolder? {
        self as? DBXSharingUpdateFolderPolicyErrorTeamFolder
    }

    @objc
    public var asOther: DBXSharingUpdateFolderPolicyErrorOther? {
        self as? DBXSharingUpdateFolderPolicyErrorOther
    }
}

/// An unspecified error.
@objc
public class DBXSharingUpdateFolderPolicyErrorAccessError: DBXSharingUpdateFolderPolicyError {
    @objc
    public var accessError: DBXSharingSharedFolderAccessError

    @objc
    public init(_ arg: DBXSharingSharedFolderAccessError) {
        self.accessError = arg
        let swift = Sharing.UpdateFolderPolicyError.accessError(arg.swift)
        super.init(swift: swift)
    }
}

/// memberPolicy in UpdateFolderPolicyArg was set even though user is not on a team.
@objc
public class DBXSharingUpdateFolderPolicyErrorNotOnTeam: DBXSharingUpdateFolderPolicyError {
    @objc
    public init() {
        let swift = Sharing.UpdateFolderPolicyError.notOnTeam
        super.init(swift: swift)
    }
}

/// Team policy is more restrictive than memberPolicy in ShareFolderArg.
@objc
public class DBXSharingUpdateFolderPolicyErrorTeamPolicyDisallowsMemberPolicy: DBXSharingUpdateFolderPolicyError {
    @objc
    public init() {
        let swift = Sharing.UpdateFolderPolicyError.teamPolicyDisallowsMemberPolicy
        super.init(swift: swift)
    }
}

/// The current account is not allowed to select the specified sharedLinkPolicy in ShareFolderArg.
@objc
public class DBXSharingUpdateFolderPolicyErrorDisallowedSharedLinkPolicy: DBXSharingUpdateFolderPolicyError {
    @objc
    public init() {
        let swift = Sharing.UpdateFolderPolicyError.disallowedSharedLinkPolicy
        super.init(swift: swift)
    }
}

/// The current user does not have permission to perform this action.
@objc
public class DBXSharingUpdateFolderPolicyErrorNoPermission: DBXSharingUpdateFolderPolicyError {
    @objc
    public init() {
        let swift = Sharing.UpdateFolderPolicyError.noPermission
        super.init(swift: swift)
    }
}

/// This action cannot be performed on a team shared folder.
@objc
public class DBXSharingUpdateFolderPolicyErrorTeamFolder: DBXSharingUpdateFolderPolicyError {
    @objc
    public init() {
        let swift = Sharing.UpdateFolderPolicyError.teamFolder
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXSharingUpdateFolderPolicyErrorOther: DBXSharingUpdateFolderPolicyError {
    @objc
    public init() {
        let swift = Sharing.UpdateFolderPolicyError.other
        super.init(swift: swift)
    }
}

/// The information about a user member of the shared content.
@objc
public class DBXSharingUserMembershipInfo: DBXSharingMembershipInfo {
    /// The account information for the membership user.
    @objc
    public var user: DBXSharingUserInfo { DBXSharingUserInfo(swift: subSwift.user) }

    @objc
    public init(
        accessType: DBXSharingAccessLevel,
        user: DBXSharingUserInfo,
        permissions: [DBXSharingMemberPermission]?,
        initials: String?,
        isInherited: NSNumber
    ) {
        let swift = Sharing.UserMembershipInfo(
            accessType: accessType.swift,
            user: user.swift,
            permissions: permissions?.map(\.swift),
            initials: initials,
            isInherited: isInherited.boolValue
        )
        self.subSwift = swift
        super.init(swift: swift)
    }

    let subSwift: Sharing.UserMembershipInfo

    public init(swift: Sharing.UserMembershipInfo) {
        self.subSwift = swift
        super.init(swift: swift)
    }

    @objc
    public override var description: String { subSwift.description }
}

/// The information about a user member of the shared content with an appended last seen timestamp.
@objc
public class DBXSharingUserFileMembershipInfo: DBXSharingUserMembershipInfo {
    /// The UTC timestamp of when the user has last seen the content. Only populated if the user has seen the
    /// content and the caller has a plan that includes viewer history.
    @objc
    public var timeLastSeen: Date? { subSubSwift.timeLastSeen }
    /// The platform on which the user has last seen the content, or unknown.
    @objc
    public var platformType: DBXSeenStatePlatformType? { guard let swift = subSubSwift.platformType else { return nil }
        return DBXSeenStatePlatformType(swift: swift)
    }

    @objc
    public init(
        accessType: DBXSharingAccessLevel,
        user: DBXSharingUserInfo,
        permissions: [DBXSharingMemberPermission]?,
        initials: String?,
        isInherited: NSNumber,
        timeLastSeen: Date?,
        platformType: DBXSeenStatePlatformType?
    ) {
        let swift = Sharing.UserFileMembershipInfo(
            accessType: accessType.swift,
            user: user.swift,
            permissions: permissions?.map(\.swift),
            initials: initials,
            isInherited: isInherited.boolValue,
            timeLastSeen: timeLastSeen,
            platformType: platformType?.swift
        )
        self.subSubSwift = swift
        super.init(swift: swift)
    }

    let subSubSwift: Sharing.UserFileMembershipInfo

    public init(swift: Sharing.UserFileMembershipInfo) {
        self.subSubSwift = swift
        super.init(swift: swift)
    }

    @objc
    public override var description: String { subSwift.description }
}

/// Basic information about a user. Use usersAccount and usersAccountBatch to obtain more detailed information.
@objc
public class DBXSharingUserInfo: NSObject {
    /// The account ID of the user.
    @objc
    public var accountId: String { swift.accountId }
    /// Email address of user.
    @objc
    public var email: String { swift.email }
    /// The display name of the user.
    @objc
    public var displayName: String { swift.displayName }
    /// If the user is in the same team as current user.
    @objc
    public var sameTeam: NSNumber { swift.sameTeam as NSNumber }
    /// The team member ID of the shared folder member. Only present if sameTeam is true.
    @objc
    public var teamMemberId: String? { swift.teamMemberId }

    @objc
    public init(accountId: String, email: String, displayName: String, sameTeam: NSNumber, teamMemberId: String?) {
        self.swift = Sharing.UserInfo(accountId: accountId, email: email, displayName: displayName, sameTeam: sameTeam.boolValue, teamMemberId: teamMemberId)
    }

    let swift: Sharing.UserInfo

    public init(swift: Sharing.UserInfo) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible ViewerInfoPolicy union
@objc
public class DBXSharingViewerInfoPolicy: NSObject {
    let swift: Sharing.ViewerInfoPolicy

    public init(swift: Sharing.ViewerInfoPolicy) {
        self.swift = swift
    }

    public static func factory(swift: Sharing.ViewerInfoPolicy) -> DBXSharingViewerInfoPolicy {
        switch swift {
        case .enabled:
            return DBXSharingViewerInfoPolicyEnabled()
        case .disabled:
            return DBXSharingViewerInfoPolicyDisabled()
        case .other:
            return DBXSharingViewerInfoPolicyOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asEnabled: DBXSharingViewerInfoPolicyEnabled? {
        self as? DBXSharingViewerInfoPolicyEnabled
    }

    @objc
    public var asDisabled: DBXSharingViewerInfoPolicyDisabled? {
        self as? DBXSharingViewerInfoPolicyDisabled
    }

    @objc
    public var asOther: DBXSharingViewerInfoPolicyOther? {
        self as? DBXSharingViewerInfoPolicyOther
    }
}

/// Viewer information is available on this file.
@objc
public class DBXSharingViewerInfoPolicyEnabled: DBXSharingViewerInfoPolicy {
    @objc
    public init() {
        let swift = Sharing.ViewerInfoPolicy.enabled
        super.init(swift: swift)
    }
}

/// Viewer information is disabled on this file.
@objc
public class DBXSharingViewerInfoPolicyDisabled: DBXSharingViewerInfoPolicy {
    @objc
    public init() {
        let swift = Sharing.ViewerInfoPolicy.disabled
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXSharingViewerInfoPolicyOther: DBXSharingViewerInfoPolicy {
    @objc
    public init() {
        let swift = Sharing.ViewerInfoPolicy.other
        super.init(swift: swift)
    }
}

/// Who can access a shared link. The most open visibility is public_. The default depends on many aspects, such as
/// team and user preferences and shared folder settings.
@objc
public class DBXSharingVisibility: NSObject {
    let swift: Sharing.Visibility

    public init(swift: Sharing.Visibility) {
        self.swift = swift
    }

    public static func factory(swift: Sharing.Visibility) -> DBXSharingVisibility {
        switch swift {
        case .public_:
            return DBXSharingVisibilityPublic_()
        case .teamOnly:
            return DBXSharingVisibilityTeamOnly()
        case .password:
            return DBXSharingVisibilityPassword()
        case .teamAndPassword:
            return DBXSharingVisibilityTeamAndPassword()
        case .sharedFolderOnly:
            return DBXSharingVisibilitySharedFolderOnly()
        case .other:
            return DBXSharingVisibilityOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asPublic_: DBXSharingVisibilityPublic_? {
        self as? DBXSharingVisibilityPublic_
    }

    @objc
    public var asTeamOnly: DBXSharingVisibilityTeamOnly? {
        self as? DBXSharingVisibilityTeamOnly
    }

    @objc
    public var asPassword: DBXSharingVisibilityPassword? {
        self as? DBXSharingVisibilityPassword
    }

    @objc
    public var asTeamAndPassword: DBXSharingVisibilityTeamAndPassword? {
        self as? DBXSharingVisibilityTeamAndPassword
    }

    @objc
    public var asSharedFolderOnly: DBXSharingVisibilitySharedFolderOnly? {
        self as? DBXSharingVisibilitySharedFolderOnly
    }

    @objc
    public var asOther: DBXSharingVisibilityOther? {
        self as? DBXSharingVisibilityOther
    }
}

/// Anyone who has received the link can access it. No login required.
@objc
public class DBXSharingVisibilityPublic_: DBXSharingVisibility {
    @objc
    public init() {
        let swift = Sharing.Visibility.public_
        super.init(swift: swift)
    }
}

/// Only members of the same team can access the link. Login is required.
@objc
public class DBXSharingVisibilityTeamOnly: DBXSharingVisibility {
    @objc
    public init() {
        let swift = Sharing.Visibility.teamOnly
        super.init(swift: swift)
    }
}

/// A link-specific password is required to access the link. Login is not required.
@objc
public class DBXSharingVisibilityPassword: DBXSharingVisibility {
    @objc
    public init() {
        let swift = Sharing.Visibility.password
        super.init(swift: swift)
    }
}

/// Only members of the same team who have the link-specific password can access the link.
@objc
public class DBXSharingVisibilityTeamAndPassword: DBXSharingVisibility {
    @objc
    public init() {
        let swift = Sharing.Visibility.teamAndPassword
        super.init(swift: swift)
    }
}

/// Only members of the shared folder containing the linked file can access the link. Login is required.
@objc
public class DBXSharingVisibilitySharedFolderOnly: DBXSharingVisibility {
    @objc
    public init() {
        let swift = Sharing.Visibility.sharedFolderOnly
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXSharingVisibilityOther: DBXSharingVisibility {
    @objc
    public init() {
        let swift = Sharing.Visibility.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible VisibilityPolicy struct
@objc
public class DBXSharingVisibilityPolicy: NSObject {
    /// This is the value to submit when saving the visibility setting.
    @objc
    public var policy: DBXSharingRequestedVisibility { DBXSharingRequestedVisibility(swift: swift.policy) }
    /// This is what the effective policy would be, if you selected this option. The resolved policy is obtained
    /// after considering external effects such as shared folder settings and team policy. This value is
    /// guaranteed to be provided.
    @objc
    public var resolvedPolicy: DBXSharingAlphaResolvedVisibility { DBXSharingAlphaResolvedVisibility(swift: swift.resolvedPolicy) }
    /// Whether the user is permitted to set the visibility to this policy.
    @objc
    public var allowed: NSNumber { swift.allowed as NSNumber }
    /// If allowed is false, this will provide the reason that the user is not permitted to set the visibility to
    /// this policy.
    @objc
    public var disallowedReason: DBXSharingVisibilityPolicyDisallowedReason? { guard let swift = swift.disallowedReason else { return nil }
        return DBXSharingVisibilityPolicyDisallowedReason(swift: swift)
    }

    @objc
    public init(
        policy: DBXSharingRequestedVisibility,
        resolvedPolicy: DBXSharingAlphaResolvedVisibility,
        allowed: NSNumber,
        disallowedReason: DBXSharingVisibilityPolicyDisallowedReason?
    ) {
        self.swift = Sharing.VisibilityPolicy(
            policy: policy.swift,
            resolvedPolicy: resolvedPolicy.swift,
            allowed: allowed.boolValue,
            disallowedReason: disallowedReason?.swift
        )
    }

    let swift: Sharing.VisibilityPolicy

    public init(swift: Sharing.VisibilityPolicy) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}
