///
/// Copyright (c) 2022 Dropbox, Inc. All rights reserved.
///
/// Auto-generated by Stone, do not modify.
///

import Foundation
import SwiftyDropbox

/// Objective-C compatible datatypes for the team namespace
/// For Swift see team

/// Objective-C compatible DeviceSession struct
@objc
public class DBXTeamDeviceSession: NSObject {
    /// The session id.
    @objc
    public var sessionId: String { swift.sessionId }
    /// The IP address of the last activity from this session.
    @objc
    public var ipAddress: String? { swift.ipAddress }
    /// The country from which the last activity from this session was made.
    @objc
    public var country: String? { swift.country }
    /// The time this session was created.
    @objc
    public var created: Date? { swift.created }
    /// The time of the last activity from this session.
    @objc
    public var updated: Date? { swift.updated }

    @objc
    public init(sessionId: String, ipAddress: String?, country: String?, created: Date?, updated: Date?) {
        self.swift = Team.DeviceSession(sessionId: sessionId, ipAddress: ipAddress, country: country, created: created, updated: updated)
    }

    let swift: Team.DeviceSession

    public init(swift: Team.DeviceSession) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Information on active web sessions.
@objc
public class DBXTeamActiveWebSession: DBXTeamDeviceSession {
    /// Information on the hosting device.
    @objc
    public var userAgent: String { subSwift.userAgent }
    /// Information on the hosting operating system.
    @objc
    public var os: String { subSwift.os }
    /// Information on the browser used for this web session.
    @objc
    public var browser: String { subSwift.browser }
    /// The time this session expires.
    @objc
    public var expires: Date? { subSwift.expires }

    @objc
    public init(
        sessionId: String,
        userAgent: String,
        os: String,
        browser: String,
        ipAddress: String?,
        country: String?,
        created: Date?,
        updated: Date?,
        expires: Date?
    ) {
        let swift = Team.ActiveWebSession(
            sessionId: sessionId,
            userAgent: userAgent,
            os: os,
            browser: browser,
            ipAddress: ipAddress,
            country: country,
            created: created,
            updated: updated,
            expires: expires
        )
        self.subSwift = swift
        super.init(swift: swift)
    }

    let subSwift: Team.ActiveWebSession

    public init(swift: Team.ActiveWebSession) {
        self.subSwift = swift
        super.init(swift: swift)
    }

    @objc
    public override var description: String { subSwift.description }
}

/// Result of trying to add a secondary email to a user. 'success' is the only value indicating that a secondary
/// email was successfully added to a user. The other values explain the type of error that occurred, and include
/// the email for which the error occurred.
@objc
public class DBXTeamAddSecondaryEmailResult: NSObject {
    let swift: Team.AddSecondaryEmailResult

    public init(swift: Team.AddSecondaryEmailResult) {
        self.swift = swift
    }

    public static func factory(swift: Team.AddSecondaryEmailResult) -> DBXTeamAddSecondaryEmailResult {
        switch swift {
        case .success(let swiftArg):
            let arg = DBXSecondaryEmailsSecondaryEmail(swift: swiftArg)
            return DBXTeamAddSecondaryEmailResultSuccess(arg)
        case .unavailable(let swiftArg):
            let arg = swiftArg
            return DBXTeamAddSecondaryEmailResultUnavailable(arg)
        case .alreadyPending(let swiftArg):
            let arg = swiftArg
            return DBXTeamAddSecondaryEmailResultAlreadyPending(arg)
        case .alreadyOwnedByUser(let swiftArg):
            let arg = swiftArg
            return DBXTeamAddSecondaryEmailResultAlreadyOwnedByUser(arg)
        case .reachedLimit(let swiftArg):
            let arg = swiftArg
            return DBXTeamAddSecondaryEmailResultReachedLimit(arg)
        case .transientError(let swiftArg):
            let arg = swiftArg
            return DBXTeamAddSecondaryEmailResultTransientError(arg)
        case .tooManyUpdates(let swiftArg):
            let arg = swiftArg
            return DBXTeamAddSecondaryEmailResultTooManyUpdates(arg)
        case .unknownError(let swiftArg):
            let arg = swiftArg
            return DBXTeamAddSecondaryEmailResultUnknownError(arg)
        case .rateLimited(let swiftArg):
            let arg = swiftArg
            return DBXTeamAddSecondaryEmailResultRateLimited(arg)
        case .other:
            return DBXTeamAddSecondaryEmailResultOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asSuccess: DBXTeamAddSecondaryEmailResultSuccess? {
        self as? DBXTeamAddSecondaryEmailResultSuccess
    }

    @objc
    public var asUnavailable: DBXTeamAddSecondaryEmailResultUnavailable? {
        self as? DBXTeamAddSecondaryEmailResultUnavailable
    }

    @objc
    public var asAlreadyPending: DBXTeamAddSecondaryEmailResultAlreadyPending? {
        self as? DBXTeamAddSecondaryEmailResultAlreadyPending
    }

    @objc
    public var asAlreadyOwnedByUser: DBXTeamAddSecondaryEmailResultAlreadyOwnedByUser? {
        self as? DBXTeamAddSecondaryEmailResultAlreadyOwnedByUser
    }

    @objc
    public var asReachedLimit: DBXTeamAddSecondaryEmailResultReachedLimit? {
        self as? DBXTeamAddSecondaryEmailResultReachedLimit
    }

    @objc
    public var asTransientError: DBXTeamAddSecondaryEmailResultTransientError? {
        self as? DBXTeamAddSecondaryEmailResultTransientError
    }

    @objc
    public var asTooManyUpdates: DBXTeamAddSecondaryEmailResultTooManyUpdates? {
        self as? DBXTeamAddSecondaryEmailResultTooManyUpdates
    }

    @objc
    public var asUnknownError: DBXTeamAddSecondaryEmailResultUnknownError? {
        self as? DBXTeamAddSecondaryEmailResultUnknownError
    }

    @objc
    public var asRateLimited: DBXTeamAddSecondaryEmailResultRateLimited? {
        self as? DBXTeamAddSecondaryEmailResultRateLimited
    }

    @objc
    public var asOther: DBXTeamAddSecondaryEmailResultOther? {
        self as? DBXTeamAddSecondaryEmailResultOther
    }
}

/// Describes a secondary email that was successfully added to a user.
@objc
public class DBXTeamAddSecondaryEmailResultSuccess: DBXTeamAddSecondaryEmailResult {
    @objc
    public var success: DBXSecondaryEmailsSecondaryEmail

    @objc
    public init(_ arg: DBXSecondaryEmailsSecondaryEmail) {
        self.success = arg
        let swift = Team.AddSecondaryEmailResult.success(arg.swift)
        super.init(swift: swift)
    }
}

/// Secondary email is not available to be claimed by the user.
@objc
public class DBXTeamAddSecondaryEmailResultUnavailable: DBXTeamAddSecondaryEmailResult {
    @objc
    public var unavailable: String

    @objc
    public init(_ arg: String) {
        self.unavailable = arg
        let swift = Team.AddSecondaryEmailResult.unavailable(arg)
        super.init(swift: swift)
    }
}

/// Secondary email is already a pending email for the user.
@objc
public class DBXTeamAddSecondaryEmailResultAlreadyPending: DBXTeamAddSecondaryEmailResult {
    @objc
    public var alreadyPending: String

    @objc
    public init(_ arg: String) {
        self.alreadyPending = arg
        let swift = Team.AddSecondaryEmailResult.alreadyPending(arg)
        super.init(swift: swift)
    }
}

/// Secondary email is already a verified email for the user.
@objc
public class DBXTeamAddSecondaryEmailResultAlreadyOwnedByUser: DBXTeamAddSecondaryEmailResult {
    @objc
    public var alreadyOwnedByUser: String

    @objc
    public init(_ arg: String) {
        self.alreadyOwnedByUser = arg
        let swift = Team.AddSecondaryEmailResult.alreadyOwnedByUser(arg)
        super.init(swift: swift)
    }
}

/// User already has the maximum number of secondary emails allowed.
@objc
public class DBXTeamAddSecondaryEmailResultReachedLimit: DBXTeamAddSecondaryEmailResult {
    @objc
    public var reachedLimit: String

    @objc
    public init(_ arg: String) {
        self.reachedLimit = arg
        let swift = Team.AddSecondaryEmailResult.reachedLimit(arg)
        super.init(swift: swift)
    }
}

/// A transient error occurred. Please try again later.
@objc
public class DBXTeamAddSecondaryEmailResultTransientError: DBXTeamAddSecondaryEmailResult {
    @objc
    public var transientError: String

    @objc
    public init(_ arg: String) {
        self.transientError = arg
        let swift = Team.AddSecondaryEmailResult.transientError(arg)
        super.init(swift: swift)
    }
}

/// An error occurred due to conflicting updates. Please try again later.
@objc
public class DBXTeamAddSecondaryEmailResultTooManyUpdates: DBXTeamAddSecondaryEmailResult {
    @objc
    public var tooManyUpdates: String

    @objc
    public init(_ arg: String) {
        self.tooManyUpdates = arg
        let swift = Team.AddSecondaryEmailResult.tooManyUpdates(arg)
        super.init(swift: swift)
    }
}

/// An unknown error occurred.
@objc
public class DBXTeamAddSecondaryEmailResultUnknownError: DBXTeamAddSecondaryEmailResult {
    @objc
    public var unknownError: String

    @objc
    public init(_ arg: String) {
        self.unknownError = arg
        let swift = Team.AddSecondaryEmailResult.unknownError(arg)
        super.init(swift: swift)
    }
}

/// Too many emails are being sent to this email address. Please try again later.
@objc
public class DBXTeamAddSecondaryEmailResultRateLimited: DBXTeamAddSecondaryEmailResult {
    @objc
    public var rateLimited: String

    @objc
    public init(_ arg: String) {
        self.rateLimited = arg
        let swift = Team.AddSecondaryEmailResult.rateLimited(arg)
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXTeamAddSecondaryEmailResultOther: DBXTeamAddSecondaryEmailResult {
    @objc
    public init() {
        let swift = Team.AddSecondaryEmailResult.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible AddSecondaryEmailsArg struct
@objc
public class DBXTeamAddSecondaryEmailsArg: NSObject {
    /// List of users and secondary emails to add.
    @objc
    public var newSecondaryEmails: [DBXTeamUserSecondaryEmailsArg] { swift.newSecondaryEmails.map { DBXTeamUserSecondaryEmailsArg(swift: $0) } }

    @objc
    public init(newSecondaryEmails: [DBXTeamUserSecondaryEmailsArg]) {
        self.swift = Team.AddSecondaryEmailsArg(newSecondaryEmails: newSecondaryEmails.map(\.swift))
    }

    let swift: Team.AddSecondaryEmailsArg

    public init(swift: Team.AddSecondaryEmailsArg) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Error returned when adding secondary emails fails.
@objc
public class DBXTeamAddSecondaryEmailsError: NSObject {
    let swift: Team.AddSecondaryEmailsError

    public init(swift: Team.AddSecondaryEmailsError) {
        self.swift = swift
    }

    public static func factory(swift: Team.AddSecondaryEmailsError) -> DBXTeamAddSecondaryEmailsError {
        switch swift {
        case .secondaryEmailsDisabled:
            return DBXTeamAddSecondaryEmailsErrorSecondaryEmailsDisabled()
        case .tooManyEmails:
            return DBXTeamAddSecondaryEmailsErrorTooManyEmails()
        case .other:
            return DBXTeamAddSecondaryEmailsErrorOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asSecondaryEmailsDisabled: DBXTeamAddSecondaryEmailsErrorSecondaryEmailsDisabled? {
        self as? DBXTeamAddSecondaryEmailsErrorSecondaryEmailsDisabled
    }

    @objc
    public var asTooManyEmails: DBXTeamAddSecondaryEmailsErrorTooManyEmails? {
        self as? DBXTeamAddSecondaryEmailsErrorTooManyEmails
    }

    @objc
    public var asOther: DBXTeamAddSecondaryEmailsErrorOther? {
        self as? DBXTeamAddSecondaryEmailsErrorOther
    }
}

/// Secondary emails are disabled for the team.
@objc
public class DBXTeamAddSecondaryEmailsErrorSecondaryEmailsDisabled: DBXTeamAddSecondaryEmailsError {
    @objc
    public init() {
        let swift = Team.AddSecondaryEmailsError.secondaryEmailsDisabled
        super.init(swift: swift)
    }
}

/// A maximum of 20 secondary emails can be added in a single call.
@objc
public class DBXTeamAddSecondaryEmailsErrorTooManyEmails: DBXTeamAddSecondaryEmailsError {
    @objc
    public init() {
        let swift = Team.AddSecondaryEmailsError.tooManyEmails
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXTeamAddSecondaryEmailsErrorOther: DBXTeamAddSecondaryEmailsError {
    @objc
    public init() {
        let swift = Team.AddSecondaryEmailsError.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible AddSecondaryEmailsResult struct
@objc
public class DBXTeamAddSecondaryEmailsResult: NSObject {
    /// List of users and secondary email results.
    @objc
    public var results: [DBXTeamUserAddResult] { swift.results.map { DBXTeamUserAddResult(swift: $0) } }

    @objc
    public init(results: [DBXTeamUserAddResult]) {
        self.swift = Team.AddSecondaryEmailsResult(results: results.map(\.swift))
    }

    let swift: Team.AddSecondaryEmailsResult

    public init(swift: Team.AddSecondaryEmailsResult) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Describes which team-related admin permissions a user has.
@objc
public class DBXTeamAdminTier: NSObject {
    let swift: Team.AdminTier

    public init(swift: Team.AdminTier) {
        self.swift = swift
    }

    public static func factory(swift: Team.AdminTier) -> DBXTeamAdminTier {
        switch swift {
        case .teamAdmin:
            return DBXTeamAdminTierTeamAdmin()
        case .userManagementAdmin:
            return DBXTeamAdminTierUserManagementAdmin()
        case .supportAdmin:
            return DBXTeamAdminTierSupportAdmin()
        case .memberOnly:
            return DBXTeamAdminTierMemberOnly()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asTeamAdmin: DBXTeamAdminTierTeamAdmin? {
        self as? DBXTeamAdminTierTeamAdmin
    }

    @objc
    public var asUserManagementAdmin: DBXTeamAdminTierUserManagementAdmin? {
        self as? DBXTeamAdminTierUserManagementAdmin
    }

    @objc
    public var asSupportAdmin: DBXTeamAdminTierSupportAdmin? {
        self as? DBXTeamAdminTierSupportAdmin
    }

    @objc
    public var asMemberOnly: DBXTeamAdminTierMemberOnly? {
        self as? DBXTeamAdminTierMemberOnly
    }
}

/// User is an administrator of the team - has all permissions.
@objc
public class DBXTeamAdminTierTeamAdmin: DBXTeamAdminTier {
    @objc
    public init() {
        let swift = Team.AdminTier.teamAdmin
        super.init(swift: swift)
    }
}

/// User can do most user provisioning, de-provisioning and management.
@objc
public class DBXTeamAdminTierUserManagementAdmin: DBXTeamAdminTier {
    @objc
    public init() {
        let swift = Team.AdminTier.userManagementAdmin
        super.init(swift: swift)
    }
}

/// User can do a limited set of common support tasks for existing users. Note: Dropbox is adding new types of
/// admin roles; these may display as support_admin.
@objc
public class DBXTeamAdminTierSupportAdmin: DBXTeamAdminTier {
    @objc
    public init() {
        let swift = Team.AdminTier.supportAdmin
        super.init(swift: swift)
    }
}

/// User is not an admin of the team.
@objc
public class DBXTeamAdminTierMemberOnly: DBXTeamAdminTier {
    @objc
    public init() {
        let swift = Team.AdminTier.memberOnly
        super.init(swift: swift)
    }
}

/// Information on linked third party applications.
@objc
public class DBXTeamApiApp: NSObject {
    /// The application unique id.
    @objc
    public var appId: String { swift.appId }
    /// The application name.
    @objc
    public var appName: String { swift.appName }
    /// The application publisher name.
    @objc
    public var publisher: String? { swift.publisher }
    /// The publisher's URL.
    @objc
    public var publisherUrl: String? { swift.publisherUrl }
    /// The time this application was linked.
    @objc
    public var linked: Date? { swift.linked }
    /// Whether the linked application uses a dedicated folder.
    @objc
    public var isAppFolder: NSNumber { swift.isAppFolder as NSNumber }

    @objc
    public init(appId: String, appName: String, isAppFolder: NSNumber, publisher: String?, publisherUrl: String?, linked: Date?) {
        self.swift = Team.ApiApp(
            appId: appId,
            appName: appName,
            isAppFolder: isAppFolder.boolValue,
            publisher: publisher,
            publisherUrl: publisherUrl,
            linked: linked
        )
    }

    let swift: Team.ApiApp

    public init(swift: Team.ApiApp) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Base report structure.
@objc
public class DBXTeamBaseDfbReport: NSObject {
    /// First date present in the results as 'YYYY-MM-DD' or None.
    @objc
    public var startDate: String { swift.startDate }

    @objc
    public init(startDate: String) {
        self.swift = Team.BaseDfbReport(startDate: startDate)
    }

    let swift: Team.BaseDfbReport

    public init(swift: Team.BaseDfbReport) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Base error that all errors for existing team folders should extend.
@objc
public class DBXTeamBaseTeamFolderError: NSObject {
    let swift: Team.BaseTeamFolderError

    public init(swift: Team.BaseTeamFolderError) {
        self.swift = swift
    }

    public static func factory(swift: Team.BaseTeamFolderError) -> DBXTeamBaseTeamFolderError {
        switch swift {
        case .accessError(let swiftArg):
            let arg = DBXTeamTeamFolderAccessError(swift: swiftArg)
            return DBXTeamBaseTeamFolderErrorAccessError(arg)
        case .statusError(let swiftArg):
            let arg = DBXTeamTeamFolderInvalidStatusError(swift: swiftArg)
            return DBXTeamBaseTeamFolderErrorStatusError(arg)
        case .teamSharedDropboxError(let swiftArg):
            let arg = DBXTeamTeamFolderTeamSharedDropboxError(swift: swiftArg)
            return DBXTeamBaseTeamFolderErrorTeamSharedDropboxError(arg)
        case .other:
            return DBXTeamBaseTeamFolderErrorOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asAccessError: DBXTeamBaseTeamFolderErrorAccessError? {
        self as? DBXTeamBaseTeamFolderErrorAccessError
    }

    @objc
    public var asStatusError: DBXTeamBaseTeamFolderErrorStatusError? {
        self as? DBXTeamBaseTeamFolderErrorStatusError
    }

    @objc
    public var asTeamSharedDropboxError: DBXTeamBaseTeamFolderErrorTeamSharedDropboxError? {
        self as? DBXTeamBaseTeamFolderErrorTeamSharedDropboxError
    }

    @objc
    public var asOther: DBXTeamBaseTeamFolderErrorOther? {
        self as? DBXTeamBaseTeamFolderErrorOther
    }
}

/// An unspecified error.
@objc
public class DBXTeamBaseTeamFolderErrorAccessError: DBXTeamBaseTeamFolderError {
    @objc
    public var accessError: DBXTeamTeamFolderAccessError

    @objc
    public init(_ arg: DBXTeamTeamFolderAccessError) {
        self.accessError = arg
        let swift = Team.BaseTeamFolderError.accessError(arg.swift)
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXTeamBaseTeamFolderErrorStatusError: DBXTeamBaseTeamFolderError {
    @objc
    public var statusError: DBXTeamTeamFolderInvalidStatusError

    @objc
    public init(_ arg: DBXTeamTeamFolderInvalidStatusError) {
        self.statusError = arg
        let swift = Team.BaseTeamFolderError.statusError(arg.swift)
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXTeamBaseTeamFolderErrorTeamSharedDropboxError: DBXTeamBaseTeamFolderError {
    @objc
    public var teamSharedDropboxError: DBXTeamTeamFolderTeamSharedDropboxError

    @objc
    public init(_ arg: DBXTeamTeamFolderTeamSharedDropboxError) {
        self.teamSharedDropboxError = arg
        let swift = Team.BaseTeamFolderError.teamSharedDropboxError(arg.swift)
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXTeamBaseTeamFolderErrorOther: DBXTeamBaseTeamFolderError {
    @objc
    public init() {
        let swift = Team.BaseTeamFolderError.other
        super.init(swift: swift)
    }
}

/// Error returned when getting member custom quota.
@objc
public class DBXTeamCustomQuotaError: NSObject {
    let swift: Team.CustomQuotaError

    public init(swift: Team.CustomQuotaError) {
        self.swift = swift
    }

    public static func factory(swift: Team.CustomQuotaError) -> DBXTeamCustomQuotaError {
        switch swift {
        case .tooManyUsers:
            return DBXTeamCustomQuotaErrorTooManyUsers()
        case .other:
            return DBXTeamCustomQuotaErrorOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asTooManyUsers: DBXTeamCustomQuotaErrorTooManyUsers? {
        self as? DBXTeamCustomQuotaErrorTooManyUsers
    }

    @objc
    public var asOther: DBXTeamCustomQuotaErrorOther? {
        self as? DBXTeamCustomQuotaErrorOther
    }
}

/// A maximum of 1000 users can be set for a single call.
@objc
public class DBXTeamCustomQuotaErrorTooManyUsers: DBXTeamCustomQuotaError {
    @objc
    public init() {
        let swift = Team.CustomQuotaError.tooManyUsers
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXTeamCustomQuotaErrorOther: DBXTeamCustomQuotaError {
    @objc
    public init() {
        let swift = Team.CustomQuotaError.other
        super.init(swift: swift)
    }
}

/// User custom quota.
@objc
public class DBXTeamCustomQuotaResult: NSObject {
    let swift: Team.CustomQuotaResult

    public init(swift: Team.CustomQuotaResult) {
        self.swift = swift
    }

    public static func factory(swift: Team.CustomQuotaResult) -> DBXTeamCustomQuotaResult {
        switch swift {
        case .success(let swiftArg):
            let arg = DBXTeamUserCustomQuotaResult(swift: swiftArg)
            return DBXTeamCustomQuotaResultSuccess(arg)
        case .invalidUser(let swiftArg):
            let arg = DBXTeamUserSelectorArg(swift: swiftArg)
            return DBXTeamCustomQuotaResultInvalidUser(arg)
        case .other:
            return DBXTeamCustomQuotaResultOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asSuccess: DBXTeamCustomQuotaResultSuccess? {
        self as? DBXTeamCustomQuotaResultSuccess
    }

    @objc
    public var asInvalidUser: DBXTeamCustomQuotaResultInvalidUser? {
        self as? DBXTeamCustomQuotaResultInvalidUser
    }

    @objc
    public var asOther: DBXTeamCustomQuotaResultOther? {
        self as? DBXTeamCustomQuotaResultOther
    }
}

/// User's custom quota.
@objc
public class DBXTeamCustomQuotaResultSuccess: DBXTeamCustomQuotaResult {
    @objc
    public var success: DBXTeamUserCustomQuotaResult

    @objc
    public init(_ arg: DBXTeamUserCustomQuotaResult) {
        self.success = arg
        let swift = Team.CustomQuotaResult.success(arg.swift)
        super.init(swift: swift)
    }
}

/// Invalid user (not in team).
@objc
public class DBXTeamCustomQuotaResultInvalidUser: DBXTeamCustomQuotaResult {
    @objc
    public var invalidUser: DBXTeamUserSelectorArg

    @objc
    public init(_ arg: DBXTeamUserSelectorArg) {
        self.invalidUser = arg
        let swift = Team.CustomQuotaResult.invalidUser(arg.swift)
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXTeamCustomQuotaResultOther: DBXTeamCustomQuotaResult {
    @objc
    public init() {
        let swift = Team.CustomQuotaResult.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible CustomQuotaUsersArg struct
@objc
public class DBXTeamCustomQuotaUsersArg: NSObject {
    /// List of users.
    @objc
    public var users: [DBXTeamUserSelectorArg] { swift.users.map { DBXTeamUserSelectorArg(swift: $0) } }

    @objc
    public init(users: [DBXTeamUserSelectorArg]) {
        self.swift = Team.CustomQuotaUsersArg(users: users.map(\.swift))
    }

    let swift: Team.CustomQuotaUsersArg

    public init(swift: Team.CustomQuotaUsersArg) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Input arguments that can be provided for most reports.
@objc
public class DBXTeamDateRange: NSObject {
    /// Optional starting date (inclusive). If start_date is None or too long ago, this field will  be set to 6
    /// months ago.
    @objc
    public var startDate: Date? { swift.startDate }
    /// Optional ending date (exclusive).
    @objc
    public var endDate: Date? { swift.endDate }

    @objc
    public init(startDate: Date?, endDate: Date?) {
        self.swift = Team.DateRange(startDate: startDate, endDate: endDate)
    }

    let swift: Team.DateRange

    public init(swift: Team.DateRange) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Errors that can originate from problems in input arguments to reports.
@objc
public class DBXTeamDateRangeError: NSObject {
    let swift: Team.DateRangeError

    public init(swift: Team.DateRangeError) {
        self.swift = swift
    }

    public static func factory(swift: Team.DateRangeError) -> DBXTeamDateRangeError {
        switch swift {
        case .other:
            return DBXTeamDateRangeErrorOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asOther: DBXTeamDateRangeErrorOther? {
        self as? DBXTeamDateRangeErrorOther
    }
}

/// An unspecified error.
@objc
public class DBXTeamDateRangeErrorOther: DBXTeamDateRangeError {
    @objc
    public init() {
        let swift = Team.DateRangeError.other
        super.init(swift: swift)
    }
}

/// Result of trying to delete a secondary email address. 'success' is the only value indicating that a secondary
/// email was successfully deleted. The other values explain the type of error that occurred, and include the email
/// for which the error occurred.
@objc
public class DBXTeamDeleteSecondaryEmailResult: NSObject {
    let swift: Team.DeleteSecondaryEmailResult

    public init(swift: Team.DeleteSecondaryEmailResult) {
        self.swift = swift
    }

    public static func factory(swift: Team.DeleteSecondaryEmailResult) -> DBXTeamDeleteSecondaryEmailResult {
        switch swift {
        case .success(let swiftArg):
            let arg = swiftArg
            return DBXTeamDeleteSecondaryEmailResultSuccess(arg)
        case .notFound(let swiftArg):
            let arg = swiftArg
            return DBXTeamDeleteSecondaryEmailResultNotFound(arg)
        case .cannotRemovePrimary(let swiftArg):
            let arg = swiftArg
            return DBXTeamDeleteSecondaryEmailResultCannotRemovePrimary(arg)
        case .other:
            return DBXTeamDeleteSecondaryEmailResultOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asSuccess: DBXTeamDeleteSecondaryEmailResultSuccess? {
        self as? DBXTeamDeleteSecondaryEmailResultSuccess
    }

    @objc
    public var asNotFound: DBXTeamDeleteSecondaryEmailResultNotFound? {
        self as? DBXTeamDeleteSecondaryEmailResultNotFound
    }

    @objc
    public var asCannotRemovePrimary: DBXTeamDeleteSecondaryEmailResultCannotRemovePrimary? {
        self as? DBXTeamDeleteSecondaryEmailResultCannotRemovePrimary
    }

    @objc
    public var asOther: DBXTeamDeleteSecondaryEmailResultOther? {
        self as? DBXTeamDeleteSecondaryEmailResultOther
    }
}

/// The secondary email was successfully deleted.
@objc
public class DBXTeamDeleteSecondaryEmailResultSuccess: DBXTeamDeleteSecondaryEmailResult {
    @objc
    public var success: String

    @objc
    public init(_ arg: String) {
        self.success = arg
        let swift = Team.DeleteSecondaryEmailResult.success(arg)
        super.init(swift: swift)
    }
}

/// The email address was not found for the user.
@objc
public class DBXTeamDeleteSecondaryEmailResultNotFound: DBXTeamDeleteSecondaryEmailResult {
    @objc
    public var notFound: String

    @objc
    public init(_ arg: String) {
        self.notFound = arg
        let swift = Team.DeleteSecondaryEmailResult.notFound(arg)
        super.init(swift: swift)
    }
}

/// The email address is the primary email address of the user, and cannot be removed.
@objc
public class DBXTeamDeleteSecondaryEmailResultCannotRemovePrimary: DBXTeamDeleteSecondaryEmailResult {
    @objc
    public var cannotRemovePrimary: String

    @objc
    public init(_ arg: String) {
        self.cannotRemovePrimary = arg
        let swift = Team.DeleteSecondaryEmailResult.cannotRemovePrimary(arg)
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXTeamDeleteSecondaryEmailResultOther: DBXTeamDeleteSecondaryEmailResult {
    @objc
    public init() {
        let swift = Team.DeleteSecondaryEmailResult.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible DeleteSecondaryEmailsArg struct
@objc
public class DBXTeamDeleteSecondaryEmailsArg: NSObject {
    /// List of users and their secondary emails to delete.
    @objc
    public var emailsToDelete: [DBXTeamUserSecondaryEmailsArg] { swift.emailsToDelete.map { DBXTeamUserSecondaryEmailsArg(swift: $0) } }

    @objc
    public init(emailsToDelete: [DBXTeamUserSecondaryEmailsArg]) {
        self.swift = Team.DeleteSecondaryEmailsArg(emailsToDelete: emailsToDelete.map(\.swift))
    }

    let swift: Team.DeleteSecondaryEmailsArg

    public init(swift: Team.DeleteSecondaryEmailsArg) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible DeleteSecondaryEmailsResult struct
@objc
public class DBXTeamDeleteSecondaryEmailsResult: NSObject {
    /// (no description)
    @objc
    public var results: [DBXTeamUserDeleteResult] { swift.results.map { DBXTeamUserDeleteResult(swift: $0) } }

    @objc
    public init(results: [DBXTeamUserDeleteResult]) {
        self.swift = Team.DeleteSecondaryEmailsResult(results: results.map(\.swift))
    }

    let swift: Team.DeleteSecondaryEmailsResult

    public init(swift: Team.DeleteSecondaryEmailsResult) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Information about linked Dropbox desktop client sessions.
@objc
public class DBXTeamDesktopClientSession: DBXTeamDeviceSession {
    /// Name of the hosting desktop.
    @objc
    public var hostName: String { subSwift.hostName }
    /// The Dropbox desktop client type.
    @objc
    public var clientType: DBXTeamDesktopPlatform { DBXTeamDesktopPlatform(swift: subSwift.clientType) }
    /// The Dropbox client version.
    @objc
    public var clientVersion: String { subSwift.clientVersion }
    /// Information on the hosting platform.
    @objc
    public var platform: String { subSwift.platform }
    /// Whether it's possible to delete all of the account files upon unlinking.
    @objc
    public var isDeleteOnUnlinkSupported: NSNumber { subSwift.isDeleteOnUnlinkSupported as NSNumber }

    @objc
    public init(
        sessionId: String,
        hostName: String,
        clientType: DBXTeamDesktopPlatform,
        clientVersion: String,
        platform: String,
        isDeleteOnUnlinkSupported: NSNumber,
        ipAddress: String?,
        country: String?,
        created: Date?,
        updated: Date?
    ) {
        let swift = Team.DesktopClientSession(
            sessionId: sessionId,
            hostName: hostName,
            clientType: clientType.swift,
            clientVersion: clientVersion,
            platform: platform,
            isDeleteOnUnlinkSupported: isDeleteOnUnlinkSupported.boolValue,
            ipAddress: ipAddress,
            country: country,
            created: created,
            updated: updated
        )
        self.subSwift = swift
        super.init(swift: swift)
    }

    let subSwift: Team.DesktopClientSession

    public init(swift: Team.DesktopClientSession) {
        self.subSwift = swift
        super.init(swift: swift)
    }

    @objc
    public override var description: String { subSwift.description }
}

/// Objective-C compatible DesktopPlatform union
@objc
public class DBXTeamDesktopPlatform: NSObject {
    let swift: Team.DesktopPlatform

    public init(swift: Team.DesktopPlatform) {
        self.swift = swift
    }

    public static func factory(swift: Team.DesktopPlatform) -> DBXTeamDesktopPlatform {
        switch swift {
        case .windows:
            return DBXTeamDesktopPlatformWindows()
        case .mac:
            return DBXTeamDesktopPlatformMac()
        case .linux:
            return DBXTeamDesktopPlatformLinux()
        case .other:
            return DBXTeamDesktopPlatformOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asWindows: DBXTeamDesktopPlatformWindows? {
        self as? DBXTeamDesktopPlatformWindows
    }

    @objc
    public var asMac: DBXTeamDesktopPlatformMac? {
        self as? DBXTeamDesktopPlatformMac
    }

    @objc
    public var asLinux: DBXTeamDesktopPlatformLinux? {
        self as? DBXTeamDesktopPlatformLinux
    }

    @objc
    public var asOther: DBXTeamDesktopPlatformOther? {
        self as? DBXTeamDesktopPlatformOther
    }
}

/// Official Windows Dropbox desktop client.
@objc
public class DBXTeamDesktopPlatformWindows: DBXTeamDesktopPlatform {
    @objc
    public init() {
        let swift = Team.DesktopPlatform.windows
        super.init(swift: swift)
    }
}

/// Official Mac Dropbox desktop client.
@objc
public class DBXTeamDesktopPlatformMac: DBXTeamDesktopPlatform {
    @objc
    public init() {
        let swift = Team.DesktopPlatform.mac
        super.init(swift: swift)
    }
}

/// Official Linux Dropbox desktop client.
@objc
public class DBXTeamDesktopPlatformLinux: DBXTeamDesktopPlatform {
    @objc
    public init() {
        let swift = Team.DesktopPlatform.linux
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXTeamDesktopPlatformOther: DBXTeamDesktopPlatform {
    @objc
    public init() {
        let swift = Team.DesktopPlatform.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible DeviceSessionArg struct
@objc
public class DBXTeamDeviceSessionArg: NSObject {
    /// The session id.
    @objc
    public var sessionId: String { swift.sessionId }
    /// The unique id of the member owning the device.
    @objc
    public var teamMemberId: String { swift.teamMemberId }

    @objc
    public init(sessionId: String, teamMemberId: String) {
        self.swift = Team.DeviceSessionArg(sessionId: sessionId, teamMemberId: teamMemberId)
    }

    let swift: Team.DeviceSessionArg

    public init(swift: Team.DeviceSessionArg) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Each of the items is an array of values, one value per day. The value is the number of devices active within a
/// time window, ending with that day. If there is no data for a day, then the value will be None.
@objc
public class DBXTeamDevicesActive: NSObject {
    /// Array of number of linked windows (desktop) clients with activity.
    @objc
    public var windows: [NSNumber] { swift.windows.compactMap { $0 as NSNumber? } }
    /// Array of number of linked mac (desktop) clients with activity.
    @objc
    public var macos: [NSNumber] { swift.macos.compactMap { $0 as NSNumber? } }
    /// Array of number of linked linus (desktop) clients with activity.
    @objc
    public var linux: [NSNumber] { swift.linux.compactMap { $0 as NSNumber? } }
    /// Array of number of linked ios devices with activity.
    @objc
    public var ios: [NSNumber] { swift.ios.compactMap { $0 as NSNumber? } }
    /// Array of number of linked android devices with activity.
    @objc
    public var android: [NSNumber] { swift.android.compactMap { $0 as NSNumber? } }
    /// Array of number of other linked devices (blackberry, windows phone, etc)  with activity.
    @objc
    public var other: [NSNumber] { swift.other.compactMap { $0 as NSNumber? } }
    /// Array of total number of linked clients with activity.
    @objc
    public var total: [NSNumber] { swift.total.compactMap { $0 as NSNumber? } }

    @objc
    public init(windows: [NSNumber], macos: [NSNumber], linux: [NSNumber], ios: [NSNumber], android: [NSNumber], other: [NSNumber], total: [NSNumber]) {
        self.swift = Team.DevicesActive(
            windows: windows.map(\.uint64Value),
            macos: macos.map(\.uint64Value),
            linux: linux.map(\.uint64Value),
            ios: ios.map(\.uint64Value),
            android: android.map(\.uint64Value),
            other: other.map(\.uint64Value),
            total: total.map(\.uint64Value)
        )
    }

    let swift: Team.DevicesActive

    public init(swift: Team.DevicesActive) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Excluded users list argument.
@objc
public class DBXTeamExcludedUsersListArg: NSObject {
    /// Number of results to return per call.
    @objc
    public var limit: NSNumber { swift.limit as NSNumber }

    @objc
    public init(limit: NSNumber) {
        self.swift = Team.ExcludedUsersListArg(limit: limit.uint32Value)
    }

    let swift: Team.ExcludedUsersListArg

    public init(swift: Team.ExcludedUsersListArg) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Excluded users list continue argument.
@objc
public class DBXTeamExcludedUsersListContinueArg: NSObject {
    /// Indicates from what point to get the next set of users.
    @objc
    public var cursor: String { swift.cursor }

    @objc
    public init(cursor: String) {
        self.swift = Team.ExcludedUsersListContinueArg(cursor: cursor)
    }

    let swift: Team.ExcludedUsersListContinueArg

    public init(swift: Team.ExcludedUsersListContinueArg) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Excluded users list continue error.
@objc
public class DBXTeamExcludedUsersListContinueError: NSObject {
    let swift: Team.ExcludedUsersListContinueError

    public init(swift: Team.ExcludedUsersListContinueError) {
        self.swift = swift
    }

    public static func factory(swift: Team.ExcludedUsersListContinueError) -> DBXTeamExcludedUsersListContinueError {
        switch swift {
        case .invalidCursor:
            return DBXTeamExcludedUsersListContinueErrorInvalidCursor()
        case .other:
            return DBXTeamExcludedUsersListContinueErrorOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asInvalidCursor: DBXTeamExcludedUsersListContinueErrorInvalidCursor? {
        self as? DBXTeamExcludedUsersListContinueErrorInvalidCursor
    }

    @objc
    public var asOther: DBXTeamExcludedUsersListContinueErrorOther? {
        self as? DBXTeamExcludedUsersListContinueErrorOther
    }
}

/// The cursor is invalid.
@objc
public class DBXTeamExcludedUsersListContinueErrorInvalidCursor: DBXTeamExcludedUsersListContinueError {
    @objc
    public init() {
        let swift = Team.ExcludedUsersListContinueError.invalidCursor
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXTeamExcludedUsersListContinueErrorOther: DBXTeamExcludedUsersListContinueError {
    @objc
    public init() {
        let swift = Team.ExcludedUsersListContinueError.other
        super.init(swift: swift)
    }
}

/// Excluded users list error.
@objc
public class DBXTeamExcludedUsersListError: NSObject {
    let swift: Team.ExcludedUsersListError

    public init(swift: Team.ExcludedUsersListError) {
        self.swift = swift
    }

    public static func factory(swift: Team.ExcludedUsersListError) -> DBXTeamExcludedUsersListError {
        switch swift {
        case .listError:
            return DBXTeamExcludedUsersListErrorListError()
        case .other:
            return DBXTeamExcludedUsersListErrorOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asListError: DBXTeamExcludedUsersListErrorListError? {
        self as? DBXTeamExcludedUsersListErrorListError
    }

    @objc
    public var asOther: DBXTeamExcludedUsersListErrorOther? {
        self as? DBXTeamExcludedUsersListErrorOther
    }
}

/// An error occurred.
@objc
public class DBXTeamExcludedUsersListErrorListError: DBXTeamExcludedUsersListError {
    @objc
    public init() {
        let swift = Team.ExcludedUsersListError.listError
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXTeamExcludedUsersListErrorOther: DBXTeamExcludedUsersListError {
    @objc
    public init() {
        let swift = Team.ExcludedUsersListError.other
        super.init(swift: swift)
    }
}

/// Excluded users list result.
@objc
public class DBXTeamExcludedUsersListResult: NSObject {
    /// (no description)
    @objc
    public var users: [DBXTeamMemberProfile] { swift.users.map { DBXTeamMemberProfile(swift: $0) } }
    /// Pass the cursor into memberSpaceLimitsExcludedUsersListContinue to obtain additional excluded users.
    @objc
    public var cursor: String? { swift.cursor }
    /// Is true if there are additional excluded users that have not been returned yet. An additional call to
    /// memberSpaceLimitsExcludedUsersListContinue can retrieve them.
    @objc
    public var hasMore: NSNumber { swift.hasMore as NSNumber }

    @objc
    public init(users: [DBXTeamMemberProfile], hasMore: NSNumber, cursor: String?) {
        self.swift = Team.ExcludedUsersListResult(users: users.map(\.swift), hasMore: hasMore.boolValue, cursor: cursor)
    }

    let swift: Team.ExcludedUsersListResult

    public init(swift: Team.ExcludedUsersListResult) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Argument of excluded users update operation. Should include a list of users to add/remove (according to
/// endpoint), Maximum size of the list is 1000 users.
@objc
public class DBXTeamExcludedUsersUpdateArg: NSObject {
    /// List of users to be added/removed.
    @objc
    public var users: [DBXTeamUserSelectorArg]? { swift.users?.map { DBXTeamUserSelectorArg(swift: $0) } }

    @objc
    public init(users: [DBXTeamUserSelectorArg]?) {
        self.swift = Team.ExcludedUsersUpdateArg(users: users?.map(\.swift))
    }

    let swift: Team.ExcludedUsersUpdateArg

    public init(swift: Team.ExcludedUsersUpdateArg) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Excluded users update error.
@objc
public class DBXTeamExcludedUsersUpdateError: NSObject {
    let swift: Team.ExcludedUsersUpdateError

    public init(swift: Team.ExcludedUsersUpdateError) {
        self.swift = swift
    }

    public static func factory(swift: Team.ExcludedUsersUpdateError) -> DBXTeamExcludedUsersUpdateError {
        switch swift {
        case .usersNotInTeam:
            return DBXTeamExcludedUsersUpdateErrorUsersNotInTeam()
        case .tooManyUsers:
            return DBXTeamExcludedUsersUpdateErrorTooManyUsers()
        case .other:
            return DBXTeamExcludedUsersUpdateErrorOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asUsersNotInTeam: DBXTeamExcludedUsersUpdateErrorUsersNotInTeam? {
        self as? DBXTeamExcludedUsersUpdateErrorUsersNotInTeam
    }

    @objc
    public var asTooManyUsers: DBXTeamExcludedUsersUpdateErrorTooManyUsers? {
        self as? DBXTeamExcludedUsersUpdateErrorTooManyUsers
    }

    @objc
    public var asOther: DBXTeamExcludedUsersUpdateErrorOther? {
        self as? DBXTeamExcludedUsersUpdateErrorOther
    }
}

/// At least one of the users is not part of your team.
@objc
public class DBXTeamExcludedUsersUpdateErrorUsersNotInTeam: DBXTeamExcludedUsersUpdateError {
    @objc
    public init() {
        let swift = Team.ExcludedUsersUpdateError.usersNotInTeam
        super.init(swift: swift)
    }
}

/// A maximum of 1000 users for each of addition/removal can be supplied.
@objc
public class DBXTeamExcludedUsersUpdateErrorTooManyUsers: DBXTeamExcludedUsersUpdateError {
    @objc
    public init() {
        let swift = Team.ExcludedUsersUpdateError.tooManyUsers
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXTeamExcludedUsersUpdateErrorOther: DBXTeamExcludedUsersUpdateError {
    @objc
    public init() {
        let swift = Team.ExcludedUsersUpdateError.other
        super.init(swift: swift)
    }
}

/// Excluded users update result.
@objc
public class DBXTeamExcludedUsersUpdateResult: NSObject {
    /// Update status.
    @objc
    public var status: DBXTeamExcludedUsersUpdateStatus { DBXTeamExcludedUsersUpdateStatus(swift: swift.status) }

    @objc
    public init(status: DBXTeamExcludedUsersUpdateStatus) {
        self.swift = Team.ExcludedUsersUpdateResult(status: status.swift)
    }

    let swift: Team.ExcludedUsersUpdateResult

    public init(swift: Team.ExcludedUsersUpdateResult) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Excluded users update operation status.
@objc
public class DBXTeamExcludedUsersUpdateStatus: NSObject {
    let swift: Team.ExcludedUsersUpdateStatus

    public init(swift: Team.ExcludedUsersUpdateStatus) {
        self.swift = swift
    }

    public static func factory(swift: Team.ExcludedUsersUpdateStatus) -> DBXTeamExcludedUsersUpdateStatus {
        switch swift {
        case .success:
            return DBXTeamExcludedUsersUpdateStatusSuccess()
        case .other:
            return DBXTeamExcludedUsersUpdateStatusOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asSuccess: DBXTeamExcludedUsersUpdateStatusSuccess? {
        self as? DBXTeamExcludedUsersUpdateStatusSuccess
    }

    @objc
    public var asOther: DBXTeamExcludedUsersUpdateStatusOther? {
        self as? DBXTeamExcludedUsersUpdateStatusOther
    }
}

/// Update successful.
@objc
public class DBXTeamExcludedUsersUpdateStatusSuccess: DBXTeamExcludedUsersUpdateStatus {
    @objc
    public init() {
        let swift = Team.ExcludedUsersUpdateStatus.success
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXTeamExcludedUsersUpdateStatusOther: DBXTeamExcludedUsersUpdateStatus {
    @objc
    public init() {
        let swift = Team.ExcludedUsersUpdateStatus.other
        super.init(swift: swift)
    }
}

/// A set of features that a Dropbox Business account may support.
@objc
public class DBXTeamFeature: NSObject {
    let swift: Team.Feature

    public init(swift: Team.Feature) {
        self.swift = swift
    }

    public static func factory(swift: Team.Feature) -> DBXTeamFeature {
        switch swift {
        case .uploadApiRateLimit:
            return DBXTeamFeatureUploadApiRateLimit()
        case .hasTeamSharedDropbox:
            return DBXTeamFeatureHasTeamSharedDropbox()
        case .hasTeamFileEvents:
            return DBXTeamFeatureHasTeamFileEvents()
        case .hasTeamSelectiveSync:
            return DBXTeamFeatureHasTeamSelectiveSync()
        case .other:
            return DBXTeamFeatureOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asUploadApiRateLimit: DBXTeamFeatureUploadApiRateLimit? {
        self as? DBXTeamFeatureUploadApiRateLimit
    }

    @objc
    public var asHasTeamSharedDropbox: DBXTeamFeatureHasTeamSharedDropbox? {
        self as? DBXTeamFeatureHasTeamSharedDropbox
    }

    @objc
    public var asHasTeamFileEvents: DBXTeamFeatureHasTeamFileEvents? {
        self as? DBXTeamFeatureHasTeamFileEvents
    }

    @objc
    public var asHasTeamSelectiveSync: DBXTeamFeatureHasTeamSelectiveSync? {
        self as? DBXTeamFeatureHasTeamSelectiveSync
    }

    @objc
    public var asOther: DBXTeamFeatureOther? {
        self as? DBXTeamFeatureOther
    }
}

/// The number of upload API calls allowed per month.
@objc
public class DBXTeamFeatureUploadApiRateLimit: DBXTeamFeature {
    @objc
    public init() {
        let swift = Team.Feature.uploadApiRateLimit
        super.init(swift: swift)
    }
}

/// Does this team have a shared team root.
@objc
public class DBXTeamFeatureHasTeamSharedDropbox: DBXTeamFeature {
    @objc
    public init() {
        let swift = Team.Feature.hasTeamSharedDropbox
        super.init(swift: swift)
    }
}

/// Does this team have file events.
@objc
public class DBXTeamFeatureHasTeamFileEvents: DBXTeamFeature {
    @objc
    public init() {
        let swift = Team.Feature.hasTeamFileEvents
        super.init(swift: swift)
    }
}

/// Does this team have team selective sync enabled.
@objc
public class DBXTeamFeatureHasTeamSelectiveSync: DBXTeamFeature {
    @objc
    public init() {
        let swift = Team.Feature.hasTeamSelectiveSync
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXTeamFeatureOther: DBXTeamFeature {
    @objc
    public init() {
        let swift = Team.Feature.other
        super.init(swift: swift)
    }
}

/// The values correspond to entries in Feature. You may get different value according to your Dropbox Business
/// plan.
@objc
public class DBXTeamFeatureValue: NSObject {
    let swift: Team.FeatureValue

    public init(swift: Team.FeatureValue) {
        self.swift = swift
    }

    public static func factory(swift: Team.FeatureValue) -> DBXTeamFeatureValue {
        switch swift {
        case .uploadApiRateLimit(let swiftArg):
            let arg = DBXTeamUploadApiRateLimitValue(swift: swiftArg)
            return DBXTeamFeatureValueUploadApiRateLimit(arg)
        case .hasTeamSharedDropbox(let swiftArg):
            let arg = DBXTeamHasTeamSharedDropboxValue(swift: swiftArg)
            return DBXTeamFeatureValueHasTeamSharedDropbox(arg)
        case .hasTeamFileEvents(let swiftArg):
            let arg = DBXTeamHasTeamFileEventsValue(swift: swiftArg)
            return DBXTeamFeatureValueHasTeamFileEvents(arg)
        case .hasTeamSelectiveSync(let swiftArg):
            let arg = DBXTeamHasTeamSelectiveSyncValue(swift: swiftArg)
            return DBXTeamFeatureValueHasTeamSelectiveSync(arg)
        case .other:
            return DBXTeamFeatureValueOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asUploadApiRateLimit: DBXTeamFeatureValueUploadApiRateLimit? {
        self as? DBXTeamFeatureValueUploadApiRateLimit
    }

    @objc
    public var asHasTeamSharedDropbox: DBXTeamFeatureValueHasTeamSharedDropbox? {
        self as? DBXTeamFeatureValueHasTeamSharedDropbox
    }

    @objc
    public var asHasTeamFileEvents: DBXTeamFeatureValueHasTeamFileEvents? {
        self as? DBXTeamFeatureValueHasTeamFileEvents
    }

    @objc
    public var asHasTeamSelectiveSync: DBXTeamFeatureValueHasTeamSelectiveSync? {
        self as? DBXTeamFeatureValueHasTeamSelectiveSync
    }

    @objc
    public var asOther: DBXTeamFeatureValueOther? {
        self as? DBXTeamFeatureValueOther
    }
}

/// An unspecified error.
@objc
public class DBXTeamFeatureValueUploadApiRateLimit: DBXTeamFeatureValue {
    @objc
    public var uploadApiRateLimit: DBXTeamUploadApiRateLimitValue

    @objc
    public init(_ arg: DBXTeamUploadApiRateLimitValue) {
        self.uploadApiRateLimit = arg
        let swift = Team.FeatureValue.uploadApiRateLimit(arg.swift)
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXTeamFeatureValueHasTeamSharedDropbox: DBXTeamFeatureValue {
    @objc
    public var hasTeamSharedDropbox: DBXTeamHasTeamSharedDropboxValue

    @objc
    public init(_ arg: DBXTeamHasTeamSharedDropboxValue) {
        self.hasTeamSharedDropbox = arg
        let swift = Team.FeatureValue.hasTeamSharedDropbox(arg.swift)
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXTeamFeatureValueHasTeamFileEvents: DBXTeamFeatureValue {
    @objc
    public var hasTeamFileEvents: DBXTeamHasTeamFileEventsValue

    @objc
    public init(_ arg: DBXTeamHasTeamFileEventsValue) {
        self.hasTeamFileEvents = arg
        let swift = Team.FeatureValue.hasTeamFileEvents(arg.swift)
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXTeamFeatureValueHasTeamSelectiveSync: DBXTeamFeatureValue {
    @objc
    public var hasTeamSelectiveSync: DBXTeamHasTeamSelectiveSyncValue

    @objc
    public init(_ arg: DBXTeamHasTeamSelectiveSyncValue) {
        self.hasTeamSelectiveSync = arg
        let swift = Team.FeatureValue.hasTeamSelectiveSync(arg.swift)
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXTeamFeatureValueOther: DBXTeamFeatureValue {
    @objc
    public init() {
        let swift = Team.FeatureValue.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible FeaturesGetValuesBatchArg struct
@objc
public class DBXTeamFeaturesGetValuesBatchArg: NSObject {
    /// A list of features in Feature. If the list is empty, this route will return FeaturesGetValuesBatchError.
    @objc
    public var features: [DBXTeamFeature] { swift.features.map { DBXTeamFeature(swift: $0) } }

    @objc
    public init(features: [DBXTeamFeature]) {
        self.swift = Team.FeaturesGetValuesBatchArg(features: features.map(\.swift))
    }

    let swift: Team.FeaturesGetValuesBatchArg

    public init(swift: Team.FeaturesGetValuesBatchArg) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible FeaturesGetValuesBatchError union
@objc
public class DBXTeamFeaturesGetValuesBatchError: NSObject {
    let swift: Team.FeaturesGetValuesBatchError

    public init(swift: Team.FeaturesGetValuesBatchError) {
        self.swift = swift
    }

    public static func factory(swift: Team.FeaturesGetValuesBatchError) -> DBXTeamFeaturesGetValuesBatchError {
        switch swift {
        case .emptyFeaturesList:
            return DBXTeamFeaturesGetValuesBatchErrorEmptyFeaturesList()
        case .other:
            return DBXTeamFeaturesGetValuesBatchErrorOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asEmptyFeaturesList: DBXTeamFeaturesGetValuesBatchErrorEmptyFeaturesList? {
        self as? DBXTeamFeaturesGetValuesBatchErrorEmptyFeaturesList
    }

    @objc
    public var asOther: DBXTeamFeaturesGetValuesBatchErrorOther? {
        self as? DBXTeamFeaturesGetValuesBatchErrorOther
    }
}

/// At least one Feature must be included in the FeaturesGetValuesBatchArg.features list.
@objc
public class DBXTeamFeaturesGetValuesBatchErrorEmptyFeaturesList: DBXTeamFeaturesGetValuesBatchError {
    @objc
    public init() {
        let swift = Team.FeaturesGetValuesBatchError.emptyFeaturesList
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXTeamFeaturesGetValuesBatchErrorOther: DBXTeamFeaturesGetValuesBatchError {
    @objc
    public init() {
        let swift = Team.FeaturesGetValuesBatchError.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible FeaturesGetValuesBatchResult struct
@objc
public class DBXTeamFeaturesGetValuesBatchResult: NSObject {
    /// (no description)
    @objc
    public var values: [DBXTeamFeatureValue] { swift.values.map { DBXTeamFeatureValue(swift: $0) } }

    @objc
    public init(values: [DBXTeamFeatureValue]) {
        self.swift = Team.FeaturesGetValuesBatchResult(values: values.map(\.swift))
    }

    let swift: Team.FeaturesGetValuesBatchResult

    public init(swift: Team.FeaturesGetValuesBatchResult) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Activity Report Result. Each of the items in the storage report is an array of values, one value per day. If
/// there is no data for a day, then the value will be None.
@objc
public class DBXTeamGetActivityReport: DBXTeamBaseDfbReport {
    /// Array of total number of adds by team members.
    @objc
    public var adds: [NSNumber] { subSwift.adds.compactMap { $0 as NSNumber? } }
    /// Array of number of edits by team members. If the same user edits the same file multiple times this is
    /// counted as a single edit.
    @objc
    public var edits: [NSNumber] { subSwift.edits.compactMap { $0 as NSNumber? } }
    /// Array of total number of deletes by team members.
    @objc
    public var deletes: [NSNumber] { subSwift.deletes.compactMap { $0 as NSNumber? } }
    /// Array of the number of users who have been active in the last 28 days.
    @objc
    public var activeUsers28Day: [NSNumber] { subSwift.activeUsers28Day.compactMap { $0 as NSNumber? } }
    /// Array of the number of users who have been active in the last week.
    @objc
    public var activeUsers7Day: [NSNumber] { subSwift.activeUsers7Day.compactMap { $0 as NSNumber? } }
    /// Array of the number of users who have been active in the last day.
    @objc
    public var activeUsers1Day: [NSNumber] { subSwift.activeUsers1Day.compactMap { $0 as NSNumber? } }
    /// Array of the number of shared folders with some activity in the last 28 days.
    @objc
    public var activeSharedFolders28Day: [NSNumber] { subSwift.activeSharedFolders28Day.compactMap { $0 as NSNumber? } }
    /// Array of the number of shared folders with some activity in the last week.
    @objc
    public var activeSharedFolders7Day: [NSNumber] { subSwift.activeSharedFolders7Day.compactMap { $0 as NSNumber? } }
    /// Array of the number of shared folders with some activity in the last day.
    @objc
    public var activeSharedFolders1Day: [NSNumber] { subSwift.activeSharedFolders1Day.compactMap { $0 as NSNumber? } }
    /// Array of the number of shared links created.
    @objc
    public var sharedLinksCreated: [NSNumber] { subSwift.sharedLinksCreated.compactMap { $0 as NSNumber? } }
    /// Array of the number of views by team users to shared links created by the team.
    @objc
    public var sharedLinksViewedByTeam: [NSNumber] { subSwift.sharedLinksViewedByTeam.compactMap { $0 as NSNumber? } }
    /// Array of the number of views by users outside of the team to shared links created by the team.
    @objc
    public var sharedLinksViewedByOutsideUser: [NSNumber] { subSwift.sharedLinksViewedByOutsideUser.compactMap { $0 as NSNumber? } }
    /// Array of the number of views by non-logged-in users to shared links created by the team.
    @objc
    public var sharedLinksViewedByNotLoggedIn: [NSNumber] { subSwift.sharedLinksViewedByNotLoggedIn.compactMap { $0 as NSNumber? } }
    /// Array of the total number of views to shared links created by the team.
    @objc
    public var sharedLinksViewedTotal: [NSNumber] { subSwift.sharedLinksViewedTotal.compactMap { $0 as NSNumber? } }

    @objc
    public init(
        startDate: String,
        adds: [NSNumber],
        edits: [NSNumber],
        deletes: [NSNumber],
        activeUsers28Day: [NSNumber],
        activeUsers7Day: [NSNumber],
        activeUsers1Day: [NSNumber],
        activeSharedFolders28Day: [NSNumber],
        activeSharedFolders7Day: [NSNumber],
        activeSharedFolders1Day: [NSNumber],
        sharedLinksCreated: [NSNumber],
        sharedLinksViewedByTeam: [NSNumber],
        sharedLinksViewedByOutsideUser: [NSNumber],
        sharedLinksViewedByNotLoggedIn: [NSNumber],
        sharedLinksViewedTotal: [NSNumber]
    ) {
        let swift = Team.GetActivityReport(
            startDate: startDate,
            adds: adds.map(\.uint64Value),
            edits: edits.map(\.uint64Value),
            deletes: deletes.map(\.uint64Value),
            activeUsers28Day: activeUsers28Day.map(\.uint64Value),
            activeUsers7Day: activeUsers7Day.map(\.uint64Value),
            activeUsers1Day: activeUsers1Day.map(\.uint64Value),
            activeSharedFolders28Day: activeSharedFolders28Day.map(\.uint64Value),
            activeSharedFolders7Day: activeSharedFolders7Day.map(\.uint64Value),
            activeSharedFolders1Day: activeSharedFolders1Day.map(\.uint64Value),
            sharedLinksCreated: sharedLinksCreated.map(\.uint64Value),
            sharedLinksViewedByTeam: sharedLinksViewedByTeam.map(\.uint64Value),
            sharedLinksViewedByOutsideUser: sharedLinksViewedByOutsideUser.map(\.uint64Value),
            sharedLinksViewedByNotLoggedIn: sharedLinksViewedByNotLoggedIn.map(\.uint64Value),
            sharedLinksViewedTotal: sharedLinksViewedTotal.map(\.uint64Value)
        )
        self.subSwift = swift
        super.init(swift: swift)
    }

    let subSwift: Team.GetActivityReport

    public init(swift: Team.GetActivityReport) {
        self.subSwift = swift
        super.init(swift: swift)
    }

    @objc
    public override var description: String { subSwift.description }
}

/// Devices Report Result. Contains subsections for different time ranges of activity. Each of the items in each
/// subsection of the storage report is an array of values, one value per day. If there is no data for a day, then
/// the value will be None.
@objc
public class DBXTeamGetDevicesReport: DBXTeamBaseDfbReport {
    /// Report of the number of devices active in the last day.
    @objc
    public var active1Day: DBXTeamDevicesActive { DBXTeamDevicesActive(swift: subSwift.active1Day) }
    /// Report of the number of devices active in the last 7 days.
    @objc
    public var active7Day: DBXTeamDevicesActive { DBXTeamDevicesActive(swift: subSwift.active7Day) }
    /// Report of the number of devices active in the last 28 days.
    @objc
    public var active28Day: DBXTeamDevicesActive { DBXTeamDevicesActive(swift: subSwift.active28Day) }

    @objc
    public init(startDate: String, active1Day: DBXTeamDevicesActive, active7Day: DBXTeamDevicesActive, active28Day: DBXTeamDevicesActive) {
        let swift = Team.GetDevicesReport(startDate: startDate, active1Day: active1Day.swift, active7Day: active7Day.swift, active28Day: active28Day.swift)
        self.subSwift = swift
        super.init(swift: swift)
    }

    let subSwift: Team.GetDevicesReport

    public init(swift: Team.GetDevicesReport) {
        self.subSwift = swift
        super.init(swift: swift)
    }

    @objc
    public override var description: String { subSwift.description }
}

/// Membership Report Result. Each of the items in the storage report is an array of values, one value per day. If
/// there is no data for a day, then the value will be None.
@objc
public class DBXTeamGetMembershipReport: DBXTeamBaseDfbReport {
    /// Team size, for each day.
    @objc
    public var teamSize: [NSNumber] { subSwift.teamSize.compactMap { $0 as NSNumber? } }
    /// The number of pending invites to the team, for each day.
    @objc
    public var pendingInvites: [NSNumber] { subSwift.pendingInvites.compactMap { $0 as NSNumber? } }
    /// The number of members that joined the team, for each day.
    @objc
    public var membersJoined: [NSNumber] { subSwift.membersJoined.compactMap { $0 as NSNumber? } }
    /// The number of suspended team members, for each day.
    @objc
    public var suspendedMembers: [NSNumber] { subSwift.suspendedMembers.compactMap { $0 as NSNumber? } }
    /// The total number of licenses the team has, for each day.
    @objc
    public var licenses: [NSNumber] { subSwift.licenses.compactMap { $0 as NSNumber? } }

    @objc
    public init(
        startDate: String,
        teamSize: [NSNumber],
        pendingInvites: [NSNumber],
        membersJoined: [NSNumber],
        suspendedMembers: [NSNumber],
        licenses: [NSNumber]
    ) {
        let swift = Team.GetMembershipReport(
            startDate: startDate,
            teamSize: teamSize.map(\.uint64Value),
            pendingInvites: pendingInvites.map(\.uint64Value),
            membersJoined: membersJoined.map(\.uint64Value),
            suspendedMembers: suspendedMembers.map(\.uint64Value),
            licenses: licenses.map(\.uint64Value)
        )
        self.subSwift = swift
        super.init(swift: swift)
    }

    let subSwift: Team.GetMembershipReport

    public init(swift: Team.GetMembershipReport) {
        self.subSwift = swift
        super.init(swift: swift)
    }

    @objc
    public override var description: String { subSwift.description }
}

/// Storage Report Result. Each of the items in the storage report is an array of values, one value per day. If
/// there is no data for a day, then the value will be None.
@objc
public class DBXTeamGetStorageReport: DBXTeamBaseDfbReport {
    /// Sum of the shared, unshared, and datastore usages, for each day.
    @objc
    public var totalUsage: [NSNumber] { subSwift.totalUsage.compactMap { $0 as NSNumber? } }
    /// Array of the combined size (bytes) of team members' shared folders, for each day.
    @objc
    public var sharedUsage: [NSNumber] { subSwift.sharedUsage.compactMap { $0 as NSNumber? } }
    /// Array of the combined size (bytes) of team members' root namespaces, for each day.
    @objc
    public var unsharedUsage: [NSNumber] { subSwift.unsharedUsage.compactMap { $0 as NSNumber? } }
    /// Array of the number of shared folders owned by team members, for each day.
    @objc
    public var sharedFolders: [NSNumber] { subSwift.sharedFolders.compactMap { $0 as NSNumber? } }
    /// Array of storage summaries of team members' account sizes. Each storage summary is an array of key, value
    /// pairs, where each pair describes a storage bucket. The key indicates the upper bound of the bucket and
    /// the value is the number of users in that bucket. There is one such summary per day. If there is no data
    /// for a day, the storage summary will be empty.
    @objc
    public var memberStorageMap: [[DBXTeamStorageBucket]] { subSwift.memberStorageMap.map { $0.map { DBXTeamStorageBucket(swift: $0) } } }

    @objc
    public init(
        startDate: String,
        totalUsage: [NSNumber],
        sharedUsage: [NSNumber],
        unsharedUsage: [NSNumber],
        sharedFolders: [NSNumber],
        memberStorageMap: [[DBXTeamStorageBucket]]
    ) {
        let swift = Team.GetStorageReport(
            startDate: startDate,
            totalUsage: totalUsage.map(\.uint64Value),
            sharedUsage: sharedUsage.map(\.uint64Value),
            unsharedUsage: unsharedUsage.map(\.uint64Value),
            sharedFolders: sharedFolders.map(\.uint64Value),
            memberStorageMap: memberStorageMap.map { $0.map(\.swift) }
        )
        self.subSwift = swift
        super.init(swift: swift)
    }

    let subSwift: Team.GetStorageReport

    public init(swift: Team.GetStorageReport) {
        self.subSwift = swift
        super.init(swift: swift)
    }

    @objc
    public override var description: String { subSwift.description }
}

/// Role of a user in group.
@objc
public class DBXTeamGroupAccessType: NSObject {
    let swift: Team.GroupAccessType

    public init(swift: Team.GroupAccessType) {
        self.swift = swift
    }

    public static func factory(swift: Team.GroupAccessType) -> DBXTeamGroupAccessType {
        switch swift {
        case .member:
            return DBXTeamGroupAccessTypeMember()
        case .owner:
            return DBXTeamGroupAccessTypeOwner()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asMember: DBXTeamGroupAccessTypeMember? {
        self as? DBXTeamGroupAccessTypeMember
    }

    @objc
    public var asOwner: DBXTeamGroupAccessTypeOwner? {
        self as? DBXTeamGroupAccessTypeOwner
    }
}

/// User is a member of the group, but has no special permissions.
@objc
public class DBXTeamGroupAccessTypeMember: DBXTeamGroupAccessType {
    @objc
    public init() {
        let swift = Team.GroupAccessType.member
        super.init(swift: swift)
    }
}

/// User can rename the group, and add/remove members.
@objc
public class DBXTeamGroupAccessTypeOwner: DBXTeamGroupAccessType {
    @objc
    public init() {
        let swift = Team.GroupAccessType.owner
        super.init(swift: swift)
    }
}

/// Objective-C compatible GroupCreateArg struct
@objc
public class DBXTeamGroupCreateArg: NSObject {
    /// Group name.
    @objc
    public var groupName: String { swift.groupName }
    /// Automatically add the creator of the group.
    @objc
    public var addCreatorAsOwner: NSNumber { swift.addCreatorAsOwner as NSNumber }
    /// The creator of a team can associate an arbitrary external ID to the group.
    @objc
    public var groupExternalId: String? { swift.groupExternalId }
    /// Whether the team can be managed by selected users, or only by team admins.
    @objc
    public var groupManagementType: DBXTeamCommonGroupManagementType? { guard let swift = swift.groupManagementType else { return nil }
        return DBXTeamCommonGroupManagementType(swift: swift)
    }

    @objc
    public init(groupName: String, addCreatorAsOwner: NSNumber, groupExternalId: String?, groupManagementType: DBXTeamCommonGroupManagementType?) {
        self.swift = Team.GroupCreateArg(
            groupName: groupName,
            addCreatorAsOwner: addCreatorAsOwner.boolValue,
            groupExternalId: groupExternalId,
            groupManagementType: groupManagementType?.swift
        )
    }

    let swift: Team.GroupCreateArg

    public init(swift: Team.GroupCreateArg) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible GroupCreateError union
@objc
public class DBXTeamGroupCreateError: NSObject {
    let swift: Team.GroupCreateError

    public init(swift: Team.GroupCreateError) {
        self.swift = swift
    }

    public static func factory(swift: Team.GroupCreateError) -> DBXTeamGroupCreateError {
        switch swift {
        case .groupNameAlreadyUsed:
            return DBXTeamGroupCreateErrorGroupNameAlreadyUsed()
        case .groupNameInvalid:
            return DBXTeamGroupCreateErrorGroupNameInvalid()
        case .externalIdAlreadyInUse:
            return DBXTeamGroupCreateErrorExternalIdAlreadyInUse()
        case .systemManagedGroupDisallowed:
            return DBXTeamGroupCreateErrorSystemManagedGroupDisallowed()
        case .other:
            return DBXTeamGroupCreateErrorOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asGroupNameAlreadyUsed: DBXTeamGroupCreateErrorGroupNameAlreadyUsed? {
        self as? DBXTeamGroupCreateErrorGroupNameAlreadyUsed
    }

    @objc
    public var asGroupNameInvalid: DBXTeamGroupCreateErrorGroupNameInvalid? {
        self as? DBXTeamGroupCreateErrorGroupNameInvalid
    }

    @objc
    public var asExternalIdAlreadyInUse: DBXTeamGroupCreateErrorExternalIdAlreadyInUse? {
        self as? DBXTeamGroupCreateErrorExternalIdAlreadyInUse
    }

    @objc
    public var asSystemManagedGroupDisallowed: DBXTeamGroupCreateErrorSystemManagedGroupDisallowed? {
        self as? DBXTeamGroupCreateErrorSystemManagedGroupDisallowed
    }

    @objc
    public var asOther: DBXTeamGroupCreateErrorOther? {
        self as? DBXTeamGroupCreateErrorOther
    }
}

/// The requested group name is already being used by another group.
@objc
public class DBXTeamGroupCreateErrorGroupNameAlreadyUsed: DBXTeamGroupCreateError {
    @objc
    public init() {
        let swift = Team.GroupCreateError.groupNameAlreadyUsed
        super.init(swift: swift)
    }
}

/// Group name is empty or has invalid characters.
@objc
public class DBXTeamGroupCreateErrorGroupNameInvalid: DBXTeamGroupCreateError {
    @objc
    public init() {
        let swift = Team.GroupCreateError.groupNameInvalid
        super.init(swift: swift)
    }
}

/// The requested external ID is already being used by another group.
@objc
public class DBXTeamGroupCreateErrorExternalIdAlreadyInUse: DBXTeamGroupCreateError {
    @objc
    public init() {
        let swift = Team.GroupCreateError.externalIdAlreadyInUse
        super.init(swift: swift)
    }
}

/// System-managed group cannot be manually created.
@objc
public class DBXTeamGroupCreateErrorSystemManagedGroupDisallowed: DBXTeamGroupCreateError {
    @objc
    public init() {
        let swift = Team.GroupCreateError.systemManagedGroupDisallowed
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXTeamGroupCreateErrorOther: DBXTeamGroupCreateError {
    @objc
    public init() {
        let swift = Team.GroupCreateError.other
        super.init(swift: swift)
    }
}

/// Error that can be raised when GroupSelector is used.
@objc
public class DBXTeamGroupSelectorError: NSObject {
    let swift: Team.GroupSelectorError

    public init(swift: Team.GroupSelectorError) {
        self.swift = swift
    }

    public static func factory(swift: Team.GroupSelectorError) -> DBXTeamGroupSelectorError {
        switch swift {
        case .groupNotFound:
            return DBXTeamGroupSelectorErrorGroupNotFound()
        case .other:
            return DBXTeamGroupSelectorErrorOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asGroupNotFound: DBXTeamGroupSelectorErrorGroupNotFound? {
        self as? DBXTeamGroupSelectorErrorGroupNotFound
    }

    @objc
    public var asOther: DBXTeamGroupSelectorErrorOther? {
        self as? DBXTeamGroupSelectorErrorOther
    }
}

/// No matching group found. No groups match the specified group ID.
@objc
public class DBXTeamGroupSelectorErrorGroupNotFound: DBXTeamGroupSelectorError {
    @objc
    public init() {
        let swift = Team.GroupSelectorError.groupNotFound
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXTeamGroupSelectorErrorOther: DBXTeamGroupSelectorError {
    @objc
    public init() {
        let swift = Team.GroupSelectorError.other
        super.init(swift: swift)
    }
}

/// Error that can be raised when GroupSelector is used and team groups are disallowed from being used.
@objc
public class DBXTeamGroupSelectorWithTeamGroupError: NSObject {
    let swift: Team.GroupSelectorWithTeamGroupError

    public init(swift: Team.GroupSelectorWithTeamGroupError) {
        self.swift = swift
    }

    public static func factory(swift: Team.GroupSelectorWithTeamGroupError) -> DBXTeamGroupSelectorWithTeamGroupError {
        switch swift {
        case .groupNotFound:
            return DBXTeamGroupSelectorWithTeamGroupErrorGroupNotFound()
        case .other:
            return DBXTeamGroupSelectorWithTeamGroupErrorOther()
        case .systemManagedGroupDisallowed:
            return DBXTeamGroupSelectorWithTeamGroupErrorSystemManagedGroupDisallowed()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asGroupNotFound: DBXTeamGroupSelectorWithTeamGroupErrorGroupNotFound? {
        self as? DBXTeamGroupSelectorWithTeamGroupErrorGroupNotFound
    }

    @objc
    public var asOther: DBXTeamGroupSelectorWithTeamGroupErrorOther? {
        self as? DBXTeamGroupSelectorWithTeamGroupErrorOther
    }

    @objc
    public var asSystemManagedGroupDisallowed: DBXTeamGroupSelectorWithTeamGroupErrorSystemManagedGroupDisallowed? {
        self as? DBXTeamGroupSelectorWithTeamGroupErrorSystemManagedGroupDisallowed
    }
}

/// No matching group found. No groups match the specified group ID.
@objc
public class DBXTeamGroupSelectorWithTeamGroupErrorGroupNotFound: DBXTeamGroupSelectorWithTeamGroupError {
    @objc
    public init() {
        let swift = Team.GroupSelectorWithTeamGroupError.groupNotFound
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXTeamGroupSelectorWithTeamGroupErrorOther: DBXTeamGroupSelectorWithTeamGroupError {
    @objc
    public init() {
        let swift = Team.GroupSelectorWithTeamGroupError.other
        super.init(swift: swift)
    }
}

/// This operation is not supported on system-managed groups.
@objc
public class DBXTeamGroupSelectorWithTeamGroupErrorSystemManagedGroupDisallowed: DBXTeamGroupSelectorWithTeamGroupError {
    @objc
    public init() {
        let swift = Team.GroupSelectorWithTeamGroupError.systemManagedGroupDisallowed
        super.init(swift: swift)
    }
}

/// Objective-C compatible GroupDeleteError union
@objc
public class DBXTeamGroupDeleteError: NSObject {
    let swift: Team.GroupDeleteError

    public init(swift: Team.GroupDeleteError) {
        self.swift = swift
    }

    public static func factory(swift: Team.GroupDeleteError) -> DBXTeamGroupDeleteError {
        switch swift {
        case .groupNotFound:
            return DBXTeamGroupDeleteErrorGroupNotFound()
        case .other:
            return DBXTeamGroupDeleteErrorOther()
        case .systemManagedGroupDisallowed:
            return DBXTeamGroupDeleteErrorSystemManagedGroupDisallowed()
        case .groupAlreadyDeleted:
            return DBXTeamGroupDeleteErrorGroupAlreadyDeleted()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asGroupNotFound: DBXTeamGroupDeleteErrorGroupNotFound? {
        self as? DBXTeamGroupDeleteErrorGroupNotFound
    }

    @objc
    public var asOther: DBXTeamGroupDeleteErrorOther? {
        self as? DBXTeamGroupDeleteErrorOther
    }

    @objc
    public var asSystemManagedGroupDisallowed: DBXTeamGroupDeleteErrorSystemManagedGroupDisallowed? {
        self as? DBXTeamGroupDeleteErrorSystemManagedGroupDisallowed
    }

    @objc
    public var asGroupAlreadyDeleted: DBXTeamGroupDeleteErrorGroupAlreadyDeleted? {
        self as? DBXTeamGroupDeleteErrorGroupAlreadyDeleted
    }
}

/// No matching group found. No groups match the specified group ID.
@objc
public class DBXTeamGroupDeleteErrorGroupNotFound: DBXTeamGroupDeleteError {
    @objc
    public init() {
        let swift = Team.GroupDeleteError.groupNotFound
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXTeamGroupDeleteErrorOther: DBXTeamGroupDeleteError {
    @objc
    public init() {
        let swift = Team.GroupDeleteError.other
        super.init(swift: swift)
    }
}

/// This operation is not supported on system-managed groups.
@objc
public class DBXTeamGroupDeleteErrorSystemManagedGroupDisallowed: DBXTeamGroupDeleteError {
    @objc
    public init() {
        let swift = Team.GroupDeleteError.systemManagedGroupDisallowed
        super.init(swift: swift)
    }
}

/// This group has already been deleted.
@objc
public class DBXTeamGroupDeleteErrorGroupAlreadyDeleted: DBXTeamGroupDeleteError {
    @objc
    public init() {
        let swift = Team.GroupDeleteError.groupAlreadyDeleted
        super.init(swift: swift)
    }
}

/// Full description of a group.
@objc
public class DBXTeamGroupFullInfo: DBXTeamCommonGroupSummary {
    /// List of group members.
    @objc
    public var members: [DBXTeamGroupMemberInfo]? { subSwift.members?.map { DBXTeamGroupMemberInfo(swift: $0) } }
    /// The group creation time as a UTC timestamp in milliseconds since the Unix epoch.
    @objc
    public var created: NSNumber { subSwift.created as NSNumber }

    @objc
    public init(
        groupName: String,
        groupId: String,
        groupManagementType: DBXTeamCommonGroupManagementType,
        created: NSNumber,
        groupExternalId: String?,
        memberCount: NSNumber?,
        members: [DBXTeamGroupMemberInfo]?
    ) {
        let swift = Team.GroupFullInfo(
            groupName: groupName,
            groupId: groupId,
            groupManagementType: groupManagementType.swift,
            created: created.uint64Value,
            groupExternalId: groupExternalId,
            memberCount: memberCount?.uint32Value,
            members: members?.map(\.swift)
        )
        self.subSwift = swift
        super.init(swift: swift)
    }

    let subSwift: Team.GroupFullInfo

    public init(swift: Team.GroupFullInfo) {
        self.subSwift = swift
        super.init(swift: swift)
    }

    @objc
    public override var description: String { subSwift.description }
}

/// Profile of group member, and role in group.
@objc
public class DBXTeamGroupMemberInfo: NSObject {
    /// Profile of group member.
    @objc
    public var profile: DBXTeamMemberProfile { DBXTeamMemberProfile(swift: swift.profile) }
    /// The role that the user has in the group.
    @objc
    public var accessType: DBXTeamGroupAccessType { DBXTeamGroupAccessType(swift: swift.accessType) }

    @objc
    public init(profile: DBXTeamMemberProfile, accessType: DBXTeamGroupAccessType) {
        self.swift = Team.GroupMemberInfo(profile: profile.swift, accessType: accessType.swift)
    }

    let swift: Team.GroupMemberInfo

    public init(swift: Team.GroupMemberInfo) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Argument for selecting a group and a single user.
@objc
public class DBXTeamGroupMemberSelector: NSObject {
    /// Specify a group.
    @objc
    public var group: DBXTeamGroupSelector { DBXTeamGroupSelector(swift: swift.group) }
    /// Identity of a user that is a member of group.
    @objc
    public var user: DBXTeamUserSelectorArg { DBXTeamUserSelectorArg(swift: swift.user) }

    @objc
    public init(group: DBXTeamGroupSelector, user: DBXTeamUserSelectorArg) {
        self.swift = Team.GroupMemberSelector(group: group.swift, user: user.swift)
    }

    let swift: Team.GroupMemberSelector

    public init(swift: Team.GroupMemberSelector) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Error that can be raised when GroupMemberSelector is used, and the user is required to be a member of the
/// specified group.
@objc
public class DBXTeamGroupMemberSelectorError: NSObject {
    let swift: Team.GroupMemberSelectorError

    public init(swift: Team.GroupMemberSelectorError) {
        self.swift = swift
    }

    public static func factory(swift: Team.GroupMemberSelectorError) -> DBXTeamGroupMemberSelectorError {
        switch swift {
        case .groupNotFound:
            return DBXTeamGroupMemberSelectorErrorGroupNotFound()
        case .other:
            return DBXTeamGroupMemberSelectorErrorOther()
        case .systemManagedGroupDisallowed:
            return DBXTeamGroupMemberSelectorErrorSystemManagedGroupDisallowed()
        case .memberNotInGroup:
            return DBXTeamGroupMemberSelectorErrorMemberNotInGroup()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asGroupNotFound: DBXTeamGroupMemberSelectorErrorGroupNotFound? {
        self as? DBXTeamGroupMemberSelectorErrorGroupNotFound
    }

    @objc
    public var asOther: DBXTeamGroupMemberSelectorErrorOther? {
        self as? DBXTeamGroupMemberSelectorErrorOther
    }

    @objc
    public var asSystemManagedGroupDisallowed: DBXTeamGroupMemberSelectorErrorSystemManagedGroupDisallowed? {
        self as? DBXTeamGroupMemberSelectorErrorSystemManagedGroupDisallowed
    }

    @objc
    public var asMemberNotInGroup: DBXTeamGroupMemberSelectorErrorMemberNotInGroup? {
        self as? DBXTeamGroupMemberSelectorErrorMemberNotInGroup
    }
}

/// No matching group found. No groups match the specified group ID.
@objc
public class DBXTeamGroupMemberSelectorErrorGroupNotFound: DBXTeamGroupMemberSelectorError {
    @objc
    public init() {
        let swift = Team.GroupMemberSelectorError.groupNotFound
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXTeamGroupMemberSelectorErrorOther: DBXTeamGroupMemberSelectorError {
    @objc
    public init() {
        let swift = Team.GroupMemberSelectorError.other
        super.init(swift: swift)
    }
}

/// This operation is not supported on system-managed groups.
@objc
public class DBXTeamGroupMemberSelectorErrorSystemManagedGroupDisallowed: DBXTeamGroupMemberSelectorError {
    @objc
    public init() {
        let swift = Team.GroupMemberSelectorError.systemManagedGroupDisallowed
        super.init(swift: swift)
    }
}

/// The specified user is not a member of this group.
@objc
public class DBXTeamGroupMemberSelectorErrorMemberNotInGroup: DBXTeamGroupMemberSelectorError {
    @objc
    public init() {
        let swift = Team.GroupMemberSelectorError.memberNotInGroup
        super.init(swift: swift)
    }
}

/// Objective-C compatible GroupMemberSetAccessTypeError union
@objc
public class DBXTeamGroupMemberSetAccessTypeError: NSObject {
    let swift: Team.GroupMemberSetAccessTypeError

    public init(swift: Team.GroupMemberSetAccessTypeError) {
        self.swift = swift
    }

    public static func factory(swift: Team.GroupMemberSetAccessTypeError) -> DBXTeamGroupMemberSetAccessTypeError {
        switch swift {
        case .groupNotFound:
            return DBXTeamGroupMemberSetAccessTypeErrorGroupNotFound()
        case .other:
            return DBXTeamGroupMemberSetAccessTypeErrorOther()
        case .systemManagedGroupDisallowed:
            return DBXTeamGroupMemberSetAccessTypeErrorSystemManagedGroupDisallowed()
        case .memberNotInGroup:
            return DBXTeamGroupMemberSetAccessTypeErrorMemberNotInGroup()
        case .userCannotBeManagerOfCompanyManagedGroup:
            return DBXTeamGroupMemberSetAccessTypeErrorUserCannotBeManagerOfCompanyManagedGroup()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asGroupNotFound: DBXTeamGroupMemberSetAccessTypeErrorGroupNotFound? {
        self as? DBXTeamGroupMemberSetAccessTypeErrorGroupNotFound
    }

    @objc
    public var asOther: DBXTeamGroupMemberSetAccessTypeErrorOther? {
        self as? DBXTeamGroupMemberSetAccessTypeErrorOther
    }

    @objc
    public var asSystemManagedGroupDisallowed: DBXTeamGroupMemberSetAccessTypeErrorSystemManagedGroupDisallowed? {
        self as? DBXTeamGroupMemberSetAccessTypeErrorSystemManagedGroupDisallowed
    }

    @objc
    public var asMemberNotInGroup: DBXTeamGroupMemberSetAccessTypeErrorMemberNotInGroup? {
        self as? DBXTeamGroupMemberSetAccessTypeErrorMemberNotInGroup
    }

    @objc
    public var asUserCannotBeManagerOfCompanyManagedGroup: DBXTeamGroupMemberSetAccessTypeErrorUserCannotBeManagerOfCompanyManagedGroup? {
        self as? DBXTeamGroupMemberSetAccessTypeErrorUserCannotBeManagerOfCompanyManagedGroup
    }
}

/// No matching group found. No groups match the specified group ID.
@objc
public class DBXTeamGroupMemberSetAccessTypeErrorGroupNotFound: DBXTeamGroupMemberSetAccessTypeError {
    @objc
    public init() {
        let swift = Team.GroupMemberSetAccessTypeError.groupNotFound
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXTeamGroupMemberSetAccessTypeErrorOther: DBXTeamGroupMemberSetAccessTypeError {
    @objc
    public init() {
        let swift = Team.GroupMemberSetAccessTypeError.other
        super.init(swift: swift)
    }
}

/// This operation is not supported on system-managed groups.
@objc
public class DBXTeamGroupMemberSetAccessTypeErrorSystemManagedGroupDisallowed: DBXTeamGroupMemberSetAccessTypeError {
    @objc
    public init() {
        let swift = Team.GroupMemberSetAccessTypeError.systemManagedGroupDisallowed
        super.init(swift: swift)
    }
}

/// The specified user is not a member of this group.
@objc
public class DBXTeamGroupMemberSetAccessTypeErrorMemberNotInGroup: DBXTeamGroupMemberSetAccessTypeError {
    @objc
    public init() {
        let swift = Team.GroupMemberSetAccessTypeError.memberNotInGroup
        super.init(swift: swift)
    }
}

/// A company managed group cannot be managed by a user.
@objc
public class DBXTeamGroupMemberSetAccessTypeErrorUserCannotBeManagerOfCompanyManagedGroup: DBXTeamGroupMemberSetAccessTypeError {
    @objc
    public init() {
        let swift = Team.GroupMemberSetAccessTypeError.userCannotBeManagerOfCompanyManagedGroup
        super.init(swift: swift)
    }
}

/// Objective-C compatible IncludeMembersArg struct
@objc
public class DBXTeamIncludeMembersArg: NSObject {
    /// Whether to return the list of members in the group.  Note that the default value will cause all the group
    /// members  to be returned in the response. This may take a long time for large groups.
    @objc
    public var returnMembers: NSNumber { swift.returnMembers as NSNumber }

    @objc
    public init(returnMembers: NSNumber) {
        self.swift = Team.IncludeMembersArg(returnMembers: returnMembers.boolValue)
    }

    let swift: Team.IncludeMembersArg

    public init(swift: Team.IncludeMembersArg) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible GroupMembersAddArg struct
@objc
public class DBXTeamGroupMembersAddArg: DBXTeamIncludeMembersArg {
    /// Group to which users will be added.
    @objc
    public var group: DBXTeamGroupSelector { DBXTeamGroupSelector(swift: subSwift.group) }
    /// List of users to be added to the group.
    @objc
    public var members: [DBXTeamMemberAccess] { subSwift.members.map { DBXTeamMemberAccess(swift: $0) } }

    @objc
    public init(group: DBXTeamGroupSelector, members: [DBXTeamMemberAccess], returnMembers: NSNumber) {
        let swift = Team.GroupMembersAddArg(group: group.swift, members: members.map(\.swift), returnMembers: returnMembers.boolValue)
        self.subSwift = swift
        super.init(swift: swift)
    }

    let subSwift: Team.GroupMembersAddArg

    public init(swift: Team.GroupMembersAddArg) {
        self.subSwift = swift
        super.init(swift: swift)
    }

    @objc
    public override var description: String { subSwift.description }
}

/// Objective-C compatible GroupMembersAddError union
@objc
public class DBXTeamGroupMembersAddError: NSObject {
    let swift: Team.GroupMembersAddError

    public init(swift: Team.GroupMembersAddError) {
        self.swift = swift
    }

    public static func factory(swift: Team.GroupMembersAddError) -> DBXTeamGroupMembersAddError {
        switch swift {
        case .groupNotFound:
            return DBXTeamGroupMembersAddErrorGroupNotFound()
        case .other:
            return DBXTeamGroupMembersAddErrorOther()
        case .systemManagedGroupDisallowed:
            return DBXTeamGroupMembersAddErrorSystemManagedGroupDisallowed()
        case .duplicateUser:
            return DBXTeamGroupMembersAddErrorDuplicateUser()
        case .groupNotInTeam:
            return DBXTeamGroupMembersAddErrorGroupNotInTeam()
        case .membersNotInTeam(let swiftArg):
            let arg = swiftArg
            return DBXTeamGroupMembersAddErrorMembersNotInTeam(arg)
        case .usersNotFound(let swiftArg):
            let arg = swiftArg
            return DBXTeamGroupMembersAddErrorUsersNotFound(arg)
        case .userMustBeActiveToBeOwner:
            return DBXTeamGroupMembersAddErrorUserMustBeActiveToBeOwner()
        case .userCannotBeManagerOfCompanyManagedGroup(let swiftArg):
            let arg = swiftArg
            return DBXTeamGroupMembersAddErrorUserCannotBeManagerOfCompanyManagedGroup(arg)
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asGroupNotFound: DBXTeamGroupMembersAddErrorGroupNotFound? {
        self as? DBXTeamGroupMembersAddErrorGroupNotFound
    }

    @objc
    public var asOther: DBXTeamGroupMembersAddErrorOther? {
        self as? DBXTeamGroupMembersAddErrorOther
    }

    @objc
    public var asSystemManagedGroupDisallowed: DBXTeamGroupMembersAddErrorSystemManagedGroupDisallowed? {
        self as? DBXTeamGroupMembersAddErrorSystemManagedGroupDisallowed
    }

    @objc
    public var asDuplicateUser: DBXTeamGroupMembersAddErrorDuplicateUser? {
        self as? DBXTeamGroupMembersAddErrorDuplicateUser
    }

    @objc
    public var asGroupNotInTeam: DBXTeamGroupMembersAddErrorGroupNotInTeam? {
        self as? DBXTeamGroupMembersAddErrorGroupNotInTeam
    }

    @objc
    public var asMembersNotInTeam: DBXTeamGroupMembersAddErrorMembersNotInTeam? {
        self as? DBXTeamGroupMembersAddErrorMembersNotInTeam
    }

    @objc
    public var asUsersNotFound: DBXTeamGroupMembersAddErrorUsersNotFound? {
        self as? DBXTeamGroupMembersAddErrorUsersNotFound
    }

    @objc
    public var asUserMustBeActiveToBeOwner: DBXTeamGroupMembersAddErrorUserMustBeActiveToBeOwner? {
        self as? DBXTeamGroupMembersAddErrorUserMustBeActiveToBeOwner
    }

    @objc
    public var asUserCannotBeManagerOfCompanyManagedGroup: DBXTeamGroupMembersAddErrorUserCannotBeManagerOfCompanyManagedGroup? {
        self as? DBXTeamGroupMembersAddErrorUserCannotBeManagerOfCompanyManagedGroup
    }
}

/// No matching group found. No groups match the specified group ID.
@objc
public class DBXTeamGroupMembersAddErrorGroupNotFound: DBXTeamGroupMembersAddError {
    @objc
    public init() {
        let swift = Team.GroupMembersAddError.groupNotFound
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXTeamGroupMembersAddErrorOther: DBXTeamGroupMembersAddError {
    @objc
    public init() {
        let swift = Team.GroupMembersAddError.other
        super.init(swift: swift)
    }
}

/// This operation is not supported on system-managed groups.
@objc
public class DBXTeamGroupMembersAddErrorSystemManagedGroupDisallowed: DBXTeamGroupMembersAddError {
    @objc
    public init() {
        let swift = Team.GroupMembersAddError.systemManagedGroupDisallowed
        super.init(swift: swift)
    }
}

/// You cannot add duplicate users. One or more of the members you are trying to add is already a member of the
/// group.
@objc
public class DBXTeamGroupMembersAddErrorDuplicateUser: DBXTeamGroupMembersAddError {
    @objc
    public init() {
        let swift = Team.GroupMembersAddError.duplicateUser
        super.init(swift: swift)
    }
}

/// Group is not in this team. You cannot add members to a group that is outside of your team.
@objc
public class DBXTeamGroupMembersAddErrorGroupNotInTeam: DBXTeamGroupMembersAddError {
    @objc
    public init() {
        let swift = Team.GroupMembersAddError.groupNotInTeam
        super.init(swift: swift)
    }
}

/// These members are not part of your team. Currently, you cannot add members to a group if they are not part
/// of your team, though this may change in a subsequent version. To add new members to your Dropbox
/// Business team, use the membersAdd endpoint.
@objc
public class DBXTeamGroupMembersAddErrorMembersNotInTeam: DBXTeamGroupMembersAddError {
    @objc
    public var membersNotInTeam: [String]

    @objc
    public init(_ arg: [String]) {
        self.membersNotInTeam = arg
        let swift = Team.GroupMembersAddError.membersNotInTeam(arg)
        super.init(swift: swift)
    }
}

/// These users were not found in Dropbox.
@objc
public class DBXTeamGroupMembersAddErrorUsersNotFound: DBXTeamGroupMembersAddError {
    @objc
    public var usersNotFound: [String]

    @objc
    public init(_ arg: [String]) {
        self.usersNotFound = arg
        let swift = Team.GroupMembersAddError.usersNotFound(arg)
        super.init(swift: swift)
    }
}

/// A suspended user cannot be added to a group as owner in GroupAccessType.
@objc
public class DBXTeamGroupMembersAddErrorUserMustBeActiveToBeOwner: DBXTeamGroupMembersAddError {
    @objc
    public init() {
        let swift = Team.GroupMembersAddError.userMustBeActiveToBeOwner
        super.init(swift: swift)
    }
}

/// A company-managed group cannot be managed by a user.
@objc
public class DBXTeamGroupMembersAddErrorUserCannotBeManagerOfCompanyManagedGroup: DBXTeamGroupMembersAddError {
    @objc
    public var userCannotBeManagerOfCompanyManagedGroup: [String]

    @objc
    public init(_ arg: [String]) {
        self.userCannotBeManagerOfCompanyManagedGroup = arg
        let swift = Team.GroupMembersAddError.userCannotBeManagerOfCompanyManagedGroup(arg)
        super.init(swift: swift)
    }
}

/// Result returned by groupsMembersAdd and groupsMembersRemove.
@objc
public class DBXTeamGroupMembersChangeResult: NSObject {
    /// The group info after member change operation has been performed.
    @objc
    public var groupInfo: DBXTeamGroupFullInfo { DBXTeamGroupFullInfo(swift: swift.groupInfo) }
    /// For legacy purposes async_job_id will always return one space ' '. Formerly, it was an ID that was used to
    /// obtain the status of granting/revoking group-owned resources. It's no longer necessary because the async
    /// processing now happens automatically.
    @objc
    public var asyncJobId: String { swift.asyncJobId }

    @objc
    public init(groupInfo: DBXTeamGroupFullInfo, asyncJobId: String) {
        self.swift = Team.GroupMembersChangeResult(groupInfo: groupInfo.subSwift, asyncJobId: asyncJobId)
    }

    let swift: Team.GroupMembersChangeResult

    public init(swift: Team.GroupMembersChangeResult) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible GroupMembersRemoveArg struct
@objc
public class DBXTeamGroupMembersRemoveArg: DBXTeamIncludeMembersArg {
    /// Group from which users will be removed.
    @objc
    public var group: DBXTeamGroupSelector { DBXTeamGroupSelector(swift: subSwift.group) }
    /// List of users to be removed from the group.
    @objc
    public var users: [DBXTeamUserSelectorArg] { subSwift.users.map { DBXTeamUserSelectorArg(swift: $0) } }

    @objc
    public init(group: DBXTeamGroupSelector, users: [DBXTeamUserSelectorArg], returnMembers: NSNumber) {
        let swift = Team.GroupMembersRemoveArg(group: group.swift, users: users.map(\.swift), returnMembers: returnMembers.boolValue)
        self.subSwift = swift
        super.init(swift: swift)
    }

    let subSwift: Team.GroupMembersRemoveArg

    public init(swift: Team.GroupMembersRemoveArg) {
        self.subSwift = swift
        super.init(swift: swift)
    }

    @objc
    public override var description: String { subSwift.description }
}

/// Error that can be raised when GroupMembersSelector is used, and the users are required to be members of the
/// specified group.
@objc
public class DBXTeamGroupMembersSelectorError: NSObject {
    let swift: Team.GroupMembersSelectorError

    public init(swift: Team.GroupMembersSelectorError) {
        self.swift = swift
    }

    public static func factory(swift: Team.GroupMembersSelectorError) -> DBXTeamGroupMembersSelectorError {
        switch swift {
        case .groupNotFound:
            return DBXTeamGroupMembersSelectorErrorGroupNotFound()
        case .other:
            return DBXTeamGroupMembersSelectorErrorOther()
        case .systemManagedGroupDisallowed:
            return DBXTeamGroupMembersSelectorErrorSystemManagedGroupDisallowed()
        case .memberNotInGroup:
            return DBXTeamGroupMembersSelectorErrorMemberNotInGroup()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asGroupNotFound: DBXTeamGroupMembersSelectorErrorGroupNotFound? {
        self as? DBXTeamGroupMembersSelectorErrorGroupNotFound
    }

    @objc
    public var asOther: DBXTeamGroupMembersSelectorErrorOther? {
        self as? DBXTeamGroupMembersSelectorErrorOther
    }

    @objc
    public var asSystemManagedGroupDisallowed: DBXTeamGroupMembersSelectorErrorSystemManagedGroupDisallowed? {
        self as? DBXTeamGroupMembersSelectorErrorSystemManagedGroupDisallowed
    }

    @objc
    public var asMemberNotInGroup: DBXTeamGroupMembersSelectorErrorMemberNotInGroup? {
        self as? DBXTeamGroupMembersSelectorErrorMemberNotInGroup
    }
}

/// No matching group found. No groups match the specified group ID.
@objc
public class DBXTeamGroupMembersSelectorErrorGroupNotFound: DBXTeamGroupMembersSelectorError {
    @objc
    public init() {
        let swift = Team.GroupMembersSelectorError.groupNotFound
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXTeamGroupMembersSelectorErrorOther: DBXTeamGroupMembersSelectorError {
    @objc
    public init() {
        let swift = Team.GroupMembersSelectorError.other
        super.init(swift: swift)
    }
}

/// This operation is not supported on system-managed groups.
@objc
public class DBXTeamGroupMembersSelectorErrorSystemManagedGroupDisallowed: DBXTeamGroupMembersSelectorError {
    @objc
    public init() {
        let swift = Team.GroupMembersSelectorError.systemManagedGroupDisallowed
        super.init(swift: swift)
    }
}

/// At least one of the specified users is not a member of the group.
@objc
public class DBXTeamGroupMembersSelectorErrorMemberNotInGroup: DBXTeamGroupMembersSelectorError {
    @objc
    public init() {
        let swift = Team.GroupMembersSelectorError.memberNotInGroup
        super.init(swift: swift)
    }
}

/// Objective-C compatible GroupMembersRemoveError union
@objc
public class DBXTeamGroupMembersRemoveError: NSObject {
    let swift: Team.GroupMembersRemoveError

    public init(swift: Team.GroupMembersRemoveError) {
        self.swift = swift
    }

    public static func factory(swift: Team.GroupMembersRemoveError) -> DBXTeamGroupMembersRemoveError {
        switch swift {
        case .groupNotFound:
            return DBXTeamGroupMembersRemoveErrorGroupNotFound()
        case .other:
            return DBXTeamGroupMembersRemoveErrorOther()
        case .systemManagedGroupDisallowed:
            return DBXTeamGroupMembersRemoveErrorSystemManagedGroupDisallowed()
        case .memberNotInGroup:
            return DBXTeamGroupMembersRemoveErrorMemberNotInGroup()
        case .groupNotInTeam:
            return DBXTeamGroupMembersRemoveErrorGroupNotInTeam()
        case .membersNotInTeam(let swiftArg):
            let arg = swiftArg
            return DBXTeamGroupMembersRemoveErrorMembersNotInTeam(arg)
        case .usersNotFound(let swiftArg):
            let arg = swiftArg
            return DBXTeamGroupMembersRemoveErrorUsersNotFound(arg)
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asGroupNotFound: DBXTeamGroupMembersRemoveErrorGroupNotFound? {
        self as? DBXTeamGroupMembersRemoveErrorGroupNotFound
    }

    @objc
    public var asOther: DBXTeamGroupMembersRemoveErrorOther? {
        self as? DBXTeamGroupMembersRemoveErrorOther
    }

    @objc
    public var asSystemManagedGroupDisallowed: DBXTeamGroupMembersRemoveErrorSystemManagedGroupDisallowed? {
        self as? DBXTeamGroupMembersRemoveErrorSystemManagedGroupDisallowed
    }

    @objc
    public var asMemberNotInGroup: DBXTeamGroupMembersRemoveErrorMemberNotInGroup? {
        self as? DBXTeamGroupMembersRemoveErrorMemberNotInGroup
    }

    @objc
    public var asGroupNotInTeam: DBXTeamGroupMembersRemoveErrorGroupNotInTeam? {
        self as? DBXTeamGroupMembersRemoveErrorGroupNotInTeam
    }

    @objc
    public var asMembersNotInTeam: DBXTeamGroupMembersRemoveErrorMembersNotInTeam? {
        self as? DBXTeamGroupMembersRemoveErrorMembersNotInTeam
    }

    @objc
    public var asUsersNotFound: DBXTeamGroupMembersRemoveErrorUsersNotFound? {
        self as? DBXTeamGroupMembersRemoveErrorUsersNotFound
    }
}

/// No matching group found. No groups match the specified group ID.
@objc
public class DBXTeamGroupMembersRemoveErrorGroupNotFound: DBXTeamGroupMembersRemoveError {
    @objc
    public init() {
        let swift = Team.GroupMembersRemoveError.groupNotFound
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXTeamGroupMembersRemoveErrorOther: DBXTeamGroupMembersRemoveError {
    @objc
    public init() {
        let swift = Team.GroupMembersRemoveError.other
        super.init(swift: swift)
    }
}

/// This operation is not supported on system-managed groups.
@objc
public class DBXTeamGroupMembersRemoveErrorSystemManagedGroupDisallowed: DBXTeamGroupMembersRemoveError {
    @objc
    public init() {
        let swift = Team.GroupMembersRemoveError.systemManagedGroupDisallowed
        super.init(swift: swift)
    }
}

/// At least one of the specified users is not a member of the group.
@objc
public class DBXTeamGroupMembersRemoveErrorMemberNotInGroup: DBXTeamGroupMembersRemoveError {
    @objc
    public init() {
        let swift = Team.GroupMembersRemoveError.memberNotInGroup
        super.init(swift: swift)
    }
}

/// Group is not in this team. You cannot remove members from a group that is outside of your team.
@objc
public class DBXTeamGroupMembersRemoveErrorGroupNotInTeam: DBXTeamGroupMembersRemoveError {
    @objc
    public init() {
        let swift = Team.GroupMembersRemoveError.groupNotInTeam
        super.init(swift: swift)
    }
}

/// These members are not part of your team.
@objc
public class DBXTeamGroupMembersRemoveErrorMembersNotInTeam: DBXTeamGroupMembersRemoveError {
    @objc
    public var membersNotInTeam: [String]

    @objc
    public init(_ arg: [String]) {
        self.membersNotInTeam = arg
        let swift = Team.GroupMembersRemoveError.membersNotInTeam(arg)
        super.init(swift: swift)
    }
}

/// These users were not found in Dropbox.
@objc
public class DBXTeamGroupMembersRemoveErrorUsersNotFound: DBXTeamGroupMembersRemoveError {
    @objc
    public var usersNotFound: [String]

    @objc
    public init(_ arg: [String]) {
        self.usersNotFound = arg
        let swift = Team.GroupMembersRemoveError.usersNotFound(arg)
        super.init(swift: swift)
    }
}

/// Argument for selecting a group and a list of users.
@objc
public class DBXTeamGroupMembersSelector: NSObject {
    /// Specify a group.
    @objc
    public var group: DBXTeamGroupSelector { DBXTeamGroupSelector(swift: swift.group) }
    /// A list of users that are members of group.
    @objc
    public var users: DBXTeamUsersSelectorArg { DBXTeamUsersSelectorArg(swift: swift.users) }

    @objc
    public init(group: DBXTeamGroupSelector, users: DBXTeamUsersSelectorArg) {
        self.swift = Team.GroupMembersSelector(group: group.swift, users: users.swift)
    }

    let swift: Team.GroupMembersSelector

    public init(swift: Team.GroupMembersSelector) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible GroupMembersSetAccessTypeArg struct
@objc
public class DBXTeamGroupMembersSetAccessTypeArg: DBXTeamGroupMemberSelector {
    /// New group access type the user will have.
    @objc
    public var accessType: DBXTeamGroupAccessType { DBXTeamGroupAccessType(swift: subSwift.accessType) }
    /// Whether to return the list of members in the group.  Note that the default value will cause all the group
    /// members  to be returned in the response. This may take a long time for large groups.
    @objc
    public var returnMembers: NSNumber { subSwift.returnMembers as NSNumber }

    @objc
    public init(group: DBXTeamGroupSelector, user: DBXTeamUserSelectorArg, accessType: DBXTeamGroupAccessType, returnMembers: NSNumber) {
        let swift = Team.GroupMembersSetAccessTypeArg(
            group: group.swift,
            user: user.swift,
            accessType: accessType.swift,
            returnMembers: returnMembers.boolValue
        )
        self.subSwift = swift
        super.init(swift: swift)
    }

    let subSwift: Team.GroupMembersSetAccessTypeArg

    public init(swift: Team.GroupMembersSetAccessTypeArg) {
        self.subSwift = swift
        super.init(swift: swift)
    }

    @objc
    public override var description: String { subSwift.description }
}

/// Argument for selecting a single group, either by group_id or by external group ID.
@objc
public class DBXTeamGroupSelector: NSObject {
    let swift: Team.GroupSelector

    public init(swift: Team.GroupSelector) {
        self.swift = swift
    }

    public static func factory(swift: Team.GroupSelector) -> DBXTeamGroupSelector {
        switch swift {
        case .groupId(let swiftArg):
            let arg = swiftArg
            return DBXTeamGroupSelectorGroupId(arg)
        case .groupExternalId(let swiftArg):
            let arg = swiftArg
            return DBXTeamGroupSelectorGroupExternalId(arg)
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asGroupId: DBXTeamGroupSelectorGroupId? {
        self as? DBXTeamGroupSelectorGroupId
    }

    @objc
    public var asGroupExternalId: DBXTeamGroupSelectorGroupExternalId? {
        self as? DBXTeamGroupSelectorGroupExternalId
    }
}

/// Group ID.
@objc
public class DBXTeamGroupSelectorGroupId: DBXTeamGroupSelector {
    @objc
    public var groupId: String

    @objc
    public init(_ arg: String) {
        self.groupId = arg
        let swift = Team.GroupSelector.groupId(arg)
        super.init(swift: swift)
    }
}

/// External ID of the group.
@objc
public class DBXTeamGroupSelectorGroupExternalId: DBXTeamGroupSelector {
    @objc
    public var groupExternalId: String

    @objc
    public init(_ arg: String) {
        self.groupExternalId = arg
        let swift = Team.GroupSelector.groupExternalId(arg)
        super.init(swift: swift)
    }
}

/// Objective-C compatible GroupUpdateArgs struct
@objc
public class DBXTeamGroupUpdateArgs: DBXTeamIncludeMembersArg {
    /// Specify a group.
    @objc
    public var group: DBXTeamGroupSelector { DBXTeamGroupSelector(swift: subSwift.group) }
    /// Optional argument. Set group name to this if provided.
    @objc
    public var newGroupName: String? { subSwift.newGroupName }
    /// Optional argument. New group external ID. If the argument is None, the group's external_id won't be updated.
    /// If the argument is empty string, the group's external id will be cleared.
    @objc
    public var newGroupExternalId: String? { subSwift.newGroupExternalId }
    /// Set new group management type, if provided.
    @objc
    public var newGroupManagementType: DBXTeamCommonGroupManagementType? { guard let swift = subSwift.newGroupManagementType else { return nil }
        return DBXTeamCommonGroupManagementType(swift: swift)
    }

    @objc
    public init(
        group: DBXTeamGroupSelector,
        returnMembers: NSNumber,
        newGroupName: String?,
        newGroupExternalId: String?,
        newGroupManagementType: DBXTeamCommonGroupManagementType?
    ) {
        let swift = Team.GroupUpdateArgs(
            group: group.swift,
            returnMembers: returnMembers.boolValue,
            newGroupName: newGroupName,
            newGroupExternalId: newGroupExternalId,
            newGroupManagementType: newGroupManagementType?.swift
        )
        self.subSwift = swift
        super.init(swift: swift)
    }

    let subSwift: Team.GroupUpdateArgs

    public init(swift: Team.GroupUpdateArgs) {
        self.subSwift = swift
        super.init(swift: swift)
    }

    @objc
    public override var description: String { subSwift.description }
}

/// Objective-C compatible GroupUpdateError union
@objc
public class DBXTeamGroupUpdateError: NSObject {
    let swift: Team.GroupUpdateError

    public init(swift: Team.GroupUpdateError) {
        self.swift = swift
    }

    public static func factory(swift: Team.GroupUpdateError) -> DBXTeamGroupUpdateError {
        switch swift {
        case .groupNotFound:
            return DBXTeamGroupUpdateErrorGroupNotFound()
        case .other:
            return DBXTeamGroupUpdateErrorOther()
        case .systemManagedGroupDisallowed:
            return DBXTeamGroupUpdateErrorSystemManagedGroupDisallowed()
        case .groupNameAlreadyUsed:
            return DBXTeamGroupUpdateErrorGroupNameAlreadyUsed()
        case .groupNameInvalid:
            return DBXTeamGroupUpdateErrorGroupNameInvalid()
        case .externalIdAlreadyInUse:
            return DBXTeamGroupUpdateErrorExternalIdAlreadyInUse()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asGroupNotFound: DBXTeamGroupUpdateErrorGroupNotFound? {
        self as? DBXTeamGroupUpdateErrorGroupNotFound
    }

    @objc
    public var asOther: DBXTeamGroupUpdateErrorOther? {
        self as? DBXTeamGroupUpdateErrorOther
    }

    @objc
    public var asSystemManagedGroupDisallowed: DBXTeamGroupUpdateErrorSystemManagedGroupDisallowed? {
        self as? DBXTeamGroupUpdateErrorSystemManagedGroupDisallowed
    }

    @objc
    public var asGroupNameAlreadyUsed: DBXTeamGroupUpdateErrorGroupNameAlreadyUsed? {
        self as? DBXTeamGroupUpdateErrorGroupNameAlreadyUsed
    }

    @objc
    public var asGroupNameInvalid: DBXTeamGroupUpdateErrorGroupNameInvalid? {
        self as? DBXTeamGroupUpdateErrorGroupNameInvalid
    }

    @objc
    public var asExternalIdAlreadyInUse: DBXTeamGroupUpdateErrorExternalIdAlreadyInUse? {
        self as? DBXTeamGroupUpdateErrorExternalIdAlreadyInUse
    }
}

/// No matching group found. No groups match the specified group ID.
@objc
public class DBXTeamGroupUpdateErrorGroupNotFound: DBXTeamGroupUpdateError {
    @objc
    public init() {
        let swift = Team.GroupUpdateError.groupNotFound
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXTeamGroupUpdateErrorOther: DBXTeamGroupUpdateError {
    @objc
    public init() {
        let swift = Team.GroupUpdateError.other
        super.init(swift: swift)
    }
}

/// This operation is not supported on system-managed groups.
@objc
public class DBXTeamGroupUpdateErrorSystemManagedGroupDisallowed: DBXTeamGroupUpdateError {
    @objc
    public init() {
        let swift = Team.GroupUpdateError.systemManagedGroupDisallowed
        super.init(swift: swift)
    }
}

/// The requested group name is already being used by another group.
@objc
public class DBXTeamGroupUpdateErrorGroupNameAlreadyUsed: DBXTeamGroupUpdateError {
    @objc
    public init() {
        let swift = Team.GroupUpdateError.groupNameAlreadyUsed
        super.init(swift: swift)
    }
}

/// Group name is empty or has invalid characters.
@objc
public class DBXTeamGroupUpdateErrorGroupNameInvalid: DBXTeamGroupUpdateError {
    @objc
    public init() {
        let swift = Team.GroupUpdateError.groupNameInvalid
        super.init(swift: swift)
    }
}

/// The requested external ID is already being used by another group.
@objc
public class DBXTeamGroupUpdateErrorExternalIdAlreadyInUse: DBXTeamGroupUpdateError {
    @objc
    public init() {
        let swift = Team.GroupUpdateError.externalIdAlreadyInUse
        super.init(swift: swift)
    }
}

/// Objective-C compatible GroupsGetInfoError union
@objc
public class DBXTeamGroupsGetInfoError: NSObject {
    let swift: Team.GroupsGetInfoError

    public init(swift: Team.GroupsGetInfoError) {
        self.swift = swift
    }

    public static func factory(swift: Team.GroupsGetInfoError) -> DBXTeamGroupsGetInfoError {
        switch swift {
        case .groupNotOnTeam:
            return DBXTeamGroupsGetInfoErrorGroupNotOnTeam()
        case .other:
            return DBXTeamGroupsGetInfoErrorOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asGroupNotOnTeam: DBXTeamGroupsGetInfoErrorGroupNotOnTeam? {
        self as? DBXTeamGroupsGetInfoErrorGroupNotOnTeam
    }

    @objc
    public var asOther: DBXTeamGroupsGetInfoErrorOther? {
        self as? DBXTeamGroupsGetInfoErrorOther
    }
}

/// The group is not on your team.
@objc
public class DBXTeamGroupsGetInfoErrorGroupNotOnTeam: DBXTeamGroupsGetInfoError {
    @objc
    public init() {
        let swift = Team.GroupsGetInfoError.groupNotOnTeam
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXTeamGroupsGetInfoErrorOther: DBXTeamGroupsGetInfoError {
    @objc
    public init() {
        let swift = Team.GroupsGetInfoError.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible GroupsGetInfoItem union
@objc
public class DBXTeamGroupsGetInfoItem: NSObject {
    let swift: Team.GroupsGetInfoItem

    public init(swift: Team.GroupsGetInfoItem) {
        self.swift = swift
    }

    public static func factory(swift: Team.GroupsGetInfoItem) -> DBXTeamGroupsGetInfoItem {
        switch swift {
        case .idNotFound(let swiftArg):
            let arg = swiftArg
            return DBXTeamGroupsGetInfoItemIdNotFound(arg)
        case .groupInfo(let swiftArg):
            let arg = DBXTeamGroupFullInfo(swift: swiftArg)
            return DBXTeamGroupsGetInfoItemGroupInfo(arg)
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asIdNotFound: DBXTeamGroupsGetInfoItemIdNotFound? {
        self as? DBXTeamGroupsGetInfoItemIdNotFound
    }

    @objc
    public var asGroupInfo: DBXTeamGroupsGetInfoItemGroupInfo? {
        self as? DBXTeamGroupsGetInfoItemGroupInfo
    }
}

/// An ID that was provided as a parameter to groupsGetInfo, and did not match a corresponding group. The ID can
/// be a group ID, or an external ID, depending on how the method was called.
@objc
public class DBXTeamGroupsGetInfoItemIdNotFound: DBXTeamGroupsGetInfoItem {
    @objc
    public var idNotFound: String

    @objc
    public init(_ arg: String) {
        self.idNotFound = arg
        let swift = Team.GroupsGetInfoItem.idNotFound(arg)
        super.init(swift: swift)
    }
}

/// Info about a group.
@objc
public class DBXTeamGroupsGetInfoItemGroupInfo: DBXTeamGroupsGetInfoItem {
    @objc
    public var groupInfo: DBXTeamGroupFullInfo

    @objc
    public init(_ arg: DBXTeamGroupFullInfo) {
        self.groupInfo = arg
        let swift = Team.GroupsGetInfoItem.groupInfo(arg.subSwift)
        super.init(swift: swift)
    }
}

/// Objective-C compatible GroupsListArg struct
@objc
public class DBXTeamGroupsListArg: NSObject {
    /// Number of results to return per call.
    @objc
    public var limit: NSNumber { swift.limit as NSNumber }

    @objc
    public init(limit: NSNumber) {
        self.swift = Team.GroupsListArg(limit: limit.uint32Value)
    }

    let swift: Team.GroupsListArg

    public init(swift: Team.GroupsListArg) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible GroupsListContinueArg struct
@objc
public class DBXTeamGroupsListContinueArg: NSObject {
    /// Indicates from what point to get the next set of groups.
    @objc
    public var cursor: String { swift.cursor }

    @objc
    public init(cursor: String) {
        self.swift = Team.GroupsListContinueArg(cursor: cursor)
    }

    let swift: Team.GroupsListContinueArg

    public init(swift: Team.GroupsListContinueArg) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible GroupsListContinueError union
@objc
public class DBXTeamGroupsListContinueError: NSObject {
    let swift: Team.GroupsListContinueError

    public init(swift: Team.GroupsListContinueError) {
        self.swift = swift
    }

    public static func factory(swift: Team.GroupsListContinueError) -> DBXTeamGroupsListContinueError {
        switch swift {
        case .invalidCursor:
            return DBXTeamGroupsListContinueErrorInvalidCursor()
        case .other:
            return DBXTeamGroupsListContinueErrorOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asInvalidCursor: DBXTeamGroupsListContinueErrorInvalidCursor? {
        self as? DBXTeamGroupsListContinueErrorInvalidCursor
    }

    @objc
    public var asOther: DBXTeamGroupsListContinueErrorOther? {
        self as? DBXTeamGroupsListContinueErrorOther
    }
}

/// The cursor is invalid.
@objc
public class DBXTeamGroupsListContinueErrorInvalidCursor: DBXTeamGroupsListContinueError {
    @objc
    public init() {
        let swift = Team.GroupsListContinueError.invalidCursor
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXTeamGroupsListContinueErrorOther: DBXTeamGroupsListContinueError {
    @objc
    public init() {
        let swift = Team.GroupsListContinueError.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible GroupsListResult struct
@objc
public class DBXTeamGroupsListResult: NSObject {
    /// (no description)
    @objc
    public var groups: [DBXTeamCommonGroupSummary] { swift.groups.map { DBXTeamCommonGroupSummary(swift: $0) } }
    /// Pass the cursor into groupsListContinue to obtain the additional groups.
    @objc
    public var cursor: String { swift.cursor }
    /// Is true if there are additional groups that have not been returned yet. An additional call to
    /// groupsListContinue can retrieve them.
    @objc
    public var hasMore: NSNumber { swift.hasMore as NSNumber }

    @objc
    public init(groups: [DBXTeamCommonGroupSummary], cursor: String, hasMore: NSNumber) {
        self.swift = Team.GroupsListResult(groups: groups.map(\.swift), cursor: cursor, hasMore: hasMore.boolValue)
    }

    let swift: Team.GroupsListResult

    public init(swift: Team.GroupsListResult) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible GroupsMembersListArg struct
@objc
public class DBXTeamGroupsMembersListArg: NSObject {
    /// The group whose members are to be listed.
    @objc
    public var group: DBXTeamGroupSelector { DBXTeamGroupSelector(swift: swift.group) }
    /// Number of results to return per call.
    @objc
    public var limit: NSNumber { swift.limit as NSNumber }

    @objc
    public init(group: DBXTeamGroupSelector, limit: NSNumber) {
        self.swift = Team.GroupsMembersListArg(group: group.swift, limit: limit.uint32Value)
    }

    let swift: Team.GroupsMembersListArg

    public init(swift: Team.GroupsMembersListArg) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible GroupsMembersListContinueArg struct
@objc
public class DBXTeamGroupsMembersListContinueArg: NSObject {
    /// Indicates from what point to get the next set of groups.
    @objc
    public var cursor: String { swift.cursor }

    @objc
    public init(cursor: String) {
        self.swift = Team.GroupsMembersListContinueArg(cursor: cursor)
    }

    let swift: Team.GroupsMembersListContinueArg

    public init(swift: Team.GroupsMembersListContinueArg) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible GroupsMembersListContinueError union
@objc
public class DBXTeamGroupsMembersListContinueError: NSObject {
    let swift: Team.GroupsMembersListContinueError

    public init(swift: Team.GroupsMembersListContinueError) {
        self.swift = swift
    }

    public static func factory(swift: Team.GroupsMembersListContinueError) -> DBXTeamGroupsMembersListContinueError {
        switch swift {
        case .invalidCursor:
            return DBXTeamGroupsMembersListContinueErrorInvalidCursor()
        case .other:
            return DBXTeamGroupsMembersListContinueErrorOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asInvalidCursor: DBXTeamGroupsMembersListContinueErrorInvalidCursor? {
        self as? DBXTeamGroupsMembersListContinueErrorInvalidCursor
    }

    @objc
    public var asOther: DBXTeamGroupsMembersListContinueErrorOther? {
        self as? DBXTeamGroupsMembersListContinueErrorOther
    }
}

/// The cursor is invalid.
@objc
public class DBXTeamGroupsMembersListContinueErrorInvalidCursor: DBXTeamGroupsMembersListContinueError {
    @objc
    public init() {
        let swift = Team.GroupsMembersListContinueError.invalidCursor
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXTeamGroupsMembersListContinueErrorOther: DBXTeamGroupsMembersListContinueError {
    @objc
    public init() {
        let swift = Team.GroupsMembersListContinueError.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible GroupsMembersListResult struct
@objc
public class DBXTeamGroupsMembersListResult: NSObject {
    /// (no description)
    @objc
    public var members: [DBXTeamGroupMemberInfo] { swift.members.map { DBXTeamGroupMemberInfo(swift: $0) } }
    /// Pass the cursor into groupsMembersListContinue to obtain additional group members.
    @objc
    public var cursor: String { swift.cursor }
    /// Is true if there are additional group members that have not been returned yet. An additional call to
    /// groupsMembersListContinue can retrieve them.
    @objc
    public var hasMore: NSNumber { swift.hasMore as NSNumber }

    @objc
    public init(members: [DBXTeamGroupMemberInfo], cursor: String, hasMore: NSNumber) {
        self.swift = Team.GroupsMembersListResult(members: members.map(\.swift), cursor: cursor, hasMore: hasMore.boolValue)
    }

    let swift: Team.GroupsMembersListResult

    public init(swift: Team.GroupsMembersListResult) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible GroupsPollError union
@objc
public class DBXTeamGroupsPollError: NSObject {
    let swift: Team.GroupsPollError

    public init(swift: Team.GroupsPollError) {
        self.swift = swift
    }

    public static func factory(swift: Team.GroupsPollError) -> DBXTeamGroupsPollError {
        switch swift {
        case .invalidAsyncJobId:
            return DBXTeamGroupsPollErrorInvalidAsyncJobId()
        case .internalError:
            return DBXTeamGroupsPollErrorInternalError()
        case .other:
            return DBXTeamGroupsPollErrorOther()
        case .accessDenied:
            return DBXTeamGroupsPollErrorAccessDenied()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asInvalidAsyncJobId: DBXTeamGroupsPollErrorInvalidAsyncJobId? {
        self as? DBXTeamGroupsPollErrorInvalidAsyncJobId
    }

    @objc
    public var asInternalError: DBXTeamGroupsPollErrorInternalError? {
        self as? DBXTeamGroupsPollErrorInternalError
    }

    @objc
    public var asOther: DBXTeamGroupsPollErrorOther? {
        self as? DBXTeamGroupsPollErrorOther
    }

    @objc
    public var asAccessDenied: DBXTeamGroupsPollErrorAccessDenied? {
        self as? DBXTeamGroupsPollErrorAccessDenied
    }
}

/// The job ID is invalid.
@objc
public class DBXTeamGroupsPollErrorInvalidAsyncJobId: DBXTeamGroupsPollError {
    @objc
    public init() {
        let swift = Team.GroupsPollError.invalidAsyncJobId
        super.init(swift: swift)
    }
}

/// Something went wrong with the job on Dropbox's end. You'll need to verify that the action you were taking
/// succeeded, and if not, try again. This should happen very rarely.
@objc
public class DBXTeamGroupsPollErrorInternalError: DBXTeamGroupsPollError {
    @objc
    public init() {
        let swift = Team.GroupsPollError.internalError
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXTeamGroupsPollErrorOther: DBXTeamGroupsPollError {
    @objc
    public init() {
        let swift = Team.GroupsPollError.other
        super.init(swift: swift)
    }
}

/// You are not allowed to poll this job.
@objc
public class DBXTeamGroupsPollErrorAccessDenied: DBXTeamGroupsPollError {
    @objc
    public init() {
        let swift = Team.GroupsPollError.accessDenied
        super.init(swift: swift)
    }
}

/// Argument for selecting a list of groups, either by group_ids, or external group IDs.
@objc
public class DBXTeamGroupsSelector: NSObject {
    let swift: Team.GroupsSelector

    public init(swift: Team.GroupsSelector) {
        self.swift = swift
    }

    public static func factory(swift: Team.GroupsSelector) -> DBXTeamGroupsSelector {
        switch swift {
        case .groupIds(let swiftArg):
            let arg = swiftArg
            return DBXTeamGroupsSelectorGroupIds(arg)
        case .groupExternalIds(let swiftArg):
            let arg = swiftArg
            return DBXTeamGroupsSelectorGroupExternalIds(arg)
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asGroupIds: DBXTeamGroupsSelectorGroupIds? {
        self as? DBXTeamGroupsSelectorGroupIds
    }

    @objc
    public var asGroupExternalIds: DBXTeamGroupsSelectorGroupExternalIds? {
        self as? DBXTeamGroupsSelectorGroupExternalIds
    }
}

/// List of group IDs.
@objc
public class DBXTeamGroupsSelectorGroupIds: DBXTeamGroupsSelector {
    @objc
    public var groupIds: [String]

    @objc
    public init(_ arg: [String]) {
        self.groupIds = arg
        let swift = Team.GroupsSelector.groupIds(arg)
        super.init(swift: swift)
    }
}

/// List of external IDs of groups.
@objc
public class DBXTeamGroupsSelectorGroupExternalIds: DBXTeamGroupsSelector {
    @objc
    public var groupExternalIds: [String]

    @objc
    public init(_ arg: [String]) {
        self.groupExternalIds = arg
        let swift = Team.GroupsSelector.groupExternalIds(arg)
        super.init(swift: swift)
    }
}

/// The value for hasTeamFileEvents in Feature.
@objc
public class DBXTeamHasTeamFileEventsValue: NSObject {
    let swift: Team.HasTeamFileEventsValue

    public init(swift: Team.HasTeamFileEventsValue) {
        self.swift = swift
    }

    public static func factory(swift: Team.HasTeamFileEventsValue) -> DBXTeamHasTeamFileEventsValue {
        switch swift {
        case .enabled(let swiftArg):
            let arg = NSNumber(value: swiftArg)
            return DBXTeamHasTeamFileEventsValueEnabled(arg)
        case .other:
            return DBXTeamHasTeamFileEventsValueOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asEnabled: DBXTeamHasTeamFileEventsValueEnabled? {
        self as? DBXTeamHasTeamFileEventsValueEnabled
    }

    @objc
    public var asOther: DBXTeamHasTeamFileEventsValueOther? {
        self as? DBXTeamHasTeamFileEventsValueOther
    }
}

/// Does this team have file events.
@objc
public class DBXTeamHasTeamFileEventsValueEnabled: DBXTeamHasTeamFileEventsValue {
    @objc
    public var enabled: NSNumber

    @objc
    public init(_ arg: NSNumber) {
        self.enabled = arg
        let swift = Team.HasTeamFileEventsValue.enabled(arg.boolValue)
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXTeamHasTeamFileEventsValueOther: DBXTeamHasTeamFileEventsValue {
    @objc
    public init() {
        let swift = Team.HasTeamFileEventsValue.other
        super.init(swift: swift)
    }
}

/// The value for hasTeamSelectiveSync in Feature.
@objc
public class DBXTeamHasTeamSelectiveSyncValue: NSObject {
    let swift: Team.HasTeamSelectiveSyncValue

    public init(swift: Team.HasTeamSelectiveSyncValue) {
        self.swift = swift
    }

    public static func factory(swift: Team.HasTeamSelectiveSyncValue) -> DBXTeamHasTeamSelectiveSyncValue {
        switch swift {
        case .hasTeamSelectiveSync(let swiftArg):
            let arg = NSNumber(value: swiftArg)
            return DBXTeamHasTeamSelectiveSyncValueHasTeamSelectiveSync(arg)
        case .other:
            return DBXTeamHasTeamSelectiveSyncValueOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asHasTeamSelectiveSync: DBXTeamHasTeamSelectiveSyncValueHasTeamSelectiveSync? {
        self as? DBXTeamHasTeamSelectiveSyncValueHasTeamSelectiveSync
    }

    @objc
    public var asOther: DBXTeamHasTeamSelectiveSyncValueOther? {
        self as? DBXTeamHasTeamSelectiveSyncValueOther
    }
}

/// Does this team have team selective sync enabled.
@objc
public class DBXTeamHasTeamSelectiveSyncValueHasTeamSelectiveSync: DBXTeamHasTeamSelectiveSyncValue {
    @objc
    public var hasTeamSelectiveSync: NSNumber

    @objc
    public init(_ arg: NSNumber) {
        self.hasTeamSelectiveSync = arg
        let swift = Team.HasTeamSelectiveSyncValue.hasTeamSelectiveSync(arg.boolValue)
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXTeamHasTeamSelectiveSyncValueOther: DBXTeamHasTeamSelectiveSyncValue {
    @objc
    public init() {
        let swift = Team.HasTeamSelectiveSyncValue.other
        super.init(swift: swift)
    }
}

/// The value for hasTeamSharedDropbox in Feature.
@objc
public class DBXTeamHasTeamSharedDropboxValue: NSObject {
    let swift: Team.HasTeamSharedDropboxValue

    public init(swift: Team.HasTeamSharedDropboxValue) {
        self.swift = swift
    }

    public static func factory(swift: Team.HasTeamSharedDropboxValue) -> DBXTeamHasTeamSharedDropboxValue {
        switch swift {
        case .hasTeamSharedDropbox(let swiftArg):
            let arg = NSNumber(value: swiftArg)
            return DBXTeamHasTeamSharedDropboxValueHasTeamSharedDropbox(arg)
        case .other:
            return DBXTeamHasTeamSharedDropboxValueOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asHasTeamSharedDropbox: DBXTeamHasTeamSharedDropboxValueHasTeamSharedDropbox? {
        self as? DBXTeamHasTeamSharedDropboxValueHasTeamSharedDropbox
    }

    @objc
    public var asOther: DBXTeamHasTeamSharedDropboxValueOther? {
        self as? DBXTeamHasTeamSharedDropboxValueOther
    }
}

/// Does this team have a shared team root.
@objc
public class DBXTeamHasTeamSharedDropboxValueHasTeamSharedDropbox: DBXTeamHasTeamSharedDropboxValue {
    @objc
    public var hasTeamSharedDropbox: NSNumber

    @objc
    public init(_ arg: NSNumber) {
        self.hasTeamSharedDropbox = arg
        let swift = Team.HasTeamSharedDropboxValue.hasTeamSharedDropbox(arg.boolValue)
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXTeamHasTeamSharedDropboxValueOther: DBXTeamHasTeamSharedDropboxValue {
    @objc
    public init() {
        let swift = Team.HasTeamSharedDropboxValue.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible LegalHoldHeldRevisionMetadata struct
@objc
public class DBXTeamLegalHoldHeldRevisionMetadata: NSObject {
    /// The held revision filename.
    @objc
    public var newFilename: String { swift.newFilename }
    /// The id of the held revision.
    @objc
    public var originalRevisionId: String { swift.originalRevisionId }
    /// The original path of the held revision.
    @objc
    public var originalFilePath: String { swift.originalFilePath }
    /// The last time the file was modified on Dropbox.
    @objc
    public var serverModified: Date { swift.serverModified }
    /// The member id of the revision's author.
    @objc
    public var authorMemberId: String { swift.authorMemberId }
    /// The member status of the revision's author.
    @objc
    public var authorMemberStatus: DBXTeamTeamMemberStatus { DBXTeamTeamMemberStatus(swift: swift.authorMemberStatus) }
    /// The email address of the held revision author.
    @objc
    public var authorEmail: String { swift.authorEmail }
    /// The type of the held revision's file.
    @objc
    public var fileType: String { swift.fileType }
    /// The file size in bytes.
    @objc
    public var size: NSNumber { swift.size as NSNumber }
    /// A hash of the file content. This field can be used to verify data integrity. For more information see our
    /// Content hash https://www.dropbox.com/developers/reference/content-hash page.
    @objc
    public var contentHash: String { swift.contentHash }

    @objc
    public init(
        newFilename: String,
        originalRevisionId: String,
        originalFilePath: String,
        serverModified: Date,
        authorMemberId: String,
        authorMemberStatus: DBXTeamTeamMemberStatus,
        authorEmail: String,
        fileType: String,
        size: NSNumber,
        contentHash: String
    ) {
        self.swift = Team.LegalHoldHeldRevisionMetadata(
            newFilename: newFilename,
            originalRevisionId: originalRevisionId,
            originalFilePath: originalFilePath,
            serverModified: serverModified,
            authorMemberId: authorMemberId,
            authorMemberStatus: authorMemberStatus.swift,
            authorEmail: authorEmail,
            fileType: fileType,
            size: size.uint64Value,
            contentHash: contentHash
        )
    }

    let swift: Team.LegalHoldHeldRevisionMetadata

    public init(swift: Team.LegalHoldHeldRevisionMetadata) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible LegalHoldPolicy struct
@objc
public class DBXTeamLegalHoldPolicy: NSObject {
    /// The legal hold id.
    @objc
    public var id: String { swift.id }
    /// Policy name.
    @objc
    public var name: String { swift.name }
    /// A description of the legal hold policy.
    @objc
    public var description_: String? { swift.description_ }
    /// The time at which the legal hold was activated.
    @objc
    public var activationTime: Date? { swift.activationTime }
    /// Team members IDs and number of permanently deleted members under hold.
    @objc
    public var members: DBXTeamMembersInfo { DBXTeamMembersInfo(swift: swift.members) }
    /// The current state of the hold.
    @objc
    public var status: DBXTeamLegalHoldStatus { DBXTeamLegalHoldStatus(swift: swift.status) }
    /// Start date of the legal hold policy.
    @objc
    public var startDate: Date { swift.startDate }
    /// End date of the legal hold policy.
    @objc
    public var endDate: Date? { swift.endDate }

    @objc
    public init(
        id: String,
        name: String,
        members: DBXTeamMembersInfo,
        status: DBXTeamLegalHoldStatus,
        startDate: Date,
        description_: String?,
        activationTime: Date?,
        endDate: Date?
    ) {
        self.swift = Team.LegalHoldPolicy(
            id: id,
            name: name,
            members: members.swift,
            status: status.swift,
            startDate: startDate,
            description_: description_,
            activationTime: activationTime,
            endDate: endDate
        )
    }

    let swift: Team.LegalHoldPolicy

    public init(swift: Team.LegalHoldPolicy) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible LegalHoldStatus union
@objc
public class DBXTeamLegalHoldStatus: NSObject {
    let swift: Team.LegalHoldStatus

    public init(swift: Team.LegalHoldStatus) {
        self.swift = swift
    }

    public static func factory(swift: Team.LegalHoldStatus) -> DBXTeamLegalHoldStatus {
        switch swift {
        case .active:
            return DBXTeamLegalHoldStatusActive()
        case .released:
            return DBXTeamLegalHoldStatusReleased()
        case .activating:
            return DBXTeamLegalHoldStatusActivating()
        case .updating:
            return DBXTeamLegalHoldStatusUpdating()
        case .exporting:
            return DBXTeamLegalHoldStatusExporting()
        case .releasing:
            return DBXTeamLegalHoldStatusReleasing()
        case .other:
            return DBXTeamLegalHoldStatusOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asActive: DBXTeamLegalHoldStatusActive? {
        self as? DBXTeamLegalHoldStatusActive
    }

    @objc
    public var asReleased: DBXTeamLegalHoldStatusReleased? {
        self as? DBXTeamLegalHoldStatusReleased
    }

    @objc
    public var asActivating: DBXTeamLegalHoldStatusActivating? {
        self as? DBXTeamLegalHoldStatusActivating
    }

    @objc
    public var asUpdating: DBXTeamLegalHoldStatusUpdating? {
        self as? DBXTeamLegalHoldStatusUpdating
    }

    @objc
    public var asExporting: DBXTeamLegalHoldStatusExporting? {
        self as? DBXTeamLegalHoldStatusExporting
    }

    @objc
    public var asReleasing: DBXTeamLegalHoldStatusReleasing? {
        self as? DBXTeamLegalHoldStatusReleasing
    }

    @objc
    public var asOther: DBXTeamLegalHoldStatusOther? {
        self as? DBXTeamLegalHoldStatusOther
    }
}

/// The legal hold policy is active.
@objc
public class DBXTeamLegalHoldStatusActive: DBXTeamLegalHoldStatus {
    @objc
    public init() {
        let swift = Team.LegalHoldStatus.active
        super.init(swift: swift)
    }
}

/// The legal hold policy was released.
@objc
public class DBXTeamLegalHoldStatusReleased: DBXTeamLegalHoldStatus {
    @objc
    public init() {
        let swift = Team.LegalHoldStatus.released
        super.init(swift: swift)
    }
}

/// The legal hold policy is activating.
@objc
public class DBXTeamLegalHoldStatusActivating: DBXTeamLegalHoldStatus {
    @objc
    public init() {
        let swift = Team.LegalHoldStatus.activating
        super.init(swift: swift)
    }
}

/// The legal hold policy is updating.
@objc
public class DBXTeamLegalHoldStatusUpdating: DBXTeamLegalHoldStatus {
    @objc
    public init() {
        let swift = Team.LegalHoldStatus.updating
        super.init(swift: swift)
    }
}

/// The legal hold policy is exporting.
@objc
public class DBXTeamLegalHoldStatusExporting: DBXTeamLegalHoldStatus {
    @objc
    public init() {
        let swift = Team.LegalHoldStatus.exporting
        super.init(swift: swift)
    }
}

/// The legal hold policy is releasing.
@objc
public class DBXTeamLegalHoldStatusReleasing: DBXTeamLegalHoldStatus {
    @objc
    public init() {
        let swift = Team.LegalHoldStatus.releasing
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXTeamLegalHoldStatusOther: DBXTeamLegalHoldStatus {
    @objc
    public init() {
        let swift = Team.LegalHoldStatus.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible LegalHoldsError union
@objc
public class DBXTeamLegalHoldsError: NSObject {
    let swift: Team.LegalHoldsError

    public init(swift: Team.LegalHoldsError) {
        self.swift = swift
    }

    public static func factory(swift: Team.LegalHoldsError) -> DBXTeamLegalHoldsError {
        switch swift {
        case .unknownLegalHoldError:
            return DBXTeamLegalHoldsErrorUnknownLegalHoldError()
        case .insufficientPermissions:
            return DBXTeamLegalHoldsErrorInsufficientPermissions()
        case .other:
            return DBXTeamLegalHoldsErrorOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asUnknownLegalHoldError: DBXTeamLegalHoldsErrorUnknownLegalHoldError? {
        self as? DBXTeamLegalHoldsErrorUnknownLegalHoldError
    }

    @objc
    public var asInsufficientPermissions: DBXTeamLegalHoldsErrorInsufficientPermissions? {
        self as? DBXTeamLegalHoldsErrorInsufficientPermissions
    }

    @objc
    public var asOther: DBXTeamLegalHoldsErrorOther? {
        self as? DBXTeamLegalHoldsErrorOther
    }
}

/// There has been an unknown legal hold error.
@objc
public class DBXTeamLegalHoldsErrorUnknownLegalHoldError: DBXTeamLegalHoldsError {
    @objc
    public init() {
        let swift = Team.LegalHoldsError.unknownLegalHoldError
        super.init(swift: swift)
    }
}

/// You don't have permissions to perform this action.
@objc
public class DBXTeamLegalHoldsErrorInsufficientPermissions: DBXTeamLegalHoldsError {
    @objc
    public init() {
        let swift = Team.LegalHoldsError.insufficientPermissions
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXTeamLegalHoldsErrorOther: DBXTeamLegalHoldsError {
    @objc
    public init() {
        let swift = Team.LegalHoldsError.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible LegalHoldsGetPolicyArg struct
@objc
public class DBXTeamLegalHoldsGetPolicyArg: NSObject {
    /// The legal hold Id.
    @objc
    public var id: String { swift.id }

    @objc
    public init(id: String) {
        self.swift = Team.LegalHoldsGetPolicyArg(id: id)
    }

    let swift: Team.LegalHoldsGetPolicyArg

    public init(swift: Team.LegalHoldsGetPolicyArg) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible LegalHoldsGetPolicyError union
@objc
public class DBXTeamLegalHoldsGetPolicyError: NSObject {
    let swift: Team.LegalHoldsGetPolicyError

    public init(swift: Team.LegalHoldsGetPolicyError) {
        self.swift = swift
    }

    public static func factory(swift: Team.LegalHoldsGetPolicyError) -> DBXTeamLegalHoldsGetPolicyError {
        switch swift {
        case .unknownLegalHoldError:
            return DBXTeamLegalHoldsGetPolicyErrorUnknownLegalHoldError()
        case .insufficientPermissions:
            return DBXTeamLegalHoldsGetPolicyErrorInsufficientPermissions()
        case .other:
            return DBXTeamLegalHoldsGetPolicyErrorOther()
        case .legalHoldPolicyNotFound:
            return DBXTeamLegalHoldsGetPolicyErrorLegalHoldPolicyNotFound()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asUnknownLegalHoldError: DBXTeamLegalHoldsGetPolicyErrorUnknownLegalHoldError? {
        self as? DBXTeamLegalHoldsGetPolicyErrorUnknownLegalHoldError
    }

    @objc
    public var asInsufficientPermissions: DBXTeamLegalHoldsGetPolicyErrorInsufficientPermissions? {
        self as? DBXTeamLegalHoldsGetPolicyErrorInsufficientPermissions
    }

    @objc
    public var asOther: DBXTeamLegalHoldsGetPolicyErrorOther? {
        self as? DBXTeamLegalHoldsGetPolicyErrorOther
    }

    @objc
    public var asLegalHoldPolicyNotFound: DBXTeamLegalHoldsGetPolicyErrorLegalHoldPolicyNotFound? {
        self as? DBXTeamLegalHoldsGetPolicyErrorLegalHoldPolicyNotFound
    }
}

/// There has been an unknown legal hold error.
@objc
public class DBXTeamLegalHoldsGetPolicyErrorUnknownLegalHoldError: DBXTeamLegalHoldsGetPolicyError {
    @objc
    public init() {
        let swift = Team.LegalHoldsGetPolicyError.unknownLegalHoldError
        super.init(swift: swift)
    }
}

/// You don't have permissions to perform this action.
@objc
public class DBXTeamLegalHoldsGetPolicyErrorInsufficientPermissions: DBXTeamLegalHoldsGetPolicyError {
    @objc
    public init() {
        let swift = Team.LegalHoldsGetPolicyError.insufficientPermissions
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXTeamLegalHoldsGetPolicyErrorOther: DBXTeamLegalHoldsGetPolicyError {
    @objc
    public init() {
        let swift = Team.LegalHoldsGetPolicyError.other
        super.init(swift: swift)
    }
}

/// Legal hold policy does not exist for id in LegalHoldsGetPolicyArg.
@objc
public class DBXTeamLegalHoldsGetPolicyErrorLegalHoldPolicyNotFound: DBXTeamLegalHoldsGetPolicyError {
    @objc
    public init() {
        let swift = Team.LegalHoldsGetPolicyError.legalHoldPolicyNotFound
        super.init(swift: swift)
    }
}

/// Objective-C compatible LegalHoldsListHeldRevisionResult struct
@objc
public class DBXTeamLegalHoldsListHeldRevisionResult: NSObject {
    /// List of file entries that under the hold.
    @objc
    public var entries: [DBXTeamLegalHoldHeldRevisionMetadata] { swift.entries.map { DBXTeamLegalHoldHeldRevisionMetadata(swift: $0) } }
    /// The cursor idicates where to continue reading file metadata entries for the next API call. When there are no
    /// more entries, the cursor will return none. Pass the cursor into
    /// /2/team/legal_holds/list_held_revisions/continue.
    @objc
    public var cursor: String? { swift.cursor }
    /// True if there are more file entries that haven't been returned. You can retrieve them with a call to
    /// /legal_holds/list_held_revisions_continue.
    @objc
    public var hasMore: NSNumber { swift.hasMore as NSNumber }

    @objc
    public init(entries: [DBXTeamLegalHoldHeldRevisionMetadata], hasMore: NSNumber, cursor: String?) {
        self.swift = Team.LegalHoldsListHeldRevisionResult(entries: entries.map(\.swift), hasMore: hasMore.boolValue, cursor: cursor)
    }

    let swift: Team.LegalHoldsListHeldRevisionResult

    public init(swift: Team.LegalHoldsListHeldRevisionResult) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible LegalHoldsListHeldRevisionsArg struct
@objc
public class DBXTeamLegalHoldsListHeldRevisionsArg: NSObject {
    /// The legal hold Id.
    @objc
    public var id: String { swift.id }

    @objc
    public init(id: String) {
        self.swift = Team.LegalHoldsListHeldRevisionsArg(id: id)
    }

    let swift: Team.LegalHoldsListHeldRevisionsArg

    public init(swift: Team.LegalHoldsListHeldRevisionsArg) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible LegalHoldsListHeldRevisionsContinueArg struct
@objc
public class DBXTeamLegalHoldsListHeldRevisionsContinueArg: NSObject {
    /// The legal hold Id.
    @objc
    public var id: String { swift.id }
    /// The cursor idicates where to continue reading file metadata entries for the next API call. When there are no
    /// more entries, the cursor will return none.
    @objc
    public var cursor: String? { swift.cursor }

    @objc
    public init(id: String, cursor: String?) {
        self.swift = Team.LegalHoldsListHeldRevisionsContinueArg(id: id, cursor: cursor)
    }

    let swift: Team.LegalHoldsListHeldRevisionsContinueArg

    public init(swift: Team.LegalHoldsListHeldRevisionsContinueArg) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible LegalHoldsListHeldRevisionsContinueError union
@objc
public class DBXTeamLegalHoldsListHeldRevisionsContinueError: NSObject {
    let swift: Team.LegalHoldsListHeldRevisionsContinueError

    public init(swift: Team.LegalHoldsListHeldRevisionsContinueError) {
        self.swift = swift
    }

    public static func factory(swift: Team.LegalHoldsListHeldRevisionsContinueError) -> DBXTeamLegalHoldsListHeldRevisionsContinueError {
        switch swift {
        case .unknownLegalHoldError:
            return DBXTeamLegalHoldsListHeldRevisionsContinueErrorUnknownLegalHoldError()
        case .transientError:
            return DBXTeamLegalHoldsListHeldRevisionsContinueErrorTransientError()
        case .reset:
            return DBXTeamLegalHoldsListHeldRevisionsContinueErrorReset()
        case .other:
            return DBXTeamLegalHoldsListHeldRevisionsContinueErrorOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asUnknownLegalHoldError: DBXTeamLegalHoldsListHeldRevisionsContinueErrorUnknownLegalHoldError? {
        self as? DBXTeamLegalHoldsListHeldRevisionsContinueErrorUnknownLegalHoldError
    }

    @objc
    public var asTransientError: DBXTeamLegalHoldsListHeldRevisionsContinueErrorTransientError? {
        self as? DBXTeamLegalHoldsListHeldRevisionsContinueErrorTransientError
    }

    @objc
    public var asReset: DBXTeamLegalHoldsListHeldRevisionsContinueErrorReset? {
        self as? DBXTeamLegalHoldsListHeldRevisionsContinueErrorReset
    }

    @objc
    public var asOther: DBXTeamLegalHoldsListHeldRevisionsContinueErrorOther? {
        self as? DBXTeamLegalHoldsListHeldRevisionsContinueErrorOther
    }
}

/// There has been an unknown legal hold error.
@objc
public class DBXTeamLegalHoldsListHeldRevisionsContinueErrorUnknownLegalHoldError: DBXTeamLegalHoldsListHeldRevisionsContinueError {
    @objc
    public init() {
        let swift = Team.LegalHoldsListHeldRevisionsContinueError.unknownLegalHoldError
        super.init(swift: swift)
    }
}

/// Temporary infrastructure failure, please retry.
@objc
public class DBXTeamLegalHoldsListHeldRevisionsContinueErrorTransientError: DBXTeamLegalHoldsListHeldRevisionsContinueError {
    @objc
    public init() {
        let swift = Team.LegalHoldsListHeldRevisionsContinueError.transientError
        super.init(swift: swift)
    }
}

/// Indicates that the cursor has been invalidated. Call legalHoldsListHeldRevisionsContinue again with an empty
/// cursor to obtain a new cursor.
@objc
public class DBXTeamLegalHoldsListHeldRevisionsContinueErrorReset: DBXTeamLegalHoldsListHeldRevisionsContinueError {
    @objc
    public init() {
        let swift = Team.LegalHoldsListHeldRevisionsContinueError.reset
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXTeamLegalHoldsListHeldRevisionsContinueErrorOther: DBXTeamLegalHoldsListHeldRevisionsContinueError {
    @objc
    public init() {
        let swift = Team.LegalHoldsListHeldRevisionsContinueError.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible LegalHoldsListHeldRevisionsError union
@objc
public class DBXTeamLegalHoldsListHeldRevisionsError: NSObject {
    let swift: Team.LegalHoldsListHeldRevisionsError

    public init(swift: Team.LegalHoldsListHeldRevisionsError) {
        self.swift = swift
    }

    public static func factory(swift: Team.LegalHoldsListHeldRevisionsError) -> DBXTeamLegalHoldsListHeldRevisionsError {
        switch swift {
        case .unknownLegalHoldError:
            return DBXTeamLegalHoldsListHeldRevisionsErrorUnknownLegalHoldError()
        case .insufficientPermissions:
            return DBXTeamLegalHoldsListHeldRevisionsErrorInsufficientPermissions()
        case .other:
            return DBXTeamLegalHoldsListHeldRevisionsErrorOther()
        case .transientError:
            return DBXTeamLegalHoldsListHeldRevisionsErrorTransientError()
        case .legalHoldStillEmpty:
            return DBXTeamLegalHoldsListHeldRevisionsErrorLegalHoldStillEmpty()
        case .inactiveLegalHold:
            return DBXTeamLegalHoldsListHeldRevisionsErrorInactiveLegalHold()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asUnknownLegalHoldError: DBXTeamLegalHoldsListHeldRevisionsErrorUnknownLegalHoldError? {
        self as? DBXTeamLegalHoldsListHeldRevisionsErrorUnknownLegalHoldError
    }

    @objc
    public var asInsufficientPermissions: DBXTeamLegalHoldsListHeldRevisionsErrorInsufficientPermissions? {
        self as? DBXTeamLegalHoldsListHeldRevisionsErrorInsufficientPermissions
    }

    @objc
    public var asOther: DBXTeamLegalHoldsListHeldRevisionsErrorOther? {
        self as? DBXTeamLegalHoldsListHeldRevisionsErrorOther
    }

    @objc
    public var asTransientError: DBXTeamLegalHoldsListHeldRevisionsErrorTransientError? {
        self as? DBXTeamLegalHoldsListHeldRevisionsErrorTransientError
    }

    @objc
    public var asLegalHoldStillEmpty: DBXTeamLegalHoldsListHeldRevisionsErrorLegalHoldStillEmpty? {
        self as? DBXTeamLegalHoldsListHeldRevisionsErrorLegalHoldStillEmpty
    }

    @objc
    public var asInactiveLegalHold: DBXTeamLegalHoldsListHeldRevisionsErrorInactiveLegalHold? {
        self as? DBXTeamLegalHoldsListHeldRevisionsErrorInactiveLegalHold
    }
}

/// There has been an unknown legal hold error.
@objc
public class DBXTeamLegalHoldsListHeldRevisionsErrorUnknownLegalHoldError: DBXTeamLegalHoldsListHeldRevisionsError {
    @objc
    public init() {
        let swift = Team.LegalHoldsListHeldRevisionsError.unknownLegalHoldError
        super.init(swift: swift)
    }
}

/// You don't have permissions to perform this action.
@objc
public class DBXTeamLegalHoldsListHeldRevisionsErrorInsufficientPermissions: DBXTeamLegalHoldsListHeldRevisionsError {
    @objc
    public init() {
        let swift = Team.LegalHoldsListHeldRevisionsError.insufficientPermissions
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXTeamLegalHoldsListHeldRevisionsErrorOther: DBXTeamLegalHoldsListHeldRevisionsError {
    @objc
    public init() {
        let swift = Team.LegalHoldsListHeldRevisionsError.other
        super.init(swift: swift)
    }
}

/// Temporary infrastructure failure, please retry.
@objc
public class DBXTeamLegalHoldsListHeldRevisionsErrorTransientError: DBXTeamLegalHoldsListHeldRevisionsError {
    @objc
    public init() {
        let swift = Team.LegalHoldsListHeldRevisionsError.transientError
        super.init(swift: swift)
    }
}

/// The legal hold is not holding any revisions yet.
@objc
public class DBXTeamLegalHoldsListHeldRevisionsErrorLegalHoldStillEmpty: DBXTeamLegalHoldsListHeldRevisionsError {
    @objc
    public init() {
        let swift = Team.LegalHoldsListHeldRevisionsError.legalHoldStillEmpty
        super.init(swift: swift)
    }
}

/// Trying to list revisions for an inactive legal hold.
@objc
public class DBXTeamLegalHoldsListHeldRevisionsErrorInactiveLegalHold: DBXTeamLegalHoldsListHeldRevisionsError {
    @objc
    public init() {
        let swift = Team.LegalHoldsListHeldRevisionsError.inactiveLegalHold
        super.init(swift: swift)
    }
}

/// Objective-C compatible LegalHoldsListPoliciesArg struct
@objc
public class DBXTeamLegalHoldsListPoliciesArg: NSObject {
    /// Whether to return holds that were released.
    @objc
    public var includeReleased: NSNumber { swift.includeReleased as NSNumber }

    @objc
    public init(includeReleased: NSNumber) {
        self.swift = Team.LegalHoldsListPoliciesArg(includeReleased: includeReleased.boolValue)
    }

    let swift: Team.LegalHoldsListPoliciesArg

    public init(swift: Team.LegalHoldsListPoliciesArg) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible LegalHoldsListPoliciesError union
@objc
public class DBXTeamLegalHoldsListPoliciesError: NSObject {
    let swift: Team.LegalHoldsListPoliciesError

    public init(swift: Team.LegalHoldsListPoliciesError) {
        self.swift = swift
    }

    public static func factory(swift: Team.LegalHoldsListPoliciesError) -> DBXTeamLegalHoldsListPoliciesError {
        switch swift {
        case .unknownLegalHoldError:
            return DBXTeamLegalHoldsListPoliciesErrorUnknownLegalHoldError()
        case .insufficientPermissions:
            return DBXTeamLegalHoldsListPoliciesErrorInsufficientPermissions()
        case .other:
            return DBXTeamLegalHoldsListPoliciesErrorOther()
        case .transientError:
            return DBXTeamLegalHoldsListPoliciesErrorTransientError()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asUnknownLegalHoldError: DBXTeamLegalHoldsListPoliciesErrorUnknownLegalHoldError? {
        self as? DBXTeamLegalHoldsListPoliciesErrorUnknownLegalHoldError
    }

    @objc
    public var asInsufficientPermissions: DBXTeamLegalHoldsListPoliciesErrorInsufficientPermissions? {
        self as? DBXTeamLegalHoldsListPoliciesErrorInsufficientPermissions
    }

    @objc
    public var asOther: DBXTeamLegalHoldsListPoliciesErrorOther? {
        self as? DBXTeamLegalHoldsListPoliciesErrorOther
    }

    @objc
    public var asTransientError: DBXTeamLegalHoldsListPoliciesErrorTransientError? {
        self as? DBXTeamLegalHoldsListPoliciesErrorTransientError
    }
}

/// There has been an unknown legal hold error.
@objc
public class DBXTeamLegalHoldsListPoliciesErrorUnknownLegalHoldError: DBXTeamLegalHoldsListPoliciesError {
    @objc
    public init() {
        let swift = Team.LegalHoldsListPoliciesError.unknownLegalHoldError
        super.init(swift: swift)
    }
}

/// You don't have permissions to perform this action.
@objc
public class DBXTeamLegalHoldsListPoliciesErrorInsufficientPermissions: DBXTeamLegalHoldsListPoliciesError {
    @objc
    public init() {
        let swift = Team.LegalHoldsListPoliciesError.insufficientPermissions
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXTeamLegalHoldsListPoliciesErrorOther: DBXTeamLegalHoldsListPoliciesError {
    @objc
    public init() {
        let swift = Team.LegalHoldsListPoliciesError.other
        super.init(swift: swift)
    }
}

/// Temporary infrastructure failure, please retry.
@objc
public class DBXTeamLegalHoldsListPoliciesErrorTransientError: DBXTeamLegalHoldsListPoliciesError {
    @objc
    public init() {
        let swift = Team.LegalHoldsListPoliciesError.transientError
        super.init(swift: swift)
    }
}

/// Objective-C compatible LegalHoldsListPoliciesResult struct
@objc
public class DBXTeamLegalHoldsListPoliciesResult: NSObject {
    /// (no description)
    @objc
    public var policies: [DBXTeamLegalHoldPolicy] { swift.policies.map { DBXTeamLegalHoldPolicy(swift: $0) } }

    @objc
    public init(policies: [DBXTeamLegalHoldPolicy]) {
        self.swift = Team.LegalHoldsListPoliciesResult(policies: policies.map(\.swift))
    }

    let swift: Team.LegalHoldsListPoliciesResult

    public init(swift: Team.LegalHoldsListPoliciesResult) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible LegalHoldsPolicyCreateArg struct
@objc
public class DBXTeamLegalHoldsPolicyCreateArg: NSObject {
    /// Policy name.
    @objc
    public var name: String { swift.name }
    /// A description of the legal hold policy.
    @objc
    public var description_: String? { swift.description_ }
    /// List of team member IDs added to the hold.
    @objc
    public var members: [String] { swift.members }
    /// start date of the legal hold policy.
    @objc
    public var startDate: Date? { swift.startDate }
    /// end date of the legal hold policy.
    @objc
    public var endDate: Date? { swift.endDate }

    @objc
    public init(name: String, members: [String], description_: String?, startDate: Date?, endDate: Date?) {
        self.swift = Team.LegalHoldsPolicyCreateArg(name: name, members: members, description_: description_, startDate: startDate, endDate: endDate)
    }

    let swift: Team.LegalHoldsPolicyCreateArg

    public init(swift: Team.LegalHoldsPolicyCreateArg) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible LegalHoldsPolicyCreateError union
@objc
public class DBXTeamLegalHoldsPolicyCreateError: NSObject {
    let swift: Team.LegalHoldsPolicyCreateError

    public init(swift: Team.LegalHoldsPolicyCreateError) {
        self.swift = swift
    }

    public static func factory(swift: Team.LegalHoldsPolicyCreateError) -> DBXTeamLegalHoldsPolicyCreateError {
        switch swift {
        case .unknownLegalHoldError:
            return DBXTeamLegalHoldsPolicyCreateErrorUnknownLegalHoldError()
        case .insufficientPermissions:
            return DBXTeamLegalHoldsPolicyCreateErrorInsufficientPermissions()
        case .other:
            return DBXTeamLegalHoldsPolicyCreateErrorOther()
        case .startDateIsLaterThanEndDate:
            return DBXTeamLegalHoldsPolicyCreateErrorStartDateIsLaterThanEndDate()
        case .emptyMembersList:
            return DBXTeamLegalHoldsPolicyCreateErrorEmptyMembersList()
        case .invalidMembers:
            return DBXTeamLegalHoldsPolicyCreateErrorInvalidMembers()
        case .numberOfUsersOnHoldIsGreaterThanHoldLimitation:
            return DBXTeamLegalHoldsPolicyCreateErrorNumberOfUsersOnHoldIsGreaterThanHoldLimitation()
        case .transientError:
            return DBXTeamLegalHoldsPolicyCreateErrorTransientError()
        case .nameMustBeUnique:
            return DBXTeamLegalHoldsPolicyCreateErrorNameMustBeUnique()
        case .teamExceededLegalHoldQuota:
            return DBXTeamLegalHoldsPolicyCreateErrorTeamExceededLegalHoldQuota()
        case .invalidDate:
            return DBXTeamLegalHoldsPolicyCreateErrorInvalidDate()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asUnknownLegalHoldError: DBXTeamLegalHoldsPolicyCreateErrorUnknownLegalHoldError? {
        self as? DBXTeamLegalHoldsPolicyCreateErrorUnknownLegalHoldError
    }

    @objc
    public var asInsufficientPermissions: DBXTeamLegalHoldsPolicyCreateErrorInsufficientPermissions? {
        self as? DBXTeamLegalHoldsPolicyCreateErrorInsufficientPermissions
    }

    @objc
    public var asOther: DBXTeamLegalHoldsPolicyCreateErrorOther? {
        self as? DBXTeamLegalHoldsPolicyCreateErrorOther
    }

    @objc
    public var asStartDateIsLaterThanEndDate: DBXTeamLegalHoldsPolicyCreateErrorStartDateIsLaterThanEndDate? {
        self as? DBXTeamLegalHoldsPolicyCreateErrorStartDateIsLaterThanEndDate
    }

    @objc
    public var asEmptyMembersList: DBXTeamLegalHoldsPolicyCreateErrorEmptyMembersList? {
        self as? DBXTeamLegalHoldsPolicyCreateErrorEmptyMembersList
    }

    @objc
    public var asInvalidMembers: DBXTeamLegalHoldsPolicyCreateErrorInvalidMembers? {
        self as? DBXTeamLegalHoldsPolicyCreateErrorInvalidMembers
    }

    @objc
    public var asNumberOfUsersOnHoldIsGreaterThanHoldLimitation: DBXTeamLegalHoldsPolicyCreateErrorNumberOfUsersOnHoldIsGreaterThanHoldLimitation? {
        self as? DBXTeamLegalHoldsPolicyCreateErrorNumberOfUsersOnHoldIsGreaterThanHoldLimitation
    }

    @objc
    public var asTransientError: DBXTeamLegalHoldsPolicyCreateErrorTransientError? {
        self as? DBXTeamLegalHoldsPolicyCreateErrorTransientError
    }

    @objc
    public var asNameMustBeUnique: DBXTeamLegalHoldsPolicyCreateErrorNameMustBeUnique? {
        self as? DBXTeamLegalHoldsPolicyCreateErrorNameMustBeUnique
    }

    @objc
    public var asTeamExceededLegalHoldQuota: DBXTeamLegalHoldsPolicyCreateErrorTeamExceededLegalHoldQuota? {
        self as? DBXTeamLegalHoldsPolicyCreateErrorTeamExceededLegalHoldQuota
    }

    @objc
    public var asInvalidDate: DBXTeamLegalHoldsPolicyCreateErrorInvalidDate? {
        self as? DBXTeamLegalHoldsPolicyCreateErrorInvalidDate
    }
}

/// There has been an unknown legal hold error.
@objc
public class DBXTeamLegalHoldsPolicyCreateErrorUnknownLegalHoldError: DBXTeamLegalHoldsPolicyCreateError {
    @objc
    public init() {
        let swift = Team.LegalHoldsPolicyCreateError.unknownLegalHoldError
        super.init(swift: swift)
    }
}

/// You don't have permissions to perform this action.
@objc
public class DBXTeamLegalHoldsPolicyCreateErrorInsufficientPermissions: DBXTeamLegalHoldsPolicyCreateError {
    @objc
    public init() {
        let swift = Team.LegalHoldsPolicyCreateError.insufficientPermissions
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXTeamLegalHoldsPolicyCreateErrorOther: DBXTeamLegalHoldsPolicyCreateError {
    @objc
    public init() {
        let swift = Team.LegalHoldsPolicyCreateError.other
        super.init(swift: swift)
    }
}

/// Start date must be earlier than end date.
@objc
public class DBXTeamLegalHoldsPolicyCreateErrorStartDateIsLaterThanEndDate: DBXTeamLegalHoldsPolicyCreateError {
    @objc
    public init() {
        let swift = Team.LegalHoldsPolicyCreateError.startDateIsLaterThanEndDate
        super.init(swift: swift)
    }
}

/// The users list must have at least one user.
@objc
public class DBXTeamLegalHoldsPolicyCreateErrorEmptyMembersList: DBXTeamLegalHoldsPolicyCreateError {
    @objc
    public init() {
        let swift = Team.LegalHoldsPolicyCreateError.emptyMembersList
        super.init(swift: swift)
    }
}

/// Some members in the members list are not valid to be placed under legal hold.
@objc
public class DBXTeamLegalHoldsPolicyCreateErrorInvalidMembers: DBXTeamLegalHoldsPolicyCreateError {
    @objc
    public init() {
        let swift = Team.LegalHoldsPolicyCreateError.invalidMembers
        super.init(swift: swift)
    }
}

/// You cannot add more than 5 users in a legal hold.
@objc
public class DBXTeamLegalHoldsPolicyCreateErrorNumberOfUsersOnHoldIsGreaterThanHoldLimitation: DBXTeamLegalHoldsPolicyCreateError {
    @objc
    public init() {
        let swift = Team.LegalHoldsPolicyCreateError.numberOfUsersOnHoldIsGreaterThanHoldLimitation
        super.init(swift: swift)
    }
}

/// Temporary infrastructure failure, please retry.
@objc
public class DBXTeamLegalHoldsPolicyCreateErrorTransientError: DBXTeamLegalHoldsPolicyCreateError {
    @objc
    public init() {
        let swift = Team.LegalHoldsPolicyCreateError.transientError
        super.init(swift: swift)
    }
}

/// The name provided is already in use by another legal hold.
@objc
public class DBXTeamLegalHoldsPolicyCreateErrorNameMustBeUnique: DBXTeamLegalHoldsPolicyCreateError {
    @objc
    public init() {
        let swift = Team.LegalHoldsPolicyCreateError.nameMustBeUnique
        super.init(swift: swift)
    }
}

/// Team exceeded legal hold quota.
@objc
public class DBXTeamLegalHoldsPolicyCreateErrorTeamExceededLegalHoldQuota: DBXTeamLegalHoldsPolicyCreateError {
    @objc
    public init() {
        let swift = Team.LegalHoldsPolicyCreateError.teamExceededLegalHoldQuota
        super.init(swift: swift)
    }
}

/// The provided date is invalid.
@objc
public class DBXTeamLegalHoldsPolicyCreateErrorInvalidDate: DBXTeamLegalHoldsPolicyCreateError {
    @objc
    public init() {
        let swift = Team.LegalHoldsPolicyCreateError.invalidDate
        super.init(swift: swift)
    }
}

/// Objective-C compatible LegalHoldsPolicyReleaseArg struct
@objc
public class DBXTeamLegalHoldsPolicyReleaseArg: NSObject {
    /// The legal hold Id.
    @objc
    public var id: String { swift.id }

    @objc
    public init(id: String) {
        self.swift = Team.LegalHoldsPolicyReleaseArg(id: id)
    }

    let swift: Team.LegalHoldsPolicyReleaseArg

    public init(swift: Team.LegalHoldsPolicyReleaseArg) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible LegalHoldsPolicyReleaseError union
@objc
public class DBXTeamLegalHoldsPolicyReleaseError: NSObject {
    let swift: Team.LegalHoldsPolicyReleaseError

    public init(swift: Team.LegalHoldsPolicyReleaseError) {
        self.swift = swift
    }

    public static func factory(swift: Team.LegalHoldsPolicyReleaseError) -> DBXTeamLegalHoldsPolicyReleaseError {
        switch swift {
        case .unknownLegalHoldError:
            return DBXTeamLegalHoldsPolicyReleaseErrorUnknownLegalHoldError()
        case .insufficientPermissions:
            return DBXTeamLegalHoldsPolicyReleaseErrorInsufficientPermissions()
        case .other:
            return DBXTeamLegalHoldsPolicyReleaseErrorOther()
        case .legalHoldPerformingAnotherOperation:
            return DBXTeamLegalHoldsPolicyReleaseErrorLegalHoldPerformingAnotherOperation()
        case .legalHoldAlreadyReleasing:
            return DBXTeamLegalHoldsPolicyReleaseErrorLegalHoldAlreadyReleasing()
        case .legalHoldPolicyNotFound:
            return DBXTeamLegalHoldsPolicyReleaseErrorLegalHoldPolicyNotFound()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asUnknownLegalHoldError: DBXTeamLegalHoldsPolicyReleaseErrorUnknownLegalHoldError? {
        self as? DBXTeamLegalHoldsPolicyReleaseErrorUnknownLegalHoldError
    }

    @objc
    public var asInsufficientPermissions: DBXTeamLegalHoldsPolicyReleaseErrorInsufficientPermissions? {
        self as? DBXTeamLegalHoldsPolicyReleaseErrorInsufficientPermissions
    }

    @objc
    public var asOther: DBXTeamLegalHoldsPolicyReleaseErrorOther? {
        self as? DBXTeamLegalHoldsPolicyReleaseErrorOther
    }

    @objc
    public var asLegalHoldPerformingAnotherOperation: DBXTeamLegalHoldsPolicyReleaseErrorLegalHoldPerformingAnotherOperation? {
        self as? DBXTeamLegalHoldsPolicyReleaseErrorLegalHoldPerformingAnotherOperation
    }

    @objc
    public var asLegalHoldAlreadyReleasing: DBXTeamLegalHoldsPolicyReleaseErrorLegalHoldAlreadyReleasing? {
        self as? DBXTeamLegalHoldsPolicyReleaseErrorLegalHoldAlreadyReleasing
    }

    @objc
    public var asLegalHoldPolicyNotFound: DBXTeamLegalHoldsPolicyReleaseErrorLegalHoldPolicyNotFound? {
        self as? DBXTeamLegalHoldsPolicyReleaseErrorLegalHoldPolicyNotFound
    }
}

/// There has been an unknown legal hold error.
@objc
public class DBXTeamLegalHoldsPolicyReleaseErrorUnknownLegalHoldError: DBXTeamLegalHoldsPolicyReleaseError {
    @objc
    public init() {
        let swift = Team.LegalHoldsPolicyReleaseError.unknownLegalHoldError
        super.init(swift: swift)
    }
}

/// You don't have permissions to perform this action.
@objc
public class DBXTeamLegalHoldsPolicyReleaseErrorInsufficientPermissions: DBXTeamLegalHoldsPolicyReleaseError {
    @objc
    public init() {
        let swift = Team.LegalHoldsPolicyReleaseError.insufficientPermissions
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXTeamLegalHoldsPolicyReleaseErrorOther: DBXTeamLegalHoldsPolicyReleaseError {
    @objc
    public init() {
        let swift = Team.LegalHoldsPolicyReleaseError.other
        super.init(swift: swift)
    }
}

/// Legal hold is currently performing another operation.
@objc
public class DBXTeamLegalHoldsPolicyReleaseErrorLegalHoldPerformingAnotherOperation: DBXTeamLegalHoldsPolicyReleaseError {
    @objc
    public init() {
        let swift = Team.LegalHoldsPolicyReleaseError.legalHoldPerformingAnotherOperation
        super.init(swift: swift)
    }
}

/// Legal hold is currently performing a release or is already released.
@objc
public class DBXTeamLegalHoldsPolicyReleaseErrorLegalHoldAlreadyReleasing: DBXTeamLegalHoldsPolicyReleaseError {
    @objc
    public init() {
        let swift = Team.LegalHoldsPolicyReleaseError.legalHoldAlreadyReleasing
        super.init(swift: swift)
    }
}

/// Legal hold policy does not exist for id in LegalHoldsPolicyReleaseArg.
@objc
public class DBXTeamLegalHoldsPolicyReleaseErrorLegalHoldPolicyNotFound: DBXTeamLegalHoldsPolicyReleaseError {
    @objc
    public init() {
        let swift = Team.LegalHoldsPolicyReleaseError.legalHoldPolicyNotFound
        super.init(swift: swift)
    }
}

/// Objective-C compatible LegalHoldsPolicyUpdateArg struct
@objc
public class DBXTeamLegalHoldsPolicyUpdateArg: NSObject {
    /// The legal hold Id.
    @objc
    public var id: String { swift.id }
    /// Policy new name.
    @objc
    public var name: String? { swift.name }
    /// Policy new description.
    @objc
    public var description_: String? { swift.description_ }
    /// List of team member IDs to apply the policy on.
    @objc
    public var members: [String]? { swift.members }

    @objc
    public init(id: String, name: String?, description_: String?, members: [String]?) {
        self.swift = Team.LegalHoldsPolicyUpdateArg(id: id, name: name, description_: description_, members: members)
    }

    let swift: Team.LegalHoldsPolicyUpdateArg

    public init(swift: Team.LegalHoldsPolicyUpdateArg) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible LegalHoldsPolicyUpdateError union
@objc
public class DBXTeamLegalHoldsPolicyUpdateError: NSObject {
    let swift: Team.LegalHoldsPolicyUpdateError

    public init(swift: Team.LegalHoldsPolicyUpdateError) {
        self.swift = swift
    }

    public static func factory(swift: Team.LegalHoldsPolicyUpdateError) -> DBXTeamLegalHoldsPolicyUpdateError {
        switch swift {
        case .unknownLegalHoldError:
            return DBXTeamLegalHoldsPolicyUpdateErrorUnknownLegalHoldError()
        case .insufficientPermissions:
            return DBXTeamLegalHoldsPolicyUpdateErrorInsufficientPermissions()
        case .other:
            return DBXTeamLegalHoldsPolicyUpdateErrorOther()
        case .transientError:
            return DBXTeamLegalHoldsPolicyUpdateErrorTransientError()
        case .inactiveLegalHold:
            return DBXTeamLegalHoldsPolicyUpdateErrorInactiveLegalHold()
        case .legalHoldPerformingAnotherOperation:
            return DBXTeamLegalHoldsPolicyUpdateErrorLegalHoldPerformingAnotherOperation()
        case .invalidMembers:
            return DBXTeamLegalHoldsPolicyUpdateErrorInvalidMembers()
        case .numberOfUsersOnHoldIsGreaterThanHoldLimitation:
            return DBXTeamLegalHoldsPolicyUpdateErrorNumberOfUsersOnHoldIsGreaterThanHoldLimitation()
        case .emptyMembersList:
            return DBXTeamLegalHoldsPolicyUpdateErrorEmptyMembersList()
        case .nameMustBeUnique:
            return DBXTeamLegalHoldsPolicyUpdateErrorNameMustBeUnique()
        case .legalHoldPolicyNotFound:
            return DBXTeamLegalHoldsPolicyUpdateErrorLegalHoldPolicyNotFound()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asUnknownLegalHoldError: DBXTeamLegalHoldsPolicyUpdateErrorUnknownLegalHoldError? {
        self as? DBXTeamLegalHoldsPolicyUpdateErrorUnknownLegalHoldError
    }

    @objc
    public var asInsufficientPermissions: DBXTeamLegalHoldsPolicyUpdateErrorInsufficientPermissions? {
        self as? DBXTeamLegalHoldsPolicyUpdateErrorInsufficientPermissions
    }

    @objc
    public var asOther: DBXTeamLegalHoldsPolicyUpdateErrorOther? {
        self as? DBXTeamLegalHoldsPolicyUpdateErrorOther
    }

    @objc
    public var asTransientError: DBXTeamLegalHoldsPolicyUpdateErrorTransientError? {
        self as? DBXTeamLegalHoldsPolicyUpdateErrorTransientError
    }

    @objc
    public var asInactiveLegalHold: DBXTeamLegalHoldsPolicyUpdateErrorInactiveLegalHold? {
        self as? DBXTeamLegalHoldsPolicyUpdateErrorInactiveLegalHold
    }

    @objc
    public var asLegalHoldPerformingAnotherOperation: DBXTeamLegalHoldsPolicyUpdateErrorLegalHoldPerformingAnotherOperation? {
        self as? DBXTeamLegalHoldsPolicyUpdateErrorLegalHoldPerformingAnotherOperation
    }

    @objc
    public var asInvalidMembers: DBXTeamLegalHoldsPolicyUpdateErrorInvalidMembers? {
        self as? DBXTeamLegalHoldsPolicyUpdateErrorInvalidMembers
    }

    @objc
    public var asNumberOfUsersOnHoldIsGreaterThanHoldLimitation: DBXTeamLegalHoldsPolicyUpdateErrorNumberOfUsersOnHoldIsGreaterThanHoldLimitation? {
        self as? DBXTeamLegalHoldsPolicyUpdateErrorNumberOfUsersOnHoldIsGreaterThanHoldLimitation
    }

    @objc
    public var asEmptyMembersList: DBXTeamLegalHoldsPolicyUpdateErrorEmptyMembersList? {
        self as? DBXTeamLegalHoldsPolicyUpdateErrorEmptyMembersList
    }

    @objc
    public var asNameMustBeUnique: DBXTeamLegalHoldsPolicyUpdateErrorNameMustBeUnique? {
        self as? DBXTeamLegalHoldsPolicyUpdateErrorNameMustBeUnique
    }

    @objc
    public var asLegalHoldPolicyNotFound: DBXTeamLegalHoldsPolicyUpdateErrorLegalHoldPolicyNotFound? {
        self as? DBXTeamLegalHoldsPolicyUpdateErrorLegalHoldPolicyNotFound
    }
}

/// There has been an unknown legal hold error.
@objc
public class DBXTeamLegalHoldsPolicyUpdateErrorUnknownLegalHoldError: DBXTeamLegalHoldsPolicyUpdateError {
    @objc
    public init() {
        let swift = Team.LegalHoldsPolicyUpdateError.unknownLegalHoldError
        super.init(swift: swift)
    }
}

/// You don't have permissions to perform this action.
@objc
public class DBXTeamLegalHoldsPolicyUpdateErrorInsufficientPermissions: DBXTeamLegalHoldsPolicyUpdateError {
    @objc
    public init() {
        let swift = Team.LegalHoldsPolicyUpdateError.insufficientPermissions
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXTeamLegalHoldsPolicyUpdateErrorOther: DBXTeamLegalHoldsPolicyUpdateError {
    @objc
    public init() {
        let swift = Team.LegalHoldsPolicyUpdateError.other
        super.init(swift: swift)
    }
}

/// Temporary infrastructure failure, please retry.
@objc
public class DBXTeamLegalHoldsPolicyUpdateErrorTransientError: DBXTeamLegalHoldsPolicyUpdateError {
    @objc
    public init() {
        let swift = Team.LegalHoldsPolicyUpdateError.transientError
        super.init(swift: swift)
    }
}

/// Trying to release an inactive legal hold.
@objc
public class DBXTeamLegalHoldsPolicyUpdateErrorInactiveLegalHold: DBXTeamLegalHoldsPolicyUpdateError {
    @objc
    public init() {
        let swift = Team.LegalHoldsPolicyUpdateError.inactiveLegalHold
        super.init(swift: swift)
    }
}

/// Legal hold is currently performing another operation.
@objc
public class DBXTeamLegalHoldsPolicyUpdateErrorLegalHoldPerformingAnotherOperation: DBXTeamLegalHoldsPolicyUpdateError {
    @objc
    public init() {
        let swift = Team.LegalHoldsPolicyUpdateError.legalHoldPerformingAnotherOperation
        super.init(swift: swift)
    }
}

/// Some members in the members list are not valid to be placed under legal hold.
@objc
public class DBXTeamLegalHoldsPolicyUpdateErrorInvalidMembers: DBXTeamLegalHoldsPolicyUpdateError {
    @objc
    public init() {
        let swift = Team.LegalHoldsPolicyUpdateError.invalidMembers
        super.init(swift: swift)
    }
}

/// You cannot add more than 5 users in a legal hold.
@objc
public class DBXTeamLegalHoldsPolicyUpdateErrorNumberOfUsersOnHoldIsGreaterThanHoldLimitation: DBXTeamLegalHoldsPolicyUpdateError {
    @objc
    public init() {
        let swift = Team.LegalHoldsPolicyUpdateError.numberOfUsersOnHoldIsGreaterThanHoldLimitation
        super.init(swift: swift)
    }
}

/// The users list must have at least one user.
@objc
public class DBXTeamLegalHoldsPolicyUpdateErrorEmptyMembersList: DBXTeamLegalHoldsPolicyUpdateError {
    @objc
    public init() {
        let swift = Team.LegalHoldsPolicyUpdateError.emptyMembersList
        super.init(swift: swift)
    }
}

/// The name provided is already in use by another legal hold.
@objc
public class DBXTeamLegalHoldsPolicyUpdateErrorNameMustBeUnique: DBXTeamLegalHoldsPolicyUpdateError {
    @objc
    public init() {
        let swift = Team.LegalHoldsPolicyUpdateError.nameMustBeUnique
        super.init(swift: swift)
    }
}

/// Legal hold policy does not exist for id in LegalHoldsPolicyUpdateArg.
@objc
public class DBXTeamLegalHoldsPolicyUpdateErrorLegalHoldPolicyNotFound: DBXTeamLegalHoldsPolicyUpdateError {
    @objc
    public init() {
        let swift = Team.LegalHoldsPolicyUpdateError.legalHoldPolicyNotFound
        super.init(swift: swift)
    }
}

/// Objective-C compatible ListMemberAppsArg struct
@objc
public class DBXTeamListMemberAppsArg: NSObject {
    /// The team member id.
    @objc
    public var teamMemberId: String { swift.teamMemberId }

    @objc
    public init(teamMemberId: String) {
        self.swift = Team.ListMemberAppsArg(teamMemberId: teamMemberId)
    }

    let swift: Team.ListMemberAppsArg

    public init(swift: Team.ListMemberAppsArg) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Error returned by linkedAppsListMemberLinkedApps.
@objc
public class DBXTeamListMemberAppsError: NSObject {
    let swift: Team.ListMemberAppsError

    public init(swift: Team.ListMemberAppsError) {
        self.swift = swift
    }

    public static func factory(swift: Team.ListMemberAppsError) -> DBXTeamListMemberAppsError {
        switch swift {
        case .memberNotFound:
            return DBXTeamListMemberAppsErrorMemberNotFound()
        case .other:
            return DBXTeamListMemberAppsErrorOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asMemberNotFound: DBXTeamListMemberAppsErrorMemberNotFound? {
        self as? DBXTeamListMemberAppsErrorMemberNotFound
    }

    @objc
    public var asOther: DBXTeamListMemberAppsErrorOther? {
        self as? DBXTeamListMemberAppsErrorOther
    }
}

/// Member not found.
@objc
public class DBXTeamListMemberAppsErrorMemberNotFound: DBXTeamListMemberAppsError {
    @objc
    public init() {
        let swift = Team.ListMemberAppsError.memberNotFound
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXTeamListMemberAppsErrorOther: DBXTeamListMemberAppsError {
    @objc
    public init() {
        let swift = Team.ListMemberAppsError.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible ListMemberAppsResult struct
@objc
public class DBXTeamListMemberAppsResult: NSObject {
    /// List of third party applications linked by this team member.
    @objc
    public var linkedApiApps: [DBXTeamApiApp] { swift.linkedApiApps.map { DBXTeamApiApp(swift: $0) } }

    @objc
    public init(linkedApiApps: [DBXTeamApiApp]) {
        self.swift = Team.ListMemberAppsResult(linkedApiApps: linkedApiApps.map(\.swift))
    }

    let swift: Team.ListMemberAppsResult

    public init(swift: Team.ListMemberAppsResult) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible ListMemberDevicesArg struct
@objc
public class DBXTeamListMemberDevicesArg: NSObject {
    /// The team's member id.
    @objc
    public var teamMemberId: String { swift.teamMemberId }
    /// Whether to list web sessions of the team's member.
    @objc
    public var includeWebSessions: NSNumber { swift.includeWebSessions as NSNumber }
    /// Whether to list linked desktop devices of the team's member.
    @objc
    public var includeDesktopClients: NSNumber { swift.includeDesktopClients as NSNumber }
    /// Whether to list linked mobile devices of the team's member.
    @objc
    public var includeMobileClients: NSNumber { swift.includeMobileClients as NSNumber }

    @objc
    public init(teamMemberId: String, includeWebSessions: NSNumber, includeDesktopClients: NSNumber, includeMobileClients: NSNumber) {
        self.swift = Team.ListMemberDevicesArg(
            teamMemberId: teamMemberId,
            includeWebSessions: includeWebSessions.boolValue,
            includeDesktopClients: includeDesktopClients.boolValue,
            includeMobileClients: includeMobileClients.boolValue
        )
    }

    let swift: Team.ListMemberDevicesArg

    public init(swift: Team.ListMemberDevicesArg) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible ListMemberDevicesError union
@objc
public class DBXTeamListMemberDevicesError: NSObject {
    let swift: Team.ListMemberDevicesError

    public init(swift: Team.ListMemberDevicesError) {
        self.swift = swift
    }

    public static func factory(swift: Team.ListMemberDevicesError) -> DBXTeamListMemberDevicesError {
        switch swift {
        case .memberNotFound:
            return DBXTeamListMemberDevicesErrorMemberNotFound()
        case .other:
            return DBXTeamListMemberDevicesErrorOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asMemberNotFound: DBXTeamListMemberDevicesErrorMemberNotFound? {
        self as? DBXTeamListMemberDevicesErrorMemberNotFound
    }

    @objc
    public var asOther: DBXTeamListMemberDevicesErrorOther? {
        self as? DBXTeamListMemberDevicesErrorOther
    }
}

/// Member not found.
@objc
public class DBXTeamListMemberDevicesErrorMemberNotFound: DBXTeamListMemberDevicesError {
    @objc
    public init() {
        let swift = Team.ListMemberDevicesError.memberNotFound
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXTeamListMemberDevicesErrorOther: DBXTeamListMemberDevicesError {
    @objc
    public init() {
        let swift = Team.ListMemberDevicesError.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible ListMemberDevicesResult struct
@objc
public class DBXTeamListMemberDevicesResult: NSObject {
    /// List of web sessions made by this team member.
    @objc
    public var activeWebSessions: [DBXTeamActiveWebSession]? { swift.activeWebSessions?.map { DBXTeamActiveWebSession(swift: $0) } }
    /// List of desktop clients used by this team member.
    @objc
    public var desktopClientSessions: [DBXTeamDesktopClientSession]? { swift.desktopClientSessions?.map { DBXTeamDesktopClientSession(swift: $0) } }
    /// List of mobile client used by this team member.
    @objc
    public var mobileClientSessions: [DBXTeamMobileClientSession]? { swift.mobileClientSessions?.map { DBXTeamMobileClientSession(swift: $0) } }

    @objc
    public init(
        activeWebSessions: [DBXTeamActiveWebSession]?,
        desktopClientSessions: [DBXTeamDesktopClientSession]?,
        mobileClientSessions: [DBXTeamMobileClientSession]?
    ) {
        self.swift = Team.ListMemberDevicesResult(
            activeWebSessions: activeWebSessions?.map(\.subSwift),
            desktopClientSessions: desktopClientSessions?.map(\.subSwift),
            mobileClientSessions: mobileClientSessions?.map(\.subSwift)
        )
    }

    let swift: Team.ListMemberDevicesResult

    public init(swift: Team.ListMemberDevicesResult) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Arguments for linkedAppsListMembersLinkedApps.
@objc
public class DBXTeamListMembersAppsArg: NSObject {
    /// At the first call to the linkedAppsListMembersLinkedApps the cursor shouldn't be passed. Then, if the result
    /// of the call includes a cursor, the following requests should include the received cursors in order to
    /// receive the next sub list of the team applications.
    @objc
    public var cursor: String? { swift.cursor }

    @objc
    public init(cursor: String?) {
        self.swift = Team.ListMembersAppsArg(cursor: cursor)
    }

    let swift: Team.ListMembersAppsArg

    public init(swift: Team.ListMembersAppsArg) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Error returned by linkedAppsListMembersLinkedApps.
@objc
public class DBXTeamListMembersAppsError: NSObject {
    let swift: Team.ListMembersAppsError

    public init(swift: Team.ListMembersAppsError) {
        self.swift = swift
    }

    public static func factory(swift: Team.ListMembersAppsError) -> DBXTeamListMembersAppsError {
        switch swift {
        case .reset:
            return DBXTeamListMembersAppsErrorReset()
        case .other:
            return DBXTeamListMembersAppsErrorOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asReset: DBXTeamListMembersAppsErrorReset? {
        self as? DBXTeamListMembersAppsErrorReset
    }

    @objc
    public var asOther: DBXTeamListMembersAppsErrorOther? {
        self as? DBXTeamListMembersAppsErrorOther
    }
}

/// Indicates that the cursor has been invalidated. Call linkedAppsListMembersLinkedApps again with an empty
/// cursor to obtain a new cursor.
@objc
public class DBXTeamListMembersAppsErrorReset: DBXTeamListMembersAppsError {
    @objc
    public init() {
        let swift = Team.ListMembersAppsError.reset
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXTeamListMembersAppsErrorOther: DBXTeamListMembersAppsError {
    @objc
    public init() {
        let swift = Team.ListMembersAppsError.other
        super.init(swift: swift)
    }
}

/// Information returned by linkedAppsListMembersLinkedApps.
@objc
public class DBXTeamListMembersAppsResult: NSObject {
    /// The linked applications of each member of the team.
    @objc
    public var apps: [DBXTeamMemberLinkedApps] { swift.apps.map { DBXTeamMemberLinkedApps(swift: $0) } }
    /// If true, then there are more apps available. Pass the cursor to linkedAppsListMembersLinkedApps to retrieve
    /// the rest.
    @objc
    public var hasMore: NSNumber { swift.hasMore as NSNumber }
    /// Pass the cursor into linkedAppsListMembersLinkedApps to receive the next sub list of team's applications.
    @objc
    public var cursor: String? { swift.cursor }

    @objc
    public init(apps: [DBXTeamMemberLinkedApps], hasMore: NSNumber, cursor: String?) {
        self.swift = Team.ListMembersAppsResult(apps: apps.map(\.swift), hasMore: hasMore.boolValue, cursor: cursor)
    }

    let swift: Team.ListMembersAppsResult

    public init(swift: Team.ListMembersAppsResult) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible ListMembersDevicesArg struct
@objc
public class DBXTeamListMembersDevicesArg: NSObject {
    /// At the first call to the devicesListMembersDevices the cursor shouldn't be passed. Then, if the result of
    /// the call includes a cursor, the following requests should include the received cursors in order to
    /// receive the next sub list of team devices.
    @objc
    public var cursor: String? { swift.cursor }
    /// Whether to list web sessions of the team members.
    @objc
    public var includeWebSessions: NSNumber { swift.includeWebSessions as NSNumber }
    /// Whether to list desktop clients of the team members.
    @objc
    public var includeDesktopClients: NSNumber { swift.includeDesktopClients as NSNumber }
    /// Whether to list mobile clients of the team members.
    @objc
    public var includeMobileClients: NSNumber { swift.includeMobileClients as NSNumber }

    @objc
    public init(cursor: String?, includeWebSessions: NSNumber, includeDesktopClients: NSNumber, includeMobileClients: NSNumber) {
        self.swift = Team.ListMembersDevicesArg(
            cursor: cursor,
            includeWebSessions: includeWebSessions.boolValue,
            includeDesktopClients: includeDesktopClients.boolValue,
            includeMobileClients: includeMobileClients.boolValue
        )
    }

    let swift: Team.ListMembersDevicesArg

    public init(swift: Team.ListMembersDevicesArg) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible ListMembersDevicesError union
@objc
public class DBXTeamListMembersDevicesError: NSObject {
    let swift: Team.ListMembersDevicesError

    public init(swift: Team.ListMembersDevicesError) {
        self.swift = swift
    }

    public static func factory(swift: Team.ListMembersDevicesError) -> DBXTeamListMembersDevicesError {
        switch swift {
        case .reset:
            return DBXTeamListMembersDevicesErrorReset()
        case .other:
            return DBXTeamListMembersDevicesErrorOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asReset: DBXTeamListMembersDevicesErrorReset? {
        self as? DBXTeamListMembersDevicesErrorReset
    }

    @objc
    public var asOther: DBXTeamListMembersDevicesErrorOther? {
        self as? DBXTeamListMembersDevicesErrorOther
    }
}

/// Indicates that the cursor has been invalidated. Call devicesListMembersDevices again with an empty cursor to
/// obtain a new cursor.
@objc
public class DBXTeamListMembersDevicesErrorReset: DBXTeamListMembersDevicesError {
    @objc
    public init() {
        let swift = Team.ListMembersDevicesError.reset
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXTeamListMembersDevicesErrorOther: DBXTeamListMembersDevicesError {
    @objc
    public init() {
        let swift = Team.ListMembersDevicesError.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible ListMembersDevicesResult struct
@objc
public class DBXTeamListMembersDevicesResult: NSObject {
    /// The devices of each member of the team.
    @objc
    public var devices: [DBXTeamMemberDevices] { swift.devices.map { DBXTeamMemberDevices(swift: $0) } }
    /// If true, then there are more devices available. Pass the cursor to devicesListMembersDevices to retrieve the
    /// rest.
    @objc
    public var hasMore: NSNumber { swift.hasMore as NSNumber }
    /// Pass the cursor into devicesListMembersDevices to receive the next sub list of team's devices.
    @objc
    public var cursor: String? { swift.cursor }

    @objc
    public init(devices: [DBXTeamMemberDevices], hasMore: NSNumber, cursor: String?) {
        self.swift = Team.ListMembersDevicesResult(devices: devices.map(\.swift), hasMore: hasMore.boolValue, cursor: cursor)
    }

    let swift: Team.ListMembersDevicesResult

    public init(swift: Team.ListMembersDevicesResult) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Arguments for linkedAppsListTeamLinkedApps.
@objc
public class DBXTeamListTeamAppsArg: NSObject {
    /// At the first call to the linkedAppsListTeamLinkedApps the cursor shouldn't be passed. Then, if the result of
    /// the call includes a cursor, the following requests should include the received cursors in order to
    /// receive the next sub list of the team applications.
    @objc
    public var cursor: String? { swift.cursor }

    @objc
    public init(cursor: String?) {
        self.swift = Team.ListTeamAppsArg(cursor: cursor)
    }

    let swift: Team.ListTeamAppsArg

    public init(swift: Team.ListTeamAppsArg) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Error returned by linkedAppsListTeamLinkedApps.
@objc
public class DBXTeamListTeamAppsError: NSObject {
    let swift: Team.ListTeamAppsError

    public init(swift: Team.ListTeamAppsError) {
        self.swift = swift
    }

    public static func factory(swift: Team.ListTeamAppsError) -> DBXTeamListTeamAppsError {
        switch swift {
        case .reset:
            return DBXTeamListTeamAppsErrorReset()
        case .other:
            return DBXTeamListTeamAppsErrorOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asReset: DBXTeamListTeamAppsErrorReset? {
        self as? DBXTeamListTeamAppsErrorReset
    }

    @objc
    public var asOther: DBXTeamListTeamAppsErrorOther? {
        self as? DBXTeamListTeamAppsErrorOther
    }
}

/// Indicates that the cursor has been invalidated. Call linkedAppsListTeamLinkedApps again with an empty cursor
/// to obtain a new cursor.
@objc
public class DBXTeamListTeamAppsErrorReset: DBXTeamListTeamAppsError {
    @objc
    public init() {
        let swift = Team.ListTeamAppsError.reset
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXTeamListTeamAppsErrorOther: DBXTeamListTeamAppsError {
    @objc
    public init() {
        let swift = Team.ListTeamAppsError.other
        super.init(swift: swift)
    }
}

/// Information returned by linkedAppsListTeamLinkedApps.
@objc
public class DBXTeamListTeamAppsResult: NSObject {
    /// The linked applications of each member of the team.
    @objc
    public var apps: [DBXTeamMemberLinkedApps] { swift.apps.map { DBXTeamMemberLinkedApps(swift: $0) } }
    /// If true, then there are more apps available. Pass the cursor to linkedAppsListTeamLinkedApps to retrieve the
    /// rest.
    @objc
    public var hasMore: NSNumber { swift.hasMore as NSNumber }
    /// Pass the cursor into linkedAppsListTeamLinkedApps to receive the next sub list of team's applications.
    @objc
    public var cursor: String? { swift.cursor }

    @objc
    public init(apps: [DBXTeamMemberLinkedApps], hasMore: NSNumber, cursor: String?) {
        self.swift = Team.ListTeamAppsResult(apps: apps.map(\.swift), hasMore: hasMore.boolValue, cursor: cursor)
    }

    let swift: Team.ListTeamAppsResult

    public init(swift: Team.ListTeamAppsResult) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible ListTeamDevicesArg struct
@objc
public class DBXTeamListTeamDevicesArg: NSObject {
    /// At the first call to the devicesListTeamDevices the cursor shouldn't be passed. Then, if the result of the
    /// call includes a cursor, the following requests should include the received cursors in order to receive
    /// the next sub list of team devices.
    @objc
    public var cursor: String? { swift.cursor }
    /// Whether to list web sessions of the team members.
    @objc
    public var includeWebSessions: NSNumber { swift.includeWebSessions as NSNumber }
    /// Whether to list desktop clients of the team members.
    @objc
    public var includeDesktopClients: NSNumber { swift.includeDesktopClients as NSNumber }
    /// Whether to list mobile clients of the team members.
    @objc
    public var includeMobileClients: NSNumber { swift.includeMobileClients as NSNumber }

    @objc
    public init(cursor: String?, includeWebSessions: NSNumber, includeDesktopClients: NSNumber, includeMobileClients: NSNumber) {
        self.swift = Team.ListTeamDevicesArg(
            cursor: cursor,
            includeWebSessions: includeWebSessions.boolValue,
            includeDesktopClients: includeDesktopClients.boolValue,
            includeMobileClients: includeMobileClients.boolValue
        )
    }

    let swift: Team.ListTeamDevicesArg

    public init(swift: Team.ListTeamDevicesArg) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible ListTeamDevicesError union
@objc
public class DBXTeamListTeamDevicesError: NSObject {
    let swift: Team.ListTeamDevicesError

    public init(swift: Team.ListTeamDevicesError) {
        self.swift = swift
    }

    public static func factory(swift: Team.ListTeamDevicesError) -> DBXTeamListTeamDevicesError {
        switch swift {
        case .reset:
            return DBXTeamListTeamDevicesErrorReset()
        case .other:
            return DBXTeamListTeamDevicesErrorOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asReset: DBXTeamListTeamDevicesErrorReset? {
        self as? DBXTeamListTeamDevicesErrorReset
    }

    @objc
    public var asOther: DBXTeamListTeamDevicesErrorOther? {
        self as? DBXTeamListTeamDevicesErrorOther
    }
}

/// Indicates that the cursor has been invalidated. Call devicesListTeamDevices again with an empty cursor to
/// obtain a new cursor.
@objc
public class DBXTeamListTeamDevicesErrorReset: DBXTeamListTeamDevicesError {
    @objc
    public init() {
        let swift = Team.ListTeamDevicesError.reset
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXTeamListTeamDevicesErrorOther: DBXTeamListTeamDevicesError {
    @objc
    public init() {
        let swift = Team.ListTeamDevicesError.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible ListTeamDevicesResult struct
@objc
public class DBXTeamListTeamDevicesResult: NSObject {
    /// The devices of each member of the team.
    @objc
    public var devices: [DBXTeamMemberDevices] { swift.devices.map { DBXTeamMemberDevices(swift: $0) } }
    /// If true, then there are more devices available. Pass the cursor to devicesListTeamDevices to retrieve the
    /// rest.
    @objc
    public var hasMore: NSNumber { swift.hasMore as NSNumber }
    /// Pass the cursor into devicesListTeamDevices to receive the next sub list of team's devices.
    @objc
    public var cursor: String? { swift.cursor }

    @objc
    public init(devices: [DBXTeamMemberDevices], hasMore: NSNumber, cursor: String?) {
        self.swift = Team.ListTeamDevicesResult(devices: devices.map(\.swift), hasMore: hasMore.boolValue, cursor: cursor)
    }

    let swift: Team.ListTeamDevicesResult

    public init(swift: Team.ListTeamDevicesResult) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Specify access type a member should have when joined to a group.
@objc
public class DBXTeamMemberAccess: NSObject {
    /// Identity of a user.
    @objc
    public var user: DBXTeamUserSelectorArg { DBXTeamUserSelectorArg(swift: swift.user) }
    /// Access type.
    @objc
    public var accessType: DBXTeamGroupAccessType { DBXTeamGroupAccessType(swift: swift.accessType) }

    @objc
    public init(user: DBXTeamUserSelectorArg, accessType: DBXTeamGroupAccessType) {
        self.swift = Team.MemberAccess(user: user.swift, accessType: accessType.swift)
    }

    let swift: Team.MemberAccess

    public init(swift: Team.MemberAccess) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible MemberAddArgBase struct
@objc
public class DBXTeamMemberAddArgBase: NSObject {
    /// (no description)
    @objc
    public var memberEmail: String { swift.memberEmail }
    /// Member's first name.
    @objc
    public var memberGivenName: String? { swift.memberGivenName }
    /// Member's last name.
    @objc
    public var memberSurname: String? { swift.memberSurname }
    /// External ID for member.
    @objc
    public var memberExternalId: String? { swift.memberExternalId }
    /// Persistent ID for member. This field is only available to teams using persistent ID SAML configuration.
    @objc
    public var memberPersistentId: String? { swift.memberPersistentId }
    /// Whether to send a welcome email to the member. If send_welcome_email is false, no email invitation will be
    /// sent to the user. This may be useful for apps using single sign-on (SSO) flows for onboarding that want
    /// to handle announcements themselves.
    @objc
    public var sendWelcomeEmail: NSNumber { swift.sendWelcomeEmail as NSNumber }
    /// Whether a user is directory restricted.
    @objc
    public var isDirectoryRestricted: NSNumber? { swift.isDirectoryRestricted as NSNumber? }

    @objc
    public init(
        memberEmail: String,
        memberGivenName: String?,
        memberSurname: String?,
        memberExternalId: String?,
        memberPersistentId: String?,
        sendWelcomeEmail: NSNumber,
        isDirectoryRestricted: NSNumber?
    ) {
        self.swift = Team.MemberAddArgBase(
            memberEmail: memberEmail,
            memberGivenName: memberGivenName,
            memberSurname: memberSurname,
            memberExternalId: memberExternalId,
            memberPersistentId: memberPersistentId,
            sendWelcomeEmail: sendWelcomeEmail.boolValue,
            isDirectoryRestricted: isDirectoryRestricted?.boolValue
        )
    }

    let swift: Team.MemberAddArgBase

    public init(swift: Team.MemberAddArgBase) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible MemberAddArg struct
@objc
public class DBXTeamMemberAddArg: DBXTeamMemberAddArgBase {
    /// (no description)
    @objc
    public var role: DBXTeamAdminTier { DBXTeamAdminTier(swift: subSwift.role) }

    @objc
    public init(
        memberEmail: String,
        memberGivenName: String?,
        memberSurname: String?,
        memberExternalId: String?,
        memberPersistentId: String?,
        sendWelcomeEmail: NSNumber,
        isDirectoryRestricted: NSNumber?,
        role: DBXTeamAdminTier
    ) {
        let swift = Team.MemberAddArg(
            memberEmail: memberEmail,
            memberGivenName: memberGivenName,
            memberSurname: memberSurname,
            memberExternalId: memberExternalId,
            memberPersistentId: memberPersistentId,
            sendWelcomeEmail: sendWelcomeEmail.boolValue,
            isDirectoryRestricted: isDirectoryRestricted?.boolValue,
            role: role.swift
        )
        self.subSwift = swift
        super.init(swift: swift)
    }

    let subSwift: Team.MemberAddArg

    public init(swift: Team.MemberAddArg) {
        self.subSwift = swift
        super.init(swift: swift)
    }

    @objc
    public override var description: String { subSwift.description }
}

/// Objective-C compatible MemberAddResultBase union
@objc
public class DBXTeamMemberAddResultBase: NSObject {
    let swift: Team.MemberAddResultBase

    public init(swift: Team.MemberAddResultBase) {
        self.swift = swift
    }

    public static func factory(swift: Team.MemberAddResultBase) -> DBXTeamMemberAddResultBase {
        switch swift {
        case .teamLicenseLimit(let swiftArg):
            let arg = swiftArg
            return DBXTeamMemberAddResultBaseTeamLicenseLimit(arg)
        case .freeTeamMemberLimitReached(let swiftArg):
            let arg = swiftArg
            return DBXTeamMemberAddResultBaseFreeTeamMemberLimitReached(arg)
        case .userAlreadyOnTeam(let swiftArg):
            let arg = swiftArg
            return DBXTeamMemberAddResultBaseUserAlreadyOnTeam(arg)
        case .userOnAnotherTeam(let swiftArg):
            let arg = swiftArg
            return DBXTeamMemberAddResultBaseUserOnAnotherTeam(arg)
        case .userAlreadyPaired(let swiftArg):
            let arg = swiftArg
            return DBXTeamMemberAddResultBaseUserAlreadyPaired(arg)
        case .userMigrationFailed(let swiftArg):
            let arg = swiftArg
            return DBXTeamMemberAddResultBaseUserMigrationFailed(arg)
        case .duplicateExternalMemberId(let swiftArg):
            let arg = swiftArg
            return DBXTeamMemberAddResultBaseDuplicateExternalMemberId(arg)
        case .duplicateMemberPersistentId(let swiftArg):
            let arg = swiftArg
            return DBXTeamMemberAddResultBaseDuplicateMemberPersistentId(arg)
        case .persistentIdDisabled(let swiftArg):
            let arg = swiftArg
            return DBXTeamMemberAddResultBasePersistentIdDisabled(arg)
        case .userCreationFailed(let swiftArg):
            let arg = swiftArg
            return DBXTeamMemberAddResultBaseUserCreationFailed(arg)
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asTeamLicenseLimit: DBXTeamMemberAddResultBaseTeamLicenseLimit? {
        self as? DBXTeamMemberAddResultBaseTeamLicenseLimit
    }

    @objc
    public var asFreeTeamMemberLimitReached: DBXTeamMemberAddResultBaseFreeTeamMemberLimitReached? {
        self as? DBXTeamMemberAddResultBaseFreeTeamMemberLimitReached
    }

    @objc
    public var asUserAlreadyOnTeam: DBXTeamMemberAddResultBaseUserAlreadyOnTeam? {
        self as? DBXTeamMemberAddResultBaseUserAlreadyOnTeam
    }

    @objc
    public var asUserOnAnotherTeam: DBXTeamMemberAddResultBaseUserOnAnotherTeam? {
        self as? DBXTeamMemberAddResultBaseUserOnAnotherTeam
    }

    @objc
    public var asUserAlreadyPaired: DBXTeamMemberAddResultBaseUserAlreadyPaired? {
        self as? DBXTeamMemberAddResultBaseUserAlreadyPaired
    }

    @objc
    public var asUserMigrationFailed: DBXTeamMemberAddResultBaseUserMigrationFailed? {
        self as? DBXTeamMemberAddResultBaseUserMigrationFailed
    }

    @objc
    public var asDuplicateExternalMemberId: DBXTeamMemberAddResultBaseDuplicateExternalMemberId? {
        self as? DBXTeamMemberAddResultBaseDuplicateExternalMemberId
    }

    @objc
    public var asDuplicateMemberPersistentId: DBXTeamMemberAddResultBaseDuplicateMemberPersistentId? {
        self as? DBXTeamMemberAddResultBaseDuplicateMemberPersistentId
    }

    @objc
    public var asPersistentIdDisabled: DBXTeamMemberAddResultBasePersistentIdDisabled? {
        self as? DBXTeamMemberAddResultBasePersistentIdDisabled
    }

    @objc
    public var asUserCreationFailed: DBXTeamMemberAddResultBaseUserCreationFailed? {
        self as? DBXTeamMemberAddResultBaseUserCreationFailed
    }
}

/// Team is already full. The organization has no available licenses.
@objc
public class DBXTeamMemberAddResultBaseTeamLicenseLimit: DBXTeamMemberAddResultBase {
    @objc
    public var teamLicenseLimit: String

    @objc
    public init(_ arg: String) {
        self.teamLicenseLimit = arg
        let swift = Team.MemberAddResultBase.teamLicenseLimit(arg)
        super.init(swift: swift)
    }
}

/// Team is already full. The free team member limit has been reached.
@objc
public class DBXTeamMemberAddResultBaseFreeTeamMemberLimitReached: DBXTeamMemberAddResultBase {
    @objc
    public var freeTeamMemberLimitReached: String

    @objc
    public init(_ arg: String) {
        self.freeTeamMemberLimitReached = arg
        let swift = Team.MemberAddResultBase.freeTeamMemberLimitReached(arg)
        super.init(swift: swift)
    }
}

/// User is already on this team. The provided email address is associated with a user who is already a member
/// of (including in recoverable state) or invited to the team.
@objc
public class DBXTeamMemberAddResultBaseUserAlreadyOnTeam: DBXTeamMemberAddResultBase {
    @objc
    public var userAlreadyOnTeam: String

    @objc
    public init(_ arg: String) {
        self.userAlreadyOnTeam = arg
        let swift = Team.MemberAddResultBase.userAlreadyOnTeam(arg)
        super.init(swift: swift)
    }
}

/// User is already on another team. The provided email address is associated with a user that is already a
/// member or invited to another team.
@objc
public class DBXTeamMemberAddResultBaseUserOnAnotherTeam: DBXTeamMemberAddResultBase {
    @objc
    public var userOnAnotherTeam: String

    @objc
    public init(_ arg: String) {
        self.userOnAnotherTeam = arg
        let swift = Team.MemberAddResultBase.userOnAnotherTeam(arg)
        super.init(swift: swift)
    }
}

/// User is already paired.
@objc
public class DBXTeamMemberAddResultBaseUserAlreadyPaired: DBXTeamMemberAddResultBase {
    @objc
    public var userAlreadyPaired: String

    @objc
    public init(_ arg: String) {
        self.userAlreadyPaired = arg
        let swift = Team.MemberAddResultBase.userAlreadyPaired(arg)
        super.init(swift: swift)
    }
}

/// User migration has failed.
@objc
public class DBXTeamMemberAddResultBaseUserMigrationFailed: DBXTeamMemberAddResultBase {
    @objc
    public var userMigrationFailed: String

    @objc
    public init(_ arg: String) {
        self.userMigrationFailed = arg
        let swift = Team.MemberAddResultBase.userMigrationFailed(arg)
        super.init(swift: swift)
    }
}

/// A user with the given external member ID already exists on the team (including in recoverable state).
@objc
public class DBXTeamMemberAddResultBaseDuplicateExternalMemberId: DBXTeamMemberAddResultBase {
    @objc
    public var duplicateExternalMemberId: String

    @objc
    public init(_ arg: String) {
        self.duplicateExternalMemberId = arg
        let swift = Team.MemberAddResultBase.duplicateExternalMemberId(arg)
        super.init(swift: swift)
    }
}

/// A user with the given persistent ID already exists on the team (including in recoverable state).
@objc
public class DBXTeamMemberAddResultBaseDuplicateMemberPersistentId: DBXTeamMemberAddResultBase {
    @objc
    public var duplicateMemberPersistentId: String

    @objc
    public init(_ arg: String) {
        self.duplicateMemberPersistentId = arg
        let swift = Team.MemberAddResultBase.duplicateMemberPersistentId(arg)
        super.init(swift: swift)
    }
}

/// Persistent ID is only available to teams with persistent ID SAML configuration. Please contact Dropbox for
/// more information.
@objc
public class DBXTeamMemberAddResultBasePersistentIdDisabled: DBXTeamMemberAddResultBase {
    @objc
    public var persistentIdDisabled: String

    @objc
    public init(_ arg: String) {
        self.persistentIdDisabled = arg
        let swift = Team.MemberAddResultBase.persistentIdDisabled(arg)
        super.init(swift: swift)
    }
}

/// User creation has failed.
@objc
public class DBXTeamMemberAddResultBaseUserCreationFailed: DBXTeamMemberAddResultBase {
    @objc
    public var userCreationFailed: String

    @objc
    public init(_ arg: String) {
        self.userCreationFailed = arg
        let swift = Team.MemberAddResultBase.userCreationFailed(arg)
        super.init(swift: swift)
    }
}

/// Describes the result of attempting to add a single user to the team. 'success' is the only value indicating that
/// a user was indeed added to the team - the other values explain the type of failure that occurred, and include
/// the email of the user for which the operation has failed.
@objc
public class DBXTeamMemberAddResult: NSObject {
    let swift: Team.MemberAddResult

    public init(swift: Team.MemberAddResult) {
        self.swift = swift
    }

    public static func factory(swift: Team.MemberAddResult) -> DBXTeamMemberAddResult {
        switch swift {
        case .teamLicenseLimit(let swiftArg):
            let arg = swiftArg
            return DBXTeamMemberAddResultTeamLicenseLimit(arg)
        case .freeTeamMemberLimitReached(let swiftArg):
            let arg = swiftArg
            return DBXTeamMemberAddResultFreeTeamMemberLimitReached(arg)
        case .userAlreadyOnTeam(let swiftArg):
            let arg = swiftArg
            return DBXTeamMemberAddResultUserAlreadyOnTeam(arg)
        case .userOnAnotherTeam(let swiftArg):
            let arg = swiftArg
            return DBXTeamMemberAddResultUserOnAnotherTeam(arg)
        case .userAlreadyPaired(let swiftArg):
            let arg = swiftArg
            return DBXTeamMemberAddResultUserAlreadyPaired(arg)
        case .userMigrationFailed(let swiftArg):
            let arg = swiftArg
            return DBXTeamMemberAddResultUserMigrationFailed(arg)
        case .duplicateExternalMemberId(let swiftArg):
            let arg = swiftArg
            return DBXTeamMemberAddResultDuplicateExternalMemberId(arg)
        case .duplicateMemberPersistentId(let swiftArg):
            let arg = swiftArg
            return DBXTeamMemberAddResultDuplicateMemberPersistentId(arg)
        case .persistentIdDisabled(let swiftArg):
            let arg = swiftArg
            return DBXTeamMemberAddResultPersistentIdDisabled(arg)
        case .userCreationFailed(let swiftArg):
            let arg = swiftArg
            return DBXTeamMemberAddResultUserCreationFailed(arg)
        case .success(let swiftArg):
            let arg = DBXTeamTeamMemberInfo(swift: swiftArg)
            return DBXTeamMemberAddResultSuccess(arg)
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asTeamLicenseLimit: DBXTeamMemberAddResultTeamLicenseLimit? {
        self as? DBXTeamMemberAddResultTeamLicenseLimit
    }

    @objc
    public var asFreeTeamMemberLimitReached: DBXTeamMemberAddResultFreeTeamMemberLimitReached? {
        self as? DBXTeamMemberAddResultFreeTeamMemberLimitReached
    }

    @objc
    public var asUserAlreadyOnTeam: DBXTeamMemberAddResultUserAlreadyOnTeam? {
        self as? DBXTeamMemberAddResultUserAlreadyOnTeam
    }

    @objc
    public var asUserOnAnotherTeam: DBXTeamMemberAddResultUserOnAnotherTeam? {
        self as? DBXTeamMemberAddResultUserOnAnotherTeam
    }

    @objc
    public var asUserAlreadyPaired: DBXTeamMemberAddResultUserAlreadyPaired? {
        self as? DBXTeamMemberAddResultUserAlreadyPaired
    }

    @objc
    public var asUserMigrationFailed: DBXTeamMemberAddResultUserMigrationFailed? {
        self as? DBXTeamMemberAddResultUserMigrationFailed
    }

    @objc
    public var asDuplicateExternalMemberId: DBXTeamMemberAddResultDuplicateExternalMemberId? {
        self as? DBXTeamMemberAddResultDuplicateExternalMemberId
    }

    @objc
    public var asDuplicateMemberPersistentId: DBXTeamMemberAddResultDuplicateMemberPersistentId? {
        self as? DBXTeamMemberAddResultDuplicateMemberPersistentId
    }

    @objc
    public var asPersistentIdDisabled: DBXTeamMemberAddResultPersistentIdDisabled? {
        self as? DBXTeamMemberAddResultPersistentIdDisabled
    }

    @objc
    public var asUserCreationFailed: DBXTeamMemberAddResultUserCreationFailed? {
        self as? DBXTeamMemberAddResultUserCreationFailed
    }

    @objc
    public var asSuccess: DBXTeamMemberAddResultSuccess? {
        self as? DBXTeamMemberAddResultSuccess
    }
}

/// Team is already full. The organization has no available licenses.
@objc
public class DBXTeamMemberAddResultTeamLicenseLimit: DBXTeamMemberAddResult {
    @objc
    public var teamLicenseLimit: String

    @objc
    public init(_ arg: String) {
        self.teamLicenseLimit = arg
        let swift = Team.MemberAddResult.teamLicenseLimit(arg)
        super.init(swift: swift)
    }
}

/// Team is already full. The free team member limit has been reached.
@objc
public class DBXTeamMemberAddResultFreeTeamMemberLimitReached: DBXTeamMemberAddResult {
    @objc
    public var freeTeamMemberLimitReached: String

    @objc
    public init(_ arg: String) {
        self.freeTeamMemberLimitReached = arg
        let swift = Team.MemberAddResult.freeTeamMemberLimitReached(arg)
        super.init(swift: swift)
    }
}

/// User is already on this team. The provided email address is associated with a user who is already a member
/// of (including in recoverable state) or invited to the team.
@objc
public class DBXTeamMemberAddResultUserAlreadyOnTeam: DBXTeamMemberAddResult {
    @objc
    public var userAlreadyOnTeam: String

    @objc
    public init(_ arg: String) {
        self.userAlreadyOnTeam = arg
        let swift = Team.MemberAddResult.userAlreadyOnTeam(arg)
        super.init(swift: swift)
    }
}

/// User is already on another team. The provided email address is associated with a user that is already a
/// member or invited to another team.
@objc
public class DBXTeamMemberAddResultUserOnAnotherTeam: DBXTeamMemberAddResult {
    @objc
    public var userOnAnotherTeam: String

    @objc
    public init(_ arg: String) {
        self.userOnAnotherTeam = arg
        let swift = Team.MemberAddResult.userOnAnotherTeam(arg)
        super.init(swift: swift)
    }
}

/// User is already paired.
@objc
public class DBXTeamMemberAddResultUserAlreadyPaired: DBXTeamMemberAddResult {
    @objc
    public var userAlreadyPaired: String

    @objc
    public init(_ arg: String) {
        self.userAlreadyPaired = arg
        let swift = Team.MemberAddResult.userAlreadyPaired(arg)
        super.init(swift: swift)
    }
}

/// User migration has failed.
@objc
public class DBXTeamMemberAddResultUserMigrationFailed: DBXTeamMemberAddResult {
    @objc
    public var userMigrationFailed: String

    @objc
    public init(_ arg: String) {
        self.userMigrationFailed = arg
        let swift = Team.MemberAddResult.userMigrationFailed(arg)
        super.init(swift: swift)
    }
}

/// A user with the given external member ID already exists on the team (including in recoverable state).
@objc
public class DBXTeamMemberAddResultDuplicateExternalMemberId: DBXTeamMemberAddResult {
    @objc
    public var duplicateExternalMemberId: String

    @objc
    public init(_ arg: String) {
        self.duplicateExternalMemberId = arg
        let swift = Team.MemberAddResult.duplicateExternalMemberId(arg)
        super.init(swift: swift)
    }
}

/// A user with the given persistent ID already exists on the team (including in recoverable state).
@objc
public class DBXTeamMemberAddResultDuplicateMemberPersistentId: DBXTeamMemberAddResult {
    @objc
    public var duplicateMemberPersistentId: String

    @objc
    public init(_ arg: String) {
        self.duplicateMemberPersistentId = arg
        let swift = Team.MemberAddResult.duplicateMemberPersistentId(arg)
        super.init(swift: swift)
    }
}

/// Persistent ID is only available to teams with persistent ID SAML configuration. Please contact Dropbox for
/// more information.
@objc
public class DBXTeamMemberAddResultPersistentIdDisabled: DBXTeamMemberAddResult {
    @objc
    public var persistentIdDisabled: String

    @objc
    public init(_ arg: String) {
        self.persistentIdDisabled = arg
        let swift = Team.MemberAddResult.persistentIdDisabled(arg)
        super.init(swift: swift)
    }
}

/// User creation has failed.
@objc
public class DBXTeamMemberAddResultUserCreationFailed: DBXTeamMemberAddResult {
    @objc
    public var userCreationFailed: String

    @objc
    public init(_ arg: String) {
        self.userCreationFailed = arg
        let swift = Team.MemberAddResult.userCreationFailed(arg)
        super.init(swift: swift)
    }
}

/// Describes a user that was successfully added to the team.
@objc
public class DBXTeamMemberAddResultSuccess: DBXTeamMemberAddResult {
    @objc
    public var success: DBXTeamTeamMemberInfo

    @objc
    public init(_ arg: DBXTeamTeamMemberInfo) {
        self.success = arg
        let swift = Team.MemberAddResult.success(arg.swift)
        super.init(swift: swift)
    }
}

/// Objective-C compatible MemberAddV2Arg struct
@objc
public class DBXTeamMemberAddV2Arg: DBXTeamMemberAddArgBase {
    /// (no description)
    @objc
    public var roleIds: [String]? { subSwift.roleIds }

    @objc
    public init(
        memberEmail: String,
        memberGivenName: String?,
        memberSurname: String?,
        memberExternalId: String?,
        memberPersistentId: String?,
        sendWelcomeEmail: NSNumber,
        isDirectoryRestricted: NSNumber?,
        roleIds: [String]?
    ) {
        let swift = Team.MemberAddV2Arg(
            memberEmail: memberEmail,
            memberGivenName: memberGivenName,
            memberSurname: memberSurname,
            memberExternalId: memberExternalId,
            memberPersistentId: memberPersistentId,
            sendWelcomeEmail: sendWelcomeEmail.boolValue,
            isDirectoryRestricted: isDirectoryRestricted?.boolValue,
            roleIds: roleIds
        )
        self.subSwift = swift
        super.init(swift: swift)
    }

    let subSwift: Team.MemberAddV2Arg

    public init(swift: Team.MemberAddV2Arg) {
        self.subSwift = swift
        super.init(swift: swift)
    }

    @objc
    public override var description: String { subSwift.description }
}

/// Describes the result of attempting to add a single user to the team. 'success' is the only value indicating that
/// a user was indeed added to the team - the other values explain the type of failure that occurred, and include
/// the email of the user for which the operation has failed.
@objc
public class DBXTeamMemberAddV2Result: NSObject {
    let swift: Team.MemberAddV2Result

    public init(swift: Team.MemberAddV2Result) {
        self.swift = swift
    }

    public static func factory(swift: Team.MemberAddV2Result) -> DBXTeamMemberAddV2Result {
        switch swift {
        case .teamLicenseLimit(let swiftArg):
            let arg = swiftArg
            return DBXTeamMemberAddV2ResultTeamLicenseLimit(arg)
        case .freeTeamMemberLimitReached(let swiftArg):
            let arg = swiftArg
            return DBXTeamMemberAddV2ResultFreeTeamMemberLimitReached(arg)
        case .userAlreadyOnTeam(let swiftArg):
            let arg = swiftArg
            return DBXTeamMemberAddV2ResultUserAlreadyOnTeam(arg)
        case .userOnAnotherTeam(let swiftArg):
            let arg = swiftArg
            return DBXTeamMemberAddV2ResultUserOnAnotherTeam(arg)
        case .userAlreadyPaired(let swiftArg):
            let arg = swiftArg
            return DBXTeamMemberAddV2ResultUserAlreadyPaired(arg)
        case .userMigrationFailed(let swiftArg):
            let arg = swiftArg
            return DBXTeamMemberAddV2ResultUserMigrationFailed(arg)
        case .duplicateExternalMemberId(let swiftArg):
            let arg = swiftArg
            return DBXTeamMemberAddV2ResultDuplicateExternalMemberId(arg)
        case .duplicateMemberPersistentId(let swiftArg):
            let arg = swiftArg
            return DBXTeamMemberAddV2ResultDuplicateMemberPersistentId(arg)
        case .persistentIdDisabled(let swiftArg):
            let arg = swiftArg
            return DBXTeamMemberAddV2ResultPersistentIdDisabled(arg)
        case .userCreationFailed(let swiftArg):
            let arg = swiftArg
            return DBXTeamMemberAddV2ResultUserCreationFailed(arg)
        case .success(let swiftArg):
            let arg = DBXTeamTeamMemberInfoV2(swift: swiftArg)
            return DBXTeamMemberAddV2ResultSuccess(arg)
        case .other:
            return DBXTeamMemberAddV2ResultOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asTeamLicenseLimit: DBXTeamMemberAddV2ResultTeamLicenseLimit? {
        self as? DBXTeamMemberAddV2ResultTeamLicenseLimit
    }

    @objc
    public var asFreeTeamMemberLimitReached: DBXTeamMemberAddV2ResultFreeTeamMemberLimitReached? {
        self as? DBXTeamMemberAddV2ResultFreeTeamMemberLimitReached
    }

    @objc
    public var asUserAlreadyOnTeam: DBXTeamMemberAddV2ResultUserAlreadyOnTeam? {
        self as? DBXTeamMemberAddV2ResultUserAlreadyOnTeam
    }

    @objc
    public var asUserOnAnotherTeam: DBXTeamMemberAddV2ResultUserOnAnotherTeam? {
        self as? DBXTeamMemberAddV2ResultUserOnAnotherTeam
    }

    @objc
    public var asUserAlreadyPaired: DBXTeamMemberAddV2ResultUserAlreadyPaired? {
        self as? DBXTeamMemberAddV2ResultUserAlreadyPaired
    }

    @objc
    public var asUserMigrationFailed: DBXTeamMemberAddV2ResultUserMigrationFailed? {
        self as? DBXTeamMemberAddV2ResultUserMigrationFailed
    }

    @objc
    public var asDuplicateExternalMemberId: DBXTeamMemberAddV2ResultDuplicateExternalMemberId? {
        self as? DBXTeamMemberAddV2ResultDuplicateExternalMemberId
    }

    @objc
    public var asDuplicateMemberPersistentId: DBXTeamMemberAddV2ResultDuplicateMemberPersistentId? {
        self as? DBXTeamMemberAddV2ResultDuplicateMemberPersistentId
    }

    @objc
    public var asPersistentIdDisabled: DBXTeamMemberAddV2ResultPersistentIdDisabled? {
        self as? DBXTeamMemberAddV2ResultPersistentIdDisabled
    }

    @objc
    public var asUserCreationFailed: DBXTeamMemberAddV2ResultUserCreationFailed? {
        self as? DBXTeamMemberAddV2ResultUserCreationFailed
    }

    @objc
    public var asSuccess: DBXTeamMemberAddV2ResultSuccess? {
        self as? DBXTeamMemberAddV2ResultSuccess
    }

    @objc
    public var asOther: DBXTeamMemberAddV2ResultOther? {
        self as? DBXTeamMemberAddV2ResultOther
    }
}

/// Team is already full. The organization has no available licenses.
@objc
public class DBXTeamMemberAddV2ResultTeamLicenseLimit: DBXTeamMemberAddV2Result {
    @objc
    public var teamLicenseLimit: String

    @objc
    public init(_ arg: String) {
        self.teamLicenseLimit = arg
        let swift = Team.MemberAddV2Result.teamLicenseLimit(arg)
        super.init(swift: swift)
    }
}

/// Team is already full. The free team member limit has been reached.
@objc
public class DBXTeamMemberAddV2ResultFreeTeamMemberLimitReached: DBXTeamMemberAddV2Result {
    @objc
    public var freeTeamMemberLimitReached: String

    @objc
    public init(_ arg: String) {
        self.freeTeamMemberLimitReached = arg
        let swift = Team.MemberAddV2Result.freeTeamMemberLimitReached(arg)
        super.init(swift: swift)
    }
}

/// User is already on this team. The provided email address is associated with a user who is already a member
/// of (including in recoverable state) or invited to the team.
@objc
public class DBXTeamMemberAddV2ResultUserAlreadyOnTeam: DBXTeamMemberAddV2Result {
    @objc
    public var userAlreadyOnTeam: String

    @objc
    public init(_ arg: String) {
        self.userAlreadyOnTeam = arg
        let swift = Team.MemberAddV2Result.userAlreadyOnTeam(arg)
        super.init(swift: swift)
    }
}

/// User is already on another team. The provided email address is associated with a user that is already a
/// member or invited to another team.
@objc
public class DBXTeamMemberAddV2ResultUserOnAnotherTeam: DBXTeamMemberAddV2Result {
    @objc
    public var userOnAnotherTeam: String

    @objc
    public init(_ arg: String) {
        self.userOnAnotherTeam = arg
        let swift = Team.MemberAddV2Result.userOnAnotherTeam(arg)
        super.init(swift: swift)
    }
}

/// User is already paired.
@objc
public class DBXTeamMemberAddV2ResultUserAlreadyPaired: DBXTeamMemberAddV2Result {
    @objc
    public var userAlreadyPaired: String

    @objc
    public init(_ arg: String) {
        self.userAlreadyPaired = arg
        let swift = Team.MemberAddV2Result.userAlreadyPaired(arg)
        super.init(swift: swift)
    }
}

/// User migration has failed.
@objc
public class DBXTeamMemberAddV2ResultUserMigrationFailed: DBXTeamMemberAddV2Result {
    @objc
    public var userMigrationFailed: String

    @objc
    public init(_ arg: String) {
        self.userMigrationFailed = arg
        let swift = Team.MemberAddV2Result.userMigrationFailed(arg)
        super.init(swift: swift)
    }
}

/// A user with the given external member ID already exists on the team (including in recoverable state).
@objc
public class DBXTeamMemberAddV2ResultDuplicateExternalMemberId: DBXTeamMemberAddV2Result {
    @objc
    public var duplicateExternalMemberId: String

    @objc
    public init(_ arg: String) {
        self.duplicateExternalMemberId = arg
        let swift = Team.MemberAddV2Result.duplicateExternalMemberId(arg)
        super.init(swift: swift)
    }
}

/// A user with the given persistent ID already exists on the team (including in recoverable state).
@objc
public class DBXTeamMemberAddV2ResultDuplicateMemberPersistentId: DBXTeamMemberAddV2Result {
    @objc
    public var duplicateMemberPersistentId: String

    @objc
    public init(_ arg: String) {
        self.duplicateMemberPersistentId = arg
        let swift = Team.MemberAddV2Result.duplicateMemberPersistentId(arg)
        super.init(swift: swift)
    }
}

/// Persistent ID is only available to teams with persistent ID SAML configuration. Please contact Dropbox for
/// more information.
@objc
public class DBXTeamMemberAddV2ResultPersistentIdDisabled: DBXTeamMemberAddV2Result {
    @objc
    public var persistentIdDisabled: String

    @objc
    public init(_ arg: String) {
        self.persistentIdDisabled = arg
        let swift = Team.MemberAddV2Result.persistentIdDisabled(arg)
        super.init(swift: swift)
    }
}

/// User creation has failed.
@objc
public class DBXTeamMemberAddV2ResultUserCreationFailed: DBXTeamMemberAddV2Result {
    @objc
    public var userCreationFailed: String

    @objc
    public init(_ arg: String) {
        self.userCreationFailed = arg
        let swift = Team.MemberAddV2Result.userCreationFailed(arg)
        super.init(swift: swift)
    }
}

/// Describes a user that was successfully added to the team.
@objc
public class DBXTeamMemberAddV2ResultSuccess: DBXTeamMemberAddV2Result {
    @objc
    public var success: DBXTeamTeamMemberInfoV2

    @objc
    public init(_ arg: DBXTeamTeamMemberInfoV2) {
        self.success = arg
        let swift = Team.MemberAddV2Result.success(arg.swift)
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXTeamMemberAddV2ResultOther: DBXTeamMemberAddV2Result {
    @objc
    public init() {
        let swift = Team.MemberAddV2Result.other
        super.init(swift: swift)
    }
}

/// Information on devices of a team's member.
@objc
public class DBXTeamMemberDevices: NSObject {
    /// The member unique Id.
    @objc
    public var teamMemberId: String { swift.teamMemberId }
    /// List of web sessions made by this team member.
    @objc
    public var webSessions: [DBXTeamActiveWebSession]? { swift.webSessions?.map { DBXTeamActiveWebSession(swift: $0) } }
    /// List of desktop clients by this team member.
    @objc
    public var desktopClients: [DBXTeamDesktopClientSession]? { swift.desktopClients?.map { DBXTeamDesktopClientSession(swift: $0) } }
    /// List of mobile clients by this team member.
    @objc
    public var mobileClients: [DBXTeamMobileClientSession]? { swift.mobileClients?.map { DBXTeamMobileClientSession(swift: $0) } }

    @objc
    public init(
        teamMemberId: String,
        webSessions: [DBXTeamActiveWebSession]?,
        desktopClients: [DBXTeamDesktopClientSession]?,
        mobileClients: [DBXTeamMobileClientSession]?
    ) {
        self.swift = Team.MemberDevices(
            teamMemberId: teamMemberId,
            webSessions: webSessions?.map(\.subSwift),
            desktopClients: desktopClients?.map(\.subSwift),
            mobileClients: mobileClients?.map(\.subSwift)
        )
    }

    let swift: Team.MemberDevices

    public init(swift: Team.MemberDevices) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Information on linked applications of a team member.
@objc
public class DBXTeamMemberLinkedApps: NSObject {
    /// The member unique Id.
    @objc
    public var teamMemberId: String { swift.teamMemberId }
    /// List of third party applications linked by this team member.
    @objc
    public var linkedApiApps: [DBXTeamApiApp] { swift.linkedApiApps.map { DBXTeamApiApp(swift: $0) } }

    @objc
    public init(teamMemberId: String, linkedApiApps: [DBXTeamApiApp]) {
        self.swift = Team.MemberLinkedApps(teamMemberId: teamMemberId, linkedApiApps: linkedApiApps.map(\.swift))
    }

    let swift: Team.MemberLinkedApps

    public init(swift: Team.MemberLinkedApps) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Basic member profile.
@objc
public class DBXTeamMemberProfile: NSObject {
    /// ID of user as a member of a team.
    @objc
    public var teamMemberId: String { swift.teamMemberId }
    /// External ID that a team can attach to the user. An application using the API may find it easier to use their
    /// own IDs instead of Dropbox IDs like account_id or team_member_id.
    @objc
    public var externalId: String? { swift.externalId }
    /// A user's account identifier.
    @objc
    public var accountId: String? { swift.accountId }
    /// Email address of user.
    @objc
    public var email: String { swift.email }
    /// Is true if the user's email is verified to be owned by the user.
    @objc
    public var emailVerified: NSNumber { swift.emailVerified as NSNumber }
    /// Secondary emails of a user.
    @objc
    public var secondaryEmails: [DBXSecondaryEmailsSecondaryEmail]? { swift.secondaryEmails?.map { DBXSecondaryEmailsSecondaryEmail(swift: $0) } }
    /// The user's status as a member of a specific team.
    @objc
    public var status: DBXTeamTeamMemberStatus { DBXTeamTeamMemberStatus(swift: swift.status) }
    /// Representations for a person's name.
    @objc
    public var name: DBXUsersName { DBXUsersName(swift: swift.name) }
    /// The user's membership type: full (normal team member) vs limited (does not use a license; no access to the
    /// team's shared quota).
    @objc
    public var membershipType: DBXTeamTeamMembershipType { DBXTeamTeamMembershipType(swift: swift.membershipType) }
    /// The date and time the user was invited to the team (contains value only when the member's status matches
    /// invited in TeamMemberStatus).
    @objc
    public var invitedOn: Date? { swift.invitedOn }
    /// The date and time the user joined as a member of a specific team.
    @objc
    public var joinedOn: Date? { swift.joinedOn }
    /// The date and time the user was suspended from the team (contains value only when the member's status matches
    /// suspended in TeamMemberStatus).
    @objc
    public var suspendedOn: Date? { swift.suspendedOn }
    /// Persistent ID that a team can attach to the user. The persistent ID is unique ID to be used for SAML
    /// authentication.
    @objc
    public var persistentId: String? { swift.persistentId }
    /// Whether the user is a directory restricted user.
    @objc
    public var isDirectoryRestricted: NSNumber? { swift.isDirectoryRestricted as NSNumber? }
    /// URL for the photo representing the user, if one is set.
    @objc
    public var profilePhotoUrl: String? { swift.profilePhotoUrl }

    @objc
    public init(
        teamMemberId: String,
        email: String,
        emailVerified: NSNumber,
        status: DBXTeamTeamMemberStatus,
        name: DBXUsersName,
        membershipType: DBXTeamTeamMembershipType,
        externalId: String?,
        accountId: String?,
        secondaryEmails: [DBXSecondaryEmailsSecondaryEmail]?,
        invitedOn: Date?,
        joinedOn: Date?,
        suspendedOn: Date?,
        persistentId: String?,
        isDirectoryRestricted: NSNumber?,
        profilePhotoUrl: String?
    ) {
        self.swift = Team.MemberProfile(
            teamMemberId: teamMemberId,
            email: email,
            emailVerified: emailVerified.boolValue,
            status: status.swift,
            name: name.swift,
            membershipType: membershipType.swift,
            externalId: externalId,
            accountId: accountId,
            secondaryEmails: secondaryEmails?.map(\.swift),
            invitedOn: invitedOn,
            joinedOn: joinedOn,
            suspendedOn: suspendedOn,
            persistentId: persistentId,
            isDirectoryRestricted: isDirectoryRestricted?.boolValue,
            profilePhotoUrl: profilePhotoUrl
        )
    }

    let swift: Team.MemberProfile

    public init(swift: Team.MemberProfile) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Error that can be returned whenever a struct derived from UserSelectorArg is used.
@objc
public class DBXTeamUserSelectorError: NSObject {
    let swift: Team.UserSelectorError

    public init(swift: Team.UserSelectorError) {
        self.swift = swift
    }

    public static func factory(swift: Team.UserSelectorError) -> DBXTeamUserSelectorError {
        switch swift {
        case .userNotFound:
            return DBXTeamUserSelectorErrorUserNotFound()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asUserNotFound: DBXTeamUserSelectorErrorUserNotFound? {
        self as? DBXTeamUserSelectorErrorUserNotFound
    }
}

/// No matching user found. The provided team_member_id, email, or external_id does not exist on this team.
@objc
public class DBXTeamUserSelectorErrorUserNotFound: DBXTeamUserSelectorError {
    @objc
    public init() {
        let swift = Team.UserSelectorError.userNotFound
        super.init(swift: swift)
    }
}

/// Objective-C compatible MemberSelectorError union
@objc
public class DBXTeamMemberSelectorError: NSObject {
    let swift: Team.MemberSelectorError

    public init(swift: Team.MemberSelectorError) {
        self.swift = swift
    }

    public static func factory(swift: Team.MemberSelectorError) -> DBXTeamMemberSelectorError {
        switch swift {
        case .userNotFound:
            return DBXTeamMemberSelectorErrorUserNotFound()
        case .userNotInTeam:
            return DBXTeamMemberSelectorErrorUserNotInTeam()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asUserNotFound: DBXTeamMemberSelectorErrorUserNotFound? {
        self as? DBXTeamMemberSelectorErrorUserNotFound
    }

    @objc
    public var asUserNotInTeam: DBXTeamMemberSelectorErrorUserNotInTeam? {
        self as? DBXTeamMemberSelectorErrorUserNotInTeam
    }
}

/// No matching user found. The provided team_member_id, email, or external_id does not exist on this team.
@objc
public class DBXTeamMemberSelectorErrorUserNotFound: DBXTeamMemberSelectorError {
    @objc
    public init() {
        let swift = Team.MemberSelectorError.userNotFound
        super.init(swift: swift)
    }
}

/// The user is not a member of the team.
@objc
public class DBXTeamMemberSelectorErrorUserNotInTeam: DBXTeamMemberSelectorError {
    @objc
    public init() {
        let swift = Team.MemberSelectorError.userNotInTeam
        super.init(swift: swift)
    }
}

/// Objective-C compatible MembersAddArgBase struct
@objc
public class DBXTeamMembersAddArgBase: NSObject {
    /// Whether to force the add to happen asynchronously.
    @objc
    public var forceAsync: NSNumber { swift.forceAsync as NSNumber }

    @objc
    public init(forceAsync: NSNumber) {
        self.swift = Team.MembersAddArgBase(forceAsync: forceAsync.boolValue)
    }

    let swift: Team.MembersAddArgBase

    public init(swift: Team.MembersAddArgBase) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible MembersAddArg struct
@objc
public class DBXTeamMembersAddArg: DBXTeamMembersAddArgBase {
    /// Details of new members to be added to the team.
    @objc
    public var newMembers: [DBXTeamMemberAddArg] { subSwift.newMembers.map { DBXTeamMemberAddArg(swift: $0) } }

    @objc
    public init(newMembers: [DBXTeamMemberAddArg], forceAsync: NSNumber) {
        let swift = Team.MembersAddArg(newMembers: newMembers.map(\.subSwift), forceAsync: forceAsync.boolValue)
        self.subSwift = swift
        super.init(swift: swift)
    }

    let subSwift: Team.MembersAddArg

    public init(swift: Team.MembersAddArg) {
        self.subSwift = swift
        super.init(swift: swift)
    }

    @objc
    public override var description: String { subSwift.description }
}

/// Objective-C compatible MembersAddJobStatus union
@objc
public class DBXTeamMembersAddJobStatus: NSObject {
    let swift: Team.MembersAddJobStatus

    public init(swift: Team.MembersAddJobStatus) {
        self.swift = swift
    }

    public static func factory(swift: Team.MembersAddJobStatus) -> DBXTeamMembersAddJobStatus {
        switch swift {
        case .inProgress:
            return DBXTeamMembersAddJobStatusInProgress()
        case .complete(let swiftArg):
            let arg = swiftArg.map { DBXTeamMemberAddResult.factory(swift: $0) }
            return DBXTeamMembersAddJobStatusComplete(arg)
        case .failed(let swiftArg):
            let arg = swiftArg
            return DBXTeamMembersAddJobStatusFailed(arg)
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asInProgress: DBXTeamMembersAddJobStatusInProgress? {
        self as? DBXTeamMembersAddJobStatusInProgress
    }

    @objc
    public var asComplete: DBXTeamMembersAddJobStatusComplete? {
        self as? DBXTeamMembersAddJobStatusComplete
    }

    @objc
    public var asFailed: DBXTeamMembersAddJobStatusFailed? {
        self as? DBXTeamMembersAddJobStatusFailed
    }
}

/// The asynchronous job is still in progress.
@objc
public class DBXTeamMembersAddJobStatusInProgress: DBXTeamMembersAddJobStatus {
    @objc
    public init() {
        let swift = Team.MembersAddJobStatus.inProgress
        super.init(swift: swift)
    }
}

/// The asynchronous job has finished. For each member that was specified in the parameter MembersAddArg that
/// was provided to membersAdd, a corresponding item is returned in this list.
@objc
public class DBXTeamMembersAddJobStatusComplete: DBXTeamMembersAddJobStatus {
    @objc
    public var complete: [DBXTeamMemberAddResult]

    @objc
    public init(_ arg: [DBXTeamMemberAddResult]) {
        self.complete = arg
        let swift = Team.MembersAddJobStatus.complete(arg.map(\.swift))
        super.init(swift: swift)
    }
}

/// The asynchronous job returned an error. The string contains an error message.
@objc
public class DBXTeamMembersAddJobStatusFailed: DBXTeamMembersAddJobStatus {
    @objc
    public var failed: String

    @objc
    public init(_ arg: String) {
        self.failed = arg
        let swift = Team.MembersAddJobStatus.failed(arg)
        super.init(swift: swift)
    }
}

/// Objective-C compatible MembersAddJobStatusV2Result union
@objc
public class DBXTeamMembersAddJobStatusV2Result: NSObject {
    let swift: Team.MembersAddJobStatusV2Result

    public init(swift: Team.MembersAddJobStatusV2Result) {
        self.swift = swift
    }

    public static func factory(swift: Team.MembersAddJobStatusV2Result) -> DBXTeamMembersAddJobStatusV2Result {
        switch swift {
        case .inProgress:
            return DBXTeamMembersAddJobStatusV2ResultInProgress()
        case .complete(let swiftArg):
            let arg = swiftArg.map { DBXTeamMemberAddV2Result.factory(swift: $0) }
            return DBXTeamMembersAddJobStatusV2ResultComplete(arg)
        case .failed(let swiftArg):
            let arg = swiftArg
            return DBXTeamMembersAddJobStatusV2ResultFailed(arg)
        case .other:
            return DBXTeamMembersAddJobStatusV2ResultOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asInProgress: DBXTeamMembersAddJobStatusV2ResultInProgress? {
        self as? DBXTeamMembersAddJobStatusV2ResultInProgress
    }

    @objc
    public var asComplete: DBXTeamMembersAddJobStatusV2ResultComplete? {
        self as? DBXTeamMembersAddJobStatusV2ResultComplete
    }

    @objc
    public var asFailed: DBXTeamMembersAddJobStatusV2ResultFailed? {
        self as? DBXTeamMembersAddJobStatusV2ResultFailed
    }

    @objc
    public var asOther: DBXTeamMembersAddJobStatusV2ResultOther? {
        self as? DBXTeamMembersAddJobStatusV2ResultOther
    }
}

/// The asynchronous job is still in progress.
@objc
public class DBXTeamMembersAddJobStatusV2ResultInProgress: DBXTeamMembersAddJobStatusV2Result {
    @objc
    public init() {
        let swift = Team.MembersAddJobStatusV2Result.inProgress
        super.init(swift: swift)
    }
}

/// The asynchronous job has finished. For each member that was specified in the parameter MembersAddArg that
/// was provided to membersAddV2, a corresponding item is returned in this list.
@objc
public class DBXTeamMembersAddJobStatusV2ResultComplete: DBXTeamMembersAddJobStatusV2Result {
    @objc
    public var complete: [DBXTeamMemberAddV2Result]

    @objc
    public init(_ arg: [DBXTeamMemberAddV2Result]) {
        self.complete = arg
        let swift = Team.MembersAddJobStatusV2Result.complete(arg.map(\.swift))
        super.init(swift: swift)
    }
}

/// The asynchronous job returned an error. The string contains an error message.
@objc
public class DBXTeamMembersAddJobStatusV2ResultFailed: DBXTeamMembersAddJobStatusV2Result {
    @objc
    public var failed: String

    @objc
    public init(_ arg: String) {
        self.failed = arg
        let swift = Team.MembersAddJobStatusV2Result.failed(arg)
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXTeamMembersAddJobStatusV2ResultOther: DBXTeamMembersAddJobStatusV2Result {
    @objc
    public init() {
        let swift = Team.MembersAddJobStatusV2Result.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible MembersAddLaunch union
@objc
public class DBXTeamMembersAddLaunch: NSObject {
    let swift: Team.MembersAddLaunch

    public init(swift: Team.MembersAddLaunch) {
        self.swift = swift
    }

    public static func factory(swift: Team.MembersAddLaunch) -> DBXTeamMembersAddLaunch {
        switch swift {
        case .asyncJobId(let swiftArg):
            let arg = swiftArg
            return DBXTeamMembersAddLaunchAsyncJobId(arg)
        case .complete(let swiftArg):
            let arg = swiftArg.map { DBXTeamMemberAddResult.factory(swift: $0) }
            return DBXTeamMembersAddLaunchComplete(arg)
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asAsyncJobId: DBXTeamMembersAddLaunchAsyncJobId? {
        self as? DBXTeamMembersAddLaunchAsyncJobId
    }

    @objc
    public var asComplete: DBXTeamMembersAddLaunchComplete? {
        self as? DBXTeamMembersAddLaunchComplete
    }
}

/// This response indicates that the processing is asynchronous. The string is an id that can be used to obtain
/// the status of the asynchronous job.
@objc
public class DBXTeamMembersAddLaunchAsyncJobId: DBXTeamMembersAddLaunch {
    @objc
    public var asyncJobId: String

    @objc
    public init(_ arg: String) {
        self.asyncJobId = arg
        let swift = Team.MembersAddLaunch.asyncJobId(arg)
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXTeamMembersAddLaunchComplete: DBXTeamMembersAddLaunch {
    @objc
    public var complete: [DBXTeamMemberAddResult]

    @objc
    public init(_ arg: [DBXTeamMemberAddResult]) {
        self.complete = arg
        let swift = Team.MembersAddLaunch.complete(arg.map(\.swift))
        super.init(swift: swift)
    }
}

/// Objective-C compatible MembersAddLaunchV2Result union
@objc
public class DBXTeamMembersAddLaunchV2Result: NSObject {
    let swift: Team.MembersAddLaunchV2Result

    public init(swift: Team.MembersAddLaunchV2Result) {
        self.swift = swift
    }

    public static func factory(swift: Team.MembersAddLaunchV2Result) -> DBXTeamMembersAddLaunchV2Result {
        switch swift {
        case .asyncJobId(let swiftArg):
            let arg = swiftArg
            return DBXTeamMembersAddLaunchV2ResultAsyncJobId(arg)
        case .complete(let swiftArg):
            let arg = swiftArg.map { DBXTeamMemberAddV2Result.factory(swift: $0) }
            return DBXTeamMembersAddLaunchV2ResultComplete(arg)
        case .other:
            return DBXTeamMembersAddLaunchV2ResultOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asAsyncJobId: DBXTeamMembersAddLaunchV2ResultAsyncJobId? {
        self as? DBXTeamMembersAddLaunchV2ResultAsyncJobId
    }

    @objc
    public var asComplete: DBXTeamMembersAddLaunchV2ResultComplete? {
        self as? DBXTeamMembersAddLaunchV2ResultComplete
    }

    @objc
    public var asOther: DBXTeamMembersAddLaunchV2ResultOther? {
        self as? DBXTeamMembersAddLaunchV2ResultOther
    }
}

/// This response indicates that the processing is asynchronous. The string is an id that can be used to obtain
/// the status of the asynchronous job.
@objc
public class DBXTeamMembersAddLaunchV2ResultAsyncJobId: DBXTeamMembersAddLaunchV2Result {
    @objc
    public var asyncJobId: String

    @objc
    public init(_ arg: String) {
        self.asyncJobId = arg
        let swift = Team.MembersAddLaunchV2Result.asyncJobId(arg)
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXTeamMembersAddLaunchV2ResultComplete: DBXTeamMembersAddLaunchV2Result {
    @objc
    public var complete: [DBXTeamMemberAddV2Result]

    @objc
    public init(_ arg: [DBXTeamMemberAddV2Result]) {
        self.complete = arg
        let swift = Team.MembersAddLaunchV2Result.complete(arg.map(\.swift))
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXTeamMembersAddLaunchV2ResultOther: DBXTeamMembersAddLaunchV2Result {
    @objc
    public init() {
        let swift = Team.MembersAddLaunchV2Result.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible MembersAddV2Arg struct
@objc
public class DBXTeamMembersAddV2Arg: DBXTeamMembersAddArgBase {
    /// Details of new members to be added to the team.
    @objc
    public var newMembers: [DBXTeamMemberAddV2Arg] { subSwift.newMembers.map { DBXTeamMemberAddV2Arg(swift: $0) } }

    @objc
    public init(newMembers: [DBXTeamMemberAddV2Arg], forceAsync: NSNumber) {
        let swift = Team.MembersAddV2Arg(newMembers: newMembers.map(\.subSwift), forceAsync: forceAsync.boolValue)
        self.subSwift = swift
        super.init(swift: swift)
    }

    let subSwift: Team.MembersAddV2Arg

    public init(swift: Team.MembersAddV2Arg) {
        self.subSwift = swift
        super.init(swift: swift)
    }

    @objc
    public override var description: String { subSwift.description }
}

/// Exactly one of team_member_id, email, or external_id must be provided to identify the user account.
@objc
public class DBXTeamMembersDeactivateBaseArg: NSObject {
    /// Identity of user to remove/suspend/have their files moved.
    @objc
    public var user: DBXTeamUserSelectorArg { DBXTeamUserSelectorArg(swift: swift.user) }

    @objc
    public init(user: DBXTeamUserSelectorArg) {
        self.swift = Team.MembersDeactivateBaseArg(user: user.swift)
    }

    let swift: Team.MembersDeactivateBaseArg

    public init(swift: Team.MembersDeactivateBaseArg) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible MembersDataTransferArg struct
@objc
public class DBXTeamMembersDataTransferArg: DBXTeamMembersDeactivateBaseArg {
    /// Files from the deleted member account will be transferred to this user.
    @objc
    public var transferDestId: DBXTeamUserSelectorArg { DBXTeamUserSelectorArg(swift: subSwift.transferDestId) }
    /// Errors during the transfer process will be sent via email to this user.
    @objc
    public var transferAdminId: DBXTeamUserSelectorArg { DBXTeamUserSelectorArg(swift: subSwift.transferAdminId) }

    @objc
    public init(user: DBXTeamUserSelectorArg, transferDestId: DBXTeamUserSelectorArg, transferAdminId: DBXTeamUserSelectorArg) {
        let swift = Team.MembersDataTransferArg(user: user.swift, transferDestId: transferDestId.swift, transferAdminId: transferAdminId.swift)
        self.subSwift = swift
        super.init(swift: swift)
    }

    let subSwift: Team.MembersDataTransferArg

    public init(swift: Team.MembersDataTransferArg) {
        self.subSwift = swift
        super.init(swift: swift)
    }

    @objc
    public override var description: String { subSwift.description }
}

/// Objective-C compatible MembersDeactivateArg struct
@objc
public class DBXTeamMembersDeactivateArg: DBXTeamMembersDeactivateBaseArg {
    /// If provided, controls if the user's data will be deleted on their linked devices.
    @objc
    public var wipeData: NSNumber { subSwift.wipeData as NSNumber }

    @objc
    public init(user: DBXTeamUserSelectorArg, wipeData: NSNumber) {
        let swift = Team.MembersDeactivateArg(user: user.swift, wipeData: wipeData.boolValue)
        self.subSwift = swift
        super.init(swift: swift)
    }

    let subSwift: Team.MembersDeactivateArg

    public init(swift: Team.MembersDeactivateArg) {
        self.subSwift = swift
        super.init(swift: swift)
    }

    @objc
    public override var description: String { subSwift.description }
}

/// Objective-C compatible MembersDeactivateError union
@objc
public class DBXTeamMembersDeactivateError: NSObject {
    let swift: Team.MembersDeactivateError

    public init(swift: Team.MembersDeactivateError) {
        self.swift = swift
    }

    public static func factory(swift: Team.MembersDeactivateError) -> DBXTeamMembersDeactivateError {
        switch swift {
        case .userNotFound:
            return DBXTeamMembersDeactivateErrorUserNotFound()
        case .userNotInTeam:
            return DBXTeamMembersDeactivateErrorUserNotInTeam()
        case .other:
            return DBXTeamMembersDeactivateErrorOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asUserNotFound: DBXTeamMembersDeactivateErrorUserNotFound? {
        self as? DBXTeamMembersDeactivateErrorUserNotFound
    }

    @objc
    public var asUserNotInTeam: DBXTeamMembersDeactivateErrorUserNotInTeam? {
        self as? DBXTeamMembersDeactivateErrorUserNotInTeam
    }

    @objc
    public var asOther: DBXTeamMembersDeactivateErrorOther? {
        self as? DBXTeamMembersDeactivateErrorOther
    }
}

/// No matching user found. The provided team_member_id, email, or external_id does not exist on this team.
@objc
public class DBXTeamMembersDeactivateErrorUserNotFound: DBXTeamMembersDeactivateError {
    @objc
    public init() {
        let swift = Team.MembersDeactivateError.userNotFound
        super.init(swift: swift)
    }
}

/// The user is not a member of the team.
@objc
public class DBXTeamMembersDeactivateErrorUserNotInTeam: DBXTeamMembersDeactivateError {
    @objc
    public init() {
        let swift = Team.MembersDeactivateError.userNotInTeam
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXTeamMembersDeactivateErrorOther: DBXTeamMembersDeactivateError {
    @objc
    public init() {
        let swift = Team.MembersDeactivateError.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible MembersDeleteProfilePhotoArg struct
@objc
public class DBXTeamMembersDeleteProfilePhotoArg: NSObject {
    /// Identity of the user whose profile photo will be deleted.
    @objc
    public var user: DBXTeamUserSelectorArg { DBXTeamUserSelectorArg(swift: swift.user) }

    @objc
    public init(user: DBXTeamUserSelectorArg) {
        self.swift = Team.MembersDeleteProfilePhotoArg(user: user.swift)
    }

    let swift: Team.MembersDeleteProfilePhotoArg

    public init(swift: Team.MembersDeleteProfilePhotoArg) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible MembersDeleteProfilePhotoError union
@objc
public class DBXTeamMembersDeleteProfilePhotoError: NSObject {
    let swift: Team.MembersDeleteProfilePhotoError

    public init(swift: Team.MembersDeleteProfilePhotoError) {
        self.swift = swift
    }

    public static func factory(swift: Team.MembersDeleteProfilePhotoError) -> DBXTeamMembersDeleteProfilePhotoError {
        switch swift {
        case .userNotFound:
            return DBXTeamMembersDeleteProfilePhotoErrorUserNotFound()
        case .userNotInTeam:
            return DBXTeamMembersDeleteProfilePhotoErrorUserNotInTeam()
        case .setProfileDisallowed:
            return DBXTeamMembersDeleteProfilePhotoErrorSetProfileDisallowed()
        case .other:
            return DBXTeamMembersDeleteProfilePhotoErrorOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asUserNotFound: DBXTeamMembersDeleteProfilePhotoErrorUserNotFound? {
        self as? DBXTeamMembersDeleteProfilePhotoErrorUserNotFound
    }

    @objc
    public var asUserNotInTeam: DBXTeamMembersDeleteProfilePhotoErrorUserNotInTeam? {
        self as? DBXTeamMembersDeleteProfilePhotoErrorUserNotInTeam
    }

    @objc
    public var asSetProfileDisallowed: DBXTeamMembersDeleteProfilePhotoErrorSetProfileDisallowed? {
        self as? DBXTeamMembersDeleteProfilePhotoErrorSetProfileDisallowed
    }

    @objc
    public var asOther: DBXTeamMembersDeleteProfilePhotoErrorOther? {
        self as? DBXTeamMembersDeleteProfilePhotoErrorOther
    }
}

/// No matching user found. The provided team_member_id, email, or external_id does not exist on this team.
@objc
public class DBXTeamMembersDeleteProfilePhotoErrorUserNotFound: DBXTeamMembersDeleteProfilePhotoError {
    @objc
    public init() {
        let swift = Team.MembersDeleteProfilePhotoError.userNotFound
        super.init(swift: swift)
    }
}

/// The user is not a member of the team.
@objc
public class DBXTeamMembersDeleteProfilePhotoErrorUserNotInTeam: DBXTeamMembersDeleteProfilePhotoError {
    @objc
    public init() {
        let swift = Team.MembersDeleteProfilePhotoError.userNotInTeam
        super.init(swift: swift)
    }
}

/// Modifying deleted users is not allowed.
@objc
public class DBXTeamMembersDeleteProfilePhotoErrorSetProfileDisallowed: DBXTeamMembersDeleteProfilePhotoError {
    @objc
    public init() {
        let swift = Team.MembersDeleteProfilePhotoError.setProfileDisallowed
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXTeamMembersDeleteProfilePhotoErrorOther: DBXTeamMembersDeleteProfilePhotoError {
    @objc
    public init() {
        let swift = Team.MembersDeleteProfilePhotoError.other
        super.init(swift: swift)
    }
}

/// Available TeamMemberRole for the connected team. To be used with membersSetAdminPermissionsV2.
@objc
public class DBXTeamMembersGetAvailableTeamMemberRolesResult: NSObject {
    /// Available roles.
    @objc
    public var roles: [DBXTeamTeamMemberRole] { swift.roles.map { DBXTeamTeamMemberRole(swift: $0) } }

    @objc
    public init(roles: [DBXTeamTeamMemberRole]) {
        self.swift = Team.MembersGetAvailableTeamMemberRolesResult(roles: roles.map(\.swift))
    }

    let swift: Team.MembersGetAvailableTeamMemberRolesResult

    public init(swift: Team.MembersGetAvailableTeamMemberRolesResult) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible MembersGetInfoArgs struct
@objc
public class DBXTeamMembersGetInfoArgs: NSObject {
    /// List of team members.
    @objc
    public var members: [DBXTeamUserSelectorArg] { swift.members.map { DBXTeamUserSelectorArg(swift: $0) } }

    @objc
    public init(members: [DBXTeamUserSelectorArg]) {
        self.swift = Team.MembersGetInfoArgs(members: members.map(\.swift))
    }

    let swift: Team.MembersGetInfoArgs

    public init(swift: Team.MembersGetInfoArgs) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible MembersGetInfoError union
@objc
public class DBXTeamMembersGetInfoError: NSObject {
    let swift: Team.MembersGetInfoError

    public init(swift: Team.MembersGetInfoError) {
        self.swift = swift
    }

    public static func factory(swift: Team.MembersGetInfoError) -> DBXTeamMembersGetInfoError {
        switch swift {
        case .other:
            return DBXTeamMembersGetInfoErrorOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asOther: DBXTeamMembersGetInfoErrorOther? {
        self as? DBXTeamMembersGetInfoErrorOther
    }
}

/// An unspecified error.
@objc
public class DBXTeamMembersGetInfoErrorOther: DBXTeamMembersGetInfoError {
    @objc
    public init() {
        let swift = Team.MembersGetInfoError.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible MembersGetInfoItemBase union
@objc
public class DBXTeamMembersGetInfoItemBase: NSObject {
    let swift: Team.MembersGetInfoItemBase

    public init(swift: Team.MembersGetInfoItemBase) {
        self.swift = swift
    }

    public static func factory(swift: Team.MembersGetInfoItemBase) -> DBXTeamMembersGetInfoItemBase {
        switch swift {
        case .idNotFound(let swiftArg):
            let arg = swiftArg
            return DBXTeamMembersGetInfoItemBaseIdNotFound(arg)
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asIdNotFound: DBXTeamMembersGetInfoItemBaseIdNotFound? {
        self as? DBXTeamMembersGetInfoItemBaseIdNotFound
    }
}

/// An ID that was provided as a parameter to membersGetInfo or membersGetInfoV2, and did not match a
/// corresponding user. This might be a team_member_id, an email, or an external ID, depending on how
/// the method was called.
@objc
public class DBXTeamMembersGetInfoItemBaseIdNotFound: DBXTeamMembersGetInfoItemBase {
    @objc
    public var idNotFound: String

    @objc
    public init(_ arg: String) {
        self.idNotFound = arg
        let swift = Team.MembersGetInfoItemBase.idNotFound(arg)
        super.init(swift: swift)
    }
}

/// Describes a result obtained for a single user whose id was specified in the parameter of membersGetInfo.
@objc
public class DBXTeamMembersGetInfoItem: NSObject {
    let swift: Team.MembersGetInfoItem

    public init(swift: Team.MembersGetInfoItem) {
        self.swift = swift
    }

    public static func factory(swift: Team.MembersGetInfoItem) -> DBXTeamMembersGetInfoItem {
        switch swift {
        case .idNotFound(let swiftArg):
            let arg = swiftArg
            return DBXTeamMembersGetInfoItemIdNotFound(arg)
        case .memberInfo(let swiftArg):
            let arg = DBXTeamTeamMemberInfo(swift: swiftArg)
            return DBXTeamMembersGetInfoItemMemberInfo(arg)
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asIdNotFound: DBXTeamMembersGetInfoItemIdNotFound? {
        self as? DBXTeamMembersGetInfoItemIdNotFound
    }

    @objc
    public var asMemberInfo: DBXTeamMembersGetInfoItemMemberInfo? {
        self as? DBXTeamMembersGetInfoItemMemberInfo
    }
}

/// An ID that was provided as a parameter to membersGetInfo or membersGetInfoV2, and did not match a
/// corresponding user. This might be a team_member_id, an email, or an external ID, depending on how
/// the method was called.
@objc
public class DBXTeamMembersGetInfoItemIdNotFound: DBXTeamMembersGetInfoItem {
    @objc
    public var idNotFound: String

    @objc
    public init(_ arg: String) {
        self.idNotFound = arg
        let swift = Team.MembersGetInfoItem.idNotFound(arg)
        super.init(swift: swift)
    }
}

/// Info about a team member.
@objc
public class DBXTeamMembersGetInfoItemMemberInfo: DBXTeamMembersGetInfoItem {
    @objc
    public var memberInfo: DBXTeamTeamMemberInfo

    @objc
    public init(_ arg: DBXTeamTeamMemberInfo) {
        self.memberInfo = arg
        let swift = Team.MembersGetInfoItem.memberInfo(arg.swift)
        super.init(swift: swift)
    }
}

/// Describes a result obtained for a single user whose id was specified in the parameter of membersGetInfoV2.
@objc
public class DBXTeamMembersGetInfoItemV2: NSObject {
    let swift: Team.MembersGetInfoItemV2

    public init(swift: Team.MembersGetInfoItemV2) {
        self.swift = swift
    }

    public static func factory(swift: Team.MembersGetInfoItemV2) -> DBXTeamMembersGetInfoItemV2 {
        switch swift {
        case .idNotFound(let swiftArg):
            let arg = swiftArg
            return DBXTeamMembersGetInfoItemV2IdNotFound(arg)
        case .memberInfo(let swiftArg):
            let arg = DBXTeamTeamMemberInfoV2(swift: swiftArg)
            return DBXTeamMembersGetInfoItemV2MemberInfo(arg)
        case .other:
            return DBXTeamMembersGetInfoItemV2Other()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asIdNotFound: DBXTeamMembersGetInfoItemV2IdNotFound? {
        self as? DBXTeamMembersGetInfoItemV2IdNotFound
    }

    @objc
    public var asMemberInfo: DBXTeamMembersGetInfoItemV2MemberInfo? {
        self as? DBXTeamMembersGetInfoItemV2MemberInfo
    }

    @objc
    public var asOther: DBXTeamMembersGetInfoItemV2Other? {
        self as? DBXTeamMembersGetInfoItemV2Other
    }
}

/// An ID that was provided as a parameter to membersGetInfo or membersGetInfoV2, and did not match a
/// corresponding user. This might be a team_member_id, an email, or an external ID, depending on how
/// the method was called.
@objc
public class DBXTeamMembersGetInfoItemV2IdNotFound: DBXTeamMembersGetInfoItemV2 {
    @objc
    public var idNotFound: String

    @objc
    public init(_ arg: String) {
        self.idNotFound = arg
        let swift = Team.MembersGetInfoItemV2.idNotFound(arg)
        super.init(swift: swift)
    }
}

/// Info about a team member.
@objc
public class DBXTeamMembersGetInfoItemV2MemberInfo: DBXTeamMembersGetInfoItemV2 {
    @objc
    public var memberInfo: DBXTeamTeamMemberInfoV2

    @objc
    public init(_ arg: DBXTeamTeamMemberInfoV2) {
        self.memberInfo = arg
        let swift = Team.MembersGetInfoItemV2.memberInfo(arg.swift)
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXTeamMembersGetInfoItemV2Other: DBXTeamMembersGetInfoItemV2 {
    @objc
    public init() {
        let swift = Team.MembersGetInfoItemV2.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible MembersGetInfoV2Arg struct
@objc
public class DBXTeamMembersGetInfoV2Arg: NSObject {
    /// List of team members.
    @objc
    public var members: [DBXTeamUserSelectorArg] { swift.members.map { DBXTeamUserSelectorArg(swift: $0) } }

    @objc
    public init(members: [DBXTeamUserSelectorArg]) {
        self.swift = Team.MembersGetInfoV2Arg(members: members.map(\.swift))
    }

    let swift: Team.MembersGetInfoV2Arg

    public init(swift: Team.MembersGetInfoV2Arg) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible MembersGetInfoV2Result struct
@objc
public class DBXTeamMembersGetInfoV2Result: NSObject {
    /// List of team members info.
    @objc
    public var membersInfo: [DBXTeamMembersGetInfoItemV2] { swift.membersInfo.map { DBXTeamMembersGetInfoItemV2(swift: $0) } }

    @objc
    public init(membersInfo: [DBXTeamMembersGetInfoItemV2]) {
        self.swift = Team.MembersGetInfoV2Result(membersInfo: membersInfo.map(\.swift))
    }

    let swift: Team.MembersGetInfoV2Result

    public init(swift: Team.MembersGetInfoV2Result) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible MembersInfo struct
@objc
public class DBXTeamMembersInfo: NSObject {
    /// Team member IDs of the users under this hold.
    @objc
    public var teamMemberIds: [String] { swift.teamMemberIds }
    /// The number of permanently deleted users that were under this hold.
    @objc
    public var permanentlyDeletedUsers: NSNumber { swift.permanentlyDeletedUsers as NSNumber }

    @objc
    public init(teamMemberIds: [String], permanentlyDeletedUsers: NSNumber) {
        self.swift = Team.MembersInfo(teamMemberIds: teamMemberIds, permanentlyDeletedUsers: permanentlyDeletedUsers.uint64Value)
    }

    let swift: Team.MembersInfo

    public init(swift: Team.MembersInfo) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible MembersListArg struct
@objc
public class DBXTeamMembersListArg: NSObject {
    /// Number of results to return per call.
    @objc
    public var limit: NSNumber { swift.limit as NSNumber }
    /// Whether to return removed members.
    @objc
    public var includeRemoved: NSNumber { swift.includeRemoved as NSNumber }

    @objc
    public init(limit: NSNumber, includeRemoved: NSNumber) {
        self.swift = Team.MembersListArg(limit: limit.uint32Value, includeRemoved: includeRemoved.boolValue)
    }

    let swift: Team.MembersListArg

    public init(swift: Team.MembersListArg) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible MembersListContinueArg struct
@objc
public class DBXTeamMembersListContinueArg: NSObject {
    /// Indicates from what point to get the next set of members.
    @objc
    public var cursor: String { swift.cursor }

    @objc
    public init(cursor: String) {
        self.swift = Team.MembersListContinueArg(cursor: cursor)
    }

    let swift: Team.MembersListContinueArg

    public init(swift: Team.MembersListContinueArg) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible MembersListContinueError union
@objc
public class DBXTeamMembersListContinueError: NSObject {
    let swift: Team.MembersListContinueError

    public init(swift: Team.MembersListContinueError) {
        self.swift = swift
    }

    public static func factory(swift: Team.MembersListContinueError) -> DBXTeamMembersListContinueError {
        switch swift {
        case .invalidCursor:
            return DBXTeamMembersListContinueErrorInvalidCursor()
        case .other:
            return DBXTeamMembersListContinueErrorOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asInvalidCursor: DBXTeamMembersListContinueErrorInvalidCursor? {
        self as? DBXTeamMembersListContinueErrorInvalidCursor
    }

    @objc
    public var asOther: DBXTeamMembersListContinueErrorOther? {
        self as? DBXTeamMembersListContinueErrorOther
    }
}

/// The cursor is invalid.
@objc
public class DBXTeamMembersListContinueErrorInvalidCursor: DBXTeamMembersListContinueError {
    @objc
    public init() {
        let swift = Team.MembersListContinueError.invalidCursor
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXTeamMembersListContinueErrorOther: DBXTeamMembersListContinueError {
    @objc
    public init() {
        let swift = Team.MembersListContinueError.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible MembersListError union
@objc
public class DBXTeamMembersListError: NSObject {
    let swift: Team.MembersListError

    public init(swift: Team.MembersListError) {
        self.swift = swift
    }

    public static func factory(swift: Team.MembersListError) -> DBXTeamMembersListError {
        switch swift {
        case .other:
            return DBXTeamMembersListErrorOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asOther: DBXTeamMembersListErrorOther? {
        self as? DBXTeamMembersListErrorOther
    }
}

/// An unspecified error.
@objc
public class DBXTeamMembersListErrorOther: DBXTeamMembersListError {
    @objc
    public init() {
        let swift = Team.MembersListError.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible MembersListResult struct
@objc
public class DBXTeamMembersListResult: NSObject {
    /// List of team members.
    @objc
    public var members: [DBXTeamTeamMemberInfo] { swift.members.map { DBXTeamTeamMemberInfo(swift: $0) } }
    /// Pass the cursor into membersListContinue to obtain the additional members.
    @objc
    public var cursor: String { swift.cursor }
    /// Is true if there are additional team members that have not been returned yet. An additional call to
    /// membersListContinue can retrieve them.
    @objc
    public var hasMore: NSNumber { swift.hasMore as NSNumber }

    @objc
    public init(members: [DBXTeamTeamMemberInfo], cursor: String, hasMore: NSNumber) {
        self.swift = Team.MembersListResult(members: members.map(\.swift), cursor: cursor, hasMore: hasMore.boolValue)
    }

    let swift: Team.MembersListResult

    public init(swift: Team.MembersListResult) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible MembersListV2Result struct
@objc
public class DBXTeamMembersListV2Result: NSObject {
    /// List of team members.
    @objc
    public var members: [DBXTeamTeamMemberInfoV2] { swift.members.map { DBXTeamTeamMemberInfoV2(swift: $0) } }
    /// Pass the cursor into membersListContinueV2 to obtain the additional members.
    @objc
    public var cursor: String { swift.cursor }
    /// Is true if there are additional team members that have not been returned yet. An additional call to
    /// membersListContinueV2 can retrieve them.
    @objc
    public var hasMore: NSNumber { swift.hasMore as NSNumber }

    @objc
    public init(members: [DBXTeamTeamMemberInfoV2], cursor: String, hasMore: NSNumber) {
        self.swift = Team.MembersListV2Result(members: members.map(\.swift), cursor: cursor, hasMore: hasMore.boolValue)
    }

    let swift: Team.MembersListV2Result

    public init(swift: Team.MembersListV2Result) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Exactly one of team_member_id, email, or external_id must be provided to identify the user account.
@objc
public class DBXTeamMembersRecoverArg: NSObject {
    /// Identity of user to recover.
    @objc
    public var user: DBXTeamUserSelectorArg { DBXTeamUserSelectorArg(swift: swift.user) }

    @objc
    public init(user: DBXTeamUserSelectorArg) {
        self.swift = Team.MembersRecoverArg(user: user.swift)
    }

    let swift: Team.MembersRecoverArg

    public init(swift: Team.MembersRecoverArg) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible MembersRecoverError union
@objc
public class DBXTeamMembersRecoverError: NSObject {
    let swift: Team.MembersRecoverError

    public init(swift: Team.MembersRecoverError) {
        self.swift = swift
    }

    public static func factory(swift: Team.MembersRecoverError) -> DBXTeamMembersRecoverError {
        switch swift {
        case .userNotFound:
            return DBXTeamMembersRecoverErrorUserNotFound()
        case .userUnrecoverable:
            return DBXTeamMembersRecoverErrorUserUnrecoverable()
        case .userNotInTeam:
            return DBXTeamMembersRecoverErrorUserNotInTeam()
        case .teamLicenseLimit:
            return DBXTeamMembersRecoverErrorTeamLicenseLimit()
        case .other:
            return DBXTeamMembersRecoverErrorOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asUserNotFound: DBXTeamMembersRecoverErrorUserNotFound? {
        self as? DBXTeamMembersRecoverErrorUserNotFound
    }

    @objc
    public var asUserUnrecoverable: DBXTeamMembersRecoverErrorUserUnrecoverable? {
        self as? DBXTeamMembersRecoverErrorUserUnrecoverable
    }

    @objc
    public var asUserNotInTeam: DBXTeamMembersRecoverErrorUserNotInTeam? {
        self as? DBXTeamMembersRecoverErrorUserNotInTeam
    }

    @objc
    public var asTeamLicenseLimit: DBXTeamMembersRecoverErrorTeamLicenseLimit? {
        self as? DBXTeamMembersRecoverErrorTeamLicenseLimit
    }

    @objc
    public var asOther: DBXTeamMembersRecoverErrorOther? {
        self as? DBXTeamMembersRecoverErrorOther
    }
}

/// No matching user found. The provided team_member_id, email, or external_id does not exist on this team.
@objc
public class DBXTeamMembersRecoverErrorUserNotFound: DBXTeamMembersRecoverError {
    @objc
    public init() {
        let swift = Team.MembersRecoverError.userNotFound
        super.init(swift: swift)
    }
}

/// The user is not recoverable.
@objc
public class DBXTeamMembersRecoverErrorUserUnrecoverable: DBXTeamMembersRecoverError {
    @objc
    public init() {
        let swift = Team.MembersRecoverError.userUnrecoverable
        super.init(swift: swift)
    }
}

/// The user is not a member of the team.
@objc
public class DBXTeamMembersRecoverErrorUserNotInTeam: DBXTeamMembersRecoverError {
    @objc
    public init() {
        let swift = Team.MembersRecoverError.userNotInTeam
        super.init(swift: swift)
    }
}

/// Team is full. The organization has no available licenses.
@objc
public class DBXTeamMembersRecoverErrorTeamLicenseLimit: DBXTeamMembersRecoverError {
    @objc
    public init() {
        let swift = Team.MembersRecoverError.teamLicenseLimit
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXTeamMembersRecoverErrorOther: DBXTeamMembersRecoverError {
    @objc
    public init() {
        let swift = Team.MembersRecoverError.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible MembersRemoveArg struct
@objc
public class DBXTeamMembersRemoveArg: DBXTeamMembersDeactivateArg {
    /// If provided, files from the deleted member account will be transferred to this user.
    @objc
    public var transferDestId: DBXTeamUserSelectorArg? { guard let swift = subSubSwift.transferDestId else { return nil }
        return DBXTeamUserSelectorArg(swift: swift)
    }

    /// If provided, errors during the transfer process will be sent via email to this user. If the transfer_dest_id
    /// argument was provided, then this argument must be provided as well.
    @objc
    public var transferAdminId: DBXTeamUserSelectorArg? { guard let swift = subSubSwift.transferAdminId else { return nil }
        return DBXTeamUserSelectorArg(swift: swift)
    }

    /// Downgrade the member to a Basic account. The user will retain the email address associated with their
    /// Dropbox  account and data in their account that is not restricted to team members. In order to keep the
    /// account the argument wipeData should be set to false.
    @objc
    public var keepAccount: NSNumber { subSubSwift.keepAccount as NSNumber }
    /// If provided, allows removed users to keep access to Dropbox folders (not Dropbox Paper folders) already
    /// explicitly shared with them (not via a group) when they are downgraded to a Basic account. Users will
    /// not retain access to folders that do not allow external sharing. In order to keep the sharing
    /// relationships, the arguments wipeData should be set to false and keepAccount should be set to true.
    @objc
    public var retainTeamShares: NSNumber { subSubSwift.retainTeamShares as NSNumber }

    @objc
    public init(
        user: DBXTeamUserSelectorArg,
        wipeData: NSNumber,
        transferDestId: DBXTeamUserSelectorArg?,
        transferAdminId: DBXTeamUserSelectorArg?,
        keepAccount: NSNumber,
        retainTeamShares: NSNumber
    ) {
        let swift = Team.MembersRemoveArg(
            user: user.swift,
            wipeData: wipeData.boolValue,
            transferDestId: transferDestId?.swift,
            transferAdminId: transferAdminId?.swift,
            keepAccount: keepAccount.boolValue,
            retainTeamShares: retainTeamShares.boolValue
        )
        self.subSubSwift = swift
        super.init(swift: swift)
    }

    let subSubSwift: Team.MembersRemoveArg

    public init(swift: Team.MembersRemoveArg) {
        self.subSubSwift = swift
        super.init(swift: swift)
    }

    @objc
    public override var description: String { subSwift.description }
}

/// Objective-C compatible MembersTransferFilesError union
@objc
public class DBXTeamMembersTransferFilesError: NSObject {
    let swift: Team.MembersTransferFilesError

    public init(swift: Team.MembersTransferFilesError) {
        self.swift = swift
    }

    public static func factory(swift: Team.MembersTransferFilesError) -> DBXTeamMembersTransferFilesError {
        switch swift {
        case .userNotFound:
            return DBXTeamMembersTransferFilesErrorUserNotFound()
        case .userNotInTeam:
            return DBXTeamMembersTransferFilesErrorUserNotInTeam()
        case .other:
            return DBXTeamMembersTransferFilesErrorOther()
        case .removedAndTransferDestShouldDiffer:
            return DBXTeamMembersTransferFilesErrorRemovedAndTransferDestShouldDiffer()
        case .removedAndTransferAdminShouldDiffer:
            return DBXTeamMembersTransferFilesErrorRemovedAndTransferAdminShouldDiffer()
        case .transferDestUserNotFound:
            return DBXTeamMembersTransferFilesErrorTransferDestUserNotFound()
        case .transferDestUserNotInTeam:
            return DBXTeamMembersTransferFilesErrorTransferDestUserNotInTeam()
        case .transferAdminUserNotInTeam:
            return DBXTeamMembersTransferFilesErrorTransferAdminUserNotInTeam()
        case .transferAdminUserNotFound:
            return DBXTeamMembersTransferFilesErrorTransferAdminUserNotFound()
        case .unspecifiedTransferAdminId:
            return DBXTeamMembersTransferFilesErrorUnspecifiedTransferAdminId()
        case .transferAdminIsNotAdmin:
            return DBXTeamMembersTransferFilesErrorTransferAdminIsNotAdmin()
        case .recipientNotVerified:
            return DBXTeamMembersTransferFilesErrorRecipientNotVerified()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asUserNotFound: DBXTeamMembersTransferFilesErrorUserNotFound? {
        self as? DBXTeamMembersTransferFilesErrorUserNotFound
    }

    @objc
    public var asUserNotInTeam: DBXTeamMembersTransferFilesErrorUserNotInTeam? {
        self as? DBXTeamMembersTransferFilesErrorUserNotInTeam
    }

    @objc
    public var asOther: DBXTeamMembersTransferFilesErrorOther? {
        self as? DBXTeamMembersTransferFilesErrorOther
    }

    @objc
    public var asRemovedAndTransferDestShouldDiffer: DBXTeamMembersTransferFilesErrorRemovedAndTransferDestShouldDiffer? {
        self as? DBXTeamMembersTransferFilesErrorRemovedAndTransferDestShouldDiffer
    }

    @objc
    public var asRemovedAndTransferAdminShouldDiffer: DBXTeamMembersTransferFilesErrorRemovedAndTransferAdminShouldDiffer? {
        self as? DBXTeamMembersTransferFilesErrorRemovedAndTransferAdminShouldDiffer
    }

    @objc
    public var asTransferDestUserNotFound: DBXTeamMembersTransferFilesErrorTransferDestUserNotFound? {
        self as? DBXTeamMembersTransferFilesErrorTransferDestUserNotFound
    }

    @objc
    public var asTransferDestUserNotInTeam: DBXTeamMembersTransferFilesErrorTransferDestUserNotInTeam? {
        self as? DBXTeamMembersTransferFilesErrorTransferDestUserNotInTeam
    }

    @objc
    public var asTransferAdminUserNotInTeam: DBXTeamMembersTransferFilesErrorTransferAdminUserNotInTeam? {
        self as? DBXTeamMembersTransferFilesErrorTransferAdminUserNotInTeam
    }

    @objc
    public var asTransferAdminUserNotFound: DBXTeamMembersTransferFilesErrorTransferAdminUserNotFound? {
        self as? DBXTeamMembersTransferFilesErrorTransferAdminUserNotFound
    }

    @objc
    public var asUnspecifiedTransferAdminId: DBXTeamMembersTransferFilesErrorUnspecifiedTransferAdminId? {
        self as? DBXTeamMembersTransferFilesErrorUnspecifiedTransferAdminId
    }

    @objc
    public var asTransferAdminIsNotAdmin: DBXTeamMembersTransferFilesErrorTransferAdminIsNotAdmin? {
        self as? DBXTeamMembersTransferFilesErrorTransferAdminIsNotAdmin
    }

    @objc
    public var asRecipientNotVerified: DBXTeamMembersTransferFilesErrorRecipientNotVerified? {
        self as? DBXTeamMembersTransferFilesErrorRecipientNotVerified
    }
}

/// No matching user found. The provided team_member_id, email, or external_id does not exist on this team.
@objc
public class DBXTeamMembersTransferFilesErrorUserNotFound: DBXTeamMembersTransferFilesError {
    @objc
    public init() {
        let swift = Team.MembersTransferFilesError.userNotFound
        super.init(swift: swift)
    }
}

/// The user is not a member of the team.
@objc
public class DBXTeamMembersTransferFilesErrorUserNotInTeam: DBXTeamMembersTransferFilesError {
    @objc
    public init() {
        let swift = Team.MembersTransferFilesError.userNotInTeam
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXTeamMembersTransferFilesErrorOther: DBXTeamMembersTransferFilesError {
    @objc
    public init() {
        let swift = Team.MembersTransferFilesError.other
        super.init(swift: swift)
    }
}

/// Expected removed user and transfer_dest user to be different.
@objc
public class DBXTeamMembersTransferFilesErrorRemovedAndTransferDestShouldDiffer: DBXTeamMembersTransferFilesError {
    @objc
    public init() {
        let swift = Team.MembersTransferFilesError.removedAndTransferDestShouldDiffer
        super.init(swift: swift)
    }
}

/// Expected removed user and transfer_admin user to be different.
@objc
public class DBXTeamMembersTransferFilesErrorRemovedAndTransferAdminShouldDiffer: DBXTeamMembersTransferFilesError {
    @objc
    public init() {
        let swift = Team.MembersTransferFilesError.removedAndTransferAdminShouldDiffer
        super.init(swift: swift)
    }
}

/// No matching user found for the argument transfer_dest_id.
@objc
public class DBXTeamMembersTransferFilesErrorTransferDestUserNotFound: DBXTeamMembersTransferFilesError {
    @objc
    public init() {
        let swift = Team.MembersTransferFilesError.transferDestUserNotFound
        super.init(swift: swift)
    }
}

/// The provided transfer_dest_id does not exist on this team.
@objc
public class DBXTeamMembersTransferFilesErrorTransferDestUserNotInTeam: DBXTeamMembersTransferFilesError {
    @objc
    public init() {
        let swift = Team.MembersTransferFilesError.transferDestUserNotInTeam
        super.init(swift: swift)
    }
}

/// The provided transfer_admin_id does not exist on this team.
@objc
public class DBXTeamMembersTransferFilesErrorTransferAdminUserNotInTeam: DBXTeamMembersTransferFilesError {
    @objc
    public init() {
        let swift = Team.MembersTransferFilesError.transferAdminUserNotInTeam
        super.init(swift: swift)
    }
}

/// No matching user found for the argument transfer_admin_id.
@objc
public class DBXTeamMembersTransferFilesErrorTransferAdminUserNotFound: DBXTeamMembersTransferFilesError {
    @objc
    public init() {
        let swift = Team.MembersTransferFilesError.transferAdminUserNotFound
        super.init(swift: swift)
    }
}

/// The transfer_admin_id argument must be provided when file transfer is requested.
@objc
public class DBXTeamMembersTransferFilesErrorUnspecifiedTransferAdminId: DBXTeamMembersTransferFilesError {
    @objc
    public init() {
        let swift = Team.MembersTransferFilesError.unspecifiedTransferAdminId
        super.init(swift: swift)
    }
}

/// Specified transfer_admin user is not a team admin.
@objc
public class DBXTeamMembersTransferFilesErrorTransferAdminIsNotAdmin: DBXTeamMembersTransferFilesError {
    @objc
    public init() {
        let swift = Team.MembersTransferFilesError.transferAdminIsNotAdmin
        super.init(swift: swift)
    }
}

/// The recipient user's email is not verified.
@objc
public class DBXTeamMembersTransferFilesErrorRecipientNotVerified: DBXTeamMembersTransferFilesError {
    @objc
    public init() {
        let swift = Team.MembersTransferFilesError.recipientNotVerified
        super.init(swift: swift)
    }
}

/// Objective-C compatible MembersRemoveError union
@objc
public class DBXTeamMembersRemoveError: NSObject {
    let swift: Team.MembersRemoveError

    public init(swift: Team.MembersRemoveError) {
        self.swift = swift
    }

    public static func factory(swift: Team.MembersRemoveError) -> DBXTeamMembersRemoveError {
        switch swift {
        case .userNotFound:
            return DBXTeamMembersRemoveErrorUserNotFound()
        case .userNotInTeam:
            return DBXTeamMembersRemoveErrorUserNotInTeam()
        case .other:
            return DBXTeamMembersRemoveErrorOther()
        case .removedAndTransferDestShouldDiffer:
            return DBXTeamMembersRemoveErrorRemovedAndTransferDestShouldDiffer()
        case .removedAndTransferAdminShouldDiffer:
            return DBXTeamMembersRemoveErrorRemovedAndTransferAdminShouldDiffer()
        case .transferDestUserNotFound:
            return DBXTeamMembersRemoveErrorTransferDestUserNotFound()
        case .transferDestUserNotInTeam:
            return DBXTeamMembersRemoveErrorTransferDestUserNotInTeam()
        case .transferAdminUserNotInTeam:
            return DBXTeamMembersRemoveErrorTransferAdminUserNotInTeam()
        case .transferAdminUserNotFound:
            return DBXTeamMembersRemoveErrorTransferAdminUserNotFound()
        case .unspecifiedTransferAdminId:
            return DBXTeamMembersRemoveErrorUnspecifiedTransferAdminId()
        case .transferAdminIsNotAdmin:
            return DBXTeamMembersRemoveErrorTransferAdminIsNotAdmin()
        case .recipientNotVerified:
            return DBXTeamMembersRemoveErrorRecipientNotVerified()
        case .removeLastAdmin:
            return DBXTeamMembersRemoveErrorRemoveLastAdmin()
        case .cannotKeepAccountAndTransfer:
            return DBXTeamMembersRemoveErrorCannotKeepAccountAndTransfer()
        case .cannotKeepAccountAndDeleteData:
            return DBXTeamMembersRemoveErrorCannotKeepAccountAndDeleteData()
        case .emailAddressTooLongToBeDisabled:
            return DBXTeamMembersRemoveErrorEmailAddressTooLongToBeDisabled()
        case .cannotKeepInvitedUserAccount:
            return DBXTeamMembersRemoveErrorCannotKeepInvitedUserAccount()
        case .cannotRetainSharesWhenDataWiped:
            return DBXTeamMembersRemoveErrorCannotRetainSharesWhenDataWiped()
        case .cannotRetainSharesWhenNoAccountKept:
            return DBXTeamMembersRemoveErrorCannotRetainSharesWhenNoAccountKept()
        case .cannotRetainSharesWhenTeamExternalSharingOff:
            return DBXTeamMembersRemoveErrorCannotRetainSharesWhenTeamExternalSharingOff()
        case .cannotKeepAccount:
            return DBXTeamMembersRemoveErrorCannotKeepAccount()
        case .cannotKeepAccountUnderLegalHold:
            return DBXTeamMembersRemoveErrorCannotKeepAccountUnderLegalHold()
        case .cannotKeepAccountRequiredToSignTos:
            return DBXTeamMembersRemoveErrorCannotKeepAccountRequiredToSignTos()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asUserNotFound: DBXTeamMembersRemoveErrorUserNotFound? {
        self as? DBXTeamMembersRemoveErrorUserNotFound
    }

    @objc
    public var asUserNotInTeam: DBXTeamMembersRemoveErrorUserNotInTeam? {
        self as? DBXTeamMembersRemoveErrorUserNotInTeam
    }

    @objc
    public var asOther: DBXTeamMembersRemoveErrorOther? {
        self as? DBXTeamMembersRemoveErrorOther
    }

    @objc
    public var asRemovedAndTransferDestShouldDiffer: DBXTeamMembersRemoveErrorRemovedAndTransferDestShouldDiffer? {
        self as? DBXTeamMembersRemoveErrorRemovedAndTransferDestShouldDiffer
    }

    @objc
    public var asRemovedAndTransferAdminShouldDiffer: DBXTeamMembersRemoveErrorRemovedAndTransferAdminShouldDiffer? {
        self as? DBXTeamMembersRemoveErrorRemovedAndTransferAdminShouldDiffer
    }

    @objc
    public var asTransferDestUserNotFound: DBXTeamMembersRemoveErrorTransferDestUserNotFound? {
        self as? DBXTeamMembersRemoveErrorTransferDestUserNotFound
    }

    @objc
    public var asTransferDestUserNotInTeam: DBXTeamMembersRemoveErrorTransferDestUserNotInTeam? {
        self as? DBXTeamMembersRemoveErrorTransferDestUserNotInTeam
    }

    @objc
    public var asTransferAdminUserNotInTeam: DBXTeamMembersRemoveErrorTransferAdminUserNotInTeam? {
        self as? DBXTeamMembersRemoveErrorTransferAdminUserNotInTeam
    }

    @objc
    public var asTransferAdminUserNotFound: DBXTeamMembersRemoveErrorTransferAdminUserNotFound? {
        self as? DBXTeamMembersRemoveErrorTransferAdminUserNotFound
    }

    @objc
    public var asUnspecifiedTransferAdminId: DBXTeamMembersRemoveErrorUnspecifiedTransferAdminId? {
        self as? DBXTeamMembersRemoveErrorUnspecifiedTransferAdminId
    }

    @objc
    public var asTransferAdminIsNotAdmin: DBXTeamMembersRemoveErrorTransferAdminIsNotAdmin? {
        self as? DBXTeamMembersRemoveErrorTransferAdminIsNotAdmin
    }

    @objc
    public var asRecipientNotVerified: DBXTeamMembersRemoveErrorRecipientNotVerified? {
        self as? DBXTeamMembersRemoveErrorRecipientNotVerified
    }

    @objc
    public var asRemoveLastAdmin: DBXTeamMembersRemoveErrorRemoveLastAdmin? {
        self as? DBXTeamMembersRemoveErrorRemoveLastAdmin
    }

    @objc
    public var asCannotKeepAccountAndTransfer: DBXTeamMembersRemoveErrorCannotKeepAccountAndTransfer? {
        self as? DBXTeamMembersRemoveErrorCannotKeepAccountAndTransfer
    }

    @objc
    public var asCannotKeepAccountAndDeleteData: DBXTeamMembersRemoveErrorCannotKeepAccountAndDeleteData? {
        self as? DBXTeamMembersRemoveErrorCannotKeepAccountAndDeleteData
    }

    @objc
    public var asEmailAddressTooLongToBeDisabled: DBXTeamMembersRemoveErrorEmailAddressTooLongToBeDisabled? {
        self as? DBXTeamMembersRemoveErrorEmailAddressTooLongToBeDisabled
    }

    @objc
    public var asCannotKeepInvitedUserAccount: DBXTeamMembersRemoveErrorCannotKeepInvitedUserAccount? {
        self as? DBXTeamMembersRemoveErrorCannotKeepInvitedUserAccount
    }

    @objc
    public var asCannotRetainSharesWhenDataWiped: DBXTeamMembersRemoveErrorCannotRetainSharesWhenDataWiped? {
        self as? DBXTeamMembersRemoveErrorCannotRetainSharesWhenDataWiped
    }

    @objc
    public var asCannotRetainSharesWhenNoAccountKept: DBXTeamMembersRemoveErrorCannotRetainSharesWhenNoAccountKept? {
        self as? DBXTeamMembersRemoveErrorCannotRetainSharesWhenNoAccountKept
    }

    @objc
    public var asCannotRetainSharesWhenTeamExternalSharingOff: DBXTeamMembersRemoveErrorCannotRetainSharesWhenTeamExternalSharingOff? {
        self as? DBXTeamMembersRemoveErrorCannotRetainSharesWhenTeamExternalSharingOff
    }

    @objc
    public var asCannotKeepAccount: DBXTeamMembersRemoveErrorCannotKeepAccount? {
        self as? DBXTeamMembersRemoveErrorCannotKeepAccount
    }

    @objc
    public var asCannotKeepAccountUnderLegalHold: DBXTeamMembersRemoveErrorCannotKeepAccountUnderLegalHold? {
        self as? DBXTeamMembersRemoveErrorCannotKeepAccountUnderLegalHold
    }

    @objc
    public var asCannotKeepAccountRequiredToSignTos: DBXTeamMembersRemoveErrorCannotKeepAccountRequiredToSignTos? {
        self as? DBXTeamMembersRemoveErrorCannotKeepAccountRequiredToSignTos
    }
}

/// No matching user found. The provided team_member_id, email, or external_id does not exist on this team.
@objc
public class DBXTeamMembersRemoveErrorUserNotFound: DBXTeamMembersRemoveError {
    @objc
    public init() {
        let swift = Team.MembersRemoveError.userNotFound
        super.init(swift: swift)
    }
}

/// The user is not a member of the team.
@objc
public class DBXTeamMembersRemoveErrorUserNotInTeam: DBXTeamMembersRemoveError {
    @objc
    public init() {
        let swift = Team.MembersRemoveError.userNotInTeam
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXTeamMembersRemoveErrorOther: DBXTeamMembersRemoveError {
    @objc
    public init() {
        let swift = Team.MembersRemoveError.other
        super.init(swift: swift)
    }
}

/// Expected removed user and transfer_dest user to be different.
@objc
public class DBXTeamMembersRemoveErrorRemovedAndTransferDestShouldDiffer: DBXTeamMembersRemoveError {
    @objc
    public init() {
        let swift = Team.MembersRemoveError.removedAndTransferDestShouldDiffer
        super.init(swift: swift)
    }
}

/// Expected removed user and transfer_admin user to be different.
@objc
public class DBXTeamMembersRemoveErrorRemovedAndTransferAdminShouldDiffer: DBXTeamMembersRemoveError {
    @objc
    public init() {
        let swift = Team.MembersRemoveError.removedAndTransferAdminShouldDiffer
        super.init(swift: swift)
    }
}

/// No matching user found for the argument transfer_dest_id.
@objc
public class DBXTeamMembersRemoveErrorTransferDestUserNotFound: DBXTeamMembersRemoveError {
    @objc
    public init() {
        let swift = Team.MembersRemoveError.transferDestUserNotFound
        super.init(swift: swift)
    }
}

/// The provided transfer_dest_id does not exist on this team.
@objc
public class DBXTeamMembersRemoveErrorTransferDestUserNotInTeam: DBXTeamMembersRemoveError {
    @objc
    public init() {
        let swift = Team.MembersRemoveError.transferDestUserNotInTeam
        super.init(swift: swift)
    }
}

/// The provided transfer_admin_id does not exist on this team.
@objc
public class DBXTeamMembersRemoveErrorTransferAdminUserNotInTeam: DBXTeamMembersRemoveError {
    @objc
    public init() {
        let swift = Team.MembersRemoveError.transferAdminUserNotInTeam
        super.init(swift: swift)
    }
}

/// No matching user found for the argument transfer_admin_id.
@objc
public class DBXTeamMembersRemoveErrorTransferAdminUserNotFound: DBXTeamMembersRemoveError {
    @objc
    public init() {
        let swift = Team.MembersRemoveError.transferAdminUserNotFound
        super.init(swift: swift)
    }
}

/// The transfer_admin_id argument must be provided when file transfer is requested.
@objc
public class DBXTeamMembersRemoveErrorUnspecifiedTransferAdminId: DBXTeamMembersRemoveError {
    @objc
    public init() {
        let swift = Team.MembersRemoveError.unspecifiedTransferAdminId
        super.init(swift: swift)
    }
}

/// Specified transfer_admin user is not a team admin.
@objc
public class DBXTeamMembersRemoveErrorTransferAdminIsNotAdmin: DBXTeamMembersRemoveError {
    @objc
    public init() {
        let swift = Team.MembersRemoveError.transferAdminIsNotAdmin
        super.init(swift: swift)
    }
}

/// The recipient user's email is not verified.
@objc
public class DBXTeamMembersRemoveErrorRecipientNotVerified: DBXTeamMembersRemoveError {
    @objc
    public init() {
        let swift = Team.MembersRemoveError.recipientNotVerified
        super.init(swift: swift)
    }
}

/// The user is the last admin of the team, so it cannot be removed from it.
@objc
public class DBXTeamMembersRemoveErrorRemoveLastAdmin: DBXTeamMembersRemoveError {
    @objc
    public init() {
        let swift = Team.MembersRemoveError.removeLastAdmin
        super.init(swift: swift)
    }
}

/// Cannot keep account and transfer the data to another user at the same time.
@objc
public class DBXTeamMembersRemoveErrorCannotKeepAccountAndTransfer: DBXTeamMembersRemoveError {
    @objc
    public init() {
        let swift = Team.MembersRemoveError.cannotKeepAccountAndTransfer
        super.init(swift: swift)
    }
}

/// Cannot keep account and delete the data at the same time. To keep the account the argument wipe_data should
/// be set to false.
@objc
public class DBXTeamMembersRemoveErrorCannotKeepAccountAndDeleteData: DBXTeamMembersRemoveError {
    @objc
    public init() {
        let swift = Team.MembersRemoveError.cannotKeepAccountAndDeleteData
        super.init(swift: swift)
    }
}

/// The email address of the user is too long to be disabled.
@objc
public class DBXTeamMembersRemoveErrorEmailAddressTooLongToBeDisabled: DBXTeamMembersRemoveError {
    @objc
    public init() {
        let swift = Team.MembersRemoveError.emailAddressTooLongToBeDisabled
        super.init(swift: swift)
    }
}

/// Cannot keep account of an invited user.
@objc
public class DBXTeamMembersRemoveErrorCannotKeepInvitedUserAccount: DBXTeamMembersRemoveError {
    @objc
    public init() {
        let swift = Team.MembersRemoveError.cannotKeepInvitedUserAccount
        super.init(swift: swift)
    }
}

/// Cannot retain team shares when the user's data is marked for deletion on their linked devices. The argument
/// wipe_data should be set to false.
@objc
public class DBXTeamMembersRemoveErrorCannotRetainSharesWhenDataWiped: DBXTeamMembersRemoveError {
    @objc
    public init() {
        let swift = Team.MembersRemoveError.cannotRetainSharesWhenDataWiped
        super.init(swift: swift)
    }
}

/// The user's account must be kept in order to retain team shares. The argument keep_account should be set to
/// true.
@objc
public class DBXTeamMembersRemoveErrorCannotRetainSharesWhenNoAccountKept: DBXTeamMembersRemoveError {
    @objc
    public init() {
        let swift = Team.MembersRemoveError.cannotRetainSharesWhenNoAccountKept
        super.init(swift: swift)
    }
}

/// Externally sharing files, folders, and links must be enabled in team settings in order to retain team shares
/// for the user.
@objc
public class DBXTeamMembersRemoveErrorCannotRetainSharesWhenTeamExternalSharingOff: DBXTeamMembersRemoveError {
    @objc
    public init() {
        let swift = Team.MembersRemoveError.cannotRetainSharesWhenTeamExternalSharingOff
        super.init(swift: swift)
    }
}

/// Only a team admin, can convert this account to a Basic account.
@objc
public class DBXTeamMembersRemoveErrorCannotKeepAccount: DBXTeamMembersRemoveError {
    @objc
    public init() {
        let swift = Team.MembersRemoveError.cannotKeepAccount
        super.init(swift: swift)
    }
}

/// This user content is currently being held. To convert this member's account to a Basic account, you'll first
/// need to remove them from the hold.
@objc
public class DBXTeamMembersRemoveErrorCannotKeepAccountUnderLegalHold: DBXTeamMembersRemoveError {
    @objc
    public init() {
        let swift = Team.MembersRemoveError.cannotKeepAccountUnderLegalHold
        super.init(swift: swift)
    }
}

/// To convert this member to a Basic account, they'll first need to sign in to Dropbox and agree to the terms
/// of service.
@objc
public class DBXTeamMembersRemoveErrorCannotKeepAccountRequiredToSignTos: DBXTeamMembersRemoveError {
    @objc
    public init() {
        let swift = Team.MembersRemoveError.cannotKeepAccountRequiredToSignTos
        super.init(swift: swift)
    }
}

/// Objective-C compatible MembersSendWelcomeError union
@objc
public class DBXTeamMembersSendWelcomeError: NSObject {
    let swift: Team.MembersSendWelcomeError

    public init(swift: Team.MembersSendWelcomeError) {
        self.swift = swift
    }

    public static func factory(swift: Team.MembersSendWelcomeError) -> DBXTeamMembersSendWelcomeError {
        switch swift {
        case .userNotFound:
            return DBXTeamMembersSendWelcomeErrorUserNotFound()
        case .userNotInTeam:
            return DBXTeamMembersSendWelcomeErrorUserNotInTeam()
        case .other:
            return DBXTeamMembersSendWelcomeErrorOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asUserNotFound: DBXTeamMembersSendWelcomeErrorUserNotFound? {
        self as? DBXTeamMembersSendWelcomeErrorUserNotFound
    }

    @objc
    public var asUserNotInTeam: DBXTeamMembersSendWelcomeErrorUserNotInTeam? {
        self as? DBXTeamMembersSendWelcomeErrorUserNotInTeam
    }

    @objc
    public var asOther: DBXTeamMembersSendWelcomeErrorOther? {
        self as? DBXTeamMembersSendWelcomeErrorOther
    }
}

/// No matching user found. The provided team_member_id, email, or external_id does not exist on this team.
@objc
public class DBXTeamMembersSendWelcomeErrorUserNotFound: DBXTeamMembersSendWelcomeError {
    @objc
    public init() {
        let swift = Team.MembersSendWelcomeError.userNotFound
        super.init(swift: swift)
    }
}

/// The user is not a member of the team.
@objc
public class DBXTeamMembersSendWelcomeErrorUserNotInTeam: DBXTeamMembersSendWelcomeError {
    @objc
    public init() {
        let swift = Team.MembersSendWelcomeError.userNotInTeam
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXTeamMembersSendWelcomeErrorOther: DBXTeamMembersSendWelcomeError {
    @objc
    public init() {
        let swift = Team.MembersSendWelcomeError.other
        super.init(swift: swift)
    }
}

/// Exactly one of team_member_id, email, or external_id must be provided to identify the user account.
@objc
public class DBXTeamMembersSetPermissions2Arg: NSObject {
    /// Identity of user whose role will be set.
    @objc
    public var user: DBXTeamUserSelectorArg { DBXTeamUserSelectorArg(swift: swift.user) }
    /// The new roles for the member. Send empty list to make user member only. For now, only up to one role is
    /// allowed.
    @objc
    public var newRoles: [String]? { swift.newRoles }

    @objc
    public init(user: DBXTeamUserSelectorArg, newRoles: [String]?) {
        self.swift = Team.MembersSetPermissions2Arg(user: user.swift, newRoles: newRoles)
    }

    let swift: Team.MembersSetPermissions2Arg

    public init(swift: Team.MembersSetPermissions2Arg) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible MembersSetPermissions2Error union
@objc
public class DBXTeamMembersSetPermissions2Error: NSObject {
    let swift: Team.MembersSetPermissions2Error

    public init(swift: Team.MembersSetPermissions2Error) {
        self.swift = swift
    }

    public static func factory(swift: Team.MembersSetPermissions2Error) -> DBXTeamMembersSetPermissions2Error {
        switch swift {
        case .userNotFound:
            return DBXTeamMembersSetPermissions2ErrorUserNotFound()
        case .lastAdmin:
            return DBXTeamMembersSetPermissions2ErrorLastAdmin()
        case .userNotInTeam:
            return DBXTeamMembersSetPermissions2ErrorUserNotInTeam()
        case .cannotSetPermissions:
            return DBXTeamMembersSetPermissions2ErrorCannotSetPermissions()
        case .roleNotFound:
            return DBXTeamMembersSetPermissions2ErrorRoleNotFound()
        case .other:
            return DBXTeamMembersSetPermissions2ErrorOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asUserNotFound: DBXTeamMembersSetPermissions2ErrorUserNotFound? {
        self as? DBXTeamMembersSetPermissions2ErrorUserNotFound
    }

    @objc
    public var asLastAdmin: DBXTeamMembersSetPermissions2ErrorLastAdmin? {
        self as? DBXTeamMembersSetPermissions2ErrorLastAdmin
    }

    @objc
    public var asUserNotInTeam: DBXTeamMembersSetPermissions2ErrorUserNotInTeam? {
        self as? DBXTeamMembersSetPermissions2ErrorUserNotInTeam
    }

    @objc
    public var asCannotSetPermissions: DBXTeamMembersSetPermissions2ErrorCannotSetPermissions? {
        self as? DBXTeamMembersSetPermissions2ErrorCannotSetPermissions
    }

    @objc
    public var asRoleNotFound: DBXTeamMembersSetPermissions2ErrorRoleNotFound? {
        self as? DBXTeamMembersSetPermissions2ErrorRoleNotFound
    }

    @objc
    public var asOther: DBXTeamMembersSetPermissions2ErrorOther? {
        self as? DBXTeamMembersSetPermissions2ErrorOther
    }
}

/// No matching user found. The provided team_member_id, email, or external_id does not exist on this team.
@objc
public class DBXTeamMembersSetPermissions2ErrorUserNotFound: DBXTeamMembersSetPermissions2Error {
    @objc
    public init() {
        let swift = Team.MembersSetPermissions2Error.userNotFound
        super.init(swift: swift)
    }
}

/// Cannot remove the admin setting of the last admin.
@objc
public class DBXTeamMembersSetPermissions2ErrorLastAdmin: DBXTeamMembersSetPermissions2Error {
    @objc
    public init() {
        let swift = Team.MembersSetPermissions2Error.lastAdmin
        super.init(swift: swift)
    }
}

/// The user is not a member of the team.
@objc
public class DBXTeamMembersSetPermissions2ErrorUserNotInTeam: DBXTeamMembersSetPermissions2Error {
    @objc
    public init() {
        let swift = Team.MembersSetPermissions2Error.userNotInTeam
        super.init(swift: swift)
    }
}

/// Cannot remove/grant permissions. This can happen if the team member is suspended.
@objc
public class DBXTeamMembersSetPermissions2ErrorCannotSetPermissions: DBXTeamMembersSetPermissions2Error {
    @objc
    public init() {
        let swift = Team.MembersSetPermissions2Error.cannotSetPermissions
        super.init(swift: swift)
    }
}

/// No matching role found. At least one of the provided new_roles does not exist on this team.
@objc
public class DBXTeamMembersSetPermissions2ErrorRoleNotFound: DBXTeamMembersSetPermissions2Error {
    @objc
    public init() {
        let swift = Team.MembersSetPermissions2Error.roleNotFound
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXTeamMembersSetPermissions2ErrorOther: DBXTeamMembersSetPermissions2Error {
    @objc
    public init() {
        let swift = Team.MembersSetPermissions2Error.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible MembersSetPermissions2Result struct
@objc
public class DBXTeamMembersSetPermissions2Result: NSObject {
    /// The member ID of the user to which the change was applied.
    @objc
    public var teamMemberId: String { swift.teamMemberId }
    /// The roles after the change. Empty in case the user become a non-admin.
    @objc
    public var roles: [DBXTeamTeamMemberRole]? { swift.roles?.map { DBXTeamTeamMemberRole(swift: $0) } }

    @objc
    public init(teamMemberId: String, roles: [DBXTeamTeamMemberRole]?) {
        self.swift = Team.MembersSetPermissions2Result(teamMemberId: teamMemberId, roles: roles?.map(\.swift))
    }

    let swift: Team.MembersSetPermissions2Result

    public init(swift: Team.MembersSetPermissions2Result) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Exactly one of team_member_id, email, or external_id must be provided to identify the user account.
@objc
public class DBXTeamMembersSetPermissionsArg: NSObject {
    /// Identity of user whose role will be set.
    @objc
    public var user: DBXTeamUserSelectorArg { DBXTeamUserSelectorArg(swift: swift.user) }
    /// The new role of the member.
    @objc
    public var newRole: DBXTeamAdminTier { DBXTeamAdminTier(swift: swift.newRole) }

    @objc
    public init(user: DBXTeamUserSelectorArg, newRole: DBXTeamAdminTier) {
        self.swift = Team.MembersSetPermissionsArg(user: user.swift, newRole: newRole.swift)
    }

    let swift: Team.MembersSetPermissionsArg

    public init(swift: Team.MembersSetPermissionsArg) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible MembersSetPermissionsError union
@objc
public class DBXTeamMembersSetPermissionsError: NSObject {
    let swift: Team.MembersSetPermissionsError

    public init(swift: Team.MembersSetPermissionsError) {
        self.swift = swift
    }

    public static func factory(swift: Team.MembersSetPermissionsError) -> DBXTeamMembersSetPermissionsError {
        switch swift {
        case .userNotFound:
            return DBXTeamMembersSetPermissionsErrorUserNotFound()
        case .lastAdmin:
            return DBXTeamMembersSetPermissionsErrorLastAdmin()
        case .userNotInTeam:
            return DBXTeamMembersSetPermissionsErrorUserNotInTeam()
        case .cannotSetPermissions:
            return DBXTeamMembersSetPermissionsErrorCannotSetPermissions()
        case .teamLicenseLimit:
            return DBXTeamMembersSetPermissionsErrorTeamLicenseLimit()
        case .other:
            return DBXTeamMembersSetPermissionsErrorOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asUserNotFound: DBXTeamMembersSetPermissionsErrorUserNotFound? {
        self as? DBXTeamMembersSetPermissionsErrorUserNotFound
    }

    @objc
    public var asLastAdmin: DBXTeamMembersSetPermissionsErrorLastAdmin? {
        self as? DBXTeamMembersSetPermissionsErrorLastAdmin
    }

    @objc
    public var asUserNotInTeam: DBXTeamMembersSetPermissionsErrorUserNotInTeam? {
        self as? DBXTeamMembersSetPermissionsErrorUserNotInTeam
    }

    @objc
    public var asCannotSetPermissions: DBXTeamMembersSetPermissionsErrorCannotSetPermissions? {
        self as? DBXTeamMembersSetPermissionsErrorCannotSetPermissions
    }

    @objc
    public var asTeamLicenseLimit: DBXTeamMembersSetPermissionsErrorTeamLicenseLimit? {
        self as? DBXTeamMembersSetPermissionsErrorTeamLicenseLimit
    }

    @objc
    public var asOther: DBXTeamMembersSetPermissionsErrorOther? {
        self as? DBXTeamMembersSetPermissionsErrorOther
    }
}

/// No matching user found. The provided team_member_id, email, or external_id does not exist on this team.
@objc
public class DBXTeamMembersSetPermissionsErrorUserNotFound: DBXTeamMembersSetPermissionsError {
    @objc
    public init() {
        let swift = Team.MembersSetPermissionsError.userNotFound
        super.init(swift: swift)
    }
}

/// Cannot remove the admin setting of the last admin.
@objc
public class DBXTeamMembersSetPermissionsErrorLastAdmin: DBXTeamMembersSetPermissionsError {
    @objc
    public init() {
        let swift = Team.MembersSetPermissionsError.lastAdmin
        super.init(swift: swift)
    }
}

/// The user is not a member of the team.
@objc
public class DBXTeamMembersSetPermissionsErrorUserNotInTeam: DBXTeamMembersSetPermissionsError {
    @objc
    public init() {
        let swift = Team.MembersSetPermissionsError.userNotInTeam
        super.init(swift: swift)
    }
}

/// Cannot remove/grant permissions.
@objc
public class DBXTeamMembersSetPermissionsErrorCannotSetPermissions: DBXTeamMembersSetPermissionsError {
    @objc
    public init() {
        let swift = Team.MembersSetPermissionsError.cannotSetPermissions
        super.init(swift: swift)
    }
}

/// Team is full. The organization has no available licenses.
@objc
public class DBXTeamMembersSetPermissionsErrorTeamLicenseLimit: DBXTeamMembersSetPermissionsError {
    @objc
    public init() {
        let swift = Team.MembersSetPermissionsError.teamLicenseLimit
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXTeamMembersSetPermissionsErrorOther: DBXTeamMembersSetPermissionsError {
    @objc
    public init() {
        let swift = Team.MembersSetPermissionsError.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible MembersSetPermissionsResult struct
@objc
public class DBXTeamMembersSetPermissionsResult: NSObject {
    /// The member ID of the user to which the change was applied.
    @objc
    public var teamMemberId: String { swift.teamMemberId }
    /// The role after the change.
    @objc
    public var role: DBXTeamAdminTier { DBXTeamAdminTier(swift: swift.role) }

    @objc
    public init(teamMemberId: String, role: DBXTeamAdminTier) {
        self.swift = Team.MembersSetPermissionsResult(teamMemberId: teamMemberId, role: role.swift)
    }

    let swift: Team.MembersSetPermissionsResult

    public init(swift: Team.MembersSetPermissionsResult) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Exactly one of team_member_id, email, or external_id must be provided to identify the user account. At least one
/// of new_email, new_external_id, new_given_name, and/or new_surname must be provided.
@objc
public class DBXTeamMembersSetProfileArg: NSObject {
    /// Identity of user whose profile will be set.
    @objc
    public var user: DBXTeamUserSelectorArg { DBXTeamUserSelectorArg(swift: swift.user) }
    /// New email for member.
    @objc
    public var newEmail: String? { swift.newEmail }
    /// New external ID for member.
    @objc
    public var newExternalId: String? { swift.newExternalId }
    /// New given name for member.
    @objc
    public var newGivenName: String? { swift.newGivenName }
    /// New surname for member.
    @objc
    public var newSurname: String? { swift.newSurname }
    /// New persistent ID. This field only available to teams using persistent ID SAML configuration.
    @objc
    public var newPersistentId: String? { swift.newPersistentId }
    /// New value for whether the user is a directory restricted user.
    @objc
    public var newIsDirectoryRestricted: NSNumber? { swift.newIsDirectoryRestricted as NSNumber? }

    @objc
    public init(
        user: DBXTeamUserSelectorArg,
        newEmail: String?,
        newExternalId: String?,
        newGivenName: String?,
        newSurname: String?,
        newPersistentId: String?,
        newIsDirectoryRestricted: NSNumber?
    ) {
        self.swift = Team.MembersSetProfileArg(
            user: user.swift,
            newEmail: newEmail,
            newExternalId: newExternalId,
            newGivenName: newGivenName,
            newSurname: newSurname,
            newPersistentId: newPersistentId,
            newIsDirectoryRestricted: newIsDirectoryRestricted?.boolValue
        )
    }

    let swift: Team.MembersSetProfileArg

    public init(swift: Team.MembersSetProfileArg) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible MembersSetProfileError union
@objc
public class DBXTeamMembersSetProfileError: NSObject {
    let swift: Team.MembersSetProfileError

    public init(swift: Team.MembersSetProfileError) {
        self.swift = swift
    }

    public static func factory(swift: Team.MembersSetProfileError) -> DBXTeamMembersSetProfileError {
        switch swift {
        case .userNotFound:
            return DBXTeamMembersSetProfileErrorUserNotFound()
        case .userNotInTeam:
            return DBXTeamMembersSetProfileErrorUserNotInTeam()
        case .externalIdAndNewExternalIdUnsafe:
            return DBXTeamMembersSetProfileErrorExternalIdAndNewExternalIdUnsafe()
        case .noNewDataSpecified:
            return DBXTeamMembersSetProfileErrorNoNewDataSpecified()
        case .emailReservedForOtherUser:
            return DBXTeamMembersSetProfileErrorEmailReservedForOtherUser()
        case .externalIdUsedByOtherUser:
            return DBXTeamMembersSetProfileErrorExternalIdUsedByOtherUser()
        case .setProfileDisallowed:
            return DBXTeamMembersSetProfileErrorSetProfileDisallowed()
        case .paramCannotBeEmpty:
            return DBXTeamMembersSetProfileErrorParamCannotBeEmpty()
        case .persistentIdDisabled:
            return DBXTeamMembersSetProfileErrorPersistentIdDisabled()
        case .persistentIdUsedByOtherUser:
            return DBXTeamMembersSetProfileErrorPersistentIdUsedByOtherUser()
        case .directoryRestrictedOff:
            return DBXTeamMembersSetProfileErrorDirectoryRestrictedOff()
        case .other:
            return DBXTeamMembersSetProfileErrorOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asUserNotFound: DBXTeamMembersSetProfileErrorUserNotFound? {
        self as? DBXTeamMembersSetProfileErrorUserNotFound
    }

    @objc
    public var asUserNotInTeam: DBXTeamMembersSetProfileErrorUserNotInTeam? {
        self as? DBXTeamMembersSetProfileErrorUserNotInTeam
    }

    @objc
    public var asExternalIdAndNewExternalIdUnsafe: DBXTeamMembersSetProfileErrorExternalIdAndNewExternalIdUnsafe? {
        self as? DBXTeamMembersSetProfileErrorExternalIdAndNewExternalIdUnsafe
    }

    @objc
    public var asNoNewDataSpecified: DBXTeamMembersSetProfileErrorNoNewDataSpecified? {
        self as? DBXTeamMembersSetProfileErrorNoNewDataSpecified
    }

    @objc
    public var asEmailReservedForOtherUser: DBXTeamMembersSetProfileErrorEmailReservedForOtherUser? {
        self as? DBXTeamMembersSetProfileErrorEmailReservedForOtherUser
    }

    @objc
    public var asExternalIdUsedByOtherUser: DBXTeamMembersSetProfileErrorExternalIdUsedByOtherUser? {
        self as? DBXTeamMembersSetProfileErrorExternalIdUsedByOtherUser
    }

    @objc
    public var asSetProfileDisallowed: DBXTeamMembersSetProfileErrorSetProfileDisallowed? {
        self as? DBXTeamMembersSetProfileErrorSetProfileDisallowed
    }

    @objc
    public var asParamCannotBeEmpty: DBXTeamMembersSetProfileErrorParamCannotBeEmpty? {
        self as? DBXTeamMembersSetProfileErrorParamCannotBeEmpty
    }

    @objc
    public var asPersistentIdDisabled: DBXTeamMembersSetProfileErrorPersistentIdDisabled? {
        self as? DBXTeamMembersSetProfileErrorPersistentIdDisabled
    }

    @objc
    public var asPersistentIdUsedByOtherUser: DBXTeamMembersSetProfileErrorPersistentIdUsedByOtherUser? {
        self as? DBXTeamMembersSetProfileErrorPersistentIdUsedByOtherUser
    }

    @objc
    public var asDirectoryRestrictedOff: DBXTeamMembersSetProfileErrorDirectoryRestrictedOff? {
        self as? DBXTeamMembersSetProfileErrorDirectoryRestrictedOff
    }

    @objc
    public var asOther: DBXTeamMembersSetProfileErrorOther? {
        self as? DBXTeamMembersSetProfileErrorOther
    }
}

/// No matching user found. The provided team_member_id, email, or external_id does not exist on this team.
@objc
public class DBXTeamMembersSetProfileErrorUserNotFound: DBXTeamMembersSetProfileError {
    @objc
    public init() {
        let swift = Team.MembersSetProfileError.userNotFound
        super.init(swift: swift)
    }
}

/// The user is not a member of the team.
@objc
public class DBXTeamMembersSetProfileErrorUserNotInTeam: DBXTeamMembersSetProfileError {
    @objc
    public init() {
        let swift = Team.MembersSetProfileError.userNotInTeam
        super.init(swift: swift)
    }
}

/// It is unsafe to use both external_id and new_external_id.
@objc
public class DBXTeamMembersSetProfileErrorExternalIdAndNewExternalIdUnsafe: DBXTeamMembersSetProfileError {
    @objc
    public init() {
        let swift = Team.MembersSetProfileError.externalIdAndNewExternalIdUnsafe
        super.init(swift: swift)
    }
}

/// None of new_email, new_given_name, new_surname, or new_external_id are specified.
@objc
public class DBXTeamMembersSetProfileErrorNoNewDataSpecified: DBXTeamMembersSetProfileError {
    @objc
    public init() {
        let swift = Team.MembersSetProfileError.noNewDataSpecified
        super.init(swift: swift)
    }
}

/// Email is already reserved for another user.
@objc
public class DBXTeamMembersSetProfileErrorEmailReservedForOtherUser: DBXTeamMembersSetProfileError {
    @objc
    public init() {
        let swift = Team.MembersSetProfileError.emailReservedForOtherUser
        super.init(swift: swift)
    }
}

/// The external ID is already in use by another team member.
@objc
public class DBXTeamMembersSetProfileErrorExternalIdUsedByOtherUser: DBXTeamMembersSetProfileError {
    @objc
    public init() {
        let swift = Team.MembersSetProfileError.externalIdUsedByOtherUser
        super.init(swift: swift)
    }
}

/// Modifying deleted users is not allowed.
@objc
public class DBXTeamMembersSetProfileErrorSetProfileDisallowed: DBXTeamMembersSetProfileError {
    @objc
    public init() {
        let swift = Team.MembersSetProfileError.setProfileDisallowed
        super.init(swift: swift)
    }
}

/// Parameter new_email cannot be empty.
@objc
public class DBXTeamMembersSetProfileErrorParamCannotBeEmpty: DBXTeamMembersSetProfileError {
    @objc
    public init() {
        let swift = Team.MembersSetProfileError.paramCannotBeEmpty
        super.init(swift: swift)
    }
}

/// Persistent ID is only available to teams with persistent ID SAML configuration. Please contact Dropbox for
/// more information.
@objc
public class DBXTeamMembersSetProfileErrorPersistentIdDisabled: DBXTeamMembersSetProfileError {
    @objc
    public init() {
        let swift = Team.MembersSetProfileError.persistentIdDisabled
        super.init(swift: swift)
    }
}

/// The persistent ID is already in use by another team member.
@objc
public class DBXTeamMembersSetProfileErrorPersistentIdUsedByOtherUser: DBXTeamMembersSetProfileError {
    @objc
    public init() {
        let swift = Team.MembersSetProfileError.persistentIdUsedByOtherUser
        super.init(swift: swift)
    }
}

/// Directory Restrictions option is not available.
@objc
public class DBXTeamMembersSetProfileErrorDirectoryRestrictedOff: DBXTeamMembersSetProfileError {
    @objc
    public init() {
        let swift = Team.MembersSetProfileError.directoryRestrictedOff
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXTeamMembersSetProfileErrorOther: DBXTeamMembersSetProfileError {
    @objc
    public init() {
        let swift = Team.MembersSetProfileError.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible MembersSetProfilePhotoArg struct
@objc
public class DBXTeamMembersSetProfilePhotoArg: NSObject {
    /// Identity of the user whose profile photo will be set.
    @objc
    public var user: DBXTeamUserSelectorArg { DBXTeamUserSelectorArg(swift: swift.user) }
    /// Image to set as the member's new profile photo.
    @objc
    public var photo: DBXAccountPhotoSourceArg { DBXAccountPhotoSourceArg(swift: swift.photo) }

    @objc
    public init(user: DBXTeamUserSelectorArg, photo: DBXAccountPhotoSourceArg) {
        self.swift = Team.MembersSetProfilePhotoArg(user: user.swift, photo: photo.swift)
    }

    let swift: Team.MembersSetProfilePhotoArg

    public init(swift: Team.MembersSetProfilePhotoArg) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible MembersSetProfilePhotoError union
@objc
public class DBXTeamMembersSetProfilePhotoError: NSObject {
    let swift: Team.MembersSetProfilePhotoError

    public init(swift: Team.MembersSetProfilePhotoError) {
        self.swift = swift
    }

    public static func factory(swift: Team.MembersSetProfilePhotoError) -> DBXTeamMembersSetProfilePhotoError {
        switch swift {
        case .userNotFound:
            return DBXTeamMembersSetProfilePhotoErrorUserNotFound()
        case .userNotInTeam:
            return DBXTeamMembersSetProfilePhotoErrorUserNotInTeam()
        case .setProfileDisallowed:
            return DBXTeamMembersSetProfilePhotoErrorSetProfileDisallowed()
        case .photoError(let swiftArg):
            let arg = DBXAccountSetProfilePhotoError(swift: swiftArg)
            return DBXTeamMembersSetProfilePhotoErrorPhotoError(arg)
        case .other:
            return DBXTeamMembersSetProfilePhotoErrorOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asUserNotFound: DBXTeamMembersSetProfilePhotoErrorUserNotFound? {
        self as? DBXTeamMembersSetProfilePhotoErrorUserNotFound
    }

    @objc
    public var asUserNotInTeam: DBXTeamMembersSetProfilePhotoErrorUserNotInTeam? {
        self as? DBXTeamMembersSetProfilePhotoErrorUserNotInTeam
    }

    @objc
    public var asSetProfileDisallowed: DBXTeamMembersSetProfilePhotoErrorSetProfileDisallowed? {
        self as? DBXTeamMembersSetProfilePhotoErrorSetProfileDisallowed
    }

    @objc
    public var asPhotoError: DBXTeamMembersSetProfilePhotoErrorPhotoError? {
        self as? DBXTeamMembersSetProfilePhotoErrorPhotoError
    }

    @objc
    public var asOther: DBXTeamMembersSetProfilePhotoErrorOther? {
        self as? DBXTeamMembersSetProfilePhotoErrorOther
    }
}

/// No matching user found. The provided team_member_id, email, or external_id does not exist on this team.
@objc
public class DBXTeamMembersSetProfilePhotoErrorUserNotFound: DBXTeamMembersSetProfilePhotoError {
    @objc
    public init() {
        let swift = Team.MembersSetProfilePhotoError.userNotFound
        super.init(swift: swift)
    }
}

/// The user is not a member of the team.
@objc
public class DBXTeamMembersSetProfilePhotoErrorUserNotInTeam: DBXTeamMembersSetProfilePhotoError {
    @objc
    public init() {
        let swift = Team.MembersSetProfilePhotoError.userNotInTeam
        super.init(swift: swift)
    }
}

/// Modifying deleted users is not allowed.
@objc
public class DBXTeamMembersSetProfilePhotoErrorSetProfileDisallowed: DBXTeamMembersSetProfilePhotoError {
    @objc
    public init() {
        let swift = Team.MembersSetProfilePhotoError.setProfileDisallowed
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXTeamMembersSetProfilePhotoErrorPhotoError: DBXTeamMembersSetProfilePhotoError {
    @objc
    public var photoError: DBXAccountSetProfilePhotoError

    @objc
    public init(_ arg: DBXAccountSetProfilePhotoError) {
        self.photoError = arg
        let swift = Team.MembersSetProfilePhotoError.photoError(arg.swift)
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXTeamMembersSetProfilePhotoErrorOther: DBXTeamMembersSetProfilePhotoError {
    @objc
    public init() {
        let swift = Team.MembersSetProfilePhotoError.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible MembersSuspendError union
@objc
public class DBXTeamMembersSuspendError: NSObject {
    let swift: Team.MembersSuspendError

    public init(swift: Team.MembersSuspendError) {
        self.swift = swift
    }

    public static func factory(swift: Team.MembersSuspendError) -> DBXTeamMembersSuspendError {
        switch swift {
        case .userNotFound:
            return DBXTeamMembersSuspendErrorUserNotFound()
        case .userNotInTeam:
            return DBXTeamMembersSuspendErrorUserNotInTeam()
        case .other:
            return DBXTeamMembersSuspendErrorOther()
        case .suspendInactiveUser:
            return DBXTeamMembersSuspendErrorSuspendInactiveUser()
        case .suspendLastAdmin:
            return DBXTeamMembersSuspendErrorSuspendLastAdmin()
        case .teamLicenseLimit:
            return DBXTeamMembersSuspendErrorTeamLicenseLimit()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asUserNotFound: DBXTeamMembersSuspendErrorUserNotFound? {
        self as? DBXTeamMembersSuspendErrorUserNotFound
    }

    @objc
    public var asUserNotInTeam: DBXTeamMembersSuspendErrorUserNotInTeam? {
        self as? DBXTeamMembersSuspendErrorUserNotInTeam
    }

    @objc
    public var asOther: DBXTeamMembersSuspendErrorOther? {
        self as? DBXTeamMembersSuspendErrorOther
    }

    @objc
    public var asSuspendInactiveUser: DBXTeamMembersSuspendErrorSuspendInactiveUser? {
        self as? DBXTeamMembersSuspendErrorSuspendInactiveUser
    }

    @objc
    public var asSuspendLastAdmin: DBXTeamMembersSuspendErrorSuspendLastAdmin? {
        self as? DBXTeamMembersSuspendErrorSuspendLastAdmin
    }

    @objc
    public var asTeamLicenseLimit: DBXTeamMembersSuspendErrorTeamLicenseLimit? {
        self as? DBXTeamMembersSuspendErrorTeamLicenseLimit
    }
}

/// No matching user found. The provided team_member_id, email, or external_id does not exist on this team.
@objc
public class DBXTeamMembersSuspendErrorUserNotFound: DBXTeamMembersSuspendError {
    @objc
    public init() {
        let swift = Team.MembersSuspendError.userNotFound
        super.init(swift: swift)
    }
}

/// The user is not a member of the team.
@objc
public class DBXTeamMembersSuspendErrorUserNotInTeam: DBXTeamMembersSuspendError {
    @objc
    public init() {
        let swift = Team.MembersSuspendError.userNotInTeam
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXTeamMembersSuspendErrorOther: DBXTeamMembersSuspendError {
    @objc
    public init() {
        let swift = Team.MembersSuspendError.other
        super.init(swift: swift)
    }
}

/// The user is not active, so it cannot be suspended.
@objc
public class DBXTeamMembersSuspendErrorSuspendInactiveUser: DBXTeamMembersSuspendError {
    @objc
    public init() {
        let swift = Team.MembersSuspendError.suspendInactiveUser
        super.init(swift: swift)
    }
}

/// The user is the last admin of the team, so it cannot be suspended.
@objc
public class DBXTeamMembersSuspendErrorSuspendLastAdmin: DBXTeamMembersSuspendError {
    @objc
    public init() {
        let swift = Team.MembersSuspendError.suspendLastAdmin
        super.init(swift: swift)
    }
}

/// Team is full. The organization has no available licenses.
@objc
public class DBXTeamMembersSuspendErrorTeamLicenseLimit: DBXTeamMembersSuspendError {
    @objc
    public init() {
        let swift = Team.MembersSuspendError.teamLicenseLimit
        super.init(swift: swift)
    }
}

/// Objective-C compatible MembersTransferFormerMembersFilesError union
@objc
public class DBXTeamMembersTransferFormerMembersFilesError: NSObject {
    let swift: Team.MembersTransferFormerMembersFilesError

    public init(swift: Team.MembersTransferFormerMembersFilesError) {
        self.swift = swift
    }

    public static func factory(swift: Team.MembersTransferFormerMembersFilesError) -> DBXTeamMembersTransferFormerMembersFilesError {
        switch swift {
        case .userNotFound:
            return DBXTeamMembersTransferFormerMembersFilesErrorUserNotFound()
        case .userNotInTeam:
            return DBXTeamMembersTransferFormerMembersFilesErrorUserNotInTeam()
        case .other:
            return DBXTeamMembersTransferFormerMembersFilesErrorOther()
        case .removedAndTransferDestShouldDiffer:
            return DBXTeamMembersTransferFormerMembersFilesErrorRemovedAndTransferDestShouldDiffer()
        case .removedAndTransferAdminShouldDiffer:
            return DBXTeamMembersTransferFormerMembersFilesErrorRemovedAndTransferAdminShouldDiffer()
        case .transferDestUserNotFound:
            return DBXTeamMembersTransferFormerMembersFilesErrorTransferDestUserNotFound()
        case .transferDestUserNotInTeam:
            return DBXTeamMembersTransferFormerMembersFilesErrorTransferDestUserNotInTeam()
        case .transferAdminUserNotInTeam:
            return DBXTeamMembersTransferFormerMembersFilesErrorTransferAdminUserNotInTeam()
        case .transferAdminUserNotFound:
            return DBXTeamMembersTransferFormerMembersFilesErrorTransferAdminUserNotFound()
        case .unspecifiedTransferAdminId:
            return DBXTeamMembersTransferFormerMembersFilesErrorUnspecifiedTransferAdminId()
        case .transferAdminIsNotAdmin:
            return DBXTeamMembersTransferFormerMembersFilesErrorTransferAdminIsNotAdmin()
        case .recipientNotVerified:
            return DBXTeamMembersTransferFormerMembersFilesErrorRecipientNotVerified()
        case .userDataIsBeingTransferred:
            return DBXTeamMembersTransferFormerMembersFilesErrorUserDataIsBeingTransferred()
        case .userNotRemoved:
            return DBXTeamMembersTransferFormerMembersFilesErrorUserNotRemoved()
        case .userDataCannotBeTransferred:
            return DBXTeamMembersTransferFormerMembersFilesErrorUserDataCannotBeTransferred()
        case .userDataAlreadyTransferred:
            return DBXTeamMembersTransferFormerMembersFilesErrorUserDataAlreadyTransferred()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asUserNotFound: DBXTeamMembersTransferFormerMembersFilesErrorUserNotFound? {
        self as? DBXTeamMembersTransferFormerMembersFilesErrorUserNotFound
    }

    @objc
    public var asUserNotInTeam: DBXTeamMembersTransferFormerMembersFilesErrorUserNotInTeam? {
        self as? DBXTeamMembersTransferFormerMembersFilesErrorUserNotInTeam
    }

    @objc
    public var asOther: DBXTeamMembersTransferFormerMembersFilesErrorOther? {
        self as? DBXTeamMembersTransferFormerMembersFilesErrorOther
    }

    @objc
    public var asRemovedAndTransferDestShouldDiffer: DBXTeamMembersTransferFormerMembersFilesErrorRemovedAndTransferDestShouldDiffer? {
        self as? DBXTeamMembersTransferFormerMembersFilesErrorRemovedAndTransferDestShouldDiffer
    }

    @objc
    public var asRemovedAndTransferAdminShouldDiffer: DBXTeamMembersTransferFormerMembersFilesErrorRemovedAndTransferAdminShouldDiffer? {
        self as? DBXTeamMembersTransferFormerMembersFilesErrorRemovedAndTransferAdminShouldDiffer
    }

    @objc
    public var asTransferDestUserNotFound: DBXTeamMembersTransferFormerMembersFilesErrorTransferDestUserNotFound? {
        self as? DBXTeamMembersTransferFormerMembersFilesErrorTransferDestUserNotFound
    }

    @objc
    public var asTransferDestUserNotInTeam: DBXTeamMembersTransferFormerMembersFilesErrorTransferDestUserNotInTeam? {
        self as? DBXTeamMembersTransferFormerMembersFilesErrorTransferDestUserNotInTeam
    }

    @objc
    public var asTransferAdminUserNotInTeam: DBXTeamMembersTransferFormerMembersFilesErrorTransferAdminUserNotInTeam? {
        self as? DBXTeamMembersTransferFormerMembersFilesErrorTransferAdminUserNotInTeam
    }

    @objc
    public var asTransferAdminUserNotFound: DBXTeamMembersTransferFormerMembersFilesErrorTransferAdminUserNotFound? {
        self as? DBXTeamMembersTransferFormerMembersFilesErrorTransferAdminUserNotFound
    }

    @objc
    public var asUnspecifiedTransferAdminId: DBXTeamMembersTransferFormerMembersFilesErrorUnspecifiedTransferAdminId? {
        self as? DBXTeamMembersTransferFormerMembersFilesErrorUnspecifiedTransferAdminId
    }

    @objc
    public var asTransferAdminIsNotAdmin: DBXTeamMembersTransferFormerMembersFilesErrorTransferAdminIsNotAdmin? {
        self as? DBXTeamMembersTransferFormerMembersFilesErrorTransferAdminIsNotAdmin
    }

    @objc
    public var asRecipientNotVerified: DBXTeamMembersTransferFormerMembersFilesErrorRecipientNotVerified? {
        self as? DBXTeamMembersTransferFormerMembersFilesErrorRecipientNotVerified
    }

    @objc
    public var asUserDataIsBeingTransferred: DBXTeamMembersTransferFormerMembersFilesErrorUserDataIsBeingTransferred? {
        self as? DBXTeamMembersTransferFormerMembersFilesErrorUserDataIsBeingTransferred
    }

    @objc
    public var asUserNotRemoved: DBXTeamMembersTransferFormerMembersFilesErrorUserNotRemoved? {
        self as? DBXTeamMembersTransferFormerMembersFilesErrorUserNotRemoved
    }

    @objc
    public var asUserDataCannotBeTransferred: DBXTeamMembersTransferFormerMembersFilesErrorUserDataCannotBeTransferred? {
        self as? DBXTeamMembersTransferFormerMembersFilesErrorUserDataCannotBeTransferred
    }

    @objc
    public var asUserDataAlreadyTransferred: DBXTeamMembersTransferFormerMembersFilesErrorUserDataAlreadyTransferred? {
        self as? DBXTeamMembersTransferFormerMembersFilesErrorUserDataAlreadyTransferred
    }
}

/// No matching user found. The provided team_member_id, email, or external_id does not exist on this team.
@objc
public class DBXTeamMembersTransferFormerMembersFilesErrorUserNotFound: DBXTeamMembersTransferFormerMembersFilesError {
    @objc
    public init() {
        let swift = Team.MembersTransferFormerMembersFilesError.userNotFound
        super.init(swift: swift)
    }
}

/// The user is not a member of the team.
@objc
public class DBXTeamMembersTransferFormerMembersFilesErrorUserNotInTeam: DBXTeamMembersTransferFormerMembersFilesError {
    @objc
    public init() {
        let swift = Team.MembersTransferFormerMembersFilesError.userNotInTeam
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXTeamMembersTransferFormerMembersFilesErrorOther: DBXTeamMembersTransferFormerMembersFilesError {
    @objc
    public init() {
        let swift = Team.MembersTransferFormerMembersFilesError.other
        super.init(swift: swift)
    }
}

/// Expected removed user and transfer_dest user to be different.
@objc
public class DBXTeamMembersTransferFormerMembersFilesErrorRemovedAndTransferDestShouldDiffer: DBXTeamMembersTransferFormerMembersFilesError {
    @objc
    public init() {
        let swift = Team.MembersTransferFormerMembersFilesError.removedAndTransferDestShouldDiffer
        super.init(swift: swift)
    }
}

/// Expected removed user and transfer_admin user to be different.
@objc
public class DBXTeamMembersTransferFormerMembersFilesErrorRemovedAndTransferAdminShouldDiffer: DBXTeamMembersTransferFormerMembersFilesError {
    @objc
    public init() {
        let swift = Team.MembersTransferFormerMembersFilesError.removedAndTransferAdminShouldDiffer
        super.init(swift: swift)
    }
}

/// No matching user found for the argument transfer_dest_id.
@objc
public class DBXTeamMembersTransferFormerMembersFilesErrorTransferDestUserNotFound: DBXTeamMembersTransferFormerMembersFilesError {
    @objc
    public init() {
        let swift = Team.MembersTransferFormerMembersFilesError.transferDestUserNotFound
        super.init(swift: swift)
    }
}

/// The provided transfer_dest_id does not exist on this team.
@objc
public class DBXTeamMembersTransferFormerMembersFilesErrorTransferDestUserNotInTeam: DBXTeamMembersTransferFormerMembersFilesError {
    @objc
    public init() {
        let swift = Team.MembersTransferFormerMembersFilesError.transferDestUserNotInTeam
        super.init(swift: swift)
    }
}

/// The provided transfer_admin_id does not exist on this team.
@objc
public class DBXTeamMembersTransferFormerMembersFilesErrorTransferAdminUserNotInTeam: DBXTeamMembersTransferFormerMembersFilesError {
    @objc
    public init() {
        let swift = Team.MembersTransferFormerMembersFilesError.transferAdminUserNotInTeam
        super.init(swift: swift)
    }
}

/// No matching user found for the argument transfer_admin_id.
@objc
public class DBXTeamMembersTransferFormerMembersFilesErrorTransferAdminUserNotFound: DBXTeamMembersTransferFormerMembersFilesError {
    @objc
    public init() {
        let swift = Team.MembersTransferFormerMembersFilesError.transferAdminUserNotFound
        super.init(swift: swift)
    }
}

/// The transfer_admin_id argument must be provided when file transfer is requested.
@objc
public class DBXTeamMembersTransferFormerMembersFilesErrorUnspecifiedTransferAdminId: DBXTeamMembersTransferFormerMembersFilesError {
    @objc
    public init() {
        let swift = Team.MembersTransferFormerMembersFilesError.unspecifiedTransferAdminId
        super.init(swift: swift)
    }
}

/// Specified transfer_admin user is not a team admin.
@objc
public class DBXTeamMembersTransferFormerMembersFilesErrorTransferAdminIsNotAdmin: DBXTeamMembersTransferFormerMembersFilesError {
    @objc
    public init() {
        let swift = Team.MembersTransferFormerMembersFilesError.transferAdminIsNotAdmin
        super.init(swift: swift)
    }
}

/// The recipient user's email is not verified.
@objc
public class DBXTeamMembersTransferFormerMembersFilesErrorRecipientNotVerified: DBXTeamMembersTransferFormerMembersFilesError {
    @objc
    public init() {
        let swift = Team.MembersTransferFormerMembersFilesError.recipientNotVerified
        super.init(swift: swift)
    }
}

/// The user's data is being transferred. Please wait some time before retrying.
@objc
public class DBXTeamMembersTransferFormerMembersFilesErrorUserDataIsBeingTransferred: DBXTeamMembersTransferFormerMembersFilesError {
    @objc
    public init() {
        let swift = Team.MembersTransferFormerMembersFilesError.userDataIsBeingTransferred
        super.init(swift: swift)
    }
}

/// No matching removed user found for the argument user.
@objc
public class DBXTeamMembersTransferFormerMembersFilesErrorUserNotRemoved: DBXTeamMembersTransferFormerMembersFilesError {
    @objc
    public init() {
        let swift = Team.MembersTransferFormerMembersFilesError.userNotRemoved
        super.init(swift: swift)
    }
}

/// User files aren't transferable anymore.
@objc
public class DBXTeamMembersTransferFormerMembersFilesErrorUserDataCannotBeTransferred: DBXTeamMembersTransferFormerMembersFilesError {
    @objc
    public init() {
        let swift = Team.MembersTransferFormerMembersFilesError.userDataCannotBeTransferred
        super.init(swift: swift)
    }
}

/// User's data has already been transferred to another user.
@objc
public class DBXTeamMembersTransferFormerMembersFilesErrorUserDataAlreadyTransferred: DBXTeamMembersTransferFormerMembersFilesError {
    @objc
    public init() {
        let swift = Team.MembersTransferFormerMembersFilesError.userDataAlreadyTransferred
        super.init(swift: swift)
    }
}

/// Exactly one of team_member_id, email, or external_id must be provided to identify the user account.
@objc
public class DBXTeamMembersUnsuspendArg: NSObject {
    /// Identity of user to unsuspend.
    @objc
    public var user: DBXTeamUserSelectorArg { DBXTeamUserSelectorArg(swift: swift.user) }

    @objc
    public init(user: DBXTeamUserSelectorArg) {
        self.swift = Team.MembersUnsuspendArg(user: user.swift)
    }

    let swift: Team.MembersUnsuspendArg

    public init(swift: Team.MembersUnsuspendArg) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible MembersUnsuspendError union
@objc
public class DBXTeamMembersUnsuspendError: NSObject {
    let swift: Team.MembersUnsuspendError

    public init(swift: Team.MembersUnsuspendError) {
        self.swift = swift
    }

    public static func factory(swift: Team.MembersUnsuspendError) -> DBXTeamMembersUnsuspendError {
        switch swift {
        case .userNotFound:
            return DBXTeamMembersUnsuspendErrorUserNotFound()
        case .userNotInTeam:
            return DBXTeamMembersUnsuspendErrorUserNotInTeam()
        case .other:
            return DBXTeamMembersUnsuspendErrorOther()
        case .unsuspendNonSuspendedMember:
            return DBXTeamMembersUnsuspendErrorUnsuspendNonSuspendedMember()
        case .teamLicenseLimit:
            return DBXTeamMembersUnsuspendErrorTeamLicenseLimit()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asUserNotFound: DBXTeamMembersUnsuspendErrorUserNotFound? {
        self as? DBXTeamMembersUnsuspendErrorUserNotFound
    }

    @objc
    public var asUserNotInTeam: DBXTeamMembersUnsuspendErrorUserNotInTeam? {
        self as? DBXTeamMembersUnsuspendErrorUserNotInTeam
    }

    @objc
    public var asOther: DBXTeamMembersUnsuspendErrorOther? {
        self as? DBXTeamMembersUnsuspendErrorOther
    }

    @objc
    public var asUnsuspendNonSuspendedMember: DBXTeamMembersUnsuspendErrorUnsuspendNonSuspendedMember? {
        self as? DBXTeamMembersUnsuspendErrorUnsuspendNonSuspendedMember
    }

    @objc
    public var asTeamLicenseLimit: DBXTeamMembersUnsuspendErrorTeamLicenseLimit? {
        self as? DBXTeamMembersUnsuspendErrorTeamLicenseLimit
    }
}

/// No matching user found. The provided team_member_id, email, or external_id does not exist on this team.
@objc
public class DBXTeamMembersUnsuspendErrorUserNotFound: DBXTeamMembersUnsuspendError {
    @objc
    public init() {
        let swift = Team.MembersUnsuspendError.userNotFound
        super.init(swift: swift)
    }
}

/// The user is not a member of the team.
@objc
public class DBXTeamMembersUnsuspendErrorUserNotInTeam: DBXTeamMembersUnsuspendError {
    @objc
    public init() {
        let swift = Team.MembersUnsuspendError.userNotInTeam
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXTeamMembersUnsuspendErrorOther: DBXTeamMembersUnsuspendError {
    @objc
    public init() {
        let swift = Team.MembersUnsuspendError.other
        super.init(swift: swift)
    }
}

/// The user is unsuspended, so it cannot be unsuspended again.
@objc
public class DBXTeamMembersUnsuspendErrorUnsuspendNonSuspendedMember: DBXTeamMembersUnsuspendError {
    @objc
    public init() {
        let swift = Team.MembersUnsuspendError.unsuspendNonSuspendedMember
        super.init(swift: swift)
    }
}

/// Team is full. The organization has no available licenses.
@objc
public class DBXTeamMembersUnsuspendErrorTeamLicenseLimit: DBXTeamMembersUnsuspendError {
    @objc
    public init() {
        let swift = Team.MembersUnsuspendError.teamLicenseLimit
        super.init(swift: swift)
    }
}

/// Objective-C compatible MobileClientPlatform union
@objc
public class DBXTeamMobileClientPlatform: NSObject {
    let swift: Team.MobileClientPlatform

    public init(swift: Team.MobileClientPlatform) {
        self.swift = swift
    }

    public static func factory(swift: Team.MobileClientPlatform) -> DBXTeamMobileClientPlatform {
        switch swift {
        case .iphone:
            return DBXTeamMobileClientPlatformIphone()
        case .ipad:
            return DBXTeamMobileClientPlatformIpad()
        case .android:
            return DBXTeamMobileClientPlatformAndroid()
        case .windowsPhone:
            return DBXTeamMobileClientPlatformWindowsPhone()
        case .blackberry:
            return DBXTeamMobileClientPlatformBlackberry()
        case .other:
            return DBXTeamMobileClientPlatformOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asIphone: DBXTeamMobileClientPlatformIphone? {
        self as? DBXTeamMobileClientPlatformIphone
    }

    @objc
    public var asIpad: DBXTeamMobileClientPlatformIpad? {
        self as? DBXTeamMobileClientPlatformIpad
    }

    @objc
    public var asAndroid: DBXTeamMobileClientPlatformAndroid? {
        self as? DBXTeamMobileClientPlatformAndroid
    }

    @objc
    public var asWindowsPhone: DBXTeamMobileClientPlatformWindowsPhone? {
        self as? DBXTeamMobileClientPlatformWindowsPhone
    }

    @objc
    public var asBlackberry: DBXTeamMobileClientPlatformBlackberry? {
        self as? DBXTeamMobileClientPlatformBlackberry
    }

    @objc
    public var asOther: DBXTeamMobileClientPlatformOther? {
        self as? DBXTeamMobileClientPlatformOther
    }
}

/// Official Dropbox iPhone client.
@objc
public class DBXTeamMobileClientPlatformIphone: DBXTeamMobileClientPlatform {
    @objc
    public init() {
        let swift = Team.MobileClientPlatform.iphone
        super.init(swift: swift)
    }
}

/// Official Dropbox iPad client.
@objc
public class DBXTeamMobileClientPlatformIpad: DBXTeamMobileClientPlatform {
    @objc
    public init() {
        let swift = Team.MobileClientPlatform.ipad
        super.init(swift: swift)
    }
}

/// Official Dropbox Android client.
@objc
public class DBXTeamMobileClientPlatformAndroid: DBXTeamMobileClientPlatform {
    @objc
    public init() {
        let swift = Team.MobileClientPlatform.android
        super.init(swift: swift)
    }
}

/// Official Dropbox Windows phone client.
@objc
public class DBXTeamMobileClientPlatformWindowsPhone: DBXTeamMobileClientPlatform {
    @objc
    public init() {
        let swift = Team.MobileClientPlatform.windowsPhone
        super.init(swift: swift)
    }
}

/// Official Dropbox Blackberry client.
@objc
public class DBXTeamMobileClientPlatformBlackberry: DBXTeamMobileClientPlatform {
    @objc
    public init() {
        let swift = Team.MobileClientPlatform.blackberry
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXTeamMobileClientPlatformOther: DBXTeamMobileClientPlatform {
    @objc
    public init() {
        let swift = Team.MobileClientPlatform.other
        super.init(swift: swift)
    }
}

/// Information about linked Dropbox mobile client sessions.
@objc
public class DBXTeamMobileClientSession: DBXTeamDeviceSession {
    /// The device name.
    @objc
    public var deviceName: String { subSwift.deviceName }
    /// The mobile application type.
    @objc
    public var clientType: DBXTeamMobileClientPlatform { DBXTeamMobileClientPlatform(swift: subSwift.clientType) }
    /// The dropbox client version.
    @objc
    public var clientVersion: String? { subSwift.clientVersion }
    /// The hosting OS version.
    @objc
    public var osVersion: String? { subSwift.osVersion }
    /// last carrier used by the device.
    @objc
    public var lastCarrier: String? { subSwift.lastCarrier }

    @objc
    public init(
        sessionId: String,
        deviceName: String,
        clientType: DBXTeamMobileClientPlatform,
        ipAddress: String?,
        country: String?,
        created: Date?,
        updated: Date?,
        clientVersion: String?,
        osVersion: String?,
        lastCarrier: String?
    ) {
        let swift = Team.MobileClientSession(
            sessionId: sessionId,
            deviceName: deviceName,
            clientType: clientType.swift,
            ipAddress: ipAddress,
            country: country,
            created: created,
            updated: updated,
            clientVersion: clientVersion,
            osVersion: osVersion,
            lastCarrier: lastCarrier
        )
        self.subSwift = swift
        super.init(swift: swift)
    }

    let subSwift: Team.MobileClientSession

    public init(swift: Team.MobileClientSession) {
        self.subSwift = swift
        super.init(swift: swift)
    }

    @objc
    public override var description: String { subSwift.description }
}

/// Properties of a namespace.
@objc
public class DBXTeamNamespaceMetadata: NSObject {
    /// The name of this namespace.
    @objc
    public var name: String { swift.name }
    /// The ID of this namespace.
    @objc
    public var namespaceId: String { swift.namespaceId }
    /// The type of this namespace.
    @objc
    public var namespaceType: DBXTeamNamespaceType { DBXTeamNamespaceType(swift: swift.namespaceType) }
    /// If this is a team member or app folder, the ID of the owning team member. Otherwise, this field is not
    /// present.
    @objc
    public var teamMemberId: String? { swift.teamMemberId }

    @objc
    public init(name: String, namespaceId: String, namespaceType: DBXTeamNamespaceType, teamMemberId: String?) {
        self.swift = Team.NamespaceMetadata(name: name, namespaceId: namespaceId, namespaceType: namespaceType.swift, teamMemberId: teamMemberId)
    }

    let swift: Team.NamespaceMetadata

    public init(swift: Team.NamespaceMetadata) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible NamespaceType union
@objc
public class DBXTeamNamespaceType: NSObject {
    let swift: Team.NamespaceType

    public init(swift: Team.NamespaceType) {
        self.swift = swift
    }

    public static func factory(swift: Team.NamespaceType) -> DBXTeamNamespaceType {
        switch swift {
        case .appFolder:
            return DBXTeamNamespaceTypeAppFolder()
        case .sharedFolder:
            return DBXTeamNamespaceTypeSharedFolder()
        case .teamFolder:
            return DBXTeamNamespaceTypeTeamFolder()
        case .teamMemberFolder:
            return DBXTeamNamespaceTypeTeamMemberFolder()
        case .other:
            return DBXTeamNamespaceTypeOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asAppFolder: DBXTeamNamespaceTypeAppFolder? {
        self as? DBXTeamNamespaceTypeAppFolder
    }

    @objc
    public var asSharedFolder: DBXTeamNamespaceTypeSharedFolder? {
        self as? DBXTeamNamespaceTypeSharedFolder
    }

    @objc
    public var asTeamFolder: DBXTeamNamespaceTypeTeamFolder? {
        self as? DBXTeamNamespaceTypeTeamFolder
    }

    @objc
    public var asTeamMemberFolder: DBXTeamNamespaceTypeTeamMemberFolder? {
        self as? DBXTeamNamespaceTypeTeamMemberFolder
    }

    @objc
    public var asOther: DBXTeamNamespaceTypeOther? {
        self as? DBXTeamNamespaceTypeOther
    }
}

/// App sandbox folder.
@objc
public class DBXTeamNamespaceTypeAppFolder: DBXTeamNamespaceType {
    @objc
    public init() {
        let swift = Team.NamespaceType.appFolder
        super.init(swift: swift)
    }
}

/// Shared folder.
@objc
public class DBXTeamNamespaceTypeSharedFolder: DBXTeamNamespaceType {
    @objc
    public init() {
        let swift = Team.NamespaceType.sharedFolder
        super.init(swift: swift)
    }
}

/// Top-level team-owned folder.
@objc
public class DBXTeamNamespaceTypeTeamFolder: DBXTeamNamespaceType {
    @objc
    public init() {
        let swift = Team.NamespaceType.teamFolder
        super.init(swift: swift)
    }
}

/// Team member's home folder.
@objc
public class DBXTeamNamespaceTypeTeamMemberFolder: DBXTeamNamespaceType {
    @objc
    public init() {
        let swift = Team.NamespaceType.teamMemberFolder
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXTeamNamespaceTypeOther: DBXTeamNamespaceType {
    @objc
    public init() {
        let swift = Team.NamespaceType.other
        super.init(swift: swift)
    }
}

/// User result for setting member custom quota.
@objc
public class DBXTeamRemoveCustomQuotaResult: NSObject {
    let swift: Team.RemoveCustomQuotaResult

    public init(swift: Team.RemoveCustomQuotaResult) {
        self.swift = swift
    }

    public static func factory(swift: Team.RemoveCustomQuotaResult) -> DBXTeamRemoveCustomQuotaResult {
        switch swift {
        case .success(let swiftArg):
            let arg = DBXTeamUserSelectorArg(swift: swiftArg)
            return DBXTeamRemoveCustomQuotaResultSuccess(arg)
        case .invalidUser(let swiftArg):
            let arg = DBXTeamUserSelectorArg(swift: swiftArg)
            return DBXTeamRemoveCustomQuotaResultInvalidUser(arg)
        case .other:
            return DBXTeamRemoveCustomQuotaResultOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asSuccess: DBXTeamRemoveCustomQuotaResultSuccess? {
        self as? DBXTeamRemoveCustomQuotaResultSuccess
    }

    @objc
    public var asInvalidUser: DBXTeamRemoveCustomQuotaResultInvalidUser? {
        self as? DBXTeamRemoveCustomQuotaResultInvalidUser
    }

    @objc
    public var asOther: DBXTeamRemoveCustomQuotaResultOther? {
        self as? DBXTeamRemoveCustomQuotaResultOther
    }
}

/// Successfully removed user.
@objc
public class DBXTeamRemoveCustomQuotaResultSuccess: DBXTeamRemoveCustomQuotaResult {
    @objc
    public var success: DBXTeamUserSelectorArg

    @objc
    public init(_ arg: DBXTeamUserSelectorArg) {
        self.success = arg
        let swift = Team.RemoveCustomQuotaResult.success(arg.swift)
        super.init(swift: swift)
    }
}

/// Invalid user (not in team).
@objc
public class DBXTeamRemoveCustomQuotaResultInvalidUser: DBXTeamRemoveCustomQuotaResult {
    @objc
    public var invalidUser: DBXTeamUserSelectorArg

    @objc
    public init(_ arg: DBXTeamUserSelectorArg) {
        self.invalidUser = arg
        let swift = Team.RemoveCustomQuotaResult.invalidUser(arg.swift)
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXTeamRemoveCustomQuotaResultOther: DBXTeamRemoveCustomQuotaResult {
    @objc
    public init() {
        let swift = Team.RemoveCustomQuotaResult.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible RemovedStatus struct
@objc
public class DBXTeamRemovedStatus: NSObject {
    /// True if the removed team member is recoverable.
    @objc
    public var isRecoverable: NSNumber { swift.isRecoverable as NSNumber }
    /// True if the team member's account was converted to individual account.
    @objc
    public var isDisconnected: NSNumber { swift.isDisconnected as NSNumber }

    @objc
    public init(isRecoverable: NSNumber, isDisconnected: NSNumber) {
        self.swift = Team.RemovedStatus(isRecoverable: isRecoverable.boolValue, isDisconnected: isDisconnected.boolValue)
    }

    let swift: Team.RemovedStatus

    public init(swift: Team.RemovedStatus) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Result of trying to resend verification email to a secondary email address. 'success' is the only value
/// indicating that a verification email was successfully sent. The other values explain the type of error that
/// occurred, and include the email for which the error occurred.
@objc
public class DBXTeamResendSecondaryEmailResult: NSObject {
    let swift: Team.ResendSecondaryEmailResult

    public init(swift: Team.ResendSecondaryEmailResult) {
        self.swift = swift
    }

    public static func factory(swift: Team.ResendSecondaryEmailResult) -> DBXTeamResendSecondaryEmailResult {
        switch swift {
        case .success(let swiftArg):
            let arg = swiftArg
            return DBXTeamResendSecondaryEmailResultSuccess(arg)
        case .notPending(let swiftArg):
            let arg = swiftArg
            return DBXTeamResendSecondaryEmailResultNotPending(arg)
        case .rateLimited(let swiftArg):
            let arg = swiftArg
            return DBXTeamResendSecondaryEmailResultRateLimited(arg)
        case .other:
            return DBXTeamResendSecondaryEmailResultOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asSuccess: DBXTeamResendSecondaryEmailResultSuccess? {
        self as? DBXTeamResendSecondaryEmailResultSuccess
    }

    @objc
    public var asNotPending: DBXTeamResendSecondaryEmailResultNotPending? {
        self as? DBXTeamResendSecondaryEmailResultNotPending
    }

    @objc
    public var asRateLimited: DBXTeamResendSecondaryEmailResultRateLimited? {
        self as? DBXTeamResendSecondaryEmailResultRateLimited
    }

    @objc
    public var asOther: DBXTeamResendSecondaryEmailResultOther? {
        self as? DBXTeamResendSecondaryEmailResultOther
    }
}

/// A verification email was successfully sent to the secondary email address.
@objc
public class DBXTeamResendSecondaryEmailResultSuccess: DBXTeamResendSecondaryEmailResult {
    @objc
    public var success: String

    @objc
    public init(_ arg: String) {
        self.success = arg
        let swift = Team.ResendSecondaryEmailResult.success(arg)
        super.init(swift: swift)
    }
}

/// This secondary email address is not pending for the user.
@objc
public class DBXTeamResendSecondaryEmailResultNotPending: DBXTeamResendSecondaryEmailResult {
    @objc
    public var notPending: String

    @objc
    public init(_ arg: String) {
        self.notPending = arg
        let swift = Team.ResendSecondaryEmailResult.notPending(arg)
        super.init(swift: swift)
    }
}

/// Too many emails are being sent to this email address. Please try again later.
@objc
public class DBXTeamResendSecondaryEmailResultRateLimited: DBXTeamResendSecondaryEmailResult {
    @objc
    public var rateLimited: String

    @objc
    public init(_ arg: String) {
        self.rateLimited = arg
        let swift = Team.ResendSecondaryEmailResult.rateLimited(arg)
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXTeamResendSecondaryEmailResultOther: DBXTeamResendSecondaryEmailResult {
    @objc
    public init() {
        let swift = Team.ResendSecondaryEmailResult.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible ResendVerificationEmailArg struct
@objc
public class DBXTeamResendVerificationEmailArg: NSObject {
    /// List of users and secondary emails to resend verification emails to.
    @objc
    public var emailsToResend: [DBXTeamUserSecondaryEmailsArg] { swift.emailsToResend.map { DBXTeamUserSecondaryEmailsArg(swift: $0) } }

    @objc
    public init(emailsToResend: [DBXTeamUserSecondaryEmailsArg]) {
        self.swift = Team.ResendVerificationEmailArg(emailsToResend: emailsToResend.map(\.swift))
    }

    let swift: Team.ResendVerificationEmailArg

    public init(swift: Team.ResendVerificationEmailArg) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// List of users and resend results.
@objc
public class DBXTeamResendVerificationEmailResult: NSObject {
    /// (no description)
    @objc
    public var results: [DBXTeamUserResendResult] { swift.results.map { DBXTeamUserResendResult(swift: $0) } }

    @objc
    public init(results: [DBXTeamUserResendResult]) {
        self.swift = Team.ResendVerificationEmailResult(results: results.map(\.swift))
    }

    let swift: Team.ResendVerificationEmailResult

    public init(swift: Team.ResendVerificationEmailResult) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible RevokeDesktopClientArg struct
@objc
public class DBXTeamRevokeDesktopClientArg: DBXTeamDeviceSessionArg {
    /// Whether to delete all files of the account (this is possible only if supported by the desktop client and
    /// will be made the next time the client access the account).
    @objc
    public var deleteOnUnlink: NSNumber { subSwift.deleteOnUnlink as NSNumber }

    @objc
    public init(sessionId: String, teamMemberId: String, deleteOnUnlink: NSNumber) {
        let swift = Team.RevokeDesktopClientArg(sessionId: sessionId, teamMemberId: teamMemberId, deleteOnUnlink: deleteOnUnlink.boolValue)
        self.subSwift = swift
        super.init(swift: swift)
    }

    let subSwift: Team.RevokeDesktopClientArg

    public init(swift: Team.RevokeDesktopClientArg) {
        self.subSwift = swift
        super.init(swift: swift)
    }

    @objc
    public override var description: String { subSwift.description }
}

/// Objective-C compatible RevokeDeviceSessionArg union
@objc
public class DBXTeamRevokeDeviceSessionArg: NSObject {
    let swift: Team.RevokeDeviceSessionArg

    public init(swift: Team.RevokeDeviceSessionArg) {
        self.swift = swift
    }

    public static func factory(swift: Team.RevokeDeviceSessionArg) -> DBXTeamRevokeDeviceSessionArg {
        switch swift {
        case .webSession(let swiftArg):
            let arg = DBXTeamDeviceSessionArg(swift: swiftArg)
            return DBXTeamRevokeDeviceSessionArgWebSession(arg)
        case .desktopClient(let swiftArg):
            let arg = DBXTeamRevokeDesktopClientArg(swift: swiftArg)
            return DBXTeamRevokeDeviceSessionArgDesktopClient(arg)
        case .mobileClient(let swiftArg):
            let arg = DBXTeamDeviceSessionArg(swift: swiftArg)
            return DBXTeamRevokeDeviceSessionArgMobileClient(arg)
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asWebSession: DBXTeamRevokeDeviceSessionArgWebSession? {
        self as? DBXTeamRevokeDeviceSessionArgWebSession
    }

    @objc
    public var asDesktopClient: DBXTeamRevokeDeviceSessionArgDesktopClient? {
        self as? DBXTeamRevokeDeviceSessionArgDesktopClient
    }

    @objc
    public var asMobileClient: DBXTeamRevokeDeviceSessionArgMobileClient? {
        self as? DBXTeamRevokeDeviceSessionArgMobileClient
    }
}

/// End an active session.
@objc
public class DBXTeamRevokeDeviceSessionArgWebSession: DBXTeamRevokeDeviceSessionArg {
    @objc
    public var webSession: DBXTeamDeviceSessionArg

    @objc
    public init(_ arg: DBXTeamDeviceSessionArg) {
        self.webSession = arg
        let swift = Team.RevokeDeviceSessionArg.webSession(arg.swift)
        super.init(swift: swift)
    }
}

/// Unlink a linked desktop device.
@objc
public class DBXTeamRevokeDeviceSessionArgDesktopClient: DBXTeamRevokeDeviceSessionArg {
    @objc
    public var desktopClient: DBXTeamRevokeDesktopClientArg

    @objc
    public init(_ arg: DBXTeamRevokeDesktopClientArg) {
        self.desktopClient = arg
        let swift = Team.RevokeDeviceSessionArg.desktopClient(arg.subSwift)
        super.init(swift: swift)
    }
}

/// Unlink a linked mobile device.
@objc
public class DBXTeamRevokeDeviceSessionArgMobileClient: DBXTeamRevokeDeviceSessionArg {
    @objc
    public var mobileClient: DBXTeamDeviceSessionArg

    @objc
    public init(_ arg: DBXTeamDeviceSessionArg) {
        self.mobileClient = arg
        let swift = Team.RevokeDeviceSessionArg.mobileClient(arg.swift)
        super.init(swift: swift)
    }
}

/// Objective-C compatible RevokeDeviceSessionBatchArg struct
@objc
public class DBXTeamRevokeDeviceSessionBatchArg: NSObject {
    /// (no description)
    @objc
    public var revokeDevices: [DBXTeamRevokeDeviceSessionArg] { swift.revokeDevices.map { DBXTeamRevokeDeviceSessionArg(swift: $0) } }

    @objc
    public init(revokeDevices: [DBXTeamRevokeDeviceSessionArg]) {
        self.swift = Team.RevokeDeviceSessionBatchArg(revokeDevices: revokeDevices.map(\.swift))
    }

    let swift: Team.RevokeDeviceSessionBatchArg

    public init(swift: Team.RevokeDeviceSessionBatchArg) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible RevokeDeviceSessionBatchError union
@objc
public class DBXTeamRevokeDeviceSessionBatchError: NSObject {
    let swift: Team.RevokeDeviceSessionBatchError

    public init(swift: Team.RevokeDeviceSessionBatchError) {
        self.swift = swift
    }

    public static func factory(swift: Team.RevokeDeviceSessionBatchError) -> DBXTeamRevokeDeviceSessionBatchError {
        switch swift {
        case .other:
            return DBXTeamRevokeDeviceSessionBatchErrorOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asOther: DBXTeamRevokeDeviceSessionBatchErrorOther? {
        self as? DBXTeamRevokeDeviceSessionBatchErrorOther
    }
}

/// An unspecified error.
@objc
public class DBXTeamRevokeDeviceSessionBatchErrorOther: DBXTeamRevokeDeviceSessionBatchError {
    @objc
    public init() {
        let swift = Team.RevokeDeviceSessionBatchError.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible RevokeDeviceSessionBatchResult struct
@objc
public class DBXTeamRevokeDeviceSessionBatchResult: NSObject {
    /// (no description)
    @objc
    public var revokeDevicesStatus: [DBXTeamRevokeDeviceSessionStatus] { swift.revokeDevicesStatus.map { DBXTeamRevokeDeviceSessionStatus(swift: $0) } }

    @objc
    public init(revokeDevicesStatus: [DBXTeamRevokeDeviceSessionStatus]) {
        self.swift = Team.RevokeDeviceSessionBatchResult(revokeDevicesStatus: revokeDevicesStatus.map(\.swift))
    }

    let swift: Team.RevokeDeviceSessionBatchResult

    public init(swift: Team.RevokeDeviceSessionBatchResult) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible RevokeDeviceSessionError union
@objc
public class DBXTeamRevokeDeviceSessionError: NSObject {
    let swift: Team.RevokeDeviceSessionError

    public init(swift: Team.RevokeDeviceSessionError) {
        self.swift = swift
    }

    public static func factory(swift: Team.RevokeDeviceSessionError) -> DBXTeamRevokeDeviceSessionError {
        switch swift {
        case .deviceSessionNotFound:
            return DBXTeamRevokeDeviceSessionErrorDeviceSessionNotFound()
        case .memberNotFound:
            return DBXTeamRevokeDeviceSessionErrorMemberNotFound()
        case .other:
            return DBXTeamRevokeDeviceSessionErrorOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asDeviceSessionNotFound: DBXTeamRevokeDeviceSessionErrorDeviceSessionNotFound? {
        self as? DBXTeamRevokeDeviceSessionErrorDeviceSessionNotFound
    }

    @objc
    public var asMemberNotFound: DBXTeamRevokeDeviceSessionErrorMemberNotFound? {
        self as? DBXTeamRevokeDeviceSessionErrorMemberNotFound
    }

    @objc
    public var asOther: DBXTeamRevokeDeviceSessionErrorOther? {
        self as? DBXTeamRevokeDeviceSessionErrorOther
    }
}

/// Device session not found.
@objc
public class DBXTeamRevokeDeviceSessionErrorDeviceSessionNotFound: DBXTeamRevokeDeviceSessionError {
    @objc
    public init() {
        let swift = Team.RevokeDeviceSessionError.deviceSessionNotFound
        super.init(swift: swift)
    }
}

/// Member not found.
@objc
public class DBXTeamRevokeDeviceSessionErrorMemberNotFound: DBXTeamRevokeDeviceSessionError {
    @objc
    public init() {
        let swift = Team.RevokeDeviceSessionError.memberNotFound
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXTeamRevokeDeviceSessionErrorOther: DBXTeamRevokeDeviceSessionError {
    @objc
    public init() {
        let swift = Team.RevokeDeviceSessionError.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible RevokeDeviceSessionStatus struct
@objc
public class DBXTeamRevokeDeviceSessionStatus: NSObject {
    /// Result of the revoking request.
    @objc
    public var success: NSNumber { swift.success as NSNumber }
    /// The error cause in case of a failure.
    @objc
    public var errorType: DBXTeamRevokeDeviceSessionError? { guard let swift = swift.errorType else { return nil }
        return DBXTeamRevokeDeviceSessionError(swift: swift)
    }

    @objc
    public init(success: NSNumber, errorType: DBXTeamRevokeDeviceSessionError?) {
        self.swift = Team.RevokeDeviceSessionStatus(success: success.boolValue, errorType: errorType?.swift)
    }

    let swift: Team.RevokeDeviceSessionStatus

    public init(swift: Team.RevokeDeviceSessionStatus) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible RevokeLinkedApiAppArg struct
@objc
public class DBXTeamRevokeLinkedApiAppArg: NSObject {
    /// The application's unique id.
    @objc
    public var appId: String { swift.appId }
    /// The unique id of the member owning the device.
    @objc
    public var teamMemberId: String { swift.teamMemberId }
    /// This flag is not longer supported, the application dedicated folder (in case the application uses  one) will
    /// be kept.
    @objc
    public var keepAppFolder: NSNumber { swift.keepAppFolder as NSNumber }

    @objc
    public init(appId: String, teamMemberId: String, keepAppFolder: NSNumber) {
        self.swift = Team.RevokeLinkedApiAppArg(appId: appId, teamMemberId: teamMemberId, keepAppFolder: keepAppFolder.boolValue)
    }

    let swift: Team.RevokeLinkedApiAppArg

    public init(swift: Team.RevokeLinkedApiAppArg) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible RevokeLinkedApiAppBatchArg struct
@objc
public class DBXTeamRevokeLinkedApiAppBatchArg: NSObject {
    /// (no description)
    @objc
    public var revokeLinkedApp: [DBXTeamRevokeLinkedApiAppArg] { swift.revokeLinkedApp.map { DBXTeamRevokeLinkedApiAppArg(swift: $0) } }

    @objc
    public init(revokeLinkedApp: [DBXTeamRevokeLinkedApiAppArg]) {
        self.swift = Team.RevokeLinkedApiAppBatchArg(revokeLinkedApp: revokeLinkedApp.map(\.swift))
    }

    let swift: Team.RevokeLinkedApiAppBatchArg

    public init(swift: Team.RevokeLinkedApiAppBatchArg) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Error returned by linkedAppsRevokeLinkedAppBatch.
@objc
public class DBXTeamRevokeLinkedAppBatchError: NSObject {
    let swift: Team.RevokeLinkedAppBatchError

    public init(swift: Team.RevokeLinkedAppBatchError) {
        self.swift = swift
    }

    public static func factory(swift: Team.RevokeLinkedAppBatchError) -> DBXTeamRevokeLinkedAppBatchError {
        switch swift {
        case .other:
            return DBXTeamRevokeLinkedAppBatchErrorOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asOther: DBXTeamRevokeLinkedAppBatchErrorOther? {
        self as? DBXTeamRevokeLinkedAppBatchErrorOther
    }
}

/// An unspecified error.
@objc
public class DBXTeamRevokeLinkedAppBatchErrorOther: DBXTeamRevokeLinkedAppBatchError {
    @objc
    public init() {
        let swift = Team.RevokeLinkedAppBatchError.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible RevokeLinkedAppBatchResult struct
@objc
public class DBXTeamRevokeLinkedAppBatchResult: NSObject {
    /// (no description)
    @objc
    public var revokeLinkedAppStatus: [DBXTeamRevokeLinkedAppStatus] { swift.revokeLinkedAppStatus.map { DBXTeamRevokeLinkedAppStatus(swift: $0) } }

    @objc
    public init(revokeLinkedAppStatus: [DBXTeamRevokeLinkedAppStatus]) {
        self.swift = Team.RevokeLinkedAppBatchResult(revokeLinkedAppStatus: revokeLinkedAppStatus.map(\.swift))
    }

    let swift: Team.RevokeLinkedAppBatchResult

    public init(swift: Team.RevokeLinkedAppBatchResult) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Error returned by linkedAppsRevokeLinkedApp.
@objc
public class DBXTeamRevokeLinkedAppError: NSObject {
    let swift: Team.RevokeLinkedAppError

    public init(swift: Team.RevokeLinkedAppError) {
        self.swift = swift
    }

    public static func factory(swift: Team.RevokeLinkedAppError) -> DBXTeamRevokeLinkedAppError {
        switch swift {
        case .appNotFound:
            return DBXTeamRevokeLinkedAppErrorAppNotFound()
        case .memberNotFound:
            return DBXTeamRevokeLinkedAppErrorMemberNotFound()
        case .appFolderRemovalNotSupported:
            return DBXTeamRevokeLinkedAppErrorAppFolderRemovalNotSupported()
        case .other:
            return DBXTeamRevokeLinkedAppErrorOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asAppNotFound: DBXTeamRevokeLinkedAppErrorAppNotFound? {
        self as? DBXTeamRevokeLinkedAppErrorAppNotFound
    }

    @objc
    public var asMemberNotFound: DBXTeamRevokeLinkedAppErrorMemberNotFound? {
        self as? DBXTeamRevokeLinkedAppErrorMemberNotFound
    }

    @objc
    public var asAppFolderRemovalNotSupported: DBXTeamRevokeLinkedAppErrorAppFolderRemovalNotSupported? {
        self as? DBXTeamRevokeLinkedAppErrorAppFolderRemovalNotSupported
    }

    @objc
    public var asOther: DBXTeamRevokeLinkedAppErrorOther? {
        self as? DBXTeamRevokeLinkedAppErrorOther
    }
}

/// Application not found.
@objc
public class DBXTeamRevokeLinkedAppErrorAppNotFound: DBXTeamRevokeLinkedAppError {
    @objc
    public init() {
        let swift = Team.RevokeLinkedAppError.appNotFound
        super.init(swift: swift)
    }
}

/// Member not found.
@objc
public class DBXTeamRevokeLinkedAppErrorMemberNotFound: DBXTeamRevokeLinkedAppError {
    @objc
    public init() {
        let swift = Team.RevokeLinkedAppError.memberNotFound
        super.init(swift: swift)
    }
}

/// App folder removal is not supported.
@objc
public class DBXTeamRevokeLinkedAppErrorAppFolderRemovalNotSupported: DBXTeamRevokeLinkedAppError {
    @objc
    public init() {
        let swift = Team.RevokeLinkedAppError.appFolderRemovalNotSupported
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXTeamRevokeLinkedAppErrorOther: DBXTeamRevokeLinkedAppError {
    @objc
    public init() {
        let swift = Team.RevokeLinkedAppError.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible RevokeLinkedAppStatus struct
@objc
public class DBXTeamRevokeLinkedAppStatus: NSObject {
    /// Result of the revoking request.
    @objc
    public var success: NSNumber { swift.success as NSNumber }
    /// The error cause in case of a failure.
    @objc
    public var errorType: DBXTeamRevokeLinkedAppError? { guard let swift = swift.errorType else { return nil }
        return DBXTeamRevokeLinkedAppError(swift: swift)
    }

    @objc
    public init(success: NSNumber, errorType: DBXTeamRevokeLinkedAppError?) {
        self.swift = Team.RevokeLinkedAppStatus(success: success.boolValue, errorType: errorType?.swift)
    }

    let swift: Team.RevokeLinkedAppStatus

    public init(swift: Team.RevokeLinkedAppStatus) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible SetCustomQuotaArg struct
@objc
public class DBXTeamSetCustomQuotaArg: NSObject {
    /// List of users and their custom quotas.
    @objc
    public var usersAndQuotas: [DBXTeamUserCustomQuotaArg] { swift.usersAndQuotas.map { DBXTeamUserCustomQuotaArg(swift: $0) } }

    @objc
    public init(usersAndQuotas: [DBXTeamUserCustomQuotaArg]) {
        self.swift = Team.SetCustomQuotaArg(usersAndQuotas: usersAndQuotas.map(\.swift))
    }

    let swift: Team.SetCustomQuotaArg

    public init(swift: Team.SetCustomQuotaArg) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Error returned when setting member custom quota.
@objc
public class DBXTeamSetCustomQuotaError: NSObject {
    let swift: Team.SetCustomQuotaError

    public init(swift: Team.SetCustomQuotaError) {
        self.swift = swift
    }

    public static func factory(swift: Team.SetCustomQuotaError) -> DBXTeamSetCustomQuotaError {
        switch swift {
        case .tooManyUsers:
            return DBXTeamSetCustomQuotaErrorTooManyUsers()
        case .other:
            return DBXTeamSetCustomQuotaErrorOther()
        case .someUsersAreExcluded:
            return DBXTeamSetCustomQuotaErrorSomeUsersAreExcluded()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asTooManyUsers: DBXTeamSetCustomQuotaErrorTooManyUsers? {
        self as? DBXTeamSetCustomQuotaErrorTooManyUsers
    }

    @objc
    public var asOther: DBXTeamSetCustomQuotaErrorOther? {
        self as? DBXTeamSetCustomQuotaErrorOther
    }

    @objc
    public var asSomeUsersAreExcluded: DBXTeamSetCustomQuotaErrorSomeUsersAreExcluded? {
        self as? DBXTeamSetCustomQuotaErrorSomeUsersAreExcluded
    }
}

/// A maximum of 1000 users can be set for a single call.
@objc
public class DBXTeamSetCustomQuotaErrorTooManyUsers: DBXTeamSetCustomQuotaError {
    @objc
    public init() {
        let swift = Team.SetCustomQuotaError.tooManyUsers
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXTeamSetCustomQuotaErrorOther: DBXTeamSetCustomQuotaError {
    @objc
    public init() {
        let swift = Team.SetCustomQuotaError.other
        super.init(swift: swift)
    }
}

/// Some of the users are on the excluded users list and can't have custom quota set.
@objc
public class DBXTeamSetCustomQuotaErrorSomeUsersAreExcluded: DBXTeamSetCustomQuotaError {
    @objc
    public init() {
        let swift = Team.SetCustomQuotaError.someUsersAreExcluded
        super.init(swift: swift)
    }
}

/// Structure representing Approve List entries. Domain and emails are supported. At least one entry of any
/// supported type is required.
@objc
public class DBXTeamSharingAllowlistAddArgs: NSObject {
    /// List of domains represented by valid string representation (RFC-1034/5).
    @objc
    public var domains: [String]? { swift.domains }
    /// List of emails represented by valid string representation (RFC-5322/822).
    @objc
    public var emails: [String]? { swift.emails }

    @objc
    public init(domains: [String]?, emails: [String]?) {
        self.swift = Team.SharingAllowlistAddArgs(domains: domains, emails: emails)
    }

    let swift: Team.SharingAllowlistAddArgs

    public init(swift: Team.SharingAllowlistAddArgs) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible SharingAllowlistAddError union
@objc
public class DBXTeamSharingAllowlistAddError: NSObject {
    let swift: Team.SharingAllowlistAddError

    public init(swift: Team.SharingAllowlistAddError) {
        self.swift = swift
    }

    public static func factory(swift: Team.SharingAllowlistAddError) -> DBXTeamSharingAllowlistAddError {
        switch swift {
        case .malformedEntry(let swiftArg):
            let arg = swiftArg
            return DBXTeamSharingAllowlistAddErrorMalformedEntry(arg)
        case .noEntriesProvided:
            return DBXTeamSharingAllowlistAddErrorNoEntriesProvided()
        case .tooManyEntriesProvided:
            return DBXTeamSharingAllowlistAddErrorTooManyEntriesProvided()
        case .teamLimitReached:
            return DBXTeamSharingAllowlistAddErrorTeamLimitReached()
        case .unknownError:
            return DBXTeamSharingAllowlistAddErrorUnknownError()
        case .entriesAlreadyExist(let swiftArg):
            let arg = swiftArg
            return DBXTeamSharingAllowlistAddErrorEntriesAlreadyExist(arg)
        case .other:
            return DBXTeamSharingAllowlistAddErrorOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asMalformedEntry: DBXTeamSharingAllowlistAddErrorMalformedEntry? {
        self as? DBXTeamSharingAllowlistAddErrorMalformedEntry
    }

    @objc
    public var asNoEntriesProvided: DBXTeamSharingAllowlistAddErrorNoEntriesProvided? {
        self as? DBXTeamSharingAllowlistAddErrorNoEntriesProvided
    }

    @objc
    public var asTooManyEntriesProvided: DBXTeamSharingAllowlistAddErrorTooManyEntriesProvided? {
        self as? DBXTeamSharingAllowlistAddErrorTooManyEntriesProvided
    }

    @objc
    public var asTeamLimitReached: DBXTeamSharingAllowlistAddErrorTeamLimitReached? {
        self as? DBXTeamSharingAllowlistAddErrorTeamLimitReached
    }

    @objc
    public var asUnknownError: DBXTeamSharingAllowlistAddErrorUnknownError? {
        self as? DBXTeamSharingAllowlistAddErrorUnknownError
    }

    @objc
    public var asEntriesAlreadyExist: DBXTeamSharingAllowlistAddErrorEntriesAlreadyExist? {
        self as? DBXTeamSharingAllowlistAddErrorEntriesAlreadyExist
    }

    @objc
    public var asOther: DBXTeamSharingAllowlistAddErrorOther? {
        self as? DBXTeamSharingAllowlistAddErrorOther
    }
}

/// One of provided values is not valid.
@objc
public class DBXTeamSharingAllowlistAddErrorMalformedEntry: DBXTeamSharingAllowlistAddError {
    @objc
    public var malformedEntry: String

    @objc
    public init(_ arg: String) {
        self.malformedEntry = arg
        let swift = Team.SharingAllowlistAddError.malformedEntry(arg)
        super.init(swift: swift)
    }
}

/// Neither single domain nor email provided.
@objc
public class DBXTeamSharingAllowlistAddErrorNoEntriesProvided: DBXTeamSharingAllowlistAddError {
    @objc
    public init() {
        let swift = Team.SharingAllowlistAddError.noEntriesProvided
        super.init(swift: swift)
    }
}

/// Too many entries provided within one call.
@objc
public class DBXTeamSharingAllowlistAddErrorTooManyEntriesProvided: DBXTeamSharingAllowlistAddError {
    @objc
    public init() {
        let swift = Team.SharingAllowlistAddError.tooManyEntriesProvided
        super.init(swift: swift)
    }
}

/// Team entries limit reached.
@objc
public class DBXTeamSharingAllowlistAddErrorTeamLimitReached: DBXTeamSharingAllowlistAddError {
    @objc
    public init() {
        let swift = Team.SharingAllowlistAddError.teamLimitReached
        super.init(swift: swift)
    }
}

/// Unknown error.
@objc
public class DBXTeamSharingAllowlistAddErrorUnknownError: DBXTeamSharingAllowlistAddError {
    @objc
    public init() {
        let swift = Team.SharingAllowlistAddError.unknownError
        super.init(swift: swift)
    }
}

/// Entries already exists.
@objc
public class DBXTeamSharingAllowlistAddErrorEntriesAlreadyExist: DBXTeamSharingAllowlistAddError {
    @objc
    public var entriesAlreadyExist: String

    @objc
    public init(_ arg: String) {
        self.entriesAlreadyExist = arg
        let swift = Team.SharingAllowlistAddError.entriesAlreadyExist(arg)
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXTeamSharingAllowlistAddErrorOther: DBXTeamSharingAllowlistAddError {
    @objc
    public init() {
        let swift = Team.SharingAllowlistAddError.other
        super.init(swift: swift)
    }
}

/// This struct is empty. The comment here is intentionally emitted to avoid indentation issues with Stone.
@objc
public class DBXTeamSharingAllowlistAddResponse: NSObject {
    let swift: Team.SharingAllowlistAddResponse

    public init(swift: Team.SharingAllowlistAddResponse) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible SharingAllowlistListArg struct
@objc
public class DBXTeamSharingAllowlistListArg: NSObject {
    /// The number of entries to fetch at one time.
    @objc
    public var limit: NSNumber { swift.limit as NSNumber }

    @objc
    public init(limit: NSNumber) {
        self.swift = Team.SharingAllowlistListArg(limit: limit.uint32Value)
    }

    let swift: Team.SharingAllowlistListArg

    public init(swift: Team.SharingAllowlistListArg) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible SharingAllowlistListContinueArg struct
@objc
public class DBXTeamSharingAllowlistListContinueArg: NSObject {
    /// The cursor returned from a previous call to sharingAllowlistList or sharingAllowlistListContinue.
    @objc
    public var cursor: String { swift.cursor }

    @objc
    public init(cursor: String) {
        self.swift = Team.SharingAllowlistListContinueArg(cursor: cursor)
    }

    let swift: Team.SharingAllowlistListContinueArg

    public init(swift: Team.SharingAllowlistListContinueArg) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible SharingAllowlistListContinueError union
@objc
public class DBXTeamSharingAllowlistListContinueError: NSObject {
    let swift: Team.SharingAllowlistListContinueError

    public init(swift: Team.SharingAllowlistListContinueError) {
        self.swift = swift
    }

    public static func factory(swift: Team.SharingAllowlistListContinueError) -> DBXTeamSharingAllowlistListContinueError {
        switch swift {
        case .invalidCursor:
            return DBXTeamSharingAllowlistListContinueErrorInvalidCursor()
        case .other:
            return DBXTeamSharingAllowlistListContinueErrorOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asInvalidCursor: DBXTeamSharingAllowlistListContinueErrorInvalidCursor? {
        self as? DBXTeamSharingAllowlistListContinueErrorInvalidCursor
    }

    @objc
    public var asOther: DBXTeamSharingAllowlistListContinueErrorOther? {
        self as? DBXTeamSharingAllowlistListContinueErrorOther
    }
}

/// Provided cursor is not valid.
@objc
public class DBXTeamSharingAllowlistListContinueErrorInvalidCursor: DBXTeamSharingAllowlistListContinueError {
    @objc
    public init() {
        let swift = Team.SharingAllowlistListContinueError.invalidCursor
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXTeamSharingAllowlistListContinueErrorOther: DBXTeamSharingAllowlistListContinueError {
    @objc
    public init() {
        let swift = Team.SharingAllowlistListContinueError.other
        super.init(swift: swift)
    }
}

/// This struct is empty. The comment here is intentionally emitted to avoid indentation issues with Stone.
@objc
public class DBXTeamSharingAllowlistListError: NSObject {
    let swift: Team.SharingAllowlistListError

    public init(swift: Team.SharingAllowlistListError) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible SharingAllowlistListResponse struct
@objc
public class DBXTeamSharingAllowlistListResponse: NSObject {
    /// List of domains represented by valid string representation (RFC-1034/5).
    @objc
    public var domains: [String] { swift.domains }
    /// List of emails represented by valid string representation (RFC-5322/822).
    @objc
    public var emails: [String] { swift.emails }
    /// If this is nonempty, there are more entries that can be fetched with sharingAllowlistListContinue.
    @objc
    public var cursor: String { swift.cursor }
    /// if true indicates that more entries can be fetched with sharingAllowlistListContinue.
    @objc
    public var hasMore: NSNumber { swift.hasMore as NSNumber }

    @objc
    public init(domains: [String], emails: [String], cursor: String, hasMore: NSNumber) {
        self.swift = Team.SharingAllowlistListResponse(domains: domains, emails: emails, cursor: cursor, hasMore: hasMore.boolValue)
    }

    let swift: Team.SharingAllowlistListResponse

    public init(swift: Team.SharingAllowlistListResponse) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible SharingAllowlistRemoveArgs struct
@objc
public class DBXTeamSharingAllowlistRemoveArgs: NSObject {
    /// List of domains represented by valid string representation (RFC-1034/5).
    @objc
    public var domains: [String]? { swift.domains }
    /// List of emails represented by valid string representation (RFC-5322/822).
    @objc
    public var emails: [String]? { swift.emails }

    @objc
    public init(domains: [String]?, emails: [String]?) {
        self.swift = Team.SharingAllowlistRemoveArgs(domains: domains, emails: emails)
    }

    let swift: Team.SharingAllowlistRemoveArgs

    public init(swift: Team.SharingAllowlistRemoveArgs) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible SharingAllowlistRemoveError union
@objc
public class DBXTeamSharingAllowlistRemoveError: NSObject {
    let swift: Team.SharingAllowlistRemoveError

    public init(swift: Team.SharingAllowlistRemoveError) {
        self.swift = swift
    }

    public static func factory(swift: Team.SharingAllowlistRemoveError) -> DBXTeamSharingAllowlistRemoveError {
        switch swift {
        case .malformedEntry(let swiftArg):
            let arg = swiftArg
            return DBXTeamSharingAllowlistRemoveErrorMalformedEntry(arg)
        case .entriesDoNotExist(let swiftArg):
            let arg = swiftArg
            return DBXTeamSharingAllowlistRemoveErrorEntriesDoNotExist(arg)
        case .noEntriesProvided:
            return DBXTeamSharingAllowlistRemoveErrorNoEntriesProvided()
        case .tooManyEntriesProvided:
            return DBXTeamSharingAllowlistRemoveErrorTooManyEntriesProvided()
        case .unknownError:
            return DBXTeamSharingAllowlistRemoveErrorUnknownError()
        case .other:
            return DBXTeamSharingAllowlistRemoveErrorOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asMalformedEntry: DBXTeamSharingAllowlistRemoveErrorMalformedEntry? {
        self as? DBXTeamSharingAllowlistRemoveErrorMalformedEntry
    }

    @objc
    public var asEntriesDoNotExist: DBXTeamSharingAllowlistRemoveErrorEntriesDoNotExist? {
        self as? DBXTeamSharingAllowlistRemoveErrorEntriesDoNotExist
    }

    @objc
    public var asNoEntriesProvided: DBXTeamSharingAllowlistRemoveErrorNoEntriesProvided? {
        self as? DBXTeamSharingAllowlistRemoveErrorNoEntriesProvided
    }

    @objc
    public var asTooManyEntriesProvided: DBXTeamSharingAllowlistRemoveErrorTooManyEntriesProvided? {
        self as? DBXTeamSharingAllowlistRemoveErrorTooManyEntriesProvided
    }

    @objc
    public var asUnknownError: DBXTeamSharingAllowlistRemoveErrorUnknownError? {
        self as? DBXTeamSharingAllowlistRemoveErrorUnknownError
    }

    @objc
    public var asOther: DBXTeamSharingAllowlistRemoveErrorOther? {
        self as? DBXTeamSharingAllowlistRemoveErrorOther
    }
}

/// One of provided values is not valid.
@objc
public class DBXTeamSharingAllowlistRemoveErrorMalformedEntry: DBXTeamSharingAllowlistRemoveError {
    @objc
    public var malformedEntry: String

    @objc
    public init(_ arg: String) {
        self.malformedEntry = arg
        let swift = Team.SharingAllowlistRemoveError.malformedEntry(arg)
        super.init(swift: swift)
    }
}

/// One or more provided values do not exist.
@objc
public class DBXTeamSharingAllowlistRemoveErrorEntriesDoNotExist: DBXTeamSharingAllowlistRemoveError {
    @objc
    public var entriesDoNotExist: String

    @objc
    public init(_ arg: String) {
        self.entriesDoNotExist = arg
        let swift = Team.SharingAllowlistRemoveError.entriesDoNotExist(arg)
        super.init(swift: swift)
    }
}

/// Neither single domain nor email provided.
@objc
public class DBXTeamSharingAllowlistRemoveErrorNoEntriesProvided: DBXTeamSharingAllowlistRemoveError {
    @objc
    public init() {
        let swift = Team.SharingAllowlistRemoveError.noEntriesProvided
        super.init(swift: swift)
    }
}

/// Too many entries provided within one call.
@objc
public class DBXTeamSharingAllowlistRemoveErrorTooManyEntriesProvided: DBXTeamSharingAllowlistRemoveError {
    @objc
    public init() {
        let swift = Team.SharingAllowlistRemoveError.tooManyEntriesProvided
        super.init(swift: swift)
    }
}

/// Unknown error.
@objc
public class DBXTeamSharingAllowlistRemoveErrorUnknownError: DBXTeamSharingAllowlistRemoveError {
    @objc
    public init() {
        let swift = Team.SharingAllowlistRemoveError.unknownError
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXTeamSharingAllowlistRemoveErrorOther: DBXTeamSharingAllowlistRemoveError {
    @objc
    public init() {
        let swift = Team.SharingAllowlistRemoveError.other
        super.init(swift: swift)
    }
}

/// This struct is empty. The comment here is intentionally emitted to avoid indentation issues with Stone.
@objc
public class DBXTeamSharingAllowlistRemoveResponse: NSObject {
    let swift: Team.SharingAllowlistRemoveResponse

    public init(swift: Team.SharingAllowlistRemoveResponse) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Describes the number of users in a specific storage bucket.
@objc
public class DBXTeamStorageBucket: NSObject {
    /// The name of the storage bucket. For example, '1G' is a bucket of users with storage size up to 1 Giga.
    @objc
    public var bucket: String { swift.bucket }
    /// The number of people whose storage is in the range of this storage bucket.
    @objc
    public var users: NSNumber { swift.users as NSNumber }

    @objc
    public init(bucket: String, users: NSNumber) {
        self.swift = Team.StorageBucket(bucket: bucket, users: users.uint64Value)
    }

    let swift: Team.StorageBucket

    public init(swift: Team.StorageBucket) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible TeamFolderAccessError union
@objc
public class DBXTeamTeamFolderAccessError: NSObject {
    let swift: Team.TeamFolderAccessError

    public init(swift: Team.TeamFolderAccessError) {
        self.swift = swift
    }

    public static func factory(swift: Team.TeamFolderAccessError) -> DBXTeamTeamFolderAccessError {
        switch swift {
        case .invalidTeamFolderId:
            return DBXTeamTeamFolderAccessErrorInvalidTeamFolderId()
        case .noAccess:
            return DBXTeamTeamFolderAccessErrorNoAccess()
        case .other:
            return DBXTeamTeamFolderAccessErrorOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asInvalidTeamFolderId: DBXTeamTeamFolderAccessErrorInvalidTeamFolderId? {
        self as? DBXTeamTeamFolderAccessErrorInvalidTeamFolderId
    }

    @objc
    public var asNoAccess: DBXTeamTeamFolderAccessErrorNoAccess? {
        self as? DBXTeamTeamFolderAccessErrorNoAccess
    }

    @objc
    public var asOther: DBXTeamTeamFolderAccessErrorOther? {
        self as? DBXTeamTeamFolderAccessErrorOther
    }
}

/// The team folder ID is invalid.
@objc
public class DBXTeamTeamFolderAccessErrorInvalidTeamFolderId: DBXTeamTeamFolderAccessError {
    @objc
    public init() {
        let swift = Team.TeamFolderAccessError.invalidTeamFolderId
        super.init(swift: swift)
    }
}

/// The authenticated app does not have permission to manage that team folder.
@objc
public class DBXTeamTeamFolderAccessErrorNoAccess: DBXTeamTeamFolderAccessError {
    @objc
    public init() {
        let swift = Team.TeamFolderAccessError.noAccess
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXTeamTeamFolderAccessErrorOther: DBXTeamTeamFolderAccessError {
    @objc
    public init() {
        let swift = Team.TeamFolderAccessError.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible TeamFolderActivateError union
@objc
public class DBXTeamTeamFolderActivateError: NSObject {
    let swift: Team.TeamFolderActivateError

    public init(swift: Team.TeamFolderActivateError) {
        self.swift = swift
    }

    public static func factory(swift: Team.TeamFolderActivateError) -> DBXTeamTeamFolderActivateError {
        switch swift {
        case .accessError(let swiftArg):
            let arg = DBXTeamTeamFolderAccessError(swift: swiftArg)
            return DBXTeamTeamFolderActivateErrorAccessError(arg)
        case .statusError(let swiftArg):
            let arg = DBXTeamTeamFolderInvalidStatusError(swift: swiftArg)
            return DBXTeamTeamFolderActivateErrorStatusError(arg)
        case .teamSharedDropboxError(let swiftArg):
            let arg = DBXTeamTeamFolderTeamSharedDropboxError(swift: swiftArg)
            return DBXTeamTeamFolderActivateErrorTeamSharedDropboxError(arg)
        case .other:
            return DBXTeamTeamFolderActivateErrorOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asAccessError: DBXTeamTeamFolderActivateErrorAccessError? {
        self as? DBXTeamTeamFolderActivateErrorAccessError
    }

    @objc
    public var asStatusError: DBXTeamTeamFolderActivateErrorStatusError? {
        self as? DBXTeamTeamFolderActivateErrorStatusError
    }

    @objc
    public var asTeamSharedDropboxError: DBXTeamTeamFolderActivateErrorTeamSharedDropboxError? {
        self as? DBXTeamTeamFolderActivateErrorTeamSharedDropboxError
    }

    @objc
    public var asOther: DBXTeamTeamFolderActivateErrorOther? {
        self as? DBXTeamTeamFolderActivateErrorOther
    }
}

/// An unspecified error.
@objc
public class DBXTeamTeamFolderActivateErrorAccessError: DBXTeamTeamFolderActivateError {
    @objc
    public var accessError: DBXTeamTeamFolderAccessError

    @objc
    public init(_ arg: DBXTeamTeamFolderAccessError) {
        self.accessError = arg
        let swift = Team.TeamFolderActivateError.accessError(arg.swift)
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXTeamTeamFolderActivateErrorStatusError: DBXTeamTeamFolderActivateError {
    @objc
    public var statusError: DBXTeamTeamFolderInvalidStatusError

    @objc
    public init(_ arg: DBXTeamTeamFolderInvalidStatusError) {
        self.statusError = arg
        let swift = Team.TeamFolderActivateError.statusError(arg.swift)
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXTeamTeamFolderActivateErrorTeamSharedDropboxError: DBXTeamTeamFolderActivateError {
    @objc
    public var teamSharedDropboxError: DBXTeamTeamFolderTeamSharedDropboxError

    @objc
    public init(_ arg: DBXTeamTeamFolderTeamSharedDropboxError) {
        self.teamSharedDropboxError = arg
        let swift = Team.TeamFolderActivateError.teamSharedDropboxError(arg.swift)
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXTeamTeamFolderActivateErrorOther: DBXTeamTeamFolderActivateError {
    @objc
    public init() {
        let swift = Team.TeamFolderActivateError.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible TeamFolderIdArg struct
@objc
public class DBXTeamTeamFolderIdArg: NSObject {
    /// The ID of the team folder.
    @objc
    public var teamFolderId: String { swift.teamFolderId }

    @objc
    public init(teamFolderId: String) {
        self.swift = Team.TeamFolderIdArg(teamFolderId: teamFolderId)
    }

    let swift: Team.TeamFolderIdArg

    public init(swift: Team.TeamFolderIdArg) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible TeamFolderArchiveArg struct
@objc
public class DBXTeamTeamFolderArchiveArg: DBXTeamTeamFolderIdArg {
    /// Whether to force the archive to happen synchronously.
    @objc
    public var forceAsyncOff: NSNumber { subSwift.forceAsyncOff as NSNumber }

    @objc
    public init(teamFolderId: String, forceAsyncOff: NSNumber) {
        let swift = Team.TeamFolderArchiveArg(teamFolderId: teamFolderId, forceAsyncOff: forceAsyncOff.boolValue)
        self.subSwift = swift
        super.init(swift: swift)
    }

    let subSwift: Team.TeamFolderArchiveArg

    public init(swift: Team.TeamFolderArchiveArg) {
        self.subSwift = swift
        super.init(swift: swift)
    }

    @objc
    public override var description: String { subSwift.description }
}

/// Objective-C compatible TeamFolderArchiveError union
@objc
public class DBXTeamTeamFolderArchiveError: NSObject {
    let swift: Team.TeamFolderArchiveError

    public init(swift: Team.TeamFolderArchiveError) {
        self.swift = swift
    }

    public static func factory(swift: Team.TeamFolderArchiveError) -> DBXTeamTeamFolderArchiveError {
        switch swift {
        case .accessError(let swiftArg):
            let arg = DBXTeamTeamFolderAccessError(swift: swiftArg)
            return DBXTeamTeamFolderArchiveErrorAccessError(arg)
        case .statusError(let swiftArg):
            let arg = DBXTeamTeamFolderInvalidStatusError(swift: swiftArg)
            return DBXTeamTeamFolderArchiveErrorStatusError(arg)
        case .teamSharedDropboxError(let swiftArg):
            let arg = DBXTeamTeamFolderTeamSharedDropboxError(swift: swiftArg)
            return DBXTeamTeamFolderArchiveErrorTeamSharedDropboxError(arg)
        case .other:
            return DBXTeamTeamFolderArchiveErrorOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asAccessError: DBXTeamTeamFolderArchiveErrorAccessError? {
        self as? DBXTeamTeamFolderArchiveErrorAccessError
    }

    @objc
    public var asStatusError: DBXTeamTeamFolderArchiveErrorStatusError? {
        self as? DBXTeamTeamFolderArchiveErrorStatusError
    }

    @objc
    public var asTeamSharedDropboxError: DBXTeamTeamFolderArchiveErrorTeamSharedDropboxError? {
        self as? DBXTeamTeamFolderArchiveErrorTeamSharedDropboxError
    }

    @objc
    public var asOther: DBXTeamTeamFolderArchiveErrorOther? {
        self as? DBXTeamTeamFolderArchiveErrorOther
    }
}

/// An unspecified error.
@objc
public class DBXTeamTeamFolderArchiveErrorAccessError: DBXTeamTeamFolderArchiveError {
    @objc
    public var accessError: DBXTeamTeamFolderAccessError

    @objc
    public init(_ arg: DBXTeamTeamFolderAccessError) {
        self.accessError = arg
        let swift = Team.TeamFolderArchiveError.accessError(arg.swift)
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXTeamTeamFolderArchiveErrorStatusError: DBXTeamTeamFolderArchiveError {
    @objc
    public var statusError: DBXTeamTeamFolderInvalidStatusError

    @objc
    public init(_ arg: DBXTeamTeamFolderInvalidStatusError) {
        self.statusError = arg
        let swift = Team.TeamFolderArchiveError.statusError(arg.swift)
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXTeamTeamFolderArchiveErrorTeamSharedDropboxError: DBXTeamTeamFolderArchiveError {
    @objc
    public var teamSharedDropboxError: DBXTeamTeamFolderTeamSharedDropboxError

    @objc
    public init(_ arg: DBXTeamTeamFolderTeamSharedDropboxError) {
        self.teamSharedDropboxError = arg
        let swift = Team.TeamFolderArchiveError.teamSharedDropboxError(arg.swift)
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXTeamTeamFolderArchiveErrorOther: DBXTeamTeamFolderArchiveError {
    @objc
    public init() {
        let swift = Team.TeamFolderArchiveError.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible TeamFolderArchiveJobStatus union
@objc
public class DBXTeamTeamFolderArchiveJobStatus: NSObject {
    let swift: Team.TeamFolderArchiveJobStatus

    public init(swift: Team.TeamFolderArchiveJobStatus) {
        self.swift = swift
    }

    public static func factory(swift: Team.TeamFolderArchiveJobStatus) -> DBXTeamTeamFolderArchiveJobStatus {
        switch swift {
        case .inProgress:
            return DBXTeamTeamFolderArchiveJobStatusInProgress()
        case .complete(let swiftArg):
            let arg = DBXTeamTeamFolderMetadata(swift: swiftArg)
            return DBXTeamTeamFolderArchiveJobStatusComplete(arg)
        case .failed(let swiftArg):
            let arg = DBXTeamTeamFolderArchiveError(swift: swiftArg)
            return DBXTeamTeamFolderArchiveJobStatusFailed(arg)
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asInProgress: DBXTeamTeamFolderArchiveJobStatusInProgress? {
        self as? DBXTeamTeamFolderArchiveJobStatusInProgress
    }

    @objc
    public var asComplete: DBXTeamTeamFolderArchiveJobStatusComplete? {
        self as? DBXTeamTeamFolderArchiveJobStatusComplete
    }

    @objc
    public var asFailed: DBXTeamTeamFolderArchiveJobStatusFailed? {
        self as? DBXTeamTeamFolderArchiveJobStatusFailed
    }
}

/// The asynchronous job is still in progress.
@objc
public class DBXTeamTeamFolderArchiveJobStatusInProgress: DBXTeamTeamFolderArchiveJobStatus {
    @objc
    public init() {
        let swift = Team.TeamFolderArchiveJobStatus.inProgress
        super.init(swift: swift)
    }
}

/// The archive job has finished. The value is the metadata for the resulting team folder.
@objc
public class DBXTeamTeamFolderArchiveJobStatusComplete: DBXTeamTeamFolderArchiveJobStatus {
    @objc
    public var complete: DBXTeamTeamFolderMetadata

    @objc
    public init(_ arg: DBXTeamTeamFolderMetadata) {
        self.complete = arg
        let swift = Team.TeamFolderArchiveJobStatus.complete(arg.swift)
        super.init(swift: swift)
    }
}

/// Error occurred while performing an asynchronous job from teamFolderArchive.
@objc
public class DBXTeamTeamFolderArchiveJobStatusFailed: DBXTeamTeamFolderArchiveJobStatus {
    @objc
    public var failed: DBXTeamTeamFolderArchiveError

    @objc
    public init(_ arg: DBXTeamTeamFolderArchiveError) {
        self.failed = arg
        let swift = Team.TeamFolderArchiveJobStatus.failed(arg.swift)
        super.init(swift: swift)
    }
}

/// Objective-C compatible TeamFolderArchiveLaunch union
@objc
public class DBXTeamTeamFolderArchiveLaunch: NSObject {
    let swift: Team.TeamFolderArchiveLaunch

    public init(swift: Team.TeamFolderArchiveLaunch) {
        self.swift = swift
    }

    public static func factory(swift: Team.TeamFolderArchiveLaunch) -> DBXTeamTeamFolderArchiveLaunch {
        switch swift {
        case .asyncJobId(let swiftArg):
            let arg = swiftArg
            return DBXTeamTeamFolderArchiveLaunchAsyncJobId(arg)
        case .complete(let swiftArg):
            let arg = DBXTeamTeamFolderMetadata(swift: swiftArg)
            return DBXTeamTeamFolderArchiveLaunchComplete(arg)
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asAsyncJobId: DBXTeamTeamFolderArchiveLaunchAsyncJobId? {
        self as? DBXTeamTeamFolderArchiveLaunchAsyncJobId
    }

    @objc
    public var asComplete: DBXTeamTeamFolderArchiveLaunchComplete? {
        self as? DBXTeamTeamFolderArchiveLaunchComplete
    }
}

/// This response indicates that the processing is asynchronous. The string is an id that can be used to obtain
/// the status of the asynchronous job.
@objc
public class DBXTeamTeamFolderArchiveLaunchAsyncJobId: DBXTeamTeamFolderArchiveLaunch {
    @objc
    public var asyncJobId: String

    @objc
    public init(_ arg: String) {
        self.asyncJobId = arg
        let swift = Team.TeamFolderArchiveLaunch.asyncJobId(arg)
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXTeamTeamFolderArchiveLaunchComplete: DBXTeamTeamFolderArchiveLaunch {
    @objc
    public var complete: DBXTeamTeamFolderMetadata

    @objc
    public init(_ arg: DBXTeamTeamFolderMetadata) {
        self.complete = arg
        let swift = Team.TeamFolderArchiveLaunch.complete(arg.swift)
        super.init(swift: swift)
    }
}

/// Objective-C compatible TeamFolderCreateArg struct
@objc
public class DBXTeamTeamFolderCreateArg: NSObject {
    /// Name for the new team folder.
    @objc
    public var name: String { swift.name }
    /// The sync setting to apply to this team folder. Only permitted if the team has team selective sync enabled.
    @objc
    public var syncSetting: DBXFilesSyncSettingArg? { guard let swift = swift.syncSetting else { return nil }
        return DBXFilesSyncSettingArg(swift: swift)
    }

    @objc
    public init(name: String, syncSetting: DBXFilesSyncSettingArg?) {
        self.swift = Team.TeamFolderCreateArg(name: name, syncSetting: syncSetting?.swift)
    }

    let swift: Team.TeamFolderCreateArg

    public init(swift: Team.TeamFolderCreateArg) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible TeamFolderCreateError union
@objc
public class DBXTeamTeamFolderCreateError: NSObject {
    let swift: Team.TeamFolderCreateError

    public init(swift: Team.TeamFolderCreateError) {
        self.swift = swift
    }

    public static func factory(swift: Team.TeamFolderCreateError) -> DBXTeamTeamFolderCreateError {
        switch swift {
        case .invalidFolderName:
            return DBXTeamTeamFolderCreateErrorInvalidFolderName()
        case .folderNameAlreadyUsed:
            return DBXTeamTeamFolderCreateErrorFolderNameAlreadyUsed()
        case .folderNameReserved:
            return DBXTeamTeamFolderCreateErrorFolderNameReserved()
        case .syncSettingsError(let swiftArg):
            let arg = DBXFilesSyncSettingsError(swift: swiftArg)
            return DBXTeamTeamFolderCreateErrorSyncSettingsError(arg)
        case .other:
            return DBXTeamTeamFolderCreateErrorOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asInvalidFolderName: DBXTeamTeamFolderCreateErrorInvalidFolderName? {
        self as? DBXTeamTeamFolderCreateErrorInvalidFolderName
    }

    @objc
    public var asFolderNameAlreadyUsed: DBXTeamTeamFolderCreateErrorFolderNameAlreadyUsed? {
        self as? DBXTeamTeamFolderCreateErrorFolderNameAlreadyUsed
    }

    @objc
    public var asFolderNameReserved: DBXTeamTeamFolderCreateErrorFolderNameReserved? {
        self as? DBXTeamTeamFolderCreateErrorFolderNameReserved
    }

    @objc
    public var asSyncSettingsError: DBXTeamTeamFolderCreateErrorSyncSettingsError? {
        self as? DBXTeamTeamFolderCreateErrorSyncSettingsError
    }

    @objc
    public var asOther: DBXTeamTeamFolderCreateErrorOther? {
        self as? DBXTeamTeamFolderCreateErrorOther
    }
}

/// The provided name cannot be used.
@objc
public class DBXTeamTeamFolderCreateErrorInvalidFolderName: DBXTeamTeamFolderCreateError {
    @objc
    public init() {
        let swift = Team.TeamFolderCreateError.invalidFolderName
        super.init(swift: swift)
    }
}

/// There is already a team folder with the provided name.
@objc
public class DBXTeamTeamFolderCreateErrorFolderNameAlreadyUsed: DBXTeamTeamFolderCreateError {
    @objc
    public init() {
        let swift = Team.TeamFolderCreateError.folderNameAlreadyUsed
        super.init(swift: swift)
    }
}

/// The provided name cannot be used because it is reserved.
@objc
public class DBXTeamTeamFolderCreateErrorFolderNameReserved: DBXTeamTeamFolderCreateError {
    @objc
    public init() {
        let swift = Team.TeamFolderCreateError.folderNameReserved
        super.init(swift: swift)
    }
}

/// An error occurred setting the sync settings.
@objc
public class DBXTeamTeamFolderCreateErrorSyncSettingsError: DBXTeamTeamFolderCreateError {
    @objc
    public var syncSettingsError: DBXFilesSyncSettingsError

    @objc
    public init(_ arg: DBXFilesSyncSettingsError) {
        self.syncSettingsError = arg
        let swift = Team.TeamFolderCreateError.syncSettingsError(arg.swift)
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXTeamTeamFolderCreateErrorOther: DBXTeamTeamFolderCreateError {
    @objc
    public init() {
        let swift = Team.TeamFolderCreateError.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible TeamFolderGetInfoItem union
@objc
public class DBXTeamTeamFolderGetInfoItem: NSObject {
    let swift: Team.TeamFolderGetInfoItem

    public init(swift: Team.TeamFolderGetInfoItem) {
        self.swift = swift
    }

    public static func factory(swift: Team.TeamFolderGetInfoItem) -> DBXTeamTeamFolderGetInfoItem {
        switch swift {
        case .idNotFound(let swiftArg):
            let arg = swiftArg
            return DBXTeamTeamFolderGetInfoItemIdNotFound(arg)
        case .teamFolderMetadata(let swiftArg):
            let arg = DBXTeamTeamFolderMetadata(swift: swiftArg)
            return DBXTeamTeamFolderGetInfoItemTeamFolderMetadata(arg)
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asIdNotFound: DBXTeamTeamFolderGetInfoItemIdNotFound? {
        self as? DBXTeamTeamFolderGetInfoItemIdNotFound
    }

    @objc
    public var asTeamFolderMetadata: DBXTeamTeamFolderGetInfoItemTeamFolderMetadata? {
        self as? DBXTeamTeamFolderGetInfoItemTeamFolderMetadata
    }
}

/// An ID that was provided as a parameter to teamFolderGetInfo did not match any of the team's team folders.
@objc
public class DBXTeamTeamFolderGetInfoItemIdNotFound: DBXTeamTeamFolderGetInfoItem {
    @objc
    public var idNotFound: String

    @objc
    public init(_ arg: String) {
        self.idNotFound = arg
        let swift = Team.TeamFolderGetInfoItem.idNotFound(arg)
        super.init(swift: swift)
    }
}

/// Properties of a team folder.
@objc
public class DBXTeamTeamFolderGetInfoItemTeamFolderMetadata: DBXTeamTeamFolderGetInfoItem {
    @objc
    public var teamFolderMetadata: DBXTeamTeamFolderMetadata

    @objc
    public init(_ arg: DBXTeamTeamFolderMetadata) {
        self.teamFolderMetadata = arg
        let swift = Team.TeamFolderGetInfoItem.teamFolderMetadata(arg.swift)
        super.init(swift: swift)
    }
}

/// Objective-C compatible TeamFolderIdListArg struct
@objc
public class DBXTeamTeamFolderIdListArg: NSObject {
    /// The list of team folder IDs.
    @objc
    public var teamFolderIds: [String] { swift.teamFolderIds }

    @objc
    public init(teamFolderIds: [String]) {
        self.swift = Team.TeamFolderIdListArg(teamFolderIds: teamFolderIds)
    }

    let swift: Team.TeamFolderIdListArg

    public init(swift: Team.TeamFolderIdListArg) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible TeamFolderInvalidStatusError union
@objc
public class DBXTeamTeamFolderInvalidStatusError: NSObject {
    let swift: Team.TeamFolderInvalidStatusError

    public init(swift: Team.TeamFolderInvalidStatusError) {
        self.swift = swift
    }

    public static func factory(swift: Team.TeamFolderInvalidStatusError) -> DBXTeamTeamFolderInvalidStatusError {
        switch swift {
        case .active:
            return DBXTeamTeamFolderInvalidStatusErrorActive()
        case .archived:
            return DBXTeamTeamFolderInvalidStatusErrorArchived()
        case .archiveInProgress:
            return DBXTeamTeamFolderInvalidStatusErrorArchiveInProgress()
        case .other:
            return DBXTeamTeamFolderInvalidStatusErrorOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asActive: DBXTeamTeamFolderInvalidStatusErrorActive? {
        self as? DBXTeamTeamFolderInvalidStatusErrorActive
    }

    @objc
    public var asArchived: DBXTeamTeamFolderInvalidStatusErrorArchived? {
        self as? DBXTeamTeamFolderInvalidStatusErrorArchived
    }

    @objc
    public var asArchiveInProgress: DBXTeamTeamFolderInvalidStatusErrorArchiveInProgress? {
        self as? DBXTeamTeamFolderInvalidStatusErrorArchiveInProgress
    }

    @objc
    public var asOther: DBXTeamTeamFolderInvalidStatusErrorOther? {
        self as? DBXTeamTeamFolderInvalidStatusErrorOther
    }
}

/// The folder is active and the operation did not succeed.
@objc
public class DBXTeamTeamFolderInvalidStatusErrorActive: DBXTeamTeamFolderInvalidStatusError {
    @objc
    public init() {
        let swift = Team.TeamFolderInvalidStatusError.active
        super.init(swift: swift)
    }
}

/// The folder is archived and the operation did not succeed.
@objc
public class DBXTeamTeamFolderInvalidStatusErrorArchived: DBXTeamTeamFolderInvalidStatusError {
    @objc
    public init() {
        let swift = Team.TeamFolderInvalidStatusError.archived
        super.init(swift: swift)
    }
}

/// The folder is being archived and the operation did not succeed.
@objc
public class DBXTeamTeamFolderInvalidStatusErrorArchiveInProgress: DBXTeamTeamFolderInvalidStatusError {
    @objc
    public init() {
        let swift = Team.TeamFolderInvalidStatusError.archiveInProgress
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXTeamTeamFolderInvalidStatusErrorOther: DBXTeamTeamFolderInvalidStatusError {
    @objc
    public init() {
        let swift = Team.TeamFolderInvalidStatusError.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible TeamFolderListArg struct
@objc
public class DBXTeamTeamFolderListArg: NSObject {
    /// The maximum number of results to return per request.
    @objc
    public var limit: NSNumber { swift.limit as NSNumber }

    @objc
    public init(limit: NSNumber) {
        self.swift = Team.TeamFolderListArg(limit: limit.uint32Value)
    }

    let swift: Team.TeamFolderListArg

    public init(swift: Team.TeamFolderListArg) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible TeamFolderListContinueArg struct
@objc
public class DBXTeamTeamFolderListContinueArg: NSObject {
    /// Indicates from what point to get the next set of team folders.
    @objc
    public var cursor: String { swift.cursor }

    @objc
    public init(cursor: String) {
        self.swift = Team.TeamFolderListContinueArg(cursor: cursor)
    }

    let swift: Team.TeamFolderListContinueArg

    public init(swift: Team.TeamFolderListContinueArg) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible TeamFolderListContinueError union
@objc
public class DBXTeamTeamFolderListContinueError: NSObject {
    let swift: Team.TeamFolderListContinueError

    public init(swift: Team.TeamFolderListContinueError) {
        self.swift = swift
    }

    public static func factory(swift: Team.TeamFolderListContinueError) -> DBXTeamTeamFolderListContinueError {
        switch swift {
        case .invalidCursor:
            return DBXTeamTeamFolderListContinueErrorInvalidCursor()
        case .other:
            return DBXTeamTeamFolderListContinueErrorOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asInvalidCursor: DBXTeamTeamFolderListContinueErrorInvalidCursor? {
        self as? DBXTeamTeamFolderListContinueErrorInvalidCursor
    }

    @objc
    public var asOther: DBXTeamTeamFolderListContinueErrorOther? {
        self as? DBXTeamTeamFolderListContinueErrorOther
    }
}

/// The cursor is invalid.
@objc
public class DBXTeamTeamFolderListContinueErrorInvalidCursor: DBXTeamTeamFolderListContinueError {
    @objc
    public init() {
        let swift = Team.TeamFolderListContinueError.invalidCursor
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXTeamTeamFolderListContinueErrorOther: DBXTeamTeamFolderListContinueError {
    @objc
    public init() {
        let swift = Team.TeamFolderListContinueError.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible TeamFolderListError struct
@objc
public class DBXTeamTeamFolderListError: NSObject {
    /// (no description)
    @objc
    public var accessError: DBXTeamTeamFolderAccessError { DBXTeamTeamFolderAccessError(swift: swift.accessError) }

    @objc
    public init(accessError: DBXTeamTeamFolderAccessError) {
        self.swift = Team.TeamFolderListError(accessError: accessError.swift)
    }

    let swift: Team.TeamFolderListError

    public init(swift: Team.TeamFolderListError) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Result for teamFolderList and teamFolderListContinue.
@objc
public class DBXTeamTeamFolderListResult: NSObject {
    /// List of all team folders in the authenticated team.
    @objc
    public var teamFolders: [DBXTeamTeamFolderMetadata] { swift.teamFolders.map { DBXTeamTeamFolderMetadata(swift: $0) } }
    /// Pass the cursor into teamFolderListContinue to obtain additional team folders.
    @objc
    public var cursor: String { swift.cursor }
    /// Is true if there are additional team folders that have not been returned yet. An additional call to
    /// teamFolderListContinue can retrieve them.
    @objc
    public var hasMore: NSNumber { swift.hasMore as NSNumber }

    @objc
    public init(teamFolders: [DBXTeamTeamFolderMetadata], cursor: String, hasMore: NSNumber) {
        self.swift = Team.TeamFolderListResult(teamFolders: teamFolders.map(\.swift), cursor: cursor, hasMore: hasMore.boolValue)
    }

    let swift: Team.TeamFolderListResult

    public init(swift: Team.TeamFolderListResult) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Properties of a team folder.
@objc
public class DBXTeamTeamFolderMetadata: NSObject {
    /// The ID of the team folder.
    @objc
    public var teamFolderId: String { swift.teamFolderId }
    /// The name of the team folder.
    @objc
    public var name: String { swift.name }
    /// The status of the team folder.
    @objc
    public var status: DBXTeamTeamFolderStatus { DBXTeamTeamFolderStatus(swift: swift.status) }
    /// True if this team folder is a shared team root.
    @objc
    public var isTeamSharedDropbox: NSNumber { swift.isTeamSharedDropbox as NSNumber }
    /// The sync setting applied to this team folder.
    @objc
    public var syncSetting: DBXFilesSyncSetting { DBXFilesSyncSetting(swift: swift.syncSetting) }
    /// Sync settings applied to contents of this team folder.
    @objc
    public var contentSyncSettings: [DBXFilesContentSyncSetting] { swift.contentSyncSettings.map { DBXFilesContentSyncSetting(swift: $0) } }

    @objc
    public init(
        teamFolderId: String,
        name: String,
        status: DBXTeamTeamFolderStatus,
        isTeamSharedDropbox: NSNumber,
        syncSetting: DBXFilesSyncSetting,
        contentSyncSettings: [DBXFilesContentSyncSetting]
    ) {
        self.swift = Team.TeamFolderMetadata(
            teamFolderId: teamFolderId,
            name: name,
            status: status.swift,
            isTeamSharedDropbox: isTeamSharedDropbox.boolValue,
            syncSetting: syncSetting.swift,
            contentSyncSettings: contentSyncSettings.map(\.swift)
        )
    }

    let swift: Team.TeamFolderMetadata

    public init(swift: Team.TeamFolderMetadata) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible TeamFolderPermanentlyDeleteError union
@objc
public class DBXTeamTeamFolderPermanentlyDeleteError: NSObject {
    let swift: Team.TeamFolderPermanentlyDeleteError

    public init(swift: Team.TeamFolderPermanentlyDeleteError) {
        self.swift = swift
    }

    public static func factory(swift: Team.TeamFolderPermanentlyDeleteError) -> DBXTeamTeamFolderPermanentlyDeleteError {
        switch swift {
        case .accessError(let swiftArg):
            let arg = DBXTeamTeamFolderAccessError(swift: swiftArg)
            return DBXTeamTeamFolderPermanentlyDeleteErrorAccessError(arg)
        case .statusError(let swiftArg):
            let arg = DBXTeamTeamFolderInvalidStatusError(swift: swiftArg)
            return DBXTeamTeamFolderPermanentlyDeleteErrorStatusError(arg)
        case .teamSharedDropboxError(let swiftArg):
            let arg = DBXTeamTeamFolderTeamSharedDropboxError(swift: swiftArg)
            return DBXTeamTeamFolderPermanentlyDeleteErrorTeamSharedDropboxError(arg)
        case .other:
            return DBXTeamTeamFolderPermanentlyDeleteErrorOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asAccessError: DBXTeamTeamFolderPermanentlyDeleteErrorAccessError? {
        self as? DBXTeamTeamFolderPermanentlyDeleteErrorAccessError
    }

    @objc
    public var asStatusError: DBXTeamTeamFolderPermanentlyDeleteErrorStatusError? {
        self as? DBXTeamTeamFolderPermanentlyDeleteErrorStatusError
    }

    @objc
    public var asTeamSharedDropboxError: DBXTeamTeamFolderPermanentlyDeleteErrorTeamSharedDropboxError? {
        self as? DBXTeamTeamFolderPermanentlyDeleteErrorTeamSharedDropboxError
    }

    @objc
    public var asOther: DBXTeamTeamFolderPermanentlyDeleteErrorOther? {
        self as? DBXTeamTeamFolderPermanentlyDeleteErrorOther
    }
}

/// An unspecified error.
@objc
public class DBXTeamTeamFolderPermanentlyDeleteErrorAccessError: DBXTeamTeamFolderPermanentlyDeleteError {
    @objc
    public var accessError: DBXTeamTeamFolderAccessError

    @objc
    public init(_ arg: DBXTeamTeamFolderAccessError) {
        self.accessError = arg
        let swift = Team.TeamFolderPermanentlyDeleteError.accessError(arg.swift)
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXTeamTeamFolderPermanentlyDeleteErrorStatusError: DBXTeamTeamFolderPermanentlyDeleteError {
    @objc
    public var statusError: DBXTeamTeamFolderInvalidStatusError

    @objc
    public init(_ arg: DBXTeamTeamFolderInvalidStatusError) {
        self.statusError = arg
        let swift = Team.TeamFolderPermanentlyDeleteError.statusError(arg.swift)
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXTeamTeamFolderPermanentlyDeleteErrorTeamSharedDropboxError: DBXTeamTeamFolderPermanentlyDeleteError {
    @objc
    public var teamSharedDropboxError: DBXTeamTeamFolderTeamSharedDropboxError

    @objc
    public init(_ arg: DBXTeamTeamFolderTeamSharedDropboxError) {
        self.teamSharedDropboxError = arg
        let swift = Team.TeamFolderPermanentlyDeleteError.teamSharedDropboxError(arg.swift)
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXTeamTeamFolderPermanentlyDeleteErrorOther: DBXTeamTeamFolderPermanentlyDeleteError {
    @objc
    public init() {
        let swift = Team.TeamFolderPermanentlyDeleteError.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible TeamFolderRenameArg struct
@objc
public class DBXTeamTeamFolderRenameArg: DBXTeamTeamFolderIdArg {
    /// New team folder name.
    @objc
    public var name: String { subSwift.name }

    @objc
    public init(teamFolderId: String, name: String) {
        let swift = Team.TeamFolderRenameArg(teamFolderId: teamFolderId, name: name)
        self.subSwift = swift
        super.init(swift: swift)
    }

    let subSwift: Team.TeamFolderRenameArg

    public init(swift: Team.TeamFolderRenameArg) {
        self.subSwift = swift
        super.init(swift: swift)
    }

    @objc
    public override var description: String { subSwift.description }
}

/// Objective-C compatible TeamFolderRenameError union
@objc
public class DBXTeamTeamFolderRenameError: NSObject {
    let swift: Team.TeamFolderRenameError

    public init(swift: Team.TeamFolderRenameError) {
        self.swift = swift
    }

    public static func factory(swift: Team.TeamFolderRenameError) -> DBXTeamTeamFolderRenameError {
        switch swift {
        case .accessError(let swiftArg):
            let arg = DBXTeamTeamFolderAccessError(swift: swiftArg)
            return DBXTeamTeamFolderRenameErrorAccessError(arg)
        case .statusError(let swiftArg):
            let arg = DBXTeamTeamFolderInvalidStatusError(swift: swiftArg)
            return DBXTeamTeamFolderRenameErrorStatusError(arg)
        case .teamSharedDropboxError(let swiftArg):
            let arg = DBXTeamTeamFolderTeamSharedDropboxError(swift: swiftArg)
            return DBXTeamTeamFolderRenameErrorTeamSharedDropboxError(arg)
        case .other:
            return DBXTeamTeamFolderRenameErrorOther()
        case .invalidFolderName:
            return DBXTeamTeamFolderRenameErrorInvalidFolderName()
        case .folderNameAlreadyUsed:
            return DBXTeamTeamFolderRenameErrorFolderNameAlreadyUsed()
        case .folderNameReserved:
            return DBXTeamTeamFolderRenameErrorFolderNameReserved()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asAccessError: DBXTeamTeamFolderRenameErrorAccessError? {
        self as? DBXTeamTeamFolderRenameErrorAccessError
    }

    @objc
    public var asStatusError: DBXTeamTeamFolderRenameErrorStatusError? {
        self as? DBXTeamTeamFolderRenameErrorStatusError
    }

    @objc
    public var asTeamSharedDropboxError: DBXTeamTeamFolderRenameErrorTeamSharedDropboxError? {
        self as? DBXTeamTeamFolderRenameErrorTeamSharedDropboxError
    }

    @objc
    public var asOther: DBXTeamTeamFolderRenameErrorOther? {
        self as? DBXTeamTeamFolderRenameErrorOther
    }

    @objc
    public var asInvalidFolderName: DBXTeamTeamFolderRenameErrorInvalidFolderName? {
        self as? DBXTeamTeamFolderRenameErrorInvalidFolderName
    }

    @objc
    public var asFolderNameAlreadyUsed: DBXTeamTeamFolderRenameErrorFolderNameAlreadyUsed? {
        self as? DBXTeamTeamFolderRenameErrorFolderNameAlreadyUsed
    }

    @objc
    public var asFolderNameReserved: DBXTeamTeamFolderRenameErrorFolderNameReserved? {
        self as? DBXTeamTeamFolderRenameErrorFolderNameReserved
    }
}

/// An unspecified error.
@objc
public class DBXTeamTeamFolderRenameErrorAccessError: DBXTeamTeamFolderRenameError {
    @objc
    public var accessError: DBXTeamTeamFolderAccessError

    @objc
    public init(_ arg: DBXTeamTeamFolderAccessError) {
        self.accessError = arg
        let swift = Team.TeamFolderRenameError.accessError(arg.swift)
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXTeamTeamFolderRenameErrorStatusError: DBXTeamTeamFolderRenameError {
    @objc
    public var statusError: DBXTeamTeamFolderInvalidStatusError

    @objc
    public init(_ arg: DBXTeamTeamFolderInvalidStatusError) {
        self.statusError = arg
        let swift = Team.TeamFolderRenameError.statusError(arg.swift)
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXTeamTeamFolderRenameErrorTeamSharedDropboxError: DBXTeamTeamFolderRenameError {
    @objc
    public var teamSharedDropboxError: DBXTeamTeamFolderTeamSharedDropboxError

    @objc
    public init(_ arg: DBXTeamTeamFolderTeamSharedDropboxError) {
        self.teamSharedDropboxError = arg
        let swift = Team.TeamFolderRenameError.teamSharedDropboxError(arg.swift)
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXTeamTeamFolderRenameErrorOther: DBXTeamTeamFolderRenameError {
    @objc
    public init() {
        let swift = Team.TeamFolderRenameError.other
        super.init(swift: swift)
    }
}

/// The provided folder name cannot be used.
@objc
public class DBXTeamTeamFolderRenameErrorInvalidFolderName: DBXTeamTeamFolderRenameError {
    @objc
    public init() {
        let swift = Team.TeamFolderRenameError.invalidFolderName
        super.init(swift: swift)
    }
}

/// There is already a team folder with the same name.
@objc
public class DBXTeamTeamFolderRenameErrorFolderNameAlreadyUsed: DBXTeamTeamFolderRenameError {
    @objc
    public init() {
        let swift = Team.TeamFolderRenameError.folderNameAlreadyUsed
        super.init(swift: swift)
    }
}

/// The provided name cannot be used because it is reserved.
@objc
public class DBXTeamTeamFolderRenameErrorFolderNameReserved: DBXTeamTeamFolderRenameError {
    @objc
    public init() {
        let swift = Team.TeamFolderRenameError.folderNameReserved
        super.init(swift: swift)
    }
}

/// Objective-C compatible TeamFolderStatus union
@objc
public class DBXTeamTeamFolderStatus: NSObject {
    let swift: Team.TeamFolderStatus

    public init(swift: Team.TeamFolderStatus) {
        self.swift = swift
    }

    public static func factory(swift: Team.TeamFolderStatus) -> DBXTeamTeamFolderStatus {
        switch swift {
        case .active:
            return DBXTeamTeamFolderStatusActive()
        case .archived:
            return DBXTeamTeamFolderStatusArchived()
        case .archiveInProgress:
            return DBXTeamTeamFolderStatusArchiveInProgress()
        case .other:
            return DBXTeamTeamFolderStatusOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asActive: DBXTeamTeamFolderStatusActive? {
        self as? DBXTeamTeamFolderStatusActive
    }

    @objc
    public var asArchived: DBXTeamTeamFolderStatusArchived? {
        self as? DBXTeamTeamFolderStatusArchived
    }

    @objc
    public var asArchiveInProgress: DBXTeamTeamFolderStatusArchiveInProgress? {
        self as? DBXTeamTeamFolderStatusArchiveInProgress
    }

    @objc
    public var asOther: DBXTeamTeamFolderStatusOther? {
        self as? DBXTeamTeamFolderStatusOther
    }
}

/// The team folder and sub-folders are available to all members.
@objc
public class DBXTeamTeamFolderStatusActive: DBXTeamTeamFolderStatus {
    @objc
    public init() {
        let swift = Team.TeamFolderStatus.active
        super.init(swift: swift)
    }
}

/// The team folder is not accessible outside of the team folder manager.
@objc
public class DBXTeamTeamFolderStatusArchived: DBXTeamTeamFolderStatus {
    @objc
    public init() {
        let swift = Team.TeamFolderStatus.archived
        super.init(swift: swift)
    }
}

/// The team folder is not accessible outside of the team folder manager.
@objc
public class DBXTeamTeamFolderStatusArchiveInProgress: DBXTeamTeamFolderStatus {
    @objc
    public init() {
        let swift = Team.TeamFolderStatus.archiveInProgress
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXTeamTeamFolderStatusOther: DBXTeamTeamFolderStatus {
    @objc
    public init() {
        let swift = Team.TeamFolderStatus.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible TeamFolderTeamSharedDropboxError union
@objc
public class DBXTeamTeamFolderTeamSharedDropboxError: NSObject {
    let swift: Team.TeamFolderTeamSharedDropboxError

    public init(swift: Team.TeamFolderTeamSharedDropboxError) {
        self.swift = swift
    }

    public static func factory(swift: Team.TeamFolderTeamSharedDropboxError) -> DBXTeamTeamFolderTeamSharedDropboxError {
        switch swift {
        case .disallowed:
            return DBXTeamTeamFolderTeamSharedDropboxErrorDisallowed()
        case .other:
            return DBXTeamTeamFolderTeamSharedDropboxErrorOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asDisallowed: DBXTeamTeamFolderTeamSharedDropboxErrorDisallowed? {
        self as? DBXTeamTeamFolderTeamSharedDropboxErrorDisallowed
    }

    @objc
    public var asOther: DBXTeamTeamFolderTeamSharedDropboxErrorOther? {
        self as? DBXTeamTeamFolderTeamSharedDropboxErrorOther
    }
}

/// This action is not allowed for a shared team root.
@objc
public class DBXTeamTeamFolderTeamSharedDropboxErrorDisallowed: DBXTeamTeamFolderTeamSharedDropboxError {
    @objc
    public init() {
        let swift = Team.TeamFolderTeamSharedDropboxError.disallowed
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXTeamTeamFolderTeamSharedDropboxErrorOther: DBXTeamTeamFolderTeamSharedDropboxError {
    @objc
    public init() {
        let swift = Team.TeamFolderTeamSharedDropboxError.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible TeamFolderUpdateSyncSettingsArg struct
@objc
public class DBXTeamTeamFolderUpdateSyncSettingsArg: DBXTeamTeamFolderIdArg {
    /// Sync setting to apply to the team folder itself. Only meaningful if the team folder is not a shared team
    /// root.
    @objc
    public var syncSetting: DBXFilesSyncSettingArg? { guard let swift = subSwift.syncSetting else { return nil }
        return DBXFilesSyncSettingArg(swift: swift)
    }

    /// Sync settings to apply to contents of this team folder.
    @objc
    public var contentSyncSettings: [DBXFilesContentSyncSettingArg]? { subSwift.contentSyncSettings?.map { DBXFilesContentSyncSettingArg(swift: $0) } }

    @objc
    public init(teamFolderId: String, syncSetting: DBXFilesSyncSettingArg?, contentSyncSettings: [DBXFilesContentSyncSettingArg]?) {
        let swift = Team.TeamFolderUpdateSyncSettingsArg(
            teamFolderId: teamFolderId,
            syncSetting: syncSetting?.swift,
            contentSyncSettings: contentSyncSettings?.map(\.swift)
        )
        self.subSwift = swift
        super.init(swift: swift)
    }

    let subSwift: Team.TeamFolderUpdateSyncSettingsArg

    public init(swift: Team.TeamFolderUpdateSyncSettingsArg) {
        self.subSwift = swift
        super.init(swift: swift)
    }

    @objc
    public override var description: String { subSwift.description }
}

/// Objective-C compatible TeamFolderUpdateSyncSettingsError union
@objc
public class DBXTeamTeamFolderUpdateSyncSettingsError: NSObject {
    let swift: Team.TeamFolderUpdateSyncSettingsError

    public init(swift: Team.TeamFolderUpdateSyncSettingsError) {
        self.swift = swift
    }

    public static func factory(swift: Team.TeamFolderUpdateSyncSettingsError) -> DBXTeamTeamFolderUpdateSyncSettingsError {
        switch swift {
        case .accessError(let swiftArg):
            let arg = DBXTeamTeamFolderAccessError(swift: swiftArg)
            return DBXTeamTeamFolderUpdateSyncSettingsErrorAccessError(arg)
        case .statusError(let swiftArg):
            let arg = DBXTeamTeamFolderInvalidStatusError(swift: swiftArg)
            return DBXTeamTeamFolderUpdateSyncSettingsErrorStatusError(arg)
        case .teamSharedDropboxError(let swiftArg):
            let arg = DBXTeamTeamFolderTeamSharedDropboxError(swift: swiftArg)
            return DBXTeamTeamFolderUpdateSyncSettingsErrorTeamSharedDropboxError(arg)
        case .other:
            return DBXTeamTeamFolderUpdateSyncSettingsErrorOther()
        case .syncSettingsError(let swiftArg):
            let arg = DBXFilesSyncSettingsError(swift: swiftArg)
            return DBXTeamTeamFolderUpdateSyncSettingsErrorSyncSettingsError(arg)
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asAccessError: DBXTeamTeamFolderUpdateSyncSettingsErrorAccessError? {
        self as? DBXTeamTeamFolderUpdateSyncSettingsErrorAccessError
    }

    @objc
    public var asStatusError: DBXTeamTeamFolderUpdateSyncSettingsErrorStatusError? {
        self as? DBXTeamTeamFolderUpdateSyncSettingsErrorStatusError
    }

    @objc
    public var asTeamSharedDropboxError: DBXTeamTeamFolderUpdateSyncSettingsErrorTeamSharedDropboxError? {
        self as? DBXTeamTeamFolderUpdateSyncSettingsErrorTeamSharedDropboxError
    }

    @objc
    public var asOther: DBXTeamTeamFolderUpdateSyncSettingsErrorOther? {
        self as? DBXTeamTeamFolderUpdateSyncSettingsErrorOther
    }

    @objc
    public var asSyncSettingsError: DBXTeamTeamFolderUpdateSyncSettingsErrorSyncSettingsError? {
        self as? DBXTeamTeamFolderUpdateSyncSettingsErrorSyncSettingsError
    }
}

/// An unspecified error.
@objc
public class DBXTeamTeamFolderUpdateSyncSettingsErrorAccessError: DBXTeamTeamFolderUpdateSyncSettingsError {
    @objc
    public var accessError: DBXTeamTeamFolderAccessError

    @objc
    public init(_ arg: DBXTeamTeamFolderAccessError) {
        self.accessError = arg
        let swift = Team.TeamFolderUpdateSyncSettingsError.accessError(arg.swift)
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXTeamTeamFolderUpdateSyncSettingsErrorStatusError: DBXTeamTeamFolderUpdateSyncSettingsError {
    @objc
    public var statusError: DBXTeamTeamFolderInvalidStatusError

    @objc
    public init(_ arg: DBXTeamTeamFolderInvalidStatusError) {
        self.statusError = arg
        let swift = Team.TeamFolderUpdateSyncSettingsError.statusError(arg.swift)
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXTeamTeamFolderUpdateSyncSettingsErrorTeamSharedDropboxError: DBXTeamTeamFolderUpdateSyncSettingsError {
    @objc
    public var teamSharedDropboxError: DBXTeamTeamFolderTeamSharedDropboxError

    @objc
    public init(_ arg: DBXTeamTeamFolderTeamSharedDropboxError) {
        self.teamSharedDropboxError = arg
        let swift = Team.TeamFolderUpdateSyncSettingsError.teamSharedDropboxError(arg.swift)
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXTeamTeamFolderUpdateSyncSettingsErrorOther: DBXTeamTeamFolderUpdateSyncSettingsError {
    @objc
    public init() {
        let swift = Team.TeamFolderUpdateSyncSettingsError.other
        super.init(swift: swift)
    }
}

/// An error occurred setting the sync settings.
@objc
public class DBXTeamTeamFolderUpdateSyncSettingsErrorSyncSettingsError: DBXTeamTeamFolderUpdateSyncSettingsError {
    @objc
    public var syncSettingsError: DBXFilesSyncSettingsError

    @objc
    public init(_ arg: DBXFilesSyncSettingsError) {
        self.syncSettingsError = arg
        let swift = Team.TeamFolderUpdateSyncSettingsError.syncSettingsError(arg.swift)
        super.init(swift: swift)
    }
}

/// Objective-C compatible TeamGetInfoResult struct
@objc
public class DBXTeamTeamGetInfoResult: NSObject {
    /// The name of the team.
    @objc
    public var name: String { swift.name }
    /// The ID of the team.
    @objc
    public var teamId: String { swift.teamId }
    /// The number of licenses available to the team.
    @objc
    public var numLicensedUsers: NSNumber { swift.numLicensedUsers as NSNumber }
    /// The number of accounts that have been invited or are already active members of the team.
    @objc
    public var numProvisionedUsers: NSNumber { swift.numProvisionedUsers as NSNumber }
    /// The number of licenses used on the team.
    @objc
    public var numUsedLicenses: NSNumber { swift.numUsedLicenses as NSNumber }
    /// (no description)
    @objc
    public var policies: DBXTeamPoliciesTeamMemberPolicies { DBXTeamPoliciesTeamMemberPolicies(swift: swift.policies) }

    @objc
    public init(
        name: String,
        teamId: String,
        numLicensedUsers: NSNumber,
        numProvisionedUsers: NSNumber,
        policies: DBXTeamPoliciesTeamMemberPolicies,
        numUsedLicenses: NSNumber
    ) {
        self.swift = Team.TeamGetInfoResult(
            name: name,
            teamId: teamId,
            numLicensedUsers: numLicensedUsers.uint32Value,
            numProvisionedUsers: numProvisionedUsers.uint32Value,
            policies: policies.swift,
            numUsedLicenses: numUsedLicenses.uint32Value
        )
    }

    let swift: Team.TeamGetInfoResult

    public init(swift: Team.TeamGetInfoResult) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Information about a team member.
@objc
public class DBXTeamTeamMemberInfo: NSObject {
    /// Profile of a user as a member of a team.
    @objc
    public var profile: DBXTeamTeamMemberProfile { DBXTeamTeamMemberProfile(swift: swift.profile) }
    /// The user's role in the team.
    @objc
    public var role: DBXTeamAdminTier { DBXTeamAdminTier(swift: swift.role) }

    @objc
    public init(profile: DBXTeamTeamMemberProfile, role: DBXTeamAdminTier) {
        self.swift = Team.TeamMemberInfo(profile: profile.subSwift, role: role.swift)
    }

    let swift: Team.TeamMemberInfo

    public init(swift: Team.TeamMemberInfo) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Information about a team member.
@objc
public class DBXTeamTeamMemberInfoV2: NSObject {
    /// Profile of a user as a member of a team.
    @objc
    public var profile: DBXTeamTeamMemberProfile { DBXTeamTeamMemberProfile(swift: swift.profile) }
    /// The user's roles in the team.
    @objc
    public var roles: [DBXTeamTeamMemberRole]? { swift.roles?.map { DBXTeamTeamMemberRole(swift: $0) } }

    @objc
    public init(profile: DBXTeamTeamMemberProfile, roles: [DBXTeamTeamMemberRole]?) {
        self.swift = Team.TeamMemberInfoV2(profile: profile.subSwift, roles: roles?.map(\.swift))
    }

    let swift: Team.TeamMemberInfoV2

    public init(swift: Team.TeamMemberInfoV2) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Information about a team member, after the change, like at membersSetProfileV2.
@objc
public class DBXTeamTeamMemberInfoV2Result: NSObject {
    /// Member info, after the change.
    @objc
    public var memberInfo: DBXTeamTeamMemberInfoV2 { DBXTeamTeamMemberInfoV2(swift: swift.memberInfo) }

    @objc
    public init(memberInfo: DBXTeamTeamMemberInfoV2) {
        self.swift = Team.TeamMemberInfoV2Result(memberInfo: memberInfo.swift)
    }

    let swift: Team.TeamMemberInfoV2Result

    public init(swift: Team.TeamMemberInfoV2Result) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Profile of a user as a member of a team.
@objc
public class DBXTeamTeamMemberProfile: DBXTeamMemberProfile {
    /// List of group IDs of groups that the user belongs to.
    @objc
    public var groups: [String] { subSwift.groups }
    /// The namespace id of the user's root folder.
    @objc
    public var memberFolderId: String { subSwift.memberFolderId }

    @objc
    public init(
        teamMemberId: String,
        email: String,
        emailVerified: NSNumber,
        status: DBXTeamTeamMemberStatus,
        name: DBXUsersName,
        membershipType: DBXTeamTeamMembershipType,
        groups: [String],
        memberFolderId: String,
        externalId: String?,
        accountId: String?,
        secondaryEmails: [DBXSecondaryEmailsSecondaryEmail]?,
        invitedOn: Date?,
        joinedOn: Date?,
        suspendedOn: Date?,
        persistentId: String?,
        isDirectoryRestricted: NSNumber?,
        profilePhotoUrl: String?
    ) {
        let swift = Team.TeamMemberProfile(
            teamMemberId: teamMemberId,
            email: email,
            emailVerified: emailVerified.boolValue,
            status: status.swift,
            name: name.swift,
            membershipType: membershipType.swift,
            groups: groups,
            memberFolderId: memberFolderId,
            externalId: externalId,
            accountId: accountId,
            secondaryEmails: secondaryEmails?.map(\.swift),
            invitedOn: invitedOn,
            joinedOn: joinedOn,
            suspendedOn: suspendedOn,
            persistentId: persistentId,
            isDirectoryRestricted: isDirectoryRestricted?.boolValue,
            profilePhotoUrl: profilePhotoUrl
        )
        self.subSwift = swift
        super.init(swift: swift)
    }

    let subSwift: Team.TeamMemberProfile

    public init(swift: Team.TeamMemberProfile) {
        self.subSwift = swift
        super.init(swift: swift)
    }

    @objc
    public override var description: String { subSwift.description }
}

/// A role which can be attached to a team member. This replaces AdminTier; each AdminTier corresponds to a new
/// TeamMemberRole with a matching name.
@objc
public class DBXTeamTeamMemberRole: NSObject {
    /// A string containing encoded role ID. For roles defined by Dropbox, this is the same across all teams.
    @objc
    public var roleId: String { swift.roleId }
    /// The role display name.
    @objc
    public var name: String { swift.name }
    /// Role description. Describes which permissions come with this role.
    @objc
    public var description_: String { swift.description_ }

    @objc
    public init(roleId: String, name: String, description_: String) {
        self.swift = Team.TeamMemberRole(roleId: roleId, name: name, description_: description_)
    }

    let swift: Team.TeamMemberRole

    public init(swift: Team.TeamMemberRole) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// The user's status as a member of a specific team.
@objc
public class DBXTeamTeamMemberStatus: NSObject {
    let swift: Team.TeamMemberStatus

    public init(swift: Team.TeamMemberStatus) {
        self.swift = swift
    }

    public static func factory(swift: Team.TeamMemberStatus) -> DBXTeamTeamMemberStatus {
        switch swift {
        case .active:
            return DBXTeamTeamMemberStatusActive()
        case .invited:
            return DBXTeamTeamMemberStatusInvited()
        case .suspended:
            return DBXTeamTeamMemberStatusSuspended()
        case .removed(let swiftArg):
            let arg = DBXTeamRemovedStatus(swift: swiftArg)
            return DBXTeamTeamMemberStatusRemoved(arg)
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asActive: DBXTeamTeamMemberStatusActive? {
        self as? DBXTeamTeamMemberStatusActive
    }

    @objc
    public var asInvited: DBXTeamTeamMemberStatusInvited? {
        self as? DBXTeamTeamMemberStatusInvited
    }

    @objc
    public var asSuspended: DBXTeamTeamMemberStatusSuspended? {
        self as? DBXTeamTeamMemberStatusSuspended
    }

    @objc
    public var asRemoved: DBXTeamTeamMemberStatusRemoved? {
        self as? DBXTeamTeamMemberStatusRemoved
    }
}

/// User has successfully joined the team.
@objc
public class DBXTeamTeamMemberStatusActive: DBXTeamTeamMemberStatus {
    @objc
    public init() {
        let swift = Team.TeamMemberStatus.active
        super.init(swift: swift)
    }
}

/// User has been invited to a team, but has not joined the team yet.
@objc
public class DBXTeamTeamMemberStatusInvited: DBXTeamTeamMemberStatus {
    @objc
    public init() {
        let swift = Team.TeamMemberStatus.invited
        super.init(swift: swift)
    }
}

/// User is no longer a member of the team, but the account can be un-suspended, re-establishing the user as a
/// team member.
@objc
public class DBXTeamTeamMemberStatusSuspended: DBXTeamTeamMemberStatus {
    @objc
    public init() {
        let swift = Team.TeamMemberStatus.suspended
        super.init(swift: swift)
    }
}

/// User is no longer a member of the team. Removed users are only listed when include_removed is true in
/// members/list.
@objc
public class DBXTeamTeamMemberStatusRemoved: DBXTeamTeamMemberStatus {
    @objc
    public var removed: DBXTeamRemovedStatus

    @objc
    public init(_ arg: DBXTeamRemovedStatus) {
        self.removed = arg
        let swift = Team.TeamMemberStatus.removed(arg.swift)
        super.init(swift: swift)
    }
}

/// Objective-C compatible TeamMembershipType union
@objc
public class DBXTeamTeamMembershipType: NSObject {
    let swift: Team.TeamMembershipType

    public init(swift: Team.TeamMembershipType) {
        self.swift = swift
    }

    public static func factory(swift: Team.TeamMembershipType) -> DBXTeamTeamMembershipType {
        switch swift {
        case .full:
            return DBXTeamTeamMembershipTypeFull()
        case .limited:
            return DBXTeamTeamMembershipTypeLimited()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asFull: DBXTeamTeamMembershipTypeFull? {
        self as? DBXTeamTeamMembershipTypeFull
    }

    @objc
    public var asLimited: DBXTeamTeamMembershipTypeLimited? {
        self as? DBXTeamTeamMembershipTypeLimited
    }
}

/// User uses a license and has full access to team resources like the shared quota.
@objc
public class DBXTeamTeamMembershipTypeFull: DBXTeamTeamMembershipType {
    @objc
    public init() {
        let swift = Team.TeamMembershipType.full
        super.init(swift: swift)
    }
}

/// User does not have access to the shared quota and team admins have restricted administrative control.
@objc
public class DBXTeamTeamMembershipTypeLimited: DBXTeamTeamMembershipType {
    @objc
    public init() {
        let swift = Team.TeamMembershipType.limited
        super.init(swift: swift)
    }
}

/// Objective-C compatible TeamNamespacesListArg struct
@objc
public class DBXTeamTeamNamespacesListArg: NSObject {
    /// Specifying a value here has no effect.
    @objc
    public var limit: NSNumber { swift.limit as NSNumber }

    @objc
    public init(limit: NSNumber) {
        self.swift = Team.TeamNamespacesListArg(limit: limit.uint32Value)
    }

    let swift: Team.TeamNamespacesListArg

    public init(swift: Team.TeamNamespacesListArg) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible TeamNamespacesListContinueArg struct
@objc
public class DBXTeamTeamNamespacesListContinueArg: NSObject {
    /// Indicates from what point to get the next set of team-accessible namespaces.
    @objc
    public var cursor: String { swift.cursor }

    @objc
    public init(cursor: String) {
        self.swift = Team.TeamNamespacesListContinueArg(cursor: cursor)
    }

    let swift: Team.TeamNamespacesListContinueArg

    public init(swift: Team.TeamNamespacesListContinueArg) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible TeamNamespacesListError union
@objc
public class DBXTeamTeamNamespacesListError: NSObject {
    let swift: Team.TeamNamespacesListError

    public init(swift: Team.TeamNamespacesListError) {
        self.swift = swift
    }

    public static func factory(swift: Team.TeamNamespacesListError) -> DBXTeamTeamNamespacesListError {
        switch swift {
        case .invalidArg:
            return DBXTeamTeamNamespacesListErrorInvalidArg()
        case .other:
            return DBXTeamTeamNamespacesListErrorOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asInvalidArg: DBXTeamTeamNamespacesListErrorInvalidArg? {
        self as? DBXTeamTeamNamespacesListErrorInvalidArg
    }

    @objc
    public var asOther: DBXTeamTeamNamespacesListErrorOther? {
        self as? DBXTeamTeamNamespacesListErrorOther
    }
}

/// Argument passed in is invalid.
@objc
public class DBXTeamTeamNamespacesListErrorInvalidArg: DBXTeamTeamNamespacesListError {
    @objc
    public init() {
        let swift = Team.TeamNamespacesListError.invalidArg
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXTeamTeamNamespacesListErrorOther: DBXTeamTeamNamespacesListError {
    @objc
    public init() {
        let swift = Team.TeamNamespacesListError.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible TeamNamespacesListContinueError union
@objc
public class DBXTeamTeamNamespacesListContinueError: NSObject {
    let swift: Team.TeamNamespacesListContinueError

    public init(swift: Team.TeamNamespacesListContinueError) {
        self.swift = swift
    }

    public static func factory(swift: Team.TeamNamespacesListContinueError) -> DBXTeamTeamNamespacesListContinueError {
        switch swift {
        case .invalidArg:
            return DBXTeamTeamNamespacesListContinueErrorInvalidArg()
        case .other:
            return DBXTeamTeamNamespacesListContinueErrorOther()
        case .invalidCursor:
            return DBXTeamTeamNamespacesListContinueErrorInvalidCursor()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asInvalidArg: DBXTeamTeamNamespacesListContinueErrorInvalidArg? {
        self as? DBXTeamTeamNamespacesListContinueErrorInvalidArg
    }

    @objc
    public var asOther: DBXTeamTeamNamespacesListContinueErrorOther? {
        self as? DBXTeamTeamNamespacesListContinueErrorOther
    }

    @objc
    public var asInvalidCursor: DBXTeamTeamNamespacesListContinueErrorInvalidCursor? {
        self as? DBXTeamTeamNamespacesListContinueErrorInvalidCursor
    }
}

/// Argument passed in is invalid.
@objc
public class DBXTeamTeamNamespacesListContinueErrorInvalidArg: DBXTeamTeamNamespacesListContinueError {
    @objc
    public init() {
        let swift = Team.TeamNamespacesListContinueError.invalidArg
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXTeamTeamNamespacesListContinueErrorOther: DBXTeamTeamNamespacesListContinueError {
    @objc
    public init() {
        let swift = Team.TeamNamespacesListContinueError.other
        super.init(swift: swift)
    }
}

/// The cursor is invalid.
@objc
public class DBXTeamTeamNamespacesListContinueErrorInvalidCursor: DBXTeamTeamNamespacesListContinueError {
    @objc
    public init() {
        let swift = Team.TeamNamespacesListContinueError.invalidCursor
        super.init(swift: swift)
    }
}

/// Result for namespacesList.
@objc
public class DBXTeamTeamNamespacesListResult: NSObject {
    /// List of all namespaces the team can access.
    @objc
    public var namespaces: [DBXTeamNamespaceMetadata] { swift.namespaces.map { DBXTeamNamespaceMetadata(swift: $0) } }
    /// Pass the cursor into namespacesListContinue to obtain additional namespaces. Note that duplicate namespaces
    /// may be returned.
    @objc
    public var cursor: String { swift.cursor }
    /// Is true if there are additional namespaces that have not been returned yet.
    @objc
    public var hasMore: NSNumber { swift.hasMore as NSNumber }

    @objc
    public init(namespaces: [DBXTeamNamespaceMetadata], cursor: String, hasMore: NSNumber) {
        self.swift = Team.TeamNamespacesListResult(namespaces: namespaces.map(\.swift), cursor: cursor, hasMore: hasMore.boolValue)
    }

    let swift: Team.TeamNamespacesListResult

    public init(swift: Team.TeamNamespacesListResult) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible TeamReportFailureReason union
@objc
public class DBXTeamTeamReportFailureReason: NSObject {
    let swift: Team.TeamReportFailureReason

    public init(swift: Team.TeamReportFailureReason) {
        self.swift = swift
    }

    public static func factory(swift: Team.TeamReportFailureReason) -> DBXTeamTeamReportFailureReason {
        switch swift {
        case .temporaryError:
            return DBXTeamTeamReportFailureReasonTemporaryError()
        case .manyReportsAtOnce:
            return DBXTeamTeamReportFailureReasonManyReportsAtOnce()
        case .tooMuchData:
            return DBXTeamTeamReportFailureReasonTooMuchData()
        case .other:
            return DBXTeamTeamReportFailureReasonOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asTemporaryError: DBXTeamTeamReportFailureReasonTemporaryError? {
        self as? DBXTeamTeamReportFailureReasonTemporaryError
    }

    @objc
    public var asManyReportsAtOnce: DBXTeamTeamReportFailureReasonManyReportsAtOnce? {
        self as? DBXTeamTeamReportFailureReasonManyReportsAtOnce
    }

    @objc
    public var asTooMuchData: DBXTeamTeamReportFailureReasonTooMuchData? {
        self as? DBXTeamTeamReportFailureReasonTooMuchData
    }

    @objc
    public var asOther: DBXTeamTeamReportFailureReasonOther? {
        self as? DBXTeamTeamReportFailureReasonOther
    }
}

/// We couldn't create the report, but we think this was a fluke. Everything should work if you try it again.
@objc
public class DBXTeamTeamReportFailureReasonTemporaryError: DBXTeamTeamReportFailureReason {
    @objc
    public init() {
        let swift = Team.TeamReportFailureReason.temporaryError
        super.init(swift: swift)
    }
}

/// Too many other reports are being created right now. Try creating this report again once the others finish.
@objc
public class DBXTeamTeamReportFailureReasonManyReportsAtOnce: DBXTeamTeamReportFailureReason {
    @objc
    public init() {
        let swift = Team.TeamReportFailureReason.manyReportsAtOnce
        super.init(swift: swift)
    }
}

/// We couldn't create the report. Try creating the report again with less data.
@objc
public class DBXTeamTeamReportFailureReasonTooMuchData: DBXTeamTeamReportFailureReason {
    @objc
    public init() {
        let swift = Team.TeamReportFailureReason.tooMuchData
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXTeamTeamReportFailureReasonOther: DBXTeamTeamReportFailureReason {
    @objc
    public init() {
        let swift = Team.TeamReportFailureReason.other
        super.init(swift: swift)
    }
}

/// Error returned by tokenGetAuthenticatedAdmin.
@objc
public class DBXTeamTokenGetAuthenticatedAdminError: NSObject {
    let swift: Team.TokenGetAuthenticatedAdminError

    public init(swift: Team.TokenGetAuthenticatedAdminError) {
        self.swift = swift
    }

    public static func factory(swift: Team.TokenGetAuthenticatedAdminError) -> DBXTeamTokenGetAuthenticatedAdminError {
        switch swift {
        case .mappingNotFound:
            return DBXTeamTokenGetAuthenticatedAdminErrorMappingNotFound()
        case .adminNotActive:
            return DBXTeamTokenGetAuthenticatedAdminErrorAdminNotActive()
        case .other:
            return DBXTeamTokenGetAuthenticatedAdminErrorOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asMappingNotFound: DBXTeamTokenGetAuthenticatedAdminErrorMappingNotFound? {
        self as? DBXTeamTokenGetAuthenticatedAdminErrorMappingNotFound
    }

    @objc
    public var asAdminNotActive: DBXTeamTokenGetAuthenticatedAdminErrorAdminNotActive? {
        self as? DBXTeamTokenGetAuthenticatedAdminErrorAdminNotActive
    }

    @objc
    public var asOther: DBXTeamTokenGetAuthenticatedAdminErrorOther? {
        self as? DBXTeamTokenGetAuthenticatedAdminErrorOther
    }
}

/// The current token is not associated with a team admin, because mappings were not recorded when the token was
/// created. Consider re-authorizing a new access token to record its authenticating admin.
@objc
public class DBXTeamTokenGetAuthenticatedAdminErrorMappingNotFound: DBXTeamTokenGetAuthenticatedAdminError {
    @objc
    public init() {
        let swift = Team.TokenGetAuthenticatedAdminError.mappingNotFound
        super.init(swift: swift)
    }
}

/// Either the team admin that authorized this token is no longer an active member of the team or no longer a
/// team admin.
@objc
public class DBXTeamTokenGetAuthenticatedAdminErrorAdminNotActive: DBXTeamTokenGetAuthenticatedAdminError {
    @objc
    public init() {
        let swift = Team.TokenGetAuthenticatedAdminError.adminNotActive
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXTeamTokenGetAuthenticatedAdminErrorOther: DBXTeamTokenGetAuthenticatedAdminError {
    @objc
    public init() {
        let swift = Team.TokenGetAuthenticatedAdminError.other
        super.init(swift: swift)
    }
}

/// Results for tokenGetAuthenticatedAdmin.
@objc
public class DBXTeamTokenGetAuthenticatedAdminResult: NSObject {
    /// The admin who authorized the token.
    @objc
    public var adminProfile: DBXTeamTeamMemberProfile { DBXTeamTeamMemberProfile(swift: swift.adminProfile) }

    @objc
    public init(adminProfile: DBXTeamTeamMemberProfile) {
        self.swift = Team.TokenGetAuthenticatedAdminResult(adminProfile: adminProfile.subSwift)
    }

    let swift: Team.TokenGetAuthenticatedAdminResult

    public init(swift: Team.TokenGetAuthenticatedAdminResult) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// The value for uploadApiRateLimit in Feature.
@objc
public class DBXTeamUploadApiRateLimitValue: NSObject {
    let swift: Team.UploadApiRateLimitValue

    public init(swift: Team.UploadApiRateLimitValue) {
        self.swift = swift
    }

    public static func factory(swift: Team.UploadApiRateLimitValue) -> DBXTeamUploadApiRateLimitValue {
        switch swift {
        case .unlimited:
            return DBXTeamUploadApiRateLimitValueUnlimited()
        case .limit(let swiftArg):
            let arg = NSNumber(value: swiftArg)
            return DBXTeamUploadApiRateLimitValueLimit(arg)
        case .other:
            return DBXTeamUploadApiRateLimitValueOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asUnlimited: DBXTeamUploadApiRateLimitValueUnlimited? {
        self as? DBXTeamUploadApiRateLimitValueUnlimited
    }

    @objc
    public var asLimit: DBXTeamUploadApiRateLimitValueLimit? {
        self as? DBXTeamUploadApiRateLimitValueLimit
    }

    @objc
    public var asOther: DBXTeamUploadApiRateLimitValueOther? {
        self as? DBXTeamUploadApiRateLimitValueOther
    }
}

/// This team has unlimited upload API quota. So far both server version account and legacy  account type have
/// unlimited monthly upload api quota.
@objc
public class DBXTeamUploadApiRateLimitValueUnlimited: DBXTeamUploadApiRateLimitValue {
    @objc
    public init() {
        let swift = Team.UploadApiRateLimitValue.unlimited
        super.init(swift: swift)
    }
}

/// The number of upload API calls allowed per month.
@objc
public class DBXTeamUploadApiRateLimitValueLimit: DBXTeamUploadApiRateLimitValue {
    @objc
    public var limit: NSNumber

    @objc
    public init(_ arg: NSNumber) {
        self.limit = arg
        let swift = Team.UploadApiRateLimitValue.limit(arg.uint32Value)
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXTeamUploadApiRateLimitValueOther: DBXTeamUploadApiRateLimitValue {
    @objc
    public init() {
        let swift = Team.UploadApiRateLimitValue.other
        super.init(swift: swift)
    }
}

/// Result of trying to add secondary emails to a user. 'success' is the only value indicating that a user was
/// successfully retrieved for adding secondary emails. The other values explain the type of error that occurred,
/// and include the user for which the error occurred.
@objc
public class DBXTeamUserAddResult: NSObject {
    let swift: Team.UserAddResult

    public init(swift: Team.UserAddResult) {
        self.swift = swift
    }

    public static func factory(swift: Team.UserAddResult) -> DBXTeamUserAddResult {
        switch swift {
        case .success(let swiftArg):
            let arg = DBXTeamUserSecondaryEmailsResult(swift: swiftArg)
            return DBXTeamUserAddResultSuccess(arg)
        case .invalidUser(let swiftArg):
            let arg = DBXTeamUserSelectorArg(swift: swiftArg)
            return DBXTeamUserAddResultInvalidUser(arg)
        case .unverified(let swiftArg):
            let arg = DBXTeamUserSelectorArg(swift: swiftArg)
            return DBXTeamUserAddResultUnverified(arg)
        case .placeholderUser(let swiftArg):
            let arg = DBXTeamUserSelectorArg(swift: swiftArg)
            return DBXTeamUserAddResultPlaceholderUser(arg)
        case .other:
            return DBXTeamUserAddResultOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asSuccess: DBXTeamUserAddResultSuccess? {
        self as? DBXTeamUserAddResultSuccess
    }

    @objc
    public var asInvalidUser: DBXTeamUserAddResultInvalidUser? {
        self as? DBXTeamUserAddResultInvalidUser
    }

    @objc
    public var asUnverified: DBXTeamUserAddResultUnverified? {
        self as? DBXTeamUserAddResultUnverified
    }

    @objc
    public var asPlaceholderUser: DBXTeamUserAddResultPlaceholderUser? {
        self as? DBXTeamUserAddResultPlaceholderUser
    }

    @objc
    public var asOther: DBXTeamUserAddResultOther? {
        self as? DBXTeamUserAddResultOther
    }
}

/// Describes a user and the results for each attempt to add a secondary email.
@objc
public class DBXTeamUserAddResultSuccess: DBXTeamUserAddResult {
    @objc
    public var success: DBXTeamUserSecondaryEmailsResult

    @objc
    public init(_ arg: DBXTeamUserSecondaryEmailsResult) {
        self.success = arg
        let swift = Team.UserAddResult.success(arg.swift)
        super.init(swift: swift)
    }
}

/// Specified user is not a valid target for adding secondary emails.
@objc
public class DBXTeamUserAddResultInvalidUser: DBXTeamUserAddResult {
    @objc
    public var invalidUser: DBXTeamUserSelectorArg

    @objc
    public init(_ arg: DBXTeamUserSelectorArg) {
        self.invalidUser = arg
        let swift = Team.UserAddResult.invalidUser(arg.swift)
        super.init(swift: swift)
    }
}

/// Secondary emails can only be added to verified users.
@objc
public class DBXTeamUserAddResultUnverified: DBXTeamUserAddResult {
    @objc
    public var unverified: DBXTeamUserSelectorArg

    @objc
    public init(_ arg: DBXTeamUserSelectorArg) {
        self.unverified = arg
        let swift = Team.UserAddResult.unverified(arg.swift)
        super.init(swift: swift)
    }
}

/// Secondary emails cannot be added to placeholder users.
@objc
public class DBXTeamUserAddResultPlaceholderUser: DBXTeamUserAddResult {
    @objc
    public var placeholderUser: DBXTeamUserSelectorArg

    @objc
    public init(_ arg: DBXTeamUserSelectorArg) {
        self.placeholderUser = arg
        let swift = Team.UserAddResult.placeholderUser(arg.swift)
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXTeamUserAddResultOther: DBXTeamUserAddResult {
    @objc
    public init() {
        let swift = Team.UserAddResult.other
        super.init(swift: swift)
    }
}

/// User and their required custom quota in GB (1 TB = 1024 GB).
@objc
public class DBXTeamUserCustomQuotaArg: NSObject {
    /// (no description)
    @objc
    public var user: DBXTeamUserSelectorArg { DBXTeamUserSelectorArg(swift: swift.user) }
    /// (no description)
    @objc
    public var quotaGb: NSNumber { swift.quotaGb as NSNumber }

    @objc
    public init(user: DBXTeamUserSelectorArg, quotaGb: NSNumber) {
        self.swift = Team.UserCustomQuotaArg(user: user.swift, quotaGb: quotaGb.uint32Value)
    }

    let swift: Team.UserCustomQuotaArg

    public init(swift: Team.UserCustomQuotaArg) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// User and their custom quota in GB (1 TB = 1024 GB).  No quota returns if the user has no custom quota set.
@objc
public class DBXTeamUserCustomQuotaResult: NSObject {
    /// (no description)
    @objc
    public var user: DBXTeamUserSelectorArg { DBXTeamUserSelectorArg(swift: swift.user) }
    /// (no description)
    @objc
    public var quotaGb: NSNumber? { swift.quotaGb as NSNumber? }

    @objc
    public init(user: DBXTeamUserSelectorArg, quotaGb: NSNumber?) {
        self.swift = Team.UserCustomQuotaResult(user: user.swift, quotaGb: quotaGb?.uint32Value)
    }

    let swift: Team.UserCustomQuotaResult

    public init(swift: Team.UserCustomQuotaResult) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible UserDeleteEmailsResult struct
@objc
public class DBXTeamUserDeleteEmailsResult: NSObject {
    /// (no description)
    @objc
    public var user: DBXTeamUserSelectorArg { DBXTeamUserSelectorArg(swift: swift.user) }
    /// (no description)
    @objc
    public var results: [DBXTeamDeleteSecondaryEmailResult] { swift.results.map { DBXTeamDeleteSecondaryEmailResult(swift: $0) } }

    @objc
    public init(user: DBXTeamUserSelectorArg, results: [DBXTeamDeleteSecondaryEmailResult]) {
        self.swift = Team.UserDeleteEmailsResult(user: user.swift, results: results.map(\.swift))
    }

    let swift: Team.UserDeleteEmailsResult

    public init(swift: Team.UserDeleteEmailsResult) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Result of trying to delete a user's secondary emails. 'success' is the only value indicating that a user was
/// successfully retrieved for deleting secondary emails. The other values explain the type of error that occurred,
/// and include the user for which the error occurred.
@objc
public class DBXTeamUserDeleteResult: NSObject {
    let swift: Team.UserDeleteResult

    public init(swift: Team.UserDeleteResult) {
        self.swift = swift
    }

    public static func factory(swift: Team.UserDeleteResult) -> DBXTeamUserDeleteResult {
        switch swift {
        case .success(let swiftArg):
            let arg = DBXTeamUserDeleteEmailsResult(swift: swiftArg)
            return DBXTeamUserDeleteResultSuccess(arg)
        case .invalidUser(let swiftArg):
            let arg = DBXTeamUserSelectorArg(swift: swiftArg)
            return DBXTeamUserDeleteResultInvalidUser(arg)
        case .other:
            return DBXTeamUserDeleteResultOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asSuccess: DBXTeamUserDeleteResultSuccess? {
        self as? DBXTeamUserDeleteResultSuccess
    }

    @objc
    public var asInvalidUser: DBXTeamUserDeleteResultInvalidUser? {
        self as? DBXTeamUserDeleteResultInvalidUser
    }

    @objc
    public var asOther: DBXTeamUserDeleteResultOther? {
        self as? DBXTeamUserDeleteResultOther
    }
}

/// Describes a user and the results for each attempt to delete a secondary email.
@objc
public class DBXTeamUserDeleteResultSuccess: DBXTeamUserDeleteResult {
    @objc
    public var success: DBXTeamUserDeleteEmailsResult

    @objc
    public init(_ arg: DBXTeamUserDeleteEmailsResult) {
        self.success = arg
        let swift = Team.UserDeleteResult.success(arg.swift)
        super.init(swift: swift)
    }
}

/// Specified user is not a valid target for deleting secondary emails.
@objc
public class DBXTeamUserDeleteResultInvalidUser: DBXTeamUserDeleteResult {
    @objc
    public var invalidUser: DBXTeamUserSelectorArg

    @objc
    public init(_ arg: DBXTeamUserSelectorArg) {
        self.invalidUser = arg
        let swift = Team.UserDeleteResult.invalidUser(arg.swift)
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXTeamUserDeleteResultOther: DBXTeamUserDeleteResult {
    @objc
    public init() {
        let swift = Team.UserDeleteResult.other
        super.init(swift: swift)
    }
}

/// Objective-C compatible UserResendEmailsResult struct
@objc
public class DBXTeamUserResendEmailsResult: NSObject {
    /// (no description)
    @objc
    public var user: DBXTeamUserSelectorArg { DBXTeamUserSelectorArg(swift: swift.user) }
    /// (no description)
    @objc
    public var results: [DBXTeamResendSecondaryEmailResult] { swift.results.map { DBXTeamResendSecondaryEmailResult(swift: $0) } }

    @objc
    public init(user: DBXTeamUserSelectorArg, results: [DBXTeamResendSecondaryEmailResult]) {
        self.swift = Team.UserResendEmailsResult(user: user.swift, results: results.map(\.swift))
    }

    let swift: Team.UserResendEmailsResult

    public init(swift: Team.UserResendEmailsResult) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Result of trying to resend verification emails to a user. 'success' is the only value indicating that a user was
/// successfully retrieved for sending verification emails. The other values explain the type of error that
/// occurred, and include the user for which the error occurred.
@objc
public class DBXTeamUserResendResult: NSObject {
    let swift: Team.UserResendResult

    public init(swift: Team.UserResendResult) {
        self.swift = swift
    }

    public static func factory(swift: Team.UserResendResult) -> DBXTeamUserResendResult {
        switch swift {
        case .success(let swiftArg):
            let arg = DBXTeamUserResendEmailsResult(swift: swiftArg)
            return DBXTeamUserResendResultSuccess(arg)
        case .invalidUser(let swiftArg):
            let arg = DBXTeamUserSelectorArg(swift: swiftArg)
            return DBXTeamUserResendResultInvalidUser(arg)
        case .other:
            return DBXTeamUserResendResultOther()
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asSuccess: DBXTeamUserResendResultSuccess? {
        self as? DBXTeamUserResendResultSuccess
    }

    @objc
    public var asInvalidUser: DBXTeamUserResendResultInvalidUser? {
        self as? DBXTeamUserResendResultInvalidUser
    }

    @objc
    public var asOther: DBXTeamUserResendResultOther? {
        self as? DBXTeamUserResendResultOther
    }
}

/// Describes a user and the results for each attempt to resend verification emails.
@objc
public class DBXTeamUserResendResultSuccess: DBXTeamUserResendResult {
    @objc
    public var success: DBXTeamUserResendEmailsResult

    @objc
    public init(_ arg: DBXTeamUserResendEmailsResult) {
        self.success = arg
        let swift = Team.UserResendResult.success(arg.swift)
        super.init(swift: swift)
    }
}

/// Specified user is not a valid target for resending verification emails.
@objc
public class DBXTeamUserResendResultInvalidUser: DBXTeamUserResendResult {
    @objc
    public var invalidUser: DBXTeamUserSelectorArg

    @objc
    public init(_ arg: DBXTeamUserSelectorArg) {
        self.invalidUser = arg
        let swift = Team.UserResendResult.invalidUser(arg.swift)
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXTeamUserResendResultOther: DBXTeamUserResendResult {
    @objc
    public init() {
        let swift = Team.UserResendResult.other
        super.init(swift: swift)
    }
}

/// User and a list of secondary emails.
@objc
public class DBXTeamUserSecondaryEmailsArg: NSObject {
    /// (no description)
    @objc
    public var user: DBXTeamUserSelectorArg { DBXTeamUserSelectorArg(swift: swift.user) }
    /// (no description)
    @objc
    public var secondaryEmails: [String] { swift.secondaryEmails }

    @objc
    public init(user: DBXTeamUserSelectorArg, secondaryEmails: [String]) {
        self.swift = Team.UserSecondaryEmailsArg(user: user.swift, secondaryEmails: secondaryEmails)
    }

    let swift: Team.UserSecondaryEmailsArg

    public init(swift: Team.UserSecondaryEmailsArg) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Objective-C compatible UserSecondaryEmailsResult struct
@objc
public class DBXTeamUserSecondaryEmailsResult: NSObject {
    /// (no description)
    @objc
    public var user: DBXTeamUserSelectorArg { DBXTeamUserSelectorArg(swift: swift.user) }
    /// (no description)
    @objc
    public var results: [DBXTeamAddSecondaryEmailResult] { swift.results.map { DBXTeamAddSecondaryEmailResult(swift: $0) } }

    @objc
    public init(user: DBXTeamUserSelectorArg, results: [DBXTeamAddSecondaryEmailResult]) {
        self.swift = Team.UserSecondaryEmailsResult(user: user.swift, results: results.map(\.swift))
    }

    let swift: Team.UserSecondaryEmailsResult

    public init(swift: Team.UserSecondaryEmailsResult) {
        self.swift = swift
    }

    @objc
    public override var description: String { swift.description }
}

/// Argument for selecting a single user, either by team_member_id, external_id or email.
@objc
public class DBXTeamUserSelectorArg: NSObject {
    let swift: Team.UserSelectorArg

    public init(swift: Team.UserSelectorArg) {
        self.swift = swift
    }

    public static func factory(swift: Team.UserSelectorArg) -> DBXTeamUserSelectorArg {
        switch swift {
        case .teamMemberId(let swiftArg):
            let arg = swiftArg
            return DBXTeamUserSelectorArgTeamMemberId(arg)
        case .externalId(let swiftArg):
            let arg = swiftArg
            return DBXTeamUserSelectorArgExternalId(arg)
        case .email(let swiftArg):
            let arg = swiftArg
            return DBXTeamUserSelectorArgEmail(arg)
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asTeamMemberId: DBXTeamUserSelectorArgTeamMemberId? {
        self as? DBXTeamUserSelectorArgTeamMemberId
    }

    @objc
    public var asExternalId: DBXTeamUserSelectorArgExternalId? {
        self as? DBXTeamUserSelectorArgExternalId
    }

    @objc
    public var asEmail: DBXTeamUserSelectorArgEmail? {
        self as? DBXTeamUserSelectorArgEmail
    }
}

/// An unspecified error.
@objc
public class DBXTeamUserSelectorArgTeamMemberId: DBXTeamUserSelectorArg {
    @objc
    public var teamMemberId: String

    @objc
    public init(_ arg: String) {
        self.teamMemberId = arg
        let swift = Team.UserSelectorArg.teamMemberId(arg)
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXTeamUserSelectorArgExternalId: DBXTeamUserSelectorArg {
    @objc
    public var externalId: String

    @objc
    public init(_ arg: String) {
        self.externalId = arg
        let swift = Team.UserSelectorArg.externalId(arg)
        super.init(swift: swift)
    }
}

/// An unspecified error.
@objc
public class DBXTeamUserSelectorArgEmail: DBXTeamUserSelectorArg {
    @objc
    public var email: String

    @objc
    public init(_ arg: String) {
        self.email = arg
        let swift = Team.UserSelectorArg.email(arg)
        super.init(swift: swift)
    }
}

/// Argument for selecting a list of users, either by team_member_ids, external_ids or emails.
@objc
public class DBXTeamUsersSelectorArg: NSObject {
    let swift: Team.UsersSelectorArg

    public init(swift: Team.UsersSelectorArg) {
        self.swift = swift
    }

    public static func factory(swift: Team.UsersSelectorArg) -> DBXTeamUsersSelectorArg {
        switch swift {
        case .teamMemberIds(let swiftArg):
            let arg = swiftArg
            return DBXTeamUsersSelectorArgTeamMemberIds(arg)
        case .externalIds(let swiftArg):
            let arg = swiftArg
            return DBXTeamUsersSelectorArgExternalIds(arg)
        case .emails(let swiftArg):
            let arg = swiftArg
            return DBXTeamUsersSelectorArgEmails(arg)
        }
    }

    @objc
    public override var description: String { swift.description }

    @objc
    public var asTeamMemberIds: DBXTeamUsersSelectorArgTeamMemberIds? {
        self as? DBXTeamUsersSelectorArgTeamMemberIds
    }

    @objc
    public var asExternalIds: DBXTeamUsersSelectorArgExternalIds? {
        self as? DBXTeamUsersSelectorArgExternalIds
    }

    @objc
    public var asEmails: DBXTeamUsersSelectorArgEmails? {
        self as? DBXTeamUsersSelectorArgEmails
    }
}

/// List of member IDs.
@objc
public class DBXTeamUsersSelectorArgTeamMemberIds: DBXTeamUsersSelectorArg {
    @objc
    public var teamMemberIds: [String]

    @objc
    public init(_ arg: [String]) {
        self.teamMemberIds = arg
        let swift = Team.UsersSelectorArg.teamMemberIds(arg)
        super.init(swift: swift)
    }
}

/// List of external user IDs.
@objc
public class DBXTeamUsersSelectorArgExternalIds: DBXTeamUsersSelectorArg {
    @objc
    public var externalIds: [String]

    @objc
    public init(_ arg: [String]) {
        self.externalIds = arg
        let swift = Team.UsersSelectorArg.externalIds(arg)
        super.init(swift: swift)
    }
}

/// List of email addresses.
@objc
public class DBXTeamUsersSelectorArgEmails: DBXTeamUsersSelectorArg {
    @objc
    public var emails: [String]

    @objc
    public init(_ arg: [String]) {
        self.emails = arg
        let swift = Team.UsersSelectorArg.emails(arg)
        super.init(swift: swift)
    }
}
