///
/// Copyright (c) 2022 Dropbox, Inc. All rights reserved.
///
/// Auto-generated by Stone, do not modify.
///

import Foundation
import SwiftyDropbox

/// Objective-C compatible routes for the team_log namespace
/// For Swift routes see TeamLogRoutes
@objc
public class DBXTeamLogRoutes: NSObject {
    private let swift: TeamLogRoutes
    init(swift: TeamLogRoutes) {
        self.swift = swift
        self.client = swift.client.objc
    }

    public let client: DBXDropboxTransportClient

    /// Retrieves team events. If the result's hasMore in GetTeamEventsResult field is true, call getEventsContinue with
    /// the returned cursor to retrieve more entries. If end_time is not specified in your request, you may use the
    /// returned cursor to poll getEventsContinue for new events. Many attributes note 'may be missing due to
    /// historical data gap'. Note that the file_operations category and & analogous paper events are not available
    /// on all Dropbox Business plans /business/plans-comparison. Use features/get_values
    /// /developers/documentation/http/teams#team-features-get_values to check for this feature. Permission : Team
    /// Auditing.
    ///
    /// - scope: events.read
    ///
    /// - parameter limit: The maximal number of results to return per call. Note that some calls may not return limit
    /// number of events, and may even return no events, even with `has_more` set to true. In this case, callers
    /// should fetch again using getEventsContinue.
    /// - parameter accountId: Filter the events by account ID. Return only events with this account_id as either Actor,
    /// Context, or Participants.
    /// - parameter time: Filter by time range.
    /// - parameter category: Filter the returned events to a single category. Note that category shouldn't be provided
    /// together with event_type.
    /// - parameter eventType: Filter the returned events to a single event type. Note that event_type shouldn't be
    /// provided together with category.
    ///
    /// - returns: Through the response callback, the caller will receive a `TeamLog.GetTeamEventsResult` object on
    /// success or a `TeamLog.GetTeamEventsError` object on failure.
    @objc
    @discardableResult public func getEvents(
        limit: NSNumber,
        accountId: String?,
        time: DBXTeamCommonTimeRange?,
        category: DBXTeamLogEventCategory?,
        eventType: DBXTeamLogEventTypeArg?
    ) -> DBXTeamLogGetEventsRpcRequest {
        let swift = swift.getEvents(limit: limit.uint32Value, accountId: accountId, time: time?.swift, category: category?.swift, eventType: eventType?.swift)
        return DBXTeamLogGetEventsRpcRequest(swift: swift)
    }

    /// Retrieves team events. If the result's hasMore in GetTeamEventsResult field is true, call getEventsContinue with
    /// the returned cursor to retrieve more entries. If end_time is not specified in your request, you may use the
    /// returned cursor to poll getEventsContinue for new events. Many attributes note 'may be missing due to
    /// historical data gap'. Note that the file_operations category and & analogous paper events are not available
    /// on all Dropbox Business plans /business/plans-comparison. Use features/get_values
    /// /developers/documentation/http/teams#team-features-get_values to check for this feature. Permission : Team
    /// Auditing.
    ///
    /// - scope: events.read
    ///
    /// - returns: Through the response callback, the caller will receive a `TeamLog.GetTeamEventsResult` object on
    /// success or a `TeamLog.GetTeamEventsError` object on failure.
    @objc
    @discardableResult public func getEvents() -> DBXTeamLogGetEventsRpcRequest {
        let swift = swift.getEvents()
        return DBXTeamLogGetEventsRpcRequest(swift: swift)
    }

    /// Once a cursor has been retrieved from getEvents, use this to paginate through all events. Permission : Team
    /// Auditing.
    ///
    /// - scope: events.read
    ///
    /// - parameter cursor: Indicates from what point to get the next set of events.
    ///
    /// - returns: Through the response callback, the caller will receive a `TeamLog.GetTeamEventsResult` object on
    /// success or a `TeamLog.GetTeamEventsContinueError` object on failure.
    @objc
    @discardableResult public func getEventsContinue(cursor: String) -> DBXTeamLogGetEventsContinueRpcRequest {
        let swift = swift.getEventsContinue(cursor: cursor)
        return DBXTeamLogGetEventsContinueRpcRequest(swift: swift)
    }
}

@objc
public class DBXTeamLogGetEventsRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<TeamLog.GetTeamEventsResultSerializer, TeamLog.GetTeamEventsErrorSerializer>

    init(swift: RpcRequest<TeamLog.GetTeamEventsResultSerializer, TeamLog.GetTeamEventsErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXTeamLogGetTeamEventsResult?, DBXTeamLogGetTeamEventsError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXTeamLogGetTeamEventsResult?, DBXTeamLogGetTeamEventsError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXTeamLogGetTeamEventsError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXTeamLogGetTeamEventsError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXTeamLogGetTeamEventsResult?
            if let swift = result {
                objc = DBXTeamLogGetTeamEventsResult(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}

@objc
public class DBXTeamLogGetEventsContinueRpcRequest: NSObject, DBXRequest {
    var swift: RpcRequest<TeamLog.GetTeamEventsResultSerializer, TeamLog.GetTeamEventsContinueErrorSerializer>

    init(swift: RpcRequest<TeamLog.GetTeamEventsResultSerializer, TeamLog.GetTeamEventsContinueErrorSerializer>) {
        self.swift = swift
    }

    @objc
    @discardableResult public func response(
        completionHandler: @escaping (DBXTeamLogGetTeamEventsResult?, DBXTeamLogGetTeamEventsContinueError?, DBXCallError?) -> Void
    ) -> Self {
        response(queue: nil, completionHandler: completionHandler)
    }

    @objc
    @discardableResult public func response(
        queue: DispatchQueue?,
        completionHandler: @escaping (DBXTeamLogGetTeamEventsResult?, DBXTeamLogGetTeamEventsContinueError?, DBXCallError?) -> Void
    ) -> Self {
        swift.response(queue: queue) { result, error in
            var routeError: DBXTeamLogGetTeamEventsContinueError?
            var callError: DBXCallError?
            switch error {
            case .routeError(let box, _, _, _):
                routeError = DBXTeamLogGetTeamEventsContinueError(swift: box.unboxed)
                callError = nil
            default:
                routeError = nil
                callError = error?.objc
            }

            var objc: DBXTeamLogGetTeamEventsResult?
            if let swift = result {
                objc = DBXTeamLogGetTeamEventsResult(swift: swift)
            }
            completionHandler(objc, routeError, callError)
        }
        return self
    }

    @objc
    public var clientPersistedString: String? { swift.clientPersistedString }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public var earliestBeginDate: Date? { swift.earliestBeginDate }

    @objc
    public func persistingString(string: String?) -> Self {
        swift.persistingString(string: string)
        return self
    }

    @available(iOS 13.0, macOS 10.13, *)
    @objc
    public func settingEarliestBeginDate(date: Date?) -> Self {
        swift.settingEarliestBeginDate(date: date)
        return self
    }

    @objc
    public func cancel() {
        swift.cancel()
    }
}
