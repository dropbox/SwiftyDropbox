///
/// Copyright (c) 2016 Dropbox, Inc. All rights reserved.
///
/// Auto-generated by Stone, do not modify.
///

import Foundation

/// Datatypes and serializers for the team namespace
open class Team {
    /// The DeviceSession struct
    open class DeviceSession: CustomStringConvertible {
        /// The session id
        open let sessionId: String
        /// The IP address of the last activity from this session
        open let ipAddress: String?
        /// The country from which the last activity from this session was made
        open let country: String?
        /// The time this session was created
        open let created: Date?
        /// The time of the last activity from this session
        open let updated: Date?
        public init(sessionId: String, ipAddress: String? = nil, country: String? = nil, created: Date? = nil, updated: Date? = nil) {
            stringValidator()(sessionId)
            self.sessionId = sessionId
            nullableValidator(stringValidator())(ipAddress)
            self.ipAddress = ipAddress
            nullableValidator(stringValidator())(country)
            self.country = country
            self.created = created
            self.updated = updated
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(DeviceSessionSerializer().serialize(self)))"
        }
    }
    open class DeviceSessionSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: DeviceSession) -> JSON {
            let output = [
            "session_id": Serialization._StringSerializer.serialize(value.sessionId),
            "ip_address": NullableSerializer(Serialization._StringSerializer).serialize(value.ipAddress),
            "country": NullableSerializer(Serialization._StringSerializer).serialize(value.country),
            "created": NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.created),
            "updated": NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.updated),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> DeviceSession {
            switch json {
                case .dictionary(let dict):
                    let sessionId = Serialization._StringSerializer.deserialize(dict["session_id"] ?? .null)
                    let ipAddress = NullableSerializer(Serialization._StringSerializer).deserialize(dict["ip_address"] ?? .null)
                    let country = NullableSerializer(Serialization._StringSerializer).deserialize(dict["country"] ?? .null)
                    let created = NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).deserialize(dict["created"] ?? .null)
                    let updated = NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).deserialize(dict["updated"] ?? .null)
                    return DeviceSession(sessionId: sessionId, ipAddress: ipAddress, country: country, created: created, updated: updated)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Information on active web sessions
    open class ActiveWebSession: Team.DeviceSession {
        /// Information on the hosting device
        open let userAgent: String
        /// Information on the hosting operating system
        open let os: String
        /// Information on the browser used for this web session
        open let browser: String
        public init(sessionId: String, userAgent: String, os: String, browser: String, ipAddress: String? = nil, country: String? = nil, created: Date? = nil, updated: Date? = nil) {
            stringValidator()(userAgent)
            self.userAgent = userAgent
            stringValidator()(os)
            self.os = os
            stringValidator()(browser)
            self.browser = browser
            super.init(sessionId: sessionId, ipAddress: ipAddress, country: country, created: created, updated: updated)
        }
        open override var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ActiveWebSessionSerializer().serialize(self)))"
        }
    }
    open class ActiveWebSessionSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ActiveWebSession) -> JSON {
            let output = [
            "session_id": Serialization._StringSerializer.serialize(value.sessionId),
            "user_agent": Serialization._StringSerializer.serialize(value.userAgent),
            "os": Serialization._StringSerializer.serialize(value.os),
            "browser": Serialization._StringSerializer.serialize(value.browser),
            "ip_address": NullableSerializer(Serialization._StringSerializer).serialize(value.ipAddress),
            "country": NullableSerializer(Serialization._StringSerializer).serialize(value.country),
            "created": NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.created),
            "updated": NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.updated),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ActiveWebSession {
            switch json {
                case .dictionary(let dict):
                    let sessionId = Serialization._StringSerializer.deserialize(dict["session_id"] ?? .null)
                    let userAgent = Serialization._StringSerializer.deserialize(dict["user_agent"] ?? .null)
                    let os = Serialization._StringSerializer.deserialize(dict["os"] ?? .null)
                    let browser = Serialization._StringSerializer.deserialize(dict["browser"] ?? .null)
                    let ipAddress = NullableSerializer(Serialization._StringSerializer).deserialize(dict["ip_address"] ?? .null)
                    let country = NullableSerializer(Serialization._StringSerializer).deserialize(dict["country"] ?? .null)
                    let created = NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).deserialize(dict["created"] ?? .null)
                    let updated = NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).deserialize(dict["updated"] ?? .null)
                    return ActiveWebSession(sessionId: sessionId, userAgent: userAgent, os: os, browser: browser, ipAddress: ipAddress, country: country, created: created, updated: updated)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Arguments for adding property templates.
    open class AddPropertyTemplateArg: Properties.PropertyGroupTemplate {
        open override var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(AddPropertyTemplateArgSerializer().serialize(self)))"
        }
    }
    open class AddPropertyTemplateArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: AddPropertyTemplateArg) -> JSON {
            let output = [
            "name": Serialization._StringSerializer.serialize(value.name),
            "description": Serialization._StringSerializer.serialize(value.description_),
            "fields": ArraySerializer(Properties.PropertyFieldTemplateSerializer()).serialize(value.fields),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> AddPropertyTemplateArg {
            switch json {
                case .dictionary(let dict):
                    let name = Serialization._StringSerializer.deserialize(dict["name"] ?? .null)
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    let fields = ArraySerializer(Properties.PropertyFieldTemplateSerializer()).deserialize(dict["fields"] ?? .null)
                    return AddPropertyTemplateArg(name: name, description_: description_, fields: fields)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The AddPropertyTemplateResult struct
    open class AddPropertyTemplateResult: CustomStringConvertible {
        /// An identifier for property template added by propertiesTemplateAdd.
        open let templateId: String
        public init(templateId: String) {
            stringValidator(minLength: 1, pattern: "(/|ptid:).*")(templateId)
            self.templateId = templateId
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(AddPropertyTemplateResultSerializer().serialize(self)))"
        }
    }
    open class AddPropertyTemplateResultSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: AddPropertyTemplateResult) -> JSON {
            let output = [
            "template_id": Serialization._StringSerializer.serialize(value.templateId),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> AddPropertyTemplateResult {
            switch json {
                case .dictionary(let dict):
                    let templateId = Serialization._StringSerializer.deserialize(dict["template_id"] ?? .null)
                    return AddPropertyTemplateResult(templateId: templateId)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Describes which team-related admin permissions a user has.
    public enum AdminTier: CustomStringConvertible {
        /// User is an administrator of the team - has all permissions.
        case teamAdmin
        /// User can do most user provisioning, de-provisioning and management.
        case userManagementAdmin
        /// User can do a limited set of common support tasks for existing users.
        case supportAdmin
        /// User is not an admin of the team.
        case memberOnly

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(AdminTierSerializer().serialize(self)))"
        }
    }
    open class AdminTierSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: AdminTier) -> JSON {
            switch value {
                case .teamAdmin:
                    var d = [String: JSON]()
                    d[".tag"] = .str("team_admin")
                    return .dictionary(d)
                case .userManagementAdmin:
                    var d = [String: JSON]()
                    d[".tag"] = .str("user_management_admin")
                    return .dictionary(d)
                case .supportAdmin:
                    var d = [String: JSON]()
                    d[".tag"] = .str("support_admin")
                    return .dictionary(d)
                case .memberOnly:
                    var d = [String: JSON]()
                    d[".tag"] = .str("member_only")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> AdminTier {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "team_admin":
                            return AdminTier.teamAdmin
                        case "user_management_admin":
                            return AdminTier.userManagementAdmin
                        case "support_admin":
                            return AdminTier.supportAdmin
                        case "member_only":
                            return AdminTier.memberOnly
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Information on linked third party applications
    open class ApiApp: CustomStringConvertible {
        /// The application unique id
        open let appId: String
        /// The application name
        open let appName: String
        /// The application publisher name
        open let publisher: String?
        /// The publisher's URL
        open let publisherUrl: String?
        /// The time this application was linked
        open let linked: Date?
        /// Whether the linked application uses a dedicated folder
        open let isAppFolder: Bool
        public init(appId: String, appName: String, isAppFolder: Bool, publisher: String? = nil, publisherUrl: String? = nil, linked: Date? = nil) {
            stringValidator()(appId)
            self.appId = appId
            stringValidator()(appName)
            self.appName = appName
            nullableValidator(stringValidator())(publisher)
            self.publisher = publisher
            nullableValidator(stringValidator())(publisherUrl)
            self.publisherUrl = publisherUrl
            self.linked = linked
            self.isAppFolder = isAppFolder
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ApiAppSerializer().serialize(self)))"
        }
    }
    open class ApiAppSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ApiApp) -> JSON {
            let output = [
            "app_id": Serialization._StringSerializer.serialize(value.appId),
            "app_name": Serialization._StringSerializer.serialize(value.appName),
            "is_app_folder": Serialization._BoolSerializer.serialize(value.isAppFolder),
            "publisher": NullableSerializer(Serialization._StringSerializer).serialize(value.publisher),
            "publisher_url": NullableSerializer(Serialization._StringSerializer).serialize(value.publisherUrl),
            "linked": NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.linked),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ApiApp {
            switch json {
                case .dictionary(let dict):
                    let appId = Serialization._StringSerializer.deserialize(dict["app_id"] ?? .null)
                    let appName = Serialization._StringSerializer.deserialize(dict["app_name"] ?? .null)
                    let isAppFolder = Serialization._BoolSerializer.deserialize(dict["is_app_folder"] ?? .null)
                    let publisher = NullableSerializer(Serialization._StringSerializer).deserialize(dict["publisher"] ?? .null)
                    let publisherUrl = NullableSerializer(Serialization._StringSerializer).deserialize(dict["publisher_url"] ?? .null)
                    let linked = NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).deserialize(dict["linked"] ?? .null)
                    return ApiApp(appId: appId, appName: appName, isAppFolder: isAppFolder, publisher: publisher, publisherUrl: publisherUrl, linked: linked)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Base report structure.
    open class BaseDfbReport: CustomStringConvertible {
        /// First date present in the results as 'YYYY-MM-DD' or None.
        open let startDate: String
        public init(startDate: String) {
            stringValidator()(startDate)
            self.startDate = startDate
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(BaseDfbReportSerializer().serialize(self)))"
        }
    }
    open class BaseDfbReportSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: BaseDfbReport) -> JSON {
            let output = [
            "start_date": Serialization._StringSerializer.serialize(value.startDate),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> BaseDfbReport {
            switch json {
                case .dictionary(let dict):
                    let startDate = Serialization._StringSerializer.deserialize(dict["start_date"] ?? .null)
                    return BaseDfbReport(startDate: startDate)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Input arguments that can be provided for most reports.
    open class DateRange: CustomStringConvertible {
        /// Optional starting date (inclusive)
        open let startDate: Date?
        /// Optional ending date (exclusive)
        open let endDate: Date?
        public init(startDate: Date? = nil, endDate: Date? = nil) {
            self.startDate = startDate
            self.endDate = endDate
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(DateRangeSerializer().serialize(self)))"
        }
    }
    open class DateRangeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: DateRange) -> JSON {
            let output = [
            "start_date": NullableSerializer(NSDateSerializer("%Y-%m-%d")).serialize(value.startDate),
            "end_date": NullableSerializer(NSDateSerializer("%Y-%m-%d")).serialize(value.endDate),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> DateRange {
            switch json {
                case .dictionary(let dict):
                    let startDate = NullableSerializer(NSDateSerializer("%Y-%m-%d")).deserialize(dict["start_date"] ?? .null)
                    let endDate = NullableSerializer(NSDateSerializer("%Y-%m-%d")).deserialize(dict["end_date"] ?? .null)
                    return DateRange(startDate: startDate, endDate: endDate)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Errors that can originate from problems in input arguments to reports.
    public enum DateRangeError: CustomStringConvertible {
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(DateRangeErrorSerializer().serialize(self)))"
        }
    }
    open class DateRangeErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: DateRangeError) -> JSON {
            switch value {
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> DateRangeError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "other":
                            return DateRangeError.other
                        default:
                            return DateRangeError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Information about linked Dropbox desktop client sessions
    open class DesktopClientSession: Team.DeviceSession {
        /// Name of the hosting desktop
        open let hostName: String
        /// The Dropbox desktop client type
        open let clientType: Team.DesktopPlatform
        /// The Dropbox client version
        open let clientVersion: String
        /// Information on the hosting platform
        open let platform: String
        /// Whether it's possible to delete all of the account files upon unlinking
        open let isDeleteOnUnlinkSupported: Bool
        public init(sessionId: String, hostName: String, clientType: Team.DesktopPlatform, clientVersion: String, platform: String, isDeleteOnUnlinkSupported: Bool, ipAddress: String? = nil, country: String? = nil, created: Date? = nil, updated: Date? = nil) {
            stringValidator()(hostName)
            self.hostName = hostName
            self.clientType = clientType
            stringValidator()(clientVersion)
            self.clientVersion = clientVersion
            stringValidator()(platform)
            self.platform = platform
            self.isDeleteOnUnlinkSupported = isDeleteOnUnlinkSupported
            super.init(sessionId: sessionId, ipAddress: ipAddress, country: country, created: created, updated: updated)
        }
        open override var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(DesktopClientSessionSerializer().serialize(self)))"
        }
    }
    open class DesktopClientSessionSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: DesktopClientSession) -> JSON {
            let output = [
            "session_id": Serialization._StringSerializer.serialize(value.sessionId),
            "host_name": Serialization._StringSerializer.serialize(value.hostName),
            "client_type": Team.DesktopPlatformSerializer().serialize(value.clientType),
            "client_version": Serialization._StringSerializer.serialize(value.clientVersion),
            "platform": Serialization._StringSerializer.serialize(value.platform),
            "is_delete_on_unlink_supported": Serialization._BoolSerializer.serialize(value.isDeleteOnUnlinkSupported),
            "ip_address": NullableSerializer(Serialization._StringSerializer).serialize(value.ipAddress),
            "country": NullableSerializer(Serialization._StringSerializer).serialize(value.country),
            "created": NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.created),
            "updated": NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.updated),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> DesktopClientSession {
            switch json {
                case .dictionary(let dict):
                    let sessionId = Serialization._StringSerializer.deserialize(dict["session_id"] ?? .null)
                    let hostName = Serialization._StringSerializer.deserialize(dict["host_name"] ?? .null)
                    let clientType = Team.DesktopPlatformSerializer().deserialize(dict["client_type"] ?? .null)
                    let clientVersion = Serialization._StringSerializer.deserialize(dict["client_version"] ?? .null)
                    let platform = Serialization._StringSerializer.deserialize(dict["platform"] ?? .null)
                    let isDeleteOnUnlinkSupported = Serialization._BoolSerializer.deserialize(dict["is_delete_on_unlink_supported"] ?? .null)
                    let ipAddress = NullableSerializer(Serialization._StringSerializer).deserialize(dict["ip_address"] ?? .null)
                    let country = NullableSerializer(Serialization._StringSerializer).deserialize(dict["country"] ?? .null)
                    let created = NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).deserialize(dict["created"] ?? .null)
                    let updated = NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).deserialize(dict["updated"] ?? .null)
                    return DesktopClientSession(sessionId: sessionId, hostName: hostName, clientType: clientType, clientVersion: clientVersion, platform: platform, isDeleteOnUnlinkSupported: isDeleteOnUnlinkSupported, ipAddress: ipAddress, country: country, created: created, updated: updated)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The DesktopPlatform union
    public enum DesktopPlatform: CustomStringConvertible {
        /// Official Windows Dropbox desktop client
        case windows
        /// Official Mac Dropbox desktop client
        case mac
        /// Official Linux Dropbox desktop client
        case linux
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(DesktopPlatformSerializer().serialize(self)))"
        }
    }
    open class DesktopPlatformSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: DesktopPlatform) -> JSON {
            switch value {
                case .windows:
                    var d = [String: JSON]()
                    d[".tag"] = .str("windows")
                    return .dictionary(d)
                case .mac:
                    var d = [String: JSON]()
                    d[".tag"] = .str("mac")
                    return .dictionary(d)
                case .linux:
                    var d = [String: JSON]()
                    d[".tag"] = .str("linux")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> DesktopPlatform {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "windows":
                            return DesktopPlatform.windows
                        case "mac":
                            return DesktopPlatform.mac
                        case "linux":
                            return DesktopPlatform.linux
                        case "other":
                            return DesktopPlatform.other
                        default:
                            return DesktopPlatform.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The DeviceSessionArg struct
    open class DeviceSessionArg: CustomStringConvertible {
        /// The session id
        open let sessionId: String
        /// The unique id of the member owning the device
        open let teamMemberId: String
        public init(sessionId: String, teamMemberId: String) {
            stringValidator()(sessionId)
            self.sessionId = sessionId
            stringValidator()(teamMemberId)
            self.teamMemberId = teamMemberId
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(DeviceSessionArgSerializer().serialize(self)))"
        }
    }
    open class DeviceSessionArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: DeviceSessionArg) -> JSON {
            let output = [
            "session_id": Serialization._StringSerializer.serialize(value.sessionId),
            "team_member_id": Serialization._StringSerializer.serialize(value.teamMemberId),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> DeviceSessionArg {
            switch json {
                case .dictionary(let dict):
                    let sessionId = Serialization._StringSerializer.deserialize(dict["session_id"] ?? .null)
                    let teamMemberId = Serialization._StringSerializer.deserialize(dict["team_member_id"] ?? .null)
                    return DeviceSessionArg(sessionId: sessionId, teamMemberId: teamMemberId)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Each of the items is an array of values, one value per day. The value is the number of devices active within a
    /// time window, ending with that day. If there is no data for a day, then the value will be None.
    open class DevicesActive: CustomStringConvertible {
        /// Array of number of linked windows (desktop) clients with activity.
        open let windows: Array<UInt64?>
        /// Array of number of linked mac (desktop) clients with activity.
        open let macos: Array<UInt64?>
        /// Array of number of linked linus (desktop) clients with activity.
        open let linux: Array<UInt64?>
        /// Array of number of linked ios devices with activity.
        open let ios: Array<UInt64?>
        /// Array of number of linked android devices with activity.
        open let android: Array<UInt64?>
        /// Array of number of other linked devices (blackberry, windows phone, etc)  with activity.
        open let other: Array<UInt64?>
        /// Array of total number of linked clients with activity.
        open let total: Array<UInt64?>
        public init(windows: Array<UInt64?>, macos: Array<UInt64?>, linux: Array<UInt64?>, ios: Array<UInt64?>, android: Array<UInt64?>, other: Array<UInt64?>, total: Array<UInt64?>) {
            arrayValidator(itemValidator: nullableValidator(comparableValidator()))(windows)
            self.windows = windows
            arrayValidator(itemValidator: nullableValidator(comparableValidator()))(macos)
            self.macos = macos
            arrayValidator(itemValidator: nullableValidator(comparableValidator()))(linux)
            self.linux = linux
            arrayValidator(itemValidator: nullableValidator(comparableValidator()))(ios)
            self.ios = ios
            arrayValidator(itemValidator: nullableValidator(comparableValidator()))(android)
            self.android = android
            arrayValidator(itemValidator: nullableValidator(comparableValidator()))(other)
            self.other = other
            arrayValidator(itemValidator: nullableValidator(comparableValidator()))(total)
            self.total = total
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(DevicesActiveSerializer().serialize(self)))"
        }
    }
    open class DevicesActiveSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: DevicesActive) -> JSON {
            let output = [
            "windows": ArraySerializer(NullableSerializer(Serialization._UInt64Serializer)).serialize(value.windows),
            "macos": ArraySerializer(NullableSerializer(Serialization._UInt64Serializer)).serialize(value.macos),
            "linux": ArraySerializer(NullableSerializer(Serialization._UInt64Serializer)).serialize(value.linux),
            "ios": ArraySerializer(NullableSerializer(Serialization._UInt64Serializer)).serialize(value.ios),
            "android": ArraySerializer(NullableSerializer(Serialization._UInt64Serializer)).serialize(value.android),
            "other": ArraySerializer(NullableSerializer(Serialization._UInt64Serializer)).serialize(value.other),
            "total": ArraySerializer(NullableSerializer(Serialization._UInt64Serializer)).serialize(value.total),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> DevicesActive {
            switch json {
                case .dictionary(let dict):
                    let windows = ArraySerializer(NullableSerializer(Serialization._UInt64Serializer)).deserialize(dict["windows"] ?? .null)
                    let macos = ArraySerializer(NullableSerializer(Serialization._UInt64Serializer)).deserialize(dict["macos"] ?? .null)
                    let linux = ArraySerializer(NullableSerializer(Serialization._UInt64Serializer)).deserialize(dict["linux"] ?? .null)
                    let ios = ArraySerializer(NullableSerializer(Serialization._UInt64Serializer)).deserialize(dict["ios"] ?? .null)
                    let android = ArraySerializer(NullableSerializer(Serialization._UInt64Serializer)).deserialize(dict["android"] ?? .null)
                    let other = ArraySerializer(NullableSerializer(Serialization._UInt64Serializer)).deserialize(dict["other"] ?? .null)
                    let total = ArraySerializer(NullableSerializer(Serialization._UInt64Serializer)).deserialize(dict["total"] ?? .null)
                    return DevicesActive(windows: windows, macos: macos, linux: linux, ios: ios, android: android, other: other, total: total)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Activity Report Result. Each of the items in the storage report is an array of values, one value per day. If
    /// there is no data for a day, then the value will be None.
    open class GetActivityReport: Team.BaseDfbReport {
        /// Array of total number of adds by team members.
        open let adds: Array<UInt64?>
        /// Array of number of edits by team members. If the same user edits the same file multiple times this is
        /// counted as a single edit.
        open let edits: Array<UInt64?>
        /// Array of total number of deletes by team members.
        open let deletes: Array<UInt64?>
        /// Array of the number of users who have been active in the last 28 days.
        open let activeUsers28Day: Array<UInt64?>
        /// Array of the number of users who have been active in the last week.
        open let activeUsers7Day: Array<UInt64?>
        /// Array of the number of users who have been active in the last day.
        open let activeUsers1Day: Array<UInt64?>
        /// Array of the number of shared folders with some activity in the last 28 days.
        open let activeSharedFolders28Day: Array<UInt64?>
        /// Array of the number of shared folders with some activity in the last week.
        open let activeSharedFolders7Day: Array<UInt64?>
        /// Array of the number of shared folders with some activity in the last day.
        open let activeSharedFolders1Day: Array<UInt64?>
        /// Array of the number of shared links created.
        open let sharedLinksCreated: Array<UInt64?>
        /// Array of the number of views by team users to shared links created by the team.
        open let sharedLinksViewedByTeam: Array<UInt64?>
        /// Array of the number of views by users outside of the team to shared links created by the team.
        open let sharedLinksViewedByOutsideUser: Array<UInt64?>
        /// Array of the number of views by non-logged-in users to shared links created by the team.
        open let sharedLinksViewedByNotLoggedIn: Array<UInt64?>
        /// Array of the total number of views to shared links created by the team.
        open let sharedLinksViewedTotal: Array<UInt64?>
        public init(startDate: String, adds: Array<UInt64?>, edits: Array<UInt64?>, deletes: Array<UInt64?>, activeUsers28Day: Array<UInt64?>, activeUsers7Day: Array<UInt64?>, activeUsers1Day: Array<UInt64?>, activeSharedFolders28Day: Array<UInt64?>, activeSharedFolders7Day: Array<UInt64?>, activeSharedFolders1Day: Array<UInt64?>, sharedLinksCreated: Array<UInt64?>, sharedLinksViewedByTeam: Array<UInt64?>, sharedLinksViewedByOutsideUser: Array<UInt64?>, sharedLinksViewedByNotLoggedIn: Array<UInt64?>, sharedLinksViewedTotal: Array<UInt64?>) {
            arrayValidator(itemValidator: nullableValidator(comparableValidator()))(adds)
            self.adds = adds
            arrayValidator(itemValidator: nullableValidator(comparableValidator()))(edits)
            self.edits = edits
            arrayValidator(itemValidator: nullableValidator(comparableValidator()))(deletes)
            self.deletes = deletes
            arrayValidator(itemValidator: nullableValidator(comparableValidator()))(activeUsers28Day)
            self.activeUsers28Day = activeUsers28Day
            arrayValidator(itemValidator: nullableValidator(comparableValidator()))(activeUsers7Day)
            self.activeUsers7Day = activeUsers7Day
            arrayValidator(itemValidator: nullableValidator(comparableValidator()))(activeUsers1Day)
            self.activeUsers1Day = activeUsers1Day
            arrayValidator(itemValidator: nullableValidator(comparableValidator()))(activeSharedFolders28Day)
            self.activeSharedFolders28Day = activeSharedFolders28Day
            arrayValidator(itemValidator: nullableValidator(comparableValidator()))(activeSharedFolders7Day)
            self.activeSharedFolders7Day = activeSharedFolders7Day
            arrayValidator(itemValidator: nullableValidator(comparableValidator()))(activeSharedFolders1Day)
            self.activeSharedFolders1Day = activeSharedFolders1Day
            arrayValidator(itemValidator: nullableValidator(comparableValidator()))(sharedLinksCreated)
            self.sharedLinksCreated = sharedLinksCreated
            arrayValidator(itemValidator: nullableValidator(comparableValidator()))(sharedLinksViewedByTeam)
            self.sharedLinksViewedByTeam = sharedLinksViewedByTeam
            arrayValidator(itemValidator: nullableValidator(comparableValidator()))(sharedLinksViewedByOutsideUser)
            self.sharedLinksViewedByOutsideUser = sharedLinksViewedByOutsideUser
            arrayValidator(itemValidator: nullableValidator(comparableValidator()))(sharedLinksViewedByNotLoggedIn)
            self.sharedLinksViewedByNotLoggedIn = sharedLinksViewedByNotLoggedIn
            arrayValidator(itemValidator: nullableValidator(comparableValidator()))(sharedLinksViewedTotal)
            self.sharedLinksViewedTotal = sharedLinksViewedTotal
            super.init(startDate: startDate)
        }
        open override var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GetActivityReportSerializer().serialize(self)))"
        }
    }
    open class GetActivityReportSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GetActivityReport) -> JSON {
            let output = [
            "start_date": Serialization._StringSerializer.serialize(value.startDate),
            "adds": ArraySerializer(NullableSerializer(Serialization._UInt64Serializer)).serialize(value.adds),
            "edits": ArraySerializer(NullableSerializer(Serialization._UInt64Serializer)).serialize(value.edits),
            "deletes": ArraySerializer(NullableSerializer(Serialization._UInt64Serializer)).serialize(value.deletes),
            "active_users_28_day": ArraySerializer(NullableSerializer(Serialization._UInt64Serializer)).serialize(value.activeUsers28Day),
            "active_users_7_day": ArraySerializer(NullableSerializer(Serialization._UInt64Serializer)).serialize(value.activeUsers7Day),
            "active_users_1_day": ArraySerializer(NullableSerializer(Serialization._UInt64Serializer)).serialize(value.activeUsers1Day),
            "active_shared_folders_28_day": ArraySerializer(NullableSerializer(Serialization._UInt64Serializer)).serialize(value.activeSharedFolders28Day),
            "active_shared_folders_7_day": ArraySerializer(NullableSerializer(Serialization._UInt64Serializer)).serialize(value.activeSharedFolders7Day),
            "active_shared_folders_1_day": ArraySerializer(NullableSerializer(Serialization._UInt64Serializer)).serialize(value.activeSharedFolders1Day),
            "shared_links_created": ArraySerializer(NullableSerializer(Serialization._UInt64Serializer)).serialize(value.sharedLinksCreated),
            "shared_links_viewed_by_team": ArraySerializer(NullableSerializer(Serialization._UInt64Serializer)).serialize(value.sharedLinksViewedByTeam),
            "shared_links_viewed_by_outside_user": ArraySerializer(NullableSerializer(Serialization._UInt64Serializer)).serialize(value.sharedLinksViewedByOutsideUser),
            "shared_links_viewed_by_not_logged_in": ArraySerializer(NullableSerializer(Serialization._UInt64Serializer)).serialize(value.sharedLinksViewedByNotLoggedIn),
            "shared_links_viewed_total": ArraySerializer(NullableSerializer(Serialization._UInt64Serializer)).serialize(value.sharedLinksViewedTotal),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> GetActivityReport {
            switch json {
                case .dictionary(let dict):
                    let startDate = Serialization._StringSerializer.deserialize(dict["start_date"] ?? .null)
                    let adds = ArraySerializer(NullableSerializer(Serialization._UInt64Serializer)).deserialize(dict["adds"] ?? .null)
                    let edits = ArraySerializer(NullableSerializer(Serialization._UInt64Serializer)).deserialize(dict["edits"] ?? .null)
                    let deletes = ArraySerializer(NullableSerializer(Serialization._UInt64Serializer)).deserialize(dict["deletes"] ?? .null)
                    let activeUsers28Day = ArraySerializer(NullableSerializer(Serialization._UInt64Serializer)).deserialize(dict["active_users_28_day"] ?? .null)
                    let activeUsers7Day = ArraySerializer(NullableSerializer(Serialization._UInt64Serializer)).deserialize(dict["active_users_7_day"] ?? .null)
                    let activeUsers1Day = ArraySerializer(NullableSerializer(Serialization._UInt64Serializer)).deserialize(dict["active_users_1_day"] ?? .null)
                    let activeSharedFolders28Day = ArraySerializer(NullableSerializer(Serialization._UInt64Serializer)).deserialize(dict["active_shared_folders_28_day"] ?? .null)
                    let activeSharedFolders7Day = ArraySerializer(NullableSerializer(Serialization._UInt64Serializer)).deserialize(dict["active_shared_folders_7_day"] ?? .null)
                    let activeSharedFolders1Day = ArraySerializer(NullableSerializer(Serialization._UInt64Serializer)).deserialize(dict["active_shared_folders_1_day"] ?? .null)
                    let sharedLinksCreated = ArraySerializer(NullableSerializer(Serialization._UInt64Serializer)).deserialize(dict["shared_links_created"] ?? .null)
                    let sharedLinksViewedByTeam = ArraySerializer(NullableSerializer(Serialization._UInt64Serializer)).deserialize(dict["shared_links_viewed_by_team"] ?? .null)
                    let sharedLinksViewedByOutsideUser = ArraySerializer(NullableSerializer(Serialization._UInt64Serializer)).deserialize(dict["shared_links_viewed_by_outside_user"] ?? .null)
                    let sharedLinksViewedByNotLoggedIn = ArraySerializer(NullableSerializer(Serialization._UInt64Serializer)).deserialize(dict["shared_links_viewed_by_not_logged_in"] ?? .null)
                    let sharedLinksViewedTotal = ArraySerializer(NullableSerializer(Serialization._UInt64Serializer)).deserialize(dict["shared_links_viewed_total"] ?? .null)
                    return GetActivityReport(startDate: startDate, adds: adds, edits: edits, deletes: deletes, activeUsers28Day: activeUsers28Day, activeUsers7Day: activeUsers7Day, activeUsers1Day: activeUsers1Day, activeSharedFolders28Day: activeSharedFolders28Day, activeSharedFolders7Day: activeSharedFolders7Day, activeSharedFolders1Day: activeSharedFolders1Day, sharedLinksCreated: sharedLinksCreated, sharedLinksViewedByTeam: sharedLinksViewedByTeam, sharedLinksViewedByOutsideUser: sharedLinksViewedByOutsideUser, sharedLinksViewedByNotLoggedIn: sharedLinksViewedByNotLoggedIn, sharedLinksViewedTotal: sharedLinksViewedTotal)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Devices Report Result. Contains subsections for different time ranges of activity. Each of the items in each
    /// subsection of the storage report is an array of values, one value per day. If there is no data for a day, then
    /// the value will be None.
    open class GetDevicesReport: Team.BaseDfbReport {
        /// Report of the number of devices active in the last day.
        open let active1Day: Team.DevicesActive
        /// Report of the number of devices active in the last 7 days.
        open let active7Day: Team.DevicesActive
        /// Report of the number of devices active in the last 28 days.
        open let active28Day: Team.DevicesActive
        public init(startDate: String, active1Day: Team.DevicesActive, active7Day: Team.DevicesActive, active28Day: Team.DevicesActive) {
            self.active1Day = active1Day
            self.active7Day = active7Day
            self.active28Day = active28Day
            super.init(startDate: startDate)
        }
        open override var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GetDevicesReportSerializer().serialize(self)))"
        }
    }
    open class GetDevicesReportSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GetDevicesReport) -> JSON {
            let output = [
            "start_date": Serialization._StringSerializer.serialize(value.startDate),
            "active_1_day": Team.DevicesActiveSerializer().serialize(value.active1Day),
            "active_7_day": Team.DevicesActiveSerializer().serialize(value.active7Day),
            "active_28_day": Team.DevicesActiveSerializer().serialize(value.active28Day),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> GetDevicesReport {
            switch json {
                case .dictionary(let dict):
                    let startDate = Serialization._StringSerializer.deserialize(dict["start_date"] ?? .null)
                    let active1Day = Team.DevicesActiveSerializer().deserialize(dict["active_1_day"] ?? .null)
                    let active7Day = Team.DevicesActiveSerializer().deserialize(dict["active_7_day"] ?? .null)
                    let active28Day = Team.DevicesActiveSerializer().deserialize(dict["active_28_day"] ?? .null)
                    return GetDevicesReport(startDate: startDate, active1Day: active1Day, active7Day: active7Day, active28Day: active28Day)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Membership Report Result. Each of the items in the storage report is an array of values, one value per day. If
    /// there is no data for a day, then the value will be None.
    open class GetMembershipReport: Team.BaseDfbReport {
        /// Team size, for each day.
        open let teamSize: Array<UInt64?>
        /// The number of pending invites to the team, for each day.
        open let pendingInvites: Array<UInt64?>
        /// The number of members that joined the team, for each day.
        open let membersJoined: Array<UInt64?>
        /// The number of suspended team members, for each day.
        open let suspendedMembers: Array<UInt64?>
        /// The total number of licenses the team has, for each day.
        open let licenses: Array<UInt64?>
        public init(startDate: String, teamSize: Array<UInt64?>, pendingInvites: Array<UInt64?>, membersJoined: Array<UInt64?>, suspendedMembers: Array<UInt64?>, licenses: Array<UInt64?>) {
            arrayValidator(itemValidator: nullableValidator(comparableValidator()))(teamSize)
            self.teamSize = teamSize
            arrayValidator(itemValidator: nullableValidator(comparableValidator()))(pendingInvites)
            self.pendingInvites = pendingInvites
            arrayValidator(itemValidator: nullableValidator(comparableValidator()))(membersJoined)
            self.membersJoined = membersJoined
            arrayValidator(itemValidator: nullableValidator(comparableValidator()))(suspendedMembers)
            self.suspendedMembers = suspendedMembers
            arrayValidator(itemValidator: nullableValidator(comparableValidator()))(licenses)
            self.licenses = licenses
            super.init(startDate: startDate)
        }
        open override var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GetMembershipReportSerializer().serialize(self)))"
        }
    }
    open class GetMembershipReportSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GetMembershipReport) -> JSON {
            let output = [
            "start_date": Serialization._StringSerializer.serialize(value.startDate),
            "team_size": ArraySerializer(NullableSerializer(Serialization._UInt64Serializer)).serialize(value.teamSize),
            "pending_invites": ArraySerializer(NullableSerializer(Serialization._UInt64Serializer)).serialize(value.pendingInvites),
            "members_joined": ArraySerializer(NullableSerializer(Serialization._UInt64Serializer)).serialize(value.membersJoined),
            "suspended_members": ArraySerializer(NullableSerializer(Serialization._UInt64Serializer)).serialize(value.suspendedMembers),
            "licenses": ArraySerializer(NullableSerializer(Serialization._UInt64Serializer)).serialize(value.licenses),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> GetMembershipReport {
            switch json {
                case .dictionary(let dict):
                    let startDate = Serialization._StringSerializer.deserialize(dict["start_date"] ?? .null)
                    let teamSize = ArraySerializer(NullableSerializer(Serialization._UInt64Serializer)).deserialize(dict["team_size"] ?? .null)
                    let pendingInvites = ArraySerializer(NullableSerializer(Serialization._UInt64Serializer)).deserialize(dict["pending_invites"] ?? .null)
                    let membersJoined = ArraySerializer(NullableSerializer(Serialization._UInt64Serializer)).deserialize(dict["members_joined"] ?? .null)
                    let suspendedMembers = ArraySerializer(NullableSerializer(Serialization._UInt64Serializer)).deserialize(dict["suspended_members"] ?? .null)
                    let licenses = ArraySerializer(NullableSerializer(Serialization._UInt64Serializer)).deserialize(dict["licenses"] ?? .null)
                    return GetMembershipReport(startDate: startDate, teamSize: teamSize, pendingInvites: pendingInvites, membersJoined: membersJoined, suspendedMembers: suspendedMembers, licenses: licenses)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Storage Report Result. Each of the items in the storage report is an array of values, one value per day. If
    /// there is no data for a day, then the value will be None.
    open class GetStorageReport: Team.BaseDfbReport {
        /// Sum of the shared, unshared, and datastore usages, for each day.
        open let totalUsage: Array<UInt64?>
        /// Array of the combined size (bytes) of team members' shared folders, for each day.
        open let sharedUsage: Array<UInt64?>
        /// Array of the combined size (bytes) of team members' root namespaces, for each day.
        open let unsharedUsage: Array<UInt64?>
        /// Array of the number of shared folders owned by team members, for each day.
        open let sharedFolders: Array<UInt64?>
        /// Array of storage summaries of team members' account sizes. Each storage summary is an array of key, value
        /// pairs, where each pair describes a storage bucket. The key indicates the upper bound of the bucket and the
        /// value is the number of users in that bucket. There is one such summary per day. If there is no data for a
        /// day, the storage summary will be empty.
        open let memberStorageMap: Array<Array<Team.StorageBucket>>
        public init(startDate: String, totalUsage: Array<UInt64?>, sharedUsage: Array<UInt64?>, unsharedUsage: Array<UInt64?>, sharedFolders: Array<UInt64?>, memberStorageMap: Array<Array<Team.StorageBucket>>) {
            arrayValidator(itemValidator: nullableValidator(comparableValidator()))(totalUsage)
            self.totalUsage = totalUsage
            arrayValidator(itemValidator: nullableValidator(comparableValidator()))(sharedUsage)
            self.sharedUsage = sharedUsage
            arrayValidator(itemValidator: nullableValidator(comparableValidator()))(unsharedUsage)
            self.unsharedUsage = unsharedUsage
            arrayValidator(itemValidator: nullableValidator(comparableValidator()))(sharedFolders)
            self.sharedFolders = sharedFolders
            self.memberStorageMap = memberStorageMap
            super.init(startDate: startDate)
        }
        open override var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GetStorageReportSerializer().serialize(self)))"
        }
    }
    open class GetStorageReportSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GetStorageReport) -> JSON {
            let output = [
            "start_date": Serialization._StringSerializer.serialize(value.startDate),
            "total_usage": ArraySerializer(NullableSerializer(Serialization._UInt64Serializer)).serialize(value.totalUsage),
            "shared_usage": ArraySerializer(NullableSerializer(Serialization._UInt64Serializer)).serialize(value.sharedUsage),
            "unshared_usage": ArraySerializer(NullableSerializer(Serialization._UInt64Serializer)).serialize(value.unsharedUsage),
            "shared_folders": ArraySerializer(NullableSerializer(Serialization._UInt64Serializer)).serialize(value.sharedFolders),
            "member_storage_map": ArraySerializer(ArraySerializer(Team.StorageBucketSerializer())).serialize(value.memberStorageMap),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> GetStorageReport {
            switch json {
                case .dictionary(let dict):
                    let startDate = Serialization._StringSerializer.deserialize(dict["start_date"] ?? .null)
                    let totalUsage = ArraySerializer(NullableSerializer(Serialization._UInt64Serializer)).deserialize(dict["total_usage"] ?? .null)
                    let sharedUsage = ArraySerializer(NullableSerializer(Serialization._UInt64Serializer)).deserialize(dict["shared_usage"] ?? .null)
                    let unsharedUsage = ArraySerializer(NullableSerializer(Serialization._UInt64Serializer)).deserialize(dict["unshared_usage"] ?? .null)
                    let sharedFolders = ArraySerializer(NullableSerializer(Serialization._UInt64Serializer)).deserialize(dict["shared_folders"] ?? .null)
                    let memberStorageMap = ArraySerializer(ArraySerializer(Team.StorageBucketSerializer())).deserialize(dict["member_storage_map"] ?? .null)
                    return GetStorageReport(startDate: startDate, totalUsage: totalUsage, sharedUsage: sharedUsage, unsharedUsage: unsharedUsage, sharedFolders: sharedFolders, memberStorageMap: memberStorageMap)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Role of a user in group.
    public enum GroupAccessType: CustomStringConvertible {
        /// User is a member of the group, but has no special permissions.
        case member
        /// User can rename the group, and add/remove members.
        case owner

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GroupAccessTypeSerializer().serialize(self)))"
        }
    }
    open class GroupAccessTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GroupAccessType) -> JSON {
            switch value {
                case .member:
                    var d = [String: JSON]()
                    d[".tag"] = .str("member")
                    return .dictionary(d)
                case .owner:
                    var d = [String: JSON]()
                    d[".tag"] = .str("owner")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> GroupAccessType {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "member":
                            return GroupAccessType.member
                        case "owner":
                            return GroupAccessType.owner
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The GroupCreateArg struct
    open class GroupCreateArg: CustomStringConvertible {
        /// Group name.
        open let groupName: String
        /// The creator of a team can associate an arbitrary external ID to the group.
        open let groupExternalId: String?
        /// Whether the team can be managed by selected users, or only by team admins
        open let groupManagementType: TeamCommon.GroupManagementType?
        public init(groupName: String, groupExternalId: String? = nil, groupManagementType: TeamCommon.GroupManagementType? = nil) {
            stringValidator()(groupName)
            self.groupName = groupName
            nullableValidator(stringValidator())(groupExternalId)
            self.groupExternalId = groupExternalId
            self.groupManagementType = groupManagementType
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GroupCreateArgSerializer().serialize(self)))"
        }
    }
    open class GroupCreateArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GroupCreateArg) -> JSON {
            let output = [
            "group_name": Serialization._StringSerializer.serialize(value.groupName),
            "group_external_id": NullableSerializer(Serialization._StringSerializer).serialize(value.groupExternalId),
            "group_management_type": NullableSerializer(TeamCommon.GroupManagementTypeSerializer()).serialize(value.groupManagementType),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> GroupCreateArg {
            switch json {
                case .dictionary(let dict):
                    let groupName = Serialization._StringSerializer.deserialize(dict["group_name"] ?? .null)
                    let groupExternalId = NullableSerializer(Serialization._StringSerializer).deserialize(dict["group_external_id"] ?? .null)
                    let groupManagementType = NullableSerializer(TeamCommon.GroupManagementTypeSerializer()).deserialize(dict["group_management_type"] ?? .null)
                    return GroupCreateArg(groupName: groupName, groupExternalId: groupExternalId, groupManagementType: groupManagementType)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The GroupCreateError union
    public enum GroupCreateError: CustomStringConvertible {
        /// There is already an existing group with the requested name.
        case groupNameAlreadyUsed
        /// Group name is empty or has invalid characters.
        case groupNameInvalid
        /// The new external ID is already being used by another group.
        case externalIdAlreadyInUse
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GroupCreateErrorSerializer().serialize(self)))"
        }
    }
    open class GroupCreateErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GroupCreateError) -> JSON {
            switch value {
                case .groupNameAlreadyUsed:
                    var d = [String: JSON]()
                    d[".tag"] = .str("group_name_already_used")
                    return .dictionary(d)
                case .groupNameInvalid:
                    var d = [String: JSON]()
                    d[".tag"] = .str("group_name_invalid")
                    return .dictionary(d)
                case .externalIdAlreadyInUse:
                    var d = [String: JSON]()
                    d[".tag"] = .str("external_id_already_in_use")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> GroupCreateError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "group_name_already_used":
                            return GroupCreateError.groupNameAlreadyUsed
                        case "group_name_invalid":
                            return GroupCreateError.groupNameInvalid
                        case "external_id_already_in_use":
                            return GroupCreateError.externalIdAlreadyInUse
                        case "other":
                            return GroupCreateError.other
                        default:
                            return GroupCreateError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Error that can be raised when GroupSelector is used.
    public enum GroupSelectorError: CustomStringConvertible {
        /// No matching group found. No groups match the specified group ID.
        case groupNotFound
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GroupSelectorErrorSerializer().serialize(self)))"
        }
    }
    open class GroupSelectorErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GroupSelectorError) -> JSON {
            switch value {
                case .groupNotFound:
                    var d = [String: JSON]()
                    d[".tag"] = .str("group_not_found")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> GroupSelectorError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "group_not_found":
                            return GroupSelectorError.groupNotFound
                        case "other":
                            return GroupSelectorError.other
                        default:
                            return GroupSelectorError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The GroupDeleteError union
    public enum GroupDeleteError: CustomStringConvertible {
        /// No matching group found. No groups match the specified group ID.
        case groupNotFound
        /// An unspecified error.
        case other
        /// This group has already been deleted.
        case groupAlreadyDeleted

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GroupDeleteErrorSerializer().serialize(self)))"
        }
    }
    open class GroupDeleteErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GroupDeleteError) -> JSON {
            switch value {
                case .groupNotFound:
                    var d = [String: JSON]()
                    d[".tag"] = .str("group_not_found")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
                case .groupAlreadyDeleted:
                    var d = [String: JSON]()
                    d[".tag"] = .str("group_already_deleted")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> GroupDeleteError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "group_not_found":
                            return GroupDeleteError.groupNotFound
                        case "other":
                            return GroupDeleteError.other
                        case "group_already_deleted":
                            return GroupDeleteError.groupAlreadyDeleted
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Full description of a group.
    open class GroupFullInfo: TeamCommon.GroupSummary {
        /// List of group members.
        open let members: Array<Team.GroupMemberInfo>?
        /// The group creation time as a UTC timestamp in milliseconds since the Unix epoch.
        open let created: UInt64
        public init(groupName: String, groupId: String, groupManagementType: TeamCommon.GroupManagementType, created: UInt64, groupExternalId: String? = nil, memberCount: UInt32? = nil, members: Array<Team.GroupMemberInfo>? = nil) {
            self.members = members
            comparableValidator()(created)
            self.created = created
            super.init(groupName: groupName, groupId: groupId, groupManagementType: groupManagementType, groupExternalId: groupExternalId, memberCount: memberCount)
        }
        open override var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GroupFullInfoSerializer().serialize(self)))"
        }
    }
    open class GroupFullInfoSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GroupFullInfo) -> JSON {
            let output = [
            "group_name": Serialization._StringSerializer.serialize(value.groupName),
            "group_id": Serialization._StringSerializer.serialize(value.groupId),
            "group_management_type": TeamCommon.GroupManagementTypeSerializer().serialize(value.groupManagementType),
            "created": Serialization._UInt64Serializer.serialize(value.created),
            "group_external_id": NullableSerializer(Serialization._StringSerializer).serialize(value.groupExternalId),
            "member_count": NullableSerializer(Serialization._UInt32Serializer).serialize(value.memberCount),
            "members": NullableSerializer(ArraySerializer(Team.GroupMemberInfoSerializer())).serialize(value.members),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> GroupFullInfo {
            switch json {
                case .dictionary(let dict):
                    let groupName = Serialization._StringSerializer.deserialize(dict["group_name"] ?? .null)
                    let groupId = Serialization._StringSerializer.deserialize(dict["group_id"] ?? .null)
                    let groupManagementType = TeamCommon.GroupManagementTypeSerializer().deserialize(dict["group_management_type"] ?? .null)
                    let created = Serialization._UInt64Serializer.deserialize(dict["created"] ?? .null)
                    let groupExternalId = NullableSerializer(Serialization._StringSerializer).deserialize(dict["group_external_id"] ?? .null)
                    let memberCount = NullableSerializer(Serialization._UInt32Serializer).deserialize(dict["member_count"] ?? .null)
                    let members = NullableSerializer(ArraySerializer(Team.GroupMemberInfoSerializer())).deserialize(dict["members"] ?? .null)
                    return GroupFullInfo(groupName: groupName, groupId: groupId, groupManagementType: groupManagementType, created: created, groupExternalId: groupExternalId, memberCount: memberCount, members: members)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Profile of group member, and role in group.
    open class GroupMemberInfo: CustomStringConvertible {
        /// Profile of group member.
        open let profile: Team.MemberProfile
        /// The role that the user has in the group.
        open let accessType: Team.GroupAccessType
        public init(profile: Team.MemberProfile, accessType: Team.GroupAccessType) {
            self.profile = profile
            self.accessType = accessType
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GroupMemberInfoSerializer().serialize(self)))"
        }
    }
    open class GroupMemberInfoSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GroupMemberInfo) -> JSON {
            let output = [
            "profile": Team.MemberProfileSerializer().serialize(value.profile),
            "access_type": Team.GroupAccessTypeSerializer().serialize(value.accessType),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> GroupMemberInfo {
            switch json {
                case .dictionary(let dict):
                    let profile = Team.MemberProfileSerializer().deserialize(dict["profile"] ?? .null)
                    let accessType = Team.GroupAccessTypeSerializer().deserialize(dict["access_type"] ?? .null)
                    return GroupMemberInfo(profile: profile, accessType: accessType)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Argument for selecting a group and a single user.
    open class GroupMemberSelector: CustomStringConvertible {
        /// Specify a group.
        open let group: Team.GroupSelector
        /// Identity of a user that is a member of group.
        open let user: Team.UserSelectorArg
        public init(group: Team.GroupSelector, user: Team.UserSelectorArg) {
            self.group = group
            self.user = user
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GroupMemberSelectorSerializer().serialize(self)))"
        }
    }
    open class GroupMemberSelectorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GroupMemberSelector) -> JSON {
            let output = [
            "group": Team.GroupSelectorSerializer().serialize(value.group),
            "user": Team.UserSelectorArgSerializer().serialize(value.user),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> GroupMemberSelector {
            switch json {
                case .dictionary(let dict):
                    let group = Team.GroupSelectorSerializer().deserialize(dict["group"] ?? .null)
                    let user = Team.UserSelectorArgSerializer().deserialize(dict["user"] ?? .null)
                    return GroupMemberSelector(group: group, user: user)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Error that can be raised when GroupMemberSelector is used, and the user is required to be a member of the
    /// specified group.
    public enum GroupMemberSelectorError: CustomStringConvertible {
        /// No matching group found. No groups match the specified group ID.
        case groupNotFound
        /// An unspecified error.
        case other
        /// The specified user is not a member of this group.
        case memberNotInGroup

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GroupMemberSelectorErrorSerializer().serialize(self)))"
        }
    }
    open class GroupMemberSelectorErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GroupMemberSelectorError) -> JSON {
            switch value {
                case .groupNotFound:
                    var d = [String: JSON]()
                    d[".tag"] = .str("group_not_found")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
                case .memberNotInGroup:
                    var d = [String: JSON]()
                    d[".tag"] = .str("member_not_in_group")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> GroupMemberSelectorError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "group_not_found":
                            return GroupMemberSelectorError.groupNotFound
                        case "other":
                            return GroupMemberSelectorError.other
                        case "member_not_in_group":
                            return GroupMemberSelectorError.memberNotInGroup
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The GroupMemberSetAccessTypeError union
    public enum GroupMemberSetAccessTypeError: CustomStringConvertible {
        /// No matching group found. No groups match the specified group ID.
        case groupNotFound
        /// An unspecified error.
        case other
        /// The specified user is not a member of this group.
        case memberNotInGroup
        /// A company managed group cannot be managed by a user.
        case userCannotBeManagerOfCompanyManagedGroup

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GroupMemberSetAccessTypeErrorSerializer().serialize(self)))"
        }
    }
    open class GroupMemberSetAccessTypeErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GroupMemberSetAccessTypeError) -> JSON {
            switch value {
                case .groupNotFound:
                    var d = [String: JSON]()
                    d[".tag"] = .str("group_not_found")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
                case .memberNotInGroup:
                    var d = [String: JSON]()
                    d[".tag"] = .str("member_not_in_group")
                    return .dictionary(d)
                case .userCannotBeManagerOfCompanyManagedGroup:
                    var d = [String: JSON]()
                    d[".tag"] = .str("user_cannot_be_manager_of_company_managed_group")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> GroupMemberSetAccessTypeError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "group_not_found":
                            return GroupMemberSetAccessTypeError.groupNotFound
                        case "other":
                            return GroupMemberSetAccessTypeError.other
                        case "member_not_in_group":
                            return GroupMemberSetAccessTypeError.memberNotInGroup
                        case "user_cannot_be_manager_of_company_managed_group":
                            return GroupMemberSetAccessTypeError.userCannotBeManagerOfCompanyManagedGroup
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The IncludeMembersArg struct
    open class IncludeMembersArg: CustomStringConvertible {
        /// Whether to return the list of members in the group.  Note that the default value will cause all the group
        /// members  to be returned in the response. This may take a long time for large groups.
        open let returnMembers: Bool
        public init(returnMembers: Bool = true) {
            self.returnMembers = returnMembers
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(IncludeMembersArgSerializer().serialize(self)))"
        }
    }
    open class IncludeMembersArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: IncludeMembersArg) -> JSON {
            let output = [
            "return_members": Serialization._BoolSerializer.serialize(value.returnMembers),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> IncludeMembersArg {
            switch json {
                case .dictionary(let dict):
                    let returnMembers = Serialization._BoolSerializer.deserialize(dict["return_members"] ?? .number(1))
                    return IncludeMembersArg(returnMembers: returnMembers)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The GroupMembersAddArg struct
    open class GroupMembersAddArg: Team.IncludeMembersArg {
        /// Group to which users will be added.
        open let group: Team.GroupSelector
        /// List of users to be added to the group.
        open let members: Array<Team.MemberAccess>
        public init(group: Team.GroupSelector, members: Array<Team.MemberAccess>, returnMembers: Bool = true) {
            self.group = group
            self.members = members
            super.init(returnMembers: returnMembers)
        }
        open override var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GroupMembersAddArgSerializer().serialize(self)))"
        }
    }
    open class GroupMembersAddArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GroupMembersAddArg) -> JSON {
            let output = [
            "group": Team.GroupSelectorSerializer().serialize(value.group),
            "members": ArraySerializer(Team.MemberAccessSerializer()).serialize(value.members),
            "return_members": Serialization._BoolSerializer.serialize(value.returnMembers),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> GroupMembersAddArg {
            switch json {
                case .dictionary(let dict):
                    let group = Team.GroupSelectorSerializer().deserialize(dict["group"] ?? .null)
                    let members = ArraySerializer(Team.MemberAccessSerializer()).deserialize(dict["members"] ?? .null)
                    let returnMembers = Serialization._BoolSerializer.deserialize(dict["return_members"] ?? .number(1))
                    return GroupMembersAddArg(group: group, members: members, returnMembers: returnMembers)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The GroupMembersAddError union
    public enum GroupMembersAddError: CustomStringConvertible {
        /// No matching group found. No groups match the specified group ID.
        case groupNotFound
        /// An unspecified error.
        case other
        /// You cannot add duplicate users. One or more of the members you are trying to add is already a member of the
        /// group.
        case duplicateUser
        /// Group is not in this team. You cannot add members to a group that is outside of your team.
        case groupNotInTeam
        /// These members are not part of your team. Currently, you cannot add members to a group if they are not part
        /// of your team, though this may change in a subsequent version. To add new members to your Dropbox Business
        /// team, use the membersAdd endpoint.
        case membersNotInTeam(Array<String>)
        /// These users were not found in Dropbox.
        case usersNotFound(Array<String>)
        /// A suspended user cannot be added to a group as owner in GroupAccessType.
        case userMustBeActiveToBeOwner
        /// A company-managed group cannot be managed by a user.
        case userCannotBeManagerOfCompanyManagedGroup(Array<String>)

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GroupMembersAddErrorSerializer().serialize(self)))"
        }
    }
    open class GroupMembersAddErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GroupMembersAddError) -> JSON {
            switch value {
                case .groupNotFound:
                    var d = [String: JSON]()
                    d[".tag"] = .str("group_not_found")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
                case .duplicateUser:
                    var d = [String: JSON]()
                    d[".tag"] = .str("duplicate_user")
                    return .dictionary(d)
                case .groupNotInTeam:
                    var d = [String: JSON]()
                    d[".tag"] = .str("group_not_in_team")
                    return .dictionary(d)
                case .membersNotInTeam(let arg):
                    var d = ["members_not_in_team": ArraySerializer(Serialization._StringSerializer).serialize(arg)]
                    d[".tag"] = .str("members_not_in_team")
                    return .dictionary(d)
                case .usersNotFound(let arg):
                    var d = ["users_not_found": ArraySerializer(Serialization._StringSerializer).serialize(arg)]
                    d[".tag"] = .str("users_not_found")
                    return .dictionary(d)
                case .userMustBeActiveToBeOwner:
                    var d = [String: JSON]()
                    d[".tag"] = .str("user_must_be_active_to_be_owner")
                    return .dictionary(d)
                case .userCannotBeManagerOfCompanyManagedGroup(let arg):
                    var d = ["user_cannot_be_manager_of_company_managed_group": ArraySerializer(Serialization._StringSerializer).serialize(arg)]
                    d[".tag"] = .str("user_cannot_be_manager_of_company_managed_group")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> GroupMembersAddError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "group_not_found":
                            return GroupMembersAddError.groupNotFound
                        case "other":
                            return GroupMembersAddError.other
                        case "duplicate_user":
                            return GroupMembersAddError.duplicateUser
                        case "group_not_in_team":
                            return GroupMembersAddError.groupNotInTeam
                        case "members_not_in_team":
                            let v = ArraySerializer(Serialization._StringSerializer).deserialize(d["members_not_in_team"] ?? .null)
                            return GroupMembersAddError.membersNotInTeam(v)
                        case "users_not_found":
                            let v = ArraySerializer(Serialization._StringSerializer).deserialize(d["users_not_found"] ?? .null)
                            return GroupMembersAddError.usersNotFound(v)
                        case "user_must_be_active_to_be_owner":
                            return GroupMembersAddError.userMustBeActiveToBeOwner
                        case "user_cannot_be_manager_of_company_managed_group":
                            let v = ArraySerializer(Serialization._StringSerializer).deserialize(d["user_cannot_be_manager_of_company_managed_group"] ?? .null)
                            return GroupMembersAddError.userCannotBeManagerOfCompanyManagedGroup(v)
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Result returned by groupsMembersAdd and groupsMembersRemove.
    open class GroupMembersChangeResult: CustomStringConvertible {
        /// The group info after member change operation has been performed.
        open let groupInfo: Team.GroupFullInfo
        /// An ID that can be used to obtain the status of granting/revoking group-owned resources.
        open let asyncJobId: String
        public init(groupInfo: Team.GroupFullInfo, asyncJobId: String) {
            self.groupInfo = groupInfo
            stringValidator(minLength: 1)(asyncJobId)
            self.asyncJobId = asyncJobId
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GroupMembersChangeResultSerializer().serialize(self)))"
        }
    }
    open class GroupMembersChangeResultSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GroupMembersChangeResult) -> JSON {
            let output = [
            "group_info": Team.GroupFullInfoSerializer().serialize(value.groupInfo),
            "async_job_id": Serialization._StringSerializer.serialize(value.asyncJobId),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> GroupMembersChangeResult {
            switch json {
                case .dictionary(let dict):
                    let groupInfo = Team.GroupFullInfoSerializer().deserialize(dict["group_info"] ?? .null)
                    let asyncJobId = Serialization._StringSerializer.deserialize(dict["async_job_id"] ?? .null)
                    return GroupMembersChangeResult(groupInfo: groupInfo, asyncJobId: asyncJobId)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The GroupMembersRemoveArg struct
    open class GroupMembersRemoveArg: Team.IncludeMembersArg {
        /// Group from which users will be removed.
        open let group: Team.GroupSelector
        /// List of users to be removed from the group.
        open let users: Array<Team.UserSelectorArg>
        public init(group: Team.GroupSelector, users: Array<Team.UserSelectorArg>, returnMembers: Bool = true) {
            self.group = group
            self.users = users
            super.init(returnMembers: returnMembers)
        }
        open override var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GroupMembersRemoveArgSerializer().serialize(self)))"
        }
    }
    open class GroupMembersRemoveArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GroupMembersRemoveArg) -> JSON {
            let output = [
            "group": Team.GroupSelectorSerializer().serialize(value.group),
            "users": ArraySerializer(Team.UserSelectorArgSerializer()).serialize(value.users),
            "return_members": Serialization._BoolSerializer.serialize(value.returnMembers),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> GroupMembersRemoveArg {
            switch json {
                case .dictionary(let dict):
                    let group = Team.GroupSelectorSerializer().deserialize(dict["group"] ?? .null)
                    let users = ArraySerializer(Team.UserSelectorArgSerializer()).deserialize(dict["users"] ?? .null)
                    let returnMembers = Serialization._BoolSerializer.deserialize(dict["return_members"] ?? .number(1))
                    return GroupMembersRemoveArg(group: group, users: users, returnMembers: returnMembers)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Error that can be raised when GroupMembersSelector is used, and the users are required to be members of the
    /// specified group.
    public enum GroupMembersSelectorError: CustomStringConvertible {
        /// No matching group found. No groups match the specified group ID.
        case groupNotFound
        /// An unspecified error.
        case other
        /// At least one of the specified users is not a member of the group.
        case memberNotInGroup

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GroupMembersSelectorErrorSerializer().serialize(self)))"
        }
    }
    open class GroupMembersSelectorErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GroupMembersSelectorError) -> JSON {
            switch value {
                case .groupNotFound:
                    var d = [String: JSON]()
                    d[".tag"] = .str("group_not_found")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
                case .memberNotInGroup:
                    var d = [String: JSON]()
                    d[".tag"] = .str("member_not_in_group")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> GroupMembersSelectorError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "group_not_found":
                            return GroupMembersSelectorError.groupNotFound
                        case "other":
                            return GroupMembersSelectorError.other
                        case "member_not_in_group":
                            return GroupMembersSelectorError.memberNotInGroup
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The GroupMembersRemoveError union
    public enum GroupMembersRemoveError: CustomStringConvertible {
        /// No matching group found. No groups match the specified group ID.
        case groupNotFound
        /// An unspecified error.
        case other
        /// At least one of the specified users is not a member of the group.
        case memberNotInGroup
        /// Group is not in this team. You cannot remove members from a group that is outside of your team.
        case groupNotInTeam

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GroupMembersRemoveErrorSerializer().serialize(self)))"
        }
    }
    open class GroupMembersRemoveErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GroupMembersRemoveError) -> JSON {
            switch value {
                case .groupNotFound:
                    var d = [String: JSON]()
                    d[".tag"] = .str("group_not_found")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
                case .memberNotInGroup:
                    var d = [String: JSON]()
                    d[".tag"] = .str("member_not_in_group")
                    return .dictionary(d)
                case .groupNotInTeam:
                    var d = [String: JSON]()
                    d[".tag"] = .str("group_not_in_team")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> GroupMembersRemoveError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "group_not_found":
                            return GroupMembersRemoveError.groupNotFound
                        case "other":
                            return GroupMembersRemoveError.other
                        case "member_not_in_group":
                            return GroupMembersRemoveError.memberNotInGroup
                        case "group_not_in_team":
                            return GroupMembersRemoveError.groupNotInTeam
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Argument for selecting a group and a list of users.
    open class GroupMembersSelector: CustomStringConvertible {
        /// Specify a group.
        open let group: Team.GroupSelector
        /// A list of users that are members of group.
        open let users: Team.UsersSelectorArg
        public init(group: Team.GroupSelector, users: Team.UsersSelectorArg) {
            self.group = group
            self.users = users
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GroupMembersSelectorSerializer().serialize(self)))"
        }
    }
    open class GroupMembersSelectorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GroupMembersSelector) -> JSON {
            let output = [
            "group": Team.GroupSelectorSerializer().serialize(value.group),
            "users": Team.UsersSelectorArgSerializer().serialize(value.users),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> GroupMembersSelector {
            switch json {
                case .dictionary(let dict):
                    let group = Team.GroupSelectorSerializer().deserialize(dict["group"] ?? .null)
                    let users = Team.UsersSelectorArgSerializer().deserialize(dict["users"] ?? .null)
                    return GroupMembersSelector(group: group, users: users)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The GroupMembersSetAccessTypeArg struct
    open class GroupMembersSetAccessTypeArg: Team.GroupMemberSelector {
        /// New group access type the user will have.
        open let accessType: Team.GroupAccessType
        /// Whether to return the list of members in the group.  Note that the default value will cause all the group
        /// members  to be returned in the response. This may take a long time for large groups.
        open let returnMembers: Bool
        public init(group: Team.GroupSelector, user: Team.UserSelectorArg, accessType: Team.GroupAccessType, returnMembers: Bool = true) {
            self.accessType = accessType
            self.returnMembers = returnMembers
            super.init(group: group, user: user)
        }
        open override var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GroupMembersSetAccessTypeArgSerializer().serialize(self)))"
        }
    }
    open class GroupMembersSetAccessTypeArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GroupMembersSetAccessTypeArg) -> JSON {
            let output = [
            "group": Team.GroupSelectorSerializer().serialize(value.group),
            "user": Team.UserSelectorArgSerializer().serialize(value.user),
            "access_type": Team.GroupAccessTypeSerializer().serialize(value.accessType),
            "return_members": Serialization._BoolSerializer.serialize(value.returnMembers),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> GroupMembersSetAccessTypeArg {
            switch json {
                case .dictionary(let dict):
                    let group = Team.GroupSelectorSerializer().deserialize(dict["group"] ?? .null)
                    let user = Team.UserSelectorArgSerializer().deserialize(dict["user"] ?? .null)
                    let accessType = Team.GroupAccessTypeSerializer().deserialize(dict["access_type"] ?? .null)
                    let returnMembers = Serialization._BoolSerializer.deserialize(dict["return_members"] ?? .number(1))
                    return GroupMembersSetAccessTypeArg(group: group, user: user, accessType: accessType, returnMembers: returnMembers)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Argument for selecting a single group, either by group_id or by external group ID.
    public enum GroupSelector: CustomStringConvertible {
        /// Group ID.
        case groupId(String)
        /// External ID of the group.
        case groupExternalId(String)

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GroupSelectorSerializer().serialize(self)))"
        }
    }
    open class GroupSelectorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GroupSelector) -> JSON {
            switch value {
                case .groupId(let arg):
                    var d = ["group_id": Serialization._StringSerializer.serialize(arg)]
                    d[".tag"] = .str("group_id")
                    return .dictionary(d)
                case .groupExternalId(let arg):
                    var d = ["group_external_id": Serialization._StringSerializer.serialize(arg)]
                    d[".tag"] = .str("group_external_id")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> GroupSelector {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "group_id":
                            let v = Serialization._StringSerializer.deserialize(d["group_id"] ?? .null)
                            return GroupSelector.groupId(v)
                        case "group_external_id":
                            let v = Serialization._StringSerializer.deserialize(d["group_external_id"] ?? .null)
                            return GroupSelector.groupExternalId(v)
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The GroupUpdateArgs struct
    open class GroupUpdateArgs: Team.IncludeMembersArg {
        /// Specify a group.
        open let group: Team.GroupSelector
        /// Optional argument. Set group name to this if provided.
        open let newGroupName: String?
        /// Optional argument. New group external ID. If the argument is None, the group's external_id won't be updated.
        /// If the argument is empty string, the group's external id will be cleared.
        open let newGroupExternalId: String?
        /// Set new group management type, if provided.
        open let newGroupManagementType: TeamCommon.GroupManagementType?
        public init(group: Team.GroupSelector, returnMembers: Bool = true, newGroupName: String? = nil, newGroupExternalId: String? = nil, newGroupManagementType: TeamCommon.GroupManagementType? = nil) {
            self.group = group
            nullableValidator(stringValidator())(newGroupName)
            self.newGroupName = newGroupName
            nullableValidator(stringValidator())(newGroupExternalId)
            self.newGroupExternalId = newGroupExternalId
            self.newGroupManagementType = newGroupManagementType
            super.init(returnMembers: returnMembers)
        }
        open override var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GroupUpdateArgsSerializer().serialize(self)))"
        }
    }
    open class GroupUpdateArgsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GroupUpdateArgs) -> JSON {
            let output = [
            "group": Team.GroupSelectorSerializer().serialize(value.group),
            "return_members": Serialization._BoolSerializer.serialize(value.returnMembers),
            "new_group_name": NullableSerializer(Serialization._StringSerializer).serialize(value.newGroupName),
            "new_group_external_id": NullableSerializer(Serialization._StringSerializer).serialize(value.newGroupExternalId),
            "new_group_management_type": NullableSerializer(TeamCommon.GroupManagementTypeSerializer()).serialize(value.newGroupManagementType),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> GroupUpdateArgs {
            switch json {
                case .dictionary(let dict):
                    let group = Team.GroupSelectorSerializer().deserialize(dict["group"] ?? .null)
                    let returnMembers = Serialization._BoolSerializer.deserialize(dict["return_members"] ?? .number(1))
                    let newGroupName = NullableSerializer(Serialization._StringSerializer).deserialize(dict["new_group_name"] ?? .null)
                    let newGroupExternalId = NullableSerializer(Serialization._StringSerializer).deserialize(dict["new_group_external_id"] ?? .null)
                    let newGroupManagementType = NullableSerializer(TeamCommon.GroupManagementTypeSerializer()).deserialize(dict["new_group_management_type"] ?? .null)
                    return GroupUpdateArgs(group: group, returnMembers: returnMembers, newGroupName: newGroupName, newGroupExternalId: newGroupExternalId, newGroupManagementType: newGroupManagementType)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The GroupUpdateError union
    public enum GroupUpdateError: CustomStringConvertible {
        /// No matching group found. No groups match the specified group ID.
        case groupNotFound
        /// An unspecified error.
        case other
        /// The new external ID is already being used by another group.
        case externalIdAlreadyInUse

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GroupUpdateErrorSerializer().serialize(self)))"
        }
    }
    open class GroupUpdateErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GroupUpdateError) -> JSON {
            switch value {
                case .groupNotFound:
                    var d = [String: JSON]()
                    d[".tag"] = .str("group_not_found")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
                case .externalIdAlreadyInUse:
                    var d = [String: JSON]()
                    d[".tag"] = .str("external_id_already_in_use")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> GroupUpdateError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "group_not_found":
                            return GroupUpdateError.groupNotFound
                        case "other":
                            return GroupUpdateError.other
                        case "external_id_already_in_use":
                            return GroupUpdateError.externalIdAlreadyInUse
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The GroupsGetInfoError union
    public enum GroupsGetInfoError: CustomStringConvertible {
        /// The group is not on your team.
        case groupNotOnTeam
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GroupsGetInfoErrorSerializer().serialize(self)))"
        }
    }
    open class GroupsGetInfoErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GroupsGetInfoError) -> JSON {
            switch value {
                case .groupNotOnTeam:
                    var d = [String: JSON]()
                    d[".tag"] = .str("group_not_on_team")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> GroupsGetInfoError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "group_not_on_team":
                            return GroupsGetInfoError.groupNotOnTeam
                        case "other":
                            return GroupsGetInfoError.other
                        default:
                            return GroupsGetInfoError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The GroupsGetInfoItem union
    public enum GroupsGetInfoItem: CustomStringConvertible {
        /// An ID that was provided as a parameter to groupsGetInfo, and did not match a corresponding group. The ID can
        /// be a group ID, or an external ID, depending on how the method was called.
        case idNotFound(String)
        /// Info about a group.
        case groupInfo(Team.GroupFullInfo)

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GroupsGetInfoItemSerializer().serialize(self)))"
        }
    }
    open class GroupsGetInfoItemSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GroupsGetInfoItem) -> JSON {
            switch value {
                case .idNotFound(let arg):
                    var d = ["id_not_found": Serialization._StringSerializer.serialize(arg)]
                    d[".tag"] = .str("id_not_found")
                    return .dictionary(d)
                case .groupInfo(let arg):
                    var d = Serialization.getFields(Team.GroupFullInfoSerializer().serialize(arg))
                    d[".tag"] = .str("group_info")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> GroupsGetInfoItem {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "id_not_found":
                            let v = Serialization._StringSerializer.deserialize(d["id_not_found"] ?? .null)
                            return GroupsGetInfoItem.idNotFound(v)
                        case "group_info":
                            let v = Team.GroupFullInfoSerializer().deserialize(json)
                            return GroupsGetInfoItem.groupInfo(v)
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The GroupsListArg struct
    open class GroupsListArg: CustomStringConvertible {
        /// Number of results to return per call.
        open let limit: UInt32
        public init(limit: UInt32 = 1000) {
            comparableValidator(minValue: 1, maxValue: 1000)(limit)
            self.limit = limit
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GroupsListArgSerializer().serialize(self)))"
        }
    }
    open class GroupsListArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GroupsListArg) -> JSON {
            let output = [
            "limit": Serialization._UInt32Serializer.serialize(value.limit),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> GroupsListArg {
            switch json {
                case .dictionary(let dict):
                    let limit = Serialization._UInt32Serializer.deserialize(dict["limit"] ?? .number(1000))
                    return GroupsListArg(limit: limit)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The GroupsListContinueArg struct
    open class GroupsListContinueArg: CustomStringConvertible {
        /// Indicates from what point to get the next set of groups.
        open let cursor: String
        public init(cursor: String) {
            stringValidator()(cursor)
            self.cursor = cursor
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GroupsListContinueArgSerializer().serialize(self)))"
        }
    }
    open class GroupsListContinueArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GroupsListContinueArg) -> JSON {
            let output = [
            "cursor": Serialization._StringSerializer.serialize(value.cursor),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> GroupsListContinueArg {
            switch json {
                case .dictionary(let dict):
                    let cursor = Serialization._StringSerializer.deserialize(dict["cursor"] ?? .null)
                    return GroupsListContinueArg(cursor: cursor)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The GroupsListContinueError union
    public enum GroupsListContinueError: CustomStringConvertible {
        /// The cursor is invalid.
        case invalidCursor
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GroupsListContinueErrorSerializer().serialize(self)))"
        }
    }
    open class GroupsListContinueErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GroupsListContinueError) -> JSON {
            switch value {
                case .invalidCursor:
                    var d = [String: JSON]()
                    d[".tag"] = .str("invalid_cursor")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> GroupsListContinueError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "invalid_cursor":
                            return GroupsListContinueError.invalidCursor
                        case "other":
                            return GroupsListContinueError.other
                        default:
                            return GroupsListContinueError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The GroupsListResult struct
    open class GroupsListResult: CustomStringConvertible {
        /// (no description)
        open let groups: Array<TeamCommon.GroupSummary>
        /// Pass the cursor into groupsListContinue to obtain the additional groups.
        open let cursor: String
        /// Is true if there are additional groups that have not been returned yet. An additional call to
        /// groupsListContinue can retrieve them.
        open let hasMore: Bool
        public init(groups: Array<TeamCommon.GroupSummary>, cursor: String, hasMore: Bool) {
            self.groups = groups
            stringValidator()(cursor)
            self.cursor = cursor
            self.hasMore = hasMore
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GroupsListResultSerializer().serialize(self)))"
        }
    }
    open class GroupsListResultSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GroupsListResult) -> JSON {
            let output = [
            "groups": ArraySerializer(TeamCommon.GroupSummarySerializer()).serialize(value.groups),
            "cursor": Serialization._StringSerializer.serialize(value.cursor),
            "has_more": Serialization._BoolSerializer.serialize(value.hasMore),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> GroupsListResult {
            switch json {
                case .dictionary(let dict):
                    let groups = ArraySerializer(TeamCommon.GroupSummarySerializer()).deserialize(dict["groups"] ?? .null)
                    let cursor = Serialization._StringSerializer.deserialize(dict["cursor"] ?? .null)
                    let hasMore = Serialization._BoolSerializer.deserialize(dict["has_more"] ?? .null)
                    return GroupsListResult(groups: groups, cursor: cursor, hasMore: hasMore)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The GroupsMembersListArg struct
    open class GroupsMembersListArg: CustomStringConvertible {
        /// The group whose members are to be listed.
        open let group: Team.GroupSelector
        /// Number of results to return per call.
        open let limit: UInt32
        public init(group: Team.GroupSelector, limit: UInt32 = 1000) {
            self.group = group
            comparableValidator(minValue: 1, maxValue: 1000)(limit)
            self.limit = limit
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GroupsMembersListArgSerializer().serialize(self)))"
        }
    }
    open class GroupsMembersListArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GroupsMembersListArg) -> JSON {
            let output = [
            "group": Team.GroupSelectorSerializer().serialize(value.group),
            "limit": Serialization._UInt32Serializer.serialize(value.limit),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> GroupsMembersListArg {
            switch json {
                case .dictionary(let dict):
                    let group = Team.GroupSelectorSerializer().deserialize(dict["group"] ?? .null)
                    let limit = Serialization._UInt32Serializer.deserialize(dict["limit"] ?? .number(1000))
                    return GroupsMembersListArg(group: group, limit: limit)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The GroupsMembersListContinueArg struct
    open class GroupsMembersListContinueArg: CustomStringConvertible {
        /// Indicates from what point to get the next set of groups.
        open let cursor: String
        public init(cursor: String) {
            stringValidator()(cursor)
            self.cursor = cursor
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GroupsMembersListContinueArgSerializer().serialize(self)))"
        }
    }
    open class GroupsMembersListContinueArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GroupsMembersListContinueArg) -> JSON {
            let output = [
            "cursor": Serialization._StringSerializer.serialize(value.cursor),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> GroupsMembersListContinueArg {
            switch json {
                case .dictionary(let dict):
                    let cursor = Serialization._StringSerializer.deserialize(dict["cursor"] ?? .null)
                    return GroupsMembersListContinueArg(cursor: cursor)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The GroupsMembersListContinueError union
    public enum GroupsMembersListContinueError: CustomStringConvertible {
        /// The cursor is invalid.
        case invalidCursor
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GroupsMembersListContinueErrorSerializer().serialize(self)))"
        }
    }
    open class GroupsMembersListContinueErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GroupsMembersListContinueError) -> JSON {
            switch value {
                case .invalidCursor:
                    var d = [String: JSON]()
                    d[".tag"] = .str("invalid_cursor")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> GroupsMembersListContinueError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "invalid_cursor":
                            return GroupsMembersListContinueError.invalidCursor
                        case "other":
                            return GroupsMembersListContinueError.other
                        default:
                            return GroupsMembersListContinueError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The GroupsMembersListResult struct
    open class GroupsMembersListResult: CustomStringConvertible {
        /// (no description)
        open let members: Array<Team.GroupMemberInfo>
        /// Pass the cursor into groupsMembersListContinue to obtain additional group members.
        open let cursor: String
        /// Is true if there are additional group members that have not been returned yet. An additional call to
        /// groupsMembersListContinue can retrieve them.
        open let hasMore: Bool
        public init(members: Array<Team.GroupMemberInfo>, cursor: String, hasMore: Bool) {
            self.members = members
            stringValidator()(cursor)
            self.cursor = cursor
            self.hasMore = hasMore
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GroupsMembersListResultSerializer().serialize(self)))"
        }
    }
    open class GroupsMembersListResultSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GroupsMembersListResult) -> JSON {
            let output = [
            "members": ArraySerializer(Team.GroupMemberInfoSerializer()).serialize(value.members),
            "cursor": Serialization._StringSerializer.serialize(value.cursor),
            "has_more": Serialization._BoolSerializer.serialize(value.hasMore),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> GroupsMembersListResult {
            switch json {
                case .dictionary(let dict):
                    let members = ArraySerializer(Team.GroupMemberInfoSerializer()).deserialize(dict["members"] ?? .null)
                    let cursor = Serialization._StringSerializer.deserialize(dict["cursor"] ?? .null)
                    let hasMore = Serialization._BoolSerializer.deserialize(dict["has_more"] ?? .null)
                    return GroupsMembersListResult(members: members, cursor: cursor, hasMore: hasMore)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The GroupsPollError union
    public enum GroupsPollError: CustomStringConvertible {
        /// The job ID is invalid.
        case invalidAsyncJobId
        /// Something went wrong with the job on Dropbox's end. You'll need to verify that the action you were taking
        /// succeeded, and if not, try again. This should happen very rarely.
        case internalError
        /// An unspecified error.
        case other
        /// You are not allowed to poll this job.
        case accessDenied

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GroupsPollErrorSerializer().serialize(self)))"
        }
    }
    open class GroupsPollErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GroupsPollError) -> JSON {
            switch value {
                case .invalidAsyncJobId:
                    var d = [String: JSON]()
                    d[".tag"] = .str("invalid_async_job_id")
                    return .dictionary(d)
                case .internalError:
                    var d = [String: JSON]()
                    d[".tag"] = .str("internal_error")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
                case .accessDenied:
                    var d = [String: JSON]()
                    d[".tag"] = .str("access_denied")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> GroupsPollError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "invalid_async_job_id":
                            return GroupsPollError.invalidAsyncJobId
                        case "internal_error":
                            return GroupsPollError.internalError
                        case "other":
                            return GroupsPollError.other
                        case "access_denied":
                            return GroupsPollError.accessDenied
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Argument for selecting a list of groups, either by group_ids, or external group IDs.
    public enum GroupsSelector: CustomStringConvertible {
        /// List of group IDs.
        case groupIds(Array<String>)
        /// List of external IDs of groups.
        case groupExternalIds(Array<String>)

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GroupsSelectorSerializer().serialize(self)))"
        }
    }
    open class GroupsSelectorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GroupsSelector) -> JSON {
            switch value {
                case .groupIds(let arg):
                    var d = ["group_ids": ArraySerializer(Serialization._StringSerializer).serialize(arg)]
                    d[".tag"] = .str("group_ids")
                    return .dictionary(d)
                case .groupExternalIds(let arg):
                    var d = ["group_external_ids": ArraySerializer(Serialization._StringSerializer).serialize(arg)]
                    d[".tag"] = .str("group_external_ids")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> GroupsSelector {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "group_ids":
                            let v = ArraySerializer(Serialization._StringSerializer).deserialize(d["group_ids"] ?? .null)
                            return GroupsSelector.groupIds(v)
                        case "group_external_ids":
                            let v = ArraySerializer(Serialization._StringSerializer).deserialize(d["group_external_ids"] ?? .null)
                            return GroupsSelector.groupExternalIds(v)
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The ListMemberAppsArg struct
    open class ListMemberAppsArg: CustomStringConvertible {
        /// The team member id
        open let teamMemberId: String
        public init(teamMemberId: String) {
            stringValidator()(teamMemberId)
            self.teamMemberId = teamMemberId
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListMemberAppsArgSerializer().serialize(self)))"
        }
    }
    open class ListMemberAppsArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ListMemberAppsArg) -> JSON {
            let output = [
            "team_member_id": Serialization._StringSerializer.serialize(value.teamMemberId),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ListMemberAppsArg {
            switch json {
                case .dictionary(let dict):
                    let teamMemberId = Serialization._StringSerializer.deserialize(dict["team_member_id"] ?? .null)
                    return ListMemberAppsArg(teamMemberId: teamMemberId)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Error returned by linkedAppsListMemberLinkedApps.
    public enum ListMemberAppsError: CustomStringConvertible {
        /// Member not found.
        case memberNotFound
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListMemberAppsErrorSerializer().serialize(self)))"
        }
    }
    open class ListMemberAppsErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ListMemberAppsError) -> JSON {
            switch value {
                case .memberNotFound:
                    var d = [String: JSON]()
                    d[".tag"] = .str("member_not_found")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> ListMemberAppsError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "member_not_found":
                            return ListMemberAppsError.memberNotFound
                        case "other":
                            return ListMemberAppsError.other
                        default:
                            return ListMemberAppsError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The ListMemberAppsResult struct
    open class ListMemberAppsResult: CustomStringConvertible {
        /// List of third party applications linked by this team member
        open let linkedApiApps: Array<Team.ApiApp>
        public init(linkedApiApps: Array<Team.ApiApp>) {
            self.linkedApiApps = linkedApiApps
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListMemberAppsResultSerializer().serialize(self)))"
        }
    }
    open class ListMemberAppsResultSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ListMemberAppsResult) -> JSON {
            let output = [
            "linked_api_apps": ArraySerializer(Team.ApiAppSerializer()).serialize(value.linkedApiApps),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ListMemberAppsResult {
            switch json {
                case .dictionary(let dict):
                    let linkedApiApps = ArraySerializer(Team.ApiAppSerializer()).deserialize(dict["linked_api_apps"] ?? .null)
                    return ListMemberAppsResult(linkedApiApps: linkedApiApps)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The ListMemberDevicesArg struct
    open class ListMemberDevicesArg: CustomStringConvertible {
        /// The team's member id
        open let teamMemberId: String
        /// Whether to list web sessions of the team's member
        open let includeWebSessions: Bool
        /// Whether to list linked desktop devices of the team's member
        open let includeDesktopClients: Bool
        /// Whether to list linked mobile devices of the team's member
        open let includeMobileClients: Bool
        public init(teamMemberId: String, includeWebSessions: Bool = true, includeDesktopClients: Bool = true, includeMobileClients: Bool = true) {
            stringValidator()(teamMemberId)
            self.teamMemberId = teamMemberId
            self.includeWebSessions = includeWebSessions
            self.includeDesktopClients = includeDesktopClients
            self.includeMobileClients = includeMobileClients
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListMemberDevicesArgSerializer().serialize(self)))"
        }
    }
    open class ListMemberDevicesArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ListMemberDevicesArg) -> JSON {
            let output = [
            "team_member_id": Serialization._StringSerializer.serialize(value.teamMemberId),
            "include_web_sessions": Serialization._BoolSerializer.serialize(value.includeWebSessions),
            "include_desktop_clients": Serialization._BoolSerializer.serialize(value.includeDesktopClients),
            "include_mobile_clients": Serialization._BoolSerializer.serialize(value.includeMobileClients),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ListMemberDevicesArg {
            switch json {
                case .dictionary(let dict):
                    let teamMemberId = Serialization._StringSerializer.deserialize(dict["team_member_id"] ?? .null)
                    let includeWebSessions = Serialization._BoolSerializer.deserialize(dict["include_web_sessions"] ?? .number(1))
                    let includeDesktopClients = Serialization._BoolSerializer.deserialize(dict["include_desktop_clients"] ?? .number(1))
                    let includeMobileClients = Serialization._BoolSerializer.deserialize(dict["include_mobile_clients"] ?? .number(1))
                    return ListMemberDevicesArg(teamMemberId: teamMemberId, includeWebSessions: includeWebSessions, includeDesktopClients: includeDesktopClients, includeMobileClients: includeMobileClients)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The ListMemberDevicesError union
    public enum ListMemberDevicesError: CustomStringConvertible {
        /// Member not found.
        case memberNotFound
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListMemberDevicesErrorSerializer().serialize(self)))"
        }
    }
    open class ListMemberDevicesErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ListMemberDevicesError) -> JSON {
            switch value {
                case .memberNotFound:
                    var d = [String: JSON]()
                    d[".tag"] = .str("member_not_found")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> ListMemberDevicesError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "member_not_found":
                            return ListMemberDevicesError.memberNotFound
                        case "other":
                            return ListMemberDevicesError.other
                        default:
                            return ListMemberDevicesError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The ListMemberDevicesResult struct
    open class ListMemberDevicesResult: CustomStringConvertible {
        /// List of web sessions made by this team member
        open let activeWebSessions: Array<Team.ActiveWebSession>?
        /// List of desktop clients used by this team member
        open let desktopClientSessions: Array<Team.DesktopClientSession>?
        /// List of mobile client used by this team member
        open let mobileClientSessions: Array<Team.MobileClientSession>?
        public init(activeWebSessions: Array<Team.ActiveWebSession>? = nil, desktopClientSessions: Array<Team.DesktopClientSession>? = nil, mobileClientSessions: Array<Team.MobileClientSession>? = nil) {
            self.activeWebSessions = activeWebSessions
            self.desktopClientSessions = desktopClientSessions
            self.mobileClientSessions = mobileClientSessions
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListMemberDevicesResultSerializer().serialize(self)))"
        }
    }
    open class ListMemberDevicesResultSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ListMemberDevicesResult) -> JSON {
            let output = [
            "active_web_sessions": NullableSerializer(ArraySerializer(Team.ActiveWebSessionSerializer())).serialize(value.activeWebSessions),
            "desktop_client_sessions": NullableSerializer(ArraySerializer(Team.DesktopClientSessionSerializer())).serialize(value.desktopClientSessions),
            "mobile_client_sessions": NullableSerializer(ArraySerializer(Team.MobileClientSessionSerializer())).serialize(value.mobileClientSessions),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ListMemberDevicesResult {
            switch json {
                case .dictionary(let dict):
                    let activeWebSessions = NullableSerializer(ArraySerializer(Team.ActiveWebSessionSerializer())).deserialize(dict["active_web_sessions"] ?? .null)
                    let desktopClientSessions = NullableSerializer(ArraySerializer(Team.DesktopClientSessionSerializer())).deserialize(dict["desktop_client_sessions"] ?? .null)
                    let mobileClientSessions = NullableSerializer(ArraySerializer(Team.MobileClientSessionSerializer())).deserialize(dict["mobile_client_sessions"] ?? .null)
                    return ListMemberDevicesResult(activeWebSessions: activeWebSessions, desktopClientSessions: desktopClientSessions, mobileClientSessions: mobileClientSessions)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Arguments for linkedAppsListMembersLinkedApps.
    open class ListMembersAppsArg: CustomStringConvertible {
        /// At the first call to the linkedAppsListMembersLinkedApps the cursor shouldn't be passed. Then, if the result
        /// of the call includes a cursor, the following requests should include the received cursors in order to
        /// receive the next sub list of the team applications
        open let cursor: String?
        public init(cursor: String? = nil) {
            nullableValidator(stringValidator())(cursor)
            self.cursor = cursor
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListMembersAppsArgSerializer().serialize(self)))"
        }
    }
    open class ListMembersAppsArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ListMembersAppsArg) -> JSON {
            let output = [
            "cursor": NullableSerializer(Serialization._StringSerializer).serialize(value.cursor),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ListMembersAppsArg {
            switch json {
                case .dictionary(let dict):
                    let cursor = NullableSerializer(Serialization._StringSerializer).deserialize(dict["cursor"] ?? .null)
                    return ListMembersAppsArg(cursor: cursor)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Error returned by linkedAppsListMembersLinkedApps
    public enum ListMembersAppsError: CustomStringConvertible {
        /// Indicates that the cursor has been invalidated. Call linkedAppsListMembersLinkedApps again with an empty
        /// cursor to obtain a new cursor.
        case reset
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListMembersAppsErrorSerializer().serialize(self)))"
        }
    }
    open class ListMembersAppsErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ListMembersAppsError) -> JSON {
            switch value {
                case .reset:
                    var d = [String: JSON]()
                    d[".tag"] = .str("reset")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> ListMembersAppsError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "reset":
                            return ListMembersAppsError.reset
                        case "other":
                            return ListMembersAppsError.other
                        default:
                            return ListMembersAppsError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Information returned by linkedAppsListMembersLinkedApps.
    open class ListMembersAppsResult: CustomStringConvertible {
        /// The linked applications of each member of the team
        open let apps: Array<Team.MemberLinkedApps>
        /// If true, then there are more apps available. Pass the cursor to linkedAppsListMembersLinkedApps to retrieve
        /// the rest.
        open let hasMore: Bool
        /// Pass the cursor into linkedAppsListMembersLinkedApps to receive the next sub list of team's applications.
        open let cursor: String?
        public init(apps: Array<Team.MemberLinkedApps>, hasMore: Bool, cursor: String? = nil) {
            self.apps = apps
            self.hasMore = hasMore
            nullableValidator(stringValidator())(cursor)
            self.cursor = cursor
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListMembersAppsResultSerializer().serialize(self)))"
        }
    }
    open class ListMembersAppsResultSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ListMembersAppsResult) -> JSON {
            let output = [
            "apps": ArraySerializer(Team.MemberLinkedAppsSerializer()).serialize(value.apps),
            "has_more": Serialization._BoolSerializer.serialize(value.hasMore),
            "cursor": NullableSerializer(Serialization._StringSerializer).serialize(value.cursor),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ListMembersAppsResult {
            switch json {
                case .dictionary(let dict):
                    let apps = ArraySerializer(Team.MemberLinkedAppsSerializer()).deserialize(dict["apps"] ?? .null)
                    let hasMore = Serialization._BoolSerializer.deserialize(dict["has_more"] ?? .null)
                    let cursor = NullableSerializer(Serialization._StringSerializer).deserialize(dict["cursor"] ?? .null)
                    return ListMembersAppsResult(apps: apps, hasMore: hasMore, cursor: cursor)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The ListMembersDevicesArg struct
    open class ListMembersDevicesArg: CustomStringConvertible {
        /// At the first call to the devicesListMembersDevices the cursor shouldn't be passed. Then, if the result of
        /// the call includes a cursor, the following requests should include the received cursors in order to receive
        /// the next sub list of team devices
        open let cursor: String?
        /// Whether to list web sessions of the team members
        open let includeWebSessions: Bool
        /// Whether to list desktop clients of the team members
        open let includeDesktopClients: Bool
        /// Whether to list mobile clients of the team members
        open let includeMobileClients: Bool
        public init(cursor: String? = nil, includeWebSessions: Bool = true, includeDesktopClients: Bool = true, includeMobileClients: Bool = true) {
            nullableValidator(stringValidator())(cursor)
            self.cursor = cursor
            self.includeWebSessions = includeWebSessions
            self.includeDesktopClients = includeDesktopClients
            self.includeMobileClients = includeMobileClients
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListMembersDevicesArgSerializer().serialize(self)))"
        }
    }
    open class ListMembersDevicesArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ListMembersDevicesArg) -> JSON {
            let output = [
            "cursor": NullableSerializer(Serialization._StringSerializer).serialize(value.cursor),
            "include_web_sessions": Serialization._BoolSerializer.serialize(value.includeWebSessions),
            "include_desktop_clients": Serialization._BoolSerializer.serialize(value.includeDesktopClients),
            "include_mobile_clients": Serialization._BoolSerializer.serialize(value.includeMobileClients),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ListMembersDevicesArg {
            switch json {
                case .dictionary(let dict):
                    let cursor = NullableSerializer(Serialization._StringSerializer).deserialize(dict["cursor"] ?? .null)
                    let includeWebSessions = Serialization._BoolSerializer.deserialize(dict["include_web_sessions"] ?? .number(1))
                    let includeDesktopClients = Serialization._BoolSerializer.deserialize(dict["include_desktop_clients"] ?? .number(1))
                    let includeMobileClients = Serialization._BoolSerializer.deserialize(dict["include_mobile_clients"] ?? .number(1))
                    return ListMembersDevicesArg(cursor: cursor, includeWebSessions: includeWebSessions, includeDesktopClients: includeDesktopClients, includeMobileClients: includeMobileClients)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The ListMembersDevicesError union
    public enum ListMembersDevicesError: CustomStringConvertible {
        /// Indicates that the cursor has been invalidated. Call devicesListMembersDevices again with an empty cursor to
        /// obtain a new cursor.
        case reset
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListMembersDevicesErrorSerializer().serialize(self)))"
        }
    }
    open class ListMembersDevicesErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ListMembersDevicesError) -> JSON {
            switch value {
                case .reset:
                    var d = [String: JSON]()
                    d[".tag"] = .str("reset")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> ListMembersDevicesError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "reset":
                            return ListMembersDevicesError.reset
                        case "other":
                            return ListMembersDevicesError.other
                        default:
                            return ListMembersDevicesError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The ListMembersDevicesResult struct
    open class ListMembersDevicesResult: CustomStringConvertible {
        /// The devices of each member of the team
        open let devices: Array<Team.MemberDevices>
        /// If true, then there are more devices available. Pass the cursor to devicesListMembersDevices to retrieve the
        /// rest.
        open let hasMore: Bool
        /// Pass the cursor into devicesListMembersDevices to receive the next sub list of team's devices.
        open let cursor: String?
        public init(devices: Array<Team.MemberDevices>, hasMore: Bool, cursor: String? = nil) {
            self.devices = devices
            self.hasMore = hasMore
            nullableValidator(stringValidator())(cursor)
            self.cursor = cursor
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListMembersDevicesResultSerializer().serialize(self)))"
        }
    }
    open class ListMembersDevicesResultSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ListMembersDevicesResult) -> JSON {
            let output = [
            "devices": ArraySerializer(Team.MemberDevicesSerializer()).serialize(value.devices),
            "has_more": Serialization._BoolSerializer.serialize(value.hasMore),
            "cursor": NullableSerializer(Serialization._StringSerializer).serialize(value.cursor),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ListMembersDevicesResult {
            switch json {
                case .dictionary(let dict):
                    let devices = ArraySerializer(Team.MemberDevicesSerializer()).deserialize(dict["devices"] ?? .null)
                    let hasMore = Serialization._BoolSerializer.deserialize(dict["has_more"] ?? .null)
                    let cursor = NullableSerializer(Serialization._StringSerializer).deserialize(dict["cursor"] ?? .null)
                    return ListMembersDevicesResult(devices: devices, hasMore: hasMore, cursor: cursor)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Arguments for linkedAppsListTeamLinkedApps.
    open class ListTeamAppsArg: CustomStringConvertible {
        /// At the first call to the linkedAppsListTeamLinkedApps the cursor shouldn't be passed. Then, if the result of
        /// the call includes a cursor, the following requests should include the received cursors in order to receive
        /// the next sub list of the team applications
        open let cursor: String?
        public init(cursor: String? = nil) {
            nullableValidator(stringValidator())(cursor)
            self.cursor = cursor
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListTeamAppsArgSerializer().serialize(self)))"
        }
    }
    open class ListTeamAppsArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ListTeamAppsArg) -> JSON {
            let output = [
            "cursor": NullableSerializer(Serialization._StringSerializer).serialize(value.cursor),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ListTeamAppsArg {
            switch json {
                case .dictionary(let dict):
                    let cursor = NullableSerializer(Serialization._StringSerializer).deserialize(dict["cursor"] ?? .null)
                    return ListTeamAppsArg(cursor: cursor)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Error returned by linkedAppsListTeamLinkedApps
    public enum ListTeamAppsError: CustomStringConvertible {
        /// Indicates that the cursor has been invalidated. Call linkedAppsListTeamLinkedApps again with an empty cursor
        /// to obtain a new cursor.
        case reset
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListTeamAppsErrorSerializer().serialize(self)))"
        }
    }
    open class ListTeamAppsErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ListTeamAppsError) -> JSON {
            switch value {
                case .reset:
                    var d = [String: JSON]()
                    d[".tag"] = .str("reset")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> ListTeamAppsError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "reset":
                            return ListTeamAppsError.reset
                        case "other":
                            return ListTeamAppsError.other
                        default:
                            return ListTeamAppsError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Information returned by linkedAppsListTeamLinkedApps.
    open class ListTeamAppsResult: CustomStringConvertible {
        /// The linked applications of each member of the team
        open let apps: Array<Team.MemberLinkedApps>
        /// If true, then there are more apps available. Pass the cursor to linkedAppsListTeamLinkedApps to retrieve the
        /// rest.
        open let hasMore: Bool
        /// Pass the cursor into linkedAppsListTeamLinkedApps to receive the next sub list of team's applications.
        open let cursor: String?
        public init(apps: Array<Team.MemberLinkedApps>, hasMore: Bool, cursor: String? = nil) {
            self.apps = apps
            self.hasMore = hasMore
            nullableValidator(stringValidator())(cursor)
            self.cursor = cursor
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListTeamAppsResultSerializer().serialize(self)))"
        }
    }
    open class ListTeamAppsResultSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ListTeamAppsResult) -> JSON {
            let output = [
            "apps": ArraySerializer(Team.MemberLinkedAppsSerializer()).serialize(value.apps),
            "has_more": Serialization._BoolSerializer.serialize(value.hasMore),
            "cursor": NullableSerializer(Serialization._StringSerializer).serialize(value.cursor),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ListTeamAppsResult {
            switch json {
                case .dictionary(let dict):
                    let apps = ArraySerializer(Team.MemberLinkedAppsSerializer()).deserialize(dict["apps"] ?? .null)
                    let hasMore = Serialization._BoolSerializer.deserialize(dict["has_more"] ?? .null)
                    let cursor = NullableSerializer(Serialization._StringSerializer).deserialize(dict["cursor"] ?? .null)
                    return ListTeamAppsResult(apps: apps, hasMore: hasMore, cursor: cursor)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The ListTeamDevicesArg struct
    open class ListTeamDevicesArg: CustomStringConvertible {
        /// At the first call to the devicesListTeamDevices the cursor shouldn't be passed. Then, if the result of the
        /// call includes a cursor, the following requests should include the received cursors in order to receive the
        /// next sub list of team devices
        open let cursor: String?
        /// Whether to list web sessions of the team members
        open let includeWebSessions: Bool
        /// Whether to list desktop clients of the team members
        open let includeDesktopClients: Bool
        /// Whether to list mobile clients of the team members
        open let includeMobileClients: Bool
        public init(cursor: String? = nil, includeWebSessions: Bool = true, includeDesktopClients: Bool = true, includeMobileClients: Bool = true) {
            nullableValidator(stringValidator())(cursor)
            self.cursor = cursor
            self.includeWebSessions = includeWebSessions
            self.includeDesktopClients = includeDesktopClients
            self.includeMobileClients = includeMobileClients
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListTeamDevicesArgSerializer().serialize(self)))"
        }
    }
    open class ListTeamDevicesArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ListTeamDevicesArg) -> JSON {
            let output = [
            "cursor": NullableSerializer(Serialization._StringSerializer).serialize(value.cursor),
            "include_web_sessions": Serialization._BoolSerializer.serialize(value.includeWebSessions),
            "include_desktop_clients": Serialization._BoolSerializer.serialize(value.includeDesktopClients),
            "include_mobile_clients": Serialization._BoolSerializer.serialize(value.includeMobileClients),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ListTeamDevicesArg {
            switch json {
                case .dictionary(let dict):
                    let cursor = NullableSerializer(Serialization._StringSerializer).deserialize(dict["cursor"] ?? .null)
                    let includeWebSessions = Serialization._BoolSerializer.deserialize(dict["include_web_sessions"] ?? .number(1))
                    let includeDesktopClients = Serialization._BoolSerializer.deserialize(dict["include_desktop_clients"] ?? .number(1))
                    let includeMobileClients = Serialization._BoolSerializer.deserialize(dict["include_mobile_clients"] ?? .number(1))
                    return ListTeamDevicesArg(cursor: cursor, includeWebSessions: includeWebSessions, includeDesktopClients: includeDesktopClients, includeMobileClients: includeMobileClients)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The ListTeamDevicesError union
    public enum ListTeamDevicesError: CustomStringConvertible {
        /// Indicates that the cursor has been invalidated. Call devicesListTeamDevices again with an empty cursor to
        /// obtain a new cursor.
        case reset
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListTeamDevicesErrorSerializer().serialize(self)))"
        }
    }
    open class ListTeamDevicesErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ListTeamDevicesError) -> JSON {
            switch value {
                case .reset:
                    var d = [String: JSON]()
                    d[".tag"] = .str("reset")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> ListTeamDevicesError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "reset":
                            return ListTeamDevicesError.reset
                        case "other":
                            return ListTeamDevicesError.other
                        default:
                            return ListTeamDevicesError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The ListTeamDevicesResult struct
    open class ListTeamDevicesResult: CustomStringConvertible {
        /// The devices of each member of the team
        open let devices: Array<Team.MemberDevices>
        /// If true, then there are more devices available. Pass the cursor to devicesListTeamDevices to retrieve the
        /// rest.
        open let hasMore: Bool
        /// Pass the cursor into devicesListTeamDevices to receive the next sub list of team's devices.
        open let cursor: String?
        public init(devices: Array<Team.MemberDevices>, hasMore: Bool, cursor: String? = nil) {
            self.devices = devices
            self.hasMore = hasMore
            nullableValidator(stringValidator())(cursor)
            self.cursor = cursor
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListTeamDevicesResultSerializer().serialize(self)))"
        }
    }
    open class ListTeamDevicesResultSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ListTeamDevicesResult) -> JSON {
            let output = [
            "devices": ArraySerializer(Team.MemberDevicesSerializer()).serialize(value.devices),
            "has_more": Serialization._BoolSerializer.serialize(value.hasMore),
            "cursor": NullableSerializer(Serialization._StringSerializer).serialize(value.cursor),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ListTeamDevicesResult {
            switch json {
                case .dictionary(let dict):
                    let devices = ArraySerializer(Team.MemberDevicesSerializer()).deserialize(dict["devices"] ?? .null)
                    let hasMore = Serialization._BoolSerializer.deserialize(dict["has_more"] ?? .null)
                    let cursor = NullableSerializer(Serialization._StringSerializer).deserialize(dict["cursor"] ?? .null)
                    return ListTeamDevicesResult(devices: devices, hasMore: hasMore, cursor: cursor)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Specify access type a member should have when joined to a group.
    open class MemberAccess: CustomStringConvertible {
        /// Identity of a user.
        open let user: Team.UserSelectorArg
        /// Access type.
        open let accessType: Team.GroupAccessType
        public init(user: Team.UserSelectorArg, accessType: Team.GroupAccessType) {
            self.user = user
            self.accessType = accessType
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MemberAccessSerializer().serialize(self)))"
        }
    }
    open class MemberAccessSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: MemberAccess) -> JSON {
            let output = [
            "user": Team.UserSelectorArgSerializer().serialize(value.user),
            "access_type": Team.GroupAccessTypeSerializer().serialize(value.accessType),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> MemberAccess {
            switch json {
                case .dictionary(let dict):
                    let user = Team.UserSelectorArgSerializer().deserialize(dict["user"] ?? .null)
                    let accessType = Team.GroupAccessTypeSerializer().deserialize(dict["access_type"] ?? .null)
                    return MemberAccess(user: user, accessType: accessType)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The MemberAddArg struct
    open class MemberAddArg: CustomStringConvertible {
        /// (no description)
        open let memberEmail: String
        /// Member's first name.
        open let memberGivenName: String
        /// Member's last name.
        open let memberSurname: String
        /// External ID for member.
        open let memberExternalId: String?
        /// Whether to send a welcome email to the member. If send_welcome_email is false, no email invitation will be
        /// sent to the user. This may be useful for apps using single sign-on (SSO) flows for onboarding that want to
        /// handle announcements themselves.
        open let sendWelcomeEmail: Bool
        /// (no description)
        open let role: Team.AdminTier
        public init(memberEmail: String, memberGivenName: String, memberSurname: String, memberExternalId: String? = nil, sendWelcomeEmail: Bool = true, role: Team.AdminTier = .memberOnly) {
            stringValidator(maxLength: 255, pattern: "^['&A-Za-z0-9._%+-]+@[A-Za-z0-9-][A-Za-z0-9.-]*.[A-Za-z]{2,15}$")(memberEmail)
            self.memberEmail = memberEmail
            stringValidator(minLength: 1, maxLength: 100, pattern: "[^/:?*<>\"|]*")(memberGivenName)
            self.memberGivenName = memberGivenName
            stringValidator(minLength: 1, maxLength: 100, pattern: "[^/:?*<>\"|]*")(memberSurname)
            self.memberSurname = memberSurname
            nullableValidator(stringValidator(maxLength: 64))(memberExternalId)
            self.memberExternalId = memberExternalId
            self.sendWelcomeEmail = sendWelcomeEmail
            self.role = role
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MemberAddArgSerializer().serialize(self)))"
        }
    }
    open class MemberAddArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: MemberAddArg) -> JSON {
            let output = [
            "member_email": Serialization._StringSerializer.serialize(value.memberEmail),
            "member_given_name": Serialization._StringSerializer.serialize(value.memberGivenName),
            "member_surname": Serialization._StringSerializer.serialize(value.memberSurname),
            "member_external_id": NullableSerializer(Serialization._StringSerializer).serialize(value.memberExternalId),
            "send_welcome_email": Serialization._BoolSerializer.serialize(value.sendWelcomeEmail),
            "role": Team.AdminTierSerializer().serialize(value.role),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> MemberAddArg {
            switch json {
                case .dictionary(let dict):
                    let memberEmail = Serialization._StringSerializer.deserialize(dict["member_email"] ?? .null)
                    let memberGivenName = Serialization._StringSerializer.deserialize(dict["member_given_name"] ?? .null)
                    let memberSurname = Serialization._StringSerializer.deserialize(dict["member_surname"] ?? .null)
                    let memberExternalId = NullableSerializer(Serialization._StringSerializer).deserialize(dict["member_external_id"] ?? .null)
                    let sendWelcomeEmail = Serialization._BoolSerializer.deserialize(dict["send_welcome_email"] ?? .number(1))
                    let role = Team.AdminTierSerializer().deserialize(dict["role"] ?? Team.AdminTierSerializer().serialize(.memberOnly))
                    return MemberAddArg(memberEmail: memberEmail, memberGivenName: memberGivenName, memberSurname: memberSurname, memberExternalId: memberExternalId, sendWelcomeEmail: sendWelcomeEmail, role: role)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Describes the result of attempting to add a single user to the team. 'success' is the only value indicating that
    /// a user was indeed added to the team - the other values explain the type of failure that occurred, and include
    /// the email of the user for which the operation has failed.
    public enum MemberAddResult: CustomStringConvertible {
        /// Describes a user that was successfully added to the team.
        case success(Team.TeamMemberInfo)
        /// Team is already full. The organization has no available licenses.
        case teamLicenseLimit(String)
        /// Team is already full. The free team member limit has been reached.
        case freeTeamMemberLimitReached(String)
        /// User is already on this team. The provided email address is associated with a user who is already a member
        /// of (including in recoverable state) or invited to the team.
        case userAlreadyOnTeam(String)
        /// User is already on another team. The provided email address is associated with a user that is already a
        /// member or invited to another team.
        case userOnAnotherTeam(String)
        /// User is already paired.
        case userAlreadyPaired(String)
        /// User migration has failed.
        case userMigrationFailed(String)
        /// A user with the given external member ID already exists on the team (including in recoverable state).
        case duplicateExternalMemberId(String)
        /// User creation has failed.
        case userCreationFailed(String)

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MemberAddResultSerializer().serialize(self)))"
        }
    }
    open class MemberAddResultSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: MemberAddResult) -> JSON {
            switch value {
                case .success(let arg):
                    var d = Serialization.getFields(Team.TeamMemberInfoSerializer().serialize(arg))
                    d[".tag"] = .str("success")
                    return .dictionary(d)
                case .teamLicenseLimit(let arg):
                    var d = ["team_license_limit": Serialization._StringSerializer.serialize(arg)]
                    d[".tag"] = .str("team_license_limit")
                    return .dictionary(d)
                case .freeTeamMemberLimitReached(let arg):
                    var d = ["free_team_member_limit_reached": Serialization._StringSerializer.serialize(arg)]
                    d[".tag"] = .str("free_team_member_limit_reached")
                    return .dictionary(d)
                case .userAlreadyOnTeam(let arg):
                    var d = ["user_already_on_team": Serialization._StringSerializer.serialize(arg)]
                    d[".tag"] = .str("user_already_on_team")
                    return .dictionary(d)
                case .userOnAnotherTeam(let arg):
                    var d = ["user_on_another_team": Serialization._StringSerializer.serialize(arg)]
                    d[".tag"] = .str("user_on_another_team")
                    return .dictionary(d)
                case .userAlreadyPaired(let arg):
                    var d = ["user_already_paired": Serialization._StringSerializer.serialize(arg)]
                    d[".tag"] = .str("user_already_paired")
                    return .dictionary(d)
                case .userMigrationFailed(let arg):
                    var d = ["user_migration_failed": Serialization._StringSerializer.serialize(arg)]
                    d[".tag"] = .str("user_migration_failed")
                    return .dictionary(d)
                case .duplicateExternalMemberId(let arg):
                    var d = ["duplicate_external_member_id": Serialization._StringSerializer.serialize(arg)]
                    d[".tag"] = .str("duplicate_external_member_id")
                    return .dictionary(d)
                case .userCreationFailed(let arg):
                    var d = ["user_creation_failed": Serialization._StringSerializer.serialize(arg)]
                    d[".tag"] = .str("user_creation_failed")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> MemberAddResult {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "success":
                            let v = Team.TeamMemberInfoSerializer().deserialize(json)
                            return MemberAddResult.success(v)
                        case "team_license_limit":
                            let v = Serialization._StringSerializer.deserialize(d["team_license_limit"] ?? .null)
                            return MemberAddResult.teamLicenseLimit(v)
                        case "free_team_member_limit_reached":
                            let v = Serialization._StringSerializer.deserialize(d["free_team_member_limit_reached"] ?? .null)
                            return MemberAddResult.freeTeamMemberLimitReached(v)
                        case "user_already_on_team":
                            let v = Serialization._StringSerializer.deserialize(d["user_already_on_team"] ?? .null)
                            return MemberAddResult.userAlreadyOnTeam(v)
                        case "user_on_another_team":
                            let v = Serialization._StringSerializer.deserialize(d["user_on_another_team"] ?? .null)
                            return MemberAddResult.userOnAnotherTeam(v)
                        case "user_already_paired":
                            let v = Serialization._StringSerializer.deserialize(d["user_already_paired"] ?? .null)
                            return MemberAddResult.userAlreadyPaired(v)
                        case "user_migration_failed":
                            let v = Serialization._StringSerializer.deserialize(d["user_migration_failed"] ?? .null)
                            return MemberAddResult.userMigrationFailed(v)
                        case "duplicate_external_member_id":
                            let v = Serialization._StringSerializer.deserialize(d["duplicate_external_member_id"] ?? .null)
                            return MemberAddResult.duplicateExternalMemberId(v)
                        case "user_creation_failed":
                            let v = Serialization._StringSerializer.deserialize(d["user_creation_failed"] ?? .null)
                            return MemberAddResult.userCreationFailed(v)
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Information on devices of a team's member.
    open class MemberDevices: CustomStringConvertible {
        /// The member unique Id
        open let teamMemberId: String
        /// List of web sessions made by this team member
        open let webSessions: Array<Team.ActiveWebSession>?
        /// List of desktop clients by this team member
        open let desktopClients: Array<Team.DesktopClientSession>?
        /// List of mobile clients by this team member
        open let mobileClients: Array<Team.MobileClientSession>?
        public init(teamMemberId: String, webSessions: Array<Team.ActiveWebSession>? = nil, desktopClients: Array<Team.DesktopClientSession>? = nil, mobileClients: Array<Team.MobileClientSession>? = nil) {
            stringValidator()(teamMemberId)
            self.teamMemberId = teamMemberId
            self.webSessions = webSessions
            self.desktopClients = desktopClients
            self.mobileClients = mobileClients
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MemberDevicesSerializer().serialize(self)))"
        }
    }
    open class MemberDevicesSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: MemberDevices) -> JSON {
            let output = [
            "team_member_id": Serialization._StringSerializer.serialize(value.teamMemberId),
            "web_sessions": NullableSerializer(ArraySerializer(Team.ActiveWebSessionSerializer())).serialize(value.webSessions),
            "desktop_clients": NullableSerializer(ArraySerializer(Team.DesktopClientSessionSerializer())).serialize(value.desktopClients),
            "mobile_clients": NullableSerializer(ArraySerializer(Team.MobileClientSessionSerializer())).serialize(value.mobileClients),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> MemberDevices {
            switch json {
                case .dictionary(let dict):
                    let teamMemberId = Serialization._StringSerializer.deserialize(dict["team_member_id"] ?? .null)
                    let webSessions = NullableSerializer(ArraySerializer(Team.ActiveWebSessionSerializer())).deserialize(dict["web_sessions"] ?? .null)
                    let desktopClients = NullableSerializer(ArraySerializer(Team.DesktopClientSessionSerializer())).deserialize(dict["desktop_clients"] ?? .null)
                    let mobileClients = NullableSerializer(ArraySerializer(Team.MobileClientSessionSerializer())).deserialize(dict["mobile_clients"] ?? .null)
                    return MemberDevices(teamMemberId: teamMemberId, webSessions: webSessions, desktopClients: desktopClients, mobileClients: mobileClients)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Information on linked applications of a team member.
    open class MemberLinkedApps: CustomStringConvertible {
        /// The member unique Id
        open let teamMemberId: String
        /// List of third party applications linked by this team member
        open let linkedApiApps: Array<Team.ApiApp>
        public init(teamMemberId: String, linkedApiApps: Array<Team.ApiApp>) {
            stringValidator()(teamMemberId)
            self.teamMemberId = teamMemberId
            self.linkedApiApps = linkedApiApps
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MemberLinkedAppsSerializer().serialize(self)))"
        }
    }
    open class MemberLinkedAppsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: MemberLinkedApps) -> JSON {
            let output = [
            "team_member_id": Serialization._StringSerializer.serialize(value.teamMemberId),
            "linked_api_apps": ArraySerializer(Team.ApiAppSerializer()).serialize(value.linkedApiApps),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> MemberLinkedApps {
            switch json {
                case .dictionary(let dict):
                    let teamMemberId = Serialization._StringSerializer.deserialize(dict["team_member_id"] ?? .null)
                    let linkedApiApps = ArraySerializer(Team.ApiAppSerializer()).deserialize(dict["linked_api_apps"] ?? .null)
                    return MemberLinkedApps(teamMemberId: teamMemberId, linkedApiApps: linkedApiApps)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Basic member profile.
    open class MemberProfile: CustomStringConvertible {
        /// ID of user as a member of a team.
        open let teamMemberId: String
        /// External ID that a team can attach to the user. An application using the API may find it easier to use their
        /// own IDs instead of Dropbox IDs like account_id or team_member_id.
        open let externalId: String?
        /// A user's account identifier.
        open let accountId: String?
        /// Email address of user.
        open let email: String
        /// Is true if the user's email is verified to be owned by the user.
        open let emailVerified: Bool
        /// The user's status as a member of a specific team.
        open let status: Team.TeamMemberStatus
        /// Representations for a person's name.
        open let name: Users.Name
        /// The user's membership type: full (normal team member) vs limited (does not use a license; no access to the
        /// team's shared quota).
        open let membershipType: Team.TeamMembershipType
        public init(teamMemberId: String, email: String, emailVerified: Bool, status: Team.TeamMemberStatus, name: Users.Name, membershipType: Team.TeamMembershipType, externalId: String? = nil, accountId: String? = nil) {
            stringValidator()(teamMemberId)
            self.teamMemberId = teamMemberId
            nullableValidator(stringValidator())(externalId)
            self.externalId = externalId
            nullableValidator(stringValidator(minLength: 40, maxLength: 40))(accountId)
            self.accountId = accountId
            stringValidator()(email)
            self.email = email
            self.emailVerified = emailVerified
            self.status = status
            self.name = name
            self.membershipType = membershipType
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MemberProfileSerializer().serialize(self)))"
        }
    }
    open class MemberProfileSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: MemberProfile) -> JSON {
            let output = [
            "team_member_id": Serialization._StringSerializer.serialize(value.teamMemberId),
            "email": Serialization._StringSerializer.serialize(value.email),
            "email_verified": Serialization._BoolSerializer.serialize(value.emailVerified),
            "status": Team.TeamMemberStatusSerializer().serialize(value.status),
            "name": Users.NameSerializer().serialize(value.name),
            "membership_type": Team.TeamMembershipTypeSerializer().serialize(value.membershipType),
            "external_id": NullableSerializer(Serialization._StringSerializer).serialize(value.externalId),
            "account_id": NullableSerializer(Serialization._StringSerializer).serialize(value.accountId),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> MemberProfile {
            switch json {
                case .dictionary(let dict):
                    let teamMemberId = Serialization._StringSerializer.deserialize(dict["team_member_id"] ?? .null)
                    let email = Serialization._StringSerializer.deserialize(dict["email"] ?? .null)
                    let emailVerified = Serialization._BoolSerializer.deserialize(dict["email_verified"] ?? .null)
                    let status = Team.TeamMemberStatusSerializer().deserialize(dict["status"] ?? .null)
                    let name = Users.NameSerializer().deserialize(dict["name"] ?? .null)
                    let membershipType = Team.TeamMembershipTypeSerializer().deserialize(dict["membership_type"] ?? .null)
                    let externalId = NullableSerializer(Serialization._StringSerializer).deserialize(dict["external_id"] ?? .null)
                    let accountId = NullableSerializer(Serialization._StringSerializer).deserialize(dict["account_id"] ?? .null)
                    return MemberProfile(teamMemberId: teamMemberId, email: email, emailVerified: emailVerified, status: status, name: name, membershipType: membershipType, externalId: externalId, accountId: accountId)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Error that can be returned whenever a struct derived from UserSelectorArg is used.
    public enum UserSelectorError: CustomStringConvertible {
        /// No matching user found. The provided team_member_id, email, or external_id does not exist on this team.
        case userNotFound

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(UserSelectorErrorSerializer().serialize(self)))"
        }
    }
    open class UserSelectorErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: UserSelectorError) -> JSON {
            switch value {
                case .userNotFound:
                    var d = [String: JSON]()
                    d[".tag"] = .str("user_not_found")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> UserSelectorError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "user_not_found":
                            return UserSelectorError.userNotFound
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The MemberSelectorError union
    public enum MemberSelectorError: CustomStringConvertible {
        /// No matching user found. The provided team_member_id, email, or external_id does not exist on this team.
        case userNotFound
        /// The user is not a member of the team.
        case userNotInTeam

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MemberSelectorErrorSerializer().serialize(self)))"
        }
    }
    open class MemberSelectorErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: MemberSelectorError) -> JSON {
            switch value {
                case .userNotFound:
                    var d = [String: JSON]()
                    d[".tag"] = .str("user_not_found")
                    return .dictionary(d)
                case .userNotInTeam:
                    var d = [String: JSON]()
                    d[".tag"] = .str("user_not_in_team")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> MemberSelectorError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "user_not_found":
                            return MemberSelectorError.userNotFound
                        case "user_not_in_team":
                            return MemberSelectorError.userNotInTeam
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The MembersAddArg struct
    open class MembersAddArg: CustomStringConvertible {
        /// Details of new members to be added to the team.
        open let newMembers: Array<Team.MemberAddArg>
        /// Whether to force the add to happen asynchronously.
        open let forceAsync: Bool
        public init(newMembers: Array<Team.MemberAddArg>, forceAsync: Bool = false) {
            self.newMembers = newMembers
            self.forceAsync = forceAsync
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MembersAddArgSerializer().serialize(self)))"
        }
    }
    open class MembersAddArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: MembersAddArg) -> JSON {
            let output = [
            "new_members": ArraySerializer(Team.MemberAddArgSerializer()).serialize(value.newMembers),
            "force_async": Serialization._BoolSerializer.serialize(value.forceAsync),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> MembersAddArg {
            switch json {
                case .dictionary(let dict):
                    let newMembers = ArraySerializer(Team.MemberAddArgSerializer()).deserialize(dict["new_members"] ?? .null)
                    let forceAsync = Serialization._BoolSerializer.deserialize(dict["force_async"] ?? .number(0))
                    return MembersAddArg(newMembers: newMembers, forceAsync: forceAsync)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The MembersAddJobStatus union
    public enum MembersAddJobStatus: CustomStringConvertible {
        /// The asynchronous job is still in progress.
        case inProgress
        /// The asynchronous job has finished. For each member that was specified in the parameter MembersAddArg that
        /// was provided to membersAdd, a corresponding item is returned in this list.
        case complete(Array<Team.MemberAddResult>)
        /// The asynchronous job returned an error. The string contains an error message.
        case failed(String)

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MembersAddJobStatusSerializer().serialize(self)))"
        }
    }
    open class MembersAddJobStatusSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: MembersAddJobStatus) -> JSON {
            switch value {
                case .inProgress:
                    var d = [String: JSON]()
                    d[".tag"] = .str("in_progress")
                    return .dictionary(d)
                case .complete(let arg):
                    var d = ["complete": ArraySerializer(Team.MemberAddResultSerializer()).serialize(arg)]
                    d[".tag"] = .str("complete")
                    return .dictionary(d)
                case .failed(let arg):
                    var d = ["failed": Serialization._StringSerializer.serialize(arg)]
                    d[".tag"] = .str("failed")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> MembersAddJobStatus {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "in_progress":
                            return MembersAddJobStatus.inProgress
                        case "complete":
                            let v = ArraySerializer(Team.MemberAddResultSerializer()).deserialize(d["complete"] ?? .null)
                            return MembersAddJobStatus.complete(v)
                        case "failed":
                            let v = Serialization._StringSerializer.deserialize(d["failed"] ?? .null)
                            return MembersAddJobStatus.failed(v)
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The MembersAddLaunch union
    public enum MembersAddLaunch: CustomStringConvertible {
        /// This response indicates that the processing is asynchronous. The string is an id that can be used to obtain
        /// the status of the asynchronous job.
        case asyncJobId(String)
        /// An unspecified error.
        case complete(Array<Team.MemberAddResult>)

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MembersAddLaunchSerializer().serialize(self)))"
        }
    }
    open class MembersAddLaunchSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: MembersAddLaunch) -> JSON {
            switch value {
                case .asyncJobId(let arg):
                    var d = ["async_job_id": Serialization._StringSerializer.serialize(arg)]
                    d[".tag"] = .str("async_job_id")
                    return .dictionary(d)
                case .complete(let arg):
                    var d = ["complete": ArraySerializer(Team.MemberAddResultSerializer()).serialize(arg)]
                    d[".tag"] = .str("complete")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> MembersAddLaunch {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "async_job_id":
                            let v = Serialization._StringSerializer.deserialize(d["async_job_id"] ?? .null)
                            return MembersAddLaunch.asyncJobId(v)
                        case "complete":
                            let v = ArraySerializer(Team.MemberAddResultSerializer()).deserialize(d["complete"] ?? .null)
                            return MembersAddLaunch.complete(v)
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Exactly one of team_member_id, email, or external_id must be provided to identify the user account.
    open class MembersDeactivateArg: CustomStringConvertible {
        /// Identity of user to remove/suspend.
        open let user: Team.UserSelectorArg
        /// If provided, controls if the user's data will be deleted on their linked devices.
        open let wipeData: Bool
        public init(user: Team.UserSelectorArg, wipeData: Bool = true) {
            self.user = user
            self.wipeData = wipeData
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MembersDeactivateArgSerializer().serialize(self)))"
        }
    }
    open class MembersDeactivateArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: MembersDeactivateArg) -> JSON {
            let output = [
            "user": Team.UserSelectorArgSerializer().serialize(value.user),
            "wipe_data": Serialization._BoolSerializer.serialize(value.wipeData),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> MembersDeactivateArg {
            switch json {
                case .dictionary(let dict):
                    let user = Team.UserSelectorArgSerializer().deserialize(dict["user"] ?? .null)
                    let wipeData = Serialization._BoolSerializer.deserialize(dict["wipe_data"] ?? .number(1))
                    return MembersDeactivateArg(user: user, wipeData: wipeData)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The MembersDeactivateError union
    public enum MembersDeactivateError: CustomStringConvertible {
        /// No matching user found. The provided team_member_id, email, or external_id does not exist on this team.
        case userNotFound
        /// The user is not a member of the team.
        case userNotInTeam
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MembersDeactivateErrorSerializer().serialize(self)))"
        }
    }
    open class MembersDeactivateErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: MembersDeactivateError) -> JSON {
            switch value {
                case .userNotFound:
                    var d = [String: JSON]()
                    d[".tag"] = .str("user_not_found")
                    return .dictionary(d)
                case .userNotInTeam:
                    var d = [String: JSON]()
                    d[".tag"] = .str("user_not_in_team")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> MembersDeactivateError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "user_not_found":
                            return MembersDeactivateError.userNotFound
                        case "user_not_in_team":
                            return MembersDeactivateError.userNotInTeam
                        case "other":
                            return MembersDeactivateError.other
                        default:
                            return MembersDeactivateError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The MembersGetInfoArgs struct
    open class MembersGetInfoArgs: CustomStringConvertible {
        /// List of team members.
        open let members: Array<Team.UserSelectorArg>
        public init(members: Array<Team.UserSelectorArg>) {
            self.members = members
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MembersGetInfoArgsSerializer().serialize(self)))"
        }
    }
    open class MembersGetInfoArgsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: MembersGetInfoArgs) -> JSON {
            let output = [
            "members": ArraySerializer(Team.UserSelectorArgSerializer()).serialize(value.members),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> MembersGetInfoArgs {
            switch json {
                case .dictionary(let dict):
                    let members = ArraySerializer(Team.UserSelectorArgSerializer()).deserialize(dict["members"] ?? .null)
                    return MembersGetInfoArgs(members: members)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The MembersGetInfoError union
    public enum MembersGetInfoError: CustomStringConvertible {
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MembersGetInfoErrorSerializer().serialize(self)))"
        }
    }
    open class MembersGetInfoErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: MembersGetInfoError) -> JSON {
            switch value {
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> MembersGetInfoError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "other":
                            return MembersGetInfoError.other
                        default:
                            return MembersGetInfoError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Describes a result obtained for a single user whose id was specified in the parameter of membersGetInfo.
    public enum MembersGetInfoItem: CustomStringConvertible {
        /// An ID that was provided as a parameter to membersGetInfo, and did not match a corresponding user. This might
        /// be a team_member_id, an email, or an external ID, depending on how the method was called.
        case idNotFound(String)
        /// Info about a team member.
        case memberInfo(Team.TeamMemberInfo)

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MembersGetInfoItemSerializer().serialize(self)))"
        }
    }
    open class MembersGetInfoItemSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: MembersGetInfoItem) -> JSON {
            switch value {
                case .idNotFound(let arg):
                    var d = ["id_not_found": Serialization._StringSerializer.serialize(arg)]
                    d[".tag"] = .str("id_not_found")
                    return .dictionary(d)
                case .memberInfo(let arg):
                    var d = Serialization.getFields(Team.TeamMemberInfoSerializer().serialize(arg))
                    d[".tag"] = .str("member_info")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> MembersGetInfoItem {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "id_not_found":
                            let v = Serialization._StringSerializer.deserialize(d["id_not_found"] ?? .null)
                            return MembersGetInfoItem.idNotFound(v)
                        case "member_info":
                            let v = Team.TeamMemberInfoSerializer().deserialize(json)
                            return MembersGetInfoItem.memberInfo(v)
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The MembersListArg struct
    open class MembersListArg: CustomStringConvertible {
        /// Number of results to return per call.
        open let limit: UInt32
        /// Whether to return removed members.
        open let includeRemoved: Bool
        public init(limit: UInt32 = 1000, includeRemoved: Bool = false) {
            comparableValidator(minValue: 1, maxValue: 1000)(limit)
            self.limit = limit
            self.includeRemoved = includeRemoved
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MembersListArgSerializer().serialize(self)))"
        }
    }
    open class MembersListArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: MembersListArg) -> JSON {
            let output = [
            "limit": Serialization._UInt32Serializer.serialize(value.limit),
            "include_removed": Serialization._BoolSerializer.serialize(value.includeRemoved),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> MembersListArg {
            switch json {
                case .dictionary(let dict):
                    let limit = Serialization._UInt32Serializer.deserialize(dict["limit"] ?? .number(1000))
                    let includeRemoved = Serialization._BoolSerializer.deserialize(dict["include_removed"] ?? .number(0))
                    return MembersListArg(limit: limit, includeRemoved: includeRemoved)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The MembersListContinueArg struct
    open class MembersListContinueArg: CustomStringConvertible {
        /// Indicates from what point to get the next set of members.
        open let cursor: String
        public init(cursor: String) {
            stringValidator()(cursor)
            self.cursor = cursor
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MembersListContinueArgSerializer().serialize(self)))"
        }
    }
    open class MembersListContinueArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: MembersListContinueArg) -> JSON {
            let output = [
            "cursor": Serialization._StringSerializer.serialize(value.cursor),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> MembersListContinueArg {
            switch json {
                case .dictionary(let dict):
                    let cursor = Serialization._StringSerializer.deserialize(dict["cursor"] ?? .null)
                    return MembersListContinueArg(cursor: cursor)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The MembersListContinueError union
    public enum MembersListContinueError: CustomStringConvertible {
        /// The cursor is invalid.
        case invalidCursor
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MembersListContinueErrorSerializer().serialize(self)))"
        }
    }
    open class MembersListContinueErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: MembersListContinueError) -> JSON {
            switch value {
                case .invalidCursor:
                    var d = [String: JSON]()
                    d[".tag"] = .str("invalid_cursor")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> MembersListContinueError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "invalid_cursor":
                            return MembersListContinueError.invalidCursor
                        case "other":
                            return MembersListContinueError.other
                        default:
                            return MembersListContinueError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The MembersListError union
    public enum MembersListError: CustomStringConvertible {
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MembersListErrorSerializer().serialize(self)))"
        }
    }
    open class MembersListErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: MembersListError) -> JSON {
            switch value {
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> MembersListError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "other":
                            return MembersListError.other
                        default:
                            return MembersListError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The MembersListResult struct
    open class MembersListResult: CustomStringConvertible {
        /// List of team members.
        open let members: Array<Team.TeamMemberInfo>
        /// Pass the cursor into membersListContinue to obtain the additional members.
        open let cursor: String
        /// Is true if there are additional team members that have not been returned yet. An additional call to
        /// membersListContinue can retrieve them.
        open let hasMore: Bool
        public init(members: Array<Team.TeamMemberInfo>, cursor: String, hasMore: Bool) {
            self.members = members
            stringValidator()(cursor)
            self.cursor = cursor
            self.hasMore = hasMore
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MembersListResultSerializer().serialize(self)))"
        }
    }
    open class MembersListResultSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: MembersListResult) -> JSON {
            let output = [
            "members": ArraySerializer(Team.TeamMemberInfoSerializer()).serialize(value.members),
            "cursor": Serialization._StringSerializer.serialize(value.cursor),
            "has_more": Serialization._BoolSerializer.serialize(value.hasMore),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> MembersListResult {
            switch json {
                case .dictionary(let dict):
                    let members = ArraySerializer(Team.TeamMemberInfoSerializer()).deserialize(dict["members"] ?? .null)
                    let cursor = Serialization._StringSerializer.deserialize(dict["cursor"] ?? .null)
                    let hasMore = Serialization._BoolSerializer.deserialize(dict["has_more"] ?? .null)
                    return MembersListResult(members: members, cursor: cursor, hasMore: hasMore)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Exactly one of team_member_id, email, or external_id must be provided to identify the user account.
    open class MembersRecoverArg: CustomStringConvertible {
        /// Identity of user to recover.
        open let user: Team.UserSelectorArg
        public init(user: Team.UserSelectorArg) {
            self.user = user
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MembersRecoverArgSerializer().serialize(self)))"
        }
    }
    open class MembersRecoverArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: MembersRecoverArg) -> JSON {
            let output = [
            "user": Team.UserSelectorArgSerializer().serialize(value.user),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> MembersRecoverArg {
            switch json {
                case .dictionary(let dict):
                    let user = Team.UserSelectorArgSerializer().deserialize(dict["user"] ?? .null)
                    return MembersRecoverArg(user: user)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The MembersRecoverError union
    public enum MembersRecoverError: CustomStringConvertible {
        /// No matching user found. The provided team_member_id, email, or external_id does not exist on this team.
        case userNotFound
        /// The user is not recoverable.
        case userUnrecoverable
        /// The user is not a member of the team.
        case userNotInTeam
        /// Team is full. The organization has no available licenses.
        case teamLicenseLimit
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MembersRecoverErrorSerializer().serialize(self)))"
        }
    }
    open class MembersRecoverErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: MembersRecoverError) -> JSON {
            switch value {
                case .userNotFound:
                    var d = [String: JSON]()
                    d[".tag"] = .str("user_not_found")
                    return .dictionary(d)
                case .userUnrecoverable:
                    var d = [String: JSON]()
                    d[".tag"] = .str("user_unrecoverable")
                    return .dictionary(d)
                case .userNotInTeam:
                    var d = [String: JSON]()
                    d[".tag"] = .str("user_not_in_team")
                    return .dictionary(d)
                case .teamLicenseLimit:
                    var d = [String: JSON]()
                    d[".tag"] = .str("team_license_limit")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> MembersRecoverError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "user_not_found":
                            return MembersRecoverError.userNotFound
                        case "user_unrecoverable":
                            return MembersRecoverError.userUnrecoverable
                        case "user_not_in_team":
                            return MembersRecoverError.userNotInTeam
                        case "team_license_limit":
                            return MembersRecoverError.teamLicenseLimit
                        case "other":
                            return MembersRecoverError.other
                        default:
                            return MembersRecoverError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The MembersRemoveArg struct
    open class MembersRemoveArg: Team.MembersDeactivateArg {
        /// If provided, files from the deleted member account will be transferred to this user.
        open let transferDestId: Team.UserSelectorArg?
        /// If provided, errors during the transfer process will be sent via email to this user. If the transfer_dest_id
        /// argument was provided, then this argument must be provided as well.
        open let transferAdminId: Team.UserSelectorArg?
        /// Downgrade the member to a Basic account. The user will retain the email address associated with their
        /// Dropbox  account and data in their account that is not restricted to team members.
        open let keepAccount: Bool
        public init(user: Team.UserSelectorArg, wipeData: Bool = true, transferDestId: Team.UserSelectorArg? = nil, transferAdminId: Team.UserSelectorArg? = nil, keepAccount: Bool = false) {
            self.transferDestId = transferDestId
            self.transferAdminId = transferAdminId
            self.keepAccount = keepAccount
            super.init(user: user, wipeData: wipeData)
        }
        open override var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MembersRemoveArgSerializer().serialize(self)))"
        }
    }
    open class MembersRemoveArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: MembersRemoveArg) -> JSON {
            let output = [
            "user": Team.UserSelectorArgSerializer().serialize(value.user),
            "wipe_data": Serialization._BoolSerializer.serialize(value.wipeData),
            "transfer_dest_id": NullableSerializer(Team.UserSelectorArgSerializer()).serialize(value.transferDestId),
            "transfer_admin_id": NullableSerializer(Team.UserSelectorArgSerializer()).serialize(value.transferAdminId),
            "keep_account": Serialization._BoolSerializer.serialize(value.keepAccount),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> MembersRemoveArg {
            switch json {
                case .dictionary(let dict):
                    let user = Team.UserSelectorArgSerializer().deserialize(dict["user"] ?? .null)
                    let wipeData = Serialization._BoolSerializer.deserialize(dict["wipe_data"] ?? .number(1))
                    let transferDestId = NullableSerializer(Team.UserSelectorArgSerializer()).deserialize(dict["transfer_dest_id"] ?? .null)
                    let transferAdminId = NullableSerializer(Team.UserSelectorArgSerializer()).deserialize(dict["transfer_admin_id"] ?? .null)
                    let keepAccount = Serialization._BoolSerializer.deserialize(dict["keep_account"] ?? .number(0))
                    return MembersRemoveArg(user: user, wipeData: wipeData, transferDestId: transferDestId, transferAdminId: transferAdminId, keepAccount: keepAccount)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The MembersRemoveError union
    public enum MembersRemoveError: CustomStringConvertible {
        /// No matching user found. The provided team_member_id, email, or external_id does not exist on this team.
        case userNotFound
        /// The user is not a member of the team.
        case userNotInTeam
        /// An unspecified error.
        case other
        /// The user is the last admin of the team, so it cannot be removed from it.
        case removeLastAdmin
        /// Expected removed user and transfer_dest user to be different
        case removedAndTransferDestShouldDiffer
        /// Expected removed user and transfer_admin user to be different.
        case removedAndTransferAdminShouldDiffer
        /// No matching user found for the argument transfer_dest_id.
        case transferDestUserNotFound
        /// The provided transfer_dest_id does not exist on this team.
        case transferDestUserNotInTeam
        /// No matching user found for the argument transfer_admin_id.
        case transferAdminUserNotFound
        /// The provided transfer_admin_id does not exist on this team.
        case transferAdminUserNotInTeam
        /// The transfer_admin_id argument must be provided when file transfer is requested.
        case unspecifiedTransferAdminId
        /// Specified transfer_admin user is not a team admin.
        case transferAdminIsNotAdmin
        /// Cannot keep account and transfer the data to another user at the same time.
        case cannotKeepAccountAndTransfer
        /// Cannot keep account and delete the data at the same time.
        case cannotKeepAccountAndDeleteData
        /// The email address of the user is too long to be disabled.
        case emailAddressTooLongToBeDisabled

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MembersRemoveErrorSerializer().serialize(self)))"
        }
    }
    open class MembersRemoveErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: MembersRemoveError) -> JSON {
            switch value {
                case .userNotFound:
                    var d = [String: JSON]()
                    d[".tag"] = .str("user_not_found")
                    return .dictionary(d)
                case .userNotInTeam:
                    var d = [String: JSON]()
                    d[".tag"] = .str("user_not_in_team")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
                case .removeLastAdmin:
                    var d = [String: JSON]()
                    d[".tag"] = .str("remove_last_admin")
                    return .dictionary(d)
                case .removedAndTransferDestShouldDiffer:
                    var d = [String: JSON]()
                    d[".tag"] = .str("removed_and_transfer_dest_should_differ")
                    return .dictionary(d)
                case .removedAndTransferAdminShouldDiffer:
                    var d = [String: JSON]()
                    d[".tag"] = .str("removed_and_transfer_admin_should_differ")
                    return .dictionary(d)
                case .transferDestUserNotFound:
                    var d = [String: JSON]()
                    d[".tag"] = .str("transfer_dest_user_not_found")
                    return .dictionary(d)
                case .transferDestUserNotInTeam:
                    var d = [String: JSON]()
                    d[".tag"] = .str("transfer_dest_user_not_in_team")
                    return .dictionary(d)
                case .transferAdminUserNotFound:
                    var d = [String: JSON]()
                    d[".tag"] = .str("transfer_admin_user_not_found")
                    return .dictionary(d)
                case .transferAdminUserNotInTeam:
                    var d = [String: JSON]()
                    d[".tag"] = .str("transfer_admin_user_not_in_team")
                    return .dictionary(d)
                case .unspecifiedTransferAdminId:
                    var d = [String: JSON]()
                    d[".tag"] = .str("unspecified_transfer_admin_id")
                    return .dictionary(d)
                case .transferAdminIsNotAdmin:
                    var d = [String: JSON]()
                    d[".tag"] = .str("transfer_admin_is_not_admin")
                    return .dictionary(d)
                case .cannotKeepAccountAndTransfer:
                    var d = [String: JSON]()
                    d[".tag"] = .str("cannot_keep_account_and_transfer")
                    return .dictionary(d)
                case .cannotKeepAccountAndDeleteData:
                    var d = [String: JSON]()
                    d[".tag"] = .str("cannot_keep_account_and_delete_data")
                    return .dictionary(d)
                case .emailAddressTooLongToBeDisabled:
                    var d = [String: JSON]()
                    d[".tag"] = .str("email_address_too_long_to_be_disabled")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> MembersRemoveError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "user_not_found":
                            return MembersRemoveError.userNotFound
                        case "user_not_in_team":
                            return MembersRemoveError.userNotInTeam
                        case "other":
                            return MembersRemoveError.other
                        case "remove_last_admin":
                            return MembersRemoveError.removeLastAdmin
                        case "removed_and_transfer_dest_should_differ":
                            return MembersRemoveError.removedAndTransferDestShouldDiffer
                        case "removed_and_transfer_admin_should_differ":
                            return MembersRemoveError.removedAndTransferAdminShouldDiffer
                        case "transfer_dest_user_not_found":
                            return MembersRemoveError.transferDestUserNotFound
                        case "transfer_dest_user_not_in_team":
                            return MembersRemoveError.transferDestUserNotInTeam
                        case "transfer_admin_user_not_found":
                            return MembersRemoveError.transferAdminUserNotFound
                        case "transfer_admin_user_not_in_team":
                            return MembersRemoveError.transferAdminUserNotInTeam
                        case "unspecified_transfer_admin_id":
                            return MembersRemoveError.unspecifiedTransferAdminId
                        case "transfer_admin_is_not_admin":
                            return MembersRemoveError.transferAdminIsNotAdmin
                        case "cannot_keep_account_and_transfer":
                            return MembersRemoveError.cannotKeepAccountAndTransfer
                        case "cannot_keep_account_and_delete_data":
                            return MembersRemoveError.cannotKeepAccountAndDeleteData
                        case "email_address_too_long_to_be_disabled":
                            return MembersRemoveError.emailAddressTooLongToBeDisabled
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The MembersSendWelcomeError union
    public enum MembersSendWelcomeError: CustomStringConvertible {
        /// No matching user found. The provided team_member_id, email, or external_id does not exist on this team.
        case userNotFound
        /// The user is not a member of the team.
        case userNotInTeam
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MembersSendWelcomeErrorSerializer().serialize(self)))"
        }
    }
    open class MembersSendWelcomeErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: MembersSendWelcomeError) -> JSON {
            switch value {
                case .userNotFound:
                    var d = [String: JSON]()
                    d[".tag"] = .str("user_not_found")
                    return .dictionary(d)
                case .userNotInTeam:
                    var d = [String: JSON]()
                    d[".tag"] = .str("user_not_in_team")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> MembersSendWelcomeError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "user_not_found":
                            return MembersSendWelcomeError.userNotFound
                        case "user_not_in_team":
                            return MembersSendWelcomeError.userNotInTeam
                        case "other":
                            return MembersSendWelcomeError.other
                        default:
                            return MembersSendWelcomeError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Exactly one of team_member_id, email, or external_id must be provided to identify the user account.
    open class MembersSetPermissionsArg: CustomStringConvertible {
        /// Identity of user whose role will be set.
        open let user: Team.UserSelectorArg
        /// The new role of the member.
        open let newRole: Team.AdminTier
        public init(user: Team.UserSelectorArg, newRole: Team.AdminTier) {
            self.user = user
            self.newRole = newRole
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MembersSetPermissionsArgSerializer().serialize(self)))"
        }
    }
    open class MembersSetPermissionsArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: MembersSetPermissionsArg) -> JSON {
            let output = [
            "user": Team.UserSelectorArgSerializer().serialize(value.user),
            "new_role": Team.AdminTierSerializer().serialize(value.newRole),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> MembersSetPermissionsArg {
            switch json {
                case .dictionary(let dict):
                    let user = Team.UserSelectorArgSerializer().deserialize(dict["user"] ?? .null)
                    let newRole = Team.AdminTierSerializer().deserialize(dict["new_role"] ?? .null)
                    return MembersSetPermissionsArg(user: user, newRole: newRole)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The MembersSetPermissionsError union
    public enum MembersSetPermissionsError: CustomStringConvertible {
        /// No matching user found. The provided team_member_id, email, or external_id does not exist on this team.
        case userNotFound
        /// Cannot remove the admin setting of the last admin.
        case lastAdmin
        /// The user is not a member of the team.
        case userNotInTeam
        /// Cannot remove/grant permissions.
        case cannotSetPermissions
        /// Team is full. The organization has no available licenses.
        case teamLicenseLimit
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MembersSetPermissionsErrorSerializer().serialize(self)))"
        }
    }
    open class MembersSetPermissionsErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: MembersSetPermissionsError) -> JSON {
            switch value {
                case .userNotFound:
                    var d = [String: JSON]()
                    d[".tag"] = .str("user_not_found")
                    return .dictionary(d)
                case .lastAdmin:
                    var d = [String: JSON]()
                    d[".tag"] = .str("last_admin")
                    return .dictionary(d)
                case .userNotInTeam:
                    var d = [String: JSON]()
                    d[".tag"] = .str("user_not_in_team")
                    return .dictionary(d)
                case .cannotSetPermissions:
                    var d = [String: JSON]()
                    d[".tag"] = .str("cannot_set_permissions")
                    return .dictionary(d)
                case .teamLicenseLimit:
                    var d = [String: JSON]()
                    d[".tag"] = .str("team_license_limit")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> MembersSetPermissionsError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "user_not_found":
                            return MembersSetPermissionsError.userNotFound
                        case "last_admin":
                            return MembersSetPermissionsError.lastAdmin
                        case "user_not_in_team":
                            return MembersSetPermissionsError.userNotInTeam
                        case "cannot_set_permissions":
                            return MembersSetPermissionsError.cannotSetPermissions
                        case "team_license_limit":
                            return MembersSetPermissionsError.teamLicenseLimit
                        case "other":
                            return MembersSetPermissionsError.other
                        default:
                            return MembersSetPermissionsError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The MembersSetPermissionsResult struct
    open class MembersSetPermissionsResult: CustomStringConvertible {
        /// The member ID of the user to which the change was applied.
        open let teamMemberId: String
        /// The role after the change.
        open let role: Team.AdminTier
        public init(teamMemberId: String, role: Team.AdminTier) {
            stringValidator()(teamMemberId)
            self.teamMemberId = teamMemberId
            self.role = role
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MembersSetPermissionsResultSerializer().serialize(self)))"
        }
    }
    open class MembersSetPermissionsResultSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: MembersSetPermissionsResult) -> JSON {
            let output = [
            "team_member_id": Serialization._StringSerializer.serialize(value.teamMemberId),
            "role": Team.AdminTierSerializer().serialize(value.role),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> MembersSetPermissionsResult {
            switch json {
                case .dictionary(let dict):
                    let teamMemberId = Serialization._StringSerializer.deserialize(dict["team_member_id"] ?? .null)
                    let role = Team.AdminTierSerializer().deserialize(dict["role"] ?? .null)
                    return MembersSetPermissionsResult(teamMemberId: teamMemberId, role: role)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Exactly one of team_member_id, email, or external_id must be provided to identify the user account. At least one
    /// of new_email, new_external_id, new_given_name, and/or new_surname must be provided.
    open class MembersSetProfileArg: CustomStringConvertible {
        /// Identity of user whose profile will be set.
        open let user: Team.UserSelectorArg
        /// New email for member.
        open let newEmail: String?
        /// New external ID for member.
        open let newExternalId: String?
        /// New given name for member.
        open let newGivenName: String?
        /// New surname for member.
        open let newSurname: String?
        public init(user: Team.UserSelectorArg, newEmail: String? = nil, newExternalId: String? = nil, newGivenName: String? = nil, newSurname: String? = nil) {
            self.user = user
            nullableValidator(stringValidator(maxLength: 255, pattern: "^['&A-Za-z0-9._%+-]+@[A-Za-z0-9-][A-Za-z0-9.-]*.[A-Za-z]{2,15}$"))(newEmail)
            self.newEmail = newEmail
            nullableValidator(stringValidator(maxLength: 64))(newExternalId)
            self.newExternalId = newExternalId
            nullableValidator(stringValidator(minLength: 1, maxLength: 100, pattern: "[^/:?*<>\"|]*"))(newGivenName)
            self.newGivenName = newGivenName
            nullableValidator(stringValidator(minLength: 1, maxLength: 100, pattern: "[^/:?*<>\"|]*"))(newSurname)
            self.newSurname = newSurname
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MembersSetProfileArgSerializer().serialize(self)))"
        }
    }
    open class MembersSetProfileArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: MembersSetProfileArg) -> JSON {
            let output = [
            "user": Team.UserSelectorArgSerializer().serialize(value.user),
            "new_email": NullableSerializer(Serialization._StringSerializer).serialize(value.newEmail),
            "new_external_id": NullableSerializer(Serialization._StringSerializer).serialize(value.newExternalId),
            "new_given_name": NullableSerializer(Serialization._StringSerializer).serialize(value.newGivenName),
            "new_surname": NullableSerializer(Serialization._StringSerializer).serialize(value.newSurname),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> MembersSetProfileArg {
            switch json {
                case .dictionary(let dict):
                    let user = Team.UserSelectorArgSerializer().deserialize(dict["user"] ?? .null)
                    let newEmail = NullableSerializer(Serialization._StringSerializer).deserialize(dict["new_email"] ?? .null)
                    let newExternalId = NullableSerializer(Serialization._StringSerializer).deserialize(dict["new_external_id"] ?? .null)
                    let newGivenName = NullableSerializer(Serialization._StringSerializer).deserialize(dict["new_given_name"] ?? .null)
                    let newSurname = NullableSerializer(Serialization._StringSerializer).deserialize(dict["new_surname"] ?? .null)
                    return MembersSetProfileArg(user: user, newEmail: newEmail, newExternalId: newExternalId, newGivenName: newGivenName, newSurname: newSurname)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The MembersSetProfileError union
    public enum MembersSetProfileError: CustomStringConvertible {
        /// No matching user found. The provided team_member_id, email, or external_id does not exist on this team.
        case userNotFound
        /// The user is not a member of the team.
        case userNotInTeam
        /// It is unsafe to use both external_id and new_external_id
        case externalIdAndNewExternalIdUnsafe
        /// None of new_email, new_given_name, new_surname, or new_external_id are specified
        case noNewDataSpecified
        /// Email is already reserved for another user.
        case emailReservedForOtherUser
        /// The external ID is already in use by another team member.
        case externalIdUsedByOtherUser
        /// Setting profile disallowed
        case setProfileDisallowed
        /// Parameter new_email cannot be empty.
        case paramCannotBeEmpty
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MembersSetProfileErrorSerializer().serialize(self)))"
        }
    }
    open class MembersSetProfileErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: MembersSetProfileError) -> JSON {
            switch value {
                case .userNotFound:
                    var d = [String: JSON]()
                    d[".tag"] = .str("user_not_found")
                    return .dictionary(d)
                case .userNotInTeam:
                    var d = [String: JSON]()
                    d[".tag"] = .str("user_not_in_team")
                    return .dictionary(d)
                case .externalIdAndNewExternalIdUnsafe:
                    var d = [String: JSON]()
                    d[".tag"] = .str("external_id_and_new_external_id_unsafe")
                    return .dictionary(d)
                case .noNewDataSpecified:
                    var d = [String: JSON]()
                    d[".tag"] = .str("no_new_data_specified")
                    return .dictionary(d)
                case .emailReservedForOtherUser:
                    var d = [String: JSON]()
                    d[".tag"] = .str("email_reserved_for_other_user")
                    return .dictionary(d)
                case .externalIdUsedByOtherUser:
                    var d = [String: JSON]()
                    d[".tag"] = .str("external_id_used_by_other_user")
                    return .dictionary(d)
                case .setProfileDisallowed:
                    var d = [String: JSON]()
                    d[".tag"] = .str("set_profile_disallowed")
                    return .dictionary(d)
                case .paramCannotBeEmpty:
                    var d = [String: JSON]()
                    d[".tag"] = .str("param_cannot_be_empty")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> MembersSetProfileError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "user_not_found":
                            return MembersSetProfileError.userNotFound
                        case "user_not_in_team":
                            return MembersSetProfileError.userNotInTeam
                        case "external_id_and_new_external_id_unsafe":
                            return MembersSetProfileError.externalIdAndNewExternalIdUnsafe
                        case "no_new_data_specified":
                            return MembersSetProfileError.noNewDataSpecified
                        case "email_reserved_for_other_user":
                            return MembersSetProfileError.emailReservedForOtherUser
                        case "external_id_used_by_other_user":
                            return MembersSetProfileError.externalIdUsedByOtherUser
                        case "set_profile_disallowed":
                            return MembersSetProfileError.setProfileDisallowed
                        case "param_cannot_be_empty":
                            return MembersSetProfileError.paramCannotBeEmpty
                        case "other":
                            return MembersSetProfileError.other
                        default:
                            return MembersSetProfileError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The MembersSuspendError union
    public enum MembersSuspendError: CustomStringConvertible {
        /// No matching user found. The provided team_member_id, email, or external_id does not exist on this team.
        case userNotFound
        /// The user is not a member of the team.
        case userNotInTeam
        /// An unspecified error.
        case other
        /// The user is not active, so it cannot be suspended.
        case suspendInactiveUser
        /// The user is the last admin of the team, so it cannot be suspended.
        case suspendLastAdmin
        /// Team is full. The organization has no available licenses.
        case teamLicenseLimit

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MembersSuspendErrorSerializer().serialize(self)))"
        }
    }
    open class MembersSuspendErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: MembersSuspendError) -> JSON {
            switch value {
                case .userNotFound:
                    var d = [String: JSON]()
                    d[".tag"] = .str("user_not_found")
                    return .dictionary(d)
                case .userNotInTeam:
                    var d = [String: JSON]()
                    d[".tag"] = .str("user_not_in_team")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
                case .suspendInactiveUser:
                    var d = [String: JSON]()
                    d[".tag"] = .str("suspend_inactive_user")
                    return .dictionary(d)
                case .suspendLastAdmin:
                    var d = [String: JSON]()
                    d[".tag"] = .str("suspend_last_admin")
                    return .dictionary(d)
                case .teamLicenseLimit:
                    var d = [String: JSON]()
                    d[".tag"] = .str("team_license_limit")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> MembersSuspendError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "user_not_found":
                            return MembersSuspendError.userNotFound
                        case "user_not_in_team":
                            return MembersSuspendError.userNotInTeam
                        case "other":
                            return MembersSuspendError.other
                        case "suspend_inactive_user":
                            return MembersSuspendError.suspendInactiveUser
                        case "suspend_last_admin":
                            return MembersSuspendError.suspendLastAdmin
                        case "team_license_limit":
                            return MembersSuspendError.teamLicenseLimit
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Exactly one of team_member_id, email, or external_id must be provided to identify the user account.
    open class MembersUnsuspendArg: CustomStringConvertible {
        /// Identity of user to unsuspend.
        open let user: Team.UserSelectorArg
        public init(user: Team.UserSelectorArg) {
            self.user = user
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MembersUnsuspendArgSerializer().serialize(self)))"
        }
    }
    open class MembersUnsuspendArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: MembersUnsuspendArg) -> JSON {
            let output = [
            "user": Team.UserSelectorArgSerializer().serialize(value.user),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> MembersUnsuspendArg {
            switch json {
                case .dictionary(let dict):
                    let user = Team.UserSelectorArgSerializer().deserialize(dict["user"] ?? .null)
                    return MembersUnsuspendArg(user: user)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The MembersUnsuspendError union
    public enum MembersUnsuspendError: CustomStringConvertible {
        /// No matching user found. The provided team_member_id, email, or external_id does not exist on this team.
        case userNotFound
        /// The user is not a member of the team.
        case userNotInTeam
        /// An unspecified error.
        case other
        /// The user is unsuspended, so it cannot be unsuspended again.
        case unsuspendNonSuspendedMember
        /// Team is full. The organization has no available licenses.
        case teamLicenseLimit

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MembersUnsuspendErrorSerializer().serialize(self)))"
        }
    }
    open class MembersUnsuspendErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: MembersUnsuspendError) -> JSON {
            switch value {
                case .userNotFound:
                    var d = [String: JSON]()
                    d[".tag"] = .str("user_not_found")
                    return .dictionary(d)
                case .userNotInTeam:
                    var d = [String: JSON]()
                    d[".tag"] = .str("user_not_in_team")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
                case .unsuspendNonSuspendedMember:
                    var d = [String: JSON]()
                    d[".tag"] = .str("unsuspend_non_suspended_member")
                    return .dictionary(d)
                case .teamLicenseLimit:
                    var d = [String: JSON]()
                    d[".tag"] = .str("team_license_limit")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> MembersUnsuspendError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "user_not_found":
                            return MembersUnsuspendError.userNotFound
                        case "user_not_in_team":
                            return MembersUnsuspendError.userNotInTeam
                        case "other":
                            return MembersUnsuspendError.other
                        case "unsuspend_non_suspended_member":
                            return MembersUnsuspendError.unsuspendNonSuspendedMember
                        case "team_license_limit":
                            return MembersUnsuspendError.teamLicenseLimit
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The MobileClientPlatform union
    public enum MobileClientPlatform: CustomStringConvertible {
        /// Official Dropbox iPhone client
        case iphone
        /// Official Dropbox iPad client
        case ipad
        /// Official Dropbox Android client
        case android
        /// Official Dropbox Windows phone client
        case windowsPhone
        /// Official Dropbox Blackberry client
        case blackberry
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MobileClientPlatformSerializer().serialize(self)))"
        }
    }
    open class MobileClientPlatformSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: MobileClientPlatform) -> JSON {
            switch value {
                case .iphone:
                    var d = [String: JSON]()
                    d[".tag"] = .str("iphone")
                    return .dictionary(d)
                case .ipad:
                    var d = [String: JSON]()
                    d[".tag"] = .str("ipad")
                    return .dictionary(d)
                case .android:
                    var d = [String: JSON]()
                    d[".tag"] = .str("android")
                    return .dictionary(d)
                case .windowsPhone:
                    var d = [String: JSON]()
                    d[".tag"] = .str("windows_phone")
                    return .dictionary(d)
                case .blackberry:
                    var d = [String: JSON]()
                    d[".tag"] = .str("blackberry")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> MobileClientPlatform {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "iphone":
                            return MobileClientPlatform.iphone
                        case "ipad":
                            return MobileClientPlatform.ipad
                        case "android":
                            return MobileClientPlatform.android
                        case "windows_phone":
                            return MobileClientPlatform.windowsPhone
                        case "blackberry":
                            return MobileClientPlatform.blackberry
                        case "other":
                            return MobileClientPlatform.other
                        default:
                            return MobileClientPlatform.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Information about linked Dropbox mobile client sessions
    open class MobileClientSession: Team.DeviceSession {
        /// The device name
        open let deviceName: String
        /// The mobile application type
        open let clientType: Team.MobileClientPlatform
        /// The dropbox client version
        open let clientVersion: String?
        /// The hosting OS version
        open let osVersion: String?
        /// last carrier used by the device
        open let lastCarrier: String?
        public init(sessionId: String, deviceName: String, clientType: Team.MobileClientPlatform, ipAddress: String? = nil, country: String? = nil, created: Date? = nil, updated: Date? = nil, clientVersion: String? = nil, osVersion: String? = nil, lastCarrier: String? = nil) {
            stringValidator()(deviceName)
            self.deviceName = deviceName
            self.clientType = clientType
            nullableValidator(stringValidator())(clientVersion)
            self.clientVersion = clientVersion
            nullableValidator(stringValidator())(osVersion)
            self.osVersion = osVersion
            nullableValidator(stringValidator())(lastCarrier)
            self.lastCarrier = lastCarrier
            super.init(sessionId: sessionId, ipAddress: ipAddress, country: country, created: created, updated: updated)
        }
        open override var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MobileClientSessionSerializer().serialize(self)))"
        }
    }
    open class MobileClientSessionSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: MobileClientSession) -> JSON {
            let output = [
            "session_id": Serialization._StringSerializer.serialize(value.sessionId),
            "device_name": Serialization._StringSerializer.serialize(value.deviceName),
            "client_type": Team.MobileClientPlatformSerializer().serialize(value.clientType),
            "ip_address": NullableSerializer(Serialization._StringSerializer).serialize(value.ipAddress),
            "country": NullableSerializer(Serialization._StringSerializer).serialize(value.country),
            "created": NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.created),
            "updated": NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.updated),
            "client_version": NullableSerializer(Serialization._StringSerializer).serialize(value.clientVersion),
            "os_version": NullableSerializer(Serialization._StringSerializer).serialize(value.osVersion),
            "last_carrier": NullableSerializer(Serialization._StringSerializer).serialize(value.lastCarrier),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> MobileClientSession {
            switch json {
                case .dictionary(let dict):
                    let sessionId = Serialization._StringSerializer.deserialize(dict["session_id"] ?? .null)
                    let deviceName = Serialization._StringSerializer.deserialize(dict["device_name"] ?? .null)
                    let clientType = Team.MobileClientPlatformSerializer().deserialize(dict["client_type"] ?? .null)
                    let ipAddress = NullableSerializer(Serialization._StringSerializer).deserialize(dict["ip_address"] ?? .null)
                    let country = NullableSerializer(Serialization._StringSerializer).deserialize(dict["country"] ?? .null)
                    let created = NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).deserialize(dict["created"] ?? .null)
                    let updated = NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).deserialize(dict["updated"] ?? .null)
                    let clientVersion = NullableSerializer(Serialization._StringSerializer).deserialize(dict["client_version"] ?? .null)
                    let osVersion = NullableSerializer(Serialization._StringSerializer).deserialize(dict["os_version"] ?? .null)
                    let lastCarrier = NullableSerializer(Serialization._StringSerializer).deserialize(dict["last_carrier"] ?? .null)
                    return MobileClientSession(sessionId: sessionId, deviceName: deviceName, clientType: clientType, ipAddress: ipAddress, country: country, created: created, updated: updated, clientVersion: clientVersion, osVersion: osVersion, lastCarrier: lastCarrier)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The RemovedStatus struct
    open class RemovedStatus: CustomStringConvertible {
        /// True if the removed team member is recoverable
        open let isRecoverable: Bool
        public init(isRecoverable: Bool) {
            self.isRecoverable = isRecoverable
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(RemovedStatusSerializer().serialize(self)))"
        }
    }
    open class RemovedStatusSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: RemovedStatus) -> JSON {
            let output = [
            "is_recoverable": Serialization._BoolSerializer.serialize(value.isRecoverable),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> RemovedStatus {
            switch json {
                case .dictionary(let dict):
                    let isRecoverable = Serialization._BoolSerializer.deserialize(dict["is_recoverable"] ?? .null)
                    return RemovedStatus(isRecoverable: isRecoverable)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The RevokeDesktopClientArg struct
    open class RevokeDesktopClientArg: Team.DeviceSessionArg {
        /// Whether to delete all files of the account (this is possible only if supported by the desktop client and
        /// will be made the next time the client access the account)
        open let deleteOnUnlink: Bool
        public init(sessionId: String, teamMemberId: String, deleteOnUnlink: Bool = false) {
            self.deleteOnUnlink = deleteOnUnlink
            super.init(sessionId: sessionId, teamMemberId: teamMemberId)
        }
        open override var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(RevokeDesktopClientArgSerializer().serialize(self)))"
        }
    }
    open class RevokeDesktopClientArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: RevokeDesktopClientArg) -> JSON {
            let output = [
            "session_id": Serialization._StringSerializer.serialize(value.sessionId),
            "team_member_id": Serialization._StringSerializer.serialize(value.teamMemberId),
            "delete_on_unlink": Serialization._BoolSerializer.serialize(value.deleteOnUnlink),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> RevokeDesktopClientArg {
            switch json {
                case .dictionary(let dict):
                    let sessionId = Serialization._StringSerializer.deserialize(dict["session_id"] ?? .null)
                    let teamMemberId = Serialization._StringSerializer.deserialize(dict["team_member_id"] ?? .null)
                    let deleteOnUnlink = Serialization._BoolSerializer.deserialize(dict["delete_on_unlink"] ?? .number(0))
                    return RevokeDesktopClientArg(sessionId: sessionId, teamMemberId: teamMemberId, deleteOnUnlink: deleteOnUnlink)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The RevokeDeviceSessionArg union
    public enum RevokeDeviceSessionArg: CustomStringConvertible {
        /// End an active session
        case webSession(Team.DeviceSessionArg)
        /// Unlink a linked desktop device
        case desktopClient(Team.RevokeDesktopClientArg)
        /// Unlink a linked mobile device
        case mobileClient(Team.DeviceSessionArg)

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(RevokeDeviceSessionArgSerializer().serialize(self)))"
        }
    }
    open class RevokeDeviceSessionArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: RevokeDeviceSessionArg) -> JSON {
            switch value {
                case .webSession(let arg):
                    var d = Serialization.getFields(Team.DeviceSessionArgSerializer().serialize(arg))
                    d[".tag"] = .str("web_session")
                    return .dictionary(d)
                case .desktopClient(let arg):
                    var d = Serialization.getFields(Team.RevokeDesktopClientArgSerializer().serialize(arg))
                    d[".tag"] = .str("desktop_client")
                    return .dictionary(d)
                case .mobileClient(let arg):
                    var d = Serialization.getFields(Team.DeviceSessionArgSerializer().serialize(arg))
                    d[".tag"] = .str("mobile_client")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> RevokeDeviceSessionArg {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "web_session":
                            let v = Team.DeviceSessionArgSerializer().deserialize(json)
                            return RevokeDeviceSessionArg.webSession(v)
                        case "desktop_client":
                            let v = Team.RevokeDesktopClientArgSerializer().deserialize(json)
                            return RevokeDeviceSessionArg.desktopClient(v)
                        case "mobile_client":
                            let v = Team.DeviceSessionArgSerializer().deserialize(json)
                            return RevokeDeviceSessionArg.mobileClient(v)
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The RevokeDeviceSessionBatchArg struct
    open class RevokeDeviceSessionBatchArg: CustomStringConvertible {
        /// (no description)
        open let revokeDevices: Array<Team.RevokeDeviceSessionArg>
        public init(revokeDevices: Array<Team.RevokeDeviceSessionArg>) {
            self.revokeDevices = revokeDevices
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(RevokeDeviceSessionBatchArgSerializer().serialize(self)))"
        }
    }
    open class RevokeDeviceSessionBatchArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: RevokeDeviceSessionBatchArg) -> JSON {
            let output = [
            "revoke_devices": ArraySerializer(Team.RevokeDeviceSessionArgSerializer()).serialize(value.revokeDevices),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> RevokeDeviceSessionBatchArg {
            switch json {
                case .dictionary(let dict):
                    let revokeDevices = ArraySerializer(Team.RevokeDeviceSessionArgSerializer()).deserialize(dict["revoke_devices"] ?? .null)
                    return RevokeDeviceSessionBatchArg(revokeDevices: revokeDevices)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The RevokeDeviceSessionBatchError union
    public enum RevokeDeviceSessionBatchError: CustomStringConvertible {
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(RevokeDeviceSessionBatchErrorSerializer().serialize(self)))"
        }
    }
    open class RevokeDeviceSessionBatchErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: RevokeDeviceSessionBatchError) -> JSON {
            switch value {
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> RevokeDeviceSessionBatchError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "other":
                            return RevokeDeviceSessionBatchError.other
                        default:
                            return RevokeDeviceSessionBatchError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The RevokeDeviceSessionBatchResult struct
    open class RevokeDeviceSessionBatchResult: CustomStringConvertible {
        /// (no description)
        open let revokeDevicesStatus: Array<Team.RevokeDeviceSessionStatus>
        public init(revokeDevicesStatus: Array<Team.RevokeDeviceSessionStatus>) {
            self.revokeDevicesStatus = revokeDevicesStatus
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(RevokeDeviceSessionBatchResultSerializer().serialize(self)))"
        }
    }
    open class RevokeDeviceSessionBatchResultSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: RevokeDeviceSessionBatchResult) -> JSON {
            let output = [
            "revoke_devices_status": ArraySerializer(Team.RevokeDeviceSessionStatusSerializer()).serialize(value.revokeDevicesStatus),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> RevokeDeviceSessionBatchResult {
            switch json {
                case .dictionary(let dict):
                    let revokeDevicesStatus = ArraySerializer(Team.RevokeDeviceSessionStatusSerializer()).deserialize(dict["revoke_devices_status"] ?? .null)
                    return RevokeDeviceSessionBatchResult(revokeDevicesStatus: revokeDevicesStatus)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The RevokeDeviceSessionError union
    public enum RevokeDeviceSessionError: CustomStringConvertible {
        /// Device session not found.
        case deviceSessionNotFound
        /// Member not found.
        case memberNotFound
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(RevokeDeviceSessionErrorSerializer().serialize(self)))"
        }
    }
    open class RevokeDeviceSessionErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: RevokeDeviceSessionError) -> JSON {
            switch value {
                case .deviceSessionNotFound:
                    var d = [String: JSON]()
                    d[".tag"] = .str("device_session_not_found")
                    return .dictionary(d)
                case .memberNotFound:
                    var d = [String: JSON]()
                    d[".tag"] = .str("member_not_found")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> RevokeDeviceSessionError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "device_session_not_found":
                            return RevokeDeviceSessionError.deviceSessionNotFound
                        case "member_not_found":
                            return RevokeDeviceSessionError.memberNotFound
                        case "other":
                            return RevokeDeviceSessionError.other
                        default:
                            return RevokeDeviceSessionError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The RevokeDeviceSessionStatus struct
    open class RevokeDeviceSessionStatus: CustomStringConvertible {
        /// Result of the revoking request
        open let success: Bool
        /// The error cause in case of a failure
        open let errorType: Team.RevokeDeviceSessionError?
        public init(success: Bool, errorType: Team.RevokeDeviceSessionError? = nil) {
            self.success = success
            self.errorType = errorType
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(RevokeDeviceSessionStatusSerializer().serialize(self)))"
        }
    }
    open class RevokeDeviceSessionStatusSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: RevokeDeviceSessionStatus) -> JSON {
            let output = [
            "success": Serialization._BoolSerializer.serialize(value.success),
            "error_type": NullableSerializer(Team.RevokeDeviceSessionErrorSerializer()).serialize(value.errorType),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> RevokeDeviceSessionStatus {
            switch json {
                case .dictionary(let dict):
                    let success = Serialization._BoolSerializer.deserialize(dict["success"] ?? .null)
                    let errorType = NullableSerializer(Team.RevokeDeviceSessionErrorSerializer()).deserialize(dict["error_type"] ?? .null)
                    return RevokeDeviceSessionStatus(success: success, errorType: errorType)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The RevokeLinkedApiAppArg struct
    open class RevokeLinkedApiAppArg: CustomStringConvertible {
        /// The application's unique id
        open let appId: String
        /// The unique id of the member owning the device
        open let teamMemberId: String
        /// Whether to keep the application dedicated folder (in case the application uses  one)
        open let keepAppFolder: Bool
        public init(appId: String, teamMemberId: String, keepAppFolder: Bool = true) {
            stringValidator()(appId)
            self.appId = appId
            stringValidator()(teamMemberId)
            self.teamMemberId = teamMemberId
            self.keepAppFolder = keepAppFolder
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(RevokeLinkedApiAppArgSerializer().serialize(self)))"
        }
    }
    open class RevokeLinkedApiAppArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: RevokeLinkedApiAppArg) -> JSON {
            let output = [
            "app_id": Serialization._StringSerializer.serialize(value.appId),
            "team_member_id": Serialization._StringSerializer.serialize(value.teamMemberId),
            "keep_app_folder": Serialization._BoolSerializer.serialize(value.keepAppFolder),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> RevokeLinkedApiAppArg {
            switch json {
                case .dictionary(let dict):
                    let appId = Serialization._StringSerializer.deserialize(dict["app_id"] ?? .null)
                    let teamMemberId = Serialization._StringSerializer.deserialize(dict["team_member_id"] ?? .null)
                    let keepAppFolder = Serialization._BoolSerializer.deserialize(dict["keep_app_folder"] ?? .number(1))
                    return RevokeLinkedApiAppArg(appId: appId, teamMemberId: teamMemberId, keepAppFolder: keepAppFolder)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The RevokeLinkedApiAppBatchArg struct
    open class RevokeLinkedApiAppBatchArg: CustomStringConvertible {
        /// (no description)
        open let revokeLinkedApp: Array<Team.RevokeLinkedApiAppArg>
        public init(revokeLinkedApp: Array<Team.RevokeLinkedApiAppArg>) {
            self.revokeLinkedApp = revokeLinkedApp
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(RevokeLinkedApiAppBatchArgSerializer().serialize(self)))"
        }
    }
    open class RevokeLinkedApiAppBatchArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: RevokeLinkedApiAppBatchArg) -> JSON {
            let output = [
            "revoke_linked_app": ArraySerializer(Team.RevokeLinkedApiAppArgSerializer()).serialize(value.revokeLinkedApp),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> RevokeLinkedApiAppBatchArg {
            switch json {
                case .dictionary(let dict):
                    let revokeLinkedApp = ArraySerializer(Team.RevokeLinkedApiAppArgSerializer()).deserialize(dict["revoke_linked_app"] ?? .null)
                    return RevokeLinkedApiAppBatchArg(revokeLinkedApp: revokeLinkedApp)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Error returned by linkedAppsRevokeLinkedAppBatch.
    public enum RevokeLinkedAppBatchError: CustomStringConvertible {
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(RevokeLinkedAppBatchErrorSerializer().serialize(self)))"
        }
    }
    open class RevokeLinkedAppBatchErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: RevokeLinkedAppBatchError) -> JSON {
            switch value {
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> RevokeLinkedAppBatchError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "other":
                            return RevokeLinkedAppBatchError.other
                        default:
                            return RevokeLinkedAppBatchError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The RevokeLinkedAppBatchResult struct
    open class RevokeLinkedAppBatchResult: CustomStringConvertible {
        /// (no description)
        open let revokeLinkedAppStatus: Array<Team.RevokeLinkedAppStatus>
        public init(revokeLinkedAppStatus: Array<Team.RevokeLinkedAppStatus>) {
            self.revokeLinkedAppStatus = revokeLinkedAppStatus
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(RevokeLinkedAppBatchResultSerializer().serialize(self)))"
        }
    }
    open class RevokeLinkedAppBatchResultSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: RevokeLinkedAppBatchResult) -> JSON {
            let output = [
            "revoke_linked_app_status": ArraySerializer(Team.RevokeLinkedAppStatusSerializer()).serialize(value.revokeLinkedAppStatus),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> RevokeLinkedAppBatchResult {
            switch json {
                case .dictionary(let dict):
                    let revokeLinkedAppStatus = ArraySerializer(Team.RevokeLinkedAppStatusSerializer()).deserialize(dict["revoke_linked_app_status"] ?? .null)
                    return RevokeLinkedAppBatchResult(revokeLinkedAppStatus: revokeLinkedAppStatus)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Error returned by linkedAppsRevokeLinkedApp.
    public enum RevokeLinkedAppError: CustomStringConvertible {
        /// Application not found.
        case appNotFound
        /// Member not found.
        case memberNotFound
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(RevokeLinkedAppErrorSerializer().serialize(self)))"
        }
    }
    open class RevokeLinkedAppErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: RevokeLinkedAppError) -> JSON {
            switch value {
                case .appNotFound:
                    var d = [String: JSON]()
                    d[".tag"] = .str("app_not_found")
                    return .dictionary(d)
                case .memberNotFound:
                    var d = [String: JSON]()
                    d[".tag"] = .str("member_not_found")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> RevokeLinkedAppError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "app_not_found":
                            return RevokeLinkedAppError.appNotFound
                        case "member_not_found":
                            return RevokeLinkedAppError.memberNotFound
                        case "other":
                            return RevokeLinkedAppError.other
                        default:
                            return RevokeLinkedAppError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The RevokeLinkedAppStatus struct
    open class RevokeLinkedAppStatus: CustomStringConvertible {
        /// Result of the revoking request
        open let success: Bool
        /// The error cause in case of a failure
        open let errorType: Team.RevokeLinkedAppError?
        public init(success: Bool, errorType: Team.RevokeLinkedAppError? = nil) {
            self.success = success
            self.errorType = errorType
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(RevokeLinkedAppStatusSerializer().serialize(self)))"
        }
    }
    open class RevokeLinkedAppStatusSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: RevokeLinkedAppStatus) -> JSON {
            let output = [
            "success": Serialization._BoolSerializer.serialize(value.success),
            "error_type": NullableSerializer(Team.RevokeLinkedAppErrorSerializer()).serialize(value.errorType),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> RevokeLinkedAppStatus {
            switch json {
                case .dictionary(let dict):
                    let success = Serialization._BoolSerializer.deserialize(dict["success"] ?? .null)
                    let errorType = NullableSerializer(Team.RevokeLinkedAppErrorSerializer()).deserialize(dict["error_type"] ?? .null)
                    return RevokeLinkedAppStatus(success: success, errorType: errorType)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Describes the number of users in a specific storage bucket.
    open class StorageBucket: CustomStringConvertible {
        /// The name of the storage bucket. For example, '1G' is a bucket of users with storage size up to 1 Giga.
        open let bucket: String
        /// The number of people whose storage is in the range of this storage bucket.
        open let users: UInt64
        public init(bucket: String, users: UInt64) {
            stringValidator()(bucket)
            self.bucket = bucket
            comparableValidator()(users)
            self.users = users
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(StorageBucketSerializer().serialize(self)))"
        }
    }
    open class StorageBucketSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: StorageBucket) -> JSON {
            let output = [
            "bucket": Serialization._StringSerializer.serialize(value.bucket),
            "users": Serialization._UInt64Serializer.serialize(value.users),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> StorageBucket {
            switch json {
                case .dictionary(let dict):
                    let bucket = Serialization._StringSerializer.deserialize(dict["bucket"] ?? .null)
                    let users = Serialization._UInt64Serializer.deserialize(dict["users"] ?? .null)
                    return StorageBucket(bucket: bucket, users: users)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The TeamGetInfoResult struct
    open class TeamGetInfoResult: CustomStringConvertible {
        /// The name of the team.
        open let name: String
        /// The ID of the team.
        open let teamId: String
        /// The number of licenses available to the team.
        open let numLicensedUsers: UInt32
        /// The number of accounts that have been invited or are already active members of the team.
        open let numProvisionedUsers: UInt32
        /// (no description)
        open let policies: TeamPolicies.TeamMemberPolicies
        public init(name: String, teamId: String, numLicensedUsers: UInt32, numProvisionedUsers: UInt32, policies: TeamPolicies.TeamMemberPolicies) {
            stringValidator()(name)
            self.name = name
            stringValidator()(teamId)
            self.teamId = teamId
            comparableValidator()(numLicensedUsers)
            self.numLicensedUsers = numLicensedUsers
            comparableValidator()(numProvisionedUsers)
            self.numProvisionedUsers = numProvisionedUsers
            self.policies = policies
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(TeamGetInfoResultSerializer().serialize(self)))"
        }
    }
    open class TeamGetInfoResultSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: TeamGetInfoResult) -> JSON {
            let output = [
            "name": Serialization._StringSerializer.serialize(value.name),
            "team_id": Serialization._StringSerializer.serialize(value.teamId),
            "num_licensed_users": Serialization._UInt32Serializer.serialize(value.numLicensedUsers),
            "num_provisioned_users": Serialization._UInt32Serializer.serialize(value.numProvisionedUsers),
            "policies": TeamPolicies.TeamMemberPoliciesSerializer().serialize(value.policies),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> TeamGetInfoResult {
            switch json {
                case .dictionary(let dict):
                    let name = Serialization._StringSerializer.deserialize(dict["name"] ?? .null)
                    let teamId = Serialization._StringSerializer.deserialize(dict["team_id"] ?? .null)
                    let numLicensedUsers = Serialization._UInt32Serializer.deserialize(dict["num_licensed_users"] ?? .null)
                    let numProvisionedUsers = Serialization._UInt32Serializer.deserialize(dict["num_provisioned_users"] ?? .null)
                    let policies = TeamPolicies.TeamMemberPoliciesSerializer().deserialize(dict["policies"] ?? .null)
                    return TeamGetInfoResult(name: name, teamId: teamId, numLicensedUsers: numLicensedUsers, numProvisionedUsers: numProvisionedUsers, policies: policies)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Information about a team member.
    open class TeamMemberInfo: CustomStringConvertible {
        /// Profile of a user as a member of a team.
        open let profile: Team.TeamMemberProfile
        /// The user's role in the team.
        open let role: Team.AdminTier
        public init(profile: Team.TeamMemberProfile, role: Team.AdminTier) {
            self.profile = profile
            self.role = role
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(TeamMemberInfoSerializer().serialize(self)))"
        }
    }
    open class TeamMemberInfoSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: TeamMemberInfo) -> JSON {
            let output = [
            "profile": Team.TeamMemberProfileSerializer().serialize(value.profile),
            "role": Team.AdminTierSerializer().serialize(value.role),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> TeamMemberInfo {
            switch json {
                case .dictionary(let dict):
                    let profile = Team.TeamMemberProfileSerializer().deserialize(dict["profile"] ?? .null)
                    let role = Team.AdminTierSerializer().deserialize(dict["role"] ?? .null)
                    return TeamMemberInfo(profile: profile, role: role)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Profile of a user as a member of a team.
    open class TeamMemberProfile: Team.MemberProfile {
        /// List of group IDs of groups that the user belongs to.
        open let groups: Array<String>
        public init(teamMemberId: String, email: String, emailVerified: Bool, status: Team.TeamMemberStatus, name: Users.Name, membershipType: Team.TeamMembershipType, groups: Array<String>, externalId: String? = nil, accountId: String? = nil) {
            arrayValidator(itemValidator: stringValidator())(groups)
            self.groups = groups
            super.init(teamMemberId: teamMemberId, email: email, emailVerified: emailVerified, status: status, name: name, membershipType: membershipType, externalId: externalId, accountId: accountId)
        }
        open override var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(TeamMemberProfileSerializer().serialize(self)))"
        }
    }
    open class TeamMemberProfileSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: TeamMemberProfile) -> JSON {
            let output = [
            "team_member_id": Serialization._StringSerializer.serialize(value.teamMemberId),
            "email": Serialization._StringSerializer.serialize(value.email),
            "email_verified": Serialization._BoolSerializer.serialize(value.emailVerified),
            "status": Team.TeamMemberStatusSerializer().serialize(value.status),
            "name": Users.NameSerializer().serialize(value.name),
            "membership_type": Team.TeamMembershipTypeSerializer().serialize(value.membershipType),
            "groups": ArraySerializer(Serialization._StringSerializer).serialize(value.groups),
            "external_id": NullableSerializer(Serialization._StringSerializer).serialize(value.externalId),
            "account_id": NullableSerializer(Serialization._StringSerializer).serialize(value.accountId),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> TeamMemberProfile {
            switch json {
                case .dictionary(let dict):
                    let teamMemberId = Serialization._StringSerializer.deserialize(dict["team_member_id"] ?? .null)
                    let email = Serialization._StringSerializer.deserialize(dict["email"] ?? .null)
                    let emailVerified = Serialization._BoolSerializer.deserialize(dict["email_verified"] ?? .null)
                    let status = Team.TeamMemberStatusSerializer().deserialize(dict["status"] ?? .null)
                    let name = Users.NameSerializer().deserialize(dict["name"] ?? .null)
                    let membershipType = Team.TeamMembershipTypeSerializer().deserialize(dict["membership_type"] ?? .null)
                    let groups = ArraySerializer(Serialization._StringSerializer).deserialize(dict["groups"] ?? .null)
                    let externalId = NullableSerializer(Serialization._StringSerializer).deserialize(dict["external_id"] ?? .null)
                    let accountId = NullableSerializer(Serialization._StringSerializer).deserialize(dict["account_id"] ?? .null)
                    return TeamMemberProfile(teamMemberId: teamMemberId, email: email, emailVerified: emailVerified, status: status, name: name, membershipType: membershipType, groups: groups, externalId: externalId, accountId: accountId)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The user's status as a member of a specific team.
    public enum TeamMemberStatus: CustomStringConvertible {
        /// User has successfully joined the team.
        case active
        /// User has been invited to a team, but has not joined the team yet.
        case invited
        /// User is no longer a member of the team, but the account can be un-suspended, re-establishing the user as a
        /// team member.
        case suspended
        /// User is no longer a member of the team. Removed users are only listed when include_removed is true in
        /// members/list.
        case removed(Team.RemovedStatus)

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(TeamMemberStatusSerializer().serialize(self)))"
        }
    }
    open class TeamMemberStatusSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: TeamMemberStatus) -> JSON {
            switch value {
                case .active:
                    var d = [String: JSON]()
                    d[".tag"] = .str("active")
                    return .dictionary(d)
                case .invited:
                    var d = [String: JSON]()
                    d[".tag"] = .str("invited")
                    return .dictionary(d)
                case .suspended:
                    var d = [String: JSON]()
                    d[".tag"] = .str("suspended")
                    return .dictionary(d)
                case .removed(let arg):
                    var d = Serialization.getFields(Team.RemovedStatusSerializer().serialize(arg))
                    d[".tag"] = .str("removed")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> TeamMemberStatus {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "active":
                            return TeamMemberStatus.active
                        case "invited":
                            return TeamMemberStatus.invited
                        case "suspended":
                            return TeamMemberStatus.suspended
                        case "removed":
                            let v = Team.RemovedStatusSerializer().deserialize(json)
                            return TeamMemberStatus.removed(v)
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The TeamMembershipType union
    public enum TeamMembershipType: CustomStringConvertible {
        /// User uses a license and has full access to team resources like the shared quota.
        case full
        /// User does not have access to the shared quota and team admins have restricted administrative control.
        case limited

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(TeamMembershipTypeSerializer().serialize(self)))"
        }
    }
    open class TeamMembershipTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: TeamMembershipType) -> JSON {
            switch value {
                case .full:
                    var d = [String: JSON]()
                    d[".tag"] = .str("full")
                    return .dictionary(d)
                case .limited:
                    var d = [String: JSON]()
                    d[".tag"] = .str("limited")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> TeamMembershipType {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "full":
                            return TeamMembershipType.full
                        case "limited":
                            return TeamMembershipType.limited
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The UpdatePropertyTemplateArg struct
    open class UpdatePropertyTemplateArg: CustomStringConvertible {
        /// An identifier for property template added by propertiesTemplateAdd.
        open let templateId: String
        /// A display name for the property template. Property template names can be up to 256 bytes.
        open let name: String?
        /// Description for new property template. Property template descriptions can be up to 1024 bytes.
        open let description_: String?
        /// This is a list of custom properties to add to the property template. There can be up to 64 properties in a
        /// single property template.
        open let addFields: Array<Properties.PropertyFieldTemplate>?
        public init(templateId: String, name: String? = nil, description_: String? = nil, addFields: Array<Properties.PropertyFieldTemplate>? = nil) {
            stringValidator(minLength: 1, pattern: "(/|ptid:).*")(templateId)
            self.templateId = templateId
            nullableValidator(stringValidator())(name)
            self.name = name
            nullableValidator(stringValidator())(description_)
            self.description_ = description_
            self.addFields = addFields
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(UpdatePropertyTemplateArgSerializer().serialize(self)))"
        }
    }
    open class UpdatePropertyTemplateArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: UpdatePropertyTemplateArg) -> JSON {
            let output = [
            "template_id": Serialization._StringSerializer.serialize(value.templateId),
            "name": NullableSerializer(Serialization._StringSerializer).serialize(value.name),
            "description": NullableSerializer(Serialization._StringSerializer).serialize(value.description_),
            "add_fields": NullableSerializer(ArraySerializer(Properties.PropertyFieldTemplateSerializer())).serialize(value.addFields),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> UpdatePropertyTemplateArg {
            switch json {
                case .dictionary(let dict):
                    let templateId = Serialization._StringSerializer.deserialize(dict["template_id"] ?? .null)
                    let name = NullableSerializer(Serialization._StringSerializer).deserialize(dict["name"] ?? .null)
                    let description_ = NullableSerializer(Serialization._StringSerializer).deserialize(dict["description"] ?? .null)
                    let addFields = NullableSerializer(ArraySerializer(Properties.PropertyFieldTemplateSerializer())).deserialize(dict["add_fields"] ?? .null)
                    return UpdatePropertyTemplateArg(templateId: templateId, name: name, description_: description_, addFields: addFields)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The UpdatePropertyTemplateResult struct
    open class UpdatePropertyTemplateResult: CustomStringConvertible {
        /// An identifier for property template added by propertiesTemplateAdd.
        open let templateId: String
        public init(templateId: String) {
            stringValidator(minLength: 1, pattern: "(/|ptid:).*")(templateId)
            self.templateId = templateId
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(UpdatePropertyTemplateResultSerializer().serialize(self)))"
        }
    }
    open class UpdatePropertyTemplateResultSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: UpdatePropertyTemplateResult) -> JSON {
            let output = [
            "template_id": Serialization._StringSerializer.serialize(value.templateId),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> UpdatePropertyTemplateResult {
            switch json {
                case .dictionary(let dict):
                    let templateId = Serialization._StringSerializer.deserialize(dict["template_id"] ?? .null)
                    return UpdatePropertyTemplateResult(templateId: templateId)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Argument for selecting a single user, either by team_member_id, external_id or email.
    public enum UserSelectorArg: CustomStringConvertible {
        /// An unspecified error.
        case teamMemberId(String)
        /// An unspecified error.
        case externalId(String)
        /// An unspecified error.
        case email(String)

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(UserSelectorArgSerializer().serialize(self)))"
        }
    }
    open class UserSelectorArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: UserSelectorArg) -> JSON {
            switch value {
                case .teamMemberId(let arg):
                    var d = ["team_member_id": Serialization._StringSerializer.serialize(arg)]
                    d[".tag"] = .str("team_member_id")
                    return .dictionary(d)
                case .externalId(let arg):
                    var d = ["external_id": Serialization._StringSerializer.serialize(arg)]
                    d[".tag"] = .str("external_id")
                    return .dictionary(d)
                case .email(let arg):
                    var d = ["email": Serialization._StringSerializer.serialize(arg)]
                    d[".tag"] = .str("email")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> UserSelectorArg {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "team_member_id":
                            let v = Serialization._StringSerializer.deserialize(d["team_member_id"] ?? .null)
                            return UserSelectorArg.teamMemberId(v)
                        case "external_id":
                            let v = Serialization._StringSerializer.deserialize(d["external_id"] ?? .null)
                            return UserSelectorArg.externalId(v)
                        case "email":
                            let v = Serialization._StringSerializer.deserialize(d["email"] ?? .null)
                            return UserSelectorArg.email(v)
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Argument for selecting a list of users, either by team_member_ids, external_ids or emails.
    public enum UsersSelectorArg: CustomStringConvertible {
        /// List of member IDs.
        case teamMemberIds(Array<String>)
        /// List of external user IDs.
        case externalIds(Array<String>)
        /// List of email addresses.
        case emails(Array<String>)

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(UsersSelectorArgSerializer().serialize(self)))"
        }
    }
    open class UsersSelectorArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: UsersSelectorArg) -> JSON {
            switch value {
                case .teamMemberIds(let arg):
                    var d = ["team_member_ids": ArraySerializer(Serialization._StringSerializer).serialize(arg)]
                    d[".tag"] = .str("team_member_ids")
                    return .dictionary(d)
                case .externalIds(let arg):
                    var d = ["external_ids": ArraySerializer(Serialization._StringSerializer).serialize(arg)]
                    d[".tag"] = .str("external_ids")
                    return .dictionary(d)
                case .emails(let arg):
                    var d = ["emails": ArraySerializer(Serialization._StringSerializer).serialize(arg)]
                    d[".tag"] = .str("emails")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> UsersSelectorArg {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "team_member_ids":
                            let v = ArraySerializer(Serialization._StringSerializer).deserialize(d["team_member_ids"] ?? .null)
                            return UsersSelectorArg.teamMemberIds(v)
                        case "external_ids":
                            let v = ArraySerializer(Serialization._StringSerializer).deserialize(d["external_ids"] ?? .null)
                            return UsersSelectorArg.externalIds(v)
                        case "emails":
                            let v = ArraySerializer(Serialization._StringSerializer).deserialize(d["emails"] ?? .null)
                            return UsersSelectorArg.emails(v)
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }


    /// Stone Route Objects

    static let alphaGroupsCreate = Route(
        name: "alpha/groups/create",
        namespace: "team",
        deprecated: false,
        argSerializer: Team.GroupCreateArgSerializer(),
        responseSerializer: Team.GroupFullInfoSerializer(),
        errorSerializer: Team.GroupCreateErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let alphaGroupsGetInfo = Route(
        name: "alpha/groups/get_info",
        namespace: "team",
        deprecated: false,
        argSerializer: Team.GroupsSelectorSerializer(),
        responseSerializer: ArraySerializer(Team.GroupsGetInfoItemSerializer()),
        errorSerializer: Team.GroupsGetInfoErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let alphaGroupsList = Route(
        name: "alpha/groups/list",
        namespace: "team",
        deprecated: false,
        argSerializer: Team.GroupsListArgSerializer(),
        responseSerializer: Team.GroupsListResultSerializer(),
        errorSerializer: Serialization._VoidSerializer,
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let alphaGroupsListContinue = Route(
        name: "alpha/groups/list/continue",
        namespace: "team",
        deprecated: false,
        argSerializer: Team.GroupsListContinueArgSerializer(),
        responseSerializer: Team.GroupsListResultSerializer(),
        errorSerializer: Team.GroupsListContinueErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let alphaGroupsUpdate = Route(
        name: "alpha/groups/update",
        namespace: "team",
        deprecated: false,
        argSerializer: Team.GroupUpdateArgsSerializer(),
        responseSerializer: Team.GroupFullInfoSerializer(),
        errorSerializer: Team.GroupUpdateErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let devicesListMemberDevices = Route(
        name: "devices/list_member_devices",
        namespace: "team",
        deprecated: false,
        argSerializer: Team.ListMemberDevicesArgSerializer(),
        responseSerializer: Team.ListMemberDevicesResultSerializer(),
        errorSerializer: Team.ListMemberDevicesErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let devicesListMembersDevices = Route(
        name: "devices/list_members_devices",
        namespace: "team",
        deprecated: false,
        argSerializer: Team.ListMembersDevicesArgSerializer(),
        responseSerializer: Team.ListMembersDevicesResultSerializer(),
        errorSerializer: Team.ListMembersDevicesErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let devicesListTeamDevices = Route(
        name: "devices/list_team_devices",
        namespace: "team",
        deprecated: true,
        argSerializer: Team.ListTeamDevicesArgSerializer(),
        responseSerializer: Team.ListTeamDevicesResultSerializer(),
        errorSerializer: Team.ListTeamDevicesErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let devicesRevokeDeviceSession = Route(
        name: "devices/revoke_device_session",
        namespace: "team",
        deprecated: false,
        argSerializer: Team.RevokeDeviceSessionArgSerializer(),
        responseSerializer: Serialization._VoidSerializer,
        errorSerializer: Team.RevokeDeviceSessionErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let devicesRevokeDeviceSessionBatch = Route(
        name: "devices/revoke_device_session_batch",
        namespace: "team",
        deprecated: false,
        argSerializer: Team.RevokeDeviceSessionBatchArgSerializer(),
        responseSerializer: Team.RevokeDeviceSessionBatchResultSerializer(),
        errorSerializer: Team.RevokeDeviceSessionBatchErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let getInfo = Route(
        name: "get_info",
        namespace: "team",
        deprecated: false,
        argSerializer: Serialization._VoidSerializer,
        responseSerializer: Team.TeamGetInfoResultSerializer(),
        errorSerializer: Serialization._VoidSerializer,
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let groupsCreate = Route(
        name: "groups/create",
        namespace: "team",
        deprecated: false,
        argSerializer: Team.GroupCreateArgSerializer(),
        responseSerializer: Team.GroupFullInfoSerializer(),
        errorSerializer: Team.GroupCreateErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let groupsDelete = Route(
        name: "groups/delete",
        namespace: "team",
        deprecated: false,
        argSerializer: Team.GroupSelectorSerializer(),
        responseSerializer: Async.LaunchEmptyResultSerializer(),
        errorSerializer: Team.GroupDeleteErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let groupsGetInfo = Route(
        name: "groups/get_info",
        namespace: "team",
        deprecated: false,
        argSerializer: Team.GroupsSelectorSerializer(),
        responseSerializer: ArraySerializer(Team.GroupsGetInfoItemSerializer()),
        errorSerializer: Team.GroupsGetInfoErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let groupsJobStatusGet = Route(
        name: "groups/job_status/get",
        namespace: "team",
        deprecated: false,
        argSerializer: Async.PollArgSerializer(),
        responseSerializer: Async.PollEmptyResultSerializer(),
        errorSerializer: Team.GroupsPollErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let groupsList = Route(
        name: "groups/list",
        namespace: "team",
        deprecated: false,
        argSerializer: Team.GroupsListArgSerializer(),
        responseSerializer: Team.GroupsListResultSerializer(),
        errorSerializer: Serialization._VoidSerializer,
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let groupsListContinue = Route(
        name: "groups/list/continue",
        namespace: "team",
        deprecated: false,
        argSerializer: Team.GroupsListContinueArgSerializer(),
        responseSerializer: Team.GroupsListResultSerializer(),
        errorSerializer: Team.GroupsListContinueErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let groupsMembersAdd = Route(
        name: "groups/members/add",
        namespace: "team",
        deprecated: false,
        argSerializer: Team.GroupMembersAddArgSerializer(),
        responseSerializer: Team.GroupMembersChangeResultSerializer(),
        errorSerializer: Team.GroupMembersAddErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let groupsMembersList = Route(
        name: "groups/members/list",
        namespace: "team",
        deprecated: false,
        argSerializer: Team.GroupsMembersListArgSerializer(),
        responseSerializer: Team.GroupsMembersListResultSerializer(),
        errorSerializer: Team.GroupSelectorErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let groupsMembersListContinue = Route(
        name: "groups/members/list/continue",
        namespace: "team",
        deprecated: false,
        argSerializer: Team.GroupsMembersListContinueArgSerializer(),
        responseSerializer: Team.GroupsMembersListResultSerializer(),
        errorSerializer: Team.GroupsMembersListContinueErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let groupsMembersRemove = Route(
        name: "groups/members/remove",
        namespace: "team",
        deprecated: false,
        argSerializer: Team.GroupMembersRemoveArgSerializer(),
        responseSerializer: Team.GroupMembersChangeResultSerializer(),
        errorSerializer: Team.GroupMembersRemoveErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let groupsMembersSetAccessType = Route(
        name: "groups/members/set_access_type",
        namespace: "team",
        deprecated: false,
        argSerializer: Team.GroupMembersSetAccessTypeArgSerializer(),
        responseSerializer: ArraySerializer(Team.GroupsGetInfoItemSerializer()),
        errorSerializer: Team.GroupMemberSetAccessTypeErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let groupsUpdate = Route(
        name: "groups/update",
        namespace: "team",
        deprecated: false,
        argSerializer: Team.GroupUpdateArgsSerializer(),
        responseSerializer: Team.GroupFullInfoSerializer(),
        errorSerializer: Team.GroupUpdateErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let linkedAppsListMemberLinkedApps = Route(
        name: "linked_apps/list_member_linked_apps",
        namespace: "team",
        deprecated: false,
        argSerializer: Team.ListMemberAppsArgSerializer(),
        responseSerializer: Team.ListMemberAppsResultSerializer(),
        errorSerializer: Team.ListMemberAppsErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let linkedAppsListMembersLinkedApps = Route(
        name: "linked_apps/list_members_linked_apps",
        namespace: "team",
        deprecated: false,
        argSerializer: Team.ListMembersAppsArgSerializer(),
        responseSerializer: Team.ListMembersAppsResultSerializer(),
        errorSerializer: Team.ListMembersAppsErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let linkedAppsListTeamLinkedApps = Route(
        name: "linked_apps/list_team_linked_apps",
        namespace: "team",
        deprecated: true,
        argSerializer: Team.ListTeamAppsArgSerializer(),
        responseSerializer: Team.ListTeamAppsResultSerializer(),
        errorSerializer: Team.ListTeamAppsErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let linkedAppsRevokeLinkedApp = Route(
        name: "linked_apps/revoke_linked_app",
        namespace: "team",
        deprecated: false,
        argSerializer: Team.RevokeLinkedApiAppArgSerializer(),
        responseSerializer: Serialization._VoidSerializer,
        errorSerializer: Team.RevokeLinkedAppErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let linkedAppsRevokeLinkedAppBatch = Route(
        name: "linked_apps/revoke_linked_app_batch",
        namespace: "team",
        deprecated: false,
        argSerializer: Team.RevokeLinkedApiAppBatchArgSerializer(),
        responseSerializer: Team.RevokeLinkedAppBatchResultSerializer(),
        errorSerializer: Team.RevokeLinkedAppBatchErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let membersAdd = Route(
        name: "members/add",
        namespace: "team",
        deprecated: false,
        argSerializer: Team.MembersAddArgSerializer(),
        responseSerializer: Team.MembersAddLaunchSerializer(),
        errorSerializer: Serialization._VoidSerializer,
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let membersAddJobStatusGet = Route(
        name: "members/add/job_status/get",
        namespace: "team",
        deprecated: false,
        argSerializer: Async.PollArgSerializer(),
        responseSerializer: Team.MembersAddJobStatusSerializer(),
        errorSerializer: Async.PollErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let membersGetInfo = Route(
        name: "members/get_info",
        namespace: "team",
        deprecated: false,
        argSerializer: Team.MembersGetInfoArgsSerializer(),
        responseSerializer: ArraySerializer(Team.MembersGetInfoItemSerializer()),
        errorSerializer: Team.MembersGetInfoErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let membersList = Route(
        name: "members/list",
        namespace: "team",
        deprecated: false,
        argSerializer: Team.MembersListArgSerializer(),
        responseSerializer: Team.MembersListResultSerializer(),
        errorSerializer: Team.MembersListErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let membersListContinue = Route(
        name: "members/list/continue",
        namespace: "team",
        deprecated: false,
        argSerializer: Team.MembersListContinueArgSerializer(),
        responseSerializer: Team.MembersListResultSerializer(),
        errorSerializer: Team.MembersListContinueErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let membersRecover = Route(
        name: "members/recover",
        namespace: "team",
        deprecated: false,
        argSerializer: Team.MembersRecoverArgSerializer(),
        responseSerializer: Serialization._VoidSerializer,
        errorSerializer: Team.MembersRecoverErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let membersRemove = Route(
        name: "members/remove",
        namespace: "team",
        deprecated: false,
        argSerializer: Team.MembersRemoveArgSerializer(),
        responseSerializer: Async.LaunchEmptyResultSerializer(),
        errorSerializer: Team.MembersRemoveErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let membersRemoveJobStatusGet = Route(
        name: "members/remove/job_status/get",
        namespace: "team",
        deprecated: false,
        argSerializer: Async.PollArgSerializer(),
        responseSerializer: Async.PollEmptyResultSerializer(),
        errorSerializer: Async.PollErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let membersSendWelcomeEmail = Route(
        name: "members/send_welcome_email",
        namespace: "team",
        deprecated: false,
        argSerializer: Team.UserSelectorArgSerializer(),
        responseSerializer: Serialization._VoidSerializer,
        errorSerializer: Team.MembersSendWelcomeErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let membersSetAdminPermissions = Route(
        name: "members/set_admin_permissions",
        namespace: "team",
        deprecated: false,
        argSerializer: Team.MembersSetPermissionsArgSerializer(),
        responseSerializer: Team.MembersSetPermissionsResultSerializer(),
        errorSerializer: Team.MembersSetPermissionsErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let membersSetProfile = Route(
        name: "members/set_profile",
        namespace: "team",
        deprecated: false,
        argSerializer: Team.MembersSetProfileArgSerializer(),
        responseSerializer: Team.TeamMemberInfoSerializer(),
        errorSerializer: Team.MembersSetProfileErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let membersSuspend = Route(
        name: "members/suspend",
        namespace: "team",
        deprecated: false,
        argSerializer: Team.MembersDeactivateArgSerializer(),
        responseSerializer: Serialization._VoidSerializer,
        errorSerializer: Team.MembersSuspendErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let membersUnsuspend = Route(
        name: "members/unsuspend",
        namespace: "team",
        deprecated: false,
        argSerializer: Team.MembersUnsuspendArgSerializer(),
        responseSerializer: Serialization._VoidSerializer,
        errorSerializer: Team.MembersUnsuspendErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let propertiesTemplateAdd = Route(
        name: "properties/template/add",
        namespace: "team",
        deprecated: false,
        argSerializer: Team.AddPropertyTemplateArgSerializer(),
        responseSerializer: Team.AddPropertyTemplateResultSerializer(),
        errorSerializer: Properties.ModifyPropertyTemplateErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let propertiesTemplateGet = Route(
        name: "properties/template/get",
        namespace: "team",
        deprecated: false,
        argSerializer: Properties.GetPropertyTemplateArgSerializer(),
        responseSerializer: Properties.GetPropertyTemplateResultSerializer(),
        errorSerializer: Properties.PropertyTemplateErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let propertiesTemplateList = Route(
        name: "properties/template/list",
        namespace: "team",
        deprecated: false,
        argSerializer: Serialization._VoidSerializer,
        responseSerializer: Properties.ListPropertyTemplateIdsSerializer(),
        errorSerializer: Properties.PropertyTemplateErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let propertiesTemplateUpdate = Route(
        name: "properties/template/update",
        namespace: "team",
        deprecated: false,
        argSerializer: Team.UpdatePropertyTemplateArgSerializer(),
        responseSerializer: Team.UpdatePropertyTemplateResultSerializer(),
        errorSerializer: Properties.ModifyPropertyTemplateErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let reportsGetActivity = Route(
        name: "reports/get_activity",
        namespace: "team",
        deprecated: false,
        argSerializer: Team.DateRangeSerializer(),
        responseSerializer: Team.GetActivityReportSerializer(),
        errorSerializer: Team.DateRangeErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let reportsGetDevices = Route(
        name: "reports/get_devices",
        namespace: "team",
        deprecated: false,
        argSerializer: Team.DateRangeSerializer(),
        responseSerializer: Team.GetDevicesReportSerializer(),
        errorSerializer: Team.DateRangeErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let reportsGetMembership = Route(
        name: "reports/get_membership",
        namespace: "team",
        deprecated: false,
        argSerializer: Team.DateRangeSerializer(),
        responseSerializer: Team.GetMembershipReportSerializer(),
        errorSerializer: Team.DateRangeErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let reportsGetStorage = Route(
        name: "reports/get_storage",
        namespace: "team",
        deprecated: false,
        argSerializer: Team.DateRangeSerializer(),
        responseSerializer: Team.GetStorageReportSerializer(),
        errorSerializer: Team.DateRangeErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
}
