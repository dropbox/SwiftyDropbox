///
/// Copyright (c) 2016 Dropbox, Inc. All rights reserved.
///
/// Auto-generated by Stone, do not modify.
///

import Foundation

/// Datatypes and serializers for the openid namespace
open class Openid {
    /// The OpenIdError union
    public enum OpenIdError: CustomStringConvertible {
        /// Missing openid claims for the associated access token.
        case incorrectOpenidScopes
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(OpenIdErrorSerializer().serialize(self)))"
        }
    }
    open class OpenIdErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: OpenIdError) -> JSON {
            switch value {
                case .incorrectOpenidScopes:
                    var d = [String: JSON]()
                    d[".tag"] = .str("incorrect_openid_scopes")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> OpenIdError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "incorrect_openid_scopes":
                            return OpenIdError.incorrectOpenidScopes
                        case "other":
                            return OpenIdError.other
                        default:
                            return OpenIdError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// No Parameters
    open class UserInfoArgs: CustomStringConvertible {
        public init() {
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(UserInfoArgsSerializer().serialize(self)))"
        }
    }
    open class UserInfoArgsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: UserInfoArgs) -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> UserInfoArgs {
            switch json {
                case .dictionary(_):
                    return UserInfoArgs()
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The UserInfoError union
    public enum UserInfoError: CustomStringConvertible {
        /// An unspecified error.
        case openidError(Openid.OpenIdError)
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(UserInfoErrorSerializer().serialize(self)))"
        }
    }
    open class UserInfoErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: UserInfoError) -> JSON {
            switch value {
                case .openidError(let arg):
                    var d = ["openid_error": Openid.OpenIdErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("openid_error")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> UserInfoError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "openid_error":
                            let v = Openid.OpenIdErrorSerializer().deserialize(d["openid_error"] ?? .null)
                            return UserInfoError.openidError(v)
                        case "other":
                            return UserInfoError.other
                        default:
                            return UserInfoError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The UserInfoResult struct
    open class UserInfoResult: CustomStringConvertible {
        /// Last name of user.
        public let familyName: String?
        /// First name of user.
        public let givenName: String?
        /// Email address of user.
        public let email: String?
        /// If user is email verified.
        public let emailVerified: Bool?
        /// Issuer of token (in this case Dropbox).
        public let iss: String
        /// An identifier for the user. This is the Dropbox account_id, a string value such as
        /// dbid:AAH4f99T0taONIb-OurWxbNQ6ywGRopQngc.
        public let sub: String
        public init(familyName: String? = nil, givenName: String? = nil, email: String? = nil, emailVerified: Bool? = nil, iss: String = "", sub: String = "") {
            nullableValidator(stringValidator())(familyName)
            self.familyName = familyName
            nullableValidator(stringValidator())(givenName)
            self.givenName = givenName
            nullableValidator(stringValidator())(email)
            self.email = email
            self.emailVerified = emailVerified
            stringValidator()(iss)
            self.iss = iss
            stringValidator()(sub)
            self.sub = sub
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(UserInfoResultSerializer().serialize(self)))"
        }
    }
    open class UserInfoResultSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: UserInfoResult) -> JSON {
            let output = [ 
            "family_name": NullableSerializer(Serialization._StringSerializer).serialize(value.familyName),
            "given_name": NullableSerializer(Serialization._StringSerializer).serialize(value.givenName),
            "email": NullableSerializer(Serialization._StringSerializer).serialize(value.email),
            "email_verified": NullableSerializer(Serialization._BoolSerializer).serialize(value.emailVerified),
            "iss": Serialization._StringSerializer.serialize(value.iss),
            "sub": Serialization._StringSerializer.serialize(value.sub),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> UserInfoResult {
            switch json {
                case .dictionary(let dict):
                    let familyName = NullableSerializer(Serialization._StringSerializer).deserialize(dict["family_name"] ?? .null)
                    let givenName = NullableSerializer(Serialization._StringSerializer).deserialize(dict["given_name"] ?? .null)
                    let email = NullableSerializer(Serialization._StringSerializer).deserialize(dict["email"] ?? .null)
                    let emailVerified = NullableSerializer(Serialization._BoolSerializer).deserialize(dict["email_verified"] ?? .null)
                    let iss = Serialization._StringSerializer.deserialize(dict["iss"] ?? .str(""))
                    let sub = Serialization._StringSerializer.deserialize(dict["sub"] ?? .str(""))
                    return UserInfoResult(familyName: familyName, givenName: givenName, email: email, emailVerified: emailVerified, iss: iss, sub: sub)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }


    /// Stone Route Objects

    static let userinfo = Route(
        name: "userinfo",
        version: 1,
        namespace: "openid",
        deprecated: false,
        argSerializer: Openid.UserInfoArgsSerializer(),
        responseSerializer: Openid.UserInfoResultSerializer(),
        errorSerializer: Openid.UserInfoErrorSerializer(),
        attrs: ["auth": "user",
                "host": "api",
                "style": "rpc"]
    )
}
