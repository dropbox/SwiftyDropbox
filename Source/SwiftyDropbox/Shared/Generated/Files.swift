///
/// Copyright (c) 2016 Dropbox, Inc. All rights reserved.
///
/// Auto-generated by Stone, do not modify.
///

import Foundation

/// Datatypes and serializers for the files namespace
open class Files {
    /// The GetMetadataArg struct
    open class GetMetadataArg: CustomStringConvertible {
        /// The path of a file or folder on Dropbox.
        public let path: String
        /// If true, mediaInfo in FileMetadata is set for photo and video.
        public let includeMediaInfo: Bool
        /// If true, DeletedMetadata will be returned for deleted file or folder, otherwise notFound in LookupError will
        /// be returned.
        public let includeDeleted: Bool
        /// If true, the results will include a flag for each file indicating whether or not  that file has any explicit
        /// members.
        public let includeHasExplicitSharedMembers: Bool
        /// If set to a valid list of template IDs, propertyGroups in FileMetadata is set if there exists property data
        /// associated with the file and each of the listed templates.
        public let includePropertyGroups: FileProperties.TemplateFilterBase?
        public init(path: String, includeMediaInfo: Bool = false, includeDeleted: Bool = false, includeHasExplicitSharedMembers: Bool = false, includePropertyGroups: FileProperties.TemplateFilterBase? = nil) {
            stringValidator(pattern: "(/(.|[\\r\\n])*|id:.*)|(rev:[0-9a-f]{9,})|(ns:[0-9]+(/.*)?)")(path)
            self.path = path
            self.includeMediaInfo = includeMediaInfo
            self.includeDeleted = includeDeleted
            self.includeHasExplicitSharedMembers = includeHasExplicitSharedMembers
            self.includePropertyGroups = includePropertyGroups
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GetMetadataArgSerializer().serialize(self)))"
        }
    }
    open class GetMetadataArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GetMetadataArg) -> JSON {
            let output = [ 
            "path": Serialization._StringSerializer.serialize(value.path),
            "include_media_info": Serialization._BoolSerializer.serialize(value.includeMediaInfo),
            "include_deleted": Serialization._BoolSerializer.serialize(value.includeDeleted),
            "include_has_explicit_shared_members": Serialization._BoolSerializer.serialize(value.includeHasExplicitSharedMembers),
            "include_property_groups": NullableSerializer(FileProperties.TemplateFilterBaseSerializer()).serialize(value.includePropertyGroups),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> GetMetadataArg {
            switch json {
                case .dictionary(let dict):
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .null)
                    let includeMediaInfo = Serialization._BoolSerializer.deserialize(dict["include_media_info"] ?? .number(0))
                    let includeDeleted = Serialization._BoolSerializer.deserialize(dict["include_deleted"] ?? .number(0))
                    let includeHasExplicitSharedMembers = Serialization._BoolSerializer.deserialize(dict["include_has_explicit_shared_members"] ?? .number(0))
                    let includePropertyGroups = NullableSerializer(FileProperties.TemplateFilterBaseSerializer()).deserialize(dict["include_property_groups"] ?? .null)
                    return GetMetadataArg(path: path, includeMediaInfo: includeMediaInfo, includeDeleted: includeDeleted, includeHasExplicitSharedMembers: includeHasExplicitSharedMembers, includePropertyGroups: includePropertyGroups)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The AlphaGetMetadataArg struct
    open class AlphaGetMetadataArg: Files.GetMetadataArg {
        /// If set to a valid list of template IDs, propertyGroups in FileMetadata is set for files with custom
        /// properties.
        public let includePropertyTemplates: Array<String>?
        public init(path: String, includeMediaInfo: Bool = false, includeDeleted: Bool = false, includeHasExplicitSharedMembers: Bool = false, includePropertyGroups: FileProperties.TemplateFilterBase? = nil, includePropertyTemplates: Array<String>? = nil) {
            nullableValidator(arrayValidator(itemValidator: stringValidator(minLength: 1, pattern: "(/|ptid:).*")))(includePropertyTemplates)
            self.includePropertyTemplates = includePropertyTemplates
            super.init(path: path, includeMediaInfo: includeMediaInfo, includeDeleted: includeDeleted, includeHasExplicitSharedMembers: includeHasExplicitSharedMembers, includePropertyGroups: includePropertyGroups)
        }
        open override var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(AlphaGetMetadataArgSerializer().serialize(self)))"
        }
    }
    open class AlphaGetMetadataArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: AlphaGetMetadataArg) -> JSON {
            let output = [ 
            "path": Serialization._StringSerializer.serialize(value.path),
            "include_media_info": Serialization._BoolSerializer.serialize(value.includeMediaInfo),
            "include_deleted": Serialization._BoolSerializer.serialize(value.includeDeleted),
            "include_has_explicit_shared_members": Serialization._BoolSerializer.serialize(value.includeHasExplicitSharedMembers),
            "include_property_groups": NullableSerializer(FileProperties.TemplateFilterBaseSerializer()).serialize(value.includePropertyGroups),
            "include_property_templates": NullableSerializer(ArraySerializer(Serialization._StringSerializer)).serialize(value.includePropertyTemplates),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> AlphaGetMetadataArg {
            switch json {
                case .dictionary(let dict):
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .null)
                    let includeMediaInfo = Serialization._BoolSerializer.deserialize(dict["include_media_info"] ?? .number(0))
                    let includeDeleted = Serialization._BoolSerializer.deserialize(dict["include_deleted"] ?? .number(0))
                    let includeHasExplicitSharedMembers = Serialization._BoolSerializer.deserialize(dict["include_has_explicit_shared_members"] ?? .number(0))
                    let includePropertyGroups = NullableSerializer(FileProperties.TemplateFilterBaseSerializer()).deserialize(dict["include_property_groups"] ?? .null)
                    let includePropertyTemplates = NullableSerializer(ArraySerializer(Serialization._StringSerializer)).deserialize(dict["include_property_templates"] ?? .null)
                    return AlphaGetMetadataArg(path: path, includeMediaInfo: includeMediaInfo, includeDeleted: includeDeleted, includeHasExplicitSharedMembers: includeHasExplicitSharedMembers, includePropertyGroups: includePropertyGroups, includePropertyTemplates: includePropertyTemplates)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The GetMetadataError union
    public enum GetMetadataError: CustomStringConvertible {
        /// An unspecified error.
        case path(Files.LookupError)

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GetMetadataErrorSerializer().serialize(self)))"
        }
    }
    open class GetMetadataErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GetMetadataError) -> JSON {
            switch value {
                case .path(let arg):
                    var d = ["path": Files.LookupErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("path")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> GetMetadataError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "path":
                            let v = Files.LookupErrorSerializer().deserialize(d["path"] ?? .null)
                            return GetMetadataError.path(v)
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The AlphaGetMetadataError union
    public enum AlphaGetMetadataError: CustomStringConvertible {
        /// An unspecified error.
        case path(Files.LookupError)
        /// An unspecified error.
        case propertiesError(FileProperties.LookUpPropertiesError)

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(AlphaGetMetadataErrorSerializer().serialize(self)))"
        }
    }
    open class AlphaGetMetadataErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: AlphaGetMetadataError) -> JSON {
            switch value {
                case .path(let arg):
                    var d = ["path": Files.LookupErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("path")
                    return .dictionary(d)
                case .propertiesError(let arg):
                    var d = ["properties_error": FileProperties.LookUpPropertiesErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("properties_error")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> AlphaGetMetadataError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "path":
                            let v = Files.LookupErrorSerializer().deserialize(d["path"] ?? .null)
                            return AlphaGetMetadataError.path(v)
                        case "properties_error":
                            let v = FileProperties.LookUpPropertiesErrorSerializer().deserialize(d["properties_error"] ?? .null)
                            return AlphaGetMetadataError.propertiesError(v)
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The CommitInfo struct
    open class CommitInfo: CustomStringConvertible {
        /// Path in the user's Dropbox to save the file.
        public let path: String
        /// Selects what to do if the file already exists.
        public let mode: Files.WriteMode
        /// If there's a conflict, as determined by mode, have the Dropbox server try to autorename the file to avoid
        /// conflict.
        public let autorename: Bool
        /// The value to store as the clientModified timestamp. Dropbox automatically records the time at which the file
        /// was written to the Dropbox servers. It can also record an additional timestamp, provided by Dropbox desktop
        /// clients, mobile clients, and API apps of when the file was actually created or modified.
        public let clientModified: Date?
        /// Normally, users are made aware of any file modifications in their Dropbox account via notifications in the
        /// client software. If true, this tells the clients that this modification shouldn't result in a user
        /// notification.
        public let mute: Bool
        /// List of custom properties to add to file.
        public let propertyGroups: Array<FileProperties.PropertyGroup>?
        /// Be more strict about how each WriteMode detects conflict. For example, always return a conflict error when
        /// mode = update in WriteMode and the given "rev" doesn't match the existing file's "rev", even if the existing
        /// file has been deleted. This also forces a conflict even when the target path refers to a file with identical
        /// contents.
        public let strictConflict: Bool
        public init(path: String, mode: Files.WriteMode = .add, autorename: Bool = false, clientModified: Date? = nil, mute: Bool = false, propertyGroups: Array<FileProperties.PropertyGroup>? = nil, strictConflict: Bool = false) {
            stringValidator(pattern: "(/(.|[\\r\\n])*)|(ns:[0-9]+(/.*)?)|(id:.*)")(path)
            self.path = path
            self.mode = mode
            self.autorename = autorename
            self.clientModified = clientModified
            self.mute = mute
            self.propertyGroups = propertyGroups
            self.strictConflict = strictConflict
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(CommitInfoSerializer().serialize(self)))"
        }
    }
    open class CommitInfoSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: CommitInfo) -> JSON {
            let output = [ 
            "path": Serialization._StringSerializer.serialize(value.path),
            "mode": Files.WriteModeSerializer().serialize(value.mode),
            "autorename": Serialization._BoolSerializer.serialize(value.autorename),
            "client_modified": NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.clientModified),
            "mute": Serialization._BoolSerializer.serialize(value.mute),
            "property_groups": NullableSerializer(ArraySerializer(FileProperties.PropertyGroupSerializer())).serialize(value.propertyGroups),
            "strict_conflict": Serialization._BoolSerializer.serialize(value.strictConflict),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> CommitInfo {
            switch json {
                case .dictionary(let dict):
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .null)
                    let mode = Files.WriteModeSerializer().deserialize(dict["mode"] ?? Files.WriteModeSerializer().serialize(.add))
                    let autorename = Serialization._BoolSerializer.deserialize(dict["autorename"] ?? .number(0))
                    let clientModified = NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).deserialize(dict["client_modified"] ?? .null)
                    let mute = Serialization._BoolSerializer.deserialize(dict["mute"] ?? .number(0))
                    let propertyGroups = NullableSerializer(ArraySerializer(FileProperties.PropertyGroupSerializer())).deserialize(dict["property_groups"] ?? .null)
                    let strictConflict = Serialization._BoolSerializer.deserialize(dict["strict_conflict"] ?? .number(0))
                    return CommitInfo(path: path, mode: mode, autorename: autorename, clientModified: clientModified, mute: mute, propertyGroups: propertyGroups, strictConflict: strictConflict)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The CommitInfoWithProperties struct
    open class CommitInfoWithProperties: Files.CommitInfo {
        open override var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(CommitInfoWithPropertiesSerializer().serialize(self)))"
        }
    }
    open class CommitInfoWithPropertiesSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: CommitInfoWithProperties) -> JSON {
            let output = [ 
            "path": Serialization._StringSerializer.serialize(value.path),
            "mode": Files.WriteModeSerializer().serialize(value.mode),
            "autorename": Serialization._BoolSerializer.serialize(value.autorename),
            "client_modified": NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.clientModified),
            "mute": Serialization._BoolSerializer.serialize(value.mute),
            "property_groups": NullableSerializer(ArraySerializer(FileProperties.PropertyGroupSerializer())).serialize(value.propertyGroups),
            "strict_conflict": Serialization._BoolSerializer.serialize(value.strictConflict),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> CommitInfoWithProperties {
            switch json {
                case .dictionary(let dict):
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .null)
                    let mode = Files.WriteModeSerializer().deserialize(dict["mode"] ?? Files.WriteModeSerializer().serialize(.add))
                    let autorename = Serialization._BoolSerializer.deserialize(dict["autorename"] ?? .number(0))
                    let clientModified = NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).deserialize(dict["client_modified"] ?? .null)
                    let mute = Serialization._BoolSerializer.deserialize(dict["mute"] ?? .number(0))
                    let propertyGroups = NullableSerializer(ArraySerializer(FileProperties.PropertyGroupSerializer())).deserialize(dict["property_groups"] ?? .null)
                    let strictConflict = Serialization._BoolSerializer.deserialize(dict["strict_conflict"] ?? .number(0))
                    return CommitInfoWithProperties(path: path, mode: mode, autorename: autorename, clientModified: clientModified, mute: mute, propertyGroups: propertyGroups, strictConflict: strictConflict)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The ContentSyncSetting struct
    open class ContentSyncSetting: CustomStringConvertible {
        /// Id of the item this setting is applied to.
        public let id: String
        /// Setting for this item.
        public let syncSetting: Files.SyncSetting
        public init(id: String, syncSetting: Files.SyncSetting) {
            stringValidator(minLength: 4, pattern: "id:.+")(id)
            self.id = id
            self.syncSetting = syncSetting
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ContentSyncSettingSerializer().serialize(self)))"
        }
    }
    open class ContentSyncSettingSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ContentSyncSetting) -> JSON {
            let output = [ 
            "id": Serialization._StringSerializer.serialize(value.id),
            "sync_setting": Files.SyncSettingSerializer().serialize(value.syncSetting),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ContentSyncSetting {
            switch json {
                case .dictionary(let dict):
                    let id = Serialization._StringSerializer.deserialize(dict["id"] ?? .null)
                    let syncSetting = Files.SyncSettingSerializer().deserialize(dict["sync_setting"] ?? .null)
                    return ContentSyncSetting(id: id, syncSetting: syncSetting)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The ContentSyncSettingArg struct
    open class ContentSyncSettingArg: CustomStringConvertible {
        /// Id of the item this setting is applied to.
        public let id: String
        /// Setting for this item.
        public let syncSetting: Files.SyncSettingArg
        public init(id: String, syncSetting: Files.SyncSettingArg) {
            stringValidator(minLength: 4, pattern: "id:.+")(id)
            self.id = id
            self.syncSetting = syncSetting
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ContentSyncSettingArgSerializer().serialize(self)))"
        }
    }
    open class ContentSyncSettingArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ContentSyncSettingArg) -> JSON {
            let output = [ 
            "id": Serialization._StringSerializer.serialize(value.id),
            "sync_setting": Files.SyncSettingArgSerializer().serialize(value.syncSetting),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ContentSyncSettingArg {
            switch json {
                case .dictionary(let dict):
                    let id = Serialization._StringSerializer.deserialize(dict["id"] ?? .null)
                    let syncSetting = Files.SyncSettingArgSerializer().deserialize(dict["sync_setting"] ?? .null)
                    return ContentSyncSettingArg(id: id, syncSetting: syncSetting)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The CreateFolderArg struct
    open class CreateFolderArg: CustomStringConvertible {
        /// Path in the user's Dropbox to create.
        public let path: String
        /// If there's a conflict, have the Dropbox server try to autorename the folder to avoid the conflict.
        public let autorename: Bool
        public init(path: String, autorename: Bool = false) {
            stringValidator(pattern: "(/(.|[\\r\\n])*)|(ns:[0-9]+(/.*)?)")(path)
            self.path = path
            self.autorename = autorename
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(CreateFolderArgSerializer().serialize(self)))"
        }
    }
    open class CreateFolderArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: CreateFolderArg) -> JSON {
            let output = [ 
            "path": Serialization._StringSerializer.serialize(value.path),
            "autorename": Serialization._BoolSerializer.serialize(value.autorename),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> CreateFolderArg {
            switch json {
                case .dictionary(let dict):
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .null)
                    let autorename = Serialization._BoolSerializer.deserialize(dict["autorename"] ?? .number(0))
                    return CreateFolderArg(path: path, autorename: autorename)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The CreateFolderBatchArg struct
    open class CreateFolderBatchArg: CustomStringConvertible {
        /// List of paths to be created in the user's Dropbox. Duplicate path arguments in the batch are considered only
        /// once.
        public let paths: Array<String>
        /// If there's a conflict, have the Dropbox server try to autorename the folder to avoid the conflict.
        public let autorename: Bool
        /// Whether to force the create to happen asynchronously.
        public let forceAsync: Bool
        public init(paths: Array<String>, autorename: Bool = false, forceAsync: Bool = false) {
            arrayValidator(maxItems: 10000, itemValidator: stringValidator(pattern: "(/(.|[\\r\\n])*)|(ns:[0-9]+(/.*)?)"))(paths)
            self.paths = paths
            self.autorename = autorename
            self.forceAsync = forceAsync
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(CreateFolderBatchArgSerializer().serialize(self)))"
        }
    }
    open class CreateFolderBatchArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: CreateFolderBatchArg) -> JSON {
            let output = [ 
            "paths": ArraySerializer(Serialization._StringSerializer).serialize(value.paths),
            "autorename": Serialization._BoolSerializer.serialize(value.autorename),
            "force_async": Serialization._BoolSerializer.serialize(value.forceAsync),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> CreateFolderBatchArg {
            switch json {
                case .dictionary(let dict):
                    let paths = ArraySerializer(Serialization._StringSerializer).deserialize(dict["paths"] ?? .null)
                    let autorename = Serialization._BoolSerializer.deserialize(dict["autorename"] ?? .number(0))
                    let forceAsync = Serialization._BoolSerializer.deserialize(dict["force_async"] ?? .number(0))
                    return CreateFolderBatchArg(paths: paths, autorename: autorename, forceAsync: forceAsync)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The CreateFolderBatchError union
    public enum CreateFolderBatchError: CustomStringConvertible {
        /// The operation would involve too many files or folders.
        case tooManyFiles
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(CreateFolderBatchErrorSerializer().serialize(self)))"
        }
    }
    open class CreateFolderBatchErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: CreateFolderBatchError) -> JSON {
            switch value {
                case .tooManyFiles:
                    var d = [String: JSON]()
                    d[".tag"] = .str("too_many_files")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> CreateFolderBatchError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "too_many_files":
                            return CreateFolderBatchError.tooManyFiles
                        case "other":
                            return CreateFolderBatchError.other
                        default:
                            return CreateFolderBatchError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The CreateFolderBatchJobStatus union
    public enum CreateFolderBatchJobStatus: CustomStringConvertible {
        /// The asynchronous job is still in progress.
        case inProgress
        /// The batch create folder has finished.
        case complete(Files.CreateFolderBatchResult)
        /// The batch create folder has failed.
        case failed(Files.CreateFolderBatchError)
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(CreateFolderBatchJobStatusSerializer().serialize(self)))"
        }
    }
    open class CreateFolderBatchJobStatusSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: CreateFolderBatchJobStatus) -> JSON {
            switch value {
                case .inProgress:
                    var d = [String: JSON]()
                    d[".tag"] = .str("in_progress")
                    return .dictionary(d)
                case .complete(let arg):
                    var d = Serialization.getFields(Files.CreateFolderBatchResultSerializer().serialize(arg))
                    d[".tag"] = .str("complete")
                    return .dictionary(d)
                case .failed(let arg):
                    var d = ["failed": Files.CreateFolderBatchErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("failed")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> CreateFolderBatchJobStatus {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "in_progress":
                            return CreateFolderBatchJobStatus.inProgress
                        case "complete":
                            let v = Files.CreateFolderBatchResultSerializer().deserialize(json)
                            return CreateFolderBatchJobStatus.complete(v)
                        case "failed":
                            let v = Files.CreateFolderBatchErrorSerializer().deserialize(d["failed"] ?? .null)
                            return CreateFolderBatchJobStatus.failed(v)
                        case "other":
                            return CreateFolderBatchJobStatus.other
                        default:
                            return CreateFolderBatchJobStatus.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Result returned by createFolderBatch that may either launch an asynchronous job or complete synchronously.
    public enum CreateFolderBatchLaunch: CustomStringConvertible {
        /// This response indicates that the processing is asynchronous. The string is an id that can be used to obtain
        /// the status of the asynchronous job.
        case asyncJobId(String)
        /// An unspecified error.
        case complete(Files.CreateFolderBatchResult)
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(CreateFolderBatchLaunchSerializer().serialize(self)))"
        }
    }
    open class CreateFolderBatchLaunchSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: CreateFolderBatchLaunch) -> JSON {
            switch value {
                case .asyncJobId(let arg):
                    var d = ["async_job_id": Serialization._StringSerializer.serialize(arg)]
                    d[".tag"] = .str("async_job_id")
                    return .dictionary(d)
                case .complete(let arg):
                    var d = Serialization.getFields(Files.CreateFolderBatchResultSerializer().serialize(arg))
                    d[".tag"] = .str("complete")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> CreateFolderBatchLaunch {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "async_job_id":
                            let v = Serialization._StringSerializer.deserialize(d["async_job_id"] ?? .null)
                            return CreateFolderBatchLaunch.asyncJobId(v)
                        case "complete":
                            let v = Files.CreateFolderBatchResultSerializer().deserialize(json)
                            return CreateFolderBatchLaunch.complete(v)
                        case "other":
                            return CreateFolderBatchLaunch.other
                        default:
                            return CreateFolderBatchLaunch.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The FileOpsResult struct
    open class FileOpsResult: CustomStringConvertible {
        public init() {
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(FileOpsResultSerializer().serialize(self)))"
        }
    }
    open class FileOpsResultSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: FileOpsResult) -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> FileOpsResult {
            switch json {
                case .dictionary(_):
                    return FileOpsResult()
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The CreateFolderBatchResult struct
    open class CreateFolderBatchResult: Files.FileOpsResult {
        /// Each entry in paths in CreateFolderBatchArg will appear at the same position inside entries in
        /// CreateFolderBatchResult.
        public let entries: Array<Files.CreateFolderBatchResultEntry>
        public init(entries: Array<Files.CreateFolderBatchResultEntry>) {
            self.entries = entries
            super.init()
        }
        open override var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(CreateFolderBatchResultSerializer().serialize(self)))"
        }
    }
    open class CreateFolderBatchResultSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: CreateFolderBatchResult) -> JSON {
            let output = [ 
            "entries": ArraySerializer(Files.CreateFolderBatchResultEntrySerializer()).serialize(value.entries),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> CreateFolderBatchResult {
            switch json {
                case .dictionary(let dict):
                    let entries = ArraySerializer(Files.CreateFolderBatchResultEntrySerializer()).deserialize(dict["entries"] ?? .null)
                    return CreateFolderBatchResult(entries: entries)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The CreateFolderBatchResultEntry union
    public enum CreateFolderBatchResultEntry: CustomStringConvertible {
        /// An unspecified error.
        case success(Files.CreateFolderEntryResult)
        /// An unspecified error.
        case failure(Files.CreateFolderEntryError)

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(CreateFolderBatchResultEntrySerializer().serialize(self)))"
        }
    }
    open class CreateFolderBatchResultEntrySerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: CreateFolderBatchResultEntry) -> JSON {
            switch value {
                case .success(let arg):
                    var d = Serialization.getFields(Files.CreateFolderEntryResultSerializer().serialize(arg))
                    d[".tag"] = .str("success")
                    return .dictionary(d)
                case .failure(let arg):
                    var d = ["failure": Files.CreateFolderEntryErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("failure")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> CreateFolderBatchResultEntry {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "success":
                            let v = Files.CreateFolderEntryResultSerializer().deserialize(json)
                            return CreateFolderBatchResultEntry.success(v)
                        case "failure":
                            let v = Files.CreateFolderEntryErrorSerializer().deserialize(d["failure"] ?? .null)
                            return CreateFolderBatchResultEntry.failure(v)
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The CreateFolderEntryError union
    public enum CreateFolderEntryError: CustomStringConvertible {
        /// An unspecified error.
        case path(Files.WriteError)
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(CreateFolderEntryErrorSerializer().serialize(self)))"
        }
    }
    open class CreateFolderEntryErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: CreateFolderEntryError) -> JSON {
            switch value {
                case .path(let arg):
                    var d = ["path": Files.WriteErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("path")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> CreateFolderEntryError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "path":
                            let v = Files.WriteErrorSerializer().deserialize(d["path"] ?? .null)
                            return CreateFolderEntryError.path(v)
                        case "other":
                            return CreateFolderEntryError.other
                        default:
                            return CreateFolderEntryError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The CreateFolderEntryResult struct
    open class CreateFolderEntryResult: CustomStringConvertible {
        /// Metadata of the created folder.
        public let metadata: Files.FolderMetadata
        public init(metadata: Files.FolderMetadata) {
            self.metadata = metadata
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(CreateFolderEntryResultSerializer().serialize(self)))"
        }
    }
    open class CreateFolderEntryResultSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: CreateFolderEntryResult) -> JSON {
            let output = [ 
            "metadata": Files.FolderMetadataSerializer().serialize(value.metadata),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> CreateFolderEntryResult {
            switch json {
                case .dictionary(let dict):
                    let metadata = Files.FolderMetadataSerializer().deserialize(dict["metadata"] ?? .null)
                    return CreateFolderEntryResult(metadata: metadata)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The CreateFolderError union
    public enum CreateFolderError: CustomStringConvertible {
        /// An unspecified error.
        case path(Files.WriteError)

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(CreateFolderErrorSerializer().serialize(self)))"
        }
    }
    open class CreateFolderErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: CreateFolderError) -> JSON {
            switch value {
                case .path(let arg):
                    var d = ["path": Files.WriteErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("path")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> CreateFolderError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "path":
                            let v = Files.WriteErrorSerializer().deserialize(d["path"] ?? .null)
                            return CreateFolderError.path(v)
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The CreateFolderResult struct
    open class CreateFolderResult: Files.FileOpsResult {
        /// Metadata of the created folder.
        public let metadata: Files.FolderMetadata
        public init(metadata: Files.FolderMetadata) {
            self.metadata = metadata
            super.init()
        }
        open override var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(CreateFolderResultSerializer().serialize(self)))"
        }
    }
    open class CreateFolderResultSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: CreateFolderResult) -> JSON {
            let output = [ 
            "metadata": Files.FolderMetadataSerializer().serialize(value.metadata),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> CreateFolderResult {
            switch json {
                case .dictionary(let dict):
                    let metadata = Files.FolderMetadataSerializer().deserialize(dict["metadata"] ?? .null)
                    return CreateFolderResult(metadata: metadata)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The DeleteArg struct
    open class DeleteArg: CustomStringConvertible {
        /// Path in the user's Dropbox to delete.
        public let path: String
        /// Perform delete if given "rev" matches the existing file's latest "rev". This field does not support deleting
        /// a folder.
        public let parentRev: String?
        public init(path: String, parentRev: String? = nil) {
            stringValidator(pattern: "(/(.|[\\r\\n])*)|(ns:[0-9]+(/.*)?)|(id:.*)")(path)
            self.path = path
            nullableValidator(stringValidator(minLength: 9, pattern: "[0-9a-f]+"))(parentRev)
            self.parentRev = parentRev
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(DeleteArgSerializer().serialize(self)))"
        }
    }
    open class DeleteArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: DeleteArg) -> JSON {
            let output = [ 
            "path": Serialization._StringSerializer.serialize(value.path),
            "parent_rev": NullableSerializer(Serialization._StringSerializer).serialize(value.parentRev),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> DeleteArg {
            switch json {
                case .dictionary(let dict):
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .null)
                    let parentRev = NullableSerializer(Serialization._StringSerializer).deserialize(dict["parent_rev"] ?? .null)
                    return DeleteArg(path: path, parentRev: parentRev)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The DeleteBatchArg struct
    open class DeleteBatchArg: CustomStringConvertible {
        /// (no description)
        public let entries: Array<Files.DeleteArg>
        public init(entries: Array<Files.DeleteArg>) {
            self.entries = entries
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(DeleteBatchArgSerializer().serialize(self)))"
        }
    }
    open class DeleteBatchArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: DeleteBatchArg) -> JSON {
            let output = [ 
            "entries": ArraySerializer(Files.DeleteArgSerializer()).serialize(value.entries),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> DeleteBatchArg {
            switch json {
                case .dictionary(let dict):
                    let entries = ArraySerializer(Files.DeleteArgSerializer()).deserialize(dict["entries"] ?? .null)
                    return DeleteBatchArg(entries: entries)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The DeleteBatchError union
    public enum DeleteBatchError: CustomStringConvertible {
        /// Use tooManyWriteOperations in DeleteError. deleteBatch now provides smaller granularity about which entry
        /// has failed because of this.
        case tooManyWriteOperations
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(DeleteBatchErrorSerializer().serialize(self)))"
        }
    }
    open class DeleteBatchErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: DeleteBatchError) -> JSON {
            switch value {
                case .tooManyWriteOperations:
                    var d = [String: JSON]()
                    d[".tag"] = .str("too_many_write_operations")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> DeleteBatchError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "too_many_write_operations":
                            return DeleteBatchError.tooManyWriteOperations
                        case "other":
                            return DeleteBatchError.other
                        default:
                            return DeleteBatchError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The DeleteBatchJobStatus union
    public enum DeleteBatchJobStatus: CustomStringConvertible {
        /// The asynchronous job is still in progress.
        case inProgress
        /// The batch delete has finished.
        case complete(Files.DeleteBatchResult)
        /// The batch delete has failed.
        case failed(Files.DeleteBatchError)
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(DeleteBatchJobStatusSerializer().serialize(self)))"
        }
    }
    open class DeleteBatchJobStatusSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: DeleteBatchJobStatus) -> JSON {
            switch value {
                case .inProgress:
                    var d = [String: JSON]()
                    d[".tag"] = .str("in_progress")
                    return .dictionary(d)
                case .complete(let arg):
                    var d = Serialization.getFields(Files.DeleteBatchResultSerializer().serialize(arg))
                    d[".tag"] = .str("complete")
                    return .dictionary(d)
                case .failed(let arg):
                    var d = ["failed": Files.DeleteBatchErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("failed")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> DeleteBatchJobStatus {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "in_progress":
                            return DeleteBatchJobStatus.inProgress
                        case "complete":
                            let v = Files.DeleteBatchResultSerializer().deserialize(json)
                            return DeleteBatchJobStatus.complete(v)
                        case "failed":
                            let v = Files.DeleteBatchErrorSerializer().deserialize(d["failed"] ?? .null)
                            return DeleteBatchJobStatus.failed(v)
                        case "other":
                            return DeleteBatchJobStatus.other
                        default:
                            return DeleteBatchJobStatus.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Result returned by deleteBatch that may either launch an asynchronous job or complete synchronously.
    public enum DeleteBatchLaunch: CustomStringConvertible {
        /// This response indicates that the processing is asynchronous. The string is an id that can be used to obtain
        /// the status of the asynchronous job.
        case asyncJobId(String)
        /// An unspecified error.
        case complete(Files.DeleteBatchResult)
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(DeleteBatchLaunchSerializer().serialize(self)))"
        }
    }
    open class DeleteBatchLaunchSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: DeleteBatchLaunch) -> JSON {
            switch value {
                case .asyncJobId(let arg):
                    var d = ["async_job_id": Serialization._StringSerializer.serialize(arg)]
                    d[".tag"] = .str("async_job_id")
                    return .dictionary(d)
                case .complete(let arg):
                    var d = Serialization.getFields(Files.DeleteBatchResultSerializer().serialize(arg))
                    d[".tag"] = .str("complete")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> DeleteBatchLaunch {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "async_job_id":
                            let v = Serialization._StringSerializer.deserialize(d["async_job_id"] ?? .null)
                            return DeleteBatchLaunch.asyncJobId(v)
                        case "complete":
                            let v = Files.DeleteBatchResultSerializer().deserialize(json)
                            return DeleteBatchLaunch.complete(v)
                        case "other":
                            return DeleteBatchLaunch.other
                        default:
                            return DeleteBatchLaunch.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The DeleteBatchResult struct
    open class DeleteBatchResult: Files.FileOpsResult {
        /// Each entry in entries in DeleteBatchArg will appear at the same position inside entries in
        /// DeleteBatchResult.
        public let entries: Array<Files.DeleteBatchResultEntry>
        public init(entries: Array<Files.DeleteBatchResultEntry>) {
            self.entries = entries
            super.init()
        }
        open override var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(DeleteBatchResultSerializer().serialize(self)))"
        }
    }
    open class DeleteBatchResultSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: DeleteBatchResult) -> JSON {
            let output = [ 
            "entries": ArraySerializer(Files.DeleteBatchResultEntrySerializer()).serialize(value.entries),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> DeleteBatchResult {
            switch json {
                case .dictionary(let dict):
                    let entries = ArraySerializer(Files.DeleteBatchResultEntrySerializer()).deserialize(dict["entries"] ?? .null)
                    return DeleteBatchResult(entries: entries)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The DeleteBatchResultData struct
    open class DeleteBatchResultData: CustomStringConvertible {
        /// Metadata of the deleted object.
        public let metadata: Files.Metadata
        public init(metadata: Files.Metadata) {
            self.metadata = metadata
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(DeleteBatchResultDataSerializer().serialize(self)))"
        }
    }
    open class DeleteBatchResultDataSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: DeleteBatchResultData) -> JSON {
            let output = [ 
            "metadata": Files.MetadataSerializer().serialize(value.metadata),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> DeleteBatchResultData {
            switch json {
                case .dictionary(let dict):
                    let metadata = Files.MetadataSerializer().deserialize(dict["metadata"] ?? .null)
                    return DeleteBatchResultData(metadata: metadata)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The DeleteBatchResultEntry union
    public enum DeleteBatchResultEntry: CustomStringConvertible {
        /// An unspecified error.
        case success(Files.DeleteBatchResultData)
        /// An unspecified error.
        case failure(Files.DeleteError)

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(DeleteBatchResultEntrySerializer().serialize(self)))"
        }
    }
    open class DeleteBatchResultEntrySerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: DeleteBatchResultEntry) -> JSON {
            switch value {
                case .success(let arg):
                    var d = Serialization.getFields(Files.DeleteBatchResultDataSerializer().serialize(arg))
                    d[".tag"] = .str("success")
                    return .dictionary(d)
                case .failure(let arg):
                    var d = ["failure": Files.DeleteErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("failure")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> DeleteBatchResultEntry {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "success":
                            let v = Files.DeleteBatchResultDataSerializer().deserialize(json)
                            return DeleteBatchResultEntry.success(v)
                        case "failure":
                            let v = Files.DeleteErrorSerializer().deserialize(d["failure"] ?? .null)
                            return DeleteBatchResultEntry.failure(v)
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The DeleteError union
    public enum DeleteError: CustomStringConvertible {
        /// An unspecified error.
        case pathLookup(Files.LookupError)
        /// An unspecified error.
        case pathWrite(Files.WriteError)
        /// There are too many write operations in user's Dropbox. Please retry this request.
        case tooManyWriteOperations
        /// There are too many files in one request. Please retry with fewer files.
        case tooManyFiles
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(DeleteErrorSerializer().serialize(self)))"
        }
    }
    open class DeleteErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: DeleteError) -> JSON {
            switch value {
                case .pathLookup(let arg):
                    var d = ["path_lookup": Files.LookupErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("path_lookup")
                    return .dictionary(d)
                case .pathWrite(let arg):
                    var d = ["path_write": Files.WriteErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("path_write")
                    return .dictionary(d)
                case .tooManyWriteOperations:
                    var d = [String: JSON]()
                    d[".tag"] = .str("too_many_write_operations")
                    return .dictionary(d)
                case .tooManyFiles:
                    var d = [String: JSON]()
                    d[".tag"] = .str("too_many_files")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> DeleteError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "path_lookup":
                            let v = Files.LookupErrorSerializer().deserialize(d["path_lookup"] ?? .null)
                            return DeleteError.pathLookup(v)
                        case "path_write":
                            let v = Files.WriteErrorSerializer().deserialize(d["path_write"] ?? .null)
                            return DeleteError.pathWrite(v)
                        case "too_many_write_operations":
                            return DeleteError.tooManyWriteOperations
                        case "too_many_files":
                            return DeleteError.tooManyFiles
                        case "other":
                            return DeleteError.other
                        default:
                            return DeleteError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The DeleteResult struct
    open class DeleteResult: Files.FileOpsResult {
        /// Metadata of the deleted object.
        public let metadata: Files.Metadata
        public init(metadata: Files.Metadata) {
            self.metadata = metadata
            super.init()
        }
        open override var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(DeleteResultSerializer().serialize(self)))"
        }
    }
    open class DeleteResultSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: DeleteResult) -> JSON {
            let output = [ 
            "metadata": Files.MetadataSerializer().serialize(value.metadata),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> DeleteResult {
            switch json {
                case .dictionary(let dict):
                    let metadata = Files.MetadataSerializer().deserialize(dict["metadata"] ?? .null)
                    return DeleteResult(metadata: metadata)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Metadata for a file or folder.
    open class Metadata: CustomStringConvertible {
        /// The last component of the path (including extension). This never contains a slash.
        public let name: String
        /// The lowercased full path in the user's Dropbox. This always starts with a slash. This field will be null if
        /// the file or folder is not mounted.
        public let pathLower: String?
        /// The cased path to be used for display purposes only. In rare instances the casing will not correctly match
        /// the user's filesystem, but this behavior will match the path provided in the Core API v1, and at least the
        /// last path component will have the correct casing. Changes to only the casing of paths won't be returned by
        /// listFolderContinue. This field will be null if the file or folder is not mounted.
        public let pathDisplay: String?
        /// Please use parentSharedFolderId in FileSharingInfo or parentSharedFolderId in FolderSharingInfo instead.
        public let parentSharedFolderId: String?
        public init(name: String, pathLower: String? = nil, pathDisplay: String? = nil, parentSharedFolderId: String? = nil) {
            stringValidator()(name)
            self.name = name
            nullableValidator(stringValidator())(pathLower)
            self.pathLower = pathLower
            nullableValidator(stringValidator())(pathDisplay)
            self.pathDisplay = pathDisplay
            nullableValidator(stringValidator(pattern: "[-_0-9a-zA-Z:]+"))(parentSharedFolderId)
            self.parentSharedFolderId = parentSharedFolderId
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MetadataSerializer().serialize(self)))"
        }
    }
    open class MetadataSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: Metadata) -> JSON {
            var output = [ 
            "name": Serialization._StringSerializer.serialize(value.name),
            "path_lower": NullableSerializer(Serialization._StringSerializer).serialize(value.pathLower),
            "path_display": NullableSerializer(Serialization._StringSerializer).serialize(value.pathDisplay),
            "parent_shared_folder_id": NullableSerializer(Serialization._StringSerializer).serialize(value.parentSharedFolderId),
            ]
            switch value {
                case let file as Files.FileMetadata:
                    for (k, v) in Serialization.getFields(Files.FileMetadataSerializer().serialize(file)) {
                        output[k] = v
                    }
                    output[".tag"] = .str("file")
                case let folder as Files.FolderMetadata:
                    for (k, v) in Serialization.getFields(Files.FolderMetadataSerializer().serialize(folder)) {
                        output[k] = v
                    }
                    output[".tag"] = .str("folder")
                case let deleted as Files.DeletedMetadata:
                    for (k, v) in Serialization.getFields(Files.DeletedMetadataSerializer().serialize(deleted)) {
                        output[k] = v
                    }
                    output[".tag"] = .str("deleted")
                default: fatalError("Tried to serialize unexpected subtype")
            }
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> Metadata {
            switch json {
                case .dictionary(let dict):
                    let tag = Serialization.getTag(dict)
                    switch tag {
                        case "file":
                            return Files.FileMetadataSerializer().deserialize(json)
                        case "folder":
                            return Files.FolderMetadataSerializer().deserialize(json)
                        case "deleted":
                            return Files.DeletedMetadataSerializer().deserialize(json)
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Indicates that there used to be a file or folder at this path, but it no longer exists.
    open class DeletedMetadata: Files.Metadata {
        open override var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(DeletedMetadataSerializer().serialize(self)))"
        }
    }
    open class DeletedMetadataSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: DeletedMetadata) -> JSON {
            let output = [ 
            "name": Serialization._StringSerializer.serialize(value.name),
            "path_lower": NullableSerializer(Serialization._StringSerializer).serialize(value.pathLower),
            "path_display": NullableSerializer(Serialization._StringSerializer).serialize(value.pathDisplay),
            "parent_shared_folder_id": NullableSerializer(Serialization._StringSerializer).serialize(value.parentSharedFolderId),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> DeletedMetadata {
            switch json {
                case .dictionary(let dict):
                    let name = Serialization._StringSerializer.deserialize(dict["name"] ?? .null)
                    let pathLower = NullableSerializer(Serialization._StringSerializer).deserialize(dict["path_lower"] ?? .null)
                    let pathDisplay = NullableSerializer(Serialization._StringSerializer).deserialize(dict["path_display"] ?? .null)
                    let parentSharedFolderId = NullableSerializer(Serialization._StringSerializer).deserialize(dict["parent_shared_folder_id"] ?? .null)
                    return DeletedMetadata(name: name, pathLower: pathLower, pathDisplay: pathDisplay, parentSharedFolderId: parentSharedFolderId)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Dimensions for a photo or video.
    open class Dimensions: CustomStringConvertible {
        /// Height of the photo/video.
        public let height: UInt64
        /// Width of the photo/video.
        public let width: UInt64
        public init(height: UInt64, width: UInt64) {
            comparableValidator()(height)
            self.height = height
            comparableValidator()(width)
            self.width = width
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(DimensionsSerializer().serialize(self)))"
        }
    }
    open class DimensionsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: Dimensions) -> JSON {
            let output = [ 
            "height": Serialization._UInt64Serializer.serialize(value.height),
            "width": Serialization._UInt64Serializer.serialize(value.width),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> Dimensions {
            switch json {
                case .dictionary(let dict):
                    let height = Serialization._UInt64Serializer.deserialize(dict["height"] ?? .null)
                    let width = Serialization._UInt64Serializer.deserialize(dict["width"] ?? .null)
                    return Dimensions(height: height, width: width)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The DownloadArg struct
    open class DownloadArg: CustomStringConvertible {
        /// The path of the file to download.
        public let path: String
        /// Please specify revision in path instead.
        public let rev: String?
        public init(path: String, rev: String? = nil) {
            stringValidator(pattern: "(/(.|[\\r\\n])*|id:.*)|(rev:[0-9a-f]{9,})|(ns:[0-9]+(/.*)?)")(path)
            self.path = path
            nullableValidator(stringValidator(minLength: 9, pattern: "[0-9a-f]+"))(rev)
            self.rev = rev
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(DownloadArgSerializer().serialize(self)))"
        }
    }
    open class DownloadArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: DownloadArg) -> JSON {
            let output = [ 
            "path": Serialization._StringSerializer.serialize(value.path),
            "rev": NullableSerializer(Serialization._StringSerializer).serialize(value.rev),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> DownloadArg {
            switch json {
                case .dictionary(let dict):
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .null)
                    let rev = NullableSerializer(Serialization._StringSerializer).deserialize(dict["rev"] ?? .null)
                    return DownloadArg(path: path, rev: rev)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The DownloadError union
    public enum DownloadError: CustomStringConvertible {
        /// An unspecified error.
        case path(Files.LookupError)
        /// This file type cannot be downloaded directly; use export instead.
        case unsupportedFile
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(DownloadErrorSerializer().serialize(self)))"
        }
    }
    open class DownloadErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: DownloadError) -> JSON {
            switch value {
                case .path(let arg):
                    var d = ["path": Files.LookupErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("path")
                    return .dictionary(d)
                case .unsupportedFile:
                    var d = [String: JSON]()
                    d[".tag"] = .str("unsupported_file")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> DownloadError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "path":
                            let v = Files.LookupErrorSerializer().deserialize(d["path"] ?? .null)
                            return DownloadError.path(v)
                        case "unsupported_file":
                            return DownloadError.unsupportedFile
                        case "other":
                            return DownloadError.other
                        default:
                            return DownloadError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The DownloadZipArg struct
    open class DownloadZipArg: CustomStringConvertible {
        /// The path of the folder to download.
        public let path: String
        public init(path: String) {
            stringValidator(pattern: "(/(.|[\\r\\n])*|id:.*)|(rev:[0-9a-f]{9,})|(ns:[0-9]+(/.*)?)")(path)
            self.path = path
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(DownloadZipArgSerializer().serialize(self)))"
        }
    }
    open class DownloadZipArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: DownloadZipArg) -> JSON {
            let output = [ 
            "path": Serialization._StringSerializer.serialize(value.path),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> DownloadZipArg {
            switch json {
                case .dictionary(let dict):
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .null)
                    return DownloadZipArg(path: path)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The DownloadZipError union
    public enum DownloadZipError: CustomStringConvertible {
        /// An unspecified error.
        case path(Files.LookupError)
        /// The folder or a file is too large to download.
        case tooLarge
        /// The folder has too many files to download.
        case tooManyFiles
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(DownloadZipErrorSerializer().serialize(self)))"
        }
    }
    open class DownloadZipErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: DownloadZipError) -> JSON {
            switch value {
                case .path(let arg):
                    var d = ["path": Files.LookupErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("path")
                    return .dictionary(d)
                case .tooLarge:
                    var d = [String: JSON]()
                    d[".tag"] = .str("too_large")
                    return .dictionary(d)
                case .tooManyFiles:
                    var d = [String: JSON]()
                    d[".tag"] = .str("too_many_files")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> DownloadZipError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "path":
                            let v = Files.LookupErrorSerializer().deserialize(d["path"] ?? .null)
                            return DownloadZipError.path(v)
                        case "too_large":
                            return DownloadZipError.tooLarge
                        case "too_many_files":
                            return DownloadZipError.tooManyFiles
                        case "other":
                            return DownloadZipError.other
                        default:
                            return DownloadZipError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The DownloadZipResult struct
    open class DownloadZipResult: CustomStringConvertible {
        /// (no description)
        public let metadata: Files.FolderMetadata
        public init(metadata: Files.FolderMetadata) {
            self.metadata = metadata
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(DownloadZipResultSerializer().serialize(self)))"
        }
    }
    open class DownloadZipResultSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: DownloadZipResult) -> JSON {
            let output = [ 
            "metadata": Files.FolderMetadataSerializer().serialize(value.metadata),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> DownloadZipResult {
            switch json {
                case .dictionary(let dict):
                    let metadata = Files.FolderMetadataSerializer().deserialize(dict["metadata"] ?? .null)
                    return DownloadZipResult(metadata: metadata)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The ExportArg struct
    open class ExportArg: CustomStringConvertible {
        /// The path of the file to be exported.
        public let path: String
        /// The file format to which the file should be exported. This must be one of the formats listed in the file's
        /// export_options returned by getMetadata. If none is specified, the default format (specified in export_as in
        /// file metadata) will be used.
        public let exportFormat: String?
        public init(path: String, exportFormat: String? = nil) {
            stringValidator(pattern: "(/(.|[\\r\\n])*|id:.*)|(rev:[0-9a-f]{9,})|(ns:[0-9]+(/.*)?)")(path)
            self.path = path
            nullableValidator(stringValidator())(exportFormat)
            self.exportFormat = exportFormat
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ExportArgSerializer().serialize(self)))"
        }
    }
    open class ExportArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ExportArg) -> JSON {
            let output = [ 
            "path": Serialization._StringSerializer.serialize(value.path),
            "export_format": NullableSerializer(Serialization._StringSerializer).serialize(value.exportFormat),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ExportArg {
            switch json {
                case .dictionary(let dict):
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .null)
                    let exportFormat = NullableSerializer(Serialization._StringSerializer).deserialize(dict["export_format"] ?? .null)
                    return ExportArg(path: path, exportFormat: exportFormat)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The ExportError union
    public enum ExportError: CustomStringConvertible {
        /// An unspecified error.
        case path(Files.LookupError)
        /// This file type cannot be exported. Use download instead.
        case nonExportable
        /// The specified export format is not a valid option for this file type.
        case invalidExportFormat
        /// The exportable content is not yet available. Please retry later.
        case retryError
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ExportErrorSerializer().serialize(self)))"
        }
    }
    open class ExportErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ExportError) -> JSON {
            switch value {
                case .path(let arg):
                    var d = ["path": Files.LookupErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("path")
                    return .dictionary(d)
                case .nonExportable:
                    var d = [String: JSON]()
                    d[".tag"] = .str("non_exportable")
                    return .dictionary(d)
                case .invalidExportFormat:
                    var d = [String: JSON]()
                    d[".tag"] = .str("invalid_export_format")
                    return .dictionary(d)
                case .retryError:
                    var d = [String: JSON]()
                    d[".tag"] = .str("retry_error")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> ExportError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "path":
                            let v = Files.LookupErrorSerializer().deserialize(d["path"] ?? .null)
                            return ExportError.path(v)
                        case "non_exportable":
                            return ExportError.nonExportable
                        case "invalid_export_format":
                            return ExportError.invalidExportFormat
                        case "retry_error":
                            return ExportError.retryError
                        case "other":
                            return ExportError.other
                        default:
                            return ExportError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Export information for a file.
    open class ExportInfo: CustomStringConvertible {
        /// Format to which the file can be exported to.
        public let exportAs: String?
        /// Additional formats to which the file can be exported. These values can be specified as the export_format in
        /// /files/export.
        public let exportOptions: Array<String>?
        public init(exportAs: String? = nil, exportOptions: Array<String>? = nil) {
            nullableValidator(stringValidator())(exportAs)
            self.exportAs = exportAs
            nullableValidator(arrayValidator(itemValidator: stringValidator()))(exportOptions)
            self.exportOptions = exportOptions
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ExportInfoSerializer().serialize(self)))"
        }
    }
    open class ExportInfoSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ExportInfo) -> JSON {
            let output = [ 
            "export_as": NullableSerializer(Serialization._StringSerializer).serialize(value.exportAs),
            "export_options": NullableSerializer(ArraySerializer(Serialization._StringSerializer)).serialize(value.exportOptions),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ExportInfo {
            switch json {
                case .dictionary(let dict):
                    let exportAs = NullableSerializer(Serialization._StringSerializer).deserialize(dict["export_as"] ?? .null)
                    let exportOptions = NullableSerializer(ArraySerializer(Serialization._StringSerializer)).deserialize(dict["export_options"] ?? .null)
                    return ExportInfo(exportAs: exportAs, exportOptions: exportOptions)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The ExportMetadata struct
    open class ExportMetadata: CustomStringConvertible {
        /// The last component of the path (including extension). This never contains a slash.
        public let name: String
        /// The file size in bytes.
        public let size: UInt64
        /// A hash based on the exported file content. This field can be used to verify data integrity. Similar to
        /// content hash. For more information see our Content hash
        /// https://www.dropbox.com/developers/reference/content-hash page.
        public let exportHash: String?
        /// If the file is a Paper doc, this gives the latest doc revision which can be used in paperUpdate.
        public let paperRevision: Int64?
        public init(name: String, size: UInt64, exportHash: String? = nil, paperRevision: Int64? = nil) {
            stringValidator()(name)
            self.name = name
            comparableValidator()(size)
            self.size = size
            nullableValidator(stringValidator(minLength: 64, maxLength: 64))(exportHash)
            self.exportHash = exportHash
            nullableValidator(comparableValidator())(paperRevision)
            self.paperRevision = paperRevision
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ExportMetadataSerializer().serialize(self)))"
        }
    }
    open class ExportMetadataSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ExportMetadata) -> JSON {
            let output = [ 
            "name": Serialization._StringSerializer.serialize(value.name),
            "size": Serialization._UInt64Serializer.serialize(value.size),
            "export_hash": NullableSerializer(Serialization._StringSerializer).serialize(value.exportHash),
            "paper_revision": NullableSerializer(Serialization._Int64Serializer).serialize(value.paperRevision),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ExportMetadata {
            switch json {
                case .dictionary(let dict):
                    let name = Serialization._StringSerializer.deserialize(dict["name"] ?? .null)
                    let size = Serialization._UInt64Serializer.deserialize(dict["size"] ?? .null)
                    let exportHash = NullableSerializer(Serialization._StringSerializer).deserialize(dict["export_hash"] ?? .null)
                    let paperRevision = NullableSerializer(Serialization._Int64Serializer).deserialize(dict["paper_revision"] ?? .null)
                    return ExportMetadata(name: name, size: size, exportHash: exportHash, paperRevision: paperRevision)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The ExportResult struct
    open class ExportResult: CustomStringConvertible {
        /// Metadata for the exported version of the file.
        public let exportMetadata: Files.ExportMetadata
        /// Metadata for the original file.
        public let fileMetadata: Files.FileMetadata
        public init(exportMetadata: Files.ExportMetadata, fileMetadata: Files.FileMetadata) {
            self.exportMetadata = exportMetadata
            self.fileMetadata = fileMetadata
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ExportResultSerializer().serialize(self)))"
        }
    }
    open class ExportResultSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ExportResult) -> JSON {
            let output = [ 
            "export_metadata": Files.ExportMetadataSerializer().serialize(value.exportMetadata),
            "file_metadata": Files.FileMetadataSerializer().serialize(value.fileMetadata),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ExportResult {
            switch json {
                case .dictionary(let dict):
                    let exportMetadata = Files.ExportMetadataSerializer().deserialize(dict["export_metadata"] ?? .null)
                    let fileMetadata = Files.FileMetadataSerializer().deserialize(dict["file_metadata"] ?? .null)
                    return ExportResult(exportMetadata: exportMetadata, fileMetadata: fileMetadata)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The FileCategory union
    public enum FileCategory: CustomStringConvertible {
        /// jpg, png, gif, and more.
        case image
        /// doc, docx, txt, and more.
        case document
        /// pdf.
        case pdf
        /// xlsx, xls, csv, and more.
        case spreadsheet
        /// ppt, pptx, key, and more.
        case presentation
        /// mp3, wav, mid, and more.
        case audio
        /// mov, wmv, mp4, and more.
        case video
        /// dropbox folder.
        case folder
        /// dropbox paper doc.
        case paper
        /// any file not in one of the categories above.
        case others
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(FileCategorySerializer().serialize(self)))"
        }
    }
    open class FileCategorySerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: FileCategory) -> JSON {
            switch value {
                case .image:
                    var d = [String: JSON]()
                    d[".tag"] = .str("image")
                    return .dictionary(d)
                case .document:
                    var d = [String: JSON]()
                    d[".tag"] = .str("document")
                    return .dictionary(d)
                case .pdf:
                    var d = [String: JSON]()
                    d[".tag"] = .str("pdf")
                    return .dictionary(d)
                case .spreadsheet:
                    var d = [String: JSON]()
                    d[".tag"] = .str("spreadsheet")
                    return .dictionary(d)
                case .presentation:
                    var d = [String: JSON]()
                    d[".tag"] = .str("presentation")
                    return .dictionary(d)
                case .audio:
                    var d = [String: JSON]()
                    d[".tag"] = .str("audio")
                    return .dictionary(d)
                case .video:
                    var d = [String: JSON]()
                    d[".tag"] = .str("video")
                    return .dictionary(d)
                case .folder:
                    var d = [String: JSON]()
                    d[".tag"] = .str("folder")
                    return .dictionary(d)
                case .paper:
                    var d = [String: JSON]()
                    d[".tag"] = .str("paper")
                    return .dictionary(d)
                case .others:
                    var d = [String: JSON]()
                    d[".tag"] = .str("others")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> FileCategory {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "image":
                            return FileCategory.image
                        case "document":
                            return FileCategory.document
                        case "pdf":
                            return FileCategory.pdf
                        case "spreadsheet":
                            return FileCategory.spreadsheet
                        case "presentation":
                            return FileCategory.presentation
                        case "audio":
                            return FileCategory.audio
                        case "video":
                            return FileCategory.video
                        case "folder":
                            return FileCategory.folder
                        case "paper":
                            return FileCategory.paper
                        case "others":
                            return FileCategory.others
                        case "other":
                            return FileCategory.other
                        default:
                            return FileCategory.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The FileLock struct
    open class FileLock: CustomStringConvertible {
        /// The lock description.
        public let content: Files.FileLockContent
        public init(content: Files.FileLockContent) {
            self.content = content
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(FileLockSerializer().serialize(self)))"
        }
    }
    open class FileLockSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: FileLock) -> JSON {
            let output = [ 
            "content": Files.FileLockContentSerializer().serialize(value.content),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> FileLock {
            switch json {
                case .dictionary(let dict):
                    let content = Files.FileLockContentSerializer().deserialize(dict["content"] ?? .null)
                    return FileLock(content: content)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The FileLockContent union
    public enum FileLockContent: CustomStringConvertible {
        /// Empty type to indicate no lock.
        case unlocked
        /// A lock held by a single user.
        case singleUser(Files.SingleUserLock)
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(FileLockContentSerializer().serialize(self)))"
        }
    }
    open class FileLockContentSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: FileLockContent) -> JSON {
            switch value {
                case .unlocked:
                    var d = [String: JSON]()
                    d[".tag"] = .str("unlocked")
                    return .dictionary(d)
                case .singleUser(let arg):
                    var d = Serialization.getFields(Files.SingleUserLockSerializer().serialize(arg))
                    d[".tag"] = .str("single_user")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> FileLockContent {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "unlocked":
                            return FileLockContent.unlocked
                        case "single_user":
                            let v = Files.SingleUserLockSerializer().deserialize(json)
                            return FileLockContent.singleUser(v)
                        case "other":
                            return FileLockContent.other
                        default:
                            return FileLockContent.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The FileLockMetadata struct
    open class FileLockMetadata: CustomStringConvertible {
        /// True if caller holds the file lock.
        public let isLockholder: Bool?
        /// The display name of the lock holder.
        public let lockholderName: String?
        /// The account ID of the lock holder if known.
        public let lockholderAccountId: String?
        /// The timestamp of the lock was created.
        public let created: Date?
        public init(isLockholder: Bool? = nil, lockholderName: String? = nil, lockholderAccountId: String? = nil, created: Date? = nil) {
            self.isLockholder = isLockholder
            nullableValidator(stringValidator())(lockholderName)
            self.lockholderName = lockholderName
            nullableValidator(stringValidator(minLength: 40, maxLength: 40))(lockholderAccountId)
            self.lockholderAccountId = lockholderAccountId
            self.created = created
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(FileLockMetadataSerializer().serialize(self)))"
        }
    }
    open class FileLockMetadataSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: FileLockMetadata) -> JSON {
            let output = [ 
            "is_lockholder": NullableSerializer(Serialization._BoolSerializer).serialize(value.isLockholder),
            "lockholder_name": NullableSerializer(Serialization._StringSerializer).serialize(value.lockholderName),
            "lockholder_account_id": NullableSerializer(Serialization._StringSerializer).serialize(value.lockholderAccountId),
            "created": NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.created),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> FileLockMetadata {
            switch json {
                case .dictionary(let dict):
                    let isLockholder = NullableSerializer(Serialization._BoolSerializer).deserialize(dict["is_lockholder"] ?? .null)
                    let lockholderName = NullableSerializer(Serialization._StringSerializer).deserialize(dict["lockholder_name"] ?? .null)
                    let lockholderAccountId = NullableSerializer(Serialization._StringSerializer).deserialize(dict["lockholder_account_id"] ?? .null)
                    let created = NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).deserialize(dict["created"] ?? .null)
                    return FileLockMetadata(isLockholder: isLockholder, lockholderName: lockholderName, lockholderAccountId: lockholderAccountId, created: created)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The FileMetadata struct
    open class FileMetadata: Files.Metadata {
        /// A unique identifier for the file.
        public let id: String
        /// For files, this is the modification time set by the desktop client when the file was added to Dropbox. Since
        /// this time is not verified (the Dropbox server stores whatever the desktop client sends up), this should only
        /// be used for display purposes (such as sorting) and not, for example, to determine if a file has changed or
        /// not.
        public let clientModified: Date
        /// The last time the file was modified on Dropbox.
        public let serverModified: Date
        /// A unique identifier for the current revision of a file. This field is the same rev as elsewhere in the API
        /// and can be used to detect changes and avoid conflicts.
        public let rev: String
        /// The file size in bytes.
        public let size: UInt64
        /// Additional information if the file is a photo or video. This field will not be set on entries returned by
        /// listFolder, listFolderContinue, or getThumbnailBatch, starting December 2, 2019.
        public let mediaInfo: Files.MediaInfo?
        /// Set if this file is a symlink.
        public let symlinkInfo: Files.SymlinkInfo?
        /// Set if this file is contained in a shared folder.
        public let sharingInfo: Files.FileSharingInfo?
        /// If true, file can be downloaded directly; else the file must be exported.
        public let isDownloadable: Bool
        /// Information about format this file can be exported to. This filed must be set if isDownloadable is set to
        /// false.
        public let exportInfo: Files.ExportInfo?
        /// Additional information if the file has custom properties with the property template specified.
        public let propertyGroups: Array<FileProperties.PropertyGroup>?
        /// This flag will only be present if include_has_explicit_shared_members  is true in listFolder or getMetadata.
        /// If this  flag is present, it will be true if this file has any explicit shared  members. This is different
        /// from sharing_info in that this could be true  in the case where a file has explicit members but is not
        /// contained within  a shared folder.
        public let hasExplicitSharedMembers: Bool?
        /// A hash of the file content. This field can be used to verify data integrity. For more information see our
        /// Content hash https://www.dropbox.com/developers/reference/content-hash page.
        public let contentHash: String?
        /// If present, the metadata associated with the file's current lock.
        public let fileLockInfo: Files.FileLockMetadata?
        public init(name: String, id: String, clientModified: Date, serverModified: Date, rev: String, size: UInt64, pathLower: String? = nil, pathDisplay: String? = nil, parentSharedFolderId: String? = nil, mediaInfo: Files.MediaInfo? = nil, symlinkInfo: Files.SymlinkInfo? = nil, sharingInfo: Files.FileSharingInfo? = nil, isDownloadable: Bool = true, exportInfo: Files.ExportInfo? = nil, propertyGroups: Array<FileProperties.PropertyGroup>? = nil, hasExplicitSharedMembers: Bool? = nil, contentHash: String? = nil, fileLockInfo: Files.FileLockMetadata? = nil) {
            stringValidator(minLength: 1)(id)
            self.id = id
            self.clientModified = clientModified
            self.serverModified = serverModified
            stringValidator(minLength: 9, pattern: "[0-9a-f]+")(rev)
            self.rev = rev
            comparableValidator()(size)
            self.size = size
            self.mediaInfo = mediaInfo
            self.symlinkInfo = symlinkInfo
            self.sharingInfo = sharingInfo
            self.isDownloadable = isDownloadable
            self.exportInfo = exportInfo
            self.propertyGroups = propertyGroups
            self.hasExplicitSharedMembers = hasExplicitSharedMembers
            nullableValidator(stringValidator(minLength: 64, maxLength: 64))(contentHash)
            self.contentHash = contentHash
            self.fileLockInfo = fileLockInfo
            super.init(name: name, pathLower: pathLower, pathDisplay: pathDisplay, parentSharedFolderId: parentSharedFolderId)
        }
        open override var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(FileMetadataSerializer().serialize(self)))"
        }
    }
    open class FileMetadataSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: FileMetadata) -> JSON {
            let output = [ 
            "name": Serialization._StringSerializer.serialize(value.name),
            "id": Serialization._StringSerializer.serialize(value.id),
            "client_modified": NSDateSerializer("%Y-%m-%dT%H:%M:%SZ").serialize(value.clientModified),
            "server_modified": NSDateSerializer("%Y-%m-%dT%H:%M:%SZ").serialize(value.serverModified),
            "rev": Serialization._StringSerializer.serialize(value.rev),
            "size": Serialization._UInt64Serializer.serialize(value.size),
            "path_lower": NullableSerializer(Serialization._StringSerializer).serialize(value.pathLower),
            "path_display": NullableSerializer(Serialization._StringSerializer).serialize(value.pathDisplay),
            "parent_shared_folder_id": NullableSerializer(Serialization._StringSerializer).serialize(value.parentSharedFolderId),
            "media_info": NullableSerializer(Files.MediaInfoSerializer()).serialize(value.mediaInfo),
            "symlink_info": NullableSerializer(Files.SymlinkInfoSerializer()).serialize(value.symlinkInfo),
            "sharing_info": NullableSerializer(Files.FileSharingInfoSerializer()).serialize(value.sharingInfo),
            "is_downloadable": Serialization._BoolSerializer.serialize(value.isDownloadable),
            "export_info": NullableSerializer(Files.ExportInfoSerializer()).serialize(value.exportInfo),
            "property_groups": NullableSerializer(ArraySerializer(FileProperties.PropertyGroupSerializer())).serialize(value.propertyGroups),
            "has_explicit_shared_members": NullableSerializer(Serialization._BoolSerializer).serialize(value.hasExplicitSharedMembers),
            "content_hash": NullableSerializer(Serialization._StringSerializer).serialize(value.contentHash),
            "file_lock_info": NullableSerializer(Files.FileLockMetadataSerializer()).serialize(value.fileLockInfo),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> FileMetadata {
            switch json {
                case .dictionary(let dict):
                    let name = Serialization._StringSerializer.deserialize(dict["name"] ?? .null)
                    let id = Serialization._StringSerializer.deserialize(dict["id"] ?? .null)
                    let clientModified = NSDateSerializer("%Y-%m-%dT%H:%M:%SZ").deserialize(dict["client_modified"] ?? .null)
                    let serverModified = NSDateSerializer("%Y-%m-%dT%H:%M:%SZ").deserialize(dict["server_modified"] ?? .null)
                    let rev = Serialization._StringSerializer.deserialize(dict["rev"] ?? .null)
                    let size = Serialization._UInt64Serializer.deserialize(dict["size"] ?? .null)
                    let pathLower = NullableSerializer(Serialization._StringSerializer).deserialize(dict["path_lower"] ?? .null)
                    let pathDisplay = NullableSerializer(Serialization._StringSerializer).deserialize(dict["path_display"] ?? .null)
                    let parentSharedFolderId = NullableSerializer(Serialization._StringSerializer).deserialize(dict["parent_shared_folder_id"] ?? .null)
                    let mediaInfo = NullableSerializer(Files.MediaInfoSerializer()).deserialize(dict["media_info"] ?? .null)
                    let symlinkInfo = NullableSerializer(Files.SymlinkInfoSerializer()).deserialize(dict["symlink_info"] ?? .null)
                    let sharingInfo = NullableSerializer(Files.FileSharingInfoSerializer()).deserialize(dict["sharing_info"] ?? .null)
                    let isDownloadable = Serialization._BoolSerializer.deserialize(dict["is_downloadable"] ?? .number(1))
                    let exportInfo = NullableSerializer(Files.ExportInfoSerializer()).deserialize(dict["export_info"] ?? .null)
                    let propertyGroups = NullableSerializer(ArraySerializer(FileProperties.PropertyGroupSerializer())).deserialize(dict["property_groups"] ?? .null)
                    let hasExplicitSharedMembers = NullableSerializer(Serialization._BoolSerializer).deserialize(dict["has_explicit_shared_members"] ?? .null)
                    let contentHash = NullableSerializer(Serialization._StringSerializer).deserialize(dict["content_hash"] ?? .null)
                    let fileLockInfo = NullableSerializer(Files.FileLockMetadataSerializer()).deserialize(dict["file_lock_info"] ?? .null)
                    return FileMetadata(name: name, id: id, clientModified: clientModified, serverModified: serverModified, rev: rev, size: size, pathLower: pathLower, pathDisplay: pathDisplay, parentSharedFolderId: parentSharedFolderId, mediaInfo: mediaInfo, symlinkInfo: symlinkInfo, sharingInfo: sharingInfo, isDownloadable: isDownloadable, exportInfo: exportInfo, propertyGroups: propertyGroups, hasExplicitSharedMembers: hasExplicitSharedMembers, contentHash: contentHash, fileLockInfo: fileLockInfo)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Sharing info for a file or folder.
    open class SharingInfo: CustomStringConvertible {
        /// True if the file or folder is inside a read-only shared folder.
        public let readOnly: Bool
        public init(readOnly: Bool) {
            self.readOnly = readOnly
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharingInfoSerializer().serialize(self)))"
        }
    }
    open class SharingInfoSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SharingInfo) -> JSON {
            let output = [ 
            "read_only": Serialization._BoolSerializer.serialize(value.readOnly),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SharingInfo {
            switch json {
                case .dictionary(let dict):
                    let readOnly = Serialization._BoolSerializer.deserialize(dict["read_only"] ?? .null)
                    return SharingInfo(readOnly: readOnly)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Sharing info for a file which is contained by a shared folder.
    open class FileSharingInfo: Files.SharingInfo {
        /// ID of shared folder that holds this file.
        public let parentSharedFolderId: String
        /// The last user who modified the file. This field will be null if the user's account has been deleted.
        public let modifiedBy: String?
        public init(readOnly: Bool, parentSharedFolderId: String, modifiedBy: String? = nil) {
            stringValidator(pattern: "[-_0-9a-zA-Z:]+")(parentSharedFolderId)
            self.parentSharedFolderId = parentSharedFolderId
            nullableValidator(stringValidator(minLength: 40, maxLength: 40))(modifiedBy)
            self.modifiedBy = modifiedBy
            super.init(readOnly: readOnly)
        }
        open override var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(FileSharingInfoSerializer().serialize(self)))"
        }
    }
    open class FileSharingInfoSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: FileSharingInfo) -> JSON {
            let output = [ 
            "read_only": Serialization._BoolSerializer.serialize(value.readOnly),
            "parent_shared_folder_id": Serialization._StringSerializer.serialize(value.parentSharedFolderId),
            "modified_by": NullableSerializer(Serialization._StringSerializer).serialize(value.modifiedBy),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> FileSharingInfo {
            switch json {
                case .dictionary(let dict):
                    let readOnly = Serialization._BoolSerializer.deserialize(dict["read_only"] ?? .null)
                    let parentSharedFolderId = Serialization._StringSerializer.deserialize(dict["parent_shared_folder_id"] ?? .null)
                    let modifiedBy = NullableSerializer(Serialization._StringSerializer).deserialize(dict["modified_by"] ?? .null)
                    return FileSharingInfo(readOnly: readOnly, parentSharedFolderId: parentSharedFolderId, modifiedBy: modifiedBy)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The FileStatus union
    public enum FileStatus: CustomStringConvertible {
        /// An unspecified error.
        case active
        /// An unspecified error.
        case deleted
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(FileStatusSerializer().serialize(self)))"
        }
    }
    open class FileStatusSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: FileStatus) -> JSON {
            switch value {
                case .active:
                    var d = [String: JSON]()
                    d[".tag"] = .str("active")
                    return .dictionary(d)
                case .deleted:
                    var d = [String: JSON]()
                    d[".tag"] = .str("deleted")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> FileStatus {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "active":
                            return FileStatus.active
                        case "deleted":
                            return FileStatus.deleted
                        case "other":
                            return FileStatus.other
                        default:
                            return FileStatus.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The FolderMetadata struct
    open class FolderMetadata: Files.Metadata {
        /// A unique identifier for the folder.
        public let id: String
        /// Please use sharingInfo instead.
        public let sharedFolderId: String?
        /// Set if the folder is contained in a shared folder or is a shared folder mount point.
        public let sharingInfo: Files.FolderSharingInfo?
        /// Additional information if the file has custom properties with the property template specified. Note that
        /// only properties associated with user-owned templates, not team-owned templates, can be attached to folders.
        public let propertyGroups: Array<FileProperties.PropertyGroup>?
        public init(name: String, id: String, pathLower: String? = nil, pathDisplay: String? = nil, parentSharedFolderId: String? = nil, sharedFolderId: String? = nil, sharingInfo: Files.FolderSharingInfo? = nil, propertyGroups: Array<FileProperties.PropertyGroup>? = nil) {
            stringValidator(minLength: 1)(id)
            self.id = id
            nullableValidator(stringValidator(pattern: "[-_0-9a-zA-Z:]+"))(sharedFolderId)
            self.sharedFolderId = sharedFolderId
            self.sharingInfo = sharingInfo
            self.propertyGroups = propertyGroups
            super.init(name: name, pathLower: pathLower, pathDisplay: pathDisplay, parentSharedFolderId: parentSharedFolderId)
        }
        open override var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(FolderMetadataSerializer().serialize(self)))"
        }
    }
    open class FolderMetadataSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: FolderMetadata) -> JSON {
            let output = [ 
            "name": Serialization._StringSerializer.serialize(value.name),
            "id": Serialization._StringSerializer.serialize(value.id),
            "path_lower": NullableSerializer(Serialization._StringSerializer).serialize(value.pathLower),
            "path_display": NullableSerializer(Serialization._StringSerializer).serialize(value.pathDisplay),
            "parent_shared_folder_id": NullableSerializer(Serialization._StringSerializer).serialize(value.parentSharedFolderId),
            "shared_folder_id": NullableSerializer(Serialization._StringSerializer).serialize(value.sharedFolderId),
            "sharing_info": NullableSerializer(Files.FolderSharingInfoSerializer()).serialize(value.sharingInfo),
            "property_groups": NullableSerializer(ArraySerializer(FileProperties.PropertyGroupSerializer())).serialize(value.propertyGroups),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> FolderMetadata {
            switch json {
                case .dictionary(let dict):
                    let name = Serialization._StringSerializer.deserialize(dict["name"] ?? .null)
                    let id = Serialization._StringSerializer.deserialize(dict["id"] ?? .null)
                    let pathLower = NullableSerializer(Serialization._StringSerializer).deserialize(dict["path_lower"] ?? .null)
                    let pathDisplay = NullableSerializer(Serialization._StringSerializer).deserialize(dict["path_display"] ?? .null)
                    let parentSharedFolderId = NullableSerializer(Serialization._StringSerializer).deserialize(dict["parent_shared_folder_id"] ?? .null)
                    let sharedFolderId = NullableSerializer(Serialization._StringSerializer).deserialize(dict["shared_folder_id"] ?? .null)
                    let sharingInfo = NullableSerializer(Files.FolderSharingInfoSerializer()).deserialize(dict["sharing_info"] ?? .null)
                    let propertyGroups = NullableSerializer(ArraySerializer(FileProperties.PropertyGroupSerializer())).deserialize(dict["property_groups"] ?? .null)
                    return FolderMetadata(name: name, id: id, pathLower: pathLower, pathDisplay: pathDisplay, parentSharedFolderId: parentSharedFolderId, sharedFolderId: sharedFolderId, sharingInfo: sharingInfo, propertyGroups: propertyGroups)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Sharing info for a folder which is contained in a shared folder or is a shared folder mount point.
    open class FolderSharingInfo: Files.SharingInfo {
        /// Set if the folder is contained by a shared folder.
        public let parentSharedFolderId: String?
        /// If this folder is a shared folder mount point, the ID of the shared folder mounted at this location.
        public let sharedFolderId: String?
        /// Specifies that the folder can only be traversed and the user can only see a limited subset of the contents
        /// of this folder because they don't have read access to this folder. They do, however, have access to some sub
        /// folder.
        public let traverseOnly: Bool
        /// Specifies that the folder cannot be accessed by the user.
        public let noAccess: Bool
        public init(readOnly: Bool, parentSharedFolderId: String? = nil, sharedFolderId: String? = nil, traverseOnly: Bool = false, noAccess: Bool = false) {
            nullableValidator(stringValidator(pattern: "[-_0-9a-zA-Z:]+"))(parentSharedFolderId)
            self.parentSharedFolderId = parentSharedFolderId
            nullableValidator(stringValidator(pattern: "[-_0-9a-zA-Z:]+"))(sharedFolderId)
            self.sharedFolderId = sharedFolderId
            self.traverseOnly = traverseOnly
            self.noAccess = noAccess
            super.init(readOnly: readOnly)
        }
        open override var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(FolderSharingInfoSerializer().serialize(self)))"
        }
    }
    open class FolderSharingInfoSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: FolderSharingInfo) -> JSON {
            let output = [ 
            "read_only": Serialization._BoolSerializer.serialize(value.readOnly),
            "parent_shared_folder_id": NullableSerializer(Serialization._StringSerializer).serialize(value.parentSharedFolderId),
            "shared_folder_id": NullableSerializer(Serialization._StringSerializer).serialize(value.sharedFolderId),
            "traverse_only": Serialization._BoolSerializer.serialize(value.traverseOnly),
            "no_access": Serialization._BoolSerializer.serialize(value.noAccess),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> FolderSharingInfo {
            switch json {
                case .dictionary(let dict):
                    let readOnly = Serialization._BoolSerializer.deserialize(dict["read_only"] ?? .null)
                    let parentSharedFolderId = NullableSerializer(Serialization._StringSerializer).deserialize(dict["parent_shared_folder_id"] ?? .null)
                    let sharedFolderId = NullableSerializer(Serialization._StringSerializer).deserialize(dict["shared_folder_id"] ?? .null)
                    let traverseOnly = Serialization._BoolSerializer.deserialize(dict["traverse_only"] ?? .number(0))
                    let noAccess = Serialization._BoolSerializer.deserialize(dict["no_access"] ?? .number(0))
                    return FolderSharingInfo(readOnly: readOnly, parentSharedFolderId: parentSharedFolderId, sharedFolderId: sharedFolderId, traverseOnly: traverseOnly, noAccess: noAccess)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The GetCopyReferenceArg struct
    open class GetCopyReferenceArg: CustomStringConvertible {
        /// The path to the file or folder you want to get a copy reference to.
        public let path: String
        public init(path: String) {
            stringValidator(pattern: "(/(.|[\\r\\n])*|id:.*)|(rev:[0-9a-f]{9,})|(ns:[0-9]+(/.*)?)")(path)
            self.path = path
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GetCopyReferenceArgSerializer().serialize(self)))"
        }
    }
    open class GetCopyReferenceArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GetCopyReferenceArg) -> JSON {
            let output = [ 
            "path": Serialization._StringSerializer.serialize(value.path),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> GetCopyReferenceArg {
            switch json {
                case .dictionary(let dict):
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .null)
                    return GetCopyReferenceArg(path: path)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The GetCopyReferenceError union
    public enum GetCopyReferenceError: CustomStringConvertible {
        /// An unspecified error.
        case path(Files.LookupError)
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GetCopyReferenceErrorSerializer().serialize(self)))"
        }
    }
    open class GetCopyReferenceErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GetCopyReferenceError) -> JSON {
            switch value {
                case .path(let arg):
                    var d = ["path": Files.LookupErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("path")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> GetCopyReferenceError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "path":
                            let v = Files.LookupErrorSerializer().deserialize(d["path"] ?? .null)
                            return GetCopyReferenceError.path(v)
                        case "other":
                            return GetCopyReferenceError.other
                        default:
                            return GetCopyReferenceError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The GetCopyReferenceResult struct
    open class GetCopyReferenceResult: CustomStringConvertible {
        /// Metadata of the file or folder.
        public let metadata: Files.Metadata
        /// A copy reference to the file or folder.
        public let copyReference: String
        /// The expiration date of the copy reference. This value is currently set to be far enough in the future so
        /// that expiration is effectively not an issue.
        public let expires: Date
        public init(metadata: Files.Metadata, copyReference: String, expires: Date) {
            self.metadata = metadata
            stringValidator()(copyReference)
            self.copyReference = copyReference
            self.expires = expires
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GetCopyReferenceResultSerializer().serialize(self)))"
        }
    }
    open class GetCopyReferenceResultSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GetCopyReferenceResult) -> JSON {
            let output = [ 
            "metadata": Files.MetadataSerializer().serialize(value.metadata),
            "copy_reference": Serialization._StringSerializer.serialize(value.copyReference),
            "expires": NSDateSerializer("%Y-%m-%dT%H:%M:%SZ").serialize(value.expires),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> GetCopyReferenceResult {
            switch json {
                case .dictionary(let dict):
                    let metadata = Files.MetadataSerializer().deserialize(dict["metadata"] ?? .null)
                    let copyReference = Serialization._StringSerializer.deserialize(dict["copy_reference"] ?? .null)
                    let expires = NSDateSerializer("%Y-%m-%dT%H:%M:%SZ").deserialize(dict["expires"] ?? .null)
                    return GetCopyReferenceResult(metadata: metadata, copyReference: copyReference, expires: expires)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The GetTemporaryLinkArg struct
    open class GetTemporaryLinkArg: CustomStringConvertible {
        /// The path to the file you want a temporary link to.
        public let path: String
        public init(path: String) {
            stringValidator(pattern: "(/(.|[\\r\\n])*|id:.*)|(rev:[0-9a-f]{9,})|(ns:[0-9]+(/.*)?)")(path)
            self.path = path
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GetTemporaryLinkArgSerializer().serialize(self)))"
        }
    }
    open class GetTemporaryLinkArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GetTemporaryLinkArg) -> JSON {
            let output = [ 
            "path": Serialization._StringSerializer.serialize(value.path),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> GetTemporaryLinkArg {
            switch json {
                case .dictionary(let dict):
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .null)
                    return GetTemporaryLinkArg(path: path)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The GetTemporaryLinkError union
    public enum GetTemporaryLinkError: CustomStringConvertible {
        /// An unspecified error.
        case path(Files.LookupError)
        /// This user's email address is not verified. This functionality is only available on accounts with a verified
        /// email address. Users can verify their email address here https://www.dropbox.com/help/317.
        case emailNotVerified
        /// Cannot get temporary link to this file type; use export instead.
        case unsupportedFile
        /// The user is not allowed to request a temporary link to the specified file. For example, this can occur if
        /// the file is restricted or if the user's links are banned
        /// https://help.dropbox.com/files-folders/share/banned-links.
        case notAllowed
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GetTemporaryLinkErrorSerializer().serialize(self)))"
        }
    }
    open class GetTemporaryLinkErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GetTemporaryLinkError) -> JSON {
            switch value {
                case .path(let arg):
                    var d = ["path": Files.LookupErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("path")
                    return .dictionary(d)
                case .emailNotVerified:
                    var d = [String: JSON]()
                    d[".tag"] = .str("email_not_verified")
                    return .dictionary(d)
                case .unsupportedFile:
                    var d = [String: JSON]()
                    d[".tag"] = .str("unsupported_file")
                    return .dictionary(d)
                case .notAllowed:
                    var d = [String: JSON]()
                    d[".tag"] = .str("not_allowed")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> GetTemporaryLinkError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "path":
                            let v = Files.LookupErrorSerializer().deserialize(d["path"] ?? .null)
                            return GetTemporaryLinkError.path(v)
                        case "email_not_verified":
                            return GetTemporaryLinkError.emailNotVerified
                        case "unsupported_file":
                            return GetTemporaryLinkError.unsupportedFile
                        case "not_allowed":
                            return GetTemporaryLinkError.notAllowed
                        case "other":
                            return GetTemporaryLinkError.other
                        default:
                            return GetTemporaryLinkError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The GetTemporaryLinkResult struct
    open class GetTemporaryLinkResult: CustomStringConvertible {
        /// Metadata of the file.
        public let metadata: Files.FileMetadata
        /// The temporary link which can be used to stream content the file.
        public let link: String
        public init(metadata: Files.FileMetadata, link: String) {
            self.metadata = metadata
            stringValidator()(link)
            self.link = link
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GetTemporaryLinkResultSerializer().serialize(self)))"
        }
    }
    open class GetTemporaryLinkResultSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GetTemporaryLinkResult) -> JSON {
            let output = [ 
            "metadata": Files.FileMetadataSerializer().serialize(value.metadata),
            "link": Serialization._StringSerializer.serialize(value.link),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> GetTemporaryLinkResult {
            switch json {
                case .dictionary(let dict):
                    let metadata = Files.FileMetadataSerializer().deserialize(dict["metadata"] ?? .null)
                    let link = Serialization._StringSerializer.deserialize(dict["link"] ?? .null)
                    return GetTemporaryLinkResult(metadata: metadata, link: link)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The GetTemporaryUploadLinkArg struct
    open class GetTemporaryUploadLinkArg: CustomStringConvertible {
        /// Contains the path and other optional modifiers for the future upload commit. Equivalent to the parameters
        /// provided to upload.
        public let commitInfo: Files.CommitInfo
        /// How long before this link expires, in seconds.  Attempting to start an upload with this link longer than
        /// this period  of time after link creation will result in an error.
        public let duration: Double
        public init(commitInfo: Files.CommitInfo, duration: Double = 14400.0) {
            self.commitInfo = commitInfo
            comparableValidator(minValue: 60.0, maxValue: 14400.0)(duration)
            self.duration = duration
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GetTemporaryUploadLinkArgSerializer().serialize(self)))"
        }
    }
    open class GetTemporaryUploadLinkArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GetTemporaryUploadLinkArg) -> JSON {
            let output = [ 
            "commit_info": Files.CommitInfoSerializer().serialize(value.commitInfo),
            "duration": Serialization._DoubleSerializer.serialize(value.duration),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> GetTemporaryUploadLinkArg {
            switch json {
                case .dictionary(let dict):
                    let commitInfo = Files.CommitInfoSerializer().deserialize(dict["commit_info"] ?? .null)
                    let duration = Serialization._DoubleSerializer.deserialize(dict["duration"] ?? .number(14400.0))
                    return GetTemporaryUploadLinkArg(commitInfo: commitInfo, duration: duration)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The GetTemporaryUploadLinkResult struct
    open class GetTemporaryUploadLinkResult: CustomStringConvertible {
        /// The temporary link which can be used to stream a file to a Dropbox location.
        public let link: String
        public init(link: String) {
            stringValidator()(link)
            self.link = link
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GetTemporaryUploadLinkResultSerializer().serialize(self)))"
        }
    }
    open class GetTemporaryUploadLinkResultSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GetTemporaryUploadLinkResult) -> JSON {
            let output = [ 
            "link": Serialization._StringSerializer.serialize(value.link),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> GetTemporaryUploadLinkResult {
            switch json {
                case .dictionary(let dict):
                    let link = Serialization._StringSerializer.deserialize(dict["link"] ?? .null)
                    return GetTemporaryUploadLinkResult(link: link)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Arguments for getThumbnailBatch.
    open class GetThumbnailBatchArg: CustomStringConvertible {
        /// List of files to get thumbnails.
        public let entries: Array<Files.ThumbnailArg>
        public init(entries: Array<Files.ThumbnailArg>) {
            self.entries = entries
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GetThumbnailBatchArgSerializer().serialize(self)))"
        }
    }
    open class GetThumbnailBatchArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GetThumbnailBatchArg) -> JSON {
            let output = [ 
            "entries": ArraySerializer(Files.ThumbnailArgSerializer()).serialize(value.entries),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> GetThumbnailBatchArg {
            switch json {
                case .dictionary(let dict):
                    let entries = ArraySerializer(Files.ThumbnailArgSerializer()).deserialize(dict["entries"] ?? .null)
                    return GetThumbnailBatchArg(entries: entries)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The GetThumbnailBatchError union
    public enum GetThumbnailBatchError: CustomStringConvertible {
        /// The operation involves more than 25 files.
        case tooManyFiles
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GetThumbnailBatchErrorSerializer().serialize(self)))"
        }
    }
    open class GetThumbnailBatchErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GetThumbnailBatchError) -> JSON {
            switch value {
                case .tooManyFiles:
                    var d = [String: JSON]()
                    d[".tag"] = .str("too_many_files")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> GetThumbnailBatchError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "too_many_files":
                            return GetThumbnailBatchError.tooManyFiles
                        case "other":
                            return GetThumbnailBatchError.other
                        default:
                            return GetThumbnailBatchError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The GetThumbnailBatchResult struct
    open class GetThumbnailBatchResult: CustomStringConvertible {
        /// List of files and their thumbnails.
        public let entries: Array<Files.GetThumbnailBatchResultEntry>
        public init(entries: Array<Files.GetThumbnailBatchResultEntry>) {
            self.entries = entries
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GetThumbnailBatchResultSerializer().serialize(self)))"
        }
    }
    open class GetThumbnailBatchResultSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GetThumbnailBatchResult) -> JSON {
            let output = [ 
            "entries": ArraySerializer(Files.GetThumbnailBatchResultEntrySerializer()).serialize(value.entries),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> GetThumbnailBatchResult {
            switch json {
                case .dictionary(let dict):
                    let entries = ArraySerializer(Files.GetThumbnailBatchResultEntrySerializer()).deserialize(dict["entries"] ?? .null)
                    return GetThumbnailBatchResult(entries: entries)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The GetThumbnailBatchResultData struct
    open class GetThumbnailBatchResultData: CustomStringConvertible {
        /// (no description)
        public let metadata: Files.FileMetadata
        /// A string containing the base64-encoded thumbnail data for this file.
        public let thumbnail: String
        public init(metadata: Files.FileMetadata, thumbnail: String) {
            self.metadata = metadata
            stringValidator()(thumbnail)
            self.thumbnail = thumbnail
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GetThumbnailBatchResultDataSerializer().serialize(self)))"
        }
    }
    open class GetThumbnailBatchResultDataSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GetThumbnailBatchResultData) -> JSON {
            let output = [ 
            "metadata": Files.FileMetadataSerializer().serialize(value.metadata),
            "thumbnail": Serialization._StringSerializer.serialize(value.thumbnail),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> GetThumbnailBatchResultData {
            switch json {
                case .dictionary(let dict):
                    let metadata = Files.FileMetadataSerializer().deserialize(dict["metadata"] ?? .null)
                    let thumbnail = Serialization._StringSerializer.deserialize(dict["thumbnail"] ?? .null)
                    return GetThumbnailBatchResultData(metadata: metadata, thumbnail: thumbnail)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The GetThumbnailBatchResultEntry union
    public enum GetThumbnailBatchResultEntry: CustomStringConvertible {
        /// An unspecified error.
        case success(Files.GetThumbnailBatchResultData)
        /// The result for this file if it was an error.
        case failure(Files.ThumbnailError)
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GetThumbnailBatchResultEntrySerializer().serialize(self)))"
        }
    }
    open class GetThumbnailBatchResultEntrySerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GetThumbnailBatchResultEntry) -> JSON {
            switch value {
                case .success(let arg):
                    var d = Serialization.getFields(Files.GetThumbnailBatchResultDataSerializer().serialize(arg))
                    d[".tag"] = .str("success")
                    return .dictionary(d)
                case .failure(let arg):
                    var d = ["failure": Files.ThumbnailErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("failure")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> GetThumbnailBatchResultEntry {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "success":
                            let v = Files.GetThumbnailBatchResultDataSerializer().deserialize(json)
                            return GetThumbnailBatchResultEntry.success(v)
                        case "failure":
                            let v = Files.ThumbnailErrorSerializer().deserialize(d["failure"] ?? .null)
                            return GetThumbnailBatchResultEntry.failure(v)
                        case "other":
                            return GetThumbnailBatchResultEntry.other
                        default:
                            return GetThumbnailBatchResultEntry.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// GPS coordinates for a photo or video.
    open class GpsCoordinates: CustomStringConvertible {
        /// Latitude of the GPS coordinates.
        public let latitude: Double
        /// Longitude of the GPS coordinates.
        public let longitude: Double
        public init(latitude: Double, longitude: Double) {
            comparableValidator()(latitude)
            self.latitude = latitude
            comparableValidator()(longitude)
            self.longitude = longitude
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GpsCoordinatesSerializer().serialize(self)))"
        }
    }
    open class GpsCoordinatesSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GpsCoordinates) -> JSON {
            let output = [ 
            "latitude": Serialization._DoubleSerializer.serialize(value.latitude),
            "longitude": Serialization._DoubleSerializer.serialize(value.longitude),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> GpsCoordinates {
            switch json {
                case .dictionary(let dict):
                    let latitude = Serialization._DoubleSerializer.deserialize(dict["latitude"] ?? .null)
                    let longitude = Serialization._DoubleSerializer.deserialize(dict["longitude"] ?? .null)
                    return GpsCoordinates(latitude: latitude, longitude: longitude)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The HighlightSpan struct
    open class HighlightSpan: CustomStringConvertible {
        /// String to be determined whether it should be highlighted or not.
        public let highlightStr: String
        /// The string should be highlighted or not.
        public let isHighlighted: Bool
        public init(highlightStr: String, isHighlighted: Bool) {
            stringValidator()(highlightStr)
            self.highlightStr = highlightStr
            self.isHighlighted = isHighlighted
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(HighlightSpanSerializer().serialize(self)))"
        }
    }
    open class HighlightSpanSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: HighlightSpan) -> JSON {
            let output = [ 
            "highlight_str": Serialization._StringSerializer.serialize(value.highlightStr),
            "is_highlighted": Serialization._BoolSerializer.serialize(value.isHighlighted),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> HighlightSpan {
            switch json {
                case .dictionary(let dict):
                    let highlightStr = Serialization._StringSerializer.deserialize(dict["highlight_str"] ?? .null)
                    let isHighlighted = Serialization._BoolSerializer.deserialize(dict["is_highlighted"] ?? .null)
                    return HighlightSpan(highlightStr: highlightStr, isHighlighted: isHighlighted)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The import format of the incoming Paper doc content.
    public enum ImportFormat: CustomStringConvertible {
        /// The provided data is interpreted as standard HTML.
        case html
        /// The provided data is interpreted as markdown.
        case markdown
        /// The provided data is interpreted as plain text.
        case plainText
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ImportFormatSerializer().serialize(self)))"
        }
    }
    open class ImportFormatSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ImportFormat) -> JSON {
            switch value {
                case .html:
                    var d = [String: JSON]()
                    d[".tag"] = .str("html")
                    return .dictionary(d)
                case .markdown:
                    var d = [String: JSON]()
                    d[".tag"] = .str("markdown")
                    return .dictionary(d)
                case .plainText:
                    var d = [String: JSON]()
                    d[".tag"] = .str("plain_text")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> ImportFormat {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "html":
                            return ImportFormat.html
                        case "markdown":
                            return ImportFormat.markdown
                        case "plain_text":
                            return ImportFormat.plainText
                        case "other":
                            return ImportFormat.other
                        default:
                            return ImportFormat.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The ListFolderArg struct
    open class ListFolderArg: CustomStringConvertible {
        /// A unique identifier for the file.
        public let path: String
        /// If true, the list folder operation will be applied recursively to all subfolders and the response will
        /// contain contents of all subfolders.
        public let recursive: Bool
        /// If true, mediaInfo in FileMetadata is set for photo and video. This parameter will no longer have an effect
        /// starting December 2, 2019.
        public let includeMediaInfo: Bool
        /// If true, the results will include entries for files and folders that used to exist but were deleted.
        public let includeDeleted: Bool
        /// If true, the results will include a flag for each file indicating whether or not  that file has any explicit
        /// members.
        public let includeHasExplicitSharedMembers: Bool
        /// If true, the results will include entries under mounted folders which includes app folder, shared folder and
        /// team folder.
        public let includeMountedFolders: Bool
        /// The maximum number of results to return per request. Note: This is an approximate number and there can be
        /// slightly more entries returned in some cases.
        public let limit: UInt32?
        /// A shared link to list the contents of. If the link is password-protected, the password must be provided. If
        /// this field is present, path in ListFolderArg will be relative to root of the shared link. Only non-recursive
        /// mode is supported for shared link.
        public let sharedLink: Files.SharedLink?
        /// If set to a valid list of template IDs, propertyGroups in FileMetadata is set if there exists property data
        /// associated with the file and each of the listed templates.
        public let includePropertyGroups: FileProperties.TemplateFilterBase?
        /// If true, include files that are not downloadable, i.e. Google Docs.
        public let includeNonDownloadableFiles: Bool
        public init(path: String, recursive: Bool = false, includeMediaInfo: Bool = false, includeDeleted: Bool = false, includeHasExplicitSharedMembers: Bool = false, includeMountedFolders: Bool = true, limit: UInt32? = nil, sharedLink: Files.SharedLink? = nil, includePropertyGroups: FileProperties.TemplateFilterBase? = nil, includeNonDownloadableFiles: Bool = true) {
            stringValidator(pattern: "(/(.|[\\r\\n])*)?|id:.*|(ns:[0-9]+(/.*)?)")(path)
            self.path = path
            self.recursive = recursive
            self.includeMediaInfo = includeMediaInfo
            self.includeDeleted = includeDeleted
            self.includeHasExplicitSharedMembers = includeHasExplicitSharedMembers
            self.includeMountedFolders = includeMountedFolders
            nullableValidator(comparableValidator(minValue: 1, maxValue: 2000))(limit)
            self.limit = limit
            self.sharedLink = sharedLink
            self.includePropertyGroups = includePropertyGroups
            self.includeNonDownloadableFiles = includeNonDownloadableFiles
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListFolderArgSerializer().serialize(self)))"
        }
    }
    open class ListFolderArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ListFolderArg) -> JSON {
            let output = [ 
            "path": Serialization._StringSerializer.serialize(value.path),
            "recursive": Serialization._BoolSerializer.serialize(value.recursive),
            "include_media_info": Serialization._BoolSerializer.serialize(value.includeMediaInfo),
            "include_deleted": Serialization._BoolSerializer.serialize(value.includeDeleted),
            "include_has_explicit_shared_members": Serialization._BoolSerializer.serialize(value.includeHasExplicitSharedMembers),
            "include_mounted_folders": Serialization._BoolSerializer.serialize(value.includeMountedFolders),
            "limit": NullableSerializer(Serialization._UInt32Serializer).serialize(value.limit),
            "shared_link": NullableSerializer(Files.SharedLinkSerializer()).serialize(value.sharedLink),
            "include_property_groups": NullableSerializer(FileProperties.TemplateFilterBaseSerializer()).serialize(value.includePropertyGroups),
            "include_non_downloadable_files": Serialization._BoolSerializer.serialize(value.includeNonDownloadableFiles),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ListFolderArg {
            switch json {
                case .dictionary(let dict):
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .null)
                    let recursive = Serialization._BoolSerializer.deserialize(dict["recursive"] ?? .number(0))
                    let includeMediaInfo = Serialization._BoolSerializer.deserialize(dict["include_media_info"] ?? .number(0))
                    let includeDeleted = Serialization._BoolSerializer.deserialize(dict["include_deleted"] ?? .number(0))
                    let includeHasExplicitSharedMembers = Serialization._BoolSerializer.deserialize(dict["include_has_explicit_shared_members"] ?? .number(0))
                    let includeMountedFolders = Serialization._BoolSerializer.deserialize(dict["include_mounted_folders"] ?? .number(1))
                    let limit = NullableSerializer(Serialization._UInt32Serializer).deserialize(dict["limit"] ?? .null)
                    let sharedLink = NullableSerializer(Files.SharedLinkSerializer()).deserialize(dict["shared_link"] ?? .null)
                    let includePropertyGroups = NullableSerializer(FileProperties.TemplateFilterBaseSerializer()).deserialize(dict["include_property_groups"] ?? .null)
                    let includeNonDownloadableFiles = Serialization._BoolSerializer.deserialize(dict["include_non_downloadable_files"] ?? .number(1))
                    return ListFolderArg(path: path, recursive: recursive, includeMediaInfo: includeMediaInfo, includeDeleted: includeDeleted, includeHasExplicitSharedMembers: includeHasExplicitSharedMembers, includeMountedFolders: includeMountedFolders, limit: limit, sharedLink: sharedLink, includePropertyGroups: includePropertyGroups, includeNonDownloadableFiles: includeNonDownloadableFiles)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The ListFolderContinueArg struct
    open class ListFolderContinueArg: CustomStringConvertible {
        /// The cursor returned by your last call to listFolder or listFolderContinue.
        public let cursor: String
        public init(cursor: String) {
            stringValidator(minLength: 1)(cursor)
            self.cursor = cursor
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListFolderContinueArgSerializer().serialize(self)))"
        }
    }
    open class ListFolderContinueArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ListFolderContinueArg) -> JSON {
            let output = [ 
            "cursor": Serialization._StringSerializer.serialize(value.cursor),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ListFolderContinueArg {
            switch json {
                case .dictionary(let dict):
                    let cursor = Serialization._StringSerializer.deserialize(dict["cursor"] ?? .null)
                    return ListFolderContinueArg(cursor: cursor)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The ListFolderContinueError union
    public enum ListFolderContinueError: CustomStringConvertible {
        /// An unspecified error.
        case path(Files.LookupError)
        /// Indicates that the cursor has been invalidated. Call listFolder to obtain a new cursor.
        case reset
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListFolderContinueErrorSerializer().serialize(self)))"
        }
    }
    open class ListFolderContinueErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ListFolderContinueError) -> JSON {
            switch value {
                case .path(let arg):
                    var d = ["path": Files.LookupErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("path")
                    return .dictionary(d)
                case .reset:
                    var d = [String: JSON]()
                    d[".tag"] = .str("reset")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> ListFolderContinueError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "path":
                            let v = Files.LookupErrorSerializer().deserialize(d["path"] ?? .null)
                            return ListFolderContinueError.path(v)
                        case "reset":
                            return ListFolderContinueError.reset
                        case "other":
                            return ListFolderContinueError.other
                        default:
                            return ListFolderContinueError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The ListFolderError union
    public enum ListFolderError: CustomStringConvertible {
        /// An unspecified error.
        case path(Files.LookupError)
        /// An unspecified error.
        case templateError(FileProperties.TemplateError)
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListFolderErrorSerializer().serialize(self)))"
        }
    }
    open class ListFolderErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ListFolderError) -> JSON {
            switch value {
                case .path(let arg):
                    var d = ["path": Files.LookupErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("path")
                    return .dictionary(d)
                case .templateError(let arg):
                    var d = ["template_error": FileProperties.TemplateErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("template_error")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> ListFolderError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "path":
                            let v = Files.LookupErrorSerializer().deserialize(d["path"] ?? .null)
                            return ListFolderError.path(v)
                        case "template_error":
                            let v = FileProperties.TemplateErrorSerializer().deserialize(d["template_error"] ?? .null)
                            return ListFolderError.templateError(v)
                        case "other":
                            return ListFolderError.other
                        default:
                            return ListFolderError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The ListFolderGetLatestCursorResult struct
    open class ListFolderGetLatestCursorResult: CustomStringConvertible {
        /// Pass the cursor into listFolderContinue to see what's changed in the folder since your previous query.
        public let cursor: String
        public init(cursor: String) {
            stringValidator(minLength: 1)(cursor)
            self.cursor = cursor
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListFolderGetLatestCursorResultSerializer().serialize(self)))"
        }
    }
    open class ListFolderGetLatestCursorResultSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ListFolderGetLatestCursorResult) -> JSON {
            let output = [ 
            "cursor": Serialization._StringSerializer.serialize(value.cursor),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ListFolderGetLatestCursorResult {
            switch json {
                case .dictionary(let dict):
                    let cursor = Serialization._StringSerializer.deserialize(dict["cursor"] ?? .null)
                    return ListFolderGetLatestCursorResult(cursor: cursor)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The ListFolderLongpollArg struct
    open class ListFolderLongpollArg: CustomStringConvertible {
        /// A cursor as returned by listFolder or listFolderContinue. Cursors retrieved by setting includeMediaInfo in
        /// ListFolderArg to true are not supported.
        public let cursor: String
        /// A timeout in seconds. The request will block for at most this length of time, plus up to 90 seconds of
        /// random jitter added to avoid the thundering herd problem. Care should be taken when using this parameter, as
        /// some network infrastructure does not support long timeouts.
        public let timeout: UInt64
        public init(cursor: String, timeout: UInt64 = 30) {
            stringValidator(minLength: 1)(cursor)
            self.cursor = cursor
            comparableValidator(minValue: 30, maxValue: 480)(timeout)
            self.timeout = timeout
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListFolderLongpollArgSerializer().serialize(self)))"
        }
    }
    open class ListFolderLongpollArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ListFolderLongpollArg) -> JSON {
            let output = [ 
            "cursor": Serialization._StringSerializer.serialize(value.cursor),
            "timeout": Serialization._UInt64Serializer.serialize(value.timeout),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ListFolderLongpollArg {
            switch json {
                case .dictionary(let dict):
                    let cursor = Serialization._StringSerializer.deserialize(dict["cursor"] ?? .null)
                    let timeout = Serialization._UInt64Serializer.deserialize(dict["timeout"] ?? .number(30))
                    return ListFolderLongpollArg(cursor: cursor, timeout: timeout)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The ListFolderLongpollError union
    public enum ListFolderLongpollError: CustomStringConvertible {
        /// Indicates that the cursor has been invalidated. Call listFolder to obtain a new cursor.
        case reset
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListFolderLongpollErrorSerializer().serialize(self)))"
        }
    }
    open class ListFolderLongpollErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ListFolderLongpollError) -> JSON {
            switch value {
                case .reset:
                    var d = [String: JSON]()
                    d[".tag"] = .str("reset")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> ListFolderLongpollError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "reset":
                            return ListFolderLongpollError.reset
                        case "other":
                            return ListFolderLongpollError.other
                        default:
                            return ListFolderLongpollError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The ListFolderLongpollResult struct
    open class ListFolderLongpollResult: CustomStringConvertible {
        /// Indicates whether new changes are available. If true, call listFolderContinue to retrieve the changes.
        public let changes: Bool
        /// If present, backoff for at least this many seconds before calling listFolderLongpoll again.
        public let backoff: UInt64?
        public init(changes: Bool, backoff: UInt64? = nil) {
            self.changes = changes
            nullableValidator(comparableValidator())(backoff)
            self.backoff = backoff
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListFolderLongpollResultSerializer().serialize(self)))"
        }
    }
    open class ListFolderLongpollResultSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ListFolderLongpollResult) -> JSON {
            let output = [ 
            "changes": Serialization._BoolSerializer.serialize(value.changes),
            "backoff": NullableSerializer(Serialization._UInt64Serializer).serialize(value.backoff),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ListFolderLongpollResult {
            switch json {
                case .dictionary(let dict):
                    let changes = Serialization._BoolSerializer.deserialize(dict["changes"] ?? .null)
                    let backoff = NullableSerializer(Serialization._UInt64Serializer).deserialize(dict["backoff"] ?? .null)
                    return ListFolderLongpollResult(changes: changes, backoff: backoff)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The ListFolderResult struct
    open class ListFolderResult: CustomStringConvertible {
        /// The files and (direct) subfolders in the folder.
        public let entries: Array<Files.Metadata>
        /// Pass the cursor into listFolderContinue to see what's changed in the folder since your previous query.
        public let cursor: String
        /// If true, then there are more entries available. Pass the cursor to listFolderContinue to retrieve the rest.
        public let hasMore: Bool
        public init(entries: Array<Files.Metadata>, cursor: String, hasMore: Bool) {
            self.entries = entries
            stringValidator(minLength: 1)(cursor)
            self.cursor = cursor
            self.hasMore = hasMore
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListFolderResultSerializer().serialize(self)))"
        }
    }
    open class ListFolderResultSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ListFolderResult) -> JSON {
            let output = [ 
            "entries": ArraySerializer(Files.MetadataSerializer()).serialize(value.entries),
            "cursor": Serialization._StringSerializer.serialize(value.cursor),
            "has_more": Serialization._BoolSerializer.serialize(value.hasMore),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ListFolderResult {
            switch json {
                case .dictionary(let dict):
                    let entries = ArraySerializer(Files.MetadataSerializer()).deserialize(dict["entries"] ?? .null)
                    let cursor = Serialization._StringSerializer.deserialize(dict["cursor"] ?? .null)
                    let hasMore = Serialization._BoolSerializer.deserialize(dict["has_more"] ?? .null)
                    return ListFolderResult(entries: entries, cursor: cursor, hasMore: hasMore)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The ListRevisionsArg struct
    open class ListRevisionsArg: CustomStringConvertible {
        /// The path to the file you want to see the revisions of.
        public let path: String
        /// Determines the behavior of the API in listing the revisions for a given file path or id.
        public let mode: Files.ListRevisionsMode
        /// The maximum number of revision entries returned.
        public let limit: UInt64
        public init(path: String, mode: Files.ListRevisionsMode = .path, limit: UInt64 = 10) {
            stringValidator(pattern: "/(.|[\\r\\n])*|id:.*|(ns:[0-9]+(/.*)?)")(path)
            self.path = path
            self.mode = mode
            comparableValidator(minValue: 1, maxValue: 100)(limit)
            self.limit = limit
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListRevisionsArgSerializer().serialize(self)))"
        }
    }
    open class ListRevisionsArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ListRevisionsArg) -> JSON {
            let output = [ 
            "path": Serialization._StringSerializer.serialize(value.path),
            "mode": Files.ListRevisionsModeSerializer().serialize(value.mode),
            "limit": Serialization._UInt64Serializer.serialize(value.limit),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ListRevisionsArg {
            switch json {
                case .dictionary(let dict):
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .null)
                    let mode = Files.ListRevisionsModeSerializer().deserialize(dict["mode"] ?? Files.ListRevisionsModeSerializer().serialize(.path))
                    let limit = Serialization._UInt64Serializer.deserialize(dict["limit"] ?? .number(10))
                    return ListRevisionsArg(path: path, mode: mode, limit: limit)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The ListRevisionsError union
    public enum ListRevisionsError: CustomStringConvertible {
        /// An unspecified error.
        case path(Files.LookupError)
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListRevisionsErrorSerializer().serialize(self)))"
        }
    }
    open class ListRevisionsErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ListRevisionsError) -> JSON {
            switch value {
                case .path(let arg):
                    var d = ["path": Files.LookupErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("path")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> ListRevisionsError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "path":
                            let v = Files.LookupErrorSerializer().deserialize(d["path"] ?? .null)
                            return ListRevisionsError.path(v)
                        case "other":
                            return ListRevisionsError.other
                        default:
                            return ListRevisionsError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The ListRevisionsMode union
    public enum ListRevisionsMode: CustomStringConvertible {
        /// Returns revisions with the same file path as identified by the latest file entry at the given file path or
        /// id.
        case path
        /// Returns revisions with the same file id as identified by the latest file entry at the given file path or id.
        case id
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListRevisionsModeSerializer().serialize(self)))"
        }
    }
    open class ListRevisionsModeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ListRevisionsMode) -> JSON {
            switch value {
                case .path:
                    var d = [String: JSON]()
                    d[".tag"] = .str("path")
                    return .dictionary(d)
                case .id:
                    var d = [String: JSON]()
                    d[".tag"] = .str("id")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> ListRevisionsMode {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "path":
                            return ListRevisionsMode.path
                        case "id":
                            return ListRevisionsMode.id
                        case "other":
                            return ListRevisionsMode.other
                        default:
                            return ListRevisionsMode.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The ListRevisionsResult struct
    open class ListRevisionsResult: CustomStringConvertible {
        /// If the file identified by the latest revision in the response is either deleted or moved.
        public let isDeleted: Bool
        /// The time of deletion if the file was deleted.
        public let serverDeleted: Date?
        /// The revisions for the file. Only revisions that are not deleted will show up here.
        public let entries: Array<Files.FileMetadata>
        public init(isDeleted: Bool, entries: Array<Files.FileMetadata>, serverDeleted: Date? = nil) {
            self.isDeleted = isDeleted
            self.serverDeleted = serverDeleted
            self.entries = entries
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListRevisionsResultSerializer().serialize(self)))"
        }
    }
    open class ListRevisionsResultSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ListRevisionsResult) -> JSON {
            let output = [ 
            "is_deleted": Serialization._BoolSerializer.serialize(value.isDeleted),
            "entries": ArraySerializer(Files.FileMetadataSerializer()).serialize(value.entries),
            "server_deleted": NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.serverDeleted),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ListRevisionsResult {
            switch json {
                case .dictionary(let dict):
                    let isDeleted = Serialization._BoolSerializer.deserialize(dict["is_deleted"] ?? .null)
                    let entries = ArraySerializer(Files.FileMetadataSerializer()).deserialize(dict["entries"] ?? .null)
                    let serverDeleted = NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).deserialize(dict["server_deleted"] ?? .null)
                    return ListRevisionsResult(isDeleted: isDeleted, entries: entries, serverDeleted: serverDeleted)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The LockConflictError struct
    open class LockConflictError: CustomStringConvertible {
        /// The lock that caused the conflict.
        public let lock: Files.FileLock
        public init(lock: Files.FileLock) {
            self.lock = lock
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(LockConflictErrorSerializer().serialize(self)))"
        }
    }
    open class LockConflictErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: LockConflictError) -> JSON {
            let output = [ 
            "lock": Files.FileLockSerializer().serialize(value.lock),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> LockConflictError {
            switch json {
                case .dictionary(let dict):
                    let lock = Files.FileLockSerializer().deserialize(dict["lock"] ?? .null)
                    return LockConflictError(lock: lock)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The LockFileArg struct
    open class LockFileArg: CustomStringConvertible {
        /// Path in the user's Dropbox to a file.
        public let path: String
        public init(path: String) {
            stringValidator(pattern: "(/(.|[\\r\\n])*)|(ns:[0-9]+(/.*)?)|(id:.*)")(path)
            self.path = path
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(LockFileArgSerializer().serialize(self)))"
        }
    }
    open class LockFileArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: LockFileArg) -> JSON {
            let output = [ 
            "path": Serialization._StringSerializer.serialize(value.path),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> LockFileArg {
            switch json {
                case .dictionary(let dict):
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .null)
                    return LockFileArg(path: path)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The LockFileBatchArg struct
    open class LockFileBatchArg: CustomStringConvertible {
        /// List of 'entries'. Each 'entry' contains a path of the file which will be locked or queried. Duplicate path
        /// arguments in the batch are considered only once.
        public let entries: Array<Files.LockFileArg>
        public init(entries: Array<Files.LockFileArg>) {
            self.entries = entries
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(LockFileBatchArgSerializer().serialize(self)))"
        }
    }
    open class LockFileBatchArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: LockFileBatchArg) -> JSON {
            let output = [ 
            "entries": ArraySerializer(Files.LockFileArgSerializer()).serialize(value.entries),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> LockFileBatchArg {
            switch json {
                case .dictionary(let dict):
                    let entries = ArraySerializer(Files.LockFileArgSerializer()).deserialize(dict["entries"] ?? .null)
                    return LockFileBatchArg(entries: entries)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The LockFileBatchResult struct
    open class LockFileBatchResult: Files.FileOpsResult {
        /// Each Entry in the 'entries' will have '.tag' with the operation status (e.g. success), the metadata for the
        /// file and the lock state after the operation.
        public let entries: Array<Files.LockFileResultEntry>
        public init(entries: Array<Files.LockFileResultEntry>) {
            self.entries = entries
            super.init()
        }
        open override var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(LockFileBatchResultSerializer().serialize(self)))"
        }
    }
    open class LockFileBatchResultSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: LockFileBatchResult) -> JSON {
            let output = [ 
            "entries": ArraySerializer(Files.LockFileResultEntrySerializer()).serialize(value.entries),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> LockFileBatchResult {
            switch json {
                case .dictionary(let dict):
                    let entries = ArraySerializer(Files.LockFileResultEntrySerializer()).deserialize(dict["entries"] ?? .null)
                    return LockFileBatchResult(entries: entries)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The LockFileError union
    public enum LockFileError: CustomStringConvertible {
        /// Could not find the specified resource.
        case pathLookup(Files.LookupError)
        /// There are too many write operations in user's Dropbox. Please retry this request.
        case tooManyWriteOperations
        /// There are too many files in one request. Please retry with fewer files.
        case tooManyFiles
        /// The user does not have permissions to change the lock state or access the file.
        case noWritePermission
        /// Item is a type that cannot be locked.
        case cannotBeLocked
        /// Requested file is not currently shared.
        case fileNotShared
        /// The user action conflicts with an existing lock on the file.
        case lockConflict(Files.LockConflictError)
        /// Something went wrong with the job on Dropbox's end. You'll need to verify that the action you were taking
        /// succeeded, and if not, try again. This should happen very rarely.
        case internalError
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(LockFileErrorSerializer().serialize(self)))"
        }
    }
    open class LockFileErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: LockFileError) -> JSON {
            switch value {
                case .pathLookup(let arg):
                    var d = ["path_lookup": Files.LookupErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("path_lookup")
                    return .dictionary(d)
                case .tooManyWriteOperations:
                    var d = [String: JSON]()
                    d[".tag"] = .str("too_many_write_operations")
                    return .dictionary(d)
                case .tooManyFiles:
                    var d = [String: JSON]()
                    d[".tag"] = .str("too_many_files")
                    return .dictionary(d)
                case .noWritePermission:
                    var d = [String: JSON]()
                    d[".tag"] = .str("no_write_permission")
                    return .dictionary(d)
                case .cannotBeLocked:
                    var d = [String: JSON]()
                    d[".tag"] = .str("cannot_be_locked")
                    return .dictionary(d)
                case .fileNotShared:
                    var d = [String: JSON]()
                    d[".tag"] = .str("file_not_shared")
                    return .dictionary(d)
                case .lockConflict(let arg):
                    var d = Serialization.getFields(Files.LockConflictErrorSerializer().serialize(arg))
                    d[".tag"] = .str("lock_conflict")
                    return .dictionary(d)
                case .internalError:
                    var d = [String: JSON]()
                    d[".tag"] = .str("internal_error")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> LockFileError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "path_lookup":
                            let v = Files.LookupErrorSerializer().deserialize(d["path_lookup"] ?? .null)
                            return LockFileError.pathLookup(v)
                        case "too_many_write_operations":
                            return LockFileError.tooManyWriteOperations
                        case "too_many_files":
                            return LockFileError.tooManyFiles
                        case "no_write_permission":
                            return LockFileError.noWritePermission
                        case "cannot_be_locked":
                            return LockFileError.cannotBeLocked
                        case "file_not_shared":
                            return LockFileError.fileNotShared
                        case "lock_conflict":
                            let v = Files.LockConflictErrorSerializer().deserialize(json)
                            return LockFileError.lockConflict(v)
                        case "internal_error":
                            return LockFileError.internalError
                        case "other":
                            return LockFileError.other
                        default:
                            return LockFileError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The LockFileResult struct
    open class LockFileResult: CustomStringConvertible {
        /// Metadata of the file.
        public let metadata: Files.Metadata
        /// The file lock state after the operation.
        public let lock: Files.FileLock
        public init(metadata: Files.Metadata, lock: Files.FileLock) {
            self.metadata = metadata
            self.lock = lock
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(LockFileResultSerializer().serialize(self)))"
        }
    }
    open class LockFileResultSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: LockFileResult) -> JSON {
            let output = [ 
            "metadata": Files.MetadataSerializer().serialize(value.metadata),
            "lock": Files.FileLockSerializer().serialize(value.lock),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> LockFileResult {
            switch json {
                case .dictionary(let dict):
                    let metadata = Files.MetadataSerializer().deserialize(dict["metadata"] ?? .null)
                    let lock = Files.FileLockSerializer().deserialize(dict["lock"] ?? .null)
                    return LockFileResult(metadata: metadata, lock: lock)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The LockFileResultEntry union
    public enum LockFileResultEntry: CustomStringConvertible {
        /// An unspecified error.
        case success(Files.LockFileResult)
        /// An unspecified error.
        case failure(Files.LockFileError)

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(LockFileResultEntrySerializer().serialize(self)))"
        }
    }
    open class LockFileResultEntrySerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: LockFileResultEntry) -> JSON {
            switch value {
                case .success(let arg):
                    var d = Serialization.getFields(Files.LockFileResultSerializer().serialize(arg))
                    d[".tag"] = .str("success")
                    return .dictionary(d)
                case .failure(let arg):
                    var d = ["failure": Files.LockFileErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("failure")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> LockFileResultEntry {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "success":
                            let v = Files.LockFileResultSerializer().deserialize(json)
                            return LockFileResultEntry.success(v)
                        case "failure":
                            let v = Files.LockFileErrorSerializer().deserialize(d["failure"] ?? .null)
                            return LockFileResultEntry.failure(v)
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The LookupError union
    public enum LookupError: CustomStringConvertible {
        /// The given path does not satisfy the required path format. Please refer to the Path formats documentation
        /// https://www.dropbox.com/developers/documentation/http/documentation#path-formats for more information.
        case malformedPath(String?)
        /// There is nothing at the given path.
        case notFound
        /// We were expecting a file, but the given path refers to something that isn't a file.
        case notFile
        /// We were expecting a folder, but the given path refers to something that isn't a folder.
        case notFolder
        /// The file cannot be transferred because the content is restricted.  For example, sometimes there are legal
        /// restrictions due to copyright claims.
        case restrictedContent
        /// This operation is not supported for this content type.
        case unsupportedContentType
        /// The given path is locked.
        case locked
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(LookupErrorSerializer().serialize(self)))"
        }
    }
    open class LookupErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: LookupError) -> JSON {
            switch value {
                case .malformedPath(let arg):
                    var d = ["malformed_path": NullableSerializer(Serialization._StringSerializer).serialize(arg)]
                    d[".tag"] = .str("malformed_path")
                    return .dictionary(d)
                case .notFound:
                    var d = [String: JSON]()
                    d[".tag"] = .str("not_found")
                    return .dictionary(d)
                case .notFile:
                    var d = [String: JSON]()
                    d[".tag"] = .str("not_file")
                    return .dictionary(d)
                case .notFolder:
                    var d = [String: JSON]()
                    d[".tag"] = .str("not_folder")
                    return .dictionary(d)
                case .restrictedContent:
                    var d = [String: JSON]()
                    d[".tag"] = .str("restricted_content")
                    return .dictionary(d)
                case .unsupportedContentType:
                    var d = [String: JSON]()
                    d[".tag"] = .str("unsupported_content_type")
                    return .dictionary(d)
                case .locked:
                    var d = [String: JSON]()
                    d[".tag"] = .str("locked")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> LookupError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "malformed_path":
                            let v = NullableSerializer(Serialization._StringSerializer).deserialize(d["malformed_path"] ?? .null)
                            return LookupError.malformedPath(v)
                        case "not_found":
                            return LookupError.notFound
                        case "not_file":
                            return LookupError.notFile
                        case "not_folder":
                            return LookupError.notFolder
                        case "restricted_content":
                            return LookupError.restrictedContent
                        case "unsupported_content_type":
                            return LookupError.unsupportedContentType
                        case "locked":
                            return LookupError.locked
                        case "other":
                            return LookupError.other
                        default:
                            return LookupError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The MediaInfo union
    public enum MediaInfo: CustomStringConvertible {
        /// Indicate the photo/video is still under processing and metadata is not available yet.
        case pending
        /// The metadata for the photo/video.
        case metadata(Files.MediaMetadata)

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MediaInfoSerializer().serialize(self)))"
        }
    }
    open class MediaInfoSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: MediaInfo) -> JSON {
            switch value {
                case .pending:
                    var d = [String: JSON]()
                    d[".tag"] = .str("pending")
                    return .dictionary(d)
                case .metadata(let arg):
                    var d = ["metadata": Files.MediaMetadataSerializer().serialize(arg)]
                    d[".tag"] = .str("metadata")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> MediaInfo {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "pending":
                            return MediaInfo.pending
                        case "metadata":
                            let v = Files.MediaMetadataSerializer().deserialize(d["metadata"] ?? .null)
                            return MediaInfo.metadata(v)
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Metadata for a photo or video.
    open class MediaMetadata: CustomStringConvertible {
        /// Dimension of the photo/video.
        public let dimensions: Files.Dimensions?
        /// The GPS coordinate of the photo/video.
        public let location: Files.GpsCoordinates?
        /// The timestamp when the photo/video is taken.
        public let timeTaken: Date?
        public init(dimensions: Files.Dimensions? = nil, location: Files.GpsCoordinates? = nil, timeTaken: Date? = nil) {
            self.dimensions = dimensions
            self.location = location
            self.timeTaken = timeTaken
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MediaMetadataSerializer().serialize(self)))"
        }
    }
    open class MediaMetadataSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: MediaMetadata) -> JSON {
            var output = [ 
            "dimensions": NullableSerializer(Files.DimensionsSerializer()).serialize(value.dimensions),
            "location": NullableSerializer(Files.GpsCoordinatesSerializer()).serialize(value.location),
            "time_taken": NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.timeTaken),
            ]
            switch value {
                case let photo as Files.PhotoMetadata:
                    for (k, v) in Serialization.getFields(Files.PhotoMetadataSerializer().serialize(photo)) {
                        output[k] = v
                    }
                    output[".tag"] = .str("photo")
                case let video as Files.VideoMetadata:
                    for (k, v) in Serialization.getFields(Files.VideoMetadataSerializer().serialize(video)) {
                        output[k] = v
                    }
                    output[".tag"] = .str("video")
                default: fatalError("Tried to serialize unexpected subtype")
            }
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> MediaMetadata {
            switch json {
                case .dictionary(let dict):
                    let tag = Serialization.getTag(dict)
                    switch tag {
                        case "photo":
                            return Files.PhotoMetadataSerializer().deserialize(json)
                        case "video":
                            return Files.VideoMetadataSerializer().deserialize(json)
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Metadata for a file, folder or other resource types.
    public enum MetadataV2: CustomStringConvertible {
        /// An unspecified error.
        case metadata(Files.Metadata)
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MetadataV2Serializer().serialize(self)))"
        }
    }
    open class MetadataV2Serializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: MetadataV2) -> JSON {
            switch value {
                case .metadata(let arg):
                    var d = ["metadata": Files.MetadataSerializer().serialize(arg)]
                    d[".tag"] = .str("metadata")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> MetadataV2 {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "metadata":
                            let v = Files.MetadataSerializer().deserialize(d["metadata"] ?? .null)
                            return MetadataV2.metadata(v)
                        case "other":
                            return MetadataV2.other
                        default:
                            return MetadataV2.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The MinimalFileLinkMetadata struct
    open class MinimalFileLinkMetadata: CustomStringConvertible {
        /// URL of the shared link.
        public let url: String
        /// Unique identifier for the linked file.
        public let id: String?
        /// Full path in the user's Dropbox. This always starts with a slash. This field will only be present only if
        /// the linked file is in the authenticated user's Dropbox.
        public let path: String?
        /// A unique identifier for the current revision of a file. This field is the same rev as elsewhere in the API
        /// and can be used to detect changes and avoid conflicts.
        public let rev: String
        public init(url: String, rev: String, id: String? = nil, path: String? = nil) {
            stringValidator()(url)
            self.url = url
            nullableValidator(stringValidator(minLength: 1))(id)
            self.id = id
            nullableValidator(stringValidator())(path)
            self.path = path
            stringValidator(minLength: 9, pattern: "[0-9a-f]+")(rev)
            self.rev = rev
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MinimalFileLinkMetadataSerializer().serialize(self)))"
        }
    }
    open class MinimalFileLinkMetadataSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: MinimalFileLinkMetadata) -> JSON {
            let output = [ 
            "url": Serialization._StringSerializer.serialize(value.url),
            "rev": Serialization._StringSerializer.serialize(value.rev),
            "id": NullableSerializer(Serialization._StringSerializer).serialize(value.id),
            "path": NullableSerializer(Serialization._StringSerializer).serialize(value.path),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> MinimalFileLinkMetadata {
            switch json {
                case .dictionary(let dict):
                    let url = Serialization._StringSerializer.deserialize(dict["url"] ?? .null)
                    let rev = Serialization._StringSerializer.deserialize(dict["rev"] ?? .null)
                    let id = NullableSerializer(Serialization._StringSerializer).deserialize(dict["id"] ?? .null)
                    let path = NullableSerializer(Serialization._StringSerializer).deserialize(dict["path"] ?? .null)
                    return MinimalFileLinkMetadata(url: url, rev: rev, id: id, path: path)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The RelocationBatchArgBase struct
    open class RelocationBatchArgBase: CustomStringConvertible {
        /// List of entries to be moved or copied. Each entry is RelocationPath.
        public let entries: Array<Files.RelocationPath>
        /// If there's a conflict with any file, have the Dropbox server try to autorename that file to avoid the
        /// conflict.
        public let autorename: Bool
        public init(entries: Array<Files.RelocationPath>, autorename: Bool = false) {
            self.entries = entries
            self.autorename = autorename
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(RelocationBatchArgBaseSerializer().serialize(self)))"
        }
    }
    open class RelocationBatchArgBaseSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: RelocationBatchArgBase) -> JSON {
            let output = [ 
            "entries": ArraySerializer(Files.RelocationPathSerializer()).serialize(value.entries),
            "autorename": Serialization._BoolSerializer.serialize(value.autorename),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> RelocationBatchArgBase {
            switch json {
                case .dictionary(let dict):
                    let entries = ArraySerializer(Files.RelocationPathSerializer()).deserialize(dict["entries"] ?? .null)
                    let autorename = Serialization._BoolSerializer.deserialize(dict["autorename"] ?? .number(0))
                    return RelocationBatchArgBase(entries: entries, autorename: autorename)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The MoveBatchArg struct
    open class MoveBatchArg: Files.RelocationBatchArgBase {
        /// Allow moves by owner even if it would result in an ownership transfer for the content being moved. This does
        /// not apply to copies.
        public let allowOwnershipTransfer: Bool
        public init(entries: Array<Files.RelocationPath>, autorename: Bool = false, allowOwnershipTransfer: Bool = false) {
            self.allowOwnershipTransfer = allowOwnershipTransfer
            super.init(entries: entries, autorename: autorename)
        }
        open override var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MoveBatchArgSerializer().serialize(self)))"
        }
    }
    open class MoveBatchArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: MoveBatchArg) -> JSON {
            let output = [ 
            "entries": ArraySerializer(Files.RelocationPathSerializer()).serialize(value.entries),
            "autorename": Serialization._BoolSerializer.serialize(value.autorename),
            "allow_ownership_transfer": Serialization._BoolSerializer.serialize(value.allowOwnershipTransfer),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> MoveBatchArg {
            switch json {
                case .dictionary(let dict):
                    let entries = ArraySerializer(Files.RelocationPathSerializer()).deserialize(dict["entries"] ?? .null)
                    let autorename = Serialization._BoolSerializer.deserialize(dict["autorename"] ?? .number(0))
                    let allowOwnershipTransfer = Serialization._BoolSerializer.deserialize(dict["allow_ownership_transfer"] ?? .number(0))
                    return MoveBatchArg(entries: entries, autorename: autorename, allowOwnershipTransfer: allowOwnershipTransfer)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The MoveIntoVaultError union
    public enum MoveIntoVaultError: CustomStringConvertible {
        /// Moving shared folder into Vault is not allowed.
        case isSharedFolder
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MoveIntoVaultErrorSerializer().serialize(self)))"
        }
    }
    open class MoveIntoVaultErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: MoveIntoVaultError) -> JSON {
            switch value {
                case .isSharedFolder:
                    var d = [String: JSON]()
                    d[".tag"] = .str("is_shared_folder")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> MoveIntoVaultError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "is_shared_folder":
                            return MoveIntoVaultError.isSharedFolder
                        case "other":
                            return MoveIntoVaultError.other
                        default:
                            return MoveIntoVaultError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The PaperContentError union
    public enum PaperContentError: CustomStringConvertible {
        /// Your account does not have permissions to edit Paper docs.
        case insufficientPermissions
        /// The provided content was malformed and cannot be imported to Paper.
        case contentMalformed
        /// The Paper doc would be too large, split the content into multiple docs.
        case docLengthExceeded
        /// The imported document contains an image that is too large. The current limit is 1MB. This only applies to
        /// HTML with data URI.
        case imageSizeExceeded
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PaperContentErrorSerializer().serialize(self)))"
        }
    }
    open class PaperContentErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PaperContentError) -> JSON {
            switch value {
                case .insufficientPermissions:
                    var d = [String: JSON]()
                    d[".tag"] = .str("insufficient_permissions")
                    return .dictionary(d)
                case .contentMalformed:
                    var d = [String: JSON]()
                    d[".tag"] = .str("content_malformed")
                    return .dictionary(d)
                case .docLengthExceeded:
                    var d = [String: JSON]()
                    d[".tag"] = .str("doc_length_exceeded")
                    return .dictionary(d)
                case .imageSizeExceeded:
                    var d = [String: JSON]()
                    d[".tag"] = .str("image_size_exceeded")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> PaperContentError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "insufficient_permissions":
                            return PaperContentError.insufficientPermissions
                        case "content_malformed":
                            return PaperContentError.contentMalformed
                        case "doc_length_exceeded":
                            return PaperContentError.docLengthExceeded
                        case "image_size_exceeded":
                            return PaperContentError.imageSizeExceeded
                        case "other":
                            return PaperContentError.other
                        default:
                            return PaperContentError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The PaperCreateArg struct
    open class PaperCreateArg: CustomStringConvertible {
        /// The fully qualified path to the location in the user's Dropbox where the Paper Doc should be created. This
        /// should include the document's title and end with .paper.
        public let path: String
        /// The format of the provided data.
        public let importFormat: Files.ImportFormat
        public init(path: String, importFormat: Files.ImportFormat) {
            stringValidator(pattern: "/(.|[\\r\\n])*")(path)
            self.path = path
            self.importFormat = importFormat
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PaperCreateArgSerializer().serialize(self)))"
        }
    }
    open class PaperCreateArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PaperCreateArg) -> JSON {
            let output = [ 
            "path": Serialization._StringSerializer.serialize(value.path),
            "import_format": Files.ImportFormatSerializer().serialize(value.importFormat),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> PaperCreateArg {
            switch json {
                case .dictionary(let dict):
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .null)
                    let importFormat = Files.ImportFormatSerializer().deserialize(dict["import_format"] ?? .null)
                    return PaperCreateArg(path: path, importFormat: importFormat)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The PaperCreateError union
    public enum PaperCreateError: CustomStringConvertible {
        /// Your account does not have permissions to edit Paper docs.
        case insufficientPermissions
        /// The provided content was malformed and cannot be imported to Paper.
        case contentMalformed
        /// The Paper doc would be too large, split the content into multiple docs.
        case docLengthExceeded
        /// The imported document contains an image that is too large. The current limit is 1MB. This only applies to
        /// HTML with data URI.
        case imageSizeExceeded
        /// An unspecified error.
        case other
        /// The file could not be saved to the specified location.
        case invalidPath
        /// The user's email must be verified to create Paper docs.
        case emailUnverified
        /// The file path must end in .paper.
        case invalidFileExtension
        /// Paper is disabled for your team.
        case paperDisabled

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PaperCreateErrorSerializer().serialize(self)))"
        }
    }
    open class PaperCreateErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PaperCreateError) -> JSON {
            switch value {
                case .insufficientPermissions:
                    var d = [String: JSON]()
                    d[".tag"] = .str("insufficient_permissions")
                    return .dictionary(d)
                case .contentMalformed:
                    var d = [String: JSON]()
                    d[".tag"] = .str("content_malformed")
                    return .dictionary(d)
                case .docLengthExceeded:
                    var d = [String: JSON]()
                    d[".tag"] = .str("doc_length_exceeded")
                    return .dictionary(d)
                case .imageSizeExceeded:
                    var d = [String: JSON]()
                    d[".tag"] = .str("image_size_exceeded")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
                case .invalidPath:
                    var d = [String: JSON]()
                    d[".tag"] = .str("invalid_path")
                    return .dictionary(d)
                case .emailUnverified:
                    var d = [String: JSON]()
                    d[".tag"] = .str("email_unverified")
                    return .dictionary(d)
                case .invalidFileExtension:
                    var d = [String: JSON]()
                    d[".tag"] = .str("invalid_file_extension")
                    return .dictionary(d)
                case .paperDisabled:
                    var d = [String: JSON]()
                    d[".tag"] = .str("paper_disabled")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> PaperCreateError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "insufficient_permissions":
                            return PaperCreateError.insufficientPermissions
                        case "content_malformed":
                            return PaperCreateError.contentMalformed
                        case "doc_length_exceeded":
                            return PaperCreateError.docLengthExceeded
                        case "image_size_exceeded":
                            return PaperCreateError.imageSizeExceeded
                        case "other":
                            return PaperCreateError.other
                        case "invalid_path":
                            return PaperCreateError.invalidPath
                        case "email_unverified":
                            return PaperCreateError.emailUnverified
                        case "invalid_file_extension":
                            return PaperCreateError.invalidFileExtension
                        case "paper_disabled":
                            return PaperCreateError.paperDisabled
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The PaperCreateResult struct
    open class PaperCreateResult: CustomStringConvertible {
        /// URL to open the Paper Doc.
        public let url: String
        /// The fully qualified path the Paper Doc was actually created at.
        public let resultPath: String
        /// The id to use in Dropbox APIs when referencing the Paper Doc.
        public let fileId: String
        /// The current doc revision.
        public let paperRevision: Int64
        public init(url: String, resultPath: String, fileId: String, paperRevision: Int64) {
            stringValidator()(url)
            self.url = url
            stringValidator()(resultPath)
            self.resultPath = resultPath
            stringValidator(minLength: 4, pattern: "id:.+")(fileId)
            self.fileId = fileId
            comparableValidator()(paperRevision)
            self.paperRevision = paperRevision
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PaperCreateResultSerializer().serialize(self)))"
        }
    }
    open class PaperCreateResultSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PaperCreateResult) -> JSON {
            let output = [ 
            "url": Serialization._StringSerializer.serialize(value.url),
            "result_path": Serialization._StringSerializer.serialize(value.resultPath),
            "file_id": Serialization._StringSerializer.serialize(value.fileId),
            "paper_revision": Serialization._Int64Serializer.serialize(value.paperRevision),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> PaperCreateResult {
            switch json {
                case .dictionary(let dict):
                    let url = Serialization._StringSerializer.deserialize(dict["url"] ?? .null)
                    let resultPath = Serialization._StringSerializer.deserialize(dict["result_path"] ?? .null)
                    let fileId = Serialization._StringSerializer.deserialize(dict["file_id"] ?? .null)
                    let paperRevision = Serialization._Int64Serializer.deserialize(dict["paper_revision"] ?? .null)
                    return PaperCreateResult(url: url, resultPath: resultPath, fileId: fileId, paperRevision: paperRevision)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The PaperDocUpdatePolicy union
    public enum PaperDocUpdatePolicy: CustomStringConvertible {
        /// Sets the doc content to the provided content if the provided paper_revision matches the latest doc revision.
        /// Otherwise, returns an error.
        case update
        /// Sets the doc content to the provided content without checking paper_revision.
        case overwrite
        /// Adds the provided content to the beginning of the doc without checking paper_revision.
        case prepend
        /// Adds the provided content to the end of the doc without checking paper_revision.
        case append
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PaperDocUpdatePolicySerializer().serialize(self)))"
        }
    }
    open class PaperDocUpdatePolicySerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PaperDocUpdatePolicy) -> JSON {
            switch value {
                case .update:
                    var d = [String: JSON]()
                    d[".tag"] = .str("update")
                    return .dictionary(d)
                case .overwrite:
                    var d = [String: JSON]()
                    d[".tag"] = .str("overwrite")
                    return .dictionary(d)
                case .prepend:
                    var d = [String: JSON]()
                    d[".tag"] = .str("prepend")
                    return .dictionary(d)
                case .append:
                    var d = [String: JSON]()
                    d[".tag"] = .str("append")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> PaperDocUpdatePolicy {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "update":
                            return PaperDocUpdatePolicy.update
                        case "overwrite":
                            return PaperDocUpdatePolicy.overwrite
                        case "prepend":
                            return PaperDocUpdatePolicy.prepend
                        case "append":
                            return PaperDocUpdatePolicy.append
                        case "other":
                            return PaperDocUpdatePolicy.other
                        default:
                            return PaperDocUpdatePolicy.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The PaperUpdateArg struct
    open class PaperUpdateArg: CustomStringConvertible {
        /// Path in the user's Dropbox to update. The path must correspond to a Paper doc or an error will be returned.
        public let path: String
        /// The format of the provided data.
        public let importFormat: Files.ImportFormat
        /// How the provided content should be applied to the doc.
        public let docUpdatePolicy: Files.PaperDocUpdatePolicy
        /// The latest doc revision. Required when doc_update_policy is update. This value must match the current
        /// revision of the doc or error revision_mismatch will be returned.
        public let paperRevision: Int64?
        public init(path: String, importFormat: Files.ImportFormat, docUpdatePolicy: Files.PaperDocUpdatePolicy, paperRevision: Int64? = nil) {
            stringValidator(pattern: "(/(.|[\\r\\n])*)|(ns:[0-9]+(/.*)?)|(id:.*)")(path)
            self.path = path
            self.importFormat = importFormat
            self.docUpdatePolicy = docUpdatePolicy
            nullableValidator(comparableValidator())(paperRevision)
            self.paperRevision = paperRevision
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PaperUpdateArgSerializer().serialize(self)))"
        }
    }
    open class PaperUpdateArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PaperUpdateArg) -> JSON {
            let output = [ 
            "path": Serialization._StringSerializer.serialize(value.path),
            "import_format": Files.ImportFormatSerializer().serialize(value.importFormat),
            "doc_update_policy": Files.PaperDocUpdatePolicySerializer().serialize(value.docUpdatePolicy),
            "paper_revision": NullableSerializer(Serialization._Int64Serializer).serialize(value.paperRevision),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> PaperUpdateArg {
            switch json {
                case .dictionary(let dict):
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .null)
                    let importFormat = Files.ImportFormatSerializer().deserialize(dict["import_format"] ?? .null)
                    let docUpdatePolicy = Files.PaperDocUpdatePolicySerializer().deserialize(dict["doc_update_policy"] ?? .null)
                    let paperRevision = NullableSerializer(Serialization._Int64Serializer).deserialize(dict["paper_revision"] ?? .null)
                    return PaperUpdateArg(path: path, importFormat: importFormat, docUpdatePolicy: docUpdatePolicy, paperRevision: paperRevision)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The PaperUpdateError union
    public enum PaperUpdateError: CustomStringConvertible {
        /// Your account does not have permissions to edit Paper docs.
        case insufficientPermissions
        /// The provided content was malformed and cannot be imported to Paper.
        case contentMalformed
        /// The Paper doc would be too large, split the content into multiple docs.
        case docLengthExceeded
        /// The imported document contains an image that is too large. The current limit is 1MB. This only applies to
        /// HTML with data URI.
        case imageSizeExceeded
        /// An unspecified error.
        case other
        /// An unspecified error.
        case path(Files.LookupError)
        /// The provided revision does not match the document head.
        case revisionMismatch
        /// This operation is not allowed on archived Paper docs.
        case docArchived
        /// This operation is not allowed on deleted Paper docs.
        case docDeleted

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PaperUpdateErrorSerializer().serialize(self)))"
        }
    }
    open class PaperUpdateErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PaperUpdateError) -> JSON {
            switch value {
                case .insufficientPermissions:
                    var d = [String: JSON]()
                    d[".tag"] = .str("insufficient_permissions")
                    return .dictionary(d)
                case .contentMalformed:
                    var d = [String: JSON]()
                    d[".tag"] = .str("content_malformed")
                    return .dictionary(d)
                case .docLengthExceeded:
                    var d = [String: JSON]()
                    d[".tag"] = .str("doc_length_exceeded")
                    return .dictionary(d)
                case .imageSizeExceeded:
                    var d = [String: JSON]()
                    d[".tag"] = .str("image_size_exceeded")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
                case .path(let arg):
                    var d = ["path": Files.LookupErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("path")
                    return .dictionary(d)
                case .revisionMismatch:
                    var d = [String: JSON]()
                    d[".tag"] = .str("revision_mismatch")
                    return .dictionary(d)
                case .docArchived:
                    var d = [String: JSON]()
                    d[".tag"] = .str("doc_archived")
                    return .dictionary(d)
                case .docDeleted:
                    var d = [String: JSON]()
                    d[".tag"] = .str("doc_deleted")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> PaperUpdateError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "insufficient_permissions":
                            return PaperUpdateError.insufficientPermissions
                        case "content_malformed":
                            return PaperUpdateError.contentMalformed
                        case "doc_length_exceeded":
                            return PaperUpdateError.docLengthExceeded
                        case "image_size_exceeded":
                            return PaperUpdateError.imageSizeExceeded
                        case "other":
                            return PaperUpdateError.other
                        case "path":
                            let v = Files.LookupErrorSerializer().deserialize(d["path"] ?? .null)
                            return PaperUpdateError.path(v)
                        case "revision_mismatch":
                            return PaperUpdateError.revisionMismatch
                        case "doc_archived":
                            return PaperUpdateError.docArchived
                        case "doc_deleted":
                            return PaperUpdateError.docDeleted
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The PaperUpdateResult struct
    open class PaperUpdateResult: CustomStringConvertible {
        /// The current doc revision.
        public let paperRevision: Int64
        public init(paperRevision: Int64) {
            comparableValidator()(paperRevision)
            self.paperRevision = paperRevision
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PaperUpdateResultSerializer().serialize(self)))"
        }
    }
    open class PaperUpdateResultSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PaperUpdateResult) -> JSON {
            let output = [ 
            "paper_revision": Serialization._Int64Serializer.serialize(value.paperRevision),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> PaperUpdateResult {
            switch json {
                case .dictionary(let dict):
                    let paperRevision = Serialization._Int64Serializer.deserialize(dict["paper_revision"] ?? .null)
                    return PaperUpdateResult(paperRevision: paperRevision)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The PathOrLink union
    public enum PathOrLink: CustomStringConvertible {
        /// An unspecified error.
        case path(String)
        /// An unspecified error.
        case link(Files.SharedLinkFileInfo)
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PathOrLinkSerializer().serialize(self)))"
        }
    }
    open class PathOrLinkSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PathOrLink) -> JSON {
            switch value {
                case .path(let arg):
                    var d = ["path": Serialization._StringSerializer.serialize(arg)]
                    d[".tag"] = .str("path")
                    return .dictionary(d)
                case .link(let arg):
                    var d = Serialization.getFields(Files.SharedLinkFileInfoSerializer().serialize(arg))
                    d[".tag"] = .str("link")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> PathOrLink {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "path":
                            let v = Serialization._StringSerializer.deserialize(d["path"] ?? .null)
                            return PathOrLink.path(v)
                        case "link":
                            let v = Files.SharedLinkFileInfoSerializer().deserialize(json)
                            return PathOrLink.link(v)
                        case "other":
                            return PathOrLink.other
                        default:
                            return PathOrLink.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Metadata for a photo.
    open class PhotoMetadata: Files.MediaMetadata {
        open override var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PhotoMetadataSerializer().serialize(self)))"
        }
    }
    open class PhotoMetadataSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PhotoMetadata) -> JSON {
            let output = [ 
            "dimensions": NullableSerializer(Files.DimensionsSerializer()).serialize(value.dimensions),
            "location": NullableSerializer(Files.GpsCoordinatesSerializer()).serialize(value.location),
            "time_taken": NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.timeTaken),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> PhotoMetadata {
            switch json {
                case .dictionary(let dict):
                    let dimensions = NullableSerializer(Files.DimensionsSerializer()).deserialize(dict["dimensions"] ?? .null)
                    let location = NullableSerializer(Files.GpsCoordinatesSerializer()).deserialize(dict["location"] ?? .null)
                    let timeTaken = NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).deserialize(dict["time_taken"] ?? .null)
                    return PhotoMetadata(dimensions: dimensions, location: location, timeTaken: timeTaken)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The PreviewArg struct
    open class PreviewArg: CustomStringConvertible {
        /// The path of the file to preview.
        public let path: String
        /// Please specify revision in path instead.
        public let rev: String?
        public init(path: String, rev: String? = nil) {
            stringValidator(pattern: "(/(.|[\\r\\n])*|id:.*)|(rev:[0-9a-f]{9,})|(ns:[0-9]+(/.*)?)")(path)
            self.path = path
            nullableValidator(stringValidator(minLength: 9, pattern: "[0-9a-f]+"))(rev)
            self.rev = rev
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PreviewArgSerializer().serialize(self)))"
        }
    }
    open class PreviewArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PreviewArg) -> JSON {
            let output = [ 
            "path": Serialization._StringSerializer.serialize(value.path),
            "rev": NullableSerializer(Serialization._StringSerializer).serialize(value.rev),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> PreviewArg {
            switch json {
                case .dictionary(let dict):
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .null)
                    let rev = NullableSerializer(Serialization._StringSerializer).deserialize(dict["rev"] ?? .null)
                    return PreviewArg(path: path, rev: rev)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The PreviewError union
    public enum PreviewError: CustomStringConvertible {
        /// An error occurs when downloading metadata for the file.
        case path(Files.LookupError)
        /// This preview generation is still in progress and the file is not ready  for preview yet.
        case inProgress
        /// The file extension is not supported preview generation.
        case unsupportedExtension
        /// The file content is not supported for preview generation.
        case unsupportedContent

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PreviewErrorSerializer().serialize(self)))"
        }
    }
    open class PreviewErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PreviewError) -> JSON {
            switch value {
                case .path(let arg):
                    var d = ["path": Files.LookupErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("path")
                    return .dictionary(d)
                case .inProgress:
                    var d = [String: JSON]()
                    d[".tag"] = .str("in_progress")
                    return .dictionary(d)
                case .unsupportedExtension:
                    var d = [String: JSON]()
                    d[".tag"] = .str("unsupported_extension")
                    return .dictionary(d)
                case .unsupportedContent:
                    var d = [String: JSON]()
                    d[".tag"] = .str("unsupported_content")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> PreviewError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "path":
                            let v = Files.LookupErrorSerializer().deserialize(d["path"] ?? .null)
                            return PreviewError.path(v)
                        case "in_progress":
                            return PreviewError.inProgress
                        case "unsupported_extension":
                            return PreviewError.unsupportedExtension
                        case "unsupported_content":
                            return PreviewError.unsupportedContent
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The PreviewResult struct
    open class PreviewResult: CustomStringConvertible {
        /// Metadata corresponding to the file received as an argument. Will be populated if the endpoint is called with
        /// a path (ReadPath).
        public let fileMetadata: Files.FileMetadata?
        /// Minimal metadata corresponding to the file received as an argument. Will be populated if the endpoint is
        /// called using a shared link (SharedLinkFileInfo).
        public let linkMetadata: Files.MinimalFileLinkMetadata?
        public init(fileMetadata: Files.FileMetadata? = nil, linkMetadata: Files.MinimalFileLinkMetadata? = nil) {
            self.fileMetadata = fileMetadata
            self.linkMetadata = linkMetadata
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PreviewResultSerializer().serialize(self)))"
        }
    }
    open class PreviewResultSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PreviewResult) -> JSON {
            let output = [ 
            "file_metadata": NullableSerializer(Files.FileMetadataSerializer()).serialize(value.fileMetadata),
            "link_metadata": NullableSerializer(Files.MinimalFileLinkMetadataSerializer()).serialize(value.linkMetadata),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> PreviewResult {
            switch json {
                case .dictionary(let dict):
                    let fileMetadata = NullableSerializer(Files.FileMetadataSerializer()).deserialize(dict["file_metadata"] ?? .null)
                    let linkMetadata = NullableSerializer(Files.MinimalFileLinkMetadataSerializer()).deserialize(dict["link_metadata"] ?? .null)
                    return PreviewResult(fileMetadata: fileMetadata, linkMetadata: linkMetadata)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The RelocationPath struct
    open class RelocationPath: CustomStringConvertible {
        /// Path in the user's Dropbox to be copied or moved.
        public let fromPath: String
        /// Path in the user's Dropbox that is the destination.
        public let toPath: String
        public init(fromPath: String, toPath: String) {
            stringValidator(pattern: "(/(.|[\\r\\n])*)|(ns:[0-9]+(/.*)?)|(id:.*)")(fromPath)
            self.fromPath = fromPath
            stringValidator(pattern: "(/(.|[\\r\\n])*)|(ns:[0-9]+(/.*)?)|(id:.*)")(toPath)
            self.toPath = toPath
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(RelocationPathSerializer().serialize(self)))"
        }
    }
    open class RelocationPathSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: RelocationPath) -> JSON {
            let output = [ 
            "from_path": Serialization._StringSerializer.serialize(value.fromPath),
            "to_path": Serialization._StringSerializer.serialize(value.toPath),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> RelocationPath {
            switch json {
                case .dictionary(let dict):
                    let fromPath = Serialization._StringSerializer.deserialize(dict["from_path"] ?? .null)
                    let toPath = Serialization._StringSerializer.deserialize(dict["to_path"] ?? .null)
                    return RelocationPath(fromPath: fromPath, toPath: toPath)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The RelocationArg struct
    open class RelocationArg: Files.RelocationPath {
        /// This flag has no effect.
        public let allowSharedFolder: Bool
        /// If there's a conflict, have the Dropbox server try to autorename the file to avoid the conflict.
        public let autorename: Bool
        /// Allow moves by owner even if it would result in an ownership transfer for the content being moved. This does
        /// not apply to copies.
        public let allowOwnershipTransfer: Bool
        public init(fromPath: String, toPath: String, allowSharedFolder: Bool = false, autorename: Bool = false, allowOwnershipTransfer: Bool = false) {
            self.allowSharedFolder = allowSharedFolder
            self.autorename = autorename
            self.allowOwnershipTransfer = allowOwnershipTransfer
            super.init(fromPath: fromPath, toPath: toPath)
        }
        open override var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(RelocationArgSerializer().serialize(self)))"
        }
    }
    open class RelocationArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: RelocationArg) -> JSON {
            let output = [ 
            "from_path": Serialization._StringSerializer.serialize(value.fromPath),
            "to_path": Serialization._StringSerializer.serialize(value.toPath),
            "allow_shared_folder": Serialization._BoolSerializer.serialize(value.allowSharedFolder),
            "autorename": Serialization._BoolSerializer.serialize(value.autorename),
            "allow_ownership_transfer": Serialization._BoolSerializer.serialize(value.allowOwnershipTransfer),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> RelocationArg {
            switch json {
                case .dictionary(let dict):
                    let fromPath = Serialization._StringSerializer.deserialize(dict["from_path"] ?? .null)
                    let toPath = Serialization._StringSerializer.deserialize(dict["to_path"] ?? .null)
                    let allowSharedFolder = Serialization._BoolSerializer.deserialize(dict["allow_shared_folder"] ?? .number(0))
                    let autorename = Serialization._BoolSerializer.deserialize(dict["autorename"] ?? .number(0))
                    let allowOwnershipTransfer = Serialization._BoolSerializer.deserialize(dict["allow_ownership_transfer"] ?? .number(0))
                    return RelocationArg(fromPath: fromPath, toPath: toPath, allowSharedFolder: allowSharedFolder, autorename: autorename, allowOwnershipTransfer: allowOwnershipTransfer)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The RelocationBatchArg struct
    open class RelocationBatchArg: Files.RelocationBatchArgBase {
        /// This flag has no effect.
        public let allowSharedFolder: Bool
        /// Allow moves by owner even if it would result in an ownership transfer for the content being moved. This does
        /// not apply to copies.
        public let allowOwnershipTransfer: Bool
        public init(entries: Array<Files.RelocationPath>, autorename: Bool = false, allowSharedFolder: Bool = false, allowOwnershipTransfer: Bool = false) {
            self.allowSharedFolder = allowSharedFolder
            self.allowOwnershipTransfer = allowOwnershipTransfer
            super.init(entries: entries, autorename: autorename)
        }
        open override var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(RelocationBatchArgSerializer().serialize(self)))"
        }
    }
    open class RelocationBatchArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: RelocationBatchArg) -> JSON {
            let output = [ 
            "entries": ArraySerializer(Files.RelocationPathSerializer()).serialize(value.entries),
            "autorename": Serialization._BoolSerializer.serialize(value.autorename),
            "allow_shared_folder": Serialization._BoolSerializer.serialize(value.allowSharedFolder),
            "allow_ownership_transfer": Serialization._BoolSerializer.serialize(value.allowOwnershipTransfer),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> RelocationBatchArg {
            switch json {
                case .dictionary(let dict):
                    let entries = ArraySerializer(Files.RelocationPathSerializer()).deserialize(dict["entries"] ?? .null)
                    let autorename = Serialization._BoolSerializer.deserialize(dict["autorename"] ?? .number(0))
                    let allowSharedFolder = Serialization._BoolSerializer.deserialize(dict["allow_shared_folder"] ?? .number(0))
                    let allowOwnershipTransfer = Serialization._BoolSerializer.deserialize(dict["allow_ownership_transfer"] ?? .number(0))
                    return RelocationBatchArg(entries: entries, autorename: autorename, allowSharedFolder: allowSharedFolder, allowOwnershipTransfer: allowOwnershipTransfer)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The RelocationError union
    public enum RelocationError: CustomStringConvertible {
        /// An unspecified error.
        case fromLookup(Files.LookupError)
        /// An unspecified error.
        case fromWrite(Files.WriteError)
        /// An unspecified error.
        case to(Files.WriteError)
        /// Shared folders can't be copied.
        case cantCopySharedFolder
        /// Your move operation would result in nested shared folders.  This is not allowed.
        case cantNestSharedFolder
        /// You cannot move a folder into itself.
        case cantMoveFolderIntoItself
        /// The operation would involve more than 10,000 files and folders.
        case tooManyFiles
        /// There are duplicated/nested paths among fromPath in RelocationArg and toPath in RelocationArg.
        case duplicatedOrNestedPaths
        /// Your move operation would result in an ownership transfer. You may reissue the request with the field
        /// allowOwnershipTransfer in RelocationArg to true.
        case cantTransferOwnership
        /// The current user does not have enough space to move or copy the files.
        case insufficientQuota
        /// Something went wrong with the job on Dropbox's end. You'll need to verify that the action you were taking
        /// succeeded, and if not, try again. This should happen very rarely.
        case internalError
        /// Can't move the shared folder to the given destination.
        case cantMoveSharedFolder
        /// Some content cannot be moved into Vault under certain circumstances, see detailed error.
        case cantMoveIntoVault(Files.MoveIntoVaultError)
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(RelocationErrorSerializer().serialize(self)))"
        }
    }
    open class RelocationErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: RelocationError) -> JSON {
            switch value {
                case .fromLookup(let arg):
                    var d = ["from_lookup": Files.LookupErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("from_lookup")
                    return .dictionary(d)
                case .fromWrite(let arg):
                    var d = ["from_write": Files.WriteErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("from_write")
                    return .dictionary(d)
                case .to(let arg):
                    var d = ["to": Files.WriteErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("to")
                    return .dictionary(d)
                case .cantCopySharedFolder:
                    var d = [String: JSON]()
                    d[".tag"] = .str("cant_copy_shared_folder")
                    return .dictionary(d)
                case .cantNestSharedFolder:
                    var d = [String: JSON]()
                    d[".tag"] = .str("cant_nest_shared_folder")
                    return .dictionary(d)
                case .cantMoveFolderIntoItself:
                    var d = [String: JSON]()
                    d[".tag"] = .str("cant_move_folder_into_itself")
                    return .dictionary(d)
                case .tooManyFiles:
                    var d = [String: JSON]()
                    d[".tag"] = .str("too_many_files")
                    return .dictionary(d)
                case .duplicatedOrNestedPaths:
                    var d = [String: JSON]()
                    d[".tag"] = .str("duplicated_or_nested_paths")
                    return .dictionary(d)
                case .cantTransferOwnership:
                    var d = [String: JSON]()
                    d[".tag"] = .str("cant_transfer_ownership")
                    return .dictionary(d)
                case .insufficientQuota:
                    var d = [String: JSON]()
                    d[".tag"] = .str("insufficient_quota")
                    return .dictionary(d)
                case .internalError:
                    var d = [String: JSON]()
                    d[".tag"] = .str("internal_error")
                    return .dictionary(d)
                case .cantMoveSharedFolder:
                    var d = [String: JSON]()
                    d[".tag"] = .str("cant_move_shared_folder")
                    return .dictionary(d)
                case .cantMoveIntoVault(let arg):
                    var d = ["cant_move_into_vault": Files.MoveIntoVaultErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("cant_move_into_vault")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> RelocationError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "from_lookup":
                            let v = Files.LookupErrorSerializer().deserialize(d["from_lookup"] ?? .null)
                            return RelocationError.fromLookup(v)
                        case "from_write":
                            let v = Files.WriteErrorSerializer().deserialize(d["from_write"] ?? .null)
                            return RelocationError.fromWrite(v)
                        case "to":
                            let v = Files.WriteErrorSerializer().deserialize(d["to"] ?? .null)
                            return RelocationError.to(v)
                        case "cant_copy_shared_folder":
                            return RelocationError.cantCopySharedFolder
                        case "cant_nest_shared_folder":
                            return RelocationError.cantNestSharedFolder
                        case "cant_move_folder_into_itself":
                            return RelocationError.cantMoveFolderIntoItself
                        case "too_many_files":
                            return RelocationError.tooManyFiles
                        case "duplicated_or_nested_paths":
                            return RelocationError.duplicatedOrNestedPaths
                        case "cant_transfer_ownership":
                            return RelocationError.cantTransferOwnership
                        case "insufficient_quota":
                            return RelocationError.insufficientQuota
                        case "internal_error":
                            return RelocationError.internalError
                        case "cant_move_shared_folder":
                            return RelocationError.cantMoveSharedFolder
                        case "cant_move_into_vault":
                            let v = Files.MoveIntoVaultErrorSerializer().deserialize(d["cant_move_into_vault"] ?? .null)
                            return RelocationError.cantMoveIntoVault(v)
                        case "other":
                            return RelocationError.other
                        default:
                            return RelocationError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The RelocationBatchError union
    public enum RelocationBatchError: CustomStringConvertible {
        /// An unspecified error.
        case fromLookup(Files.LookupError)
        /// An unspecified error.
        case fromWrite(Files.WriteError)
        /// An unspecified error.
        case to(Files.WriteError)
        /// Shared folders can't be copied.
        case cantCopySharedFolder
        /// Your move operation would result in nested shared folders.  This is not allowed.
        case cantNestSharedFolder
        /// You cannot move a folder into itself.
        case cantMoveFolderIntoItself
        /// The operation would involve more than 10,000 files and folders.
        case tooManyFiles
        /// There are duplicated/nested paths among fromPath in RelocationArg and toPath in RelocationArg.
        case duplicatedOrNestedPaths
        /// Your move operation would result in an ownership transfer. You may reissue the request with the field
        /// allowOwnershipTransfer in RelocationArg to true.
        case cantTransferOwnership
        /// The current user does not have enough space to move or copy the files.
        case insufficientQuota
        /// Something went wrong with the job on Dropbox's end. You'll need to verify that the action you were taking
        /// succeeded, and if not, try again. This should happen very rarely.
        case internalError
        /// Can't move the shared folder to the given destination.
        case cantMoveSharedFolder
        /// Some content cannot be moved into Vault under certain circumstances, see detailed error.
        case cantMoveIntoVault(Files.MoveIntoVaultError)
        /// An unspecified error.
        case other
        /// There are too many write operations in user's Dropbox. Please retry this request.
        case tooManyWriteOperations

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(RelocationBatchErrorSerializer().serialize(self)))"
        }
    }
    open class RelocationBatchErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: RelocationBatchError) -> JSON {
            switch value {
                case .fromLookup(let arg):
                    var d = ["from_lookup": Files.LookupErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("from_lookup")
                    return .dictionary(d)
                case .fromWrite(let arg):
                    var d = ["from_write": Files.WriteErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("from_write")
                    return .dictionary(d)
                case .to(let arg):
                    var d = ["to": Files.WriteErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("to")
                    return .dictionary(d)
                case .cantCopySharedFolder:
                    var d = [String: JSON]()
                    d[".tag"] = .str("cant_copy_shared_folder")
                    return .dictionary(d)
                case .cantNestSharedFolder:
                    var d = [String: JSON]()
                    d[".tag"] = .str("cant_nest_shared_folder")
                    return .dictionary(d)
                case .cantMoveFolderIntoItself:
                    var d = [String: JSON]()
                    d[".tag"] = .str("cant_move_folder_into_itself")
                    return .dictionary(d)
                case .tooManyFiles:
                    var d = [String: JSON]()
                    d[".tag"] = .str("too_many_files")
                    return .dictionary(d)
                case .duplicatedOrNestedPaths:
                    var d = [String: JSON]()
                    d[".tag"] = .str("duplicated_or_nested_paths")
                    return .dictionary(d)
                case .cantTransferOwnership:
                    var d = [String: JSON]()
                    d[".tag"] = .str("cant_transfer_ownership")
                    return .dictionary(d)
                case .insufficientQuota:
                    var d = [String: JSON]()
                    d[".tag"] = .str("insufficient_quota")
                    return .dictionary(d)
                case .internalError:
                    var d = [String: JSON]()
                    d[".tag"] = .str("internal_error")
                    return .dictionary(d)
                case .cantMoveSharedFolder:
                    var d = [String: JSON]()
                    d[".tag"] = .str("cant_move_shared_folder")
                    return .dictionary(d)
                case .cantMoveIntoVault(let arg):
                    var d = ["cant_move_into_vault": Files.MoveIntoVaultErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("cant_move_into_vault")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
                case .tooManyWriteOperations:
                    var d = [String: JSON]()
                    d[".tag"] = .str("too_many_write_operations")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> RelocationBatchError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "from_lookup":
                            let v = Files.LookupErrorSerializer().deserialize(d["from_lookup"] ?? .null)
                            return RelocationBatchError.fromLookup(v)
                        case "from_write":
                            let v = Files.WriteErrorSerializer().deserialize(d["from_write"] ?? .null)
                            return RelocationBatchError.fromWrite(v)
                        case "to":
                            let v = Files.WriteErrorSerializer().deserialize(d["to"] ?? .null)
                            return RelocationBatchError.to(v)
                        case "cant_copy_shared_folder":
                            return RelocationBatchError.cantCopySharedFolder
                        case "cant_nest_shared_folder":
                            return RelocationBatchError.cantNestSharedFolder
                        case "cant_move_folder_into_itself":
                            return RelocationBatchError.cantMoveFolderIntoItself
                        case "too_many_files":
                            return RelocationBatchError.tooManyFiles
                        case "duplicated_or_nested_paths":
                            return RelocationBatchError.duplicatedOrNestedPaths
                        case "cant_transfer_ownership":
                            return RelocationBatchError.cantTransferOwnership
                        case "insufficient_quota":
                            return RelocationBatchError.insufficientQuota
                        case "internal_error":
                            return RelocationBatchError.internalError
                        case "cant_move_shared_folder":
                            return RelocationBatchError.cantMoveSharedFolder
                        case "cant_move_into_vault":
                            let v = Files.MoveIntoVaultErrorSerializer().deserialize(d["cant_move_into_vault"] ?? .null)
                            return RelocationBatchError.cantMoveIntoVault(v)
                        case "other":
                            return RelocationBatchError.other
                        case "too_many_write_operations":
                            return RelocationBatchError.tooManyWriteOperations
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The RelocationBatchErrorEntry union
    public enum RelocationBatchErrorEntry: CustomStringConvertible {
        /// User errors that retry won't help.
        case relocationError(Files.RelocationError)
        /// Something went wrong with the job on Dropbox's end. You'll need to verify that the action you were taking
        /// succeeded, and if not, try again. This should happen very rarely.
        case internalError
        /// There are too many write operations in user's Dropbox. Please retry this request.
        case tooManyWriteOperations
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(RelocationBatchErrorEntrySerializer().serialize(self)))"
        }
    }
    open class RelocationBatchErrorEntrySerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: RelocationBatchErrorEntry) -> JSON {
            switch value {
                case .relocationError(let arg):
                    var d = ["relocation_error": Files.RelocationErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("relocation_error")
                    return .dictionary(d)
                case .internalError:
                    var d = [String: JSON]()
                    d[".tag"] = .str("internal_error")
                    return .dictionary(d)
                case .tooManyWriteOperations:
                    var d = [String: JSON]()
                    d[".tag"] = .str("too_many_write_operations")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> RelocationBatchErrorEntry {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "relocation_error":
                            let v = Files.RelocationErrorSerializer().deserialize(d["relocation_error"] ?? .null)
                            return RelocationBatchErrorEntry.relocationError(v)
                        case "internal_error":
                            return RelocationBatchErrorEntry.internalError
                        case "too_many_write_operations":
                            return RelocationBatchErrorEntry.tooManyWriteOperations
                        case "other":
                            return RelocationBatchErrorEntry.other
                        default:
                            return RelocationBatchErrorEntry.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The RelocationBatchJobStatus union
    public enum RelocationBatchJobStatus: CustomStringConvertible {
        /// The asynchronous job is still in progress.
        case inProgress
        /// The copy or move batch job has finished.
        case complete(Files.RelocationBatchResult)
        /// The copy or move batch job has failed with exception.
        case failed(Files.RelocationBatchError)

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(RelocationBatchJobStatusSerializer().serialize(self)))"
        }
    }
    open class RelocationBatchJobStatusSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: RelocationBatchJobStatus) -> JSON {
            switch value {
                case .inProgress:
                    var d = [String: JSON]()
                    d[".tag"] = .str("in_progress")
                    return .dictionary(d)
                case .complete(let arg):
                    var d = Serialization.getFields(Files.RelocationBatchResultSerializer().serialize(arg))
                    d[".tag"] = .str("complete")
                    return .dictionary(d)
                case .failed(let arg):
                    var d = ["failed": Files.RelocationBatchErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("failed")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> RelocationBatchJobStatus {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "in_progress":
                            return RelocationBatchJobStatus.inProgress
                        case "complete":
                            let v = Files.RelocationBatchResultSerializer().deserialize(json)
                            return RelocationBatchJobStatus.complete(v)
                        case "failed":
                            let v = Files.RelocationBatchErrorSerializer().deserialize(d["failed"] ?? .null)
                            return RelocationBatchJobStatus.failed(v)
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Result returned by copyBatch or moveBatch that may either launch an asynchronous job or complete synchronously.
    public enum RelocationBatchLaunch: CustomStringConvertible {
        /// This response indicates that the processing is asynchronous. The string is an id that can be used to obtain
        /// the status of the asynchronous job.
        case asyncJobId(String)
        /// An unspecified error.
        case complete(Files.RelocationBatchResult)
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(RelocationBatchLaunchSerializer().serialize(self)))"
        }
    }
    open class RelocationBatchLaunchSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: RelocationBatchLaunch) -> JSON {
            switch value {
                case .asyncJobId(let arg):
                    var d = ["async_job_id": Serialization._StringSerializer.serialize(arg)]
                    d[".tag"] = .str("async_job_id")
                    return .dictionary(d)
                case .complete(let arg):
                    var d = Serialization.getFields(Files.RelocationBatchResultSerializer().serialize(arg))
                    d[".tag"] = .str("complete")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> RelocationBatchLaunch {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "async_job_id":
                            let v = Serialization._StringSerializer.deserialize(d["async_job_id"] ?? .null)
                            return RelocationBatchLaunch.asyncJobId(v)
                        case "complete":
                            let v = Files.RelocationBatchResultSerializer().deserialize(json)
                            return RelocationBatchLaunch.complete(v)
                        case "other":
                            return RelocationBatchLaunch.other
                        default:
                            return RelocationBatchLaunch.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The RelocationBatchResult struct
    open class RelocationBatchResult: Files.FileOpsResult {
        /// (no description)
        public let entries: Array<Files.RelocationBatchResultData>
        public init(entries: Array<Files.RelocationBatchResultData>) {
            self.entries = entries
            super.init()
        }
        open override var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(RelocationBatchResultSerializer().serialize(self)))"
        }
    }
    open class RelocationBatchResultSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: RelocationBatchResult) -> JSON {
            let output = [ 
            "entries": ArraySerializer(Files.RelocationBatchResultDataSerializer()).serialize(value.entries),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> RelocationBatchResult {
            switch json {
                case .dictionary(let dict):
                    let entries = ArraySerializer(Files.RelocationBatchResultDataSerializer()).deserialize(dict["entries"] ?? .null)
                    return RelocationBatchResult(entries: entries)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The RelocationBatchResultData struct
    open class RelocationBatchResultData: CustomStringConvertible {
        /// Metadata of the relocated object.
        public let metadata: Files.Metadata
        public init(metadata: Files.Metadata) {
            self.metadata = metadata
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(RelocationBatchResultDataSerializer().serialize(self)))"
        }
    }
    open class RelocationBatchResultDataSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: RelocationBatchResultData) -> JSON {
            let output = [ 
            "metadata": Files.MetadataSerializer().serialize(value.metadata),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> RelocationBatchResultData {
            switch json {
                case .dictionary(let dict):
                    let metadata = Files.MetadataSerializer().deserialize(dict["metadata"] ?? .null)
                    return RelocationBatchResultData(metadata: metadata)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The RelocationBatchResultEntry union
    public enum RelocationBatchResultEntry: CustomStringConvertible {
        /// An unspecified error.
        case success(Files.Metadata)
        /// An unspecified error.
        case failure(Files.RelocationBatchErrorEntry)
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(RelocationBatchResultEntrySerializer().serialize(self)))"
        }
    }
    open class RelocationBatchResultEntrySerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: RelocationBatchResultEntry) -> JSON {
            switch value {
                case .success(let arg):
                    var d = ["success": Files.MetadataSerializer().serialize(arg)]
                    d[".tag"] = .str("success")
                    return .dictionary(d)
                case .failure(let arg):
                    var d = ["failure": Files.RelocationBatchErrorEntrySerializer().serialize(arg)]
                    d[".tag"] = .str("failure")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> RelocationBatchResultEntry {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "success":
                            let v = Files.MetadataSerializer().deserialize(d["success"] ?? .null)
                            return RelocationBatchResultEntry.success(v)
                        case "failure":
                            let v = Files.RelocationBatchErrorEntrySerializer().deserialize(d["failure"] ?? .null)
                            return RelocationBatchResultEntry.failure(v)
                        case "other":
                            return RelocationBatchResultEntry.other
                        default:
                            return RelocationBatchResultEntry.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Result returned by copyBatchCheckV2 or moveBatchCheckV2 that may either be in progress or completed with result
    /// for each entry.
    public enum RelocationBatchV2JobStatus: CustomStringConvertible {
        /// The asynchronous job is still in progress.
        case inProgress
        /// The copy or move batch job has finished.
        case complete(Files.RelocationBatchV2Result)

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(RelocationBatchV2JobStatusSerializer().serialize(self)))"
        }
    }
    open class RelocationBatchV2JobStatusSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: RelocationBatchV2JobStatus) -> JSON {
            switch value {
                case .inProgress:
                    var d = [String: JSON]()
                    d[".tag"] = .str("in_progress")
                    return .dictionary(d)
                case .complete(let arg):
                    var d = Serialization.getFields(Files.RelocationBatchV2ResultSerializer().serialize(arg))
                    d[".tag"] = .str("complete")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> RelocationBatchV2JobStatus {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "in_progress":
                            return RelocationBatchV2JobStatus.inProgress
                        case "complete":
                            let v = Files.RelocationBatchV2ResultSerializer().deserialize(json)
                            return RelocationBatchV2JobStatus.complete(v)
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Result returned by copyBatchV2 or moveBatchV2 that may either launch an asynchronous job or complete
    /// synchronously.
    public enum RelocationBatchV2Launch: CustomStringConvertible {
        /// This response indicates that the processing is asynchronous. The string is an id that can be used to obtain
        /// the status of the asynchronous job.
        case asyncJobId(String)
        /// An unspecified error.
        case complete(Files.RelocationBatchV2Result)

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(RelocationBatchV2LaunchSerializer().serialize(self)))"
        }
    }
    open class RelocationBatchV2LaunchSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: RelocationBatchV2Launch) -> JSON {
            switch value {
                case .asyncJobId(let arg):
                    var d = ["async_job_id": Serialization._StringSerializer.serialize(arg)]
                    d[".tag"] = .str("async_job_id")
                    return .dictionary(d)
                case .complete(let arg):
                    var d = Serialization.getFields(Files.RelocationBatchV2ResultSerializer().serialize(arg))
                    d[".tag"] = .str("complete")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> RelocationBatchV2Launch {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "async_job_id":
                            let v = Serialization._StringSerializer.deserialize(d["async_job_id"] ?? .null)
                            return RelocationBatchV2Launch.asyncJobId(v)
                        case "complete":
                            let v = Files.RelocationBatchV2ResultSerializer().deserialize(json)
                            return RelocationBatchV2Launch.complete(v)
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The RelocationBatchV2Result struct
    open class RelocationBatchV2Result: Files.FileOpsResult {
        /// Each entry in CopyBatchArg.entries or entries in MoveBatchArg will appear at the same position inside
        /// entries in RelocationBatchV2Result.
        public let entries: Array<Files.RelocationBatchResultEntry>
        public init(entries: Array<Files.RelocationBatchResultEntry>) {
            self.entries = entries
            super.init()
        }
        open override var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(RelocationBatchV2ResultSerializer().serialize(self)))"
        }
    }
    open class RelocationBatchV2ResultSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: RelocationBatchV2Result) -> JSON {
            let output = [ 
            "entries": ArraySerializer(Files.RelocationBatchResultEntrySerializer()).serialize(value.entries),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> RelocationBatchV2Result {
            switch json {
                case .dictionary(let dict):
                    let entries = ArraySerializer(Files.RelocationBatchResultEntrySerializer()).deserialize(dict["entries"] ?? .null)
                    return RelocationBatchV2Result(entries: entries)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The RelocationResult struct
    open class RelocationResult: Files.FileOpsResult {
        /// Metadata of the relocated object.
        public let metadata: Files.Metadata
        public init(metadata: Files.Metadata) {
            self.metadata = metadata
            super.init()
        }
        open override var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(RelocationResultSerializer().serialize(self)))"
        }
    }
    open class RelocationResultSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: RelocationResult) -> JSON {
            let output = [ 
            "metadata": Files.MetadataSerializer().serialize(value.metadata),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> RelocationResult {
            switch json {
                case .dictionary(let dict):
                    let metadata = Files.MetadataSerializer().deserialize(dict["metadata"] ?? .null)
                    return RelocationResult(metadata: metadata)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The RestoreArg struct
    open class RestoreArg: CustomStringConvertible {
        /// The path to save the restored file.
        public let path: String
        /// The revision to restore.
        public let rev: String
        public init(path: String, rev: String) {
            stringValidator(pattern: "(/(.|[\\r\\n])*)|(ns:[0-9]+(/.*)?)")(path)
            self.path = path
            stringValidator(minLength: 9, pattern: "[0-9a-f]+")(rev)
            self.rev = rev
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(RestoreArgSerializer().serialize(self)))"
        }
    }
    open class RestoreArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: RestoreArg) -> JSON {
            let output = [ 
            "path": Serialization._StringSerializer.serialize(value.path),
            "rev": Serialization._StringSerializer.serialize(value.rev),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> RestoreArg {
            switch json {
                case .dictionary(let dict):
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .null)
                    let rev = Serialization._StringSerializer.deserialize(dict["rev"] ?? .null)
                    return RestoreArg(path: path, rev: rev)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The RestoreError union
    public enum RestoreError: CustomStringConvertible {
        /// An error occurs when downloading metadata for the file.
        case pathLookup(Files.LookupError)
        /// An error occurs when trying to restore the file to that path.
        case pathWrite(Files.WriteError)
        /// The revision is invalid. It may not exist or may point to a deleted file.
        case invalidRevision
        /// The restore is currently executing, but has not yet completed.
        case inProgress
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(RestoreErrorSerializer().serialize(self)))"
        }
    }
    open class RestoreErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: RestoreError) -> JSON {
            switch value {
                case .pathLookup(let arg):
                    var d = ["path_lookup": Files.LookupErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("path_lookup")
                    return .dictionary(d)
                case .pathWrite(let arg):
                    var d = ["path_write": Files.WriteErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("path_write")
                    return .dictionary(d)
                case .invalidRevision:
                    var d = [String: JSON]()
                    d[".tag"] = .str("invalid_revision")
                    return .dictionary(d)
                case .inProgress:
                    var d = [String: JSON]()
                    d[".tag"] = .str("in_progress")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> RestoreError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "path_lookup":
                            let v = Files.LookupErrorSerializer().deserialize(d["path_lookup"] ?? .null)
                            return RestoreError.pathLookup(v)
                        case "path_write":
                            let v = Files.WriteErrorSerializer().deserialize(d["path_write"] ?? .null)
                            return RestoreError.pathWrite(v)
                        case "invalid_revision":
                            return RestoreError.invalidRevision
                        case "in_progress":
                            return RestoreError.inProgress
                        case "other":
                            return RestoreError.other
                        default:
                            return RestoreError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The SaveCopyReferenceArg struct
    open class SaveCopyReferenceArg: CustomStringConvertible {
        /// A copy reference returned by copyReferenceGet.
        public let copyReference: String
        /// Path in the user's Dropbox that is the destination.
        public let path: String
        public init(copyReference: String, path: String) {
            stringValidator()(copyReference)
            self.copyReference = copyReference
            stringValidator(pattern: "/(.|[\\r\\n])*")(path)
            self.path = path
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SaveCopyReferenceArgSerializer().serialize(self)))"
        }
    }
    open class SaveCopyReferenceArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SaveCopyReferenceArg) -> JSON {
            let output = [ 
            "copy_reference": Serialization._StringSerializer.serialize(value.copyReference),
            "path": Serialization._StringSerializer.serialize(value.path),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SaveCopyReferenceArg {
            switch json {
                case .dictionary(let dict):
                    let copyReference = Serialization._StringSerializer.deserialize(dict["copy_reference"] ?? .null)
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .null)
                    return SaveCopyReferenceArg(copyReference: copyReference, path: path)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The SaveCopyReferenceError union
    public enum SaveCopyReferenceError: CustomStringConvertible {
        /// An unspecified error.
        case path(Files.WriteError)
        /// The copy reference is invalid.
        case invalidCopyReference
        /// You don't have permission to save the given copy reference. Please make sure this app is same app which
        /// created the copy reference and the source user is still linked to the app.
        case noPermission
        /// The file referenced by the copy reference cannot be found.
        case notFound
        /// The operation would involve more than 10,000 files and folders.
        case tooManyFiles
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SaveCopyReferenceErrorSerializer().serialize(self)))"
        }
    }
    open class SaveCopyReferenceErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SaveCopyReferenceError) -> JSON {
            switch value {
                case .path(let arg):
                    var d = ["path": Files.WriteErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("path")
                    return .dictionary(d)
                case .invalidCopyReference:
                    var d = [String: JSON]()
                    d[".tag"] = .str("invalid_copy_reference")
                    return .dictionary(d)
                case .noPermission:
                    var d = [String: JSON]()
                    d[".tag"] = .str("no_permission")
                    return .dictionary(d)
                case .notFound:
                    var d = [String: JSON]()
                    d[".tag"] = .str("not_found")
                    return .dictionary(d)
                case .tooManyFiles:
                    var d = [String: JSON]()
                    d[".tag"] = .str("too_many_files")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> SaveCopyReferenceError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "path":
                            let v = Files.WriteErrorSerializer().deserialize(d["path"] ?? .null)
                            return SaveCopyReferenceError.path(v)
                        case "invalid_copy_reference":
                            return SaveCopyReferenceError.invalidCopyReference
                        case "no_permission":
                            return SaveCopyReferenceError.noPermission
                        case "not_found":
                            return SaveCopyReferenceError.notFound
                        case "too_many_files":
                            return SaveCopyReferenceError.tooManyFiles
                        case "other":
                            return SaveCopyReferenceError.other
                        default:
                            return SaveCopyReferenceError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The SaveCopyReferenceResult struct
    open class SaveCopyReferenceResult: CustomStringConvertible {
        /// The metadata of the saved file or folder in the user's Dropbox.
        public let metadata: Files.Metadata
        public init(metadata: Files.Metadata) {
            self.metadata = metadata
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SaveCopyReferenceResultSerializer().serialize(self)))"
        }
    }
    open class SaveCopyReferenceResultSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SaveCopyReferenceResult) -> JSON {
            let output = [ 
            "metadata": Files.MetadataSerializer().serialize(value.metadata),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SaveCopyReferenceResult {
            switch json {
                case .dictionary(let dict):
                    let metadata = Files.MetadataSerializer().deserialize(dict["metadata"] ?? .null)
                    return SaveCopyReferenceResult(metadata: metadata)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The SaveUrlArg struct
    open class SaveUrlArg: CustomStringConvertible {
        /// The path in Dropbox where the URL will be saved to.
        public let path: String
        /// The URL to be saved.
        public let url: String
        public init(path: String, url: String) {
            stringValidator(pattern: "/(.|[\\r\\n])*")(path)
            self.path = path
            stringValidator()(url)
            self.url = url
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SaveUrlArgSerializer().serialize(self)))"
        }
    }
    open class SaveUrlArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SaveUrlArg) -> JSON {
            let output = [ 
            "path": Serialization._StringSerializer.serialize(value.path),
            "url": Serialization._StringSerializer.serialize(value.url),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SaveUrlArg {
            switch json {
                case .dictionary(let dict):
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .null)
                    let url = Serialization._StringSerializer.deserialize(dict["url"] ?? .null)
                    return SaveUrlArg(path: path, url: url)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The SaveUrlError union
    public enum SaveUrlError: CustomStringConvertible {
        /// An unspecified error.
        case path(Files.WriteError)
        /// Failed downloading the given URL. The URL may be  password-protected and the password provided was
        /// incorrect,  or the link may be disabled.
        case downloadFailed
        /// The given URL is invalid.
        case invalidUrl
        /// The file where the URL is saved to no longer exists.
        case notFound
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SaveUrlErrorSerializer().serialize(self)))"
        }
    }
    open class SaveUrlErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SaveUrlError) -> JSON {
            switch value {
                case .path(let arg):
                    var d = ["path": Files.WriteErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("path")
                    return .dictionary(d)
                case .downloadFailed:
                    var d = [String: JSON]()
                    d[".tag"] = .str("download_failed")
                    return .dictionary(d)
                case .invalidUrl:
                    var d = [String: JSON]()
                    d[".tag"] = .str("invalid_url")
                    return .dictionary(d)
                case .notFound:
                    var d = [String: JSON]()
                    d[".tag"] = .str("not_found")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> SaveUrlError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "path":
                            let v = Files.WriteErrorSerializer().deserialize(d["path"] ?? .null)
                            return SaveUrlError.path(v)
                        case "download_failed":
                            return SaveUrlError.downloadFailed
                        case "invalid_url":
                            return SaveUrlError.invalidUrl
                        case "not_found":
                            return SaveUrlError.notFound
                        case "other":
                            return SaveUrlError.other
                        default:
                            return SaveUrlError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The SaveUrlJobStatus union
    public enum SaveUrlJobStatus: CustomStringConvertible {
        /// The asynchronous job is still in progress.
        case inProgress
        /// Metadata of the file where the URL is saved to.
        case complete(Files.FileMetadata)
        /// An unspecified error.
        case failed(Files.SaveUrlError)

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SaveUrlJobStatusSerializer().serialize(self)))"
        }
    }
    open class SaveUrlJobStatusSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SaveUrlJobStatus) -> JSON {
            switch value {
                case .inProgress:
                    var d = [String: JSON]()
                    d[".tag"] = .str("in_progress")
                    return .dictionary(d)
                case .complete(let arg):
                    var d = Serialization.getFields(Files.FileMetadataSerializer().serialize(arg))
                    d[".tag"] = .str("complete")
                    return .dictionary(d)
                case .failed(let arg):
                    var d = ["failed": Files.SaveUrlErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("failed")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> SaveUrlJobStatus {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "in_progress":
                            return SaveUrlJobStatus.inProgress
                        case "complete":
                            let v = Files.FileMetadataSerializer().deserialize(json)
                            return SaveUrlJobStatus.complete(v)
                        case "failed":
                            let v = Files.SaveUrlErrorSerializer().deserialize(d["failed"] ?? .null)
                            return SaveUrlJobStatus.failed(v)
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The SaveUrlResult union
    public enum SaveUrlResult: CustomStringConvertible {
        /// This response indicates that the processing is asynchronous. The string is an id that can be used to obtain
        /// the status of the asynchronous job.
        case asyncJobId(String)
        /// Metadata of the file where the URL is saved to.
        case complete(Files.FileMetadata)

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SaveUrlResultSerializer().serialize(self)))"
        }
    }
    open class SaveUrlResultSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SaveUrlResult) -> JSON {
            switch value {
                case .asyncJobId(let arg):
                    var d = ["async_job_id": Serialization._StringSerializer.serialize(arg)]
                    d[".tag"] = .str("async_job_id")
                    return .dictionary(d)
                case .complete(let arg):
                    var d = Serialization.getFields(Files.FileMetadataSerializer().serialize(arg))
                    d[".tag"] = .str("complete")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> SaveUrlResult {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "async_job_id":
                            let v = Serialization._StringSerializer.deserialize(d["async_job_id"] ?? .null)
                            return SaveUrlResult.asyncJobId(v)
                        case "complete":
                            let v = Files.FileMetadataSerializer().deserialize(json)
                            return SaveUrlResult.complete(v)
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The SearchArg struct
    open class SearchArg: CustomStringConvertible {
        /// The path in the user's Dropbox to search. Should probably be a folder.
        public let path: String
        /// The string to search for. Query string may be rewritten to improve relevance of results. The string is split
        /// on spaces into multiple tokens. For file name searching, the last token is used for prefix matching (i.e.
        /// "bat c" matches "bat cave" but not "batman car").
        public let query: String
        /// The starting index within the search results (used for paging).
        public let start: UInt64
        /// The maximum number of search results to return.
        public let maxResults: UInt64
        /// The search mode (filename, filename_and_content, or deleted_filename). Note that searching file content is
        /// only available for Dropbox Business accounts.
        public let mode: Files.SearchMode
        public init(path: String, query: String, start: UInt64 = 0, maxResults: UInt64 = 100, mode: Files.SearchMode = .filename) {
            stringValidator(pattern: "(/(.|[\\r\\n])*)?|id:.*|(ns:[0-9]+(/.*)?)")(path)
            self.path = path
            stringValidator(maxLength: 1000)(query)
            self.query = query
            comparableValidator(maxValue: 9999)(start)
            self.start = start
            comparableValidator(minValue: 1, maxValue: 1000)(maxResults)
            self.maxResults = maxResults
            self.mode = mode
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SearchArgSerializer().serialize(self)))"
        }
    }
    open class SearchArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SearchArg) -> JSON {
            let output = [ 
            "path": Serialization._StringSerializer.serialize(value.path),
            "query": Serialization._StringSerializer.serialize(value.query),
            "start": Serialization._UInt64Serializer.serialize(value.start),
            "max_results": Serialization._UInt64Serializer.serialize(value.maxResults),
            "mode": Files.SearchModeSerializer().serialize(value.mode),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SearchArg {
            switch json {
                case .dictionary(let dict):
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .null)
                    let query = Serialization._StringSerializer.deserialize(dict["query"] ?? .null)
                    let start = Serialization._UInt64Serializer.deserialize(dict["start"] ?? .number(0))
                    let maxResults = Serialization._UInt64Serializer.deserialize(dict["max_results"] ?? .number(100))
                    let mode = Files.SearchModeSerializer().deserialize(dict["mode"] ?? Files.SearchModeSerializer().serialize(.filename))
                    return SearchArg(path: path, query: query, start: start, maxResults: maxResults, mode: mode)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The SearchError union
    public enum SearchError: CustomStringConvertible {
        /// An unspecified error.
        case path(Files.LookupError)
        /// An unspecified error.
        case invalidArgument(String?)
        /// Something went wrong, please try again.
        case internalError
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SearchErrorSerializer().serialize(self)))"
        }
    }
    open class SearchErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SearchError) -> JSON {
            switch value {
                case .path(let arg):
                    var d = ["path": Files.LookupErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("path")
                    return .dictionary(d)
                case .invalidArgument(let arg):
                    var d = ["invalid_argument": NullableSerializer(Serialization._StringSerializer).serialize(arg)]
                    d[".tag"] = .str("invalid_argument")
                    return .dictionary(d)
                case .internalError:
                    var d = [String: JSON]()
                    d[".tag"] = .str("internal_error")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> SearchError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "path":
                            let v = Files.LookupErrorSerializer().deserialize(d["path"] ?? .null)
                            return SearchError.path(v)
                        case "invalid_argument":
                            let v = NullableSerializer(Serialization._StringSerializer).deserialize(d["invalid_argument"] ?? .null)
                            return SearchError.invalidArgument(v)
                        case "internal_error":
                            return SearchError.internalError
                        case "other":
                            return SearchError.other
                        default:
                            return SearchError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The SearchMatch struct
    open class SearchMatch: CustomStringConvertible {
        /// The type of the match.
        public let matchType: Files.SearchMatchType
        /// The metadata for the matched file or folder.
        public let metadata: Files.Metadata
        public init(matchType: Files.SearchMatchType, metadata: Files.Metadata) {
            self.matchType = matchType
            self.metadata = metadata
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SearchMatchSerializer().serialize(self)))"
        }
    }
    open class SearchMatchSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SearchMatch) -> JSON {
            let output = [ 
            "match_type": Files.SearchMatchTypeSerializer().serialize(value.matchType),
            "metadata": Files.MetadataSerializer().serialize(value.metadata),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SearchMatch {
            switch json {
                case .dictionary(let dict):
                    let matchType = Files.SearchMatchTypeSerializer().deserialize(dict["match_type"] ?? .null)
                    let metadata = Files.MetadataSerializer().deserialize(dict["metadata"] ?? .null)
                    return SearchMatch(matchType: matchType, metadata: metadata)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The SearchMatchFieldOptions struct
    open class SearchMatchFieldOptions: CustomStringConvertible {
        /// Whether to include highlight span from file title.
        public let includeHighlights: Bool
        public init(includeHighlights: Bool = false) {
            self.includeHighlights = includeHighlights
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SearchMatchFieldOptionsSerializer().serialize(self)))"
        }
    }
    open class SearchMatchFieldOptionsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SearchMatchFieldOptions) -> JSON {
            let output = [ 
            "include_highlights": Serialization._BoolSerializer.serialize(value.includeHighlights),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SearchMatchFieldOptions {
            switch json {
                case .dictionary(let dict):
                    let includeHighlights = Serialization._BoolSerializer.deserialize(dict["include_highlights"] ?? .number(0))
                    return SearchMatchFieldOptions(includeHighlights: includeHighlights)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Indicates what type of match was found for a given item.
    public enum SearchMatchType: CustomStringConvertible {
        /// This item was matched on its file or folder name.
        case filename
        /// This item was matched based on its file contents.
        case content
        /// This item was matched based on both its contents and its file name.
        case both

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SearchMatchTypeSerializer().serialize(self)))"
        }
    }
    open class SearchMatchTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SearchMatchType) -> JSON {
            switch value {
                case .filename:
                    var d = [String: JSON]()
                    d[".tag"] = .str("filename")
                    return .dictionary(d)
                case .content:
                    var d = [String: JSON]()
                    d[".tag"] = .str("content")
                    return .dictionary(d)
                case .both:
                    var d = [String: JSON]()
                    d[".tag"] = .str("both")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> SearchMatchType {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "filename":
                            return SearchMatchType.filename
                        case "content":
                            return SearchMatchType.content
                        case "both":
                            return SearchMatchType.both
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Indicates what type of match was found for a given item.
    public enum SearchMatchTypeV2: CustomStringConvertible {
        /// This item was matched on its file or folder name.
        case filename
        /// This item was matched based on its file contents.
        case fileContent
        /// This item was matched based on both its contents and its file name.
        case filenameAndContent
        /// This item was matched on image content.
        case imageContent
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SearchMatchTypeV2Serializer().serialize(self)))"
        }
    }
    open class SearchMatchTypeV2Serializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SearchMatchTypeV2) -> JSON {
            switch value {
                case .filename:
                    var d = [String: JSON]()
                    d[".tag"] = .str("filename")
                    return .dictionary(d)
                case .fileContent:
                    var d = [String: JSON]()
                    d[".tag"] = .str("file_content")
                    return .dictionary(d)
                case .filenameAndContent:
                    var d = [String: JSON]()
                    d[".tag"] = .str("filename_and_content")
                    return .dictionary(d)
                case .imageContent:
                    var d = [String: JSON]()
                    d[".tag"] = .str("image_content")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> SearchMatchTypeV2 {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "filename":
                            return SearchMatchTypeV2.filename
                        case "file_content":
                            return SearchMatchTypeV2.fileContent
                        case "filename_and_content":
                            return SearchMatchTypeV2.filenameAndContent
                        case "image_content":
                            return SearchMatchTypeV2.imageContent
                        case "other":
                            return SearchMatchTypeV2.other
                        default:
                            return SearchMatchTypeV2.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The SearchMatchV2 struct
    open class SearchMatchV2: CustomStringConvertible {
        /// The metadata for the matched file or folder.
        public let metadata: Files.MetadataV2
        /// The type of the match.
        public let matchType: Files.SearchMatchTypeV2?
        /// The list of HighlightSpan determines which parts of the file title should be highlighted.
        public let highlightSpans: Array<Files.HighlightSpan>?
        public init(metadata: Files.MetadataV2, matchType: Files.SearchMatchTypeV2? = nil, highlightSpans: Array<Files.HighlightSpan>? = nil) {
            self.metadata = metadata
            self.matchType = matchType
            self.highlightSpans = highlightSpans
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SearchMatchV2Serializer().serialize(self)))"
        }
    }
    open class SearchMatchV2Serializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SearchMatchV2) -> JSON {
            let output = [ 
            "metadata": Files.MetadataV2Serializer().serialize(value.metadata),
            "match_type": NullableSerializer(Files.SearchMatchTypeV2Serializer()).serialize(value.matchType),
            "highlight_spans": NullableSerializer(ArraySerializer(Files.HighlightSpanSerializer())).serialize(value.highlightSpans),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SearchMatchV2 {
            switch json {
                case .dictionary(let dict):
                    let metadata = Files.MetadataV2Serializer().deserialize(dict["metadata"] ?? .null)
                    let matchType = NullableSerializer(Files.SearchMatchTypeV2Serializer()).deserialize(dict["match_type"] ?? .null)
                    let highlightSpans = NullableSerializer(ArraySerializer(Files.HighlightSpanSerializer())).deserialize(dict["highlight_spans"] ?? .null)
                    return SearchMatchV2(metadata: metadata, matchType: matchType, highlightSpans: highlightSpans)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The SearchMode union
    public enum SearchMode: CustomStringConvertible {
        /// Search file and folder names.
        case filename
        /// Search file and folder names as well as file contents.
        case filenameAndContent
        /// Search for deleted file and folder names.
        case deletedFilename

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SearchModeSerializer().serialize(self)))"
        }
    }
    open class SearchModeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SearchMode) -> JSON {
            switch value {
                case .filename:
                    var d = [String: JSON]()
                    d[".tag"] = .str("filename")
                    return .dictionary(d)
                case .filenameAndContent:
                    var d = [String: JSON]()
                    d[".tag"] = .str("filename_and_content")
                    return .dictionary(d)
                case .deletedFilename:
                    var d = [String: JSON]()
                    d[".tag"] = .str("deleted_filename")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> SearchMode {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "filename":
                            return SearchMode.filename
                        case "filename_and_content":
                            return SearchMode.filenameAndContent
                        case "deleted_filename":
                            return SearchMode.deletedFilename
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The SearchOptions struct
    open class SearchOptions: CustomStringConvertible {
        /// Scopes the search to a path in the user's Dropbox. Searches the entire Dropbox if not specified.
        public let path: String?
        /// The maximum number of search results to return.
        public let maxResults: UInt64
        /// Specified property of the order of search results. By default, results are sorted by relevance.
        public let orderBy: Files.SearchOrderBy?
        /// Restricts search to the given file status.
        public let fileStatus: Files.FileStatus
        /// Restricts search to only match on filenames.
        public let filenameOnly: Bool
        /// Restricts search to only the extensions specified. Only supported for active file search.
        public let fileExtensions: Array<String>?
        /// Restricts search to only the file categories specified. Only supported for active file search.
        public let fileCategories: Array<Files.FileCategory>?
        public init(path: String? = nil, maxResults: UInt64 = 100, orderBy: Files.SearchOrderBy? = nil, fileStatus: Files.FileStatus = .active, filenameOnly: Bool = false, fileExtensions: Array<String>? = nil, fileCategories: Array<Files.FileCategory>? = nil) {
            nullableValidator(stringValidator(pattern: "(/(.|[\\r\\n])*)?|id:.*|(ns:[0-9]+(/.*)?)"))(path)
            self.path = path
            comparableValidator(minValue: 1, maxValue: 1000)(maxResults)
            self.maxResults = maxResults
            self.orderBy = orderBy
            self.fileStatus = fileStatus
            self.filenameOnly = filenameOnly
            nullableValidator(arrayValidator(itemValidator: stringValidator()))(fileExtensions)
            self.fileExtensions = fileExtensions
            self.fileCategories = fileCategories
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SearchOptionsSerializer().serialize(self)))"
        }
    }
    open class SearchOptionsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SearchOptions) -> JSON {
            let output = [ 
            "path": NullableSerializer(Serialization._StringSerializer).serialize(value.path),
            "max_results": Serialization._UInt64Serializer.serialize(value.maxResults),
            "order_by": NullableSerializer(Files.SearchOrderBySerializer()).serialize(value.orderBy),
            "file_status": Files.FileStatusSerializer().serialize(value.fileStatus),
            "filename_only": Serialization._BoolSerializer.serialize(value.filenameOnly),
            "file_extensions": NullableSerializer(ArraySerializer(Serialization._StringSerializer)).serialize(value.fileExtensions),
            "file_categories": NullableSerializer(ArraySerializer(Files.FileCategorySerializer())).serialize(value.fileCategories),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SearchOptions {
            switch json {
                case .dictionary(let dict):
                    let path = NullableSerializer(Serialization._StringSerializer).deserialize(dict["path"] ?? .null)
                    let maxResults = Serialization._UInt64Serializer.deserialize(dict["max_results"] ?? .number(100))
                    let orderBy = NullableSerializer(Files.SearchOrderBySerializer()).deserialize(dict["order_by"] ?? .null)
                    let fileStatus = Files.FileStatusSerializer().deserialize(dict["file_status"] ?? Files.FileStatusSerializer().serialize(.active))
                    let filenameOnly = Serialization._BoolSerializer.deserialize(dict["filename_only"] ?? .number(0))
                    let fileExtensions = NullableSerializer(ArraySerializer(Serialization._StringSerializer)).deserialize(dict["file_extensions"] ?? .null)
                    let fileCategories = NullableSerializer(ArraySerializer(Files.FileCategorySerializer())).deserialize(dict["file_categories"] ?? .null)
                    return SearchOptions(path: path, maxResults: maxResults, orderBy: orderBy, fileStatus: fileStatus, filenameOnly: filenameOnly, fileExtensions: fileExtensions, fileCategories: fileCategories)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The SearchOrderBy union
    public enum SearchOrderBy: CustomStringConvertible {
        /// An unspecified error.
        case relevance
        /// An unspecified error.
        case lastModifiedTime
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SearchOrderBySerializer().serialize(self)))"
        }
    }
    open class SearchOrderBySerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SearchOrderBy) -> JSON {
            switch value {
                case .relevance:
                    var d = [String: JSON]()
                    d[".tag"] = .str("relevance")
                    return .dictionary(d)
                case .lastModifiedTime:
                    var d = [String: JSON]()
                    d[".tag"] = .str("last_modified_time")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> SearchOrderBy {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "relevance":
                            return SearchOrderBy.relevance
                        case "last_modified_time":
                            return SearchOrderBy.lastModifiedTime
                        case "other":
                            return SearchOrderBy.other
                        default:
                            return SearchOrderBy.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The SearchResult struct
    open class SearchResult: CustomStringConvertible {
        /// A list (possibly empty) of matches for the query.
        public let matches: Array<Files.SearchMatch>
        /// Used for paging. If true, indicates there is another page of results available that can be fetched by
        /// calling search again.
        public let more: Bool
        /// Used for paging. Value to set the start argument to when calling search to fetch the next page of results.
        public let start: UInt64
        public init(matches: Array<Files.SearchMatch>, more: Bool, start: UInt64) {
            self.matches = matches
            self.more = more
            comparableValidator()(start)
            self.start = start
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SearchResultSerializer().serialize(self)))"
        }
    }
    open class SearchResultSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SearchResult) -> JSON {
            let output = [ 
            "matches": ArraySerializer(Files.SearchMatchSerializer()).serialize(value.matches),
            "more": Serialization._BoolSerializer.serialize(value.more),
            "start": Serialization._UInt64Serializer.serialize(value.start),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SearchResult {
            switch json {
                case .dictionary(let dict):
                    let matches = ArraySerializer(Files.SearchMatchSerializer()).deserialize(dict["matches"] ?? .null)
                    let more = Serialization._BoolSerializer.deserialize(dict["more"] ?? .null)
                    let start = Serialization._UInt64Serializer.deserialize(dict["start"] ?? .null)
                    return SearchResult(matches: matches, more: more, start: start)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The SearchV2Arg struct
    open class SearchV2Arg: CustomStringConvertible {
        /// The string to search for. May match across multiple fields based on the request arguments.
        public let query: String
        /// Options for more targeted search results.
        public let options: Files.SearchOptions?
        /// Options for search results match fields.
        public let matchFieldOptions: Files.SearchMatchFieldOptions?
        /// Deprecated and moved this option to SearchMatchFieldOptions.
        public let includeHighlights: Bool?
        public init(query: String, options: Files.SearchOptions? = nil, matchFieldOptions: Files.SearchMatchFieldOptions? = nil, includeHighlights: Bool? = nil) {
            stringValidator(maxLength: 1000)(query)
            self.query = query
            self.options = options
            self.matchFieldOptions = matchFieldOptions
            self.includeHighlights = includeHighlights
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SearchV2ArgSerializer().serialize(self)))"
        }
    }
    open class SearchV2ArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SearchV2Arg) -> JSON {
            let output = [ 
            "query": Serialization._StringSerializer.serialize(value.query),
            "options": NullableSerializer(Files.SearchOptionsSerializer()).serialize(value.options),
            "match_field_options": NullableSerializer(Files.SearchMatchFieldOptionsSerializer()).serialize(value.matchFieldOptions),
            "include_highlights": NullableSerializer(Serialization._BoolSerializer).serialize(value.includeHighlights),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SearchV2Arg {
            switch json {
                case .dictionary(let dict):
                    let query = Serialization._StringSerializer.deserialize(dict["query"] ?? .null)
                    let options = NullableSerializer(Files.SearchOptionsSerializer()).deserialize(dict["options"] ?? .null)
                    let matchFieldOptions = NullableSerializer(Files.SearchMatchFieldOptionsSerializer()).deserialize(dict["match_field_options"] ?? .null)
                    let includeHighlights = NullableSerializer(Serialization._BoolSerializer).deserialize(dict["include_highlights"] ?? .null)
                    return SearchV2Arg(query: query, options: options, matchFieldOptions: matchFieldOptions, includeHighlights: includeHighlights)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The SearchV2ContinueArg struct
    open class SearchV2ContinueArg: CustomStringConvertible {
        /// The cursor returned by your last call to searchV2. Used to fetch the next page of results.
        public let cursor: String
        public init(cursor: String) {
            stringValidator(minLength: 1)(cursor)
            self.cursor = cursor
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SearchV2ContinueArgSerializer().serialize(self)))"
        }
    }
    open class SearchV2ContinueArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SearchV2ContinueArg) -> JSON {
            let output = [ 
            "cursor": Serialization._StringSerializer.serialize(value.cursor),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SearchV2ContinueArg {
            switch json {
                case .dictionary(let dict):
                    let cursor = Serialization._StringSerializer.deserialize(dict["cursor"] ?? .null)
                    return SearchV2ContinueArg(cursor: cursor)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The SearchV2Result struct
    open class SearchV2Result: CustomStringConvertible {
        /// A list (possibly empty) of matches for the query.
        public let matches: Array<Files.SearchMatchV2>
        /// Used for paging. If true, indicates there is another page of results available that can be fetched by
        /// calling searchContinueV2 with the cursor.
        public let hasMore: Bool
        /// Pass the cursor into searchContinueV2 to fetch the next page of results.
        public let cursor: String?
        public init(matches: Array<Files.SearchMatchV2>, hasMore: Bool, cursor: String? = nil) {
            self.matches = matches
            self.hasMore = hasMore
            nullableValidator(stringValidator(minLength: 1))(cursor)
            self.cursor = cursor
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SearchV2ResultSerializer().serialize(self)))"
        }
    }
    open class SearchV2ResultSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SearchV2Result) -> JSON {
            let output = [ 
            "matches": ArraySerializer(Files.SearchMatchV2Serializer()).serialize(value.matches),
            "has_more": Serialization._BoolSerializer.serialize(value.hasMore),
            "cursor": NullableSerializer(Serialization._StringSerializer).serialize(value.cursor),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SearchV2Result {
            switch json {
                case .dictionary(let dict):
                    let matches = ArraySerializer(Files.SearchMatchV2Serializer()).deserialize(dict["matches"] ?? .null)
                    let hasMore = Serialization._BoolSerializer.deserialize(dict["has_more"] ?? .null)
                    let cursor = NullableSerializer(Serialization._StringSerializer).deserialize(dict["cursor"] ?? .null)
                    return SearchV2Result(matches: matches, hasMore: hasMore, cursor: cursor)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The SharedLink struct
    open class SharedLink: CustomStringConvertible {
        /// Shared link url.
        public let url: String
        /// Password for the shared link.
        public let password: String?
        public init(url: String, password: String? = nil) {
            stringValidator()(url)
            self.url = url
            nullableValidator(stringValidator())(password)
            self.password = password
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharedLinkSerializer().serialize(self)))"
        }
    }
    open class SharedLinkSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SharedLink) -> JSON {
            let output = [ 
            "url": Serialization._StringSerializer.serialize(value.url),
            "password": NullableSerializer(Serialization._StringSerializer).serialize(value.password),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SharedLink {
            switch json {
                case .dictionary(let dict):
                    let url = Serialization._StringSerializer.deserialize(dict["url"] ?? .null)
                    let password = NullableSerializer(Serialization._StringSerializer).deserialize(dict["password"] ?? .null)
                    return SharedLink(url: url, password: password)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The SharedLinkFileInfo struct
    open class SharedLinkFileInfo: CustomStringConvertible {
        /// The shared link corresponding to either a file or shared link to a folder. If it is for a folder shared
        /// link, we use the path param to determine for which file in the folder the view is for.
        public let url: String
        /// The path corresponding to a file in a shared link to a folder. Required for shared links to folders.
        public let path: String?
        /// Password for the shared link. Required for password-protected shared links to files  unless it can be read
        /// from a cookie.
        public let password: String?
        public init(url: String, path: String? = nil, password: String? = nil) {
            stringValidator()(url)
            self.url = url
            nullableValidator(stringValidator())(path)
            self.path = path
            nullableValidator(stringValidator())(password)
            self.password = password
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SharedLinkFileInfoSerializer().serialize(self)))"
        }
    }
    open class SharedLinkFileInfoSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SharedLinkFileInfo) -> JSON {
            let output = [ 
            "url": Serialization._StringSerializer.serialize(value.url),
            "path": NullableSerializer(Serialization._StringSerializer).serialize(value.path),
            "password": NullableSerializer(Serialization._StringSerializer).serialize(value.password),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SharedLinkFileInfo {
            switch json {
                case .dictionary(let dict):
                    let url = Serialization._StringSerializer.deserialize(dict["url"] ?? .null)
                    let path = NullableSerializer(Serialization._StringSerializer).deserialize(dict["path"] ?? .null)
                    let password = NullableSerializer(Serialization._StringSerializer).deserialize(dict["password"] ?? .null)
                    return SharedLinkFileInfo(url: url, path: path, password: password)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The SingleUserLock struct
    open class SingleUserLock: CustomStringConvertible {
        /// The time the lock was created.
        public let created: Date
        /// The account ID of the lock holder if known.
        public let lockHolderAccountId: String
        /// The id of the team of the account holder if it exists.
        public let lockHolderTeamId: String?
        public init(created: Date, lockHolderAccountId: String, lockHolderTeamId: String? = nil) {
            self.created = created
            stringValidator(minLength: 40, maxLength: 40)(lockHolderAccountId)
            self.lockHolderAccountId = lockHolderAccountId
            nullableValidator(stringValidator())(lockHolderTeamId)
            self.lockHolderTeamId = lockHolderTeamId
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SingleUserLockSerializer().serialize(self)))"
        }
    }
    open class SingleUserLockSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SingleUserLock) -> JSON {
            let output = [ 
            "created": NSDateSerializer("%Y-%m-%dT%H:%M:%SZ").serialize(value.created),
            "lock_holder_account_id": Serialization._StringSerializer.serialize(value.lockHolderAccountId),
            "lock_holder_team_id": NullableSerializer(Serialization._StringSerializer).serialize(value.lockHolderTeamId),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SingleUserLock {
            switch json {
                case .dictionary(let dict):
                    let created = NSDateSerializer("%Y-%m-%dT%H:%M:%SZ").deserialize(dict["created"] ?? .null)
                    let lockHolderAccountId = Serialization._StringSerializer.deserialize(dict["lock_holder_account_id"] ?? .null)
                    let lockHolderTeamId = NullableSerializer(Serialization._StringSerializer).deserialize(dict["lock_holder_team_id"] ?? .null)
                    return SingleUserLock(created: created, lockHolderAccountId: lockHolderAccountId, lockHolderTeamId: lockHolderTeamId)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The SymlinkInfo struct
    open class SymlinkInfo: CustomStringConvertible {
        /// The target this symlink points to.
        public let target: String
        public init(target: String) {
            stringValidator()(target)
            self.target = target
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SymlinkInfoSerializer().serialize(self)))"
        }
    }
    open class SymlinkInfoSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SymlinkInfo) -> JSON {
            let output = [ 
            "target": Serialization._StringSerializer.serialize(value.target),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SymlinkInfo {
            switch json {
                case .dictionary(let dict):
                    let target = Serialization._StringSerializer.deserialize(dict["target"] ?? .null)
                    return SymlinkInfo(target: target)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The SyncSetting union
    public enum SyncSetting: CustomStringConvertible {
        /// On first sync to members' computers, the specified folder will follow its parent folder's setting or
        /// otherwise follow default sync behavior.
        case default_
        /// On first sync to members' computers, the specified folder will be set to not sync with selective sync.
        case notSynced
        /// The specified folder's not_synced setting is inactive due to its location or other configuration changes. It
        /// will follow its parent folder's setting.
        case notSyncedInactive
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SyncSettingSerializer().serialize(self)))"
        }
    }
    open class SyncSettingSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SyncSetting) -> JSON {
            switch value {
                case .default_:
                    var d = [String: JSON]()
                    d[".tag"] = .str("default")
                    return .dictionary(d)
                case .notSynced:
                    var d = [String: JSON]()
                    d[".tag"] = .str("not_synced")
                    return .dictionary(d)
                case .notSyncedInactive:
                    var d = [String: JSON]()
                    d[".tag"] = .str("not_synced_inactive")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> SyncSetting {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "default":
                            return SyncSetting.default_
                        case "not_synced":
                            return SyncSetting.notSynced
                        case "not_synced_inactive":
                            return SyncSetting.notSyncedInactive
                        case "other":
                            return SyncSetting.other
                        default:
                            return SyncSetting.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The SyncSettingArg union
    public enum SyncSettingArg: CustomStringConvertible {
        /// On first sync to members' computers, the specified folder will follow its parent folder's setting or
        /// otherwise follow default sync behavior.
        case default_
        /// On first sync to members' computers, the specified folder will be set to not sync with selective sync.
        case notSynced
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SyncSettingArgSerializer().serialize(self)))"
        }
    }
    open class SyncSettingArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SyncSettingArg) -> JSON {
            switch value {
                case .default_:
                    var d = [String: JSON]()
                    d[".tag"] = .str("default")
                    return .dictionary(d)
                case .notSynced:
                    var d = [String: JSON]()
                    d[".tag"] = .str("not_synced")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> SyncSettingArg {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "default":
                            return SyncSettingArg.default_
                        case "not_synced":
                            return SyncSettingArg.notSynced
                        case "other":
                            return SyncSettingArg.other
                        default:
                            return SyncSettingArg.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The SyncSettingsError union
    public enum SyncSettingsError: CustomStringConvertible {
        /// An unspecified error.
        case path(Files.LookupError)
        /// Setting this combination of sync settings simultaneously is not supported.
        case unsupportedCombination
        /// The specified configuration is not supported.
        case unsupportedConfiguration
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SyncSettingsErrorSerializer().serialize(self)))"
        }
    }
    open class SyncSettingsErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SyncSettingsError) -> JSON {
            switch value {
                case .path(let arg):
                    var d = ["path": Files.LookupErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("path")
                    return .dictionary(d)
                case .unsupportedCombination:
                    var d = [String: JSON]()
                    d[".tag"] = .str("unsupported_combination")
                    return .dictionary(d)
                case .unsupportedConfiguration:
                    var d = [String: JSON]()
                    d[".tag"] = .str("unsupported_configuration")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> SyncSettingsError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "path":
                            let v = Files.LookupErrorSerializer().deserialize(d["path"] ?? .null)
                            return SyncSettingsError.path(v)
                        case "unsupported_combination":
                            return SyncSettingsError.unsupportedCombination
                        case "unsupported_configuration":
                            return SyncSettingsError.unsupportedConfiguration
                        case "other":
                            return SyncSettingsError.other
                        default:
                            return SyncSettingsError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The ThumbnailArg struct
    open class ThumbnailArg: CustomStringConvertible {
        /// The path to the image file you want to thumbnail.
        public let path: String
        /// The format for the thumbnail image, jpeg (default) or png. For  images that are photos, jpeg should be
        /// preferred, while png is  better for screenshots and digital arts.
        public let format: Files.ThumbnailFormat
        /// The size for the thumbnail image.
        public let size: Files.ThumbnailSize
        /// How to resize and crop the image to achieve the desired size.
        public let mode: Files.ThumbnailMode
        public init(path: String, format: Files.ThumbnailFormat = .jpeg, size: Files.ThumbnailSize = .w64h64, mode: Files.ThumbnailMode = .strict) {
            stringValidator(pattern: "(/(.|[\\r\\n])*|id:.*)|(rev:[0-9a-f]{9,})|(ns:[0-9]+(/.*)?)")(path)
            self.path = path
            self.format = format
            self.size = size
            self.mode = mode
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ThumbnailArgSerializer().serialize(self)))"
        }
    }
    open class ThumbnailArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ThumbnailArg) -> JSON {
            let output = [ 
            "path": Serialization._StringSerializer.serialize(value.path),
            "format": Files.ThumbnailFormatSerializer().serialize(value.format),
            "size": Files.ThumbnailSizeSerializer().serialize(value.size),
            "mode": Files.ThumbnailModeSerializer().serialize(value.mode),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ThumbnailArg {
            switch json {
                case .dictionary(let dict):
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .null)
                    let format = Files.ThumbnailFormatSerializer().deserialize(dict["format"] ?? Files.ThumbnailFormatSerializer().serialize(.jpeg))
                    let size = Files.ThumbnailSizeSerializer().deserialize(dict["size"] ?? Files.ThumbnailSizeSerializer().serialize(.w64h64))
                    let mode = Files.ThumbnailModeSerializer().deserialize(dict["mode"] ?? Files.ThumbnailModeSerializer().serialize(.strict))
                    return ThumbnailArg(path: path, format: format, size: size, mode: mode)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The ThumbnailError union
    public enum ThumbnailError: CustomStringConvertible {
        /// An error occurs when downloading metadata for the image.
        case path(Files.LookupError)
        /// The file extension doesn't allow conversion to a thumbnail.
        case unsupportedExtension
        /// The image cannot be converted to a thumbnail.
        case unsupportedImage
        /// An error occurs during thumbnail conversion.
        case conversionError

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ThumbnailErrorSerializer().serialize(self)))"
        }
    }
    open class ThumbnailErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ThumbnailError) -> JSON {
            switch value {
                case .path(let arg):
                    var d = ["path": Files.LookupErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("path")
                    return .dictionary(d)
                case .unsupportedExtension:
                    var d = [String: JSON]()
                    d[".tag"] = .str("unsupported_extension")
                    return .dictionary(d)
                case .unsupportedImage:
                    var d = [String: JSON]()
                    d[".tag"] = .str("unsupported_image")
                    return .dictionary(d)
                case .conversionError:
                    var d = [String: JSON]()
                    d[".tag"] = .str("conversion_error")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> ThumbnailError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "path":
                            let v = Files.LookupErrorSerializer().deserialize(d["path"] ?? .null)
                            return ThumbnailError.path(v)
                        case "unsupported_extension":
                            return ThumbnailError.unsupportedExtension
                        case "unsupported_image":
                            return ThumbnailError.unsupportedImage
                        case "conversion_error":
                            return ThumbnailError.conversionError
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The ThumbnailFormat union
    public enum ThumbnailFormat: CustomStringConvertible {
        /// An unspecified error.
        case jpeg
        /// An unspecified error.
        case png

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ThumbnailFormatSerializer().serialize(self)))"
        }
    }
    open class ThumbnailFormatSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ThumbnailFormat) -> JSON {
            switch value {
                case .jpeg:
                    var d = [String: JSON]()
                    d[".tag"] = .str("jpeg")
                    return .dictionary(d)
                case .png:
                    var d = [String: JSON]()
                    d[".tag"] = .str("png")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> ThumbnailFormat {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "jpeg":
                            return ThumbnailFormat.jpeg
                        case "png":
                            return ThumbnailFormat.png
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The ThumbnailMode union
    public enum ThumbnailMode: CustomStringConvertible {
        /// Scale down the image to fit within the given size.
        case strict
        /// Scale down the image to fit within the given size or its transpose.
        case bestfit
        /// Scale down the image to completely cover the given size or its transpose.
        case fitoneBestfit

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ThumbnailModeSerializer().serialize(self)))"
        }
    }
    open class ThumbnailModeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ThumbnailMode) -> JSON {
            switch value {
                case .strict:
                    var d = [String: JSON]()
                    d[".tag"] = .str("strict")
                    return .dictionary(d)
                case .bestfit:
                    var d = [String: JSON]()
                    d[".tag"] = .str("bestfit")
                    return .dictionary(d)
                case .fitoneBestfit:
                    var d = [String: JSON]()
                    d[".tag"] = .str("fitone_bestfit")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> ThumbnailMode {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "strict":
                            return ThumbnailMode.strict
                        case "bestfit":
                            return ThumbnailMode.bestfit
                        case "fitone_bestfit":
                            return ThumbnailMode.fitoneBestfit
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The ThumbnailSize union
    public enum ThumbnailSize: CustomStringConvertible {
        /// 32 by 32 px.
        case w32h32
        /// 64 by 64 px.
        case w64h64
        /// 128 by 128 px.
        case w128h128
        /// 256 by 256 px.
        case w256h256
        /// 480 by 320 px.
        case w480h320
        /// 640 by 480 px.
        case w640h480
        /// 960 by 640 px.
        case w960h640
        /// 1024 by 768 px.
        case w1024h768
        /// 2048 by 1536 px.
        case w2048h1536

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ThumbnailSizeSerializer().serialize(self)))"
        }
    }
    open class ThumbnailSizeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ThumbnailSize) -> JSON {
            switch value {
                case .w32h32:
                    var d = [String: JSON]()
                    d[".tag"] = .str("w32h32")
                    return .dictionary(d)
                case .w64h64:
                    var d = [String: JSON]()
                    d[".tag"] = .str("w64h64")
                    return .dictionary(d)
                case .w128h128:
                    var d = [String: JSON]()
                    d[".tag"] = .str("w128h128")
                    return .dictionary(d)
                case .w256h256:
                    var d = [String: JSON]()
                    d[".tag"] = .str("w256h256")
                    return .dictionary(d)
                case .w480h320:
                    var d = [String: JSON]()
                    d[".tag"] = .str("w480h320")
                    return .dictionary(d)
                case .w640h480:
                    var d = [String: JSON]()
                    d[".tag"] = .str("w640h480")
                    return .dictionary(d)
                case .w960h640:
                    var d = [String: JSON]()
                    d[".tag"] = .str("w960h640")
                    return .dictionary(d)
                case .w1024h768:
                    var d = [String: JSON]()
                    d[".tag"] = .str("w1024h768")
                    return .dictionary(d)
                case .w2048h1536:
                    var d = [String: JSON]()
                    d[".tag"] = .str("w2048h1536")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> ThumbnailSize {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "w32h32":
                            return ThumbnailSize.w32h32
                        case "w64h64":
                            return ThumbnailSize.w64h64
                        case "w128h128":
                            return ThumbnailSize.w128h128
                        case "w256h256":
                            return ThumbnailSize.w256h256
                        case "w480h320":
                            return ThumbnailSize.w480h320
                        case "w640h480":
                            return ThumbnailSize.w640h480
                        case "w960h640":
                            return ThumbnailSize.w960h640
                        case "w1024h768":
                            return ThumbnailSize.w1024h768
                        case "w2048h1536":
                            return ThumbnailSize.w2048h1536
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The ThumbnailV2Arg struct
    open class ThumbnailV2Arg: CustomStringConvertible {
        /// Information specifying which file to preview. This could be a path to a file, a shared link pointing to a
        /// file, or a shared link pointing to a folder, with a relative path.
        public let resource: Files.PathOrLink
        /// The format for the thumbnail image, jpeg (default) or png. For  images that are photos, jpeg should be
        /// preferred, while png is  better for screenshots and digital arts.
        public let format: Files.ThumbnailFormat
        /// The size for the thumbnail image.
        public let size: Files.ThumbnailSize
        /// How to resize and crop the image to achieve the desired size.
        public let mode: Files.ThumbnailMode
        public init(resource: Files.PathOrLink, format: Files.ThumbnailFormat = .jpeg, size: Files.ThumbnailSize = .w64h64, mode: Files.ThumbnailMode = .strict) {
            self.resource = resource
            self.format = format
            self.size = size
            self.mode = mode
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ThumbnailV2ArgSerializer().serialize(self)))"
        }
    }
    open class ThumbnailV2ArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ThumbnailV2Arg) -> JSON {
            let output = [ 
            "resource": Files.PathOrLinkSerializer().serialize(value.resource),
            "format": Files.ThumbnailFormatSerializer().serialize(value.format),
            "size": Files.ThumbnailSizeSerializer().serialize(value.size),
            "mode": Files.ThumbnailModeSerializer().serialize(value.mode),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ThumbnailV2Arg {
            switch json {
                case .dictionary(let dict):
                    let resource = Files.PathOrLinkSerializer().deserialize(dict["resource"] ?? .null)
                    let format = Files.ThumbnailFormatSerializer().deserialize(dict["format"] ?? Files.ThumbnailFormatSerializer().serialize(.jpeg))
                    let size = Files.ThumbnailSizeSerializer().deserialize(dict["size"] ?? Files.ThumbnailSizeSerializer().serialize(.w64h64))
                    let mode = Files.ThumbnailModeSerializer().deserialize(dict["mode"] ?? Files.ThumbnailModeSerializer().serialize(.strict))
                    return ThumbnailV2Arg(resource: resource, format: format, size: size, mode: mode)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The ThumbnailV2Error union
    public enum ThumbnailV2Error: CustomStringConvertible {
        /// An error occurred when downloading metadata for the image.
        case path(Files.LookupError)
        /// The file extension doesn't allow conversion to a thumbnail.
        case unsupportedExtension
        /// The image cannot be converted to a thumbnail.
        case unsupportedImage
        /// An error occurred during thumbnail conversion.
        case conversionError
        /// Access to this shared link is forbidden.
        case accessDenied
        /// The shared link does not exist.
        case notFound
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ThumbnailV2ErrorSerializer().serialize(self)))"
        }
    }
    open class ThumbnailV2ErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ThumbnailV2Error) -> JSON {
            switch value {
                case .path(let arg):
                    var d = ["path": Files.LookupErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("path")
                    return .dictionary(d)
                case .unsupportedExtension:
                    var d = [String: JSON]()
                    d[".tag"] = .str("unsupported_extension")
                    return .dictionary(d)
                case .unsupportedImage:
                    var d = [String: JSON]()
                    d[".tag"] = .str("unsupported_image")
                    return .dictionary(d)
                case .conversionError:
                    var d = [String: JSON]()
                    d[".tag"] = .str("conversion_error")
                    return .dictionary(d)
                case .accessDenied:
                    var d = [String: JSON]()
                    d[".tag"] = .str("access_denied")
                    return .dictionary(d)
                case .notFound:
                    var d = [String: JSON]()
                    d[".tag"] = .str("not_found")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> ThumbnailV2Error {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "path":
                            let v = Files.LookupErrorSerializer().deserialize(d["path"] ?? .null)
                            return ThumbnailV2Error.path(v)
                        case "unsupported_extension":
                            return ThumbnailV2Error.unsupportedExtension
                        case "unsupported_image":
                            return ThumbnailV2Error.unsupportedImage
                        case "conversion_error":
                            return ThumbnailV2Error.conversionError
                        case "access_denied":
                            return ThumbnailV2Error.accessDenied
                        case "not_found":
                            return ThumbnailV2Error.notFound
                        case "other":
                            return ThumbnailV2Error.other
                        default:
                            return ThumbnailV2Error.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The UnlockFileArg struct
    open class UnlockFileArg: CustomStringConvertible {
        /// Path in the user's Dropbox to a file.
        public let path: String
        public init(path: String) {
            stringValidator(pattern: "(/(.|[\\r\\n])*)|(ns:[0-9]+(/.*)?)|(id:.*)")(path)
            self.path = path
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(UnlockFileArgSerializer().serialize(self)))"
        }
    }
    open class UnlockFileArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: UnlockFileArg) -> JSON {
            let output = [ 
            "path": Serialization._StringSerializer.serialize(value.path),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> UnlockFileArg {
            switch json {
                case .dictionary(let dict):
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .null)
                    return UnlockFileArg(path: path)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The UnlockFileBatchArg struct
    open class UnlockFileBatchArg: CustomStringConvertible {
        /// List of 'entries'. Each 'entry' contains a path of the file which will be unlocked. Duplicate path arguments
        /// in the batch are considered only once.
        public let entries: Array<Files.UnlockFileArg>
        public init(entries: Array<Files.UnlockFileArg>) {
            self.entries = entries
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(UnlockFileBatchArgSerializer().serialize(self)))"
        }
    }
    open class UnlockFileBatchArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: UnlockFileBatchArg) -> JSON {
            let output = [ 
            "entries": ArraySerializer(Files.UnlockFileArgSerializer()).serialize(value.entries),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> UnlockFileBatchArg {
            switch json {
                case .dictionary(let dict):
                    let entries = ArraySerializer(Files.UnlockFileArgSerializer()).deserialize(dict["entries"] ?? .null)
                    return UnlockFileBatchArg(entries: entries)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The UploadError union
    public enum UploadError: CustomStringConvertible {
        /// Unable to save the uploaded contents to a file.
        case path(Files.UploadWriteFailed)
        /// The supplied property group is invalid. The file has uploaded without property groups.
        case propertiesError(FileProperties.InvalidPropertyGroupError)
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(UploadErrorSerializer().serialize(self)))"
        }
    }
    open class UploadErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: UploadError) -> JSON {
            switch value {
                case .path(let arg):
                    var d = Serialization.getFields(Files.UploadWriteFailedSerializer().serialize(arg))
                    d[".tag"] = .str("path")
                    return .dictionary(d)
                case .propertiesError(let arg):
                    var d = ["properties_error": FileProperties.InvalidPropertyGroupErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("properties_error")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> UploadError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "path":
                            let v = Files.UploadWriteFailedSerializer().deserialize(json)
                            return UploadError.path(v)
                        case "properties_error":
                            let v = FileProperties.InvalidPropertyGroupErrorSerializer().deserialize(d["properties_error"] ?? .null)
                            return UploadError.propertiesError(v)
                        case "other":
                            return UploadError.other
                        default:
                            return UploadError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The UploadErrorWithProperties union
    public enum UploadErrorWithProperties: CustomStringConvertible {
        /// Unable to save the uploaded contents to a file.
        case path(Files.UploadWriteFailed)
        /// The supplied property group is invalid. The file has uploaded without property groups.
        case propertiesError(FileProperties.InvalidPropertyGroupError)
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(UploadErrorWithPropertiesSerializer().serialize(self)))"
        }
    }
    open class UploadErrorWithPropertiesSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: UploadErrorWithProperties) -> JSON {
            switch value {
                case .path(let arg):
                    var d = Serialization.getFields(Files.UploadWriteFailedSerializer().serialize(arg))
                    d[".tag"] = .str("path")
                    return .dictionary(d)
                case .propertiesError(let arg):
                    var d = ["properties_error": FileProperties.InvalidPropertyGroupErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("properties_error")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> UploadErrorWithProperties {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "path":
                            let v = Files.UploadWriteFailedSerializer().deserialize(json)
                            return UploadErrorWithProperties.path(v)
                        case "properties_error":
                            let v = FileProperties.InvalidPropertyGroupErrorSerializer().deserialize(d["properties_error"] ?? .null)
                            return UploadErrorWithProperties.propertiesError(v)
                        case "other":
                            return UploadErrorWithProperties.other
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The UploadSessionAppendArg struct
    open class UploadSessionAppendArg: CustomStringConvertible {
        /// Contains the upload session ID and the offset.
        public let cursor: Files.UploadSessionCursor
        /// If true, the current session will be closed, at which point you won't be able to call uploadSessionAppendV2
        /// anymore with the current session.
        public let close: Bool
        public init(cursor: Files.UploadSessionCursor, close: Bool = false) {
            self.cursor = cursor
            self.close = close
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(UploadSessionAppendArgSerializer().serialize(self)))"
        }
    }
    open class UploadSessionAppendArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: UploadSessionAppendArg) -> JSON {
            let output = [ 
            "cursor": Files.UploadSessionCursorSerializer().serialize(value.cursor),
            "close": Serialization._BoolSerializer.serialize(value.close),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> UploadSessionAppendArg {
            switch json {
                case .dictionary(let dict):
                    let cursor = Files.UploadSessionCursorSerializer().deserialize(dict["cursor"] ?? .null)
                    let close = Serialization._BoolSerializer.deserialize(dict["close"] ?? .number(0))
                    return UploadSessionAppendArg(cursor: cursor, close: close)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The UploadSessionCursor struct
    open class UploadSessionCursor: CustomStringConvertible {
        /// The upload session ID (returned by uploadSessionStart).
        public let sessionId: String
        /// Offset in bytes at which data should be appended. We use this to make sure upload data isn't lost or
        /// duplicated in the event of a network error.
        public let offset: UInt64
        public init(sessionId: String, offset: UInt64) {
            stringValidator()(sessionId)
            self.sessionId = sessionId
            comparableValidator()(offset)
            self.offset = offset
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(UploadSessionCursorSerializer().serialize(self)))"
        }
    }
    open class UploadSessionCursorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: UploadSessionCursor) -> JSON {
            let output = [ 
            "session_id": Serialization._StringSerializer.serialize(value.sessionId),
            "offset": Serialization._UInt64Serializer.serialize(value.offset),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> UploadSessionCursor {
            switch json {
                case .dictionary(let dict):
                    let sessionId = Serialization._StringSerializer.deserialize(dict["session_id"] ?? .null)
                    let offset = Serialization._UInt64Serializer.deserialize(dict["offset"] ?? .null)
                    return UploadSessionCursor(sessionId: sessionId, offset: offset)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The UploadSessionFinishArg struct
    open class UploadSessionFinishArg: CustomStringConvertible {
        /// Contains the upload session ID and the offset.
        public let cursor: Files.UploadSessionCursor
        /// Contains the path and other optional modifiers for the commit.
        public let commit: Files.CommitInfo
        public init(cursor: Files.UploadSessionCursor, commit: Files.CommitInfo) {
            self.cursor = cursor
            self.commit = commit
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(UploadSessionFinishArgSerializer().serialize(self)))"
        }
    }
    open class UploadSessionFinishArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: UploadSessionFinishArg) -> JSON {
            let output = [ 
            "cursor": Files.UploadSessionCursorSerializer().serialize(value.cursor),
            "commit": Files.CommitInfoSerializer().serialize(value.commit),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> UploadSessionFinishArg {
            switch json {
                case .dictionary(let dict):
                    let cursor = Files.UploadSessionCursorSerializer().deserialize(dict["cursor"] ?? .null)
                    let commit = Files.CommitInfoSerializer().deserialize(dict["commit"] ?? .null)
                    return UploadSessionFinishArg(cursor: cursor, commit: commit)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The UploadSessionFinishBatchArg struct
    open class UploadSessionFinishBatchArg: CustomStringConvertible {
        /// Commit information for each file in the batch.
        public let entries: Array<Files.UploadSessionFinishArg>
        public init(entries: Array<Files.UploadSessionFinishArg>) {
            self.entries = entries
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(UploadSessionFinishBatchArgSerializer().serialize(self)))"
        }
    }
    open class UploadSessionFinishBatchArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: UploadSessionFinishBatchArg) -> JSON {
            let output = [ 
            "entries": ArraySerializer(Files.UploadSessionFinishArgSerializer()).serialize(value.entries),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> UploadSessionFinishBatchArg {
            switch json {
                case .dictionary(let dict):
                    let entries = ArraySerializer(Files.UploadSessionFinishArgSerializer()).deserialize(dict["entries"] ?? .null)
                    return UploadSessionFinishBatchArg(entries: entries)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The UploadSessionFinishBatchJobStatus union
    public enum UploadSessionFinishBatchJobStatus: CustomStringConvertible {
        /// The asynchronous job is still in progress.
        case inProgress
        /// The uploadSessionFinishBatch has finished.
        case complete(Files.UploadSessionFinishBatchResult)

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(UploadSessionFinishBatchJobStatusSerializer().serialize(self)))"
        }
    }
    open class UploadSessionFinishBatchJobStatusSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: UploadSessionFinishBatchJobStatus) -> JSON {
            switch value {
                case .inProgress:
                    var d = [String: JSON]()
                    d[".tag"] = .str("in_progress")
                    return .dictionary(d)
                case .complete(let arg):
                    var d = Serialization.getFields(Files.UploadSessionFinishBatchResultSerializer().serialize(arg))
                    d[".tag"] = .str("complete")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> UploadSessionFinishBatchJobStatus {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "in_progress":
                            return UploadSessionFinishBatchJobStatus.inProgress
                        case "complete":
                            let v = Files.UploadSessionFinishBatchResultSerializer().deserialize(json)
                            return UploadSessionFinishBatchJobStatus.complete(v)
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Result returned by uploadSessionFinishBatch that may either launch an asynchronous job or complete
    /// synchronously.
    public enum UploadSessionFinishBatchLaunch: CustomStringConvertible {
        /// This response indicates that the processing is asynchronous. The string is an id that can be used to obtain
        /// the status of the asynchronous job.
        case asyncJobId(String)
        /// An unspecified error.
        case complete(Files.UploadSessionFinishBatchResult)
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(UploadSessionFinishBatchLaunchSerializer().serialize(self)))"
        }
    }
    open class UploadSessionFinishBatchLaunchSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: UploadSessionFinishBatchLaunch) -> JSON {
            switch value {
                case .asyncJobId(let arg):
                    var d = ["async_job_id": Serialization._StringSerializer.serialize(arg)]
                    d[".tag"] = .str("async_job_id")
                    return .dictionary(d)
                case .complete(let arg):
                    var d = Serialization.getFields(Files.UploadSessionFinishBatchResultSerializer().serialize(arg))
                    d[".tag"] = .str("complete")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> UploadSessionFinishBatchLaunch {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "async_job_id":
                            let v = Serialization._StringSerializer.deserialize(d["async_job_id"] ?? .null)
                            return UploadSessionFinishBatchLaunch.asyncJobId(v)
                        case "complete":
                            let v = Files.UploadSessionFinishBatchResultSerializer().deserialize(json)
                            return UploadSessionFinishBatchLaunch.complete(v)
                        case "other":
                            return UploadSessionFinishBatchLaunch.other
                        default:
                            return UploadSessionFinishBatchLaunch.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The UploadSessionFinishBatchResult struct
    open class UploadSessionFinishBatchResult: CustomStringConvertible {
        /// Each entry in entries in UploadSessionFinishBatchArg will appear at the same position inside entries in
        /// UploadSessionFinishBatchResult.
        public let entries: Array<Files.UploadSessionFinishBatchResultEntry>
        public init(entries: Array<Files.UploadSessionFinishBatchResultEntry>) {
            self.entries = entries
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(UploadSessionFinishBatchResultSerializer().serialize(self)))"
        }
    }
    open class UploadSessionFinishBatchResultSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: UploadSessionFinishBatchResult) -> JSON {
            let output = [ 
            "entries": ArraySerializer(Files.UploadSessionFinishBatchResultEntrySerializer()).serialize(value.entries),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> UploadSessionFinishBatchResult {
            switch json {
                case .dictionary(let dict):
                    let entries = ArraySerializer(Files.UploadSessionFinishBatchResultEntrySerializer()).deserialize(dict["entries"] ?? .null)
                    return UploadSessionFinishBatchResult(entries: entries)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The UploadSessionFinishBatchResultEntry union
    public enum UploadSessionFinishBatchResultEntry: CustomStringConvertible {
        /// An unspecified error.
        case success(Files.FileMetadata)
        /// An unspecified error.
        case failure(Files.UploadSessionFinishError)

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(UploadSessionFinishBatchResultEntrySerializer().serialize(self)))"
        }
    }
    open class UploadSessionFinishBatchResultEntrySerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: UploadSessionFinishBatchResultEntry) -> JSON {
            switch value {
                case .success(let arg):
                    var d = Serialization.getFields(Files.FileMetadataSerializer().serialize(arg))
                    d[".tag"] = .str("success")
                    return .dictionary(d)
                case .failure(let arg):
                    var d = ["failure": Files.UploadSessionFinishErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("failure")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> UploadSessionFinishBatchResultEntry {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "success":
                            let v = Files.FileMetadataSerializer().deserialize(json)
                            return UploadSessionFinishBatchResultEntry.success(v)
                        case "failure":
                            let v = Files.UploadSessionFinishErrorSerializer().deserialize(d["failure"] ?? .null)
                            return UploadSessionFinishBatchResultEntry.failure(v)
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The UploadSessionFinishError union
    public enum UploadSessionFinishError: CustomStringConvertible {
        /// The session arguments are incorrect; the value explains the reason.
        case lookupFailed(Files.UploadSessionLookupError)
        /// Unable to save the uploaded contents to a file. Data has already been appended to the upload session. Please
        /// retry with empty data body and updated offset.
        case path(Files.WriteError)
        /// The supplied property group is invalid. The file has uploaded without property groups.
        case propertiesError(FileProperties.InvalidPropertyGroupError)
        /// The batch request commits files into too many different shared folders. Please limit your batch request to
        /// files contained in a single shared folder.
        case tooManySharedFolderTargets
        /// There are too many write operations happening in the user's Dropbox. You should retry uploading this file.
        case tooManyWriteOperations
        /// Uploading data not allowed when finishing concurrent upload session.
        case concurrentSessionDataNotAllowed
        /// Concurrent upload sessions need to be closed before finishing.
        case concurrentSessionNotClosed
        /// Not all pieces of data were uploaded before trying to finish the session.
        case concurrentSessionMissingData
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(UploadSessionFinishErrorSerializer().serialize(self)))"
        }
    }
    open class UploadSessionFinishErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: UploadSessionFinishError) -> JSON {
            switch value {
                case .lookupFailed(let arg):
                    var d = ["lookup_failed": Files.UploadSessionLookupErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("lookup_failed")
                    return .dictionary(d)
                case .path(let arg):
                    var d = ["path": Files.WriteErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("path")
                    return .dictionary(d)
                case .propertiesError(let arg):
                    var d = ["properties_error": FileProperties.InvalidPropertyGroupErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("properties_error")
                    return .dictionary(d)
                case .tooManySharedFolderTargets:
                    var d = [String: JSON]()
                    d[".tag"] = .str("too_many_shared_folder_targets")
                    return .dictionary(d)
                case .tooManyWriteOperations:
                    var d = [String: JSON]()
                    d[".tag"] = .str("too_many_write_operations")
                    return .dictionary(d)
                case .concurrentSessionDataNotAllowed:
                    var d = [String: JSON]()
                    d[".tag"] = .str("concurrent_session_data_not_allowed")
                    return .dictionary(d)
                case .concurrentSessionNotClosed:
                    var d = [String: JSON]()
                    d[".tag"] = .str("concurrent_session_not_closed")
                    return .dictionary(d)
                case .concurrentSessionMissingData:
                    var d = [String: JSON]()
                    d[".tag"] = .str("concurrent_session_missing_data")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> UploadSessionFinishError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "lookup_failed":
                            let v = Files.UploadSessionLookupErrorSerializer().deserialize(d["lookup_failed"] ?? .null)
                            return UploadSessionFinishError.lookupFailed(v)
                        case "path":
                            let v = Files.WriteErrorSerializer().deserialize(d["path"] ?? .null)
                            return UploadSessionFinishError.path(v)
                        case "properties_error":
                            let v = FileProperties.InvalidPropertyGroupErrorSerializer().deserialize(d["properties_error"] ?? .null)
                            return UploadSessionFinishError.propertiesError(v)
                        case "too_many_shared_folder_targets":
                            return UploadSessionFinishError.tooManySharedFolderTargets
                        case "too_many_write_operations":
                            return UploadSessionFinishError.tooManyWriteOperations
                        case "concurrent_session_data_not_allowed":
                            return UploadSessionFinishError.concurrentSessionDataNotAllowed
                        case "concurrent_session_not_closed":
                            return UploadSessionFinishError.concurrentSessionNotClosed
                        case "concurrent_session_missing_data":
                            return UploadSessionFinishError.concurrentSessionMissingData
                        case "other":
                            return UploadSessionFinishError.other
                        default:
                            return UploadSessionFinishError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The UploadSessionLookupError union
    public enum UploadSessionLookupError: CustomStringConvertible {
        /// The upload session ID was not found or has expired. Upload sessions are valid for 7 days.
        case notFound
        /// The specified offset was incorrect. See the value for the correct offset. This error may occur when a
        /// previous request was received and processed successfully but the client did not receive the response, e.g.
        /// due to a network error.
        case incorrectOffset(Files.UploadSessionOffsetError)
        /// You are attempting to append data to an upload session that has already been closed (i.e. committed).
        case closed
        /// The session must be closed before calling upload_session/finish_batch.
        case notClosed
        /// You can not append to the upload session because the size of a file should not reach the max file size limit
        /// (i.e. 350GB).
        case tooLarge
        /// For concurrent upload sessions, offset needs to be multiple of 4194304 bytes.
        case concurrentSessionInvalidOffset
        /// For concurrent upload sessions, only chunks with size multiple of 4194304 bytes can be uploaded.
        case concurrentSessionInvalidDataSize
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(UploadSessionLookupErrorSerializer().serialize(self)))"
        }
    }
    open class UploadSessionLookupErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: UploadSessionLookupError) -> JSON {
            switch value {
                case .notFound:
                    var d = [String: JSON]()
                    d[".tag"] = .str("not_found")
                    return .dictionary(d)
                case .incorrectOffset(let arg):
                    var d = Serialization.getFields(Files.UploadSessionOffsetErrorSerializer().serialize(arg))
                    d[".tag"] = .str("incorrect_offset")
                    return .dictionary(d)
                case .closed:
                    var d = [String: JSON]()
                    d[".tag"] = .str("closed")
                    return .dictionary(d)
                case .notClosed:
                    var d = [String: JSON]()
                    d[".tag"] = .str("not_closed")
                    return .dictionary(d)
                case .tooLarge:
                    var d = [String: JSON]()
                    d[".tag"] = .str("too_large")
                    return .dictionary(d)
                case .concurrentSessionInvalidOffset:
                    var d = [String: JSON]()
                    d[".tag"] = .str("concurrent_session_invalid_offset")
                    return .dictionary(d)
                case .concurrentSessionInvalidDataSize:
                    var d = [String: JSON]()
                    d[".tag"] = .str("concurrent_session_invalid_data_size")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> UploadSessionLookupError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "not_found":
                            return UploadSessionLookupError.notFound
                        case "incorrect_offset":
                            let v = Files.UploadSessionOffsetErrorSerializer().deserialize(json)
                            return UploadSessionLookupError.incorrectOffset(v)
                        case "closed":
                            return UploadSessionLookupError.closed
                        case "not_closed":
                            return UploadSessionLookupError.notClosed
                        case "too_large":
                            return UploadSessionLookupError.tooLarge
                        case "concurrent_session_invalid_offset":
                            return UploadSessionLookupError.concurrentSessionInvalidOffset
                        case "concurrent_session_invalid_data_size":
                            return UploadSessionLookupError.concurrentSessionInvalidDataSize
                        case "other":
                            return UploadSessionLookupError.other
                        default:
                            return UploadSessionLookupError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The UploadSessionOffsetError struct
    open class UploadSessionOffsetError: CustomStringConvertible {
        /// The offset up to which data has been collected.
        public let correctOffset: UInt64
        public init(correctOffset: UInt64) {
            comparableValidator()(correctOffset)
            self.correctOffset = correctOffset
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(UploadSessionOffsetErrorSerializer().serialize(self)))"
        }
    }
    open class UploadSessionOffsetErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: UploadSessionOffsetError) -> JSON {
            let output = [ 
            "correct_offset": Serialization._UInt64Serializer.serialize(value.correctOffset),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> UploadSessionOffsetError {
            switch json {
                case .dictionary(let dict):
                    let correctOffset = Serialization._UInt64Serializer.deserialize(dict["correct_offset"] ?? .null)
                    return UploadSessionOffsetError(correctOffset: correctOffset)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The UploadSessionStartArg struct
    open class UploadSessionStartArg: CustomStringConvertible {
        /// If true, the current session will be closed, at which point you won't be able to call uploadSessionAppendV2
        /// anymore with the current session.
        public let close: Bool
        /// Type of upload session you want to start. If not specified, default is sequential in UploadSessionType.
        public let sessionType: Files.UploadSessionType?
        public init(close: Bool = false, sessionType: Files.UploadSessionType? = nil) {
            self.close = close
            self.sessionType = sessionType
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(UploadSessionStartArgSerializer().serialize(self)))"
        }
    }
    open class UploadSessionStartArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: UploadSessionStartArg) -> JSON {
            let output = [ 
            "close": Serialization._BoolSerializer.serialize(value.close),
            "session_type": NullableSerializer(Files.UploadSessionTypeSerializer()).serialize(value.sessionType),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> UploadSessionStartArg {
            switch json {
                case .dictionary(let dict):
                    let close = Serialization._BoolSerializer.deserialize(dict["close"] ?? .number(0))
                    let sessionType = NullableSerializer(Files.UploadSessionTypeSerializer()).deserialize(dict["session_type"] ?? .null)
                    return UploadSessionStartArg(close: close, sessionType: sessionType)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The UploadSessionStartError union
    public enum UploadSessionStartError: CustomStringConvertible {
        /// Uploading data not allowed when starting concurrent upload session.
        case concurrentSessionDataNotAllowed
        /// Can not start a closed concurrent upload session.
        case concurrentSessionCloseNotAllowed
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(UploadSessionStartErrorSerializer().serialize(self)))"
        }
    }
    open class UploadSessionStartErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: UploadSessionStartError) -> JSON {
            switch value {
                case .concurrentSessionDataNotAllowed:
                    var d = [String: JSON]()
                    d[".tag"] = .str("concurrent_session_data_not_allowed")
                    return .dictionary(d)
                case .concurrentSessionCloseNotAllowed:
                    var d = [String: JSON]()
                    d[".tag"] = .str("concurrent_session_close_not_allowed")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> UploadSessionStartError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "concurrent_session_data_not_allowed":
                            return UploadSessionStartError.concurrentSessionDataNotAllowed
                        case "concurrent_session_close_not_allowed":
                            return UploadSessionStartError.concurrentSessionCloseNotAllowed
                        case "other":
                            return UploadSessionStartError.other
                        default:
                            return UploadSessionStartError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The UploadSessionStartResult struct
    open class UploadSessionStartResult: CustomStringConvertible {
        /// A unique identifier for the upload session. Pass this to uploadSessionAppendV2 and uploadSessionFinish.
        public let sessionId: String
        public init(sessionId: String) {
            stringValidator()(sessionId)
            self.sessionId = sessionId
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(UploadSessionStartResultSerializer().serialize(self)))"
        }
    }
    open class UploadSessionStartResultSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: UploadSessionStartResult) -> JSON {
            let output = [ 
            "session_id": Serialization._StringSerializer.serialize(value.sessionId),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> UploadSessionStartResult {
            switch json {
                case .dictionary(let dict):
                    let sessionId = Serialization._StringSerializer.deserialize(dict["session_id"] ?? .null)
                    return UploadSessionStartResult(sessionId: sessionId)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The UploadSessionType union
    public enum UploadSessionType: CustomStringConvertible {
        /// Pieces of data are uploaded sequentially one after another. This is the default behavior.
        case sequential
        /// Pieces of data can be uploaded in concurrent RPCs in any order.
        case concurrent
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(UploadSessionTypeSerializer().serialize(self)))"
        }
    }
    open class UploadSessionTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: UploadSessionType) -> JSON {
            switch value {
                case .sequential:
                    var d = [String: JSON]()
                    d[".tag"] = .str("sequential")
                    return .dictionary(d)
                case .concurrent:
                    var d = [String: JSON]()
                    d[".tag"] = .str("concurrent")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> UploadSessionType {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "sequential":
                            return UploadSessionType.sequential
                        case "concurrent":
                            return UploadSessionType.concurrent
                        case "other":
                            return UploadSessionType.other
                        default:
                            return UploadSessionType.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The UploadWriteFailed struct
    open class UploadWriteFailed: CustomStringConvertible {
        /// The reason why the file couldn't be saved.
        public let reason: Files.WriteError
        /// The upload session ID; data has already been uploaded to the corresponding upload session and this ID may be
        /// used to retry the commit with uploadSessionFinish.
        public let uploadSessionId: String
        public init(reason: Files.WriteError, uploadSessionId: String) {
            self.reason = reason
            stringValidator()(uploadSessionId)
            self.uploadSessionId = uploadSessionId
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(UploadWriteFailedSerializer().serialize(self)))"
        }
    }
    open class UploadWriteFailedSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: UploadWriteFailed) -> JSON {
            let output = [ 
            "reason": Files.WriteErrorSerializer().serialize(value.reason),
            "upload_session_id": Serialization._StringSerializer.serialize(value.uploadSessionId),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> UploadWriteFailed {
            switch json {
                case .dictionary(let dict):
                    let reason = Files.WriteErrorSerializer().deserialize(dict["reason"] ?? .null)
                    let uploadSessionId = Serialization._StringSerializer.deserialize(dict["upload_session_id"] ?? .null)
                    return UploadWriteFailed(reason: reason, uploadSessionId: uploadSessionId)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Metadata for a video.
    open class VideoMetadata: Files.MediaMetadata {
        /// The duration of the video in milliseconds.
        public let duration: UInt64?
        public init(dimensions: Files.Dimensions? = nil, location: Files.GpsCoordinates? = nil, timeTaken: Date? = nil, duration: UInt64? = nil) {
            nullableValidator(comparableValidator())(duration)
            self.duration = duration
            super.init(dimensions: dimensions, location: location, timeTaken: timeTaken)
        }
        open override var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(VideoMetadataSerializer().serialize(self)))"
        }
    }
    open class VideoMetadataSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: VideoMetadata) -> JSON {
            let output = [ 
            "dimensions": NullableSerializer(Files.DimensionsSerializer()).serialize(value.dimensions),
            "location": NullableSerializer(Files.GpsCoordinatesSerializer()).serialize(value.location),
            "time_taken": NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.timeTaken),
            "duration": NullableSerializer(Serialization._UInt64Serializer).serialize(value.duration),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> VideoMetadata {
            switch json {
                case .dictionary(let dict):
                    let dimensions = NullableSerializer(Files.DimensionsSerializer()).deserialize(dict["dimensions"] ?? .null)
                    let location = NullableSerializer(Files.GpsCoordinatesSerializer()).deserialize(dict["location"] ?? .null)
                    let timeTaken = NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).deserialize(dict["time_taken"] ?? .null)
                    let duration = NullableSerializer(Serialization._UInt64Serializer).deserialize(dict["duration"] ?? .null)
                    return VideoMetadata(dimensions: dimensions, location: location, timeTaken: timeTaken, duration: duration)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The WriteConflictError union
    public enum WriteConflictError: CustomStringConvertible {
        /// There's a file in the way.
        case file
        /// There's a folder in the way.
        case folder
        /// There's a file at an ancestor path, so we couldn't create the required parent folders.
        case fileAncestor
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(WriteConflictErrorSerializer().serialize(self)))"
        }
    }
    open class WriteConflictErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: WriteConflictError) -> JSON {
            switch value {
                case .file:
                    var d = [String: JSON]()
                    d[".tag"] = .str("file")
                    return .dictionary(d)
                case .folder:
                    var d = [String: JSON]()
                    d[".tag"] = .str("folder")
                    return .dictionary(d)
                case .fileAncestor:
                    var d = [String: JSON]()
                    d[".tag"] = .str("file_ancestor")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> WriteConflictError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "file":
                            return WriteConflictError.file
                        case "folder":
                            return WriteConflictError.folder
                        case "file_ancestor":
                            return WriteConflictError.fileAncestor
                        case "other":
                            return WriteConflictError.other
                        default:
                            return WriteConflictError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The WriteError union
    public enum WriteError: CustomStringConvertible {
        /// The given path does not satisfy the required path format. Please refer to the Path formats documentation
        /// https://www.dropbox.com/developers/documentation/http/documentation#path-formats for more information.
        case malformedPath(String?)
        /// Couldn't write to the target path because there was something in the way.
        case conflict(Files.WriteConflictError)
        /// The user doesn't have permissions to write to the target location.
        case noWritePermission
        /// The user doesn't have enough available space (bytes) to write more data.
        case insufficientSpace
        /// Dropbox will not save the file or folder because of its name.
        case disallowedName
        /// This endpoint cannot move or delete team folders.
        case teamFolder
        /// This file operation is not allowed at this path.
        case operationSuppressed
        /// There are too many write operations in user's Dropbox. Please retry this request.
        case tooManyWriteOperations
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(WriteErrorSerializer().serialize(self)))"
        }
    }
    open class WriteErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: WriteError) -> JSON {
            switch value {
                case .malformedPath(let arg):
                    var d = ["malformed_path": NullableSerializer(Serialization._StringSerializer).serialize(arg)]
                    d[".tag"] = .str("malformed_path")
                    return .dictionary(d)
                case .conflict(let arg):
                    var d = ["conflict": Files.WriteConflictErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("conflict")
                    return .dictionary(d)
                case .noWritePermission:
                    var d = [String: JSON]()
                    d[".tag"] = .str("no_write_permission")
                    return .dictionary(d)
                case .insufficientSpace:
                    var d = [String: JSON]()
                    d[".tag"] = .str("insufficient_space")
                    return .dictionary(d)
                case .disallowedName:
                    var d = [String: JSON]()
                    d[".tag"] = .str("disallowed_name")
                    return .dictionary(d)
                case .teamFolder:
                    var d = [String: JSON]()
                    d[".tag"] = .str("team_folder")
                    return .dictionary(d)
                case .operationSuppressed:
                    var d = [String: JSON]()
                    d[".tag"] = .str("operation_suppressed")
                    return .dictionary(d)
                case .tooManyWriteOperations:
                    var d = [String: JSON]()
                    d[".tag"] = .str("too_many_write_operations")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> WriteError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "malformed_path":
                            let v = NullableSerializer(Serialization._StringSerializer).deserialize(d["malformed_path"] ?? .null)
                            return WriteError.malformedPath(v)
                        case "conflict":
                            let v = Files.WriteConflictErrorSerializer().deserialize(d["conflict"] ?? .null)
                            return WriteError.conflict(v)
                        case "no_write_permission":
                            return WriteError.noWritePermission
                        case "insufficient_space":
                            return WriteError.insufficientSpace
                        case "disallowed_name":
                            return WriteError.disallowedName
                        case "team_folder":
                            return WriteError.teamFolder
                        case "operation_suppressed":
                            return WriteError.operationSuppressed
                        case "too_many_write_operations":
                            return WriteError.tooManyWriteOperations
                        case "other":
                            return WriteError.other
                        default:
                            return WriteError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Your intent when writing a file to some path. This is used to determine what constitutes a conflict and what the
    /// autorename strategy is. In some situations, the conflict behavior is identical: (a) If the target path doesn't
    /// refer to anything, the file is always written; no conflict. (b) If the target path refers to a folder, it's
    /// always a conflict. (c) If the target path refers to a file with identical contents, nothing gets written; no
    /// conflict. The conflict checking differs in the case where there's a file at the target path with contents
    /// different from the contents you're trying to write.
    public enum WriteMode: CustomStringConvertible {
        /// Do not overwrite an existing file if there is a conflict. The autorename strategy is to append a number to
        /// the file name. For example, "document.txt" might become "document (2).txt".
        case add
        /// Always overwrite the existing file. The autorename strategy is the same as it is for add.
        case overwrite
        /// Overwrite if the given "rev" matches the existing file's "rev". The autorename strategy is to append the
        /// string "conflicted copy" to the file name. For example, "document.txt" might become "document (conflicted
        /// copy).txt" or "document (Panda's conflicted copy).txt".
        case update(String)

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(WriteModeSerializer().serialize(self)))"
        }
    }
    open class WriteModeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: WriteMode) -> JSON {
            switch value {
                case .add:
                    var d = [String: JSON]()
                    d[".tag"] = .str("add")
                    return .dictionary(d)
                case .overwrite:
                    var d = [String: JSON]()
                    d[".tag"] = .str("overwrite")
                    return .dictionary(d)
                case .update(let arg):
                    var d = ["update": Serialization._StringSerializer.serialize(arg)]
                    d[".tag"] = .str("update")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> WriteMode {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "add":
                            return WriteMode.add
                        case "overwrite":
                            return WriteMode.overwrite
                        case "update":
                            let v = Serialization._StringSerializer.deserialize(d["update"] ?? .null)
                            return WriteMode.update(v)
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }


    /// Stone Route Objects

    static let alphaGetMetadata = Route(
        name: "alpha/get_metadata",
        version: 1,
        namespace: "files",
        deprecated: true,
        argSerializer: Files.AlphaGetMetadataArgSerializer(),
        responseSerializer: Files.MetadataSerializer(),
        errorSerializer: Files.AlphaGetMetadataErrorSerializer(),
        attrs: ["auth": "user",
                "host": "api",
                "style": "rpc"]
    )
    static let alphaUpload = Route(
        name: "alpha/upload",
        version: 1,
        namespace: "files",
        deprecated: true,
        argSerializer: Files.CommitInfoWithPropertiesSerializer(),
        responseSerializer: Files.FileMetadataSerializer(),
        errorSerializer: Files.UploadErrorWithPropertiesSerializer(),
        attrs: ["auth": "user",
                "host": "content",
                "style": "upload"]
    )
    static let copyV2 = Route(
        name: "copy",
        version: 2,
        namespace: "files",
        deprecated: false,
        argSerializer: Files.RelocationArgSerializer(),
        responseSerializer: Files.RelocationResultSerializer(),
        errorSerializer: Files.RelocationErrorSerializer(),
        attrs: ["auth": "user",
                "host": "api",
                "style": "rpc"]
    )
    static let copy = Route(
        name: "copy",
        version: 1,
        namespace: "files",
        deprecated: true,
        argSerializer: Files.RelocationArgSerializer(),
        responseSerializer: Files.MetadataSerializer(),
        errorSerializer: Files.RelocationErrorSerializer(),
        attrs: ["auth": "user",
                "host": "api",
                "style": "rpc"]
    )
    static let copyBatchV2 = Route(
        name: "copy_batch",
        version: 2,
        namespace: "files",
        deprecated: false,
        argSerializer: Files.RelocationBatchArgBaseSerializer(),
        responseSerializer: Files.RelocationBatchV2LaunchSerializer(),
        errorSerializer: Serialization._VoidSerializer,
        attrs: ["auth": "user",
                "host": "api",
                "style": "rpc"]
    )
    static let copyBatch = Route(
        name: "copy_batch",
        version: 1,
        namespace: "files",
        deprecated: true,
        argSerializer: Files.RelocationBatchArgSerializer(),
        responseSerializer: Files.RelocationBatchLaunchSerializer(),
        errorSerializer: Serialization._VoidSerializer,
        attrs: ["auth": "user",
                "host": "api",
                "style": "rpc"]
    )
    static let copyBatchCheckV2 = Route(
        name: "copy_batch/check",
        version: 2,
        namespace: "files",
        deprecated: false,
        argSerializer: Async.PollArgSerializer(),
        responseSerializer: Files.RelocationBatchV2JobStatusSerializer(),
        errorSerializer: Async.PollErrorSerializer(),
        attrs: ["auth": "user",
                "host": "api",
                "style": "rpc"]
    )
    static let copyBatchCheck = Route(
        name: "copy_batch/check",
        version: 1,
        namespace: "files",
        deprecated: true,
        argSerializer: Async.PollArgSerializer(),
        responseSerializer: Files.RelocationBatchJobStatusSerializer(),
        errorSerializer: Async.PollErrorSerializer(),
        attrs: ["auth": "user",
                "host": "api",
                "style": "rpc"]
    )
    static let copyReferenceGet = Route(
        name: "copy_reference/get",
        version: 1,
        namespace: "files",
        deprecated: false,
        argSerializer: Files.GetCopyReferenceArgSerializer(),
        responseSerializer: Files.GetCopyReferenceResultSerializer(),
        errorSerializer: Files.GetCopyReferenceErrorSerializer(),
        attrs: ["auth": "user",
                "host": "api",
                "style": "rpc"]
    )
    static let copyReferenceSave = Route(
        name: "copy_reference/save",
        version: 1,
        namespace: "files",
        deprecated: false,
        argSerializer: Files.SaveCopyReferenceArgSerializer(),
        responseSerializer: Files.SaveCopyReferenceResultSerializer(),
        errorSerializer: Files.SaveCopyReferenceErrorSerializer(),
        attrs: ["auth": "user",
                "host": "api",
                "style": "rpc"]
    )
    static let createFolderV2 = Route(
        name: "create_folder",
        version: 2,
        namespace: "files",
        deprecated: false,
        argSerializer: Files.CreateFolderArgSerializer(),
        responseSerializer: Files.CreateFolderResultSerializer(),
        errorSerializer: Files.CreateFolderErrorSerializer(),
        attrs: ["auth": "user",
                "host": "api",
                "style": "rpc"]
    )
    static let createFolder = Route(
        name: "create_folder",
        version: 1,
        namespace: "files",
        deprecated: true,
        argSerializer: Files.CreateFolderArgSerializer(),
        responseSerializer: Files.FolderMetadataSerializer(),
        errorSerializer: Files.CreateFolderErrorSerializer(),
        attrs: ["auth": "user",
                "host": "api",
                "style": "rpc"]
    )
    static let createFolderBatch = Route(
        name: "create_folder_batch",
        version: 1,
        namespace: "files",
        deprecated: false,
        argSerializer: Files.CreateFolderBatchArgSerializer(),
        responseSerializer: Files.CreateFolderBatchLaunchSerializer(),
        errorSerializer: Serialization._VoidSerializer,
        attrs: ["auth": "user",
                "host": "api",
                "style": "rpc"]
    )
    static let createFolderBatchCheck = Route(
        name: "create_folder_batch/check",
        version: 1,
        namespace: "files",
        deprecated: false,
        argSerializer: Async.PollArgSerializer(),
        responseSerializer: Files.CreateFolderBatchJobStatusSerializer(),
        errorSerializer: Async.PollErrorSerializer(),
        attrs: ["auth": "user",
                "host": "api",
                "style": "rpc"]
    )
    static let deleteV2 = Route(
        name: "delete",
        version: 2,
        namespace: "files",
        deprecated: false,
        argSerializer: Files.DeleteArgSerializer(),
        responseSerializer: Files.DeleteResultSerializer(),
        errorSerializer: Files.DeleteErrorSerializer(),
        attrs: ["auth": "user",
                "host": "api",
                "style": "rpc"]
    )
    static let delete = Route(
        name: "delete",
        version: 1,
        namespace: "files",
        deprecated: true,
        argSerializer: Files.DeleteArgSerializer(),
        responseSerializer: Files.MetadataSerializer(),
        errorSerializer: Files.DeleteErrorSerializer(),
        attrs: ["auth": "user",
                "host": "api",
                "style": "rpc"]
    )
    static let deleteBatch = Route(
        name: "delete_batch",
        version: 1,
        namespace: "files",
        deprecated: false,
        argSerializer: Files.DeleteBatchArgSerializer(),
        responseSerializer: Files.DeleteBatchLaunchSerializer(),
        errorSerializer: Serialization._VoidSerializer,
        attrs: ["auth": "user",
                "host": "api",
                "style": "rpc"]
    )
    static let deleteBatchCheck = Route(
        name: "delete_batch/check",
        version: 1,
        namespace: "files",
        deprecated: false,
        argSerializer: Async.PollArgSerializer(),
        responseSerializer: Files.DeleteBatchJobStatusSerializer(),
        errorSerializer: Async.PollErrorSerializer(),
        attrs: ["auth": "user",
                "host": "api",
                "style": "rpc"]
    )
    static let download = Route(
        name: "download",
        version: 1,
        namespace: "files",
        deprecated: false,
        argSerializer: Files.DownloadArgSerializer(),
        responseSerializer: Files.FileMetadataSerializer(),
        errorSerializer: Files.DownloadErrorSerializer(),
        attrs: ["auth": "user",
                "host": "content",
                "style": "download"]
    )
    static let downloadZip = Route(
        name: "download_zip",
        version: 1,
        namespace: "files",
        deprecated: false,
        argSerializer: Files.DownloadZipArgSerializer(),
        responseSerializer: Files.DownloadZipResultSerializer(),
        errorSerializer: Files.DownloadZipErrorSerializer(),
        attrs: ["auth": "user",
                "host": "content",
                "style": "download"]
    )
    static let export = Route(
        name: "export",
        version: 1,
        namespace: "files",
        deprecated: false,
        argSerializer: Files.ExportArgSerializer(),
        responseSerializer: Files.ExportResultSerializer(),
        errorSerializer: Files.ExportErrorSerializer(),
        attrs: ["auth": "user",
                "host": "content",
                "style": "download"]
    )
    static let getFileLockBatch = Route(
        name: "get_file_lock_batch",
        version: 1,
        namespace: "files",
        deprecated: false,
        argSerializer: Files.LockFileBatchArgSerializer(),
        responseSerializer: Files.LockFileBatchResultSerializer(),
        errorSerializer: Files.LockFileErrorSerializer(),
        attrs: ["auth": "user",
                "host": "api",
                "style": "rpc"]
    )
    static let getMetadata = Route(
        name: "get_metadata",
        version: 1,
        namespace: "files",
        deprecated: false,
        argSerializer: Files.GetMetadataArgSerializer(),
        responseSerializer: Files.MetadataSerializer(),
        errorSerializer: Files.GetMetadataErrorSerializer(),
        attrs: ["auth": "user",
                "host": "api",
                "style": "rpc"]
    )
    static let getPreview = Route(
        name: "get_preview",
        version: 1,
        namespace: "files",
        deprecated: false,
        argSerializer: Files.PreviewArgSerializer(),
        responseSerializer: Files.FileMetadataSerializer(),
        errorSerializer: Files.PreviewErrorSerializer(),
        attrs: ["auth": "user",
                "host": "content",
                "style": "download"]
    )
    static let getTemporaryLink = Route(
        name: "get_temporary_link",
        version: 1,
        namespace: "files",
        deprecated: false,
        argSerializer: Files.GetTemporaryLinkArgSerializer(),
        responseSerializer: Files.GetTemporaryLinkResultSerializer(),
        errorSerializer: Files.GetTemporaryLinkErrorSerializer(),
        attrs: ["auth": "user",
                "host": "api",
                "style": "rpc"]
    )
    static let getTemporaryUploadLink = Route(
        name: "get_temporary_upload_link",
        version: 1,
        namespace: "files",
        deprecated: false,
        argSerializer: Files.GetTemporaryUploadLinkArgSerializer(),
        responseSerializer: Files.GetTemporaryUploadLinkResultSerializer(),
        errorSerializer: Serialization._VoidSerializer,
        attrs: ["auth": "user",
                "host": "api",
                "style": "rpc"]
    )
    static let getThumbnail = Route(
        name: "get_thumbnail",
        version: 1,
        namespace: "files",
        deprecated: false,
        argSerializer: Files.ThumbnailArgSerializer(),
        responseSerializer: Files.FileMetadataSerializer(),
        errorSerializer: Files.ThumbnailErrorSerializer(),
        attrs: ["auth": "user",
                "host": "content",
                "style": "download"]
    )
    static let getThumbnailV2 = Route(
        name: "get_thumbnail",
        version: 2,
        namespace: "files",
        deprecated: false,
        argSerializer: Files.ThumbnailV2ArgSerializer(),
        responseSerializer: Files.PreviewResultSerializer(),
        errorSerializer: Files.ThumbnailV2ErrorSerializer(),
        attrs: ["auth": "app, user",
                "host": "content",
                "style": "download"]
    )
    static let getThumbnailBatch = Route(
        name: "get_thumbnail_batch",
        version: 1,
        namespace: "files",
        deprecated: false,
        argSerializer: Files.GetThumbnailBatchArgSerializer(),
        responseSerializer: Files.GetThumbnailBatchResultSerializer(),
        errorSerializer: Files.GetThumbnailBatchErrorSerializer(),
        attrs: ["auth": "user",
                "host": "content",
                "style": "rpc"]
    )
    static let listFolder = Route(
        name: "list_folder",
        version: 1,
        namespace: "files",
        deprecated: false,
        argSerializer: Files.ListFolderArgSerializer(),
        responseSerializer: Files.ListFolderResultSerializer(),
        errorSerializer: Files.ListFolderErrorSerializer(),
        attrs: ["auth": "user",
                "host": "api",
                "style": "rpc"]
    )
    static let listFolderContinue = Route(
        name: "list_folder/continue",
        version: 1,
        namespace: "files",
        deprecated: false,
        argSerializer: Files.ListFolderContinueArgSerializer(),
        responseSerializer: Files.ListFolderResultSerializer(),
        errorSerializer: Files.ListFolderContinueErrorSerializer(),
        attrs: ["auth": "user",
                "host": "api",
                "style": "rpc"]
    )
    static let listFolderGetLatestCursor = Route(
        name: "list_folder/get_latest_cursor",
        version: 1,
        namespace: "files",
        deprecated: false,
        argSerializer: Files.ListFolderArgSerializer(),
        responseSerializer: Files.ListFolderGetLatestCursorResultSerializer(),
        errorSerializer: Files.ListFolderErrorSerializer(),
        attrs: ["auth": "user",
                "host": "api",
                "style": "rpc"]
    )
    static let listFolderLongpoll = Route(
        name: "list_folder/longpoll",
        version: 1,
        namespace: "files",
        deprecated: false,
        argSerializer: Files.ListFolderLongpollArgSerializer(),
        responseSerializer: Files.ListFolderLongpollResultSerializer(),
        errorSerializer: Files.ListFolderLongpollErrorSerializer(),
        attrs: ["auth": "noauth",
                "host": "notify",
                "style": "rpc"]
    )
    static let listRevisions = Route(
        name: "list_revisions",
        version: 1,
        namespace: "files",
        deprecated: false,
        argSerializer: Files.ListRevisionsArgSerializer(),
        responseSerializer: Files.ListRevisionsResultSerializer(),
        errorSerializer: Files.ListRevisionsErrorSerializer(),
        attrs: ["auth": "user",
                "host": "api",
                "style": "rpc"]
    )
    static let lockFileBatch = Route(
        name: "lock_file_batch",
        version: 1,
        namespace: "files",
        deprecated: false,
        argSerializer: Files.LockFileBatchArgSerializer(),
        responseSerializer: Files.LockFileBatchResultSerializer(),
        errorSerializer: Files.LockFileErrorSerializer(),
        attrs: ["auth": "user",
                "host": "api",
                "style": "rpc"]
    )
    static let moveV2 = Route(
        name: "move",
        version: 2,
        namespace: "files",
        deprecated: false,
        argSerializer: Files.RelocationArgSerializer(),
        responseSerializer: Files.RelocationResultSerializer(),
        errorSerializer: Files.RelocationErrorSerializer(),
        attrs: ["auth": "user",
                "host": "api",
                "style": "rpc"]
    )
    static let move = Route(
        name: "move",
        version: 1,
        namespace: "files",
        deprecated: true,
        argSerializer: Files.RelocationArgSerializer(),
        responseSerializer: Files.MetadataSerializer(),
        errorSerializer: Files.RelocationErrorSerializer(),
        attrs: ["auth": "user",
                "host": "api",
                "style": "rpc"]
    )
    static let moveBatchV2 = Route(
        name: "move_batch",
        version: 2,
        namespace: "files",
        deprecated: false,
        argSerializer: Files.MoveBatchArgSerializer(),
        responseSerializer: Files.RelocationBatchV2LaunchSerializer(),
        errorSerializer: Serialization._VoidSerializer,
        attrs: ["auth": "user",
                "host": "api",
                "style": "rpc"]
    )
    static let moveBatch = Route(
        name: "move_batch",
        version: 1,
        namespace: "files",
        deprecated: true,
        argSerializer: Files.RelocationBatchArgSerializer(),
        responseSerializer: Files.RelocationBatchLaunchSerializer(),
        errorSerializer: Serialization._VoidSerializer,
        attrs: ["auth": "user",
                "host": "api",
                "style": "rpc"]
    )
    static let moveBatchCheckV2 = Route(
        name: "move_batch/check",
        version: 2,
        namespace: "files",
        deprecated: false,
        argSerializer: Async.PollArgSerializer(),
        responseSerializer: Files.RelocationBatchV2JobStatusSerializer(),
        errorSerializer: Async.PollErrorSerializer(),
        attrs: ["auth": "user",
                "host": "api",
                "style": "rpc"]
    )
    static let moveBatchCheck = Route(
        name: "move_batch/check",
        version: 1,
        namespace: "files",
        deprecated: true,
        argSerializer: Async.PollArgSerializer(),
        responseSerializer: Files.RelocationBatchJobStatusSerializer(),
        errorSerializer: Async.PollErrorSerializer(),
        attrs: ["auth": "user",
                "host": "api",
                "style": "rpc"]
    )
    static let paperCreate = Route(
        name: "paper/create",
        version: 1,
        namespace: "files",
        deprecated: false,
        argSerializer: Files.PaperCreateArgSerializer(),
        responseSerializer: Files.PaperCreateResultSerializer(),
        errorSerializer: Files.PaperCreateErrorSerializer(),
        attrs: ["auth": "user",
                "host": "api",
                "style": "upload"]
    )
    static let paperUpdate = Route(
        name: "paper/update",
        version: 1,
        namespace: "files",
        deprecated: false,
        argSerializer: Files.PaperUpdateArgSerializer(),
        responseSerializer: Files.PaperUpdateResultSerializer(),
        errorSerializer: Files.PaperUpdateErrorSerializer(),
        attrs: ["auth": "user",
                "host": "api",
                "style": "upload"]
    )
    static let permanentlyDelete = Route(
        name: "permanently_delete",
        version: 1,
        namespace: "files",
        deprecated: false,
        argSerializer: Files.DeleteArgSerializer(),
        responseSerializer: Serialization._VoidSerializer,
        errorSerializer: Files.DeleteErrorSerializer(),
        attrs: ["auth": "user",
                "host": "api",
                "style": "rpc"]
    )
    static let propertiesAdd = Route(
        name: "properties/add",
        version: 1,
        namespace: "files",
        deprecated: true,
        argSerializer: FileProperties.AddPropertiesArgSerializer(),
        responseSerializer: Serialization._VoidSerializer,
        errorSerializer: FileProperties.AddPropertiesErrorSerializer(),
        attrs: ["auth": "user",
                "host": "api",
                "style": "rpc"]
    )
    static let propertiesOverwrite = Route(
        name: "properties/overwrite",
        version: 1,
        namespace: "files",
        deprecated: true,
        argSerializer: FileProperties.OverwritePropertyGroupArgSerializer(),
        responseSerializer: Serialization._VoidSerializer,
        errorSerializer: FileProperties.InvalidPropertyGroupErrorSerializer(),
        attrs: ["auth": "user",
                "host": "api",
                "style": "rpc"]
    )
    static let propertiesRemove = Route(
        name: "properties/remove",
        version: 1,
        namespace: "files",
        deprecated: true,
        argSerializer: FileProperties.RemovePropertiesArgSerializer(),
        responseSerializer: Serialization._VoidSerializer,
        errorSerializer: FileProperties.RemovePropertiesErrorSerializer(),
        attrs: ["auth": "user",
                "host": "api",
                "style": "rpc"]
    )
    static let propertiesTemplateGet = Route(
        name: "properties/template/get",
        version: 1,
        namespace: "files",
        deprecated: true,
        argSerializer: FileProperties.GetTemplateArgSerializer(),
        responseSerializer: FileProperties.GetTemplateResultSerializer(),
        errorSerializer: FileProperties.TemplateErrorSerializer(),
        attrs: ["auth": "user",
                "host": "api",
                "style": "rpc"]
    )
    static let propertiesTemplateList = Route(
        name: "properties/template/list",
        version: 1,
        namespace: "files",
        deprecated: true,
        argSerializer: Serialization._VoidSerializer,
        responseSerializer: FileProperties.ListTemplateResultSerializer(),
        errorSerializer: FileProperties.TemplateErrorSerializer(),
        attrs: ["auth": "user",
                "host": "api",
                "style": "rpc"]
    )
    static let propertiesUpdate = Route(
        name: "properties/update",
        version: 1,
        namespace: "files",
        deprecated: true,
        argSerializer: FileProperties.UpdatePropertiesArgSerializer(),
        responseSerializer: Serialization._VoidSerializer,
        errorSerializer: FileProperties.UpdatePropertiesErrorSerializer(),
        attrs: ["auth": "user",
                "host": "api",
                "style": "rpc"]
    )
    static let restore = Route(
        name: "restore",
        version: 1,
        namespace: "files",
        deprecated: false,
        argSerializer: Files.RestoreArgSerializer(),
        responseSerializer: Files.FileMetadataSerializer(),
        errorSerializer: Files.RestoreErrorSerializer(),
        attrs: ["auth": "user",
                "host": "api",
                "style": "rpc"]
    )
    static let saveUrl = Route(
        name: "save_url",
        version: 1,
        namespace: "files",
        deprecated: false,
        argSerializer: Files.SaveUrlArgSerializer(),
        responseSerializer: Files.SaveUrlResultSerializer(),
        errorSerializer: Files.SaveUrlErrorSerializer(),
        attrs: ["auth": "user",
                "host": "api",
                "style": "rpc"]
    )
    static let saveUrlCheckJobStatus = Route(
        name: "save_url/check_job_status",
        version: 1,
        namespace: "files",
        deprecated: false,
        argSerializer: Async.PollArgSerializer(),
        responseSerializer: Files.SaveUrlJobStatusSerializer(),
        errorSerializer: Async.PollErrorSerializer(),
        attrs: ["auth": "user",
                "host": "api",
                "style": "rpc"]
    )
    static let search = Route(
        name: "search",
        version: 1,
        namespace: "files",
        deprecated: true,
        argSerializer: Files.SearchArgSerializer(),
        responseSerializer: Files.SearchResultSerializer(),
        errorSerializer: Files.SearchErrorSerializer(),
        attrs: ["auth": "user",
                "host": "api",
                "style": "rpc"]
    )
    static let searchV2 = Route(
        name: "search",
        version: 2,
        namespace: "files",
        deprecated: false,
        argSerializer: Files.SearchV2ArgSerializer(),
        responseSerializer: Files.SearchV2ResultSerializer(),
        errorSerializer: Files.SearchErrorSerializer(),
        attrs: ["auth": "user",
                "host": "api",
                "style": "rpc"]
    )
    static let searchContinueV2 = Route(
        name: "search/continue",
        version: 2,
        namespace: "files",
        deprecated: false,
        argSerializer: Files.SearchV2ContinueArgSerializer(),
        responseSerializer: Files.SearchV2ResultSerializer(),
        errorSerializer: Files.SearchErrorSerializer(),
        attrs: ["auth": "user",
                "host": "api",
                "style": "rpc"]
    )
    static let unlockFileBatch = Route(
        name: "unlock_file_batch",
        version: 1,
        namespace: "files",
        deprecated: false,
        argSerializer: Files.UnlockFileBatchArgSerializer(),
        responseSerializer: Files.LockFileBatchResultSerializer(),
        errorSerializer: Files.LockFileErrorSerializer(),
        attrs: ["auth": "user",
                "host": "api",
                "style": "rpc"]
    )
    static let upload = Route(
        name: "upload",
        version: 1,
        namespace: "files",
        deprecated: false,
        argSerializer: Files.CommitInfoSerializer(),
        responseSerializer: Files.FileMetadataSerializer(),
        errorSerializer: Files.UploadErrorSerializer(),
        attrs: ["auth": "user",
                "host": "content",
                "style": "upload"]
    )
    static let uploadSessionAppendV2 = Route(
        name: "upload_session/append",
        version: 2,
        namespace: "files",
        deprecated: false,
        argSerializer: Files.UploadSessionAppendArgSerializer(),
        responseSerializer: Serialization._VoidSerializer,
        errorSerializer: Files.UploadSessionLookupErrorSerializer(),
        attrs: ["auth": "user",
                "host": "content",
                "style": "upload"]
    )
    static let uploadSessionAppend = Route(
        name: "upload_session/append",
        version: 1,
        namespace: "files",
        deprecated: true,
        argSerializer: Files.UploadSessionCursorSerializer(),
        responseSerializer: Serialization._VoidSerializer,
        errorSerializer: Files.UploadSessionLookupErrorSerializer(),
        attrs: ["auth": "user",
                "host": "content",
                "style": "upload"]
    )
    static let uploadSessionFinish = Route(
        name: "upload_session/finish",
        version: 1,
        namespace: "files",
        deprecated: false,
        argSerializer: Files.UploadSessionFinishArgSerializer(),
        responseSerializer: Files.FileMetadataSerializer(),
        errorSerializer: Files.UploadSessionFinishErrorSerializer(),
        attrs: ["auth": "user",
                "host": "content",
                "style": "upload"]
    )
    static let uploadSessionFinishBatch = Route(
        name: "upload_session/finish_batch",
        version: 1,
        namespace: "files",
        deprecated: false,
        argSerializer: Files.UploadSessionFinishBatchArgSerializer(),
        responseSerializer: Files.UploadSessionFinishBatchLaunchSerializer(),
        errorSerializer: Serialization._VoidSerializer,
        attrs: ["auth": "user",
                "host": "api",
                "style": "rpc"]
    )
    static let uploadSessionFinishBatchCheck = Route(
        name: "upload_session/finish_batch/check",
        version: 1,
        namespace: "files",
        deprecated: false,
        argSerializer: Async.PollArgSerializer(),
        responseSerializer: Files.UploadSessionFinishBatchJobStatusSerializer(),
        errorSerializer: Async.PollErrorSerializer(),
        attrs: ["auth": "user",
                "host": "api",
                "style": "rpc"]
    )
    static let uploadSessionStart = Route(
        name: "upload_session/start",
        version: 1,
        namespace: "files",
        deprecated: false,
        argSerializer: Files.UploadSessionStartArgSerializer(),
        responseSerializer: Files.UploadSessionStartResultSerializer(),
        errorSerializer: Files.UploadSessionStartErrorSerializer(),
        attrs: ["auth": "user",
                "host": "content",
                "style": "upload"]
    )
}
