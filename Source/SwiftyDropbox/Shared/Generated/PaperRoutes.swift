///
/// Copyright (c) 2016 Dropbox, Inc. All rights reserved.
///
/// Auto-generated by Stone, do not modify.
///

/// Routes for the paper namespace
open class PaperRoutes {
    open let client: DropboxTransportClient
    init(client: DropboxTransportClient) {
        self.client = client
    }

    /// Marks the given Paper doc as archived. Note: This action can be performed or undone by anyone with edit
    /// permissions to the doc.
    ///
    /// - parameter docId: The Paper doc ID.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Void` object on success or a
    /// `Paper.DocLookupError` object on failure.
    @discardableResult open func docsArchive(docId: String) -> RpcRequest<VoidSerializer, Paper.DocLookupErrorSerializer> {
        let route = Paper.docsArchive
        let serverArgs = Paper.RefPaperDoc(docId: docId)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Creates a new Paper doc with the provided content.
    ///
    /// - parameter parentFolderId: The Paper folder ID where the Paper document should be created. The API user has to
    /// have write access to this folder or error is thrown.
    /// - parameter importFormat: The format of provided data.
    /// - parameter input: The file to upload, as an Data object.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Paper.PaperDocCreateUpdateResult` object
    /// on success or a `Paper.PaperDocCreateError` object on failure.
    @discardableResult open func docsCreate(importFormat: Paper.ImportFormat, parentFolderId: String? = nil, input: Data) -> UploadRequest<Paper.PaperDocCreateUpdateResultSerializer, Paper.PaperDocCreateErrorSerializer> {
        let route = Paper.docsCreate
        let serverArgs = Paper.PaperDocCreateArgs(importFormat: importFormat, parentFolderId: parentFolderId)
        return client.request(route, serverArgs: serverArgs, input: .data(input))
    }

    /// Creates a new Paper doc with the provided content.
    ///
    /// - parameter parentFolderId: The Paper folder ID where the Paper document should be created. The API user has to
    /// have write access to this folder or error is thrown.
    /// - parameter importFormat: The format of provided data.
    /// - parameter input: The file to upload, as an URL object.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Paper.PaperDocCreateUpdateResult` object
    /// on success or a `Paper.PaperDocCreateError` object on failure.
    @discardableResult open func docsCreate(importFormat: Paper.ImportFormat, parentFolderId: String? = nil, input: URL) -> UploadRequest<Paper.PaperDocCreateUpdateResultSerializer, Paper.PaperDocCreateErrorSerializer> {
        let route = Paper.docsCreate
        let serverArgs = Paper.PaperDocCreateArgs(importFormat: importFormat, parentFolderId: parentFolderId)
        return client.request(route, serverArgs: serverArgs, input: .file(input))
    }

    /// Creates a new Paper doc with the provided content.
    ///
    /// - parameter parentFolderId: The Paper folder ID where the Paper document should be created. The API user has to
    /// have write access to this folder or error is thrown.
    /// - parameter importFormat: The format of provided data.
    /// - parameter input: The file to upload, as an InputStream object.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Paper.PaperDocCreateUpdateResult` object
    /// on success or a `Paper.PaperDocCreateError` object on failure.
    @discardableResult open func docsCreate(importFormat: Paper.ImportFormat, parentFolderId: String? = nil, input: InputStream) -> UploadRequest<Paper.PaperDocCreateUpdateResultSerializer, Paper.PaperDocCreateErrorSerializer> {
        let route = Paper.docsCreate
        let serverArgs = Paper.PaperDocCreateArgs(importFormat: importFormat, parentFolderId: parentFolderId)
        return client.request(route, serverArgs: serverArgs, input: .stream(input))
    }

    /// Exports and downloads Paper doc either as HTML or markdown.
    ///
    /// - parameter overwrite: A boolean to set behavior in the event of a naming conflict. `True` will overwrite
    /// conflicting file at destination. `False` will take no action (but if left unhandled in destination closure, an
    /// NSError will be thrown).
    /// - parameter destination: A closure used to compute the destination, given the temporary file location and the
    /// response.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Paper.PaperDocExportResult` object on
    /// success or a `Paper.DocLookupError` object on failure.
    @discardableResult open func docsDownload(docId: String, exportFormat: Paper.ExportFormat, overwrite: Bool = false, destination: @escaping (URL, HTTPURLResponse) -> URL) -> DownloadRequestFile<Paper.PaperDocExportResultSerializer, Paper.DocLookupErrorSerializer> {
        let route = Paper.docsDownload
        let serverArgs = Paper.PaperDocExport(docId: docId, exportFormat: exportFormat)
        return client.request(route, serverArgs: serverArgs, overwrite: overwrite, destination: destination)
    }

    /// Exports and downloads Paper doc either as HTML or markdown.
    ///
    ///
    ///  - returns: Through the response callback, the caller will receive a `Paper.PaperDocExportResult` object on
    /// success or a `Paper.DocLookupError` object on failure.
    @discardableResult open func docsDownload(docId: String, exportFormat: Paper.ExportFormat) -> DownloadRequestMemory<Paper.PaperDocExportResultSerializer, Paper.DocLookupErrorSerializer> {
        let route = Paper.docsDownload
        let serverArgs = Paper.PaperDocExport(docId: docId, exportFormat: exportFormat)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Lists the users who are explicitly invited to the Paper folder in which the Paper doc is contained. For private
    /// folders all users (including owner) shared on the folder are listed and for team folders all non-team users
    /// shared on the folder are returned.
    ///
    /// - parameter limit: Size limit per batch. The maximum number of users that can be retrieved per batch is 1000.
    /// Higher value results in invalid arguments error.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Paper.ListUsersOnFolderResponse` object on
    /// success or a `Paper.DocLookupError` object on failure.
    @discardableResult open func docsFolderUsersList(docId: String, limit: Int32 = 1000) -> RpcRequest<Paper.ListUsersOnFolderResponseSerializer, Paper.DocLookupErrorSerializer> {
        let route = Paper.docsFolderUsersList
        let serverArgs = Paper.ListUsersOnFolderArgs(docId: docId, limit: limit)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Once a cursor has been retrieved from docsFolderUsersList, use this to paginate through all users on the Paper
    /// folder.
    ///
    /// - parameter cursor: The cursor obtained from docsFolderUsersList or docsFolderUsersListContinue. Allows for
    /// pagination.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Paper.ListUsersOnFolderResponse` object on
    /// success or a `Paper.ListUsersCursorError` object on failure.
    @discardableResult open func docsFolderUsersListContinue(docId: String, cursor: String) -> RpcRequest<Paper.ListUsersOnFolderResponseSerializer, Paper.ListUsersCursorErrorSerializer> {
        let route = Paper.docsFolderUsersListContinue
        let serverArgs = Paper.ListUsersOnFolderContinueArgs(docId: docId, cursor: cursor)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Retrieves folder information for the given Paper doc. This includes:   - folder sharing policy; permissions for
    /// subfolders are set by the top-level folder.   - full 'filepath', i.e. the list of folders (both folderId and
    /// folderName) from the root folder to the folder directly containing the Paper doc.  Note: If the Paper doc is not
    /// in any folder (aka unfiled) the response will be empty.
    ///
    /// - parameter docId: The Paper doc ID.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Paper.FoldersContainingPaperDoc` object on
    /// success or a `Paper.DocLookupError` object on failure.
    @discardableResult open func docsGetFolderInfo(docId: String) -> RpcRequest<Paper.FoldersContainingPaperDocSerializer, Paper.DocLookupErrorSerializer> {
        let route = Paper.docsGetFolderInfo
        let serverArgs = Paper.RefPaperDoc(docId: docId)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Return the list of all Paper docs according to the argument specifications. To iterate over through the full
    /// pagination, pass the cursor to docsListContinue.
    ///
    /// - parameter filterBy: Allows user to specify how the Paper docs should be filtered.
    /// - parameter sortBy: Allows user to specify how the Paper docs should be sorted.
    /// - parameter sortOrder: Allows user to specify the sort order of the result.
    /// - parameter limit: Size limit per batch. The maximum number of docs that can be retrieved per batch is 1000.
    /// Higher value results in invalid arguments error.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Paper.ListPaperDocsResponse` object on
    /// success or a `Void` object on failure.
    @discardableResult open func docsList(filterBy: Paper.ListPaperDocsFilterBy = .docsAccessed, sortBy: Paper.ListPaperDocsSortBy = .accessed, sortOrder: Paper.ListPaperDocsSortOrder = .ascending, limit: Int32 = 1000) -> RpcRequest<Paper.ListPaperDocsResponseSerializer, VoidSerializer> {
        let route = Paper.docsList
        let serverArgs = Paper.ListPaperDocsArgs(filterBy: filterBy, sortBy: sortBy, sortOrder: sortOrder, limit: limit)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Once a cursor has been retrieved from docsList, use this to paginate through all Paper doc.
    ///
    /// - parameter cursor: The cursor obtained from docsList or docsListContinue. Allows for pagination.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Paper.ListPaperDocsResponse` object on
    /// success or a `Paper.ListDocsCursorError` object on failure.
    @discardableResult open func docsListContinue(cursor: String) -> RpcRequest<Paper.ListPaperDocsResponseSerializer, Paper.ListDocsCursorErrorSerializer> {
        let route = Paper.docsListContinue
        let serverArgs = Paper.ListPaperDocsContinueArgs(cursor: cursor)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Permanently deletes the given Paper doc. This operation is final as the doc cannot be recovered.  Note: This
    /// action can be performed only by the doc owner.
    ///
    /// - parameter docId: The Paper doc ID.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Void` object on success or a
    /// `Paper.DocLookupError` object on failure.
    @discardableResult open func docsPermanentlyDelete(docId: String) -> RpcRequest<VoidSerializer, Paper.DocLookupErrorSerializer> {
        let route = Paper.docsPermanentlyDelete
        let serverArgs = Paper.RefPaperDoc(docId: docId)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Gets the default sharing policy for the given Paper doc.
    ///
    /// - parameter docId: The Paper doc ID.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Paper.SharingPolicy` object on success or
    /// a `Paper.DocLookupError` object on failure.
    @discardableResult open func docsSharingPolicyGet(docId: String) -> RpcRequest<Paper.SharingPolicySerializer, Paper.DocLookupErrorSerializer> {
        let route = Paper.docsSharingPolicyGet
        let serverArgs = Paper.RefPaperDoc(docId: docId)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Sets the default sharing policy for the given Paper doc. The default 'team_sharing_policy' can be changed only
    /// by teams, omit this field for personal accounts.  Note: 'public_sharing_policy' cannot be set to the value
    /// 'disabled' because this setting can be changed only via the team admin console.
    ///
    /// - parameter sharingPolicy: The default sharing policy to be set for the Paper doc.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Void` object on success or a
    /// `Paper.DocLookupError` object on failure.
    @discardableResult open func docsSharingPolicySet(docId: String, sharingPolicy: Paper.SharingPolicy) -> RpcRequest<VoidSerializer, Paper.DocLookupErrorSerializer> {
        let route = Paper.docsSharingPolicySet
        let serverArgs = Paper.PaperDocSharingPolicy(docId: docId, sharingPolicy: sharingPolicy)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Updates an existing Paper doc with the provided content.
    ///
    /// - parameter docUpdatePolicy: The policy used for the current update call.
    /// - parameter revision: The latest doc revision. This value must match the head revision or an error code will be
    /// returned. This is to prevent colliding writes.
    /// - parameter importFormat: The format of provided data.
    /// - parameter input: The file to upload, as an Data object.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Paper.PaperDocCreateUpdateResult` object
    /// on success or a `Paper.PaperDocUpdateError` object on failure.
    @discardableResult open func docsUpdate(docId: String, docUpdatePolicy: Paper.PaperDocUpdatePolicy, revision: Int64, importFormat: Paper.ImportFormat, input: Data) -> UploadRequest<Paper.PaperDocCreateUpdateResultSerializer, Paper.PaperDocUpdateErrorSerializer> {
        let route = Paper.docsUpdate
        let serverArgs = Paper.PaperDocUpdateArgs(docId: docId, docUpdatePolicy: docUpdatePolicy, revision: revision, importFormat: importFormat)
        return client.request(route, serverArgs: serverArgs, input: .data(input))
    }

    /// Updates an existing Paper doc with the provided content.
    ///
    /// - parameter docUpdatePolicy: The policy used for the current update call.
    /// - parameter revision: The latest doc revision. This value must match the head revision or an error code will be
    /// returned. This is to prevent colliding writes.
    /// - parameter importFormat: The format of provided data.
    /// - parameter input: The file to upload, as an URL object.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Paper.PaperDocCreateUpdateResult` object
    /// on success or a `Paper.PaperDocUpdateError` object on failure.
    @discardableResult open func docsUpdate(docId: String, docUpdatePolicy: Paper.PaperDocUpdatePolicy, revision: Int64, importFormat: Paper.ImportFormat, input: URL) -> UploadRequest<Paper.PaperDocCreateUpdateResultSerializer, Paper.PaperDocUpdateErrorSerializer> {
        let route = Paper.docsUpdate
        let serverArgs = Paper.PaperDocUpdateArgs(docId: docId, docUpdatePolicy: docUpdatePolicy, revision: revision, importFormat: importFormat)
        return client.request(route, serverArgs: serverArgs, input: .file(input))
    }

    /// Updates an existing Paper doc with the provided content.
    ///
    /// - parameter docUpdatePolicy: The policy used for the current update call.
    /// - parameter revision: The latest doc revision. This value must match the head revision or an error code will be
    /// returned. This is to prevent colliding writes.
    /// - parameter importFormat: The format of provided data.
    /// - parameter input: The file to upload, as an InputStream object.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Paper.PaperDocCreateUpdateResult` object
    /// on success or a `Paper.PaperDocUpdateError` object on failure.
    @discardableResult open func docsUpdate(docId: String, docUpdatePolicy: Paper.PaperDocUpdatePolicy, revision: Int64, importFormat: Paper.ImportFormat, input: InputStream) -> UploadRequest<Paper.PaperDocCreateUpdateResultSerializer, Paper.PaperDocUpdateErrorSerializer> {
        let route = Paper.docsUpdate
        let serverArgs = Paper.PaperDocUpdateArgs(docId: docId, docUpdatePolicy: docUpdatePolicy, revision: revision, importFormat: importFormat)
        return client.request(route, serverArgs: serverArgs, input: .stream(input))
    }

    /// Allows an owner or editor to add users to a Paper doc or change their permissions using their email address or
    /// Dropbox account ID.  Note: The Doc owner's permissions cannot be changed.
    ///
    /// - parameter members: User which should be added to the Paper doc. Specify only email address or Dropbox account
    /// ID.
    /// - parameter customMessage: A personal message that will be emailed to each successfully added member.
    /// - parameter quiet: Clients should set this to true if no email message shall be sent to added users.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Array<Paper.AddPaperDocUserMemberResult>`
    /// object on success or a `Paper.DocLookupError` object on failure.
    @discardableResult open func docsUsersAdd(docId: String, members: Array<Paper.AddMember>, customMessage: String? = nil, quiet: Bool = false) -> RpcRequest<ArraySerializer<Paper.AddPaperDocUserMemberResultSerializer>, Paper.DocLookupErrorSerializer> {
        let route = Paper.docsUsersAdd
        let serverArgs = Paper.AddPaperDocUser(docId: docId, members: members, customMessage: customMessage, quiet: quiet)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Lists all users who visited the Paper doc or users with explicit access. This call excludes users who have been
    /// removed. The list is sorted by the date of the visit or the share date. The list will include both users, the
    /// explicitly shared ones as well as those who came in using the Paper url link.
    ///
    /// - parameter limit: Size limit per batch. The maximum number of users that can be retrieved per batch is 1000.
    /// Higher value results in invalid arguments error.
    /// - parameter filterBy: Specify this attribute if you want to obtain users that have already accessed the Paper
    /// doc.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Paper.ListUsersOnPaperDocResponse` object
    /// on success or a `Paper.DocLookupError` object on failure.
    @discardableResult open func docsUsersList(docId: String, limit: Int32 = 1000, filterBy: Paper.UserOnPaperDocFilter = .shared) -> RpcRequest<Paper.ListUsersOnPaperDocResponseSerializer, Paper.DocLookupErrorSerializer> {
        let route = Paper.docsUsersList
        let serverArgs = Paper.ListUsersOnPaperDocArgs(docId: docId, limit: limit, filterBy: filterBy)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Once a cursor has been retrieved from docsUsersList, use this to paginate through all users on the Paper doc.
    ///
    /// - parameter cursor: The cursor obtained from docsUsersList or docsUsersListContinue. Allows for pagination.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Paper.ListUsersOnPaperDocResponse` object
    /// on success or a `Paper.ListUsersCursorError` object on failure.
    @discardableResult open func docsUsersListContinue(docId: String, cursor: String) -> RpcRequest<Paper.ListUsersOnPaperDocResponseSerializer, Paper.ListUsersCursorErrorSerializer> {
        let route = Paper.docsUsersListContinue
        let serverArgs = Paper.ListUsersOnPaperDocContinueArgs(docId: docId, cursor: cursor)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Allows an owner or editor to remove users from a Paper doc using their email address or Dropbox account ID.
    /// Note: Doc owner cannot be removed.
    ///
    /// - parameter member: User which should be removed from the Paper doc. Specify only email address or Dropbox
    /// account ID.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Void` object on success or a
    /// `Paper.DocLookupError` object on failure.
    @discardableResult open func docsUsersRemove(docId: String, member: Sharing.MemberSelector) -> RpcRequest<VoidSerializer, Paper.DocLookupErrorSerializer> {
        let route = Paper.docsUsersRemove
        let serverArgs = Paper.RemovePaperDocUser(docId: docId, member: member)
        return client.request(route, serverArgs: serverArgs)
    }

}
