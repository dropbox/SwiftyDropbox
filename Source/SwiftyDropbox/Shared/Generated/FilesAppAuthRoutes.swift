///
/// Copyright (c) 2016 Dropbox, Inc. All rights reserved.
///
/// Auto-generated by Stone, do not modify.
///

import Foundation

/// Routes for the filesAppAuth namespace
/// For Objective-C compatible routes see DBFilesRoutes
public class FilesAppAuthRoutes: DropboxTransportClientOwning {
    public let client: DropboxTransportClient
    required init(client: DropboxTransportClient) {
        self.client = client
    }

    /// Get a thumbnail for an image. This method currently supports files with the following file extensions: jpg,
    /// jpeg, png, tiff, tif, gif, webp, ppm and bmp. Photos that are larger than 20MB in size won't be converted to
    /// a thumbnail.
    ///
    /// - scope: files.content.read
    ///
    /// - parameter resource: Information specifying which file to preview. This could be a path to a file, a shared
    /// link pointing to a file, or a shared link pointing to a folder, with a relative path.
    /// - parameter format: The format for the thumbnail image, jpeg (default) or png. For  images that are photos, jpeg
    /// should be preferred, while png is  better for screenshots and digital arts.
    /// - parameter size: The size for the thumbnail image.
    /// - parameter mode: How to resize and crop the image to achieve the desired size.
    /// - parameter overwrite: A boolean to set behavior in the event of a naming conflict. `True` will overwrite
    /// conflicting file at destination. `False` will take no action (but if left unhandled in destination closure,
    /// an NSError will be thrown).
    /// - parameter destination: The location to write the download to.
    ///
    /// - returns: Through the response callback, the caller will receive a `Files.PreviewResult` object on success or a
    /// `Files.ThumbnailV2Error` object on failure.
    @discardableResult public func getThumbnailV2(
        resource: Files.PathOrLink,
        format: Files.ThumbnailFormat = .jpeg,
        size: Files.ThumbnailSize = .w64h64,
        mode: Files.ThumbnailMode = .strict,
        overwrite: Bool = false,
        destination: URL
    ) -> DownloadRequestFile<Files.PreviewResultSerializer, Files.ThumbnailV2ErrorSerializer> {
        let route = Files.getThumbnailV2
        let serverArgs = Files.ThumbnailV2Arg(resource: resource, format: format, size: size, mode: mode)
        return client.request(route, serverArgs: serverArgs, overwrite: overwrite, destination: destination)
    }

    /// Get a thumbnail for an image. This method currently supports files with the following file extensions: jpg,
    /// jpeg, png, tiff, tif, gif, webp, ppm and bmp. Photos that are larger than 20MB in size won't be converted to
    /// a thumbnail.
    ///
    /// - scope: files.content.read
    ///
    /// - parameter resource: Information specifying which file to preview. This could be a path to a file, a shared
    /// link pointing to a file, or a shared link pointing to a folder, with a relative path.
    /// - parameter format: The format for the thumbnail image, jpeg (default) or png. For  images that are photos, jpeg
    /// should be preferred, while png is  better for screenshots and digital arts.
    /// - parameter size: The size for the thumbnail image.
    /// - parameter mode: How to resize and crop the image to achieve the desired size.
    ///
    /// - returns: Through the response callback, the caller will receive a `Files.PreviewResult` object on success or a
    /// `Files.ThumbnailV2Error` object on failure.
    @discardableResult public func getThumbnailV2(
        resource: Files.PathOrLink,
        format: Files.ThumbnailFormat = .jpeg,
        size: Files.ThumbnailSize = .w64h64,
        mode: Files.ThumbnailMode = .strict
    ) -> DownloadRequestMemory<Files.PreviewResultSerializer, Files.ThumbnailV2ErrorSerializer> {
        let route = Files.getThumbnailV2
        let serverArgs = Files.ThumbnailV2Arg(resource: resource, format: format, size: size, mode: mode)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Starts returning the contents of a folder. If the result's hasMore in ListFolderResult field is true, call
    /// listFolderContinue with the returned cursor in ListFolderResult to retrieve more entries. If you're using
    /// recursive in ListFolderArg set to true to keep a local cache of the contents of a Dropbox account, iterate
    /// through each entry in order and process them as follows to keep your local state in sync: For each
    /// FileMetadata, store the new entry at the given path in your local state. If the required parent folders
    /// don't exist yet, create them. If there's already something else at the given path, replace it and remove all
    /// its children. For each FolderMetadata, store the new entry at the given path in your local state. If the
    /// required parent folders don't exist yet, create them. If there's already something else at the given path,
    /// replace it but leave the children as they are. Check the new entry's readOnly in FolderSharingInfo and set
    /// all its children's read-only statuses to match. For each DeletedMetadata, if your local state has something
    /// at the given path, remove it and all its children. If there's nothing at the given path, ignore this entry.
    /// Note: auth.RateLimitError may be returned if multiple listFolder or listFolderContinue calls with same
    /// parameters are made simultaneously by same API app for same user. If your app implements retry logic, please
    /// hold off the retry until the previous request finishes.
    ///
    /// - scope: files.metadata.read
    ///
    /// - parameter path: A unique identifier for the file.
    /// - parameter recursive: If true, the list folder operation will be applied recursively to all subfolders and the
    /// response will contain contents of all subfolders.
    /// - parameter includeMediaInfo: If true, mediaInfo in FileMetadata is set for photo and video. This parameter will
    /// no longer have an effect starting December 2, 2019.
    /// - parameter includeDeleted: If true, the results will include entries for files and folders that used to exist
    /// but were deleted.
    /// - parameter includeHasExplicitSharedMembers: If true, the results will include a flag for each file indicating
    /// whether or not  that file has any explicit members.
    /// - parameter includeMountedFolders: If true, the results will include entries under mounted folders which
    /// includes app folder, shared folder and team folder.
    /// - parameter limit: The maximum number of results to return per request. Note: This is an approximate number and
    /// there can be slightly more entries returned in some cases.
    /// - parameter sharedLink: A shared link to list the contents of. If the link is password-protected, the password
    /// must be provided. If this field is present, path in ListFolderArg will be relative to root of the shared
    /// link. Only non-recursive mode is supported for shared link.
    /// - parameter includePropertyGroups: If set to a valid list of template IDs, propertyGroups in FileMetadata is set
    /// if there exists property data associated with the file and each of the listed templates.
    /// - parameter includeNonDownloadableFiles: If true, include files that are not downloadable, i.e. Google Docs.
    ///
    /// - returns: Through the response callback, the caller will receive a `Files.ListFolderResult` object on success
    /// or a `Files.ListFolderError` object on failure.
    @discardableResult public func listFolder(
        path: String,
        recursive: Bool = false,
        includeMediaInfo: Bool = false,
        includeDeleted: Bool = false,
        includeHasExplicitSharedMembers: Bool = false,
        includeMountedFolders: Bool = true,
        limit: UInt32? = nil,
        sharedLink: Files.SharedLink? = nil,
        includePropertyGroups: FileProperties.TemplateFilterBase? = nil,
        includeNonDownloadableFiles: Bool = true
    ) -> RpcRequest<Files.ListFolderResultSerializer, Files.ListFolderErrorSerializer> {
        let route = Files.listFolder
        let serverArgs = Files.ListFolderArg(
            path: path,
            recursive: recursive,
            includeMediaInfo: includeMediaInfo,
            includeDeleted: includeDeleted,
            includeHasExplicitSharedMembers: includeHasExplicitSharedMembers,
            includeMountedFolders: includeMountedFolders,
            limit: limit,
            sharedLink: sharedLink,
            includePropertyGroups: includePropertyGroups,
            includeNonDownloadableFiles: includeNonDownloadableFiles
        )
        return client.request(route, serverArgs: serverArgs)
    }

    /// Once a cursor has been retrieved from listFolder, use this to paginate through all files and retrieve updates to
    /// the folder, following the same rules as documented for listFolder.
    ///
    /// - scope: files.metadata.read
    ///
    /// - parameter cursor: The cursor returned by your last call to listFolder or listFolderContinue.
    ///
    /// - returns: Through the response callback, the caller will receive a `Files.ListFolderResult` object on success
    /// or a `Files.ListFolderContinueError` object on failure.
    @discardableResult public func listFolderContinue(cursor: String) -> RpcRequest<Files.ListFolderResultSerializer, Files.ListFolderContinueErrorSerializer> {
        let route = Files.listFolderContinue
        let serverArgs = Files.ListFolderContinueArg(cursor: cursor)
        return client.request(route, serverArgs: serverArgs)
    }
}
