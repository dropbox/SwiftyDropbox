///
/// Copyright (c) 2016 Dropbox, Inc. All rights reserved.
///
/// Auto-generated by Stone, do not modify.
///

import Foundation

/// Datatypes and serializers for the team_log namespace
public class TeamLog {
    /// Indicates the method in which the action was performed.
    public enum AccessMethodLogInfo: CustomStringConvertible, JSONRepresentable {
        /// Admin console session details.
        case adminConsole(TeamLog.WebSessionLogInfo)
        /// Api session details.
        case api(TeamLog.ApiSessionLogInfo)
        /// Content manager session details.
        case contentManager(TeamLog.WebSessionLogInfo)
        /// End user session details.
        case endUser(TeamLog.SessionLogInfo)
        /// Enterprise console session details.
        case enterpriseConsole(TeamLog.WebSessionLogInfo)
        /// Sign in as session details.
        case signInAs(TeamLog.WebSessionLogInfo)
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try AccessMethodLogInfoSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try AccessMethodLogInfoSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for AccessMethodLogInfo: \(error)"
            }
        }
    }

    public class AccessMethodLogInfoSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: AccessMethodLogInfo) throws -> JSON {
            switch value {
            case .adminConsole(let arg):
                var d = try Serialization.getFields(TeamLog.WebSessionLogInfoSerializer().serialize(arg))
                d[".tag"] = .str("admin_console")
                return .dictionary(d)
            case .api(let arg):
                var d = try Serialization.getFields(TeamLog.ApiSessionLogInfoSerializer().serialize(arg))
                d[".tag"] = .str("api")
                return .dictionary(d)
            case .contentManager(let arg):
                var d = try Serialization.getFields(TeamLog.WebSessionLogInfoSerializer().serialize(arg))
                d[".tag"] = .str("content_manager")
                return .dictionary(d)
            case .endUser(let arg):
                var d = try ["end_user": TeamLog.SessionLogInfoSerializer().serialize(arg)]
                d[".tag"] = .str("end_user")
                return .dictionary(d)
            case .enterpriseConsole(let arg):
                var d = try Serialization.getFields(TeamLog.WebSessionLogInfoSerializer().serialize(arg))
                d[".tag"] = .str("enterprise_console")
                return .dictionary(d)
            case .signInAs(let arg):
                var d = try Serialization.getFields(TeamLog.WebSessionLogInfoSerializer().serialize(arg))
                d[".tag"] = .str("sign_in_as")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> AccessMethodLogInfo {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "admin_console":
                    let v = try TeamLog.WebSessionLogInfoSerializer().deserialize(json)
                    return AccessMethodLogInfo.adminConsole(v)
                case "api":
                    let v = try TeamLog.ApiSessionLogInfoSerializer().deserialize(json)
                    return AccessMethodLogInfo.api(v)
                case "content_manager":
                    let v = try TeamLog.WebSessionLogInfoSerializer().deserialize(json)
                    return AccessMethodLogInfo.contentManager(v)
                case "end_user":
                    let v = try TeamLog.SessionLogInfoSerializer().deserialize(d["end_user"] ?? .null)
                    return AccessMethodLogInfo.endUser(v)
                case "enterprise_console":
                    let v = try TeamLog.WebSessionLogInfoSerializer().deserialize(json)
                    return AccessMethodLogInfo.enterpriseConsole(v)
                case "sign_in_as":
                    let v = try TeamLog.WebSessionLogInfoSerializer().deserialize(json)
                    return AccessMethodLogInfo.signInAs(v)
                case "other":
                    return AccessMethodLogInfo.other
                default:
                    return AccessMethodLogInfo.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: AccessMethodLogInfo.self, json: json)
            }
        }
    }

    /// The AccountCaptureAvailability union
    public enum AccountCaptureAvailability: CustomStringConvertible, JSONRepresentable {
        /// An unspecified error.
        case available
        /// An unspecified error.
        case unavailable
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try AccountCaptureAvailabilitySerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try AccountCaptureAvailabilitySerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for AccountCaptureAvailability: \(error)"
            }
        }
    }

    public class AccountCaptureAvailabilitySerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: AccountCaptureAvailability) throws -> JSON {
            switch value {
            case .available:
                var d = [String: JSON]()
                d[".tag"] = .str("available")
                return .dictionary(d)
            case .unavailable:
                var d = [String: JSON]()
                d[".tag"] = .str("unavailable")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> AccountCaptureAvailability {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "available":
                    return AccountCaptureAvailability.available
                case "unavailable":
                    return AccountCaptureAvailability.unavailable
                case "other":
                    return AccountCaptureAvailability.other
                default:
                    return AccountCaptureAvailability.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: AccountCaptureAvailability.self, json: json)
            }
        }
    }

    /// Granted/revoked option to enable account capture on team domains.
    public class AccountCaptureChangeAvailabilityDetails: CustomStringConvertible, JSONRepresentable {
        /// New account capture availabilty value.
        public let newValue: TeamLog.AccountCaptureAvailability
        /// Previous account capture availabilty value. Might be missing due to historical data gap.
        public let previousValue: TeamLog.AccountCaptureAvailability?
        public init(newValue: TeamLog.AccountCaptureAvailability, previousValue: TeamLog.AccountCaptureAvailability? = nil) {
            self.newValue = newValue
            self.previousValue = previousValue
        }

        func json() throws -> JSON {
            try AccountCaptureChangeAvailabilityDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try AccountCaptureChangeAvailabilityDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for AccountCaptureChangeAvailabilityDetails: \(error)"
            }
        }
    }

    public class AccountCaptureChangeAvailabilityDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: AccountCaptureChangeAvailabilityDetails) throws -> JSON {
            let output = [
                "new_value": try TeamLog.AccountCaptureAvailabilitySerializer().serialize(value.newValue),
                "previous_value": try NullableSerializer(TeamLog.AccountCaptureAvailabilitySerializer()).serialize(value.previousValue),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> AccountCaptureChangeAvailabilityDetails {
            switch json {
            case .dictionary(let dict):
                let newValue = try TeamLog.AccountCaptureAvailabilitySerializer().deserialize(dict["new_value"] ?? .null)
                let previousValue = try NullableSerializer(TeamLog.AccountCaptureAvailabilitySerializer()).deserialize(dict["previous_value"] ?? .null)
                return AccountCaptureChangeAvailabilityDetails(newValue: newValue, previousValue: previousValue)
            default:
                throw JSONSerializerError.deserializeError(type: AccountCaptureChangeAvailabilityDetails.self, json: json)
            }
        }
    }

    /// The AccountCaptureChangeAvailabilityType struct
    public class AccountCaptureChangeAvailabilityType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try AccountCaptureChangeAvailabilityTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try AccountCaptureChangeAvailabilityTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for AccountCaptureChangeAvailabilityType: \(error)"
            }
        }
    }

    public class AccountCaptureChangeAvailabilityTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: AccountCaptureChangeAvailabilityType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> AccountCaptureChangeAvailabilityType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return AccountCaptureChangeAvailabilityType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: AccountCaptureChangeAvailabilityType.self, json: json)
            }
        }
    }

    /// Changed account capture setting on team domain.
    public class AccountCaptureChangePolicyDetails: CustomStringConvertible, JSONRepresentable {
        /// New account capture policy.
        public let newValue: TeamLog.AccountCapturePolicy
        /// Previous account capture policy. Might be missing due to historical data gap.
        public let previousValue: TeamLog.AccountCapturePolicy?
        public init(newValue: TeamLog.AccountCapturePolicy, previousValue: TeamLog.AccountCapturePolicy? = nil) {
            self.newValue = newValue
            self.previousValue = previousValue
        }

        func json() throws -> JSON {
            try AccountCaptureChangePolicyDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try AccountCaptureChangePolicyDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for AccountCaptureChangePolicyDetails: \(error)"
            }
        }
    }

    public class AccountCaptureChangePolicyDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: AccountCaptureChangePolicyDetails) throws -> JSON {
            let output = [
                "new_value": try TeamLog.AccountCapturePolicySerializer().serialize(value.newValue),
                "previous_value": try NullableSerializer(TeamLog.AccountCapturePolicySerializer()).serialize(value.previousValue),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> AccountCaptureChangePolicyDetails {
            switch json {
            case .dictionary(let dict):
                let newValue = try TeamLog.AccountCapturePolicySerializer().deserialize(dict["new_value"] ?? .null)
                let previousValue = try NullableSerializer(TeamLog.AccountCapturePolicySerializer()).deserialize(dict["previous_value"] ?? .null)
                return AccountCaptureChangePolicyDetails(newValue: newValue, previousValue: previousValue)
            default:
                throw JSONSerializerError.deserializeError(type: AccountCaptureChangePolicyDetails.self, json: json)
            }
        }
    }

    /// The AccountCaptureChangePolicyType struct
    public class AccountCaptureChangePolicyType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try AccountCaptureChangePolicyTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try AccountCaptureChangePolicyTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for AccountCaptureChangePolicyType: \(error)"
            }
        }
    }

    public class AccountCaptureChangePolicyTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: AccountCaptureChangePolicyType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> AccountCaptureChangePolicyType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return AccountCaptureChangePolicyType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: AccountCaptureChangePolicyType.self, json: json)
            }
        }
    }

    /// Account-captured user migrated account to team.
    public class AccountCaptureMigrateAccountDetails: CustomStringConvertible, JSONRepresentable {
        /// Domain name.
        public let domainName: String
        public init(domainName: String) {
            stringValidator()(domainName)
            self.domainName = domainName
        }

        func json() throws -> JSON {
            try AccountCaptureMigrateAccountDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try AccountCaptureMigrateAccountDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for AccountCaptureMigrateAccountDetails: \(error)"
            }
        }
    }

    public class AccountCaptureMigrateAccountDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: AccountCaptureMigrateAccountDetails) throws -> JSON {
            let output = [
                "domain_name": try Serialization._StringSerializer.serialize(value.domainName),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> AccountCaptureMigrateAccountDetails {
            switch json {
            case .dictionary(let dict):
                let domainName = try Serialization._StringSerializer.deserialize(dict["domain_name"] ?? .null)
                return AccountCaptureMigrateAccountDetails(domainName: domainName)
            default:
                throw JSONSerializerError.deserializeError(type: AccountCaptureMigrateAccountDetails.self, json: json)
            }
        }
    }

    /// The AccountCaptureMigrateAccountType struct
    public class AccountCaptureMigrateAccountType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try AccountCaptureMigrateAccountTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try AccountCaptureMigrateAccountTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for AccountCaptureMigrateAccountType: \(error)"
            }
        }
    }

    public class AccountCaptureMigrateAccountTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: AccountCaptureMigrateAccountType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> AccountCaptureMigrateAccountType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return AccountCaptureMigrateAccountType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: AccountCaptureMigrateAccountType.self, json: json)
            }
        }
    }

    /// Sent account capture email to all unmanaged members.
    public class AccountCaptureNotificationEmailsSentDetails: CustomStringConvertible, JSONRepresentable {
        /// Domain name.
        public let domainName: String
        /// Account-capture email notification type.
        public let notificationType: TeamLog.AccountCaptureNotificationType?
        public init(domainName: String, notificationType: TeamLog.AccountCaptureNotificationType? = nil) {
            stringValidator()(domainName)
            self.domainName = domainName
            self.notificationType = notificationType
        }

        func json() throws -> JSON {
            try AccountCaptureNotificationEmailsSentDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try AccountCaptureNotificationEmailsSentDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for AccountCaptureNotificationEmailsSentDetails: \(error)"
            }
        }
    }

    public class AccountCaptureNotificationEmailsSentDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: AccountCaptureNotificationEmailsSentDetails) throws -> JSON {
            let output = [
                "domain_name": try Serialization._StringSerializer.serialize(value.domainName),
                "notification_type": try NullableSerializer(TeamLog.AccountCaptureNotificationTypeSerializer()).serialize(value.notificationType),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> AccountCaptureNotificationEmailsSentDetails {
            switch json {
            case .dictionary(let dict):
                let domainName = try Serialization._StringSerializer.deserialize(dict["domain_name"] ?? .null)
                let notificationType = try NullableSerializer(TeamLog.AccountCaptureNotificationTypeSerializer())
                    .deserialize(dict["notification_type"] ?? .null)
                return AccountCaptureNotificationEmailsSentDetails(domainName: domainName, notificationType: notificationType)
            default:
                throw JSONSerializerError.deserializeError(type: AccountCaptureNotificationEmailsSentDetails.self, json: json)
            }
        }
    }

    /// The AccountCaptureNotificationEmailsSentType struct
    public class AccountCaptureNotificationEmailsSentType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try AccountCaptureNotificationEmailsSentTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try AccountCaptureNotificationEmailsSentTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for AccountCaptureNotificationEmailsSentType: \(error)"
            }
        }
    }

    public class AccountCaptureNotificationEmailsSentTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: AccountCaptureNotificationEmailsSentType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> AccountCaptureNotificationEmailsSentType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return AccountCaptureNotificationEmailsSentType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: AccountCaptureNotificationEmailsSentType.self, json: json)
            }
        }
    }

    /// The AccountCaptureNotificationType union
    public enum AccountCaptureNotificationType: CustomStringConvertible, JSONRepresentable {
        /// An unspecified error.
        case actionableNotification
        /// An unspecified error.
        case proactiveWarningNotification
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try AccountCaptureNotificationTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try AccountCaptureNotificationTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for AccountCaptureNotificationType: \(error)"
            }
        }
    }

    public class AccountCaptureNotificationTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: AccountCaptureNotificationType) throws -> JSON {
            switch value {
            case .actionableNotification:
                var d = [String: JSON]()
                d[".tag"] = .str("actionable_notification")
                return .dictionary(d)
            case .proactiveWarningNotification:
                var d = [String: JSON]()
                d[".tag"] = .str("proactive_warning_notification")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> AccountCaptureNotificationType {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "actionable_notification":
                    return AccountCaptureNotificationType.actionableNotification
                case "proactive_warning_notification":
                    return AccountCaptureNotificationType.proactiveWarningNotification
                case "other":
                    return AccountCaptureNotificationType.other
                default:
                    return AccountCaptureNotificationType.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: AccountCaptureNotificationType.self, json: json)
            }
        }
    }

    /// The AccountCapturePolicy union
    public enum AccountCapturePolicy: CustomStringConvertible, JSONRepresentable {
        /// An unspecified error.
        case allUsers
        /// An unspecified error.
        case disabled
        /// An unspecified error.
        case invitedUsers
        /// An unspecified error.
        case preventPersonalCreation
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try AccountCapturePolicySerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try AccountCapturePolicySerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for AccountCapturePolicy: \(error)"
            }
        }
    }

    public class AccountCapturePolicySerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: AccountCapturePolicy) throws -> JSON {
            switch value {
            case .allUsers:
                var d = [String: JSON]()
                d[".tag"] = .str("all_users")
                return .dictionary(d)
            case .disabled:
                var d = [String: JSON]()
                d[".tag"] = .str("disabled")
                return .dictionary(d)
            case .invitedUsers:
                var d = [String: JSON]()
                d[".tag"] = .str("invited_users")
                return .dictionary(d)
            case .preventPersonalCreation:
                var d = [String: JSON]()
                d[".tag"] = .str("prevent_personal_creation")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> AccountCapturePolicy {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "all_users":
                    return AccountCapturePolicy.allUsers
                case "disabled":
                    return AccountCapturePolicy.disabled
                case "invited_users":
                    return AccountCapturePolicy.invitedUsers
                case "prevent_personal_creation":
                    return AccountCapturePolicy.preventPersonalCreation
                case "other":
                    return AccountCapturePolicy.other
                default:
                    return AccountCapturePolicy.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: AccountCapturePolicy.self, json: json)
            }
        }
    }

    /// Account-captured user changed account email to personal email.
    public class AccountCaptureRelinquishAccountDetails: CustomStringConvertible, JSONRepresentable {
        /// Domain name.
        public let domainName: String
        public init(domainName: String) {
            stringValidator()(domainName)
            self.domainName = domainName
        }

        func json() throws -> JSON {
            try AccountCaptureRelinquishAccountDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try AccountCaptureRelinquishAccountDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for AccountCaptureRelinquishAccountDetails: \(error)"
            }
        }
    }

    public class AccountCaptureRelinquishAccountDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: AccountCaptureRelinquishAccountDetails) throws -> JSON {
            let output = [
                "domain_name": try Serialization._StringSerializer.serialize(value.domainName),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> AccountCaptureRelinquishAccountDetails {
            switch json {
            case .dictionary(let dict):
                let domainName = try Serialization._StringSerializer.deserialize(dict["domain_name"] ?? .null)
                return AccountCaptureRelinquishAccountDetails(domainName: domainName)
            default:
                throw JSONSerializerError.deserializeError(type: AccountCaptureRelinquishAccountDetails.self, json: json)
            }
        }
    }

    /// The AccountCaptureRelinquishAccountType struct
    public class AccountCaptureRelinquishAccountType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try AccountCaptureRelinquishAccountTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try AccountCaptureRelinquishAccountTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for AccountCaptureRelinquishAccountType: \(error)"
            }
        }
    }

    public class AccountCaptureRelinquishAccountTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: AccountCaptureRelinquishAccountType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> AccountCaptureRelinquishAccountType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return AccountCaptureRelinquishAccountType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: AccountCaptureRelinquishAccountType.self, json: json)
            }
        }
    }

    /// Unlocked/locked account after failed sign in attempts.
    public class AccountLockOrUnlockedDetails: CustomStringConvertible, JSONRepresentable {
        /// The previous account status.
        public let previousValue: TeamLog.AccountState
        /// The new account status.
        public let newValue: TeamLog.AccountState
        public init(previousValue: TeamLog.AccountState, newValue: TeamLog.AccountState) {
            self.previousValue = previousValue
            self.newValue = newValue
        }

        func json() throws -> JSON {
            try AccountLockOrUnlockedDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try AccountLockOrUnlockedDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for AccountLockOrUnlockedDetails: \(error)"
            }
        }
    }

    public class AccountLockOrUnlockedDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: AccountLockOrUnlockedDetails) throws -> JSON {
            let output = [
                "previous_value": try TeamLog.AccountStateSerializer().serialize(value.previousValue),
                "new_value": try TeamLog.AccountStateSerializer().serialize(value.newValue),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> AccountLockOrUnlockedDetails {
            switch json {
            case .dictionary(let dict):
                let previousValue = try TeamLog.AccountStateSerializer().deserialize(dict["previous_value"] ?? .null)
                let newValue = try TeamLog.AccountStateSerializer().deserialize(dict["new_value"] ?? .null)
                return AccountLockOrUnlockedDetails(previousValue: previousValue, newValue: newValue)
            default:
                throw JSONSerializerError.deserializeError(type: AccountLockOrUnlockedDetails.self, json: json)
            }
        }
    }

    /// The AccountLockOrUnlockedType struct
    public class AccountLockOrUnlockedType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try AccountLockOrUnlockedTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try AccountLockOrUnlockedTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for AccountLockOrUnlockedType: \(error)"
            }
        }
    }

    public class AccountLockOrUnlockedTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: AccountLockOrUnlockedType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> AccountLockOrUnlockedType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return AccountLockOrUnlockedType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: AccountLockOrUnlockedType.self, json: json)
            }
        }
    }

    /// The AccountState union
    public enum AccountState: CustomStringConvertible, JSONRepresentable {
        /// An unspecified error.
        case locked
        /// An unspecified error.
        case unlocked
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try AccountStateSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try AccountStateSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for AccountState: \(error)"
            }
        }
    }

    public class AccountStateSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: AccountState) throws -> JSON {
            switch value {
            case .locked:
                var d = [String: JSON]()
                d[".tag"] = .str("locked")
                return .dictionary(d)
            case .unlocked:
                var d = [String: JSON]()
                d[".tag"] = .str("unlocked")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> AccountState {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "locked":
                    return AccountState.locked
                case "unlocked":
                    return AccountState.unlocked
                case "other":
                    return AccountState.other
                default:
                    return AccountState.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: AccountState.self, json: json)
            }
        }
    }

    /// Additional information indicating the action taken that caused status change.
    public enum ActionDetails: CustomStringConvertible, JSONRepresentable {
        /// Define how the user was removed from the team.
        case removeAction(TeamLog.MemberRemoveActionType)
        /// Additional information relevant when someone is invited to the team.
        case teamInviteDetails(TeamLog.TeamInviteDetails)
        /// Additional information relevant when a new member joins the team.
        case teamJoinDetails(TeamLog.JoinTeamDetails)
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try ActionDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ActionDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ActionDetails: \(error)"
            }
        }
    }

    public class ActionDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ActionDetails) throws -> JSON {
            switch value {
            case .removeAction(let arg):
                var d = try ["remove_action": TeamLog.MemberRemoveActionTypeSerializer().serialize(arg)]
                d[".tag"] = .str("remove_action")
                return .dictionary(d)
            case .teamInviteDetails(let arg):
                var d = try Serialization.getFields(TeamLog.TeamInviteDetailsSerializer().serialize(arg))
                d[".tag"] = .str("team_invite_details")
                return .dictionary(d)
            case .teamJoinDetails(let arg):
                var d = try Serialization.getFields(TeamLog.JoinTeamDetailsSerializer().serialize(arg))
                d[".tag"] = .str("team_join_details")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> ActionDetails {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "remove_action":
                    let v = try TeamLog.MemberRemoveActionTypeSerializer().deserialize(d["remove_action"] ?? .null)
                    return ActionDetails.removeAction(v)
                case "team_invite_details":
                    let v = try TeamLog.TeamInviteDetailsSerializer().deserialize(json)
                    return ActionDetails.teamInviteDetails(v)
                case "team_join_details":
                    let v = try TeamLog.JoinTeamDetailsSerializer().deserialize(json)
                    return ActionDetails.teamJoinDetails(v)
                case "other":
                    return ActionDetails.other
                default:
                    return ActionDetails.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: ActionDetails.self, json: json)
            }
        }
    }

    /// The entity who performed the action.
    public enum ActorLogInfo: CustomStringConvertible, JSONRepresentable {
        /// The admin who did the action.
        case admin(TeamLog.UserLogInfo)
        /// Anonymous actor.
        case anonymous
        /// The application who did the action.
        case app(TeamLog.AppLogInfo)
        /// Action done by Dropbox.
        case dropbox
        /// Action done by reseller.
        case reseller(TeamLog.ResellerLogInfo)
        /// The user who did the action.
        case user(TeamLog.UserLogInfo)
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try ActorLogInfoSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ActorLogInfoSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ActorLogInfo: \(error)"
            }
        }
    }

    public class ActorLogInfoSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ActorLogInfo) throws -> JSON {
            switch value {
            case .admin(let arg):
                var d = try ["admin": TeamLog.UserLogInfoSerializer().serialize(arg)]
                d[".tag"] = .str("admin")
                return .dictionary(d)
            case .anonymous:
                var d = [String: JSON]()
                d[".tag"] = .str("anonymous")
                return .dictionary(d)
            case .app(let arg):
                var d = try ["app": TeamLog.AppLogInfoSerializer().serialize(arg)]
                d[".tag"] = .str("app")
                return .dictionary(d)
            case .dropbox:
                var d = [String: JSON]()
                d[".tag"] = .str("dropbox")
                return .dictionary(d)
            case .reseller(let arg):
                var d = try Serialization.getFields(TeamLog.ResellerLogInfoSerializer().serialize(arg))
                d[".tag"] = .str("reseller")
                return .dictionary(d)
            case .user(let arg):
                var d = try ["user": TeamLog.UserLogInfoSerializer().serialize(arg)]
                d[".tag"] = .str("user")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> ActorLogInfo {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "admin":
                    let v = try TeamLog.UserLogInfoSerializer().deserialize(d["admin"] ?? .null)
                    return ActorLogInfo.admin(v)
                case "anonymous":
                    return ActorLogInfo.anonymous
                case "app":
                    let v = try TeamLog.AppLogInfoSerializer().deserialize(d["app"] ?? .null)
                    return ActorLogInfo.app(v)
                case "dropbox":
                    return ActorLogInfo.dropbox
                case "reseller":
                    let v = try TeamLog.ResellerLogInfoSerializer().deserialize(json)
                    return ActorLogInfo.reseller(v)
                case "user":
                    let v = try TeamLog.UserLogInfoSerializer().deserialize(d["user"] ?? .null)
                    return ActorLogInfo.user(v)
                case "other":
                    return ActorLogInfo.other
                default:
                    return ActorLogInfo.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: ActorLogInfo.self, json: json)
            }
        }
    }

    /// Alert category
    public enum AdminAlertCategoryEnum: CustomStringConvertible, JSONRepresentable {
        /// An unspecified error.
        case accountTakeover
        /// An unspecified error.
        case dataLossProtection
        /// An unspecified error.
        case informationGovernance
        /// An unspecified error.
        case malwareSharing
        /// An unspecified error.
        case massiveFileOperation
        /// An unspecified error.
        case na
        /// An unspecified error.
        case threatManagement
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try AdminAlertCategoryEnumSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try AdminAlertCategoryEnumSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for AdminAlertCategoryEnum: \(error)"
            }
        }
    }

    public class AdminAlertCategoryEnumSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: AdminAlertCategoryEnum) throws -> JSON {
            switch value {
            case .accountTakeover:
                var d = [String: JSON]()
                d[".tag"] = .str("account_takeover")
                return .dictionary(d)
            case .dataLossProtection:
                var d = [String: JSON]()
                d[".tag"] = .str("data_loss_protection")
                return .dictionary(d)
            case .informationGovernance:
                var d = [String: JSON]()
                d[".tag"] = .str("information_governance")
                return .dictionary(d)
            case .malwareSharing:
                var d = [String: JSON]()
                d[".tag"] = .str("malware_sharing")
                return .dictionary(d)
            case .massiveFileOperation:
                var d = [String: JSON]()
                d[".tag"] = .str("massive_file_operation")
                return .dictionary(d)
            case .na:
                var d = [String: JSON]()
                d[".tag"] = .str("na")
                return .dictionary(d)
            case .threatManagement:
                var d = [String: JSON]()
                d[".tag"] = .str("threat_management")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> AdminAlertCategoryEnum {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "account_takeover":
                    return AdminAlertCategoryEnum.accountTakeover
                case "data_loss_protection":
                    return AdminAlertCategoryEnum.dataLossProtection
                case "information_governance":
                    return AdminAlertCategoryEnum.informationGovernance
                case "malware_sharing":
                    return AdminAlertCategoryEnum.malwareSharing
                case "massive_file_operation":
                    return AdminAlertCategoryEnum.massiveFileOperation
                case "na":
                    return AdminAlertCategoryEnum.na
                case "threat_management":
                    return AdminAlertCategoryEnum.threatManagement
                case "other":
                    return AdminAlertCategoryEnum.other
                default:
                    return AdminAlertCategoryEnum.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: AdminAlertCategoryEnum.self, json: json)
            }
        }
    }

    /// Alert state
    public enum AdminAlertGeneralStateEnum: CustomStringConvertible, JSONRepresentable {
        /// An unspecified error.
        case active
        /// An unspecified error.
        case dismissed
        /// An unspecified error.
        case inProgress
        /// An unspecified error.
        case na
        /// An unspecified error.
        case resolved
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try AdminAlertGeneralStateEnumSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try AdminAlertGeneralStateEnumSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for AdminAlertGeneralStateEnum: \(error)"
            }
        }
    }

    public class AdminAlertGeneralStateEnumSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: AdminAlertGeneralStateEnum) throws -> JSON {
            switch value {
            case .active:
                var d = [String: JSON]()
                d[".tag"] = .str("active")
                return .dictionary(d)
            case .dismissed:
                var d = [String: JSON]()
                d[".tag"] = .str("dismissed")
                return .dictionary(d)
            case .inProgress:
                var d = [String: JSON]()
                d[".tag"] = .str("in_progress")
                return .dictionary(d)
            case .na:
                var d = [String: JSON]()
                d[".tag"] = .str("na")
                return .dictionary(d)
            case .resolved:
                var d = [String: JSON]()
                d[".tag"] = .str("resolved")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> AdminAlertGeneralStateEnum {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "active":
                    return AdminAlertGeneralStateEnum.active
                case "dismissed":
                    return AdminAlertGeneralStateEnum.dismissed
                case "in_progress":
                    return AdminAlertGeneralStateEnum.inProgress
                case "na":
                    return AdminAlertGeneralStateEnum.na
                case "resolved":
                    return AdminAlertGeneralStateEnum.resolved
                case "other":
                    return AdminAlertGeneralStateEnum.other
                default:
                    return AdminAlertGeneralStateEnum.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: AdminAlertGeneralStateEnum.self, json: json)
            }
        }
    }

    /// Alert severity
    public enum AdminAlertSeverityEnum: CustomStringConvertible, JSONRepresentable {
        /// An unspecified error.
        case high
        /// An unspecified error.
        case info
        /// An unspecified error.
        case low
        /// An unspecified error.
        case medium
        /// An unspecified error.
        case na
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try AdminAlertSeverityEnumSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try AdminAlertSeverityEnumSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for AdminAlertSeverityEnum: \(error)"
            }
        }
    }

    public class AdminAlertSeverityEnumSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: AdminAlertSeverityEnum) throws -> JSON {
            switch value {
            case .high:
                var d = [String: JSON]()
                d[".tag"] = .str("high")
                return .dictionary(d)
            case .info:
                var d = [String: JSON]()
                d[".tag"] = .str("info")
                return .dictionary(d)
            case .low:
                var d = [String: JSON]()
                d[".tag"] = .str("low")
                return .dictionary(d)
            case .medium:
                var d = [String: JSON]()
                d[".tag"] = .str("medium")
                return .dictionary(d)
            case .na:
                var d = [String: JSON]()
                d[".tag"] = .str("na")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> AdminAlertSeverityEnum {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "high":
                    return AdminAlertSeverityEnum.high
                case "info":
                    return AdminAlertSeverityEnum.info
                case "low":
                    return AdminAlertSeverityEnum.low
                case "medium":
                    return AdminAlertSeverityEnum.medium
                case "na":
                    return AdminAlertSeverityEnum.na
                case "other":
                    return AdminAlertSeverityEnum.other
                default:
                    return AdminAlertSeverityEnum.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: AdminAlertSeverityEnum.self, json: json)
            }
        }
    }

    /// Alert configurations
    public class AdminAlertingAlertConfiguration: CustomStringConvertible, JSONRepresentable {
        /// Alert state.
        public let alertState: TeamLog.AdminAlertingAlertStatePolicy?
        /// Sensitivity level.
        public let sensitivityLevel: TeamLog.AdminAlertingAlertSensitivity?
        /// Recipient settings.
        public let recipientsSettings: TeamLog.RecipientsConfiguration?
        /// Text.
        public let text: String?
        /// Excluded file extensions.
        public let excludedFileExtensions: String?
        public init(
            alertState: TeamLog.AdminAlertingAlertStatePolicy? = nil,
            sensitivityLevel: TeamLog.AdminAlertingAlertSensitivity? = nil,
            recipientsSettings: TeamLog.RecipientsConfiguration? = nil,
            text: String? = nil,
            excludedFileExtensions: String? = nil
        ) {
            self.alertState = alertState
            self.sensitivityLevel = sensitivityLevel
            self.recipientsSettings = recipientsSettings
            nullableValidator(stringValidator())(text)
            self.text = text
            nullableValidator(stringValidator())(excludedFileExtensions)
            self.excludedFileExtensions = excludedFileExtensions
        }

        func json() throws -> JSON {
            try AdminAlertingAlertConfigurationSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try AdminAlertingAlertConfigurationSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for AdminAlertingAlertConfiguration: \(error)"
            }
        }
    }

    public class AdminAlertingAlertConfigurationSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: AdminAlertingAlertConfiguration) throws -> JSON {
            let output = [
                "alert_state": try NullableSerializer(TeamLog.AdminAlertingAlertStatePolicySerializer()).serialize(value.alertState),
                "sensitivity_level": try NullableSerializer(TeamLog.AdminAlertingAlertSensitivitySerializer()).serialize(value.sensitivityLevel),
                "recipients_settings": try NullableSerializer(TeamLog.RecipientsConfigurationSerializer()).serialize(value.recipientsSettings),
                "text": try NullableSerializer(Serialization._StringSerializer).serialize(value.text),
                "excluded_file_extensions": try NullableSerializer(Serialization._StringSerializer).serialize(value.excludedFileExtensions),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> AdminAlertingAlertConfiguration {
            switch json {
            case .dictionary(let dict):
                let alertState = try NullableSerializer(TeamLog.AdminAlertingAlertStatePolicySerializer()).deserialize(dict["alert_state"] ?? .null)
                let sensitivityLevel = try NullableSerializer(TeamLog.AdminAlertingAlertSensitivitySerializer())
                    .deserialize(dict["sensitivity_level"] ?? .null)
                let recipientsSettings = try NullableSerializer(TeamLog.RecipientsConfigurationSerializer())
                    .deserialize(dict["recipients_settings"] ?? .null)
                let text = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["text"] ?? .null)
                let excludedFileExtensions = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["excluded_file_extensions"] ?? .null)
                return AdminAlertingAlertConfiguration(
                    alertState: alertState,
                    sensitivityLevel: sensitivityLevel,
                    recipientsSettings: recipientsSettings,
                    text: text,
                    excludedFileExtensions: excludedFileExtensions
                )
            default:
                throw JSONSerializerError.deserializeError(type: AdminAlertingAlertConfiguration.self, json: json)
            }
        }
    }

    /// Alert sensitivity
    public enum AdminAlertingAlertSensitivity: CustomStringConvertible, JSONRepresentable {
        /// An unspecified error.
        case high
        /// An unspecified error.
        case highest
        /// An unspecified error.
        case invalid
        /// An unspecified error.
        case low
        /// An unspecified error.
        case lowest
        /// An unspecified error.
        case medium
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try AdminAlertingAlertSensitivitySerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try AdminAlertingAlertSensitivitySerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for AdminAlertingAlertSensitivity: \(error)"
            }
        }
    }

    public class AdminAlertingAlertSensitivitySerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: AdminAlertingAlertSensitivity) throws -> JSON {
            switch value {
            case .high:
                var d = [String: JSON]()
                d[".tag"] = .str("high")
                return .dictionary(d)
            case .highest:
                var d = [String: JSON]()
                d[".tag"] = .str("highest")
                return .dictionary(d)
            case .invalid:
                var d = [String: JSON]()
                d[".tag"] = .str("invalid")
                return .dictionary(d)
            case .low:
                var d = [String: JSON]()
                d[".tag"] = .str("low")
                return .dictionary(d)
            case .lowest:
                var d = [String: JSON]()
                d[".tag"] = .str("lowest")
                return .dictionary(d)
            case .medium:
                var d = [String: JSON]()
                d[".tag"] = .str("medium")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> AdminAlertingAlertSensitivity {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "high":
                    return AdminAlertingAlertSensitivity.high
                case "highest":
                    return AdminAlertingAlertSensitivity.highest
                case "invalid":
                    return AdminAlertingAlertSensitivity.invalid
                case "low":
                    return AdminAlertingAlertSensitivity.low
                case "lowest":
                    return AdminAlertingAlertSensitivity.lowest
                case "medium":
                    return AdminAlertingAlertSensitivity.medium
                case "other":
                    return AdminAlertingAlertSensitivity.other
                default:
                    return AdminAlertingAlertSensitivity.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: AdminAlertingAlertSensitivity.self, json: json)
            }
        }
    }

    /// Changed an alert state.
    public class AdminAlertingAlertStateChangedDetails: CustomStringConvertible, JSONRepresentable {
        /// Alert name.
        public let alertName: String
        /// Alert severity.
        public let alertSeverity: TeamLog.AdminAlertSeverityEnum
        /// Alert category.
        public let alertCategory: TeamLog.AdminAlertCategoryEnum
        /// Alert ID.
        public let alertInstanceId: String
        /// Alert state before the change.
        public let previousValue: TeamLog.AdminAlertGeneralStateEnum
        /// Alert state after the change.
        public let newValue: TeamLog.AdminAlertGeneralStateEnum
        public init(
            alertName: String,
            alertSeverity: TeamLog.AdminAlertSeverityEnum,
            alertCategory: TeamLog.AdminAlertCategoryEnum,
            alertInstanceId: String,
            previousValue: TeamLog.AdminAlertGeneralStateEnum,
            newValue: TeamLog.AdminAlertGeneralStateEnum
        ) {
            stringValidator()(alertName)
            self.alertName = alertName
            self.alertSeverity = alertSeverity
            self.alertCategory = alertCategory
            stringValidator()(alertInstanceId)
            self.alertInstanceId = alertInstanceId
            self.previousValue = previousValue
            self.newValue = newValue
        }

        func json() throws -> JSON {
            try AdminAlertingAlertStateChangedDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try AdminAlertingAlertStateChangedDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for AdminAlertingAlertStateChangedDetails: \(error)"
            }
        }
    }

    public class AdminAlertingAlertStateChangedDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: AdminAlertingAlertStateChangedDetails) throws -> JSON {
            let output = [
                "alert_name": try Serialization._StringSerializer.serialize(value.alertName),
                "alert_severity": try TeamLog.AdminAlertSeverityEnumSerializer().serialize(value.alertSeverity),
                "alert_category": try TeamLog.AdminAlertCategoryEnumSerializer().serialize(value.alertCategory),
                "alert_instance_id": try Serialization._StringSerializer.serialize(value.alertInstanceId),
                "previous_value": try TeamLog.AdminAlertGeneralStateEnumSerializer().serialize(value.previousValue),
                "new_value": try TeamLog.AdminAlertGeneralStateEnumSerializer().serialize(value.newValue),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> AdminAlertingAlertStateChangedDetails {
            switch json {
            case .dictionary(let dict):
                let alertName = try Serialization._StringSerializer.deserialize(dict["alert_name"] ?? .null)
                let alertSeverity = try TeamLog.AdminAlertSeverityEnumSerializer().deserialize(dict["alert_severity"] ?? .null)
                let alertCategory = try TeamLog.AdminAlertCategoryEnumSerializer().deserialize(dict["alert_category"] ?? .null)
                let alertInstanceId = try Serialization._StringSerializer.deserialize(dict["alert_instance_id"] ?? .null)
                let previousValue = try TeamLog.AdminAlertGeneralStateEnumSerializer().deserialize(dict["previous_value"] ?? .null)
                let newValue = try TeamLog.AdminAlertGeneralStateEnumSerializer().deserialize(dict["new_value"] ?? .null)
                return AdminAlertingAlertStateChangedDetails(
                    alertName: alertName,
                    alertSeverity: alertSeverity,
                    alertCategory: alertCategory,
                    alertInstanceId: alertInstanceId,
                    previousValue: previousValue,
                    newValue: newValue
                )
            default:
                throw JSONSerializerError.deserializeError(type: AdminAlertingAlertStateChangedDetails.self, json: json)
            }
        }
    }

    /// The AdminAlertingAlertStateChangedType struct
    public class AdminAlertingAlertStateChangedType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try AdminAlertingAlertStateChangedTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try AdminAlertingAlertStateChangedTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for AdminAlertingAlertStateChangedType: \(error)"
            }
        }
    }

    public class AdminAlertingAlertStateChangedTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: AdminAlertingAlertStateChangedType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> AdminAlertingAlertStateChangedType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return AdminAlertingAlertStateChangedType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: AdminAlertingAlertStateChangedType.self, json: json)
            }
        }
    }

    /// Policy for controlling whether an alert can be triggered or not
    public enum AdminAlertingAlertStatePolicy: CustomStringConvertible, JSONRepresentable {
        /// An unspecified error.
        case off
        /// An unspecified error.
        case on
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try AdminAlertingAlertStatePolicySerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try AdminAlertingAlertStatePolicySerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for AdminAlertingAlertStatePolicy: \(error)"
            }
        }
    }

    public class AdminAlertingAlertStatePolicySerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: AdminAlertingAlertStatePolicy) throws -> JSON {
            switch value {
            case .off:
                var d = [String: JSON]()
                d[".tag"] = .str("off")
                return .dictionary(d)
            case .on:
                var d = [String: JSON]()
                d[".tag"] = .str("on")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> AdminAlertingAlertStatePolicy {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "off":
                    return AdminAlertingAlertStatePolicy.off
                case "on":
                    return AdminAlertingAlertStatePolicy.on
                case "other":
                    return AdminAlertingAlertStatePolicy.other
                default:
                    return AdminAlertingAlertStatePolicy.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: AdminAlertingAlertStatePolicy.self, json: json)
            }
        }
    }

    /// Changed an alert setting.
    public class AdminAlertingChangedAlertConfigDetails: CustomStringConvertible, JSONRepresentable {
        /// Alert Name.
        public let alertName: String
        /// Previous alert configuration.
        public let previousAlertConfig: TeamLog.AdminAlertingAlertConfiguration
        /// New alert configuration.
        public let newAlertConfig: TeamLog.AdminAlertingAlertConfiguration
        public init(alertName: String, previousAlertConfig: TeamLog.AdminAlertingAlertConfiguration, newAlertConfig: TeamLog.AdminAlertingAlertConfiguration) {
            stringValidator()(alertName)
            self.alertName = alertName
            self.previousAlertConfig = previousAlertConfig
            self.newAlertConfig = newAlertConfig
        }

        func json() throws -> JSON {
            try AdminAlertingChangedAlertConfigDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try AdminAlertingChangedAlertConfigDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for AdminAlertingChangedAlertConfigDetails: \(error)"
            }
        }
    }

    public class AdminAlertingChangedAlertConfigDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: AdminAlertingChangedAlertConfigDetails) throws -> JSON {
            let output = [
                "alert_name": try Serialization._StringSerializer.serialize(value.alertName),
                "previous_alert_config": try TeamLog.AdminAlertingAlertConfigurationSerializer().serialize(value.previousAlertConfig),
                "new_alert_config": try TeamLog.AdminAlertingAlertConfigurationSerializer().serialize(value.newAlertConfig),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> AdminAlertingChangedAlertConfigDetails {
            switch json {
            case .dictionary(let dict):
                let alertName = try Serialization._StringSerializer.deserialize(dict["alert_name"] ?? .null)
                let previousAlertConfig = try TeamLog.AdminAlertingAlertConfigurationSerializer().deserialize(dict["previous_alert_config"] ?? .null)
                let newAlertConfig = try TeamLog.AdminAlertingAlertConfigurationSerializer().deserialize(dict["new_alert_config"] ?? .null)
                return AdminAlertingChangedAlertConfigDetails(
                    alertName: alertName,
                    previousAlertConfig: previousAlertConfig,
                    newAlertConfig: newAlertConfig
                )
            default:
                throw JSONSerializerError.deserializeError(type: AdminAlertingChangedAlertConfigDetails.self, json: json)
            }
        }
    }

    /// The AdminAlertingChangedAlertConfigType struct
    public class AdminAlertingChangedAlertConfigType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try AdminAlertingChangedAlertConfigTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try AdminAlertingChangedAlertConfigTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for AdminAlertingChangedAlertConfigType: \(error)"
            }
        }
    }

    public class AdminAlertingChangedAlertConfigTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: AdminAlertingChangedAlertConfigType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> AdminAlertingChangedAlertConfigType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return AdminAlertingChangedAlertConfigType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: AdminAlertingChangedAlertConfigType.self, json: json)
            }
        }
    }

    /// Triggered security alert.
    public class AdminAlertingTriggeredAlertDetails: CustomStringConvertible, JSONRepresentable {
        /// Alert name.
        public let alertName: String
        /// Alert severity.
        public let alertSeverity: TeamLog.AdminAlertSeverityEnum
        /// Alert category.
        public let alertCategory: TeamLog.AdminAlertCategoryEnum
        /// Alert ID.
        public let alertInstanceId: String
        public init(alertName: String, alertSeverity: TeamLog.AdminAlertSeverityEnum, alertCategory: TeamLog.AdminAlertCategoryEnum, alertInstanceId: String) {
            stringValidator()(alertName)
            self.alertName = alertName
            self.alertSeverity = alertSeverity
            self.alertCategory = alertCategory
            stringValidator()(alertInstanceId)
            self.alertInstanceId = alertInstanceId
        }

        func json() throws -> JSON {
            try AdminAlertingTriggeredAlertDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try AdminAlertingTriggeredAlertDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for AdminAlertingTriggeredAlertDetails: \(error)"
            }
        }
    }

    public class AdminAlertingTriggeredAlertDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: AdminAlertingTriggeredAlertDetails) throws -> JSON {
            let output = [
                "alert_name": try Serialization._StringSerializer.serialize(value.alertName),
                "alert_severity": try TeamLog.AdminAlertSeverityEnumSerializer().serialize(value.alertSeverity),
                "alert_category": try TeamLog.AdminAlertCategoryEnumSerializer().serialize(value.alertCategory),
                "alert_instance_id": try Serialization._StringSerializer.serialize(value.alertInstanceId),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> AdminAlertingTriggeredAlertDetails {
            switch json {
            case .dictionary(let dict):
                let alertName = try Serialization._StringSerializer.deserialize(dict["alert_name"] ?? .null)
                let alertSeverity = try TeamLog.AdminAlertSeverityEnumSerializer().deserialize(dict["alert_severity"] ?? .null)
                let alertCategory = try TeamLog.AdminAlertCategoryEnumSerializer().deserialize(dict["alert_category"] ?? .null)
                let alertInstanceId = try Serialization._StringSerializer.deserialize(dict["alert_instance_id"] ?? .null)
                return AdminAlertingTriggeredAlertDetails(
                    alertName: alertName,
                    alertSeverity: alertSeverity,
                    alertCategory: alertCategory,
                    alertInstanceId: alertInstanceId
                )
            default:
                throw JSONSerializerError.deserializeError(type: AdminAlertingTriggeredAlertDetails.self, json: json)
            }
        }
    }

    /// The AdminAlertingTriggeredAlertType struct
    public class AdminAlertingTriggeredAlertType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try AdminAlertingTriggeredAlertTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try AdminAlertingTriggeredAlertTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for AdminAlertingTriggeredAlertType: \(error)"
            }
        }
    }

    public class AdminAlertingTriggeredAlertTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: AdminAlertingTriggeredAlertType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> AdminAlertingTriggeredAlertType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return AdminAlertingTriggeredAlertType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: AdminAlertingTriggeredAlertType.self, json: json)
            }
        }
    }

    /// The AdminConsoleAppPermission union
    public enum AdminConsoleAppPermission: CustomStringConvertible, JSONRepresentable {
        /// An unspecified error.
        case defaultForListedApps
        /// An unspecified error.
        case defaultForUnlistedApps
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try AdminConsoleAppPermissionSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try AdminConsoleAppPermissionSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for AdminConsoleAppPermission: \(error)"
            }
        }
    }

    public class AdminConsoleAppPermissionSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: AdminConsoleAppPermission) throws -> JSON {
            switch value {
            case .defaultForListedApps:
                var d = [String: JSON]()
                d[".tag"] = .str("default_for_listed_apps")
                return .dictionary(d)
            case .defaultForUnlistedApps:
                var d = [String: JSON]()
                d[".tag"] = .str("default_for_unlisted_apps")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> AdminConsoleAppPermission {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "default_for_listed_apps":
                    return AdminConsoleAppPermission.defaultForListedApps
                case "default_for_unlisted_apps":
                    return AdminConsoleAppPermission.defaultForUnlistedApps
                case "other":
                    return AdminConsoleAppPermission.other
                default:
                    return AdminConsoleAppPermission.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: AdminConsoleAppPermission.self, json: json)
            }
        }
    }

    /// The AdminConsoleAppPolicy union
    public enum AdminConsoleAppPolicy: CustomStringConvertible, JSONRepresentable {
        /// An unspecified error.
        case allow
        /// An unspecified error.
        case block
        /// An unspecified error.
        case default_
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try AdminConsoleAppPolicySerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try AdminConsoleAppPolicySerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for AdminConsoleAppPolicy: \(error)"
            }
        }
    }

    public class AdminConsoleAppPolicySerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: AdminConsoleAppPolicy) throws -> JSON {
            switch value {
            case .allow:
                var d = [String: JSON]()
                d[".tag"] = .str("allow")
                return .dictionary(d)
            case .block:
                var d = [String: JSON]()
                d[".tag"] = .str("block")
                return .dictionary(d)
            case .default_:
                var d = [String: JSON]()
                d[".tag"] = .str("default")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> AdminConsoleAppPolicy {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "allow":
                    return AdminConsoleAppPolicy.allow
                case "block":
                    return AdminConsoleAppPolicy.block
                case "default":
                    return AdminConsoleAppPolicy.default_
                case "other":
                    return AdminConsoleAppPolicy.other
                default:
                    return AdminConsoleAppPolicy.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: AdminConsoleAppPolicy.self, json: json)
            }
        }
    }

    /// Changed admin reminder settings for requests to join the team.
    public class AdminEmailRemindersChangedDetails: CustomStringConvertible, JSONRepresentable {
        /// To.
        public let newValue: TeamLog.AdminEmailRemindersPolicy
        /// From.
        public let previousValue: TeamLog.AdminEmailRemindersPolicy
        public init(newValue: TeamLog.AdminEmailRemindersPolicy, previousValue: TeamLog.AdminEmailRemindersPolicy) {
            self.newValue = newValue
            self.previousValue = previousValue
        }

        func json() throws -> JSON {
            try AdminEmailRemindersChangedDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try AdminEmailRemindersChangedDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for AdminEmailRemindersChangedDetails: \(error)"
            }
        }
    }

    public class AdminEmailRemindersChangedDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: AdminEmailRemindersChangedDetails) throws -> JSON {
            let output = [
                "new_value": try TeamLog.AdminEmailRemindersPolicySerializer().serialize(value.newValue),
                "previous_value": try TeamLog.AdminEmailRemindersPolicySerializer().serialize(value.previousValue),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> AdminEmailRemindersChangedDetails {
            switch json {
            case .dictionary(let dict):
                let newValue = try TeamLog.AdminEmailRemindersPolicySerializer().deserialize(dict["new_value"] ?? .null)
                let previousValue = try TeamLog.AdminEmailRemindersPolicySerializer().deserialize(dict["previous_value"] ?? .null)
                return AdminEmailRemindersChangedDetails(newValue: newValue, previousValue: previousValue)
            default:
                throw JSONSerializerError.deserializeError(type: AdminEmailRemindersChangedDetails.self, json: json)
            }
        }
    }

    /// The AdminEmailRemindersChangedType struct
    public class AdminEmailRemindersChangedType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try AdminEmailRemindersChangedTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try AdminEmailRemindersChangedTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for AdminEmailRemindersChangedType: \(error)"
            }
        }
    }

    public class AdminEmailRemindersChangedTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: AdminEmailRemindersChangedType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> AdminEmailRemindersChangedType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return AdminEmailRemindersChangedType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: AdminEmailRemindersChangedType.self, json: json)
            }
        }
    }

    /// Policy for deciding whether team admins receive reminder emails for requests to join the team
    public enum AdminEmailRemindersPolicy: CustomStringConvertible, JSONRepresentable {
        /// An unspecified error.
        case default_
        /// An unspecified error.
        case disabled
        /// An unspecified error.
        case enabled
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try AdminEmailRemindersPolicySerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try AdminEmailRemindersPolicySerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for AdminEmailRemindersPolicy: \(error)"
            }
        }
    }

    public class AdminEmailRemindersPolicySerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: AdminEmailRemindersPolicy) throws -> JSON {
            switch value {
            case .default_:
                var d = [String: JSON]()
                d[".tag"] = .str("default")
                return .dictionary(d)
            case .disabled:
                var d = [String: JSON]()
                d[".tag"] = .str("disabled")
                return .dictionary(d)
            case .enabled:
                var d = [String: JSON]()
                d[".tag"] = .str("enabled")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> AdminEmailRemindersPolicy {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "default":
                    return AdminEmailRemindersPolicy.default_
                case "disabled":
                    return AdminEmailRemindersPolicy.disabled
                case "enabled":
                    return AdminEmailRemindersPolicy.enabled
                case "other":
                    return AdminEmailRemindersPolicy.other
                default:
                    return AdminEmailRemindersPolicy.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: AdminEmailRemindersPolicy.self, json: json)
            }
        }
    }

    /// The AdminRole union
    public enum AdminRole: CustomStringConvertible, JSONRepresentable {
        /// An unspecified error.
        case billingAdmin
        /// An unspecified error.
        case complianceAdmin
        /// An unspecified error.
        case contentAdmin
        /// An unspecified error.
        case limitedAdmin
        /// An unspecified error.
        case memberOnly
        /// An unspecified error.
        case reportingAdmin
        /// An unspecified error.
        case securityAdmin
        /// An unspecified error.
        case supportAdmin
        /// An unspecified error.
        case teamAdmin
        /// An unspecified error.
        case userManagementAdmin
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try AdminRoleSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try AdminRoleSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for AdminRole: \(error)"
            }
        }
    }

    public class AdminRoleSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: AdminRole) throws -> JSON {
            switch value {
            case .billingAdmin:
                var d = [String: JSON]()
                d[".tag"] = .str("billing_admin")
                return .dictionary(d)
            case .complianceAdmin:
                var d = [String: JSON]()
                d[".tag"] = .str("compliance_admin")
                return .dictionary(d)
            case .contentAdmin:
                var d = [String: JSON]()
                d[".tag"] = .str("content_admin")
                return .dictionary(d)
            case .limitedAdmin:
                var d = [String: JSON]()
                d[".tag"] = .str("limited_admin")
                return .dictionary(d)
            case .memberOnly:
                var d = [String: JSON]()
                d[".tag"] = .str("member_only")
                return .dictionary(d)
            case .reportingAdmin:
                var d = [String: JSON]()
                d[".tag"] = .str("reporting_admin")
                return .dictionary(d)
            case .securityAdmin:
                var d = [String: JSON]()
                d[".tag"] = .str("security_admin")
                return .dictionary(d)
            case .supportAdmin:
                var d = [String: JSON]()
                d[".tag"] = .str("support_admin")
                return .dictionary(d)
            case .teamAdmin:
                var d = [String: JSON]()
                d[".tag"] = .str("team_admin")
                return .dictionary(d)
            case .userManagementAdmin:
                var d = [String: JSON]()
                d[".tag"] = .str("user_management_admin")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> AdminRole {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "billing_admin":
                    return AdminRole.billingAdmin
                case "compliance_admin":
                    return AdminRole.complianceAdmin
                case "content_admin":
                    return AdminRole.contentAdmin
                case "limited_admin":
                    return AdminRole.limitedAdmin
                case "member_only":
                    return AdminRole.memberOnly
                case "reporting_admin":
                    return AdminRole.reportingAdmin
                case "security_admin":
                    return AdminRole.securityAdmin
                case "support_admin":
                    return AdminRole.supportAdmin
                case "team_admin":
                    return AdminRole.teamAdmin
                case "user_management_admin":
                    return AdminRole.userManagementAdmin
                case "other":
                    return AdminRole.other
                default:
                    return AdminRole.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: AdminRole.self, json: json)
            }
        }
    }

    /// Alert recipients setting type
    public enum AlertRecipientsSettingType: CustomStringConvertible, JSONRepresentable {
        /// An unspecified error.
        case customList
        /// An unspecified error.
        case invalid
        /// An unspecified error.
        case none
        /// An unspecified error.
        case teamAdmins
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try AlertRecipientsSettingTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try AlertRecipientsSettingTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for AlertRecipientsSettingType: \(error)"
            }
        }
    }

    public class AlertRecipientsSettingTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: AlertRecipientsSettingType) throws -> JSON {
            switch value {
            case .customList:
                var d = [String: JSON]()
                d[".tag"] = .str("custom_list")
                return .dictionary(d)
            case .invalid:
                var d = [String: JSON]()
                d[".tag"] = .str("invalid")
                return .dictionary(d)
            case .none:
                var d = [String: JSON]()
                d[".tag"] = .str("none")
                return .dictionary(d)
            case .teamAdmins:
                var d = [String: JSON]()
                d[".tag"] = .str("team_admins")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> AlertRecipientsSettingType {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "custom_list":
                    return AlertRecipientsSettingType.customList
                case "invalid":
                    return AlertRecipientsSettingType.invalid
                case "none":
                    return AlertRecipientsSettingType.none
                case "team_admins":
                    return AlertRecipientsSettingType.teamAdmins
                case "other":
                    return AlertRecipientsSettingType.other
                default:
                    return AlertRecipientsSettingType.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: AlertRecipientsSettingType.self, json: json)
            }
        }
    }

    /// Disabled downloads.
    public class AllowDownloadDisabledDetails: CustomStringConvertible, JSONRepresentable {
        func json() throws -> JSON {
            try AllowDownloadDisabledDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try AllowDownloadDisabledDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for AllowDownloadDisabledDetails: \(error)"
            }
        }
    }

    public class AllowDownloadDisabledDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: AllowDownloadDisabledDetails) throws -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> AllowDownloadDisabledDetails {
            switch json {
            case .dictionary:
                return AllowDownloadDisabledDetails()
            default:
                throw JSONSerializerError.deserializeError(type: AllowDownloadDisabledDetails.self, json: json)
            }
        }
    }

    /// The AllowDownloadDisabledType struct
    public class AllowDownloadDisabledType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try AllowDownloadDisabledTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try AllowDownloadDisabledTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for AllowDownloadDisabledType: \(error)"
            }
        }
    }

    public class AllowDownloadDisabledTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: AllowDownloadDisabledType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> AllowDownloadDisabledType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return AllowDownloadDisabledType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: AllowDownloadDisabledType.self, json: json)
            }
        }
    }

    /// Enabled downloads.
    public class AllowDownloadEnabledDetails: CustomStringConvertible, JSONRepresentable {
        func json() throws -> JSON {
            try AllowDownloadEnabledDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try AllowDownloadEnabledDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for AllowDownloadEnabledDetails: \(error)"
            }
        }
    }

    public class AllowDownloadEnabledDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: AllowDownloadEnabledDetails) throws -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> AllowDownloadEnabledDetails {
            switch json {
            case .dictionary:
                return AllowDownloadEnabledDetails()
            default:
                throw JSONSerializerError.deserializeError(type: AllowDownloadEnabledDetails.self, json: json)
            }
        }
    }

    /// The AllowDownloadEnabledType struct
    public class AllowDownloadEnabledType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try AllowDownloadEnabledTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try AllowDownloadEnabledTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for AllowDownloadEnabledType: \(error)"
            }
        }
    }

    public class AllowDownloadEnabledTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: AllowDownloadEnabledType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> AllowDownloadEnabledType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return AllowDownloadEnabledType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: AllowDownloadEnabledType.self, json: json)
            }
        }
    }

    /// Api session.
    public class ApiSessionLogInfo: CustomStringConvertible, JSONRepresentable {
        /// Api request ID.
        public let requestId: String
        public init(requestId: String) {
            stringValidator()(requestId)
            self.requestId = requestId
        }

        func json() throws -> JSON {
            try ApiSessionLogInfoSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ApiSessionLogInfoSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ApiSessionLogInfo: \(error)"
            }
        }
    }

    public class ApiSessionLogInfoSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ApiSessionLogInfo) throws -> JSON {
            let output = [
                "request_id": try Serialization._StringSerializer.serialize(value.requestId),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ApiSessionLogInfo {
            switch json {
            case .dictionary(let dict):
                let requestId = try Serialization._StringSerializer.deserialize(dict["request_id"] ?? .null)
                return ApiSessionLogInfo(requestId: requestId)
            default:
                throw JSONSerializerError.deserializeError(type: ApiSessionLogInfo.self, json: json)
            }
        }
    }

    /// Failed to connect app for member.
    public class AppBlockedByPermissionsDetails: CustomStringConvertible, JSONRepresentable {
        /// Relevant application details.
        public let appInfo: TeamLog.AppLogInfo
        public init(appInfo: TeamLog.AppLogInfo) {
            self.appInfo = appInfo
        }

        func json() throws -> JSON {
            try AppBlockedByPermissionsDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try AppBlockedByPermissionsDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for AppBlockedByPermissionsDetails: \(error)"
            }
        }
    }

    public class AppBlockedByPermissionsDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: AppBlockedByPermissionsDetails) throws -> JSON {
            let output = [
                "app_info": try TeamLog.AppLogInfoSerializer().serialize(value.appInfo),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> AppBlockedByPermissionsDetails {
            switch json {
            case .dictionary(let dict):
                let appInfo = try TeamLog.AppLogInfoSerializer().deserialize(dict["app_info"] ?? .null)
                return AppBlockedByPermissionsDetails(appInfo: appInfo)
            default:
                throw JSONSerializerError.deserializeError(type: AppBlockedByPermissionsDetails.self, json: json)
            }
        }
    }

    /// The AppBlockedByPermissionsType struct
    public class AppBlockedByPermissionsType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try AppBlockedByPermissionsTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try AppBlockedByPermissionsTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for AppBlockedByPermissionsType: \(error)"
            }
        }
    }

    public class AppBlockedByPermissionsTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: AppBlockedByPermissionsType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> AppBlockedByPermissionsType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return AppBlockedByPermissionsType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: AppBlockedByPermissionsType.self, json: json)
            }
        }
    }

    /// Linked app for team.
    public class AppLinkTeamDetails: CustomStringConvertible, JSONRepresentable {
        /// Relevant application details.
        public let appInfo: TeamLog.AppLogInfo
        public init(appInfo: TeamLog.AppLogInfo) {
            self.appInfo = appInfo
        }

        func json() throws -> JSON {
            try AppLinkTeamDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try AppLinkTeamDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for AppLinkTeamDetails: \(error)"
            }
        }
    }

    public class AppLinkTeamDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: AppLinkTeamDetails) throws -> JSON {
            let output = [
                "app_info": try TeamLog.AppLogInfoSerializer().serialize(value.appInfo),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> AppLinkTeamDetails {
            switch json {
            case .dictionary(let dict):
                let appInfo = try TeamLog.AppLogInfoSerializer().deserialize(dict["app_info"] ?? .null)
                return AppLinkTeamDetails(appInfo: appInfo)
            default:
                throw JSONSerializerError.deserializeError(type: AppLinkTeamDetails.self, json: json)
            }
        }
    }

    /// The AppLinkTeamType struct
    public class AppLinkTeamType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try AppLinkTeamTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try AppLinkTeamTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for AppLinkTeamType: \(error)"
            }
        }
    }

    public class AppLinkTeamTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: AppLinkTeamType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> AppLinkTeamType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return AppLinkTeamType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: AppLinkTeamType.self, json: json)
            }
        }
    }

    /// Linked app for member.
    public class AppLinkUserDetails: CustomStringConvertible, JSONRepresentable {
        /// Relevant application details.
        public let appInfo: TeamLog.AppLogInfo
        public init(appInfo: TeamLog.AppLogInfo) {
            self.appInfo = appInfo
        }

        func json() throws -> JSON {
            try AppLinkUserDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try AppLinkUserDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for AppLinkUserDetails: \(error)"
            }
        }
    }

    public class AppLinkUserDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: AppLinkUserDetails) throws -> JSON {
            let output = [
                "app_info": try TeamLog.AppLogInfoSerializer().serialize(value.appInfo),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> AppLinkUserDetails {
            switch json {
            case .dictionary(let dict):
                let appInfo = try TeamLog.AppLogInfoSerializer().deserialize(dict["app_info"] ?? .null)
                return AppLinkUserDetails(appInfo: appInfo)
            default:
                throw JSONSerializerError.deserializeError(type: AppLinkUserDetails.self, json: json)
            }
        }
    }

    /// The AppLinkUserType struct
    public class AppLinkUserType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try AppLinkUserTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try AppLinkUserTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for AppLinkUserType: \(error)"
            }
        }
    }

    public class AppLinkUserTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: AppLinkUserType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> AppLinkUserType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return AppLinkUserType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: AppLinkUserType.self, json: json)
            }
        }
    }

    /// App's logged information.
    public class AppLogInfo: CustomStringConvertible, JSONRepresentable {
        /// App unique ID.
        public let appId: String?
        /// App display name.
        public let displayName: String?
        public init(appId: String? = nil, displayName: String? = nil) {
            nullableValidator(stringValidator())(appId)
            self.appId = appId
            nullableValidator(stringValidator())(displayName)
            self.displayName = displayName
        }

        func json() throws -> JSON {
            try AppLogInfoSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try AppLogInfoSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for AppLogInfo: \(error)"
            }
        }
    }

    public class AppLogInfoSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: AppLogInfo) throws -> JSON {
            var output = [
                "app_id": try NullableSerializer(Serialization._StringSerializer).serialize(value.appId),
                "display_name": try NullableSerializer(Serialization._StringSerializer).serialize(value.displayName),
            ]
            switch value {
            case let userOrTeamLinkedApp as TeamLog.UserOrTeamLinkedAppLogInfo:
                for (k, v) in try Serialization.getFields(TeamLog.UserOrTeamLinkedAppLogInfoSerializer().serialize(userOrTeamLinkedApp)) {
                    output[k] = v
                }
                output[".tag"] = .str("user_or_team_linked_app")
            case let userLinkedApp as TeamLog.UserLinkedAppLogInfo:
                for (k, v) in try Serialization.getFields(TeamLog.UserLinkedAppLogInfoSerializer().serialize(userLinkedApp)) {
                    output[k] = v
                }
                output[".tag"] = .str("user_linked_app")
            case let teamLinkedApp as TeamLog.TeamLinkedAppLogInfo:
                for (k, v) in try Serialization.getFields(TeamLog.TeamLinkedAppLogInfoSerializer().serialize(teamLinkedApp)) {
                    output[k] = v
                }
                output[".tag"] = .str("team_linked_app")
            default:
                throw JSONSerializerError.unexpectedSubtype(type: AppLogInfo.self, subtype: value)
            }
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> AppLogInfo {
            switch json {
            case .dictionary(let dict):
                let tag = try Serialization.getTag(dict)
                switch tag {
                case "user_or_team_linked_app":
                    return try TeamLog.UserOrTeamLinkedAppLogInfoSerializer().deserialize(json)
                case "user_linked_app":
                    return try TeamLog.UserLinkedAppLogInfoSerializer().deserialize(json)
                case "team_linked_app":
                    return try TeamLog.TeamLinkedAppLogInfoSerializer().deserialize(json)
                default:
                    let appId = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["app_id"] ?? .null)
                    let displayName = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["display_name"] ?? .null)
                    return AppLogInfo(appId: appId, displayName: displayName)
                }
            default:
                throw JSONSerializerError.deserializeError(type: AppLogInfo.self, json: json)
            }
        }
    }

    /// Changed app permissions.
    public class AppPermissionsChangedDetails: CustomStringConvertible, JSONRepresentable {
        /// Name of the app.
        public let appName: String?
        /// Permission that was changed.
        public let permission: TeamLog.AdminConsoleAppPermission?
        /// Previous policy.
        public let previousValue: TeamLog.AdminConsoleAppPolicy
        /// New policy.
        public let newValue: TeamLog.AdminConsoleAppPolicy
        public init(
            previousValue: TeamLog.AdminConsoleAppPolicy,
            newValue: TeamLog.AdminConsoleAppPolicy,
            appName: String? = nil,
            permission: TeamLog.AdminConsoleAppPermission? = nil
        ) {
            nullableValidator(stringValidator())(appName)
            self.appName = appName
            self.permission = permission
            self.previousValue = previousValue
            self.newValue = newValue
        }

        func json() throws -> JSON {
            try AppPermissionsChangedDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try AppPermissionsChangedDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for AppPermissionsChangedDetails: \(error)"
            }
        }
    }

    public class AppPermissionsChangedDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: AppPermissionsChangedDetails) throws -> JSON {
            let output = [
                "previous_value": try TeamLog.AdminConsoleAppPolicySerializer().serialize(value.previousValue),
                "new_value": try TeamLog.AdminConsoleAppPolicySerializer().serialize(value.newValue),
                "app_name": try NullableSerializer(Serialization._StringSerializer).serialize(value.appName),
                "permission": try NullableSerializer(TeamLog.AdminConsoleAppPermissionSerializer()).serialize(value.permission),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> AppPermissionsChangedDetails {
            switch json {
            case .dictionary(let dict):
                let previousValue = try TeamLog.AdminConsoleAppPolicySerializer().deserialize(dict["previous_value"] ?? .null)
                let newValue = try TeamLog.AdminConsoleAppPolicySerializer().deserialize(dict["new_value"] ?? .null)
                let appName = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["app_name"] ?? .null)
                let permission = try NullableSerializer(TeamLog.AdminConsoleAppPermissionSerializer()).deserialize(dict["permission"] ?? .null)
                return AppPermissionsChangedDetails(previousValue: previousValue, newValue: newValue, appName: appName, permission: permission)
            default:
                throw JSONSerializerError.deserializeError(type: AppPermissionsChangedDetails.self, json: json)
            }
        }
    }

    /// The AppPermissionsChangedType struct
    public class AppPermissionsChangedType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try AppPermissionsChangedTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try AppPermissionsChangedTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for AppPermissionsChangedType: \(error)"
            }
        }
    }

    public class AppPermissionsChangedTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: AppPermissionsChangedType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> AppPermissionsChangedType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return AppPermissionsChangedType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: AppPermissionsChangedType.self, json: json)
            }
        }
    }

    /// Unlinked app for team.
    public class AppUnlinkTeamDetails: CustomStringConvertible, JSONRepresentable {
        /// Relevant application details.
        public let appInfo: TeamLog.AppLogInfo
        public init(appInfo: TeamLog.AppLogInfo) {
            self.appInfo = appInfo
        }

        func json() throws -> JSON {
            try AppUnlinkTeamDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try AppUnlinkTeamDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for AppUnlinkTeamDetails: \(error)"
            }
        }
    }

    public class AppUnlinkTeamDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: AppUnlinkTeamDetails) throws -> JSON {
            let output = [
                "app_info": try TeamLog.AppLogInfoSerializer().serialize(value.appInfo),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> AppUnlinkTeamDetails {
            switch json {
            case .dictionary(let dict):
                let appInfo = try TeamLog.AppLogInfoSerializer().deserialize(dict["app_info"] ?? .null)
                return AppUnlinkTeamDetails(appInfo: appInfo)
            default:
                throw JSONSerializerError.deserializeError(type: AppUnlinkTeamDetails.self, json: json)
            }
        }
    }

    /// The AppUnlinkTeamType struct
    public class AppUnlinkTeamType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try AppUnlinkTeamTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try AppUnlinkTeamTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for AppUnlinkTeamType: \(error)"
            }
        }
    }

    public class AppUnlinkTeamTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: AppUnlinkTeamType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> AppUnlinkTeamType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return AppUnlinkTeamType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: AppUnlinkTeamType.self, json: json)
            }
        }
    }

    /// Unlinked app for member.
    public class AppUnlinkUserDetails: CustomStringConvertible, JSONRepresentable {
        /// Relevant application details.
        public let appInfo: TeamLog.AppLogInfo
        public init(appInfo: TeamLog.AppLogInfo) {
            self.appInfo = appInfo
        }

        func json() throws -> JSON {
            try AppUnlinkUserDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try AppUnlinkUserDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for AppUnlinkUserDetails: \(error)"
            }
        }
    }

    public class AppUnlinkUserDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: AppUnlinkUserDetails) throws -> JSON {
            let output = [
                "app_info": try TeamLog.AppLogInfoSerializer().serialize(value.appInfo),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> AppUnlinkUserDetails {
            switch json {
            case .dictionary(let dict):
                let appInfo = try TeamLog.AppLogInfoSerializer().deserialize(dict["app_info"] ?? .null)
                return AppUnlinkUserDetails(appInfo: appInfo)
            default:
                throw JSONSerializerError.deserializeError(type: AppUnlinkUserDetails.self, json: json)
            }
        }
    }

    /// The AppUnlinkUserType struct
    public class AppUnlinkUserType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try AppUnlinkUserTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try AppUnlinkUserTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for AppUnlinkUserType: \(error)"
            }
        }
    }

    public class AppUnlinkUserTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: AppUnlinkUserType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> AppUnlinkUserType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return AppUnlinkUserType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: AppUnlinkUserType.self, json: json)
            }
        }
    }

    /// Applied naming convention.
    public class ApplyNamingConventionDetails: CustomStringConvertible, JSONRepresentable {
        func json() throws -> JSON {
            try ApplyNamingConventionDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ApplyNamingConventionDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ApplyNamingConventionDetails: \(error)"
            }
        }
    }

    public class ApplyNamingConventionDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ApplyNamingConventionDetails) throws -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ApplyNamingConventionDetails {
            switch json {
            case .dictionary:
                return ApplyNamingConventionDetails()
            default:
                throw JSONSerializerError.deserializeError(type: ApplyNamingConventionDetails.self, json: json)
            }
        }
    }

    /// The ApplyNamingConventionType struct
    public class ApplyNamingConventionType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try ApplyNamingConventionTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ApplyNamingConventionTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ApplyNamingConventionType: \(error)"
            }
        }
    }

    public class ApplyNamingConventionTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ApplyNamingConventionType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ApplyNamingConventionType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return ApplyNamingConventionType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: ApplyNamingConventionType.self, json: json)
            }
        }
    }

    /// Asset details.
    public enum AssetLogInfo: CustomStringConvertible, JSONRepresentable {
        /// File's details.
        case file(TeamLog.FileLogInfo)
        /// Folder's details.
        case folder(TeamLog.FolderLogInfo)
        /// Paper document's details.
        case paperDocument(TeamLog.PaperDocumentLogInfo)
        /// Paper folder's details.
        case paperFolder(TeamLog.PaperFolderLogInfo)
        /// Showcase document's details.
        case showcaseDocument(TeamLog.ShowcaseDocumentLogInfo)
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try AssetLogInfoSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try AssetLogInfoSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for AssetLogInfo: \(error)"
            }
        }
    }

    public class AssetLogInfoSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: AssetLogInfo) throws -> JSON {
            switch value {
            case .file(let arg):
                var d = try Serialization.getFields(TeamLog.FileLogInfoSerializer().serialize(arg))
                d[".tag"] = .str("file")
                return .dictionary(d)
            case .folder(let arg):
                var d = try Serialization.getFields(TeamLog.FolderLogInfoSerializer().serialize(arg))
                d[".tag"] = .str("folder")
                return .dictionary(d)
            case .paperDocument(let arg):
                var d = try Serialization.getFields(TeamLog.PaperDocumentLogInfoSerializer().serialize(arg))
                d[".tag"] = .str("paper_document")
                return .dictionary(d)
            case .paperFolder(let arg):
                var d = try Serialization.getFields(TeamLog.PaperFolderLogInfoSerializer().serialize(arg))
                d[".tag"] = .str("paper_folder")
                return .dictionary(d)
            case .showcaseDocument(let arg):
                var d = try Serialization.getFields(TeamLog.ShowcaseDocumentLogInfoSerializer().serialize(arg))
                d[".tag"] = .str("showcase_document")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> AssetLogInfo {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "file":
                    let v = try TeamLog.FileLogInfoSerializer().deserialize(json)
                    return AssetLogInfo.file(v)
                case "folder":
                    let v = try TeamLog.FolderLogInfoSerializer().deserialize(json)
                    return AssetLogInfo.folder(v)
                case "paper_document":
                    let v = try TeamLog.PaperDocumentLogInfoSerializer().deserialize(json)
                    return AssetLogInfo.paperDocument(v)
                case "paper_folder":
                    let v = try TeamLog.PaperFolderLogInfoSerializer().deserialize(json)
                    return AssetLogInfo.paperFolder(v)
                case "showcase_document":
                    let v = try TeamLog.ShowcaseDocumentLogInfoSerializer().deserialize(json)
                    return AssetLogInfo.showcaseDocument(v)
                case "other":
                    return AssetLogInfo.other
                default:
                    return AssetLogInfo.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: AssetLogInfo.self, json: json)
            }
        }
    }

    /// Invited members to activate Backup.
    public class BackupAdminInvitationSentDetails: CustomStringConvertible, JSONRepresentable {
        func json() throws -> JSON {
            try BackupAdminInvitationSentDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try BackupAdminInvitationSentDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for BackupAdminInvitationSentDetails: \(error)"
            }
        }
    }

    public class BackupAdminInvitationSentDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: BackupAdminInvitationSentDetails) throws -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> BackupAdminInvitationSentDetails {
            switch json {
            case .dictionary:
                return BackupAdminInvitationSentDetails()
            default:
                throw JSONSerializerError.deserializeError(type: BackupAdminInvitationSentDetails.self, json: json)
            }
        }
    }

    /// The BackupAdminInvitationSentType struct
    public class BackupAdminInvitationSentType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try BackupAdminInvitationSentTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try BackupAdminInvitationSentTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for BackupAdminInvitationSentType: \(error)"
            }
        }
    }

    public class BackupAdminInvitationSentTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: BackupAdminInvitationSentType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> BackupAdminInvitationSentType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return BackupAdminInvitationSentType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: BackupAdminInvitationSentType.self, json: json)
            }
        }
    }

    /// Opened Backup invite.
    public class BackupInvitationOpenedDetails: CustomStringConvertible, JSONRepresentable {
        func json() throws -> JSON {
            try BackupInvitationOpenedDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try BackupInvitationOpenedDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for BackupInvitationOpenedDetails: \(error)"
            }
        }
    }

    public class BackupInvitationOpenedDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: BackupInvitationOpenedDetails) throws -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> BackupInvitationOpenedDetails {
            switch json {
            case .dictionary:
                return BackupInvitationOpenedDetails()
            default:
                throw JSONSerializerError.deserializeError(type: BackupInvitationOpenedDetails.self, json: json)
            }
        }
    }

    /// The BackupInvitationOpenedType struct
    public class BackupInvitationOpenedType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try BackupInvitationOpenedTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try BackupInvitationOpenedTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for BackupInvitationOpenedType: \(error)"
            }
        }
    }

    public class BackupInvitationOpenedTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: BackupInvitationOpenedType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> BackupInvitationOpenedType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return BackupInvitationOpenedType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: BackupInvitationOpenedType.self, json: json)
            }
        }
    }

    /// Backup status
    public enum BackupStatus: CustomStringConvertible, JSONRepresentable {
        /// An unspecified error.
        case disabled
        /// An unspecified error.
        case enabled
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try BackupStatusSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try BackupStatusSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for BackupStatus: \(error)"
            }
        }
    }

    public class BackupStatusSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: BackupStatus) throws -> JSON {
            switch value {
            case .disabled:
                var d = [String: JSON]()
                d[".tag"] = .str("disabled")
                return .dictionary(d)
            case .enabled:
                var d = [String: JSON]()
                d[".tag"] = .str("enabled")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> BackupStatus {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "disabled":
                    return BackupStatus.disabled
                case "enabled":
                    return BackupStatus.enabled
                case "other":
                    return BackupStatus.other
                default:
                    return BackupStatus.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: BackupStatus.self, json: json)
            }
        }
    }

    /// Added Binder page.
    public class BinderAddPageDetails: CustomStringConvertible, JSONRepresentable {
        /// Event unique identifier.
        public let eventUuid: String
        /// Title of the Binder doc.
        public let docTitle: String
        /// Name of the Binder page/section.
        public let binderItemName: String
        public init(eventUuid: String, docTitle: String, binderItemName: String) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
            stringValidator()(docTitle)
            self.docTitle = docTitle
            stringValidator()(binderItemName)
            self.binderItemName = binderItemName
        }

        func json() throws -> JSON {
            try BinderAddPageDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try BinderAddPageDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for BinderAddPageDetails: \(error)"
            }
        }
    }

    public class BinderAddPageDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: BinderAddPageDetails) throws -> JSON {
            let output = [
                "event_uuid": try Serialization._StringSerializer.serialize(value.eventUuid),
                "doc_title": try Serialization._StringSerializer.serialize(value.docTitle),
                "binder_item_name": try Serialization._StringSerializer.serialize(value.binderItemName),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> BinderAddPageDetails {
            switch json {
            case .dictionary(let dict):
                let eventUuid = try Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                let docTitle = try Serialization._StringSerializer.deserialize(dict["doc_title"] ?? .null)
                let binderItemName = try Serialization._StringSerializer.deserialize(dict["binder_item_name"] ?? .null)
                return BinderAddPageDetails(eventUuid: eventUuid, docTitle: docTitle, binderItemName: binderItemName)
            default:
                throw JSONSerializerError.deserializeError(type: BinderAddPageDetails.self, json: json)
            }
        }
    }

    /// The BinderAddPageType struct
    public class BinderAddPageType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try BinderAddPageTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try BinderAddPageTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for BinderAddPageType: \(error)"
            }
        }
    }

    public class BinderAddPageTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: BinderAddPageType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> BinderAddPageType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return BinderAddPageType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: BinderAddPageType.self, json: json)
            }
        }
    }

    /// Added Binder section.
    public class BinderAddSectionDetails: CustomStringConvertible, JSONRepresentable {
        /// Event unique identifier.
        public let eventUuid: String
        /// Title of the Binder doc.
        public let docTitle: String
        /// Name of the Binder page/section.
        public let binderItemName: String
        public init(eventUuid: String, docTitle: String, binderItemName: String) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
            stringValidator()(docTitle)
            self.docTitle = docTitle
            stringValidator()(binderItemName)
            self.binderItemName = binderItemName
        }

        func json() throws -> JSON {
            try BinderAddSectionDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try BinderAddSectionDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for BinderAddSectionDetails: \(error)"
            }
        }
    }

    public class BinderAddSectionDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: BinderAddSectionDetails) throws -> JSON {
            let output = [
                "event_uuid": try Serialization._StringSerializer.serialize(value.eventUuid),
                "doc_title": try Serialization._StringSerializer.serialize(value.docTitle),
                "binder_item_name": try Serialization._StringSerializer.serialize(value.binderItemName),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> BinderAddSectionDetails {
            switch json {
            case .dictionary(let dict):
                let eventUuid = try Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                let docTitle = try Serialization._StringSerializer.deserialize(dict["doc_title"] ?? .null)
                let binderItemName = try Serialization._StringSerializer.deserialize(dict["binder_item_name"] ?? .null)
                return BinderAddSectionDetails(eventUuid: eventUuid, docTitle: docTitle, binderItemName: binderItemName)
            default:
                throw JSONSerializerError.deserializeError(type: BinderAddSectionDetails.self, json: json)
            }
        }
    }

    /// The BinderAddSectionType struct
    public class BinderAddSectionType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try BinderAddSectionTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try BinderAddSectionTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for BinderAddSectionType: \(error)"
            }
        }
    }

    public class BinderAddSectionTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: BinderAddSectionType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> BinderAddSectionType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return BinderAddSectionType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: BinderAddSectionType.self, json: json)
            }
        }
    }

    /// Removed Binder page.
    public class BinderRemovePageDetails: CustomStringConvertible, JSONRepresentable {
        /// Event unique identifier.
        public let eventUuid: String
        /// Title of the Binder doc.
        public let docTitle: String
        /// Name of the Binder page/section.
        public let binderItemName: String
        public init(eventUuid: String, docTitle: String, binderItemName: String) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
            stringValidator()(docTitle)
            self.docTitle = docTitle
            stringValidator()(binderItemName)
            self.binderItemName = binderItemName
        }

        func json() throws -> JSON {
            try BinderRemovePageDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try BinderRemovePageDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for BinderRemovePageDetails: \(error)"
            }
        }
    }

    public class BinderRemovePageDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: BinderRemovePageDetails) throws -> JSON {
            let output = [
                "event_uuid": try Serialization._StringSerializer.serialize(value.eventUuid),
                "doc_title": try Serialization._StringSerializer.serialize(value.docTitle),
                "binder_item_name": try Serialization._StringSerializer.serialize(value.binderItemName),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> BinderRemovePageDetails {
            switch json {
            case .dictionary(let dict):
                let eventUuid = try Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                let docTitle = try Serialization._StringSerializer.deserialize(dict["doc_title"] ?? .null)
                let binderItemName = try Serialization._StringSerializer.deserialize(dict["binder_item_name"] ?? .null)
                return BinderRemovePageDetails(eventUuid: eventUuid, docTitle: docTitle, binderItemName: binderItemName)
            default:
                throw JSONSerializerError.deserializeError(type: BinderRemovePageDetails.self, json: json)
            }
        }
    }

    /// The BinderRemovePageType struct
    public class BinderRemovePageType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try BinderRemovePageTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try BinderRemovePageTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for BinderRemovePageType: \(error)"
            }
        }
    }

    public class BinderRemovePageTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: BinderRemovePageType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> BinderRemovePageType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return BinderRemovePageType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: BinderRemovePageType.self, json: json)
            }
        }
    }

    /// Removed Binder section.
    public class BinderRemoveSectionDetails: CustomStringConvertible, JSONRepresentable {
        /// Event unique identifier.
        public let eventUuid: String
        /// Title of the Binder doc.
        public let docTitle: String
        /// Name of the Binder page/section.
        public let binderItemName: String
        public init(eventUuid: String, docTitle: String, binderItemName: String) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
            stringValidator()(docTitle)
            self.docTitle = docTitle
            stringValidator()(binderItemName)
            self.binderItemName = binderItemName
        }

        func json() throws -> JSON {
            try BinderRemoveSectionDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try BinderRemoveSectionDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for BinderRemoveSectionDetails: \(error)"
            }
        }
    }

    public class BinderRemoveSectionDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: BinderRemoveSectionDetails) throws -> JSON {
            let output = [
                "event_uuid": try Serialization._StringSerializer.serialize(value.eventUuid),
                "doc_title": try Serialization._StringSerializer.serialize(value.docTitle),
                "binder_item_name": try Serialization._StringSerializer.serialize(value.binderItemName),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> BinderRemoveSectionDetails {
            switch json {
            case .dictionary(let dict):
                let eventUuid = try Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                let docTitle = try Serialization._StringSerializer.deserialize(dict["doc_title"] ?? .null)
                let binderItemName = try Serialization._StringSerializer.deserialize(dict["binder_item_name"] ?? .null)
                return BinderRemoveSectionDetails(eventUuid: eventUuid, docTitle: docTitle, binderItemName: binderItemName)
            default:
                throw JSONSerializerError.deserializeError(type: BinderRemoveSectionDetails.self, json: json)
            }
        }
    }

    /// The BinderRemoveSectionType struct
    public class BinderRemoveSectionType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try BinderRemoveSectionTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try BinderRemoveSectionTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for BinderRemoveSectionType: \(error)"
            }
        }
    }

    public class BinderRemoveSectionTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: BinderRemoveSectionType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> BinderRemoveSectionType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return BinderRemoveSectionType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: BinderRemoveSectionType.self, json: json)
            }
        }
    }

    /// Renamed Binder page.
    public class BinderRenamePageDetails: CustomStringConvertible, JSONRepresentable {
        /// Event unique identifier.
        public let eventUuid: String
        /// Title of the Binder doc.
        public let docTitle: String
        /// Name of the Binder page/section.
        public let binderItemName: String
        /// Previous name of the Binder page/section.
        public let previousBinderItemName: String?
        public init(eventUuid: String, docTitle: String, binderItemName: String, previousBinderItemName: String? = nil) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
            stringValidator()(docTitle)
            self.docTitle = docTitle
            stringValidator()(binderItemName)
            self.binderItemName = binderItemName
            nullableValidator(stringValidator())(previousBinderItemName)
            self.previousBinderItemName = previousBinderItemName
        }

        func json() throws -> JSON {
            try BinderRenamePageDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try BinderRenamePageDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for BinderRenamePageDetails: \(error)"
            }
        }
    }

    public class BinderRenamePageDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: BinderRenamePageDetails) throws -> JSON {
            let output = [
                "event_uuid": try Serialization._StringSerializer.serialize(value.eventUuid),
                "doc_title": try Serialization._StringSerializer.serialize(value.docTitle),
                "binder_item_name": try Serialization._StringSerializer.serialize(value.binderItemName),
                "previous_binder_item_name": try NullableSerializer(Serialization._StringSerializer).serialize(value.previousBinderItemName),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> BinderRenamePageDetails {
            switch json {
            case .dictionary(let dict):
                let eventUuid = try Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                let docTitle = try Serialization._StringSerializer.deserialize(dict["doc_title"] ?? .null)
                let binderItemName = try Serialization._StringSerializer.deserialize(dict["binder_item_name"] ?? .null)
                let previousBinderItemName = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["previous_binder_item_name"] ?? .null)
                return BinderRenamePageDetails(
                    eventUuid: eventUuid,
                    docTitle: docTitle,
                    binderItemName: binderItemName,
                    previousBinderItemName: previousBinderItemName
                )
            default:
                throw JSONSerializerError.deserializeError(type: BinderRenamePageDetails.self, json: json)
            }
        }
    }

    /// The BinderRenamePageType struct
    public class BinderRenamePageType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try BinderRenamePageTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try BinderRenamePageTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for BinderRenamePageType: \(error)"
            }
        }
    }

    public class BinderRenamePageTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: BinderRenamePageType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> BinderRenamePageType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return BinderRenamePageType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: BinderRenamePageType.self, json: json)
            }
        }
    }

    /// Renamed Binder section.
    public class BinderRenameSectionDetails: CustomStringConvertible, JSONRepresentable {
        /// Event unique identifier.
        public let eventUuid: String
        /// Title of the Binder doc.
        public let docTitle: String
        /// Name of the Binder page/section.
        public let binderItemName: String
        /// Previous name of the Binder page/section.
        public let previousBinderItemName: String?
        public init(eventUuid: String, docTitle: String, binderItemName: String, previousBinderItemName: String? = nil) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
            stringValidator()(docTitle)
            self.docTitle = docTitle
            stringValidator()(binderItemName)
            self.binderItemName = binderItemName
            nullableValidator(stringValidator())(previousBinderItemName)
            self.previousBinderItemName = previousBinderItemName
        }

        func json() throws -> JSON {
            try BinderRenameSectionDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try BinderRenameSectionDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for BinderRenameSectionDetails: \(error)"
            }
        }
    }

    public class BinderRenameSectionDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: BinderRenameSectionDetails) throws -> JSON {
            let output = [
                "event_uuid": try Serialization._StringSerializer.serialize(value.eventUuid),
                "doc_title": try Serialization._StringSerializer.serialize(value.docTitle),
                "binder_item_name": try Serialization._StringSerializer.serialize(value.binderItemName),
                "previous_binder_item_name": try NullableSerializer(Serialization._StringSerializer).serialize(value.previousBinderItemName),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> BinderRenameSectionDetails {
            switch json {
            case .dictionary(let dict):
                let eventUuid = try Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                let docTitle = try Serialization._StringSerializer.deserialize(dict["doc_title"] ?? .null)
                let binderItemName = try Serialization._StringSerializer.deserialize(dict["binder_item_name"] ?? .null)
                let previousBinderItemName = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["previous_binder_item_name"] ?? .null)
                return BinderRenameSectionDetails(
                    eventUuid: eventUuid,
                    docTitle: docTitle,
                    binderItemName: binderItemName,
                    previousBinderItemName: previousBinderItemName
                )
            default:
                throw JSONSerializerError.deserializeError(type: BinderRenameSectionDetails.self, json: json)
            }
        }
    }

    /// The BinderRenameSectionType struct
    public class BinderRenameSectionType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try BinderRenameSectionTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try BinderRenameSectionTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for BinderRenameSectionType: \(error)"
            }
        }
    }

    public class BinderRenameSectionTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: BinderRenameSectionType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> BinderRenameSectionType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return BinderRenameSectionType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: BinderRenameSectionType.self, json: json)
            }
        }
    }

    /// Reordered Binder page.
    public class BinderReorderPageDetails: CustomStringConvertible, JSONRepresentable {
        /// Event unique identifier.
        public let eventUuid: String
        /// Title of the Binder doc.
        public let docTitle: String
        /// Name of the Binder page/section.
        public let binderItemName: String
        public init(eventUuid: String, docTitle: String, binderItemName: String) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
            stringValidator()(docTitle)
            self.docTitle = docTitle
            stringValidator()(binderItemName)
            self.binderItemName = binderItemName
        }

        func json() throws -> JSON {
            try BinderReorderPageDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try BinderReorderPageDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for BinderReorderPageDetails: \(error)"
            }
        }
    }

    public class BinderReorderPageDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: BinderReorderPageDetails) throws -> JSON {
            let output = [
                "event_uuid": try Serialization._StringSerializer.serialize(value.eventUuid),
                "doc_title": try Serialization._StringSerializer.serialize(value.docTitle),
                "binder_item_name": try Serialization._StringSerializer.serialize(value.binderItemName),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> BinderReorderPageDetails {
            switch json {
            case .dictionary(let dict):
                let eventUuid = try Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                let docTitle = try Serialization._StringSerializer.deserialize(dict["doc_title"] ?? .null)
                let binderItemName = try Serialization._StringSerializer.deserialize(dict["binder_item_name"] ?? .null)
                return BinderReorderPageDetails(eventUuid: eventUuid, docTitle: docTitle, binderItemName: binderItemName)
            default:
                throw JSONSerializerError.deserializeError(type: BinderReorderPageDetails.self, json: json)
            }
        }
    }

    /// The BinderReorderPageType struct
    public class BinderReorderPageType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try BinderReorderPageTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try BinderReorderPageTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for BinderReorderPageType: \(error)"
            }
        }
    }

    public class BinderReorderPageTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: BinderReorderPageType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> BinderReorderPageType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return BinderReorderPageType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: BinderReorderPageType.self, json: json)
            }
        }
    }

    /// Reordered Binder section.
    public class BinderReorderSectionDetails: CustomStringConvertible, JSONRepresentable {
        /// Event unique identifier.
        public let eventUuid: String
        /// Title of the Binder doc.
        public let docTitle: String
        /// Name of the Binder page/section.
        public let binderItemName: String
        public init(eventUuid: String, docTitle: String, binderItemName: String) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
            stringValidator()(docTitle)
            self.docTitle = docTitle
            stringValidator()(binderItemName)
            self.binderItemName = binderItemName
        }

        func json() throws -> JSON {
            try BinderReorderSectionDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try BinderReorderSectionDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for BinderReorderSectionDetails: \(error)"
            }
        }
    }

    public class BinderReorderSectionDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: BinderReorderSectionDetails) throws -> JSON {
            let output = [
                "event_uuid": try Serialization._StringSerializer.serialize(value.eventUuid),
                "doc_title": try Serialization._StringSerializer.serialize(value.docTitle),
                "binder_item_name": try Serialization._StringSerializer.serialize(value.binderItemName),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> BinderReorderSectionDetails {
            switch json {
            case .dictionary(let dict):
                let eventUuid = try Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                let docTitle = try Serialization._StringSerializer.deserialize(dict["doc_title"] ?? .null)
                let binderItemName = try Serialization._StringSerializer.deserialize(dict["binder_item_name"] ?? .null)
                return BinderReorderSectionDetails(eventUuid: eventUuid, docTitle: docTitle, binderItemName: binderItemName)
            default:
                throw JSONSerializerError.deserializeError(type: BinderReorderSectionDetails.self, json: json)
            }
        }
    }

    /// The BinderReorderSectionType struct
    public class BinderReorderSectionType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try BinderReorderSectionTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try BinderReorderSectionTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for BinderReorderSectionType: \(error)"
            }
        }
    }

    public class BinderReorderSectionTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: BinderReorderSectionType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> BinderReorderSectionType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return BinderReorderSectionType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: BinderReorderSectionType.self, json: json)
            }
        }
    }

    /// Policy for controlling if team members can activate camera uploads
    public enum CameraUploadsPolicy: CustomStringConvertible, JSONRepresentable {
        /// An unspecified error.
        case disabled
        /// An unspecified error.
        case enabled
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try CameraUploadsPolicySerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try CameraUploadsPolicySerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for CameraUploadsPolicy: \(error)"
            }
        }
    }

    public class CameraUploadsPolicySerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: CameraUploadsPolicy) throws -> JSON {
            switch value {
            case .disabled:
                var d = [String: JSON]()
                d[".tag"] = .str("disabled")
                return .dictionary(d)
            case .enabled:
                var d = [String: JSON]()
                d[".tag"] = .str("enabled")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> CameraUploadsPolicy {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "disabled":
                    return CameraUploadsPolicy.disabled
                case "enabled":
                    return CameraUploadsPolicy.enabled
                case "other":
                    return CameraUploadsPolicy.other
                default:
                    return CameraUploadsPolicy.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: CameraUploadsPolicy.self, json: json)
            }
        }
    }

    /// Changed camera uploads setting for team.
    public class CameraUploadsPolicyChangedDetails: CustomStringConvertible, JSONRepresentable {
        /// New camera uploads setting.
        public let newValue: TeamLog.CameraUploadsPolicy
        /// Previous camera uploads setting.
        public let previousValue: TeamLog.CameraUploadsPolicy
        public init(newValue: TeamLog.CameraUploadsPolicy, previousValue: TeamLog.CameraUploadsPolicy) {
            self.newValue = newValue
            self.previousValue = previousValue
        }

        func json() throws -> JSON {
            try CameraUploadsPolicyChangedDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try CameraUploadsPolicyChangedDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for CameraUploadsPolicyChangedDetails: \(error)"
            }
        }
    }

    public class CameraUploadsPolicyChangedDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: CameraUploadsPolicyChangedDetails) throws -> JSON {
            let output = [
                "new_value": try TeamLog.CameraUploadsPolicySerializer().serialize(value.newValue),
                "previous_value": try TeamLog.CameraUploadsPolicySerializer().serialize(value.previousValue),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> CameraUploadsPolicyChangedDetails {
            switch json {
            case .dictionary(let dict):
                let newValue = try TeamLog.CameraUploadsPolicySerializer().deserialize(dict["new_value"] ?? .null)
                let previousValue = try TeamLog.CameraUploadsPolicySerializer().deserialize(dict["previous_value"] ?? .null)
                return CameraUploadsPolicyChangedDetails(newValue: newValue, previousValue: previousValue)
            default:
                throw JSONSerializerError.deserializeError(type: CameraUploadsPolicyChangedDetails.self, json: json)
            }
        }
    }

    /// The CameraUploadsPolicyChangedType struct
    public class CameraUploadsPolicyChangedType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try CameraUploadsPolicyChangedTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try CameraUploadsPolicyChangedTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for CameraUploadsPolicyChangedType: \(error)"
            }
        }
    }

    public class CameraUploadsPolicyChangedTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: CameraUploadsPolicyChangedType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> CameraUploadsPolicyChangedType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return CameraUploadsPolicyChangedType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: CameraUploadsPolicyChangedType.self, json: json)
            }
        }
    }

    /// Policy for deciding whether team users can transcription in Capture
    public enum CaptureTranscriptPolicy: CustomStringConvertible, JSONRepresentable {
        /// An unspecified error.
        case default_
        /// An unspecified error.
        case disabled
        /// An unspecified error.
        case enabled
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try CaptureTranscriptPolicySerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try CaptureTranscriptPolicySerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for CaptureTranscriptPolicy: \(error)"
            }
        }
    }

    public class CaptureTranscriptPolicySerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: CaptureTranscriptPolicy) throws -> JSON {
            switch value {
            case .default_:
                var d = [String: JSON]()
                d[".tag"] = .str("default")
                return .dictionary(d)
            case .disabled:
                var d = [String: JSON]()
                d[".tag"] = .str("disabled")
                return .dictionary(d)
            case .enabled:
                var d = [String: JSON]()
                d[".tag"] = .str("enabled")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> CaptureTranscriptPolicy {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "default":
                    return CaptureTranscriptPolicy.default_
                case "disabled":
                    return CaptureTranscriptPolicy.disabled
                case "enabled":
                    return CaptureTranscriptPolicy.enabled
                case "other":
                    return CaptureTranscriptPolicy.other
                default:
                    return CaptureTranscriptPolicy.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: CaptureTranscriptPolicy.self, json: json)
            }
        }
    }

    /// Changed Capture transcription policy for team.
    public class CaptureTranscriptPolicyChangedDetails: CustomStringConvertible, JSONRepresentable {
        /// To.
        public let newValue: TeamLog.CaptureTranscriptPolicy
        /// From.
        public let previousValue: TeamLog.CaptureTranscriptPolicy
        public init(newValue: TeamLog.CaptureTranscriptPolicy, previousValue: TeamLog.CaptureTranscriptPolicy) {
            self.newValue = newValue
            self.previousValue = previousValue
        }

        func json() throws -> JSON {
            try CaptureTranscriptPolicyChangedDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try CaptureTranscriptPolicyChangedDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for CaptureTranscriptPolicyChangedDetails: \(error)"
            }
        }
    }

    public class CaptureTranscriptPolicyChangedDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: CaptureTranscriptPolicyChangedDetails) throws -> JSON {
            let output = [
                "new_value": try TeamLog.CaptureTranscriptPolicySerializer().serialize(value.newValue),
                "previous_value": try TeamLog.CaptureTranscriptPolicySerializer().serialize(value.previousValue),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> CaptureTranscriptPolicyChangedDetails {
            switch json {
            case .dictionary(let dict):
                let newValue = try TeamLog.CaptureTranscriptPolicySerializer().deserialize(dict["new_value"] ?? .null)
                let previousValue = try TeamLog.CaptureTranscriptPolicySerializer().deserialize(dict["previous_value"] ?? .null)
                return CaptureTranscriptPolicyChangedDetails(newValue: newValue, previousValue: previousValue)
            default:
                throw JSONSerializerError.deserializeError(type: CaptureTranscriptPolicyChangedDetails.self, json: json)
            }
        }
    }

    /// The CaptureTranscriptPolicyChangedType struct
    public class CaptureTranscriptPolicyChangedType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try CaptureTranscriptPolicyChangedTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try CaptureTranscriptPolicyChangedTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for CaptureTranscriptPolicyChangedType: \(error)"
            }
        }
    }

    public class CaptureTranscriptPolicyChangedTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: CaptureTranscriptPolicyChangedType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> CaptureTranscriptPolicyChangedType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return CaptureTranscriptPolicyChangedType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: CaptureTranscriptPolicyChangedType.self, json: json)
            }
        }
    }

    /// Certificate details.
    public class Certificate: CustomStringConvertible, JSONRepresentable {
        /// Certificate subject.
        public let subject: String
        /// Certificate issuer.
        public let issuer: String
        /// Certificate issue date.
        public let issueDate: String
        /// Certificate expiration date.
        public let expirationDate: String
        /// Certificate serial number.
        public let serialNumber: String
        /// Certificate sha1 fingerprint.
        public let sha1Fingerprint: String
        /// Certificate common name.
        public let commonName: String?
        public init(
            subject: String,
            issuer: String,
            issueDate: String,
            expirationDate: String,
            serialNumber: String,
            sha1Fingerprint: String,
            commonName: String? = nil
        ) {
            stringValidator()(subject)
            self.subject = subject
            stringValidator()(issuer)
            self.issuer = issuer
            stringValidator()(issueDate)
            self.issueDate = issueDate
            stringValidator()(expirationDate)
            self.expirationDate = expirationDate
            stringValidator()(serialNumber)
            self.serialNumber = serialNumber
            stringValidator()(sha1Fingerprint)
            self.sha1Fingerprint = sha1Fingerprint
            nullableValidator(stringValidator())(commonName)
            self.commonName = commonName
        }

        func json() throws -> JSON {
            try CertificateSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try CertificateSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for Certificate: \(error)"
            }
        }
    }

    public class CertificateSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: Certificate) throws -> JSON {
            let output = [
                "subject": try Serialization._StringSerializer.serialize(value.subject),
                "issuer": try Serialization._StringSerializer.serialize(value.issuer),
                "issue_date": try Serialization._StringSerializer.serialize(value.issueDate),
                "expiration_date": try Serialization._StringSerializer.serialize(value.expirationDate),
                "serial_number": try Serialization._StringSerializer.serialize(value.serialNumber),
                "sha1_fingerprint": try Serialization._StringSerializer.serialize(value.sha1Fingerprint),
                "common_name": try NullableSerializer(Serialization._StringSerializer).serialize(value.commonName),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> Certificate {
            switch json {
            case .dictionary(let dict):
                let subject = try Serialization._StringSerializer.deserialize(dict["subject"] ?? .null)
                let issuer = try Serialization._StringSerializer.deserialize(dict["issuer"] ?? .null)
                let issueDate = try Serialization._StringSerializer.deserialize(dict["issue_date"] ?? .null)
                let expirationDate = try Serialization._StringSerializer.deserialize(dict["expiration_date"] ?? .null)
                let serialNumber = try Serialization._StringSerializer.deserialize(dict["serial_number"] ?? .null)
                let sha1Fingerprint = try Serialization._StringSerializer.deserialize(dict["sha1_fingerprint"] ?? .null)
                let commonName = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["common_name"] ?? .null)
                return Certificate(
                    subject: subject,
                    issuer: issuer,
                    issueDate: issueDate,
                    expirationDate: expirationDate,
                    serialNumber: serialNumber,
                    sha1Fingerprint: sha1Fingerprint,
                    commonName: commonName
                )
            default:
                throw JSONSerializerError.deserializeError(type: Certificate.self, json: json)
            }
        }
    }

    /// Policy for deciding whether the team's default expiration days policy must be enforced when an externally shared
    /// link is updated
    public enum ChangeLinkExpirationPolicy: CustomStringConvertible, JSONRepresentable {
        /// An unspecified error.
        case allowed
        /// An unspecified error.
        case notAllowed
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try ChangeLinkExpirationPolicySerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ChangeLinkExpirationPolicySerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ChangeLinkExpirationPolicy: \(error)"
            }
        }
    }

    public class ChangeLinkExpirationPolicySerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ChangeLinkExpirationPolicy) throws -> JSON {
            switch value {
            case .allowed:
                var d = [String: JSON]()
                d[".tag"] = .str("allowed")
                return .dictionary(d)
            case .notAllowed:
                var d = [String: JSON]()
                d[".tag"] = .str("not_allowed")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> ChangeLinkExpirationPolicy {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "allowed":
                    return ChangeLinkExpirationPolicy.allowed
                case "not_allowed":
                    return ChangeLinkExpirationPolicy.notAllowed
                case "other":
                    return ChangeLinkExpirationPolicy.other
                default:
                    return ChangeLinkExpirationPolicy.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: ChangeLinkExpirationPolicy.self, json: json)
            }
        }
    }

    /// Changed enterprise admin role.
    public class ChangedEnterpriseAdminRoleDetails: CustomStringConvertible, JSONRepresentable {
        /// The member&#x2019s previous enterprise admin role.
        public let previousValue: TeamLog.FedAdminRole
        /// The member&#x2019s new enterprise admin role.
        public let newValue: TeamLog.FedAdminRole
        /// The name of the member&#x2019s team.
        public let teamName: String
        public init(previousValue: TeamLog.FedAdminRole, newValue: TeamLog.FedAdminRole, teamName: String) {
            self.previousValue = previousValue
            self.newValue = newValue
            stringValidator()(teamName)
            self.teamName = teamName
        }

        func json() throws -> JSON {
            try ChangedEnterpriseAdminRoleDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ChangedEnterpriseAdminRoleDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ChangedEnterpriseAdminRoleDetails: \(error)"
            }
        }
    }

    public class ChangedEnterpriseAdminRoleDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ChangedEnterpriseAdminRoleDetails) throws -> JSON {
            let output = [
                "previous_value": try TeamLog.FedAdminRoleSerializer().serialize(value.previousValue),
                "new_value": try TeamLog.FedAdminRoleSerializer().serialize(value.newValue),
                "team_name": try Serialization._StringSerializer.serialize(value.teamName),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ChangedEnterpriseAdminRoleDetails {
            switch json {
            case .dictionary(let dict):
                let previousValue = try TeamLog.FedAdminRoleSerializer().deserialize(dict["previous_value"] ?? .null)
                let newValue = try TeamLog.FedAdminRoleSerializer().deserialize(dict["new_value"] ?? .null)
                let teamName = try Serialization._StringSerializer.deserialize(dict["team_name"] ?? .null)
                return ChangedEnterpriseAdminRoleDetails(previousValue: previousValue, newValue: newValue, teamName: teamName)
            default:
                throw JSONSerializerError.deserializeError(type: ChangedEnterpriseAdminRoleDetails.self, json: json)
            }
        }
    }

    /// The ChangedEnterpriseAdminRoleType struct
    public class ChangedEnterpriseAdminRoleType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try ChangedEnterpriseAdminRoleTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ChangedEnterpriseAdminRoleTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ChangedEnterpriseAdminRoleType: \(error)"
            }
        }
    }

    public class ChangedEnterpriseAdminRoleTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ChangedEnterpriseAdminRoleType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ChangedEnterpriseAdminRoleType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return ChangedEnterpriseAdminRoleType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: ChangedEnterpriseAdminRoleType.self, json: json)
            }
        }
    }

    /// Changed enterprise-connected team status.
    public class ChangedEnterpriseConnectedTeamStatusDetails: CustomStringConvertible, JSONRepresentable {
        /// The preformed change in the team&#x2019s connection status.
        public let action: TeamLog.FedHandshakeAction
        /// Additional information about the organization or team.
        public let additionalInfo: TeamLog.FederationStatusChangeAdditionalInfo
        /// Previous request state.
        public let previousValue: TeamLog.TrustedTeamsRequestState
        /// New request state.
        public let newValue: TeamLog.TrustedTeamsRequestState
        public init(
            action: TeamLog.FedHandshakeAction,
            additionalInfo: TeamLog.FederationStatusChangeAdditionalInfo,
            previousValue: TeamLog.TrustedTeamsRequestState,
            newValue: TeamLog.TrustedTeamsRequestState
        ) {
            self.action = action
            self.additionalInfo = additionalInfo
            self.previousValue = previousValue
            self.newValue = newValue
        }

        func json() throws -> JSON {
            try ChangedEnterpriseConnectedTeamStatusDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ChangedEnterpriseConnectedTeamStatusDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ChangedEnterpriseConnectedTeamStatusDetails: \(error)"
            }
        }
    }

    public class ChangedEnterpriseConnectedTeamStatusDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ChangedEnterpriseConnectedTeamStatusDetails) throws -> JSON {
            let output = [
                "action": try TeamLog.FedHandshakeActionSerializer().serialize(value.action),
                "additional_info": try TeamLog.FederationStatusChangeAdditionalInfoSerializer().serialize(value.additionalInfo),
                "previous_value": try TeamLog.TrustedTeamsRequestStateSerializer().serialize(value.previousValue),
                "new_value": try TeamLog.TrustedTeamsRequestStateSerializer().serialize(value.newValue),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ChangedEnterpriseConnectedTeamStatusDetails {
            switch json {
            case .dictionary(let dict):
                let action = try TeamLog.FedHandshakeActionSerializer().deserialize(dict["action"] ?? .null)
                let additionalInfo = try TeamLog.FederationStatusChangeAdditionalInfoSerializer().deserialize(dict["additional_info"] ?? .null)
                let previousValue = try TeamLog.TrustedTeamsRequestStateSerializer().deserialize(dict["previous_value"] ?? .null)
                let newValue = try TeamLog.TrustedTeamsRequestStateSerializer().deserialize(dict["new_value"] ?? .null)
                return ChangedEnterpriseConnectedTeamStatusDetails(
                    action: action,
                    additionalInfo: additionalInfo,
                    previousValue: previousValue,
                    newValue: newValue
                )
            default:
                throw JSONSerializerError.deserializeError(type: ChangedEnterpriseConnectedTeamStatusDetails.self, json: json)
            }
        }
    }

    /// The ChangedEnterpriseConnectedTeamStatusType struct
    public class ChangedEnterpriseConnectedTeamStatusType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try ChangedEnterpriseConnectedTeamStatusTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ChangedEnterpriseConnectedTeamStatusTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ChangedEnterpriseConnectedTeamStatusType: \(error)"
            }
        }
    }

    public class ChangedEnterpriseConnectedTeamStatusTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ChangedEnterpriseConnectedTeamStatusType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ChangedEnterpriseConnectedTeamStatusType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return ChangedEnterpriseConnectedTeamStatusType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: ChangedEnterpriseConnectedTeamStatusType.self, json: json)
            }
        }
    }

    /// Changed classification policy for team.
    public class ClassificationChangePolicyDetails: CustomStringConvertible, JSONRepresentable {
        /// Previous classification policy.
        public let previousValue: TeamLog.ClassificationPolicyEnumWrapper
        /// New classification policy.
        public let newValue: TeamLog.ClassificationPolicyEnumWrapper
        /// Policy type.
        public let classificationType: TeamLog.ClassificationType
        public init(
            previousValue: TeamLog.ClassificationPolicyEnumWrapper,
            newValue: TeamLog.ClassificationPolicyEnumWrapper,
            classificationType: TeamLog.ClassificationType
        ) {
            self.previousValue = previousValue
            self.newValue = newValue
            self.classificationType = classificationType
        }

        func json() throws -> JSON {
            try ClassificationChangePolicyDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ClassificationChangePolicyDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ClassificationChangePolicyDetails: \(error)"
            }
        }
    }

    public class ClassificationChangePolicyDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ClassificationChangePolicyDetails) throws -> JSON {
            let output = [
                "previous_value": try TeamLog.ClassificationPolicyEnumWrapperSerializer().serialize(value.previousValue),
                "new_value": try TeamLog.ClassificationPolicyEnumWrapperSerializer().serialize(value.newValue),
                "classification_type": try TeamLog.ClassificationTypeSerializer().serialize(value.classificationType),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ClassificationChangePolicyDetails {
            switch json {
            case .dictionary(let dict):
                let previousValue = try TeamLog.ClassificationPolicyEnumWrapperSerializer().deserialize(dict["previous_value"] ?? .null)
                let newValue = try TeamLog.ClassificationPolicyEnumWrapperSerializer().deserialize(dict["new_value"] ?? .null)
                let classificationType = try TeamLog.ClassificationTypeSerializer().deserialize(dict["classification_type"] ?? .null)
                return ClassificationChangePolicyDetails(previousValue: previousValue, newValue: newValue, classificationType: classificationType)
            default:
                throw JSONSerializerError.deserializeError(type: ClassificationChangePolicyDetails.self, json: json)
            }
        }
    }

    /// The ClassificationChangePolicyType struct
    public class ClassificationChangePolicyType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try ClassificationChangePolicyTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ClassificationChangePolicyTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ClassificationChangePolicyType: \(error)"
            }
        }
    }

    public class ClassificationChangePolicyTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ClassificationChangePolicyType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ClassificationChangePolicyType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return ClassificationChangePolicyType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: ClassificationChangePolicyType.self, json: json)
            }
        }
    }

    /// Created Classification report.
    public class ClassificationCreateReportDetails: CustomStringConvertible, JSONRepresentable {
        func json() throws -> JSON {
            try ClassificationCreateReportDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ClassificationCreateReportDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ClassificationCreateReportDetails: \(error)"
            }
        }
    }

    public class ClassificationCreateReportDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ClassificationCreateReportDetails) throws -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ClassificationCreateReportDetails {
            switch json {
            case .dictionary:
                return ClassificationCreateReportDetails()
            default:
                throw JSONSerializerError.deserializeError(type: ClassificationCreateReportDetails.self, json: json)
            }
        }
    }

    /// Couldn't create Classification report.
    public class ClassificationCreateReportFailDetails: CustomStringConvertible, JSONRepresentable {
        /// Failure reason.
        public let failureReason: Team.TeamReportFailureReason
        public init(failureReason: Team.TeamReportFailureReason) {
            self.failureReason = failureReason
        }

        func json() throws -> JSON {
            try ClassificationCreateReportFailDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ClassificationCreateReportFailDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ClassificationCreateReportFailDetails: \(error)"
            }
        }
    }

    public class ClassificationCreateReportFailDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ClassificationCreateReportFailDetails) throws -> JSON {
            let output = [
                "failure_reason": try Team.TeamReportFailureReasonSerializer().serialize(value.failureReason),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ClassificationCreateReportFailDetails {
            switch json {
            case .dictionary(let dict):
                let failureReason = try Team.TeamReportFailureReasonSerializer().deserialize(dict["failure_reason"] ?? .null)
                return ClassificationCreateReportFailDetails(failureReason: failureReason)
            default:
                throw JSONSerializerError.deserializeError(type: ClassificationCreateReportFailDetails.self, json: json)
            }
        }
    }

    /// The ClassificationCreateReportFailType struct
    public class ClassificationCreateReportFailType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try ClassificationCreateReportFailTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ClassificationCreateReportFailTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ClassificationCreateReportFailType: \(error)"
            }
        }
    }

    public class ClassificationCreateReportFailTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ClassificationCreateReportFailType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ClassificationCreateReportFailType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return ClassificationCreateReportFailType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: ClassificationCreateReportFailType.self, json: json)
            }
        }
    }

    /// The ClassificationCreateReportType struct
    public class ClassificationCreateReportType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try ClassificationCreateReportTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ClassificationCreateReportTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ClassificationCreateReportType: \(error)"
            }
        }
    }

    public class ClassificationCreateReportTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ClassificationCreateReportType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ClassificationCreateReportType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return ClassificationCreateReportType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: ClassificationCreateReportType.self, json: json)
            }
        }
    }

    /// Policy for controlling team access to the classification feature
    public enum ClassificationPolicyEnumWrapper: CustomStringConvertible, JSONRepresentable {
        /// An unspecified error.
        case disabled
        /// An unspecified error.
        case enabled
        /// An unspecified error.
        case memberAndTeamFolders
        /// An unspecified error.
        case teamFolders
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try ClassificationPolicyEnumWrapperSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ClassificationPolicyEnumWrapperSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ClassificationPolicyEnumWrapper: \(error)"
            }
        }
    }

    public class ClassificationPolicyEnumWrapperSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ClassificationPolicyEnumWrapper) throws -> JSON {
            switch value {
            case .disabled:
                var d = [String: JSON]()
                d[".tag"] = .str("disabled")
                return .dictionary(d)
            case .enabled:
                var d = [String: JSON]()
                d[".tag"] = .str("enabled")
                return .dictionary(d)
            case .memberAndTeamFolders:
                var d = [String: JSON]()
                d[".tag"] = .str("member_and_team_folders")
                return .dictionary(d)
            case .teamFolders:
                var d = [String: JSON]()
                d[".tag"] = .str("team_folders")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> ClassificationPolicyEnumWrapper {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "disabled":
                    return ClassificationPolicyEnumWrapper.disabled
                case "enabled":
                    return ClassificationPolicyEnumWrapper.enabled
                case "member_and_team_folders":
                    return ClassificationPolicyEnumWrapper.memberAndTeamFolders
                case "team_folders":
                    return ClassificationPolicyEnumWrapper.teamFolders
                case "other":
                    return ClassificationPolicyEnumWrapper.other
                default:
                    return ClassificationPolicyEnumWrapper.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: ClassificationPolicyEnumWrapper.self, json: json)
            }
        }
    }

    /// The type of classification (currently only personal information)
    public enum ClassificationType: CustomStringConvertible, JSONRepresentable {
        /// An unspecified error.
        case personalInformation
        /// An unspecified error.
        case pii
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try ClassificationTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ClassificationTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ClassificationType: \(error)"
            }
        }
    }

    public class ClassificationTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ClassificationType) throws -> JSON {
            switch value {
            case .personalInformation:
                var d = [String: JSON]()
                d[".tag"] = .str("personal_information")
                return .dictionary(d)
            case .pii:
                var d = [String: JSON]()
                d[".tag"] = .str("pii")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> ClassificationType {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "personal_information":
                    return ClassificationType.personalInformation
                case "pii":
                    return ClassificationType.pii
                case "other":
                    return ClassificationType.other
                default:
                    return ClassificationType.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: ClassificationType.self, json: json)
            }
        }
    }

    /// Shared album.
    public class CollectionShareDetails: CustomStringConvertible, JSONRepresentable {
        /// Album name.
        public let albumName: String
        public init(albumName: String) {
            stringValidator()(albumName)
            self.albumName = albumName
        }

        func json() throws -> JSON {
            try CollectionShareDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try CollectionShareDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for CollectionShareDetails: \(error)"
            }
        }
    }

    public class CollectionShareDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: CollectionShareDetails) throws -> JSON {
            let output = [
                "album_name": try Serialization._StringSerializer.serialize(value.albumName),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> CollectionShareDetails {
            switch json {
            case .dictionary(let dict):
                let albumName = try Serialization._StringSerializer.deserialize(dict["album_name"] ?? .null)
                return CollectionShareDetails(albumName: albumName)
            default:
                throw JSONSerializerError.deserializeError(type: CollectionShareDetails.self, json: json)
            }
        }
    }

    /// The CollectionShareType struct
    public class CollectionShareType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try CollectionShareTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try CollectionShareTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for CollectionShareType: \(error)"
            }
        }
    }

    public class CollectionShareTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: CollectionShareType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> CollectionShareType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return CollectionShareType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: CollectionShareType.self, json: json)
            }
        }
    }

    /// Policy for controlling team access to computer backup feature
    public enum ComputerBackupPolicy: CustomStringConvertible, JSONRepresentable {
        /// An unspecified error.
        case default_
        /// An unspecified error.
        case disabled
        /// An unspecified error.
        case enabled
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try ComputerBackupPolicySerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ComputerBackupPolicySerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ComputerBackupPolicy: \(error)"
            }
        }
    }

    public class ComputerBackupPolicySerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ComputerBackupPolicy) throws -> JSON {
            switch value {
            case .default_:
                var d = [String: JSON]()
                d[".tag"] = .str("default")
                return .dictionary(d)
            case .disabled:
                var d = [String: JSON]()
                d[".tag"] = .str("disabled")
                return .dictionary(d)
            case .enabled:
                var d = [String: JSON]()
                d[".tag"] = .str("enabled")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> ComputerBackupPolicy {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "default":
                    return ComputerBackupPolicy.default_
                case "disabled":
                    return ComputerBackupPolicy.disabled
                case "enabled":
                    return ComputerBackupPolicy.enabled
                case "other":
                    return ComputerBackupPolicy.other
                default:
                    return ComputerBackupPolicy.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: ComputerBackupPolicy.self, json: json)
            }
        }
    }

    /// Changed computer backup policy for team.
    public class ComputerBackupPolicyChangedDetails: CustomStringConvertible, JSONRepresentable {
        /// New computer backup policy.
        public let newValue: TeamLog.ComputerBackupPolicy
        /// Previous computer backup policy.
        public let previousValue: TeamLog.ComputerBackupPolicy
        public init(newValue: TeamLog.ComputerBackupPolicy, previousValue: TeamLog.ComputerBackupPolicy) {
            self.newValue = newValue
            self.previousValue = previousValue
        }

        func json() throws -> JSON {
            try ComputerBackupPolicyChangedDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ComputerBackupPolicyChangedDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ComputerBackupPolicyChangedDetails: \(error)"
            }
        }
    }

    public class ComputerBackupPolicyChangedDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ComputerBackupPolicyChangedDetails) throws -> JSON {
            let output = [
                "new_value": try TeamLog.ComputerBackupPolicySerializer().serialize(value.newValue),
                "previous_value": try TeamLog.ComputerBackupPolicySerializer().serialize(value.previousValue),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ComputerBackupPolicyChangedDetails {
            switch json {
            case .dictionary(let dict):
                let newValue = try TeamLog.ComputerBackupPolicySerializer().deserialize(dict["new_value"] ?? .null)
                let previousValue = try TeamLog.ComputerBackupPolicySerializer().deserialize(dict["previous_value"] ?? .null)
                return ComputerBackupPolicyChangedDetails(newValue: newValue, previousValue: previousValue)
            default:
                throw JSONSerializerError.deserializeError(type: ComputerBackupPolicyChangedDetails.self, json: json)
            }
        }
    }

    /// The ComputerBackupPolicyChangedType struct
    public class ComputerBackupPolicyChangedType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try ComputerBackupPolicyChangedTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ComputerBackupPolicyChangedTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ComputerBackupPolicyChangedType: \(error)"
            }
        }
    }

    public class ComputerBackupPolicyChangedTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ComputerBackupPolicyChangedType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ComputerBackupPolicyChangedType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return ComputerBackupPolicyChangedType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: ComputerBackupPolicyChangedType.self, json: json)
            }
        }
    }

    /// The name of the team
    public class ConnectedTeamName: CustomStringConvertible, JSONRepresentable {
        /// The name of the team.
        public let team: String
        public init(team: String) {
            stringValidator()(team)
            self.team = team
        }

        func json() throws -> JSON {
            try ConnectedTeamNameSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ConnectedTeamNameSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ConnectedTeamName: \(error)"
            }
        }
    }

    public class ConnectedTeamNameSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ConnectedTeamName) throws -> JSON {
            let output = [
                "team": try Serialization._StringSerializer.serialize(value.team),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ConnectedTeamName {
            switch json {
            case .dictionary(let dict):
                let team = try Serialization._StringSerializer.deserialize(dict["team"] ?? .null)
                return ConnectedTeamName(team: team)
            default:
                throw JSONSerializerError.deserializeError(type: ConnectedTeamName.self, json: json)
            }
        }
    }

    /// Changed content management setting.
    public class ContentAdministrationPolicyChangedDetails: CustomStringConvertible, JSONRepresentable {
        /// New content administration policy.
        public let newValue: String
        /// Previous content administration policy.
        public let previousValue: String
        public init(newValue: String, previousValue: String) {
            stringValidator()(newValue)
            self.newValue = newValue
            stringValidator()(previousValue)
            self.previousValue = previousValue
        }

        func json() throws -> JSON {
            try ContentAdministrationPolicyChangedDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ContentAdministrationPolicyChangedDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ContentAdministrationPolicyChangedDetails: \(error)"
            }
        }
    }

    public class ContentAdministrationPolicyChangedDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ContentAdministrationPolicyChangedDetails) throws -> JSON {
            let output = [
                "new_value": try Serialization._StringSerializer.serialize(value.newValue),
                "previous_value": try Serialization._StringSerializer.serialize(value.previousValue),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ContentAdministrationPolicyChangedDetails {
            switch json {
            case .dictionary(let dict):
                let newValue = try Serialization._StringSerializer.deserialize(dict["new_value"] ?? .null)
                let previousValue = try Serialization._StringSerializer.deserialize(dict["previous_value"] ?? .null)
                return ContentAdministrationPolicyChangedDetails(newValue: newValue, previousValue: previousValue)
            default:
                throw JSONSerializerError.deserializeError(type: ContentAdministrationPolicyChangedDetails.self, json: json)
            }
        }
    }

    /// The ContentAdministrationPolicyChangedType struct
    public class ContentAdministrationPolicyChangedType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try ContentAdministrationPolicyChangedTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ContentAdministrationPolicyChangedTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ContentAdministrationPolicyChangedType: \(error)"
            }
        }
    }

    public class ContentAdministrationPolicyChangedTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ContentAdministrationPolicyChangedType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ContentAdministrationPolicyChangedType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return ContentAdministrationPolicyChangedType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: ContentAdministrationPolicyChangedType.self, json: json)
            }
        }
    }

    /// Policy for pemanent content deletion
    public enum ContentPermanentDeletePolicy: CustomStringConvertible, JSONRepresentable {
        /// An unspecified error.
        case disabled
        /// An unspecified error.
        case enabled
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try ContentPermanentDeletePolicySerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ContentPermanentDeletePolicySerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ContentPermanentDeletePolicy: \(error)"
            }
        }
    }

    public class ContentPermanentDeletePolicySerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ContentPermanentDeletePolicy) throws -> JSON {
            switch value {
            case .disabled:
                var d = [String: JSON]()
                d[".tag"] = .str("disabled")
                return .dictionary(d)
            case .enabled:
                var d = [String: JSON]()
                d[".tag"] = .str("enabled")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> ContentPermanentDeletePolicy {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "disabled":
                    return ContentPermanentDeletePolicy.disabled
                case "enabled":
                    return ContentPermanentDeletePolicy.enabled
                case "other":
                    return ContentPermanentDeletePolicy.other
                default:
                    return ContentPermanentDeletePolicy.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: ContentPermanentDeletePolicy.self, json: json)
            }
        }
    }

    /// The primary entity on which the action was done.
    public enum ContextLogInfo: CustomStringConvertible, JSONRepresentable {
        /// Anonymous context.
        case anonymous
        /// Action was done on behalf of a non team member.
        case nonTeamMember(TeamLog.NonTeamMemberLogInfo)
        /// Action was done on behalf of a team that's part of an organization.
        case organizationTeam(TeamLog.TeamLogInfo)
        /// Action was done on behalf of the team.
        case team
        /// Action was done on behalf of a team member.
        case teamMember(TeamLog.TeamMemberLogInfo)
        /// Action was done on behalf of a trusted non team member.
        case trustedNonTeamMember(TeamLog.TrustedNonTeamMemberLogInfo)
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try ContextLogInfoSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ContextLogInfoSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ContextLogInfo: \(error)"
            }
        }
    }

    public class ContextLogInfoSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ContextLogInfo) throws -> JSON {
            switch value {
            case .anonymous:
                var d = [String: JSON]()
                d[".tag"] = .str("anonymous")
                return .dictionary(d)
            case .nonTeamMember(let arg):
                var d = try Serialization.getFields(TeamLog.NonTeamMemberLogInfoSerializer().serialize(arg))
                d[".tag"] = .str("non_team_member")
                return .dictionary(d)
            case .organizationTeam(let arg):
                var d = try Serialization.getFields(TeamLog.TeamLogInfoSerializer().serialize(arg))
                d[".tag"] = .str("organization_team")
                return .dictionary(d)
            case .team:
                var d = [String: JSON]()
                d[".tag"] = .str("team")
                return .dictionary(d)
            case .teamMember(let arg):
                var d = try Serialization.getFields(TeamLog.TeamMemberLogInfoSerializer().serialize(arg))
                d[".tag"] = .str("team_member")
                return .dictionary(d)
            case .trustedNonTeamMember(let arg):
                var d = try Serialization.getFields(TeamLog.TrustedNonTeamMemberLogInfoSerializer().serialize(arg))
                d[".tag"] = .str("trusted_non_team_member")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> ContextLogInfo {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "anonymous":
                    return ContextLogInfo.anonymous
                case "non_team_member":
                    let v = try TeamLog.NonTeamMemberLogInfoSerializer().deserialize(json)
                    return ContextLogInfo.nonTeamMember(v)
                case "organization_team":
                    let v = try TeamLog.TeamLogInfoSerializer().deserialize(json)
                    return ContextLogInfo.organizationTeam(v)
                case "team":
                    return ContextLogInfo.team
                case "team_member":
                    let v = try TeamLog.TeamMemberLogInfoSerializer().deserialize(json)
                    return ContextLogInfo.teamMember(v)
                case "trusted_non_team_member":
                    let v = try TeamLog.TrustedNonTeamMemberLogInfoSerializer().deserialize(json)
                    return ContextLogInfo.trustedNonTeamMember(v)
                case "other":
                    return ContextLogInfo.other
                default:
                    return ContextLogInfo.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: ContextLogInfo.self, json: json)
            }
        }
    }

    /// Created folders.
    public class CreateFolderDetails: CustomStringConvertible, JSONRepresentable {
        func json() throws -> JSON {
            try CreateFolderDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try CreateFolderDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for CreateFolderDetails: \(error)"
            }
        }
    }

    public class CreateFolderDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: CreateFolderDetails) throws -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> CreateFolderDetails {
            switch json {
            case .dictionary:
                return CreateFolderDetails()
            default:
                throw JSONSerializerError.deserializeError(type: CreateFolderDetails.self, json: json)
            }
        }
    }

    /// The CreateFolderType struct
    public class CreateFolderType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try CreateFolderTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try CreateFolderTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for CreateFolderType: \(error)"
            }
        }
    }

    public class CreateFolderTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: CreateFolderType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> CreateFolderType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return CreateFolderType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: CreateFolderType.self, json: json)
            }
        }
    }

    /// Created team invite link.
    public class CreateTeamInviteLinkDetails: CustomStringConvertible, JSONRepresentable {
        /// The invite link url that was created.
        public let linkUrl: String
        /// The expiration date of the invite link.
        public let expiryDate: String
        public init(linkUrl: String, expiryDate: String) {
            stringValidator()(linkUrl)
            self.linkUrl = linkUrl
            stringValidator()(expiryDate)
            self.expiryDate = expiryDate
        }

        func json() throws -> JSON {
            try CreateTeamInviteLinkDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try CreateTeamInviteLinkDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for CreateTeamInviteLinkDetails: \(error)"
            }
        }
    }

    public class CreateTeamInviteLinkDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: CreateTeamInviteLinkDetails) throws -> JSON {
            let output = [
                "link_url": try Serialization._StringSerializer.serialize(value.linkUrl),
                "expiry_date": try Serialization._StringSerializer.serialize(value.expiryDate),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> CreateTeamInviteLinkDetails {
            switch json {
            case .dictionary(let dict):
                let linkUrl = try Serialization._StringSerializer.deserialize(dict["link_url"] ?? .null)
                let expiryDate = try Serialization._StringSerializer.deserialize(dict["expiry_date"] ?? .null)
                return CreateTeamInviteLinkDetails(linkUrl: linkUrl, expiryDate: expiryDate)
            default:
                throw JSONSerializerError.deserializeError(type: CreateTeamInviteLinkDetails.self, json: json)
            }
        }
    }

    /// The CreateTeamInviteLinkType struct
    public class CreateTeamInviteLinkType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try CreateTeamInviteLinkTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try CreateTeamInviteLinkTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for CreateTeamInviteLinkType: \(error)"
            }
        }
    }

    public class CreateTeamInviteLinkTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: CreateTeamInviteLinkType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> CreateTeamInviteLinkType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return CreateTeamInviteLinkType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: CreateTeamInviteLinkType.self, json: json)
            }
        }
    }

    /// Set restrictions on data center locations where team data resides.
    public class DataPlacementRestrictionChangePolicyDetails: CustomStringConvertible, JSONRepresentable {
        /// Previous placement restriction.
        public let previousValue: TeamLog.PlacementRestriction
        /// New placement restriction.
        public let newValue: TeamLog.PlacementRestriction
        public init(previousValue: TeamLog.PlacementRestriction, newValue: TeamLog.PlacementRestriction) {
            self.previousValue = previousValue
            self.newValue = newValue
        }

        func json() throws -> JSON {
            try DataPlacementRestrictionChangePolicyDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try DataPlacementRestrictionChangePolicyDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for DataPlacementRestrictionChangePolicyDetails: \(error)"
            }
        }
    }

    public class DataPlacementRestrictionChangePolicyDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: DataPlacementRestrictionChangePolicyDetails) throws -> JSON {
            let output = [
                "previous_value": try TeamLog.PlacementRestrictionSerializer().serialize(value.previousValue),
                "new_value": try TeamLog.PlacementRestrictionSerializer().serialize(value.newValue),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> DataPlacementRestrictionChangePolicyDetails {
            switch json {
            case .dictionary(let dict):
                let previousValue = try TeamLog.PlacementRestrictionSerializer().deserialize(dict["previous_value"] ?? .null)
                let newValue = try TeamLog.PlacementRestrictionSerializer().deserialize(dict["new_value"] ?? .null)
                return DataPlacementRestrictionChangePolicyDetails(previousValue: previousValue, newValue: newValue)
            default:
                throw JSONSerializerError.deserializeError(type: DataPlacementRestrictionChangePolicyDetails.self, json: json)
            }
        }
    }

    /// The DataPlacementRestrictionChangePolicyType struct
    public class DataPlacementRestrictionChangePolicyType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try DataPlacementRestrictionChangePolicyTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try DataPlacementRestrictionChangePolicyTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for DataPlacementRestrictionChangePolicyType: \(error)"
            }
        }
    }

    public class DataPlacementRestrictionChangePolicyTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: DataPlacementRestrictionChangePolicyType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> DataPlacementRestrictionChangePolicyType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return DataPlacementRestrictionChangePolicyType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: DataPlacementRestrictionChangePolicyType.self, json: json)
            }
        }
    }

    /// Completed restrictions on data center locations where team data resides.
    public class DataPlacementRestrictionSatisfyPolicyDetails: CustomStringConvertible, JSONRepresentable {
        /// Placement restriction.
        public let placementRestriction: TeamLog.PlacementRestriction
        public init(placementRestriction: TeamLog.PlacementRestriction) {
            self.placementRestriction = placementRestriction
        }

        func json() throws -> JSON {
            try DataPlacementRestrictionSatisfyPolicyDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try DataPlacementRestrictionSatisfyPolicyDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for DataPlacementRestrictionSatisfyPolicyDetails: \(error)"
            }
        }
    }

    public class DataPlacementRestrictionSatisfyPolicyDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: DataPlacementRestrictionSatisfyPolicyDetails) throws -> JSON {
            let output = [
                "placement_restriction": try TeamLog.PlacementRestrictionSerializer().serialize(value.placementRestriction),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> DataPlacementRestrictionSatisfyPolicyDetails {
            switch json {
            case .dictionary(let dict):
                let placementRestriction = try TeamLog.PlacementRestrictionSerializer().deserialize(dict["placement_restriction"] ?? .null)
                return DataPlacementRestrictionSatisfyPolicyDetails(placementRestriction: placementRestriction)
            default:
                throw JSONSerializerError.deserializeError(type: DataPlacementRestrictionSatisfyPolicyDetails.self, json: json)
            }
        }
    }

    /// The DataPlacementRestrictionSatisfyPolicyType struct
    public class DataPlacementRestrictionSatisfyPolicyType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try DataPlacementRestrictionSatisfyPolicyTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try DataPlacementRestrictionSatisfyPolicyTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for DataPlacementRestrictionSatisfyPolicyType: \(error)"
            }
        }
    }

    public class DataPlacementRestrictionSatisfyPolicyTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: DataPlacementRestrictionSatisfyPolicyType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> DataPlacementRestrictionSatisfyPolicyType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return DataPlacementRestrictionSatisfyPolicyType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: DataPlacementRestrictionSatisfyPolicyType.self, json: json)
            }
        }
    }

    /// Requested data residency migration for team data.
    public class DataResidencyMigrationRequestSuccessfulDetails: CustomStringConvertible, JSONRepresentable {
        func json() throws -> JSON {
            try DataResidencyMigrationRequestSuccessfulDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try DataResidencyMigrationRequestSuccessfulDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for DataResidencyMigrationRequestSuccessfulDetails: \(error)"
            }
        }
    }

    public class DataResidencyMigrationRequestSuccessfulDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: DataResidencyMigrationRequestSuccessfulDetails) throws -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> DataResidencyMigrationRequestSuccessfulDetails {
            switch json {
            case .dictionary:
                return DataResidencyMigrationRequestSuccessfulDetails()
            default:
                throw JSONSerializerError.deserializeError(type: DataResidencyMigrationRequestSuccessfulDetails.self, json: json)
            }
        }
    }

    /// The DataResidencyMigrationRequestSuccessfulType struct
    public class DataResidencyMigrationRequestSuccessfulType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try DataResidencyMigrationRequestSuccessfulTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try DataResidencyMigrationRequestSuccessfulTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for DataResidencyMigrationRequestSuccessfulType: \(error)"
            }
        }
    }

    public class DataResidencyMigrationRequestSuccessfulTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: DataResidencyMigrationRequestSuccessfulType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> DataResidencyMigrationRequestSuccessfulType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return DataResidencyMigrationRequestSuccessfulType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: DataResidencyMigrationRequestSuccessfulType.self, json: json)
            }
        }
    }

    /// Request for data residency migration for team data has failed.
    public class DataResidencyMigrationRequestUnsuccessfulDetails: CustomStringConvertible, JSONRepresentable {
        func json() throws -> JSON {
            try DataResidencyMigrationRequestUnsuccessfulDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try DataResidencyMigrationRequestUnsuccessfulDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for DataResidencyMigrationRequestUnsuccessfulDetails: \(error)"
            }
        }
    }

    public class DataResidencyMigrationRequestUnsuccessfulDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: DataResidencyMigrationRequestUnsuccessfulDetails) throws -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> DataResidencyMigrationRequestUnsuccessfulDetails {
            switch json {
            case .dictionary:
                return DataResidencyMigrationRequestUnsuccessfulDetails()
            default:
                throw JSONSerializerError.deserializeError(type: DataResidencyMigrationRequestUnsuccessfulDetails.self, json: json)
            }
        }
    }

    /// The DataResidencyMigrationRequestUnsuccessfulType struct
    public class DataResidencyMigrationRequestUnsuccessfulType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try DataResidencyMigrationRequestUnsuccessfulTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try DataResidencyMigrationRequestUnsuccessfulTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for DataResidencyMigrationRequestUnsuccessfulType: \(error)"
            }
        }
    }

    public class DataResidencyMigrationRequestUnsuccessfulTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: DataResidencyMigrationRequestUnsuccessfulType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> DataResidencyMigrationRequestUnsuccessfulType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return DataResidencyMigrationRequestUnsuccessfulType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: DataResidencyMigrationRequestUnsuccessfulType.self, json: json)
            }
        }
    }

    /// Policy for the default number of days until an externally shared link expires
    public enum DefaultLinkExpirationDaysPolicy: CustomStringConvertible, JSONRepresentable {
        /// An unspecified error.
        case day1
        /// An unspecified error.
        case day180
        /// An unspecified error.
        case day3
        /// An unspecified error.
        case day30
        /// An unspecified error.
        case day7
        /// An unspecified error.
        case day90
        /// An unspecified error.
        case none
        /// An unspecified error.
        case year1
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try DefaultLinkExpirationDaysPolicySerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try DefaultLinkExpirationDaysPolicySerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for DefaultLinkExpirationDaysPolicy: \(error)"
            }
        }
    }

    public class DefaultLinkExpirationDaysPolicySerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: DefaultLinkExpirationDaysPolicy) throws -> JSON {
            switch value {
            case .day1:
                var d = [String: JSON]()
                d[".tag"] = .str("day_1")
                return .dictionary(d)
            case .day180:
                var d = [String: JSON]()
                d[".tag"] = .str("day_180")
                return .dictionary(d)
            case .day3:
                var d = [String: JSON]()
                d[".tag"] = .str("day_3")
                return .dictionary(d)
            case .day30:
                var d = [String: JSON]()
                d[".tag"] = .str("day_30")
                return .dictionary(d)
            case .day7:
                var d = [String: JSON]()
                d[".tag"] = .str("day_7")
                return .dictionary(d)
            case .day90:
                var d = [String: JSON]()
                d[".tag"] = .str("day_90")
                return .dictionary(d)
            case .none:
                var d = [String: JSON]()
                d[".tag"] = .str("none")
                return .dictionary(d)
            case .year1:
                var d = [String: JSON]()
                d[".tag"] = .str("year_1")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> DefaultLinkExpirationDaysPolicy {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "day_1":
                    return DefaultLinkExpirationDaysPolicy.day1
                case "day_180":
                    return DefaultLinkExpirationDaysPolicy.day180
                case "day_3":
                    return DefaultLinkExpirationDaysPolicy.day3
                case "day_30":
                    return DefaultLinkExpirationDaysPolicy.day30
                case "day_7":
                    return DefaultLinkExpirationDaysPolicy.day7
                case "day_90":
                    return DefaultLinkExpirationDaysPolicy.day90
                case "none":
                    return DefaultLinkExpirationDaysPolicy.none
                case "year_1":
                    return DefaultLinkExpirationDaysPolicy.year1
                case "other":
                    return DefaultLinkExpirationDaysPolicy.other
                default:
                    return DefaultLinkExpirationDaysPolicy.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: DefaultLinkExpirationDaysPolicy.self, json: json)
            }
        }
    }

    /// Deleted team invite link.
    public class DeleteTeamInviteLinkDetails: CustomStringConvertible, JSONRepresentable {
        /// The invite link url that was deleted.
        public let linkUrl: String
        public init(linkUrl: String) {
            stringValidator()(linkUrl)
            self.linkUrl = linkUrl
        }

        func json() throws -> JSON {
            try DeleteTeamInviteLinkDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try DeleteTeamInviteLinkDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for DeleteTeamInviteLinkDetails: \(error)"
            }
        }
    }

    public class DeleteTeamInviteLinkDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: DeleteTeamInviteLinkDetails) throws -> JSON {
            let output = [
                "link_url": try Serialization._StringSerializer.serialize(value.linkUrl),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> DeleteTeamInviteLinkDetails {
            switch json {
            case .dictionary(let dict):
                let linkUrl = try Serialization._StringSerializer.deserialize(dict["link_url"] ?? .null)
                return DeleteTeamInviteLinkDetails(linkUrl: linkUrl)
            default:
                throw JSONSerializerError.deserializeError(type: DeleteTeamInviteLinkDetails.self, json: json)
            }
        }
    }

    /// The DeleteTeamInviteLinkType struct
    public class DeleteTeamInviteLinkType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try DeleteTeamInviteLinkTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try DeleteTeamInviteLinkTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for DeleteTeamInviteLinkType: \(error)"
            }
        }
    }

    public class DeleteTeamInviteLinkTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: DeleteTeamInviteLinkType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> DeleteTeamInviteLinkType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return DeleteTeamInviteLinkType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: DeleteTeamInviteLinkType.self, json: json)
            }
        }
    }

    /// Device's session logged information.
    public class DeviceSessionLogInfo: CustomStringConvertible, JSONRepresentable {
        /// The IP address of the last activity from this session.
        public let ipAddress: String?
        /// The time this session was created.
        public let created: Date?
        /// The time of the last activity from this session.
        public let updated: Date?
        public init(ipAddress: String? = nil, created: Date? = nil, updated: Date? = nil) {
            nullableValidator(stringValidator())(ipAddress)
            self.ipAddress = ipAddress
            self.created = created
            self.updated = updated
        }

        func json() throws -> JSON {
            try DeviceSessionLogInfoSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try DeviceSessionLogInfoSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for DeviceSessionLogInfo: \(error)"
            }
        }
    }

    public class DeviceSessionLogInfoSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: DeviceSessionLogInfo) throws -> JSON {
            var output = [
                "ip_address": try NullableSerializer(Serialization._StringSerializer).serialize(value.ipAddress),
                "created": try NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.created),
                "updated": try NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.updated),
            ]
            switch value {
            case let desktopDeviceSession as TeamLog.DesktopDeviceSessionLogInfo:
                for (k, v) in try Serialization.getFields(TeamLog.DesktopDeviceSessionLogInfoSerializer().serialize(desktopDeviceSession)) {
                    output[k] = v
                }
                output[".tag"] = .str("desktop_device_session")
            case let mobileDeviceSession as TeamLog.MobileDeviceSessionLogInfo:
                for (k, v) in try Serialization.getFields(TeamLog.MobileDeviceSessionLogInfoSerializer().serialize(mobileDeviceSession)) {
                    output[k] = v
                }
                output[".tag"] = .str("mobile_device_session")
            case let webDeviceSession as TeamLog.WebDeviceSessionLogInfo:
                for (k, v) in try Serialization.getFields(TeamLog.WebDeviceSessionLogInfoSerializer().serialize(webDeviceSession)) {
                    output[k] = v
                }
                output[".tag"] = .str("web_device_session")
            case let legacyDeviceSession as TeamLog.LegacyDeviceSessionLogInfo:
                for (k, v) in try Serialization.getFields(TeamLog.LegacyDeviceSessionLogInfoSerializer().serialize(legacyDeviceSession)) {
                    output[k] = v
                }
                output[".tag"] = .str("legacy_device_session")
            default:
                throw JSONSerializerError.unexpectedSubtype(type: DeviceSessionLogInfo.self, subtype: value)
            }
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> DeviceSessionLogInfo {
            switch json {
            case .dictionary(let dict):
                let tag = try Serialization.getTag(dict)
                switch tag {
                case "desktop_device_session":
                    return try TeamLog.DesktopDeviceSessionLogInfoSerializer().deserialize(json)
                case "mobile_device_session":
                    return try TeamLog.MobileDeviceSessionLogInfoSerializer().deserialize(json)
                case "web_device_session":
                    return try TeamLog.WebDeviceSessionLogInfoSerializer().deserialize(json)
                case "legacy_device_session":
                    return try TeamLog.LegacyDeviceSessionLogInfoSerializer().deserialize(json)
                default:
                    let ipAddress = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["ip_address"] ?? .null)
                    let created = try NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).deserialize(dict["created"] ?? .null)
                    let updated = try NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).deserialize(dict["updated"] ?? .null)
                    return DeviceSessionLogInfo(ipAddress: ipAddress, created: created, updated: updated)
                }
            default:
                throw JSONSerializerError.deserializeError(type: DeviceSessionLogInfo.self, json: json)
            }
        }
    }

    /// Information about linked Dropbox desktop client sessions
    public class DesktopDeviceSessionLogInfo: TeamLog.DeviceSessionLogInfo {
        /// Desktop session unique id.
        public let sessionInfo: TeamLog.DesktopSessionLogInfo?
        /// Name of the hosting desktop.
        public let hostName: String
        /// The Dropbox desktop client type.
        public let clientType: Team.DesktopPlatform
        /// The Dropbox client version.
        public let clientVersion: String?
        /// Information on the hosting platform.
        public let platform: String
        /// Whether itu2019s possible to delete all of the account files upon unlinking.
        public let isDeleteOnUnlinkSupported: Bool
        public init(
            hostName: String,
            clientType: Team.DesktopPlatform,
            platform: String,
            isDeleteOnUnlinkSupported: Bool,
            ipAddress: String? = nil,
            created: Date? = nil,
            updated: Date? = nil,
            sessionInfo: TeamLog.DesktopSessionLogInfo? = nil,
            clientVersion: String? = nil
        ) {
            self.sessionInfo = sessionInfo
            stringValidator()(hostName)
            self.hostName = hostName
            self.clientType = clientType
            nullableValidator(stringValidator())(clientVersion)
            self.clientVersion = clientVersion
            stringValidator()(platform)
            self.platform = platform
            self.isDeleteOnUnlinkSupported = isDeleteOnUnlinkSupported
            super.init(ipAddress: ipAddress, created: created, updated: updated)
        }

        public override var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try DesktopDeviceSessionLogInfoSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for DesktopDeviceSessionLogInfo: \(error)"
            }
        }
    }

    public class DesktopDeviceSessionLogInfoSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: DesktopDeviceSessionLogInfo) throws -> JSON {
            let output = [
                "host_name": try Serialization._StringSerializer.serialize(value.hostName),
                "client_type": try Team.DesktopPlatformSerializer().serialize(value.clientType),
                "platform": try Serialization._StringSerializer.serialize(value.platform),
                "is_delete_on_unlink_supported": try Serialization._BoolSerializer.serialize(value.isDeleteOnUnlinkSupported),
                "ip_address": try NullableSerializer(Serialization._StringSerializer).serialize(value.ipAddress),
                "created": try NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.created),
                "updated": try NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.updated),
                "session_info": try NullableSerializer(TeamLog.DesktopSessionLogInfoSerializer()).serialize(value.sessionInfo),
                "client_version": try NullableSerializer(Serialization._StringSerializer).serialize(value.clientVersion),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> DesktopDeviceSessionLogInfo {
            switch json {
            case .dictionary(let dict):
                let hostName = try Serialization._StringSerializer.deserialize(dict["host_name"] ?? .null)
                let clientType = try Team.DesktopPlatformSerializer().deserialize(dict["client_type"] ?? .null)
                let platform = try Serialization._StringSerializer.deserialize(dict["platform"] ?? .null)
                let isDeleteOnUnlinkSupported = try Serialization._BoolSerializer.deserialize(dict["is_delete_on_unlink_supported"] ?? .null)
                let ipAddress = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["ip_address"] ?? .null)
                let created = try NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).deserialize(dict["created"] ?? .null)
                let updated = try NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).deserialize(dict["updated"] ?? .null)
                let sessionInfo = try NullableSerializer(TeamLog.DesktopSessionLogInfoSerializer()).deserialize(dict["session_info"] ?? .null)
                let clientVersion = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["client_version"] ?? .null)
                return DesktopDeviceSessionLogInfo(
                    hostName: hostName,
                    clientType: clientType,
                    platform: platform,
                    isDeleteOnUnlinkSupported: isDeleteOnUnlinkSupported,
                    ipAddress: ipAddress,
                    created: created,
                    updated: updated,
                    sessionInfo: sessionInfo,
                    clientVersion: clientVersion
                )
            default:
                throw JSONSerializerError.deserializeError(type: DesktopDeviceSessionLogInfo.self, json: json)
            }
        }
    }

    /// Session's logged information.
    public class SessionLogInfo: CustomStringConvertible, JSONRepresentable {
        /// Session ID.
        public let sessionId: String?
        public init(sessionId: String? = nil) {
            nullableValidator(stringValidator())(sessionId)
            self.sessionId = sessionId
        }

        func json() throws -> JSON {
            try SessionLogInfoSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SessionLogInfoSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SessionLogInfo: \(error)"
            }
        }
    }

    public class SessionLogInfoSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SessionLogInfo) throws -> JSON {
            var output = [
                "session_id": try NullableSerializer(Serialization._StringSerializer).serialize(value.sessionId),
            ]
            switch value {
            case let web as TeamLog.WebSessionLogInfo:
                for (k, v) in try Serialization.getFields(TeamLog.WebSessionLogInfoSerializer().serialize(web)) {
                    output[k] = v
                }
                output[".tag"] = .str("web")
            case let desktop as TeamLog.DesktopSessionLogInfo:
                for (k, v) in try Serialization.getFields(TeamLog.DesktopSessionLogInfoSerializer().serialize(desktop)) {
                    output[k] = v
                }
                output[".tag"] = .str("desktop")
            case let mobile as TeamLog.MobileSessionLogInfo:
                for (k, v) in try Serialization.getFields(TeamLog.MobileSessionLogInfoSerializer().serialize(mobile)) {
                    output[k] = v
                }
                output[".tag"] = .str("mobile")
            default:
                throw JSONSerializerError.unexpectedSubtype(type: SessionLogInfo.self, subtype: value)
            }
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SessionLogInfo {
            switch json {
            case .dictionary(let dict):
                let tag = try Serialization.getTag(dict)
                switch tag {
                case "web":
                    return try TeamLog.WebSessionLogInfoSerializer().deserialize(json)
                case "desktop":
                    return try TeamLog.DesktopSessionLogInfoSerializer().deserialize(json)
                case "mobile":
                    return try TeamLog.MobileSessionLogInfoSerializer().deserialize(json)
                default:
                    let sessionId = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["session_id"] ?? .null)
                    return SessionLogInfo(sessionId: sessionId)
                }
            default:
                throw JSONSerializerError.deserializeError(type: SessionLogInfo.self, json: json)
            }
        }
    }

    /// Desktop session.
    public class DesktopSessionLogInfo: TeamLog.SessionLogInfo {
        public override var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try DesktopSessionLogInfoSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for DesktopSessionLogInfo: \(error)"
            }
        }
    }

    public class DesktopSessionLogInfoSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: DesktopSessionLogInfo) throws -> JSON {
            let output = [
                "session_id": try NullableSerializer(Serialization._StringSerializer).serialize(value.sessionId),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> DesktopSessionLogInfo {
            switch json {
            case .dictionary(let dict):
                let sessionId = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["session_id"] ?? .null)
                return DesktopSessionLogInfo(sessionId: sessionId)
            default:
                throw JSONSerializerError.deserializeError(type: DesktopSessionLogInfo.self, json: json)
            }
        }
    }

    /// Added members to device approvals exception list.
    public class DeviceApprovalsAddExceptionDetails: CustomStringConvertible, JSONRepresentable {
        func json() throws -> JSON {
            try DeviceApprovalsAddExceptionDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try DeviceApprovalsAddExceptionDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for DeviceApprovalsAddExceptionDetails: \(error)"
            }
        }
    }

    public class DeviceApprovalsAddExceptionDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: DeviceApprovalsAddExceptionDetails) throws -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> DeviceApprovalsAddExceptionDetails {
            switch json {
            case .dictionary:
                return DeviceApprovalsAddExceptionDetails()
            default:
                throw JSONSerializerError.deserializeError(type: DeviceApprovalsAddExceptionDetails.self, json: json)
            }
        }
    }

    /// The DeviceApprovalsAddExceptionType struct
    public class DeviceApprovalsAddExceptionType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try DeviceApprovalsAddExceptionTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try DeviceApprovalsAddExceptionTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for DeviceApprovalsAddExceptionType: \(error)"
            }
        }
    }

    public class DeviceApprovalsAddExceptionTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: DeviceApprovalsAddExceptionType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> DeviceApprovalsAddExceptionType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return DeviceApprovalsAddExceptionType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: DeviceApprovalsAddExceptionType.self, json: json)
            }
        }
    }

    /// Set/removed limit on number of computers member can link to team Dropbox account.
    public class DeviceApprovalsChangeDesktopPolicyDetails: CustomStringConvertible, JSONRepresentable {
        /// New desktop device approvals policy. Might be missing due to historical data gap.
        public let newValue: TeamLog.DeviceApprovalsPolicy?
        /// Previous desktop device approvals policy. Might be missing due to historical data gap.
        public let previousValue: TeamLog.DeviceApprovalsPolicy?
        public init(newValue: TeamLog.DeviceApprovalsPolicy? = nil, previousValue: TeamLog.DeviceApprovalsPolicy? = nil) {
            self.newValue = newValue
            self.previousValue = previousValue
        }

        func json() throws -> JSON {
            try DeviceApprovalsChangeDesktopPolicyDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try DeviceApprovalsChangeDesktopPolicyDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for DeviceApprovalsChangeDesktopPolicyDetails: \(error)"
            }
        }
    }

    public class DeviceApprovalsChangeDesktopPolicyDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: DeviceApprovalsChangeDesktopPolicyDetails) throws -> JSON {
            let output = [
                "new_value": try NullableSerializer(TeamLog.DeviceApprovalsPolicySerializer()).serialize(value.newValue),
                "previous_value": try NullableSerializer(TeamLog.DeviceApprovalsPolicySerializer()).serialize(value.previousValue),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> DeviceApprovalsChangeDesktopPolicyDetails {
            switch json {
            case .dictionary(let dict):
                let newValue = try NullableSerializer(TeamLog.DeviceApprovalsPolicySerializer()).deserialize(dict["new_value"] ?? .null)
                let previousValue = try NullableSerializer(TeamLog.DeviceApprovalsPolicySerializer()).deserialize(dict["previous_value"] ?? .null)
                return DeviceApprovalsChangeDesktopPolicyDetails(newValue: newValue, previousValue: previousValue)
            default:
                throw JSONSerializerError.deserializeError(type: DeviceApprovalsChangeDesktopPolicyDetails.self, json: json)
            }
        }
    }

    /// The DeviceApprovalsChangeDesktopPolicyType struct
    public class DeviceApprovalsChangeDesktopPolicyType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try DeviceApprovalsChangeDesktopPolicyTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try DeviceApprovalsChangeDesktopPolicyTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for DeviceApprovalsChangeDesktopPolicyType: \(error)"
            }
        }
    }

    public class DeviceApprovalsChangeDesktopPolicyTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: DeviceApprovalsChangeDesktopPolicyType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> DeviceApprovalsChangeDesktopPolicyType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return DeviceApprovalsChangeDesktopPolicyType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: DeviceApprovalsChangeDesktopPolicyType.self, json: json)
            }
        }
    }

    /// Set/removed limit on number of mobile devices member can link to team Dropbox account.
    public class DeviceApprovalsChangeMobilePolicyDetails: CustomStringConvertible, JSONRepresentable {
        /// New mobile device approvals policy. Might be missing due to historical data gap.
        public let newValue: TeamLog.DeviceApprovalsPolicy?
        /// Previous mobile device approvals policy. Might be missing due to historical data gap.
        public let previousValue: TeamLog.DeviceApprovalsPolicy?
        public init(newValue: TeamLog.DeviceApprovalsPolicy? = nil, previousValue: TeamLog.DeviceApprovalsPolicy? = nil) {
            self.newValue = newValue
            self.previousValue = previousValue
        }

        func json() throws -> JSON {
            try DeviceApprovalsChangeMobilePolicyDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try DeviceApprovalsChangeMobilePolicyDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for DeviceApprovalsChangeMobilePolicyDetails: \(error)"
            }
        }
    }

    public class DeviceApprovalsChangeMobilePolicyDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: DeviceApprovalsChangeMobilePolicyDetails) throws -> JSON {
            let output = [
                "new_value": try NullableSerializer(TeamLog.DeviceApprovalsPolicySerializer()).serialize(value.newValue),
                "previous_value": try NullableSerializer(TeamLog.DeviceApprovalsPolicySerializer()).serialize(value.previousValue),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> DeviceApprovalsChangeMobilePolicyDetails {
            switch json {
            case .dictionary(let dict):
                let newValue = try NullableSerializer(TeamLog.DeviceApprovalsPolicySerializer()).deserialize(dict["new_value"] ?? .null)
                let previousValue = try NullableSerializer(TeamLog.DeviceApprovalsPolicySerializer()).deserialize(dict["previous_value"] ?? .null)
                return DeviceApprovalsChangeMobilePolicyDetails(newValue: newValue, previousValue: previousValue)
            default:
                throw JSONSerializerError.deserializeError(type: DeviceApprovalsChangeMobilePolicyDetails.self, json: json)
            }
        }
    }

    /// The DeviceApprovalsChangeMobilePolicyType struct
    public class DeviceApprovalsChangeMobilePolicyType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try DeviceApprovalsChangeMobilePolicyTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try DeviceApprovalsChangeMobilePolicyTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for DeviceApprovalsChangeMobilePolicyType: \(error)"
            }
        }
    }

    public class DeviceApprovalsChangeMobilePolicyTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: DeviceApprovalsChangeMobilePolicyType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> DeviceApprovalsChangeMobilePolicyType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return DeviceApprovalsChangeMobilePolicyType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: DeviceApprovalsChangeMobilePolicyType.self, json: json)
            }
        }
    }

    /// Changed device approvals setting when member is over limit.
    public class DeviceApprovalsChangeOverageActionDetails: CustomStringConvertible, JSONRepresentable {
        /// New over the limits policy. Might be missing due to historical data gap.
        public let newValue: TeamPolicies.RolloutMethod?
        /// Previous over the limit policy. Might be missing due to historical data gap.
        public let previousValue: TeamPolicies.RolloutMethod?
        public init(newValue: TeamPolicies.RolloutMethod? = nil, previousValue: TeamPolicies.RolloutMethod? = nil) {
            self.newValue = newValue
            self.previousValue = previousValue
        }

        func json() throws -> JSON {
            try DeviceApprovalsChangeOverageActionDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try DeviceApprovalsChangeOverageActionDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for DeviceApprovalsChangeOverageActionDetails: \(error)"
            }
        }
    }

    public class DeviceApprovalsChangeOverageActionDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: DeviceApprovalsChangeOverageActionDetails) throws -> JSON {
            let output = [
                "new_value": try NullableSerializer(TeamPolicies.RolloutMethodSerializer()).serialize(value.newValue),
                "previous_value": try NullableSerializer(TeamPolicies.RolloutMethodSerializer()).serialize(value.previousValue),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> DeviceApprovalsChangeOverageActionDetails {
            switch json {
            case .dictionary(let dict):
                let newValue = try NullableSerializer(TeamPolicies.RolloutMethodSerializer()).deserialize(dict["new_value"] ?? .null)
                let previousValue = try NullableSerializer(TeamPolicies.RolloutMethodSerializer()).deserialize(dict["previous_value"] ?? .null)
                return DeviceApprovalsChangeOverageActionDetails(newValue: newValue, previousValue: previousValue)
            default:
                throw JSONSerializerError.deserializeError(type: DeviceApprovalsChangeOverageActionDetails.self, json: json)
            }
        }
    }

    /// The DeviceApprovalsChangeOverageActionType struct
    public class DeviceApprovalsChangeOverageActionType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try DeviceApprovalsChangeOverageActionTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try DeviceApprovalsChangeOverageActionTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for DeviceApprovalsChangeOverageActionType: \(error)"
            }
        }
    }

    public class DeviceApprovalsChangeOverageActionTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: DeviceApprovalsChangeOverageActionType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> DeviceApprovalsChangeOverageActionType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return DeviceApprovalsChangeOverageActionType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: DeviceApprovalsChangeOverageActionType.self, json: json)
            }
        }
    }

    /// Changed device approvals setting when member unlinks approved device.
    public class DeviceApprovalsChangeUnlinkActionDetails: CustomStringConvertible, JSONRepresentable {
        /// New device unlink policy. Might be missing due to historical data gap.
        public let newValue: TeamLog.DeviceUnlinkPolicy?
        /// Previous device unlink policy. Might be missing due to historical data gap.
        public let previousValue: TeamLog.DeviceUnlinkPolicy?
        public init(newValue: TeamLog.DeviceUnlinkPolicy? = nil, previousValue: TeamLog.DeviceUnlinkPolicy? = nil) {
            self.newValue = newValue
            self.previousValue = previousValue
        }

        func json() throws -> JSON {
            try DeviceApprovalsChangeUnlinkActionDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try DeviceApprovalsChangeUnlinkActionDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for DeviceApprovalsChangeUnlinkActionDetails: \(error)"
            }
        }
    }

    public class DeviceApprovalsChangeUnlinkActionDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: DeviceApprovalsChangeUnlinkActionDetails) throws -> JSON {
            let output = [
                "new_value": try NullableSerializer(TeamLog.DeviceUnlinkPolicySerializer()).serialize(value.newValue),
                "previous_value": try NullableSerializer(TeamLog.DeviceUnlinkPolicySerializer()).serialize(value.previousValue),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> DeviceApprovalsChangeUnlinkActionDetails {
            switch json {
            case .dictionary(let dict):
                let newValue = try NullableSerializer(TeamLog.DeviceUnlinkPolicySerializer()).deserialize(dict["new_value"] ?? .null)
                let previousValue = try NullableSerializer(TeamLog.DeviceUnlinkPolicySerializer()).deserialize(dict["previous_value"] ?? .null)
                return DeviceApprovalsChangeUnlinkActionDetails(newValue: newValue, previousValue: previousValue)
            default:
                throw JSONSerializerError.deserializeError(type: DeviceApprovalsChangeUnlinkActionDetails.self, json: json)
            }
        }
    }

    /// The DeviceApprovalsChangeUnlinkActionType struct
    public class DeviceApprovalsChangeUnlinkActionType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try DeviceApprovalsChangeUnlinkActionTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try DeviceApprovalsChangeUnlinkActionTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for DeviceApprovalsChangeUnlinkActionType: \(error)"
            }
        }
    }

    public class DeviceApprovalsChangeUnlinkActionTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: DeviceApprovalsChangeUnlinkActionType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> DeviceApprovalsChangeUnlinkActionType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return DeviceApprovalsChangeUnlinkActionType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: DeviceApprovalsChangeUnlinkActionType.self, json: json)
            }
        }
    }

    /// The DeviceApprovalsPolicy union
    public enum DeviceApprovalsPolicy: CustomStringConvertible, JSONRepresentable {
        /// An unspecified error.
        case limited
        /// An unspecified error.
        case unlimited
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try DeviceApprovalsPolicySerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try DeviceApprovalsPolicySerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for DeviceApprovalsPolicy: \(error)"
            }
        }
    }

    public class DeviceApprovalsPolicySerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: DeviceApprovalsPolicy) throws -> JSON {
            switch value {
            case .limited:
                var d = [String: JSON]()
                d[".tag"] = .str("limited")
                return .dictionary(d)
            case .unlimited:
                var d = [String: JSON]()
                d[".tag"] = .str("unlimited")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> DeviceApprovalsPolicy {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "limited":
                    return DeviceApprovalsPolicy.limited
                case "unlimited":
                    return DeviceApprovalsPolicy.unlimited
                case "other":
                    return DeviceApprovalsPolicy.other
                default:
                    return DeviceApprovalsPolicy.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: DeviceApprovalsPolicy.self, json: json)
            }
        }
    }

    /// Removed members from device approvals exception list.
    public class DeviceApprovalsRemoveExceptionDetails: CustomStringConvertible, JSONRepresentable {
        func json() throws -> JSON {
            try DeviceApprovalsRemoveExceptionDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try DeviceApprovalsRemoveExceptionDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for DeviceApprovalsRemoveExceptionDetails: \(error)"
            }
        }
    }

    public class DeviceApprovalsRemoveExceptionDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: DeviceApprovalsRemoveExceptionDetails) throws -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> DeviceApprovalsRemoveExceptionDetails {
            switch json {
            case .dictionary:
                return DeviceApprovalsRemoveExceptionDetails()
            default:
                throw JSONSerializerError.deserializeError(type: DeviceApprovalsRemoveExceptionDetails.self, json: json)
            }
        }
    }

    /// The DeviceApprovalsRemoveExceptionType struct
    public class DeviceApprovalsRemoveExceptionType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try DeviceApprovalsRemoveExceptionTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try DeviceApprovalsRemoveExceptionTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for DeviceApprovalsRemoveExceptionType: \(error)"
            }
        }
    }

    public class DeviceApprovalsRemoveExceptionTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: DeviceApprovalsRemoveExceptionType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> DeviceApprovalsRemoveExceptionType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return DeviceApprovalsRemoveExceptionType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: DeviceApprovalsRemoveExceptionType.self, json: json)
            }
        }
    }

    /// Changed IP address associated with active desktop session.
    public class DeviceChangeIpDesktopDetails: CustomStringConvertible, JSONRepresentable {
        /// Device's session logged information.
        public let deviceSessionInfo: TeamLog.DeviceSessionLogInfo
        public init(deviceSessionInfo: TeamLog.DeviceSessionLogInfo) {
            self.deviceSessionInfo = deviceSessionInfo
        }

        func json() throws -> JSON {
            try DeviceChangeIpDesktopDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try DeviceChangeIpDesktopDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for DeviceChangeIpDesktopDetails: \(error)"
            }
        }
    }

    public class DeviceChangeIpDesktopDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: DeviceChangeIpDesktopDetails) throws -> JSON {
            let output = [
                "device_session_info": try TeamLog.DeviceSessionLogInfoSerializer().serialize(value.deviceSessionInfo),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> DeviceChangeIpDesktopDetails {
            switch json {
            case .dictionary(let dict):
                let deviceSessionInfo = try TeamLog.DeviceSessionLogInfoSerializer().deserialize(dict["device_session_info"] ?? .null)
                return DeviceChangeIpDesktopDetails(deviceSessionInfo: deviceSessionInfo)
            default:
                throw JSONSerializerError.deserializeError(type: DeviceChangeIpDesktopDetails.self, json: json)
            }
        }
    }

    /// The DeviceChangeIpDesktopType struct
    public class DeviceChangeIpDesktopType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try DeviceChangeIpDesktopTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try DeviceChangeIpDesktopTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for DeviceChangeIpDesktopType: \(error)"
            }
        }
    }

    public class DeviceChangeIpDesktopTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: DeviceChangeIpDesktopType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> DeviceChangeIpDesktopType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return DeviceChangeIpDesktopType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: DeviceChangeIpDesktopType.self, json: json)
            }
        }
    }

    /// Changed IP address associated with active mobile session.
    public class DeviceChangeIpMobileDetails: CustomStringConvertible, JSONRepresentable {
        /// Device's session logged information.
        public let deviceSessionInfo: TeamLog.DeviceSessionLogInfo?
        public init(deviceSessionInfo: TeamLog.DeviceSessionLogInfo? = nil) {
            self.deviceSessionInfo = deviceSessionInfo
        }

        func json() throws -> JSON {
            try DeviceChangeIpMobileDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try DeviceChangeIpMobileDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for DeviceChangeIpMobileDetails: \(error)"
            }
        }
    }

    public class DeviceChangeIpMobileDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: DeviceChangeIpMobileDetails) throws -> JSON {
            let output = [
                "device_session_info": try NullableSerializer(TeamLog.DeviceSessionLogInfoSerializer()).serialize(value.deviceSessionInfo),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> DeviceChangeIpMobileDetails {
            switch json {
            case .dictionary(let dict):
                let deviceSessionInfo = try NullableSerializer(TeamLog.DeviceSessionLogInfoSerializer()).deserialize(dict["device_session_info"] ?? .null)
                return DeviceChangeIpMobileDetails(deviceSessionInfo: deviceSessionInfo)
            default:
                throw JSONSerializerError.deserializeError(type: DeviceChangeIpMobileDetails.self, json: json)
            }
        }
    }

    /// The DeviceChangeIpMobileType struct
    public class DeviceChangeIpMobileType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try DeviceChangeIpMobileTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try DeviceChangeIpMobileTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for DeviceChangeIpMobileType: \(error)"
            }
        }
    }

    public class DeviceChangeIpMobileTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: DeviceChangeIpMobileType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> DeviceChangeIpMobileType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return DeviceChangeIpMobileType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: DeviceChangeIpMobileType.self, json: json)
            }
        }
    }

    /// Changed IP address associated with active web session.
    public class DeviceChangeIpWebDetails: CustomStringConvertible, JSONRepresentable {
        /// Web browser name.
        public let userAgent: String
        public init(userAgent: String) {
            stringValidator()(userAgent)
            self.userAgent = userAgent
        }

        func json() throws -> JSON {
            try DeviceChangeIpWebDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try DeviceChangeIpWebDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for DeviceChangeIpWebDetails: \(error)"
            }
        }
    }

    public class DeviceChangeIpWebDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: DeviceChangeIpWebDetails) throws -> JSON {
            let output = [
                "user_agent": try Serialization._StringSerializer.serialize(value.userAgent),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> DeviceChangeIpWebDetails {
            switch json {
            case .dictionary(let dict):
                let userAgent = try Serialization._StringSerializer.deserialize(dict["user_agent"] ?? .null)
                return DeviceChangeIpWebDetails(userAgent: userAgent)
            default:
                throw JSONSerializerError.deserializeError(type: DeviceChangeIpWebDetails.self, json: json)
            }
        }
    }

    /// The DeviceChangeIpWebType struct
    public class DeviceChangeIpWebType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try DeviceChangeIpWebTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try DeviceChangeIpWebTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for DeviceChangeIpWebType: \(error)"
            }
        }
    }

    public class DeviceChangeIpWebTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: DeviceChangeIpWebType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> DeviceChangeIpWebType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return DeviceChangeIpWebType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: DeviceChangeIpWebType.self, json: json)
            }
        }
    }

    /// Failed to delete all files from unlinked device.
    public class DeviceDeleteOnUnlinkFailDetails: CustomStringConvertible, JSONRepresentable {
        /// Session unique id.
        public let sessionInfo: TeamLog.SessionLogInfo?
        /// The device name. Might be missing due to historical data gap.
        public let displayName: String?
        /// The number of times that remote file deletion failed.
        public let numFailures: Int64
        public init(numFailures: Int64, sessionInfo: TeamLog.SessionLogInfo? = nil, displayName: String? = nil) {
            self.sessionInfo = sessionInfo
            nullableValidator(stringValidator())(displayName)
            self.displayName = displayName
            comparableValidator()(numFailures)
            self.numFailures = numFailures
        }

        func json() throws -> JSON {
            try DeviceDeleteOnUnlinkFailDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try DeviceDeleteOnUnlinkFailDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for DeviceDeleteOnUnlinkFailDetails: \(error)"
            }
        }
    }

    public class DeviceDeleteOnUnlinkFailDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: DeviceDeleteOnUnlinkFailDetails) throws -> JSON {
            let output = [
                "num_failures": try Serialization._Int64Serializer.serialize(value.numFailures),
                "session_info": try NullableSerializer(TeamLog.SessionLogInfoSerializer()).serialize(value.sessionInfo),
                "display_name": try NullableSerializer(Serialization._StringSerializer).serialize(value.displayName),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> DeviceDeleteOnUnlinkFailDetails {
            switch json {
            case .dictionary(let dict):
                let numFailures = try Serialization._Int64Serializer.deserialize(dict["num_failures"] ?? .null)
                let sessionInfo = try NullableSerializer(TeamLog.SessionLogInfoSerializer()).deserialize(dict["session_info"] ?? .null)
                let displayName = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["display_name"] ?? .null)
                return DeviceDeleteOnUnlinkFailDetails(numFailures: numFailures, sessionInfo: sessionInfo, displayName: displayName)
            default:
                throw JSONSerializerError.deserializeError(type: DeviceDeleteOnUnlinkFailDetails.self, json: json)
            }
        }
    }

    /// The DeviceDeleteOnUnlinkFailType struct
    public class DeviceDeleteOnUnlinkFailType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try DeviceDeleteOnUnlinkFailTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try DeviceDeleteOnUnlinkFailTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for DeviceDeleteOnUnlinkFailType: \(error)"
            }
        }
    }

    public class DeviceDeleteOnUnlinkFailTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: DeviceDeleteOnUnlinkFailType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> DeviceDeleteOnUnlinkFailType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return DeviceDeleteOnUnlinkFailType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: DeviceDeleteOnUnlinkFailType.self, json: json)
            }
        }
    }

    /// Deleted all files from unlinked device.
    public class DeviceDeleteOnUnlinkSuccessDetails: CustomStringConvertible, JSONRepresentable {
        /// Session unique id.
        public let sessionInfo: TeamLog.SessionLogInfo?
        /// The device name. Might be missing due to historical data gap.
        public let displayName: String?
        public init(sessionInfo: TeamLog.SessionLogInfo? = nil, displayName: String? = nil) {
            self.sessionInfo = sessionInfo
            nullableValidator(stringValidator())(displayName)
            self.displayName = displayName
        }

        func json() throws -> JSON {
            try DeviceDeleteOnUnlinkSuccessDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try DeviceDeleteOnUnlinkSuccessDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for DeviceDeleteOnUnlinkSuccessDetails: \(error)"
            }
        }
    }

    public class DeviceDeleteOnUnlinkSuccessDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: DeviceDeleteOnUnlinkSuccessDetails) throws -> JSON {
            let output = [
                "session_info": try NullableSerializer(TeamLog.SessionLogInfoSerializer()).serialize(value.sessionInfo),
                "display_name": try NullableSerializer(Serialization._StringSerializer).serialize(value.displayName),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> DeviceDeleteOnUnlinkSuccessDetails {
            switch json {
            case .dictionary(let dict):
                let sessionInfo = try NullableSerializer(TeamLog.SessionLogInfoSerializer()).deserialize(dict["session_info"] ?? .null)
                let displayName = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["display_name"] ?? .null)
                return DeviceDeleteOnUnlinkSuccessDetails(sessionInfo: sessionInfo, displayName: displayName)
            default:
                throw JSONSerializerError.deserializeError(type: DeviceDeleteOnUnlinkSuccessDetails.self, json: json)
            }
        }
    }

    /// The DeviceDeleteOnUnlinkSuccessType struct
    public class DeviceDeleteOnUnlinkSuccessType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try DeviceDeleteOnUnlinkSuccessTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try DeviceDeleteOnUnlinkSuccessTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for DeviceDeleteOnUnlinkSuccessType: \(error)"
            }
        }
    }

    public class DeviceDeleteOnUnlinkSuccessTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: DeviceDeleteOnUnlinkSuccessType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> DeviceDeleteOnUnlinkSuccessType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return DeviceDeleteOnUnlinkSuccessType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: DeviceDeleteOnUnlinkSuccessType.self, json: json)
            }
        }
    }

    /// Failed to link device.
    public class DeviceLinkFailDetails: CustomStringConvertible, JSONRepresentable {
        /// IP address. Might be missing due to historical data gap.
        public let ipAddress: String?
        /// A description of the device used while user approval blocked.
        public let deviceType: TeamLog.DeviceType
        public init(deviceType: TeamLog.DeviceType, ipAddress: String? = nil) {
            nullableValidator(stringValidator())(ipAddress)
            self.ipAddress = ipAddress
            self.deviceType = deviceType
        }

        func json() throws -> JSON {
            try DeviceLinkFailDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try DeviceLinkFailDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for DeviceLinkFailDetails: \(error)"
            }
        }
    }

    public class DeviceLinkFailDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: DeviceLinkFailDetails) throws -> JSON {
            let output = [
                "device_type": try TeamLog.DeviceTypeSerializer().serialize(value.deviceType),
                "ip_address": try NullableSerializer(Serialization._StringSerializer).serialize(value.ipAddress),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> DeviceLinkFailDetails {
            switch json {
            case .dictionary(let dict):
                let deviceType = try TeamLog.DeviceTypeSerializer().deserialize(dict["device_type"] ?? .null)
                let ipAddress = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["ip_address"] ?? .null)
                return DeviceLinkFailDetails(deviceType: deviceType, ipAddress: ipAddress)
            default:
                throw JSONSerializerError.deserializeError(type: DeviceLinkFailDetails.self, json: json)
            }
        }
    }

    /// The DeviceLinkFailType struct
    public class DeviceLinkFailType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try DeviceLinkFailTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try DeviceLinkFailTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for DeviceLinkFailType: \(error)"
            }
        }
    }

    public class DeviceLinkFailTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: DeviceLinkFailType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> DeviceLinkFailType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return DeviceLinkFailType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: DeviceLinkFailType.self, json: json)
            }
        }
    }

    /// Linked device.
    public class DeviceLinkSuccessDetails: CustomStringConvertible, JSONRepresentable {
        /// Device's session logged information.
        public let deviceSessionInfo: TeamLog.DeviceSessionLogInfo?
        public init(deviceSessionInfo: TeamLog.DeviceSessionLogInfo? = nil) {
            self.deviceSessionInfo = deviceSessionInfo
        }

        func json() throws -> JSON {
            try DeviceLinkSuccessDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try DeviceLinkSuccessDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for DeviceLinkSuccessDetails: \(error)"
            }
        }
    }

    public class DeviceLinkSuccessDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: DeviceLinkSuccessDetails) throws -> JSON {
            let output = [
                "device_session_info": try NullableSerializer(TeamLog.DeviceSessionLogInfoSerializer()).serialize(value.deviceSessionInfo),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> DeviceLinkSuccessDetails {
            switch json {
            case .dictionary(let dict):
                let deviceSessionInfo = try NullableSerializer(TeamLog.DeviceSessionLogInfoSerializer()).deserialize(dict["device_session_info"] ?? .null)
                return DeviceLinkSuccessDetails(deviceSessionInfo: deviceSessionInfo)
            default:
                throw JSONSerializerError.deserializeError(type: DeviceLinkSuccessDetails.self, json: json)
            }
        }
    }

    /// The DeviceLinkSuccessType struct
    public class DeviceLinkSuccessType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try DeviceLinkSuccessTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try DeviceLinkSuccessTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for DeviceLinkSuccessType: \(error)"
            }
        }
    }

    public class DeviceLinkSuccessTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: DeviceLinkSuccessType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> DeviceLinkSuccessType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return DeviceLinkSuccessType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: DeviceLinkSuccessType.self, json: json)
            }
        }
    }

    /// Disabled device management.
    public class DeviceManagementDisabledDetails: CustomStringConvertible, JSONRepresentable {
        func json() throws -> JSON {
            try DeviceManagementDisabledDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try DeviceManagementDisabledDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for DeviceManagementDisabledDetails: \(error)"
            }
        }
    }

    public class DeviceManagementDisabledDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: DeviceManagementDisabledDetails) throws -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> DeviceManagementDisabledDetails {
            switch json {
            case .dictionary:
                return DeviceManagementDisabledDetails()
            default:
                throw JSONSerializerError.deserializeError(type: DeviceManagementDisabledDetails.self, json: json)
            }
        }
    }

    /// The DeviceManagementDisabledType struct
    public class DeviceManagementDisabledType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try DeviceManagementDisabledTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try DeviceManagementDisabledTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for DeviceManagementDisabledType: \(error)"
            }
        }
    }

    public class DeviceManagementDisabledTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: DeviceManagementDisabledType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> DeviceManagementDisabledType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return DeviceManagementDisabledType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: DeviceManagementDisabledType.self, json: json)
            }
        }
    }

    /// Enabled device management.
    public class DeviceManagementEnabledDetails: CustomStringConvertible, JSONRepresentable {
        func json() throws -> JSON {
            try DeviceManagementEnabledDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try DeviceManagementEnabledDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for DeviceManagementEnabledDetails: \(error)"
            }
        }
    }

    public class DeviceManagementEnabledDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: DeviceManagementEnabledDetails) throws -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> DeviceManagementEnabledDetails {
            switch json {
            case .dictionary:
                return DeviceManagementEnabledDetails()
            default:
                throw JSONSerializerError.deserializeError(type: DeviceManagementEnabledDetails.self, json: json)
            }
        }
    }

    /// The DeviceManagementEnabledType struct
    public class DeviceManagementEnabledType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try DeviceManagementEnabledTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try DeviceManagementEnabledTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for DeviceManagementEnabledType: \(error)"
            }
        }
    }

    public class DeviceManagementEnabledTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: DeviceManagementEnabledType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> DeviceManagementEnabledType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return DeviceManagementEnabledType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: DeviceManagementEnabledType.self, json: json)
            }
        }
    }

    /// Enabled/disabled backup for computer.
    public class DeviceSyncBackupStatusChangedDetails: CustomStringConvertible, JSONRepresentable {
        /// Device's session logged information.
        public let desktopDeviceSessionInfo: TeamLog.DesktopDeviceSessionLogInfo
        /// Previous status of computer backup on the device.
        public let previousValue: TeamLog.BackupStatus
        /// Next status of computer backup on the device.
        public let newValue: TeamLog.BackupStatus
        public init(desktopDeviceSessionInfo: TeamLog.DesktopDeviceSessionLogInfo, previousValue: TeamLog.BackupStatus, newValue: TeamLog.BackupStatus) {
            self.desktopDeviceSessionInfo = desktopDeviceSessionInfo
            self.previousValue = previousValue
            self.newValue = newValue
        }

        func json() throws -> JSON {
            try DeviceSyncBackupStatusChangedDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try DeviceSyncBackupStatusChangedDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for DeviceSyncBackupStatusChangedDetails: \(error)"
            }
        }
    }

    public class DeviceSyncBackupStatusChangedDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: DeviceSyncBackupStatusChangedDetails) throws -> JSON {
            let output = [
                "desktop_device_session_info": try TeamLog.DesktopDeviceSessionLogInfoSerializer().serialize(value.desktopDeviceSessionInfo),
                "previous_value": try TeamLog.BackupStatusSerializer().serialize(value.previousValue),
                "new_value": try TeamLog.BackupStatusSerializer().serialize(value.newValue),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> DeviceSyncBackupStatusChangedDetails {
            switch json {
            case .dictionary(let dict):
                let desktopDeviceSessionInfo = try TeamLog.DesktopDeviceSessionLogInfoSerializer().deserialize(dict["desktop_device_session_info"] ?? .null)
                let previousValue = try TeamLog.BackupStatusSerializer().deserialize(dict["previous_value"] ?? .null)
                let newValue = try TeamLog.BackupStatusSerializer().deserialize(dict["new_value"] ?? .null)
                return DeviceSyncBackupStatusChangedDetails(
                    desktopDeviceSessionInfo: desktopDeviceSessionInfo,
                    previousValue: previousValue,
                    newValue: newValue
                )
            default:
                throw JSONSerializerError.deserializeError(type: DeviceSyncBackupStatusChangedDetails.self, json: json)
            }
        }
    }

    /// The DeviceSyncBackupStatusChangedType struct
    public class DeviceSyncBackupStatusChangedType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try DeviceSyncBackupStatusChangedTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try DeviceSyncBackupStatusChangedTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for DeviceSyncBackupStatusChangedType: \(error)"
            }
        }
    }

    public class DeviceSyncBackupStatusChangedTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: DeviceSyncBackupStatusChangedType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> DeviceSyncBackupStatusChangedType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return DeviceSyncBackupStatusChangedType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: DeviceSyncBackupStatusChangedType.self, json: json)
            }
        }
    }

    /// The DeviceType union
    public enum DeviceType: CustomStringConvertible, JSONRepresentable {
        /// An unspecified error.
        case desktop
        /// An unspecified error.
        case mobile
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try DeviceTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try DeviceTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for DeviceType: \(error)"
            }
        }
    }

    public class DeviceTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: DeviceType) throws -> JSON {
            switch value {
            case .desktop:
                var d = [String: JSON]()
                d[".tag"] = .str("desktop")
                return .dictionary(d)
            case .mobile:
                var d = [String: JSON]()
                d[".tag"] = .str("mobile")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> DeviceType {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "desktop":
                    return DeviceType.desktop
                case "mobile":
                    return DeviceType.mobile
                case "other":
                    return DeviceType.other
                default:
                    return DeviceType.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: DeviceType.self, json: json)
            }
        }
    }

    /// Disconnected device.
    public class DeviceUnlinkDetails: CustomStringConvertible, JSONRepresentable {
        /// Session unique id.
        public let sessionInfo: TeamLog.SessionLogInfo?
        /// The device name. Might be missing due to historical data gap.
        public let displayName: String?
        /// True if the user requested to delete data after device unlink, false otherwise.
        public let deleteData: Bool
        public init(deleteData: Bool, sessionInfo: TeamLog.SessionLogInfo? = nil, displayName: String? = nil) {
            self.sessionInfo = sessionInfo
            nullableValidator(stringValidator())(displayName)
            self.displayName = displayName
            self.deleteData = deleteData
        }

        func json() throws -> JSON {
            try DeviceUnlinkDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try DeviceUnlinkDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for DeviceUnlinkDetails: \(error)"
            }
        }
    }

    public class DeviceUnlinkDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: DeviceUnlinkDetails) throws -> JSON {
            let output = [
                "delete_data": try Serialization._BoolSerializer.serialize(value.deleteData),
                "session_info": try NullableSerializer(TeamLog.SessionLogInfoSerializer()).serialize(value.sessionInfo),
                "display_name": try NullableSerializer(Serialization._StringSerializer).serialize(value.displayName),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> DeviceUnlinkDetails {
            switch json {
            case .dictionary(let dict):
                let deleteData = try Serialization._BoolSerializer.deserialize(dict["delete_data"] ?? .null)
                let sessionInfo = try NullableSerializer(TeamLog.SessionLogInfoSerializer()).deserialize(dict["session_info"] ?? .null)
                let displayName = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["display_name"] ?? .null)
                return DeviceUnlinkDetails(deleteData: deleteData, sessionInfo: sessionInfo, displayName: displayName)
            default:
                throw JSONSerializerError.deserializeError(type: DeviceUnlinkDetails.self, json: json)
            }
        }
    }

    /// The DeviceUnlinkPolicy union
    public enum DeviceUnlinkPolicy: CustomStringConvertible, JSONRepresentable {
        /// An unspecified error.
        case keep
        /// An unspecified error.
        case remove
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try DeviceUnlinkPolicySerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try DeviceUnlinkPolicySerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for DeviceUnlinkPolicy: \(error)"
            }
        }
    }

    public class DeviceUnlinkPolicySerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: DeviceUnlinkPolicy) throws -> JSON {
            switch value {
            case .keep:
                var d = [String: JSON]()
                d[".tag"] = .str("keep")
                return .dictionary(d)
            case .remove:
                var d = [String: JSON]()
                d[".tag"] = .str("remove")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> DeviceUnlinkPolicy {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "keep":
                    return DeviceUnlinkPolicy.keep
                case "remove":
                    return DeviceUnlinkPolicy.remove
                case "other":
                    return DeviceUnlinkPolicy.other
                default:
                    return DeviceUnlinkPolicy.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: DeviceUnlinkPolicy.self, json: json)
            }
        }
    }

    /// The DeviceUnlinkType struct
    public class DeviceUnlinkType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try DeviceUnlinkTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try DeviceUnlinkTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for DeviceUnlinkType: \(error)"
            }
        }
    }

    public class DeviceUnlinkTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: DeviceUnlinkType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> DeviceUnlinkType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return DeviceUnlinkType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: DeviceUnlinkType.self, json: json)
            }
        }
    }

    /// Added members to directory restrictions list.
    public class DirectoryRestrictionsAddMembersDetails: CustomStringConvertible, JSONRepresentable {
        func json() throws -> JSON {
            try DirectoryRestrictionsAddMembersDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try DirectoryRestrictionsAddMembersDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for DirectoryRestrictionsAddMembersDetails: \(error)"
            }
        }
    }

    public class DirectoryRestrictionsAddMembersDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: DirectoryRestrictionsAddMembersDetails) throws -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> DirectoryRestrictionsAddMembersDetails {
            switch json {
            case .dictionary:
                return DirectoryRestrictionsAddMembersDetails()
            default:
                throw JSONSerializerError.deserializeError(type: DirectoryRestrictionsAddMembersDetails.self, json: json)
            }
        }
    }

    /// The DirectoryRestrictionsAddMembersType struct
    public class DirectoryRestrictionsAddMembersType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try DirectoryRestrictionsAddMembersTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try DirectoryRestrictionsAddMembersTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for DirectoryRestrictionsAddMembersType: \(error)"
            }
        }
    }

    public class DirectoryRestrictionsAddMembersTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: DirectoryRestrictionsAddMembersType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> DirectoryRestrictionsAddMembersType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return DirectoryRestrictionsAddMembersType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: DirectoryRestrictionsAddMembersType.self, json: json)
            }
        }
    }

    /// Removed members from directory restrictions list.
    public class DirectoryRestrictionsRemoveMembersDetails: CustomStringConvertible, JSONRepresentable {
        func json() throws -> JSON {
            try DirectoryRestrictionsRemoveMembersDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try DirectoryRestrictionsRemoveMembersDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for DirectoryRestrictionsRemoveMembersDetails: \(error)"
            }
        }
    }

    public class DirectoryRestrictionsRemoveMembersDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: DirectoryRestrictionsRemoveMembersDetails) throws -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> DirectoryRestrictionsRemoveMembersDetails {
            switch json {
            case .dictionary:
                return DirectoryRestrictionsRemoveMembersDetails()
            default:
                throw JSONSerializerError.deserializeError(type: DirectoryRestrictionsRemoveMembersDetails.self, json: json)
            }
        }
    }

    /// The DirectoryRestrictionsRemoveMembersType struct
    public class DirectoryRestrictionsRemoveMembersType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try DirectoryRestrictionsRemoveMembersTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try DirectoryRestrictionsRemoveMembersTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for DirectoryRestrictionsRemoveMembersType: \(error)"
            }
        }
    }

    public class DirectoryRestrictionsRemoveMembersTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: DirectoryRestrictionsRemoveMembersType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> DirectoryRestrictionsRemoveMembersType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return DirectoryRestrictionsRemoveMembersType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: DirectoryRestrictionsRemoveMembersType.self, json: json)
            }
        }
    }

    /// Disabled domain invites.
    public class DisabledDomainInvitesDetails: CustomStringConvertible, JSONRepresentable {
        func json() throws -> JSON {
            try DisabledDomainInvitesDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try DisabledDomainInvitesDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for DisabledDomainInvitesDetails: \(error)"
            }
        }
    }

    public class DisabledDomainInvitesDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: DisabledDomainInvitesDetails) throws -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> DisabledDomainInvitesDetails {
            switch json {
            case .dictionary:
                return DisabledDomainInvitesDetails()
            default:
                throw JSONSerializerError.deserializeError(type: DisabledDomainInvitesDetails.self, json: json)
            }
        }
    }

    /// The DisabledDomainInvitesType struct
    public class DisabledDomainInvitesType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try DisabledDomainInvitesTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try DisabledDomainInvitesTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for DisabledDomainInvitesType: \(error)"
            }
        }
    }

    public class DisabledDomainInvitesTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: DisabledDomainInvitesType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> DisabledDomainInvitesType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return DisabledDomainInvitesType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: DisabledDomainInvitesType.self, json: json)
            }
        }
    }

    /// The DispositionActionType union
    public enum DispositionActionType: CustomStringConvertible, JSONRepresentable {
        /// An unspecified error.
        case automaticDelete
        /// An unspecified error.
        case automaticPermanentlyDelete
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try DispositionActionTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try DispositionActionTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for DispositionActionType: \(error)"
            }
        }
    }

    public class DispositionActionTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: DispositionActionType) throws -> JSON {
            switch value {
            case .automaticDelete:
                var d = [String: JSON]()
                d[".tag"] = .str("automatic_delete")
                return .dictionary(d)
            case .automaticPermanentlyDelete:
                var d = [String: JSON]()
                d[".tag"] = .str("automatic_permanently_delete")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> DispositionActionType {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "automatic_delete":
                    return DispositionActionType.automaticDelete
                case "automatic_permanently_delete":
                    return DispositionActionType.automaticPermanentlyDelete
                case "other":
                    return DispositionActionType.other
                default:
                    return DispositionActionType.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: DispositionActionType.self, json: json)
            }
        }
    }

    /// Approved user's request to join team.
    public class DomainInvitesApproveRequestToJoinTeamDetails: CustomStringConvertible, JSONRepresentable {
        func json() throws -> JSON {
            try DomainInvitesApproveRequestToJoinTeamDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try DomainInvitesApproveRequestToJoinTeamDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for DomainInvitesApproveRequestToJoinTeamDetails: \(error)"
            }
        }
    }

    public class DomainInvitesApproveRequestToJoinTeamDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: DomainInvitesApproveRequestToJoinTeamDetails) throws -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> DomainInvitesApproveRequestToJoinTeamDetails {
            switch json {
            case .dictionary:
                return DomainInvitesApproveRequestToJoinTeamDetails()
            default:
                throw JSONSerializerError.deserializeError(type: DomainInvitesApproveRequestToJoinTeamDetails.self, json: json)
            }
        }
    }

    /// The DomainInvitesApproveRequestToJoinTeamType struct
    public class DomainInvitesApproveRequestToJoinTeamType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try DomainInvitesApproveRequestToJoinTeamTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try DomainInvitesApproveRequestToJoinTeamTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for DomainInvitesApproveRequestToJoinTeamType: \(error)"
            }
        }
    }

    public class DomainInvitesApproveRequestToJoinTeamTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: DomainInvitesApproveRequestToJoinTeamType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> DomainInvitesApproveRequestToJoinTeamType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return DomainInvitesApproveRequestToJoinTeamType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: DomainInvitesApproveRequestToJoinTeamType.self, json: json)
            }
        }
    }

    /// Declined user's request to join team.
    public class DomainInvitesDeclineRequestToJoinTeamDetails: CustomStringConvertible, JSONRepresentable {
        func json() throws -> JSON {
            try DomainInvitesDeclineRequestToJoinTeamDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try DomainInvitesDeclineRequestToJoinTeamDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for DomainInvitesDeclineRequestToJoinTeamDetails: \(error)"
            }
        }
    }

    public class DomainInvitesDeclineRequestToJoinTeamDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: DomainInvitesDeclineRequestToJoinTeamDetails) throws -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> DomainInvitesDeclineRequestToJoinTeamDetails {
            switch json {
            case .dictionary:
                return DomainInvitesDeclineRequestToJoinTeamDetails()
            default:
                throw JSONSerializerError.deserializeError(type: DomainInvitesDeclineRequestToJoinTeamDetails.self, json: json)
            }
        }
    }

    /// The DomainInvitesDeclineRequestToJoinTeamType struct
    public class DomainInvitesDeclineRequestToJoinTeamType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try DomainInvitesDeclineRequestToJoinTeamTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try DomainInvitesDeclineRequestToJoinTeamTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for DomainInvitesDeclineRequestToJoinTeamType: \(error)"
            }
        }
    }

    public class DomainInvitesDeclineRequestToJoinTeamTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: DomainInvitesDeclineRequestToJoinTeamType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> DomainInvitesDeclineRequestToJoinTeamType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return DomainInvitesDeclineRequestToJoinTeamType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: DomainInvitesDeclineRequestToJoinTeamType.self, json: json)
            }
        }
    }

    /// Sent domain invites to existing domain accounts.
    public class DomainInvitesEmailExistingUsersDetails: CustomStringConvertible, JSONRepresentable {
        /// Domain names.
        public let domainName: String
        /// Number of recipients.
        public let numRecipients: UInt64
        public init(domainName: String, numRecipients: UInt64) {
            stringValidator()(domainName)
            self.domainName = domainName
            comparableValidator()(numRecipients)
            self.numRecipients = numRecipients
        }

        func json() throws -> JSON {
            try DomainInvitesEmailExistingUsersDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try DomainInvitesEmailExistingUsersDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for DomainInvitesEmailExistingUsersDetails: \(error)"
            }
        }
    }

    public class DomainInvitesEmailExistingUsersDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: DomainInvitesEmailExistingUsersDetails) throws -> JSON {
            let output = [
                "domain_name": try Serialization._StringSerializer.serialize(value.domainName),
                "num_recipients": try Serialization._UInt64Serializer.serialize(value.numRecipients),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> DomainInvitesEmailExistingUsersDetails {
            switch json {
            case .dictionary(let dict):
                let domainName = try Serialization._StringSerializer.deserialize(dict["domain_name"] ?? .null)
                let numRecipients = try Serialization._UInt64Serializer.deserialize(dict["num_recipients"] ?? .null)
                return DomainInvitesEmailExistingUsersDetails(domainName: domainName, numRecipients: numRecipients)
            default:
                throw JSONSerializerError.deserializeError(type: DomainInvitesEmailExistingUsersDetails.self, json: json)
            }
        }
    }

    /// The DomainInvitesEmailExistingUsersType struct
    public class DomainInvitesEmailExistingUsersType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try DomainInvitesEmailExistingUsersTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try DomainInvitesEmailExistingUsersTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for DomainInvitesEmailExistingUsersType: \(error)"
            }
        }
    }

    public class DomainInvitesEmailExistingUsersTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: DomainInvitesEmailExistingUsersType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> DomainInvitesEmailExistingUsersType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return DomainInvitesEmailExistingUsersType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: DomainInvitesEmailExistingUsersType.self, json: json)
            }
        }
    }

    /// Requested to join team.
    public class DomainInvitesRequestToJoinTeamDetails: CustomStringConvertible, JSONRepresentable {
        func json() throws -> JSON {
            try DomainInvitesRequestToJoinTeamDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try DomainInvitesRequestToJoinTeamDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for DomainInvitesRequestToJoinTeamDetails: \(error)"
            }
        }
    }

    public class DomainInvitesRequestToJoinTeamDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: DomainInvitesRequestToJoinTeamDetails) throws -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> DomainInvitesRequestToJoinTeamDetails {
            switch json {
            case .dictionary:
                return DomainInvitesRequestToJoinTeamDetails()
            default:
                throw JSONSerializerError.deserializeError(type: DomainInvitesRequestToJoinTeamDetails.self, json: json)
            }
        }
    }

    /// The DomainInvitesRequestToJoinTeamType struct
    public class DomainInvitesRequestToJoinTeamType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try DomainInvitesRequestToJoinTeamTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try DomainInvitesRequestToJoinTeamTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for DomainInvitesRequestToJoinTeamType: \(error)"
            }
        }
    }

    public class DomainInvitesRequestToJoinTeamTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: DomainInvitesRequestToJoinTeamType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> DomainInvitesRequestToJoinTeamType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return DomainInvitesRequestToJoinTeamType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: DomainInvitesRequestToJoinTeamType.self, json: json)
            }
        }
    }

    /// Disabled "Automatically invite new users".
    public class DomainInvitesSetInviteNewUserPrefToNoDetails: CustomStringConvertible, JSONRepresentable {
        func json() throws -> JSON {
            try DomainInvitesSetInviteNewUserPrefToNoDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try DomainInvitesSetInviteNewUserPrefToNoDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for DomainInvitesSetInviteNewUserPrefToNoDetails: \(error)"
            }
        }
    }

    public class DomainInvitesSetInviteNewUserPrefToNoDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: DomainInvitesSetInviteNewUserPrefToNoDetails) throws -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> DomainInvitesSetInviteNewUserPrefToNoDetails {
            switch json {
            case .dictionary:
                return DomainInvitesSetInviteNewUserPrefToNoDetails()
            default:
                throw JSONSerializerError.deserializeError(type: DomainInvitesSetInviteNewUserPrefToNoDetails.self, json: json)
            }
        }
    }

    /// The DomainInvitesSetInviteNewUserPrefToNoType struct
    public class DomainInvitesSetInviteNewUserPrefToNoType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try DomainInvitesSetInviteNewUserPrefToNoTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try DomainInvitesSetInviteNewUserPrefToNoTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for DomainInvitesSetInviteNewUserPrefToNoType: \(error)"
            }
        }
    }

    public class DomainInvitesSetInviteNewUserPrefToNoTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: DomainInvitesSetInviteNewUserPrefToNoType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> DomainInvitesSetInviteNewUserPrefToNoType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return DomainInvitesSetInviteNewUserPrefToNoType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: DomainInvitesSetInviteNewUserPrefToNoType.self, json: json)
            }
        }
    }

    /// Enabled "Automatically invite new users".
    public class DomainInvitesSetInviteNewUserPrefToYesDetails: CustomStringConvertible, JSONRepresentable {
        func json() throws -> JSON {
            try DomainInvitesSetInviteNewUserPrefToYesDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try DomainInvitesSetInviteNewUserPrefToYesDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for DomainInvitesSetInviteNewUserPrefToYesDetails: \(error)"
            }
        }
    }

    public class DomainInvitesSetInviteNewUserPrefToYesDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: DomainInvitesSetInviteNewUserPrefToYesDetails) throws -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> DomainInvitesSetInviteNewUserPrefToYesDetails {
            switch json {
            case .dictionary:
                return DomainInvitesSetInviteNewUserPrefToYesDetails()
            default:
                throw JSONSerializerError.deserializeError(type: DomainInvitesSetInviteNewUserPrefToYesDetails.self, json: json)
            }
        }
    }

    /// The DomainInvitesSetInviteNewUserPrefToYesType struct
    public class DomainInvitesSetInviteNewUserPrefToYesType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try DomainInvitesSetInviteNewUserPrefToYesTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try DomainInvitesSetInviteNewUserPrefToYesTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for DomainInvitesSetInviteNewUserPrefToYesType: \(error)"
            }
        }
    }

    public class DomainInvitesSetInviteNewUserPrefToYesTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: DomainInvitesSetInviteNewUserPrefToYesType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> DomainInvitesSetInviteNewUserPrefToYesType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return DomainInvitesSetInviteNewUserPrefToYesType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: DomainInvitesSetInviteNewUserPrefToYesType.self, json: json)
            }
        }
    }

    /// Failed to verify team domain.
    public class DomainVerificationAddDomainFailDetails: CustomStringConvertible, JSONRepresentable {
        /// Domain name.
        public let domainName: String
        /// Domain name verification method. Might be missing due to historical data gap.
        public let verificationMethod: String?
        public init(domainName: String, verificationMethod: String? = nil) {
            stringValidator()(domainName)
            self.domainName = domainName
            nullableValidator(stringValidator())(verificationMethod)
            self.verificationMethod = verificationMethod
        }

        func json() throws -> JSON {
            try DomainVerificationAddDomainFailDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try DomainVerificationAddDomainFailDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for DomainVerificationAddDomainFailDetails: \(error)"
            }
        }
    }

    public class DomainVerificationAddDomainFailDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: DomainVerificationAddDomainFailDetails) throws -> JSON {
            let output = [
                "domain_name": try Serialization._StringSerializer.serialize(value.domainName),
                "verification_method": try NullableSerializer(Serialization._StringSerializer).serialize(value.verificationMethod),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> DomainVerificationAddDomainFailDetails {
            switch json {
            case .dictionary(let dict):
                let domainName = try Serialization._StringSerializer.deserialize(dict["domain_name"] ?? .null)
                let verificationMethod = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["verification_method"] ?? .null)
                return DomainVerificationAddDomainFailDetails(domainName: domainName, verificationMethod: verificationMethod)
            default:
                throw JSONSerializerError.deserializeError(type: DomainVerificationAddDomainFailDetails.self, json: json)
            }
        }
    }

    /// The DomainVerificationAddDomainFailType struct
    public class DomainVerificationAddDomainFailType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try DomainVerificationAddDomainFailTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try DomainVerificationAddDomainFailTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for DomainVerificationAddDomainFailType: \(error)"
            }
        }
    }

    public class DomainVerificationAddDomainFailTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: DomainVerificationAddDomainFailType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> DomainVerificationAddDomainFailType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return DomainVerificationAddDomainFailType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: DomainVerificationAddDomainFailType.self, json: json)
            }
        }
    }

    /// Verified team domain.
    public class DomainVerificationAddDomainSuccessDetails: CustomStringConvertible, JSONRepresentable {
        /// Domain names.
        public let domainNames: [String]
        /// Domain name verification method. Might be missing due to historical data gap.
        public let verificationMethod: String?
        public init(domainNames: [String], verificationMethod: String? = nil) {
            arrayValidator(itemValidator: stringValidator())(domainNames)
            self.domainNames = domainNames
            nullableValidator(stringValidator())(verificationMethod)
            self.verificationMethod = verificationMethod
        }

        func json() throws -> JSON {
            try DomainVerificationAddDomainSuccessDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try DomainVerificationAddDomainSuccessDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for DomainVerificationAddDomainSuccessDetails: \(error)"
            }
        }
    }

    public class DomainVerificationAddDomainSuccessDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: DomainVerificationAddDomainSuccessDetails) throws -> JSON {
            let output = [
                "domain_names": try ArraySerializer(Serialization._StringSerializer).serialize(value.domainNames),
                "verification_method": try NullableSerializer(Serialization._StringSerializer).serialize(value.verificationMethod),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> DomainVerificationAddDomainSuccessDetails {
            switch json {
            case .dictionary(let dict):
                let domainNames = try ArraySerializer(Serialization._StringSerializer).deserialize(dict["domain_names"] ?? .null)
                let verificationMethod = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["verification_method"] ?? .null)
                return DomainVerificationAddDomainSuccessDetails(domainNames: domainNames, verificationMethod: verificationMethod)
            default:
                throw JSONSerializerError.deserializeError(type: DomainVerificationAddDomainSuccessDetails.self, json: json)
            }
        }
    }

    /// The DomainVerificationAddDomainSuccessType struct
    public class DomainVerificationAddDomainSuccessType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try DomainVerificationAddDomainSuccessTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try DomainVerificationAddDomainSuccessTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for DomainVerificationAddDomainSuccessType: \(error)"
            }
        }
    }

    public class DomainVerificationAddDomainSuccessTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: DomainVerificationAddDomainSuccessType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> DomainVerificationAddDomainSuccessType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return DomainVerificationAddDomainSuccessType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: DomainVerificationAddDomainSuccessType.self, json: json)
            }
        }
    }

    /// Removed domain from list of verified team domains.
    public class DomainVerificationRemoveDomainDetails: CustomStringConvertible, JSONRepresentable {
        /// Domain names.
        public let domainNames: [String]
        public init(domainNames: [String]) {
            arrayValidator(itemValidator: stringValidator())(domainNames)
            self.domainNames = domainNames
        }

        func json() throws -> JSON {
            try DomainVerificationRemoveDomainDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try DomainVerificationRemoveDomainDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for DomainVerificationRemoveDomainDetails: \(error)"
            }
        }
    }

    public class DomainVerificationRemoveDomainDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: DomainVerificationRemoveDomainDetails) throws -> JSON {
            let output = [
                "domain_names": try ArraySerializer(Serialization._StringSerializer).serialize(value.domainNames),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> DomainVerificationRemoveDomainDetails {
            switch json {
            case .dictionary(let dict):
                let domainNames = try ArraySerializer(Serialization._StringSerializer).deserialize(dict["domain_names"] ?? .null)
                return DomainVerificationRemoveDomainDetails(domainNames: domainNames)
            default:
                throw JSONSerializerError.deserializeError(type: DomainVerificationRemoveDomainDetails.self, json: json)
            }
        }
    }

    /// The DomainVerificationRemoveDomainType struct
    public class DomainVerificationRemoveDomainType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try DomainVerificationRemoveDomainTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try DomainVerificationRemoveDomainTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for DomainVerificationRemoveDomainType: \(error)"
            }
        }
    }

    public class DomainVerificationRemoveDomainTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: DomainVerificationRemoveDomainType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> DomainVerificationRemoveDomainType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return DomainVerificationRemoveDomainType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: DomainVerificationRemoveDomainType.self, json: json)
            }
        }
    }

    /// Shared content downloads policy
    public enum DownloadPolicyType: CustomStringConvertible, JSONRepresentable {
        /// An unspecified error.
        case allow
        /// An unspecified error.
        case disallow
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try DownloadPolicyTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try DownloadPolicyTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for DownloadPolicyType: \(error)"
            }
        }
    }

    public class DownloadPolicyTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: DownloadPolicyType) throws -> JSON {
            switch value {
            case .allow:
                var d = [String: JSON]()
                d[".tag"] = .str("allow")
                return .dictionary(d)
            case .disallow:
                var d = [String: JSON]()
                d[".tag"] = .str("disallow")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> DownloadPolicyType {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "allow":
                    return DownloadPolicyType.allow
                case "disallow":
                    return DownloadPolicyType.disallow
                case "other":
                    return DownloadPolicyType.other
                default:
                    return DownloadPolicyType.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: DownloadPolicyType.self, json: json)
            }
        }
    }

    /// Exported passwords.
    public class DropboxPasswordsExportedDetails: CustomStringConvertible, JSONRepresentable {
        /// The platform the device runs export.
        public let platform: String
        public init(platform: String) {
            stringValidator()(platform)
            self.platform = platform
        }

        func json() throws -> JSON {
            try DropboxPasswordsExportedDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try DropboxPasswordsExportedDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for DropboxPasswordsExportedDetails: \(error)"
            }
        }
    }

    public class DropboxPasswordsExportedDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: DropboxPasswordsExportedDetails) throws -> JSON {
            let output = [
                "platform": try Serialization._StringSerializer.serialize(value.platform),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> DropboxPasswordsExportedDetails {
            switch json {
            case .dictionary(let dict):
                let platform = try Serialization._StringSerializer.deserialize(dict["platform"] ?? .null)
                return DropboxPasswordsExportedDetails(platform: platform)
            default:
                throw JSONSerializerError.deserializeError(type: DropboxPasswordsExportedDetails.self, json: json)
            }
        }
    }

    /// The DropboxPasswordsExportedType struct
    public class DropboxPasswordsExportedType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try DropboxPasswordsExportedTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try DropboxPasswordsExportedTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for DropboxPasswordsExportedType: \(error)"
            }
        }
    }

    public class DropboxPasswordsExportedTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: DropboxPasswordsExportedType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> DropboxPasswordsExportedType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return DropboxPasswordsExportedType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: DropboxPasswordsExportedType.self, json: json)
            }
        }
    }

    /// Enrolled new Dropbox Passwords device.
    public class DropboxPasswordsNewDeviceEnrolledDetails: CustomStringConvertible, JSONRepresentable {
        /// Whether it's a first device enrolled.
        public let isFirstDevice: Bool
        /// The platform the device is enrolled.
        public let platform: String
        public init(isFirstDevice: Bool, platform: String) {
            self.isFirstDevice = isFirstDevice
            stringValidator()(platform)
            self.platform = platform
        }

        func json() throws -> JSON {
            try DropboxPasswordsNewDeviceEnrolledDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try DropboxPasswordsNewDeviceEnrolledDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for DropboxPasswordsNewDeviceEnrolledDetails: \(error)"
            }
        }
    }

    public class DropboxPasswordsNewDeviceEnrolledDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: DropboxPasswordsNewDeviceEnrolledDetails) throws -> JSON {
            let output = [
                "is_first_device": try Serialization._BoolSerializer.serialize(value.isFirstDevice),
                "platform": try Serialization._StringSerializer.serialize(value.platform),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> DropboxPasswordsNewDeviceEnrolledDetails {
            switch json {
            case .dictionary(let dict):
                let isFirstDevice = try Serialization._BoolSerializer.deserialize(dict["is_first_device"] ?? .null)
                let platform = try Serialization._StringSerializer.deserialize(dict["platform"] ?? .null)
                return DropboxPasswordsNewDeviceEnrolledDetails(isFirstDevice: isFirstDevice, platform: platform)
            default:
                throw JSONSerializerError.deserializeError(type: DropboxPasswordsNewDeviceEnrolledDetails.self, json: json)
            }
        }
    }

    /// The DropboxPasswordsNewDeviceEnrolledType struct
    public class DropboxPasswordsNewDeviceEnrolledType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try DropboxPasswordsNewDeviceEnrolledTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try DropboxPasswordsNewDeviceEnrolledTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for DropboxPasswordsNewDeviceEnrolledType: \(error)"
            }
        }
    }

    public class DropboxPasswordsNewDeviceEnrolledTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: DropboxPasswordsNewDeviceEnrolledType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> DropboxPasswordsNewDeviceEnrolledType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return DropboxPasswordsNewDeviceEnrolledType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: DropboxPasswordsNewDeviceEnrolledType.self, json: json)
            }
        }
    }

    /// Policy for deciding whether team users can use Dropbox Passwords
    public enum DropboxPasswordsPolicy: CustomStringConvertible, JSONRepresentable {
        /// An unspecified error.
        case default_
        /// An unspecified error.
        case disabled
        /// An unspecified error.
        case enabled
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try DropboxPasswordsPolicySerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try DropboxPasswordsPolicySerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for DropboxPasswordsPolicy: \(error)"
            }
        }
    }

    public class DropboxPasswordsPolicySerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: DropboxPasswordsPolicy) throws -> JSON {
            switch value {
            case .default_:
                var d = [String: JSON]()
                d[".tag"] = .str("default")
                return .dictionary(d)
            case .disabled:
                var d = [String: JSON]()
                d[".tag"] = .str("disabled")
                return .dictionary(d)
            case .enabled:
                var d = [String: JSON]()
                d[".tag"] = .str("enabled")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> DropboxPasswordsPolicy {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "default":
                    return DropboxPasswordsPolicy.default_
                case "disabled":
                    return DropboxPasswordsPolicy.disabled
                case "enabled":
                    return DropboxPasswordsPolicy.enabled
                case "other":
                    return DropboxPasswordsPolicy.other
                default:
                    return DropboxPasswordsPolicy.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: DropboxPasswordsPolicy.self, json: json)
            }
        }
    }

    /// Changed Dropbox Passwords policy for team.
    public class DropboxPasswordsPolicyChangedDetails: CustomStringConvertible, JSONRepresentable {
        /// To.
        public let newValue: TeamLog.DropboxPasswordsPolicy
        /// From.
        public let previousValue: TeamLog.DropboxPasswordsPolicy
        public init(newValue: TeamLog.DropboxPasswordsPolicy, previousValue: TeamLog.DropboxPasswordsPolicy) {
            self.newValue = newValue
            self.previousValue = previousValue
        }

        func json() throws -> JSON {
            try DropboxPasswordsPolicyChangedDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try DropboxPasswordsPolicyChangedDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for DropboxPasswordsPolicyChangedDetails: \(error)"
            }
        }
    }

    public class DropboxPasswordsPolicyChangedDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: DropboxPasswordsPolicyChangedDetails) throws -> JSON {
            let output = [
                "new_value": try TeamLog.DropboxPasswordsPolicySerializer().serialize(value.newValue),
                "previous_value": try TeamLog.DropboxPasswordsPolicySerializer().serialize(value.previousValue),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> DropboxPasswordsPolicyChangedDetails {
            switch json {
            case .dictionary(let dict):
                let newValue = try TeamLog.DropboxPasswordsPolicySerializer().deserialize(dict["new_value"] ?? .null)
                let previousValue = try TeamLog.DropboxPasswordsPolicySerializer().deserialize(dict["previous_value"] ?? .null)
                return DropboxPasswordsPolicyChangedDetails(newValue: newValue, previousValue: previousValue)
            default:
                throw JSONSerializerError.deserializeError(type: DropboxPasswordsPolicyChangedDetails.self, json: json)
            }
        }
    }

    /// The DropboxPasswordsPolicyChangedType struct
    public class DropboxPasswordsPolicyChangedType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try DropboxPasswordsPolicyChangedTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try DropboxPasswordsPolicyChangedTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for DropboxPasswordsPolicyChangedType: \(error)"
            }
        }
    }

    public class DropboxPasswordsPolicyChangedTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: DropboxPasswordsPolicyChangedType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> DropboxPasswordsPolicyChangedType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return DropboxPasswordsPolicyChangedType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: DropboxPasswordsPolicyChangedType.self, json: json)
            }
        }
    }

    /// Represents a time duration: unit and amount
    public class DurationLogInfo: CustomStringConvertible, JSONRepresentable {
        /// Time unit.
        public let unit: TeamLog.TimeUnit
        /// Amount of time.
        public let amount: UInt64
        public init(unit: TeamLog.TimeUnit, amount: UInt64) {
            self.unit = unit
            comparableValidator()(amount)
            self.amount = amount
        }

        func json() throws -> JSON {
            try DurationLogInfoSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try DurationLogInfoSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for DurationLogInfo: \(error)"
            }
        }
    }

    public class DurationLogInfoSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: DurationLogInfo) throws -> JSON {
            let output = [
                "unit": try TeamLog.TimeUnitSerializer().serialize(value.unit),
                "amount": try Serialization._UInt64Serializer.serialize(value.amount),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> DurationLogInfo {
            switch json {
            case .dictionary(let dict):
                let unit = try TeamLog.TimeUnitSerializer().deserialize(dict["unit"] ?? .null)
                let amount = try Serialization._UInt64Serializer.deserialize(dict["amount"] ?? .null)
                return DurationLogInfo(unit: unit, amount: amount)
            default:
                throw JSONSerializerError.deserializeError(type: DurationLogInfo.self, json: json)
            }
        }
    }

    /// Policy for deciding whether a team can use Email to Dropbox feature
    public enum EmailIngestPolicy: CustomStringConvertible, JSONRepresentable {
        /// An unspecified error.
        case disabled
        /// An unspecified error.
        case enabled
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try EmailIngestPolicySerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try EmailIngestPolicySerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for EmailIngestPolicy: \(error)"
            }
        }
    }

    public class EmailIngestPolicySerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: EmailIngestPolicy) throws -> JSON {
            switch value {
            case .disabled:
                var d = [String: JSON]()
                d[".tag"] = .str("disabled")
                return .dictionary(d)
            case .enabled:
                var d = [String: JSON]()
                d[".tag"] = .str("enabled")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> EmailIngestPolicy {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "disabled":
                    return EmailIngestPolicy.disabled
                case "enabled":
                    return EmailIngestPolicy.enabled
                case "other":
                    return EmailIngestPolicy.other
                default:
                    return EmailIngestPolicy.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: EmailIngestPolicy.self, json: json)
            }
        }
    }

    /// Changed email to Dropbox policy for team.
    public class EmailIngestPolicyChangedDetails: CustomStringConvertible, JSONRepresentable {
        /// To.
        public let newValue: TeamLog.EmailIngestPolicy
        /// From.
        public let previousValue: TeamLog.EmailIngestPolicy
        public init(newValue: TeamLog.EmailIngestPolicy, previousValue: TeamLog.EmailIngestPolicy) {
            self.newValue = newValue
            self.previousValue = previousValue
        }

        func json() throws -> JSON {
            try EmailIngestPolicyChangedDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try EmailIngestPolicyChangedDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for EmailIngestPolicyChangedDetails: \(error)"
            }
        }
    }

    public class EmailIngestPolicyChangedDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: EmailIngestPolicyChangedDetails) throws -> JSON {
            let output = [
                "new_value": try TeamLog.EmailIngestPolicySerializer().serialize(value.newValue),
                "previous_value": try TeamLog.EmailIngestPolicySerializer().serialize(value.previousValue),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> EmailIngestPolicyChangedDetails {
            switch json {
            case .dictionary(let dict):
                let newValue = try TeamLog.EmailIngestPolicySerializer().deserialize(dict["new_value"] ?? .null)
                let previousValue = try TeamLog.EmailIngestPolicySerializer().deserialize(dict["previous_value"] ?? .null)
                return EmailIngestPolicyChangedDetails(newValue: newValue, previousValue: previousValue)
            default:
                throw JSONSerializerError.deserializeError(type: EmailIngestPolicyChangedDetails.self, json: json)
            }
        }
    }

    /// The EmailIngestPolicyChangedType struct
    public class EmailIngestPolicyChangedType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try EmailIngestPolicyChangedTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try EmailIngestPolicyChangedTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for EmailIngestPolicyChangedType: \(error)"
            }
        }
    }

    public class EmailIngestPolicyChangedTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: EmailIngestPolicyChangedType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> EmailIngestPolicyChangedType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return EmailIngestPolicyChangedType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: EmailIngestPolicyChangedType.self, json: json)
            }
        }
    }

    /// Received files via Email to Dropbox.
    public class EmailIngestReceiveFileDetails: CustomStringConvertible, JSONRepresentable {
        /// Inbox name.
        public let inboxName: String
        /// Submitted file names.
        public let attachmentNames: [String]
        /// Subject of the email.
        public let subject: String?
        /// The name as provided by the submitter.
        public let fromName: String?
        /// The email as provided by the submitter.
        public let fromEmail: String?
        public init(inboxName: String, attachmentNames: [String], subject: String? = nil, fromName: String? = nil, fromEmail: String? = nil) {
            stringValidator()(inboxName)
            self.inboxName = inboxName
            arrayValidator(itemValidator: stringValidator())(attachmentNames)
            self.attachmentNames = attachmentNames
            nullableValidator(stringValidator())(subject)
            self.subject = subject
            nullableValidator(stringValidator())(fromName)
            self.fromName = fromName
            nullableValidator(stringValidator(maxLength: 255))(fromEmail)
            self.fromEmail = fromEmail
        }

        func json() throws -> JSON {
            try EmailIngestReceiveFileDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try EmailIngestReceiveFileDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for EmailIngestReceiveFileDetails: \(error)"
            }
        }
    }

    public class EmailIngestReceiveFileDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: EmailIngestReceiveFileDetails) throws -> JSON {
            let output = [
                "inbox_name": try Serialization._StringSerializer.serialize(value.inboxName),
                "attachment_names": try ArraySerializer(Serialization._StringSerializer).serialize(value.attachmentNames),
                "subject": try NullableSerializer(Serialization._StringSerializer).serialize(value.subject),
                "from_name": try NullableSerializer(Serialization._StringSerializer).serialize(value.fromName),
                "from_email": try NullableSerializer(Serialization._StringSerializer).serialize(value.fromEmail),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> EmailIngestReceiveFileDetails {
            switch json {
            case .dictionary(let dict):
                let inboxName = try Serialization._StringSerializer.deserialize(dict["inbox_name"] ?? .null)
                let attachmentNames = try ArraySerializer(Serialization._StringSerializer).deserialize(dict["attachment_names"] ?? .null)
                let subject = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["subject"] ?? .null)
                let fromName = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["from_name"] ?? .null)
                let fromEmail = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["from_email"] ?? .null)
                return EmailIngestReceiveFileDetails(
                    inboxName: inboxName,
                    attachmentNames: attachmentNames,
                    subject: subject,
                    fromName: fromName,
                    fromEmail: fromEmail
                )
            default:
                throw JSONSerializerError.deserializeError(type: EmailIngestReceiveFileDetails.self, json: json)
            }
        }
    }

    /// The EmailIngestReceiveFileType struct
    public class EmailIngestReceiveFileType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try EmailIngestReceiveFileTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try EmailIngestReceiveFileTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for EmailIngestReceiveFileType: \(error)"
            }
        }
    }

    public class EmailIngestReceiveFileTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: EmailIngestReceiveFileType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> EmailIngestReceiveFileType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return EmailIngestReceiveFileType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: EmailIngestReceiveFileType.self, json: json)
            }
        }
    }

    /// Added members to EMM exception list.
    public class EmmAddExceptionDetails: CustomStringConvertible, JSONRepresentable {
        func json() throws -> JSON {
            try EmmAddExceptionDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try EmmAddExceptionDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for EmmAddExceptionDetails: \(error)"
            }
        }
    }

    public class EmmAddExceptionDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: EmmAddExceptionDetails) throws -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> EmmAddExceptionDetails {
            switch json {
            case .dictionary:
                return EmmAddExceptionDetails()
            default:
                throw JSONSerializerError.deserializeError(type: EmmAddExceptionDetails.self, json: json)
            }
        }
    }

    /// The EmmAddExceptionType struct
    public class EmmAddExceptionType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try EmmAddExceptionTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try EmmAddExceptionTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for EmmAddExceptionType: \(error)"
            }
        }
    }

    public class EmmAddExceptionTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: EmmAddExceptionType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> EmmAddExceptionType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return EmmAddExceptionType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: EmmAddExceptionType.self, json: json)
            }
        }
    }

    /// Enabled/disabled enterprise mobility management for members.
    public class EmmChangePolicyDetails: CustomStringConvertible, JSONRepresentable {
        /// New enterprise mobility management policy.
        public let newValue: TeamPolicies.EmmState
        /// Previous enterprise mobility management policy. Might be missing due to historical data gap.
        public let previousValue: TeamPolicies.EmmState?
        public init(newValue: TeamPolicies.EmmState, previousValue: TeamPolicies.EmmState? = nil) {
            self.newValue = newValue
            self.previousValue = previousValue
        }

        func json() throws -> JSON {
            try EmmChangePolicyDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try EmmChangePolicyDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for EmmChangePolicyDetails: \(error)"
            }
        }
    }

    public class EmmChangePolicyDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: EmmChangePolicyDetails) throws -> JSON {
            let output = [
                "new_value": try TeamPolicies.EmmStateSerializer().serialize(value.newValue),
                "previous_value": try NullableSerializer(TeamPolicies.EmmStateSerializer()).serialize(value.previousValue),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> EmmChangePolicyDetails {
            switch json {
            case .dictionary(let dict):
                let newValue = try TeamPolicies.EmmStateSerializer().deserialize(dict["new_value"] ?? .null)
                let previousValue = try NullableSerializer(TeamPolicies.EmmStateSerializer()).deserialize(dict["previous_value"] ?? .null)
                return EmmChangePolicyDetails(newValue: newValue, previousValue: previousValue)
            default:
                throw JSONSerializerError.deserializeError(type: EmmChangePolicyDetails.self, json: json)
            }
        }
    }

    /// The EmmChangePolicyType struct
    public class EmmChangePolicyType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try EmmChangePolicyTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try EmmChangePolicyTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for EmmChangePolicyType: \(error)"
            }
        }
    }

    public class EmmChangePolicyTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: EmmChangePolicyType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> EmmChangePolicyType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return EmmChangePolicyType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: EmmChangePolicyType.self, json: json)
            }
        }
    }

    /// Created EMM-excluded users report.
    public class EmmCreateExceptionsReportDetails: CustomStringConvertible, JSONRepresentable {
        func json() throws -> JSON {
            try EmmCreateExceptionsReportDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try EmmCreateExceptionsReportDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for EmmCreateExceptionsReportDetails: \(error)"
            }
        }
    }

    public class EmmCreateExceptionsReportDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: EmmCreateExceptionsReportDetails) throws -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> EmmCreateExceptionsReportDetails {
            switch json {
            case .dictionary:
                return EmmCreateExceptionsReportDetails()
            default:
                throw JSONSerializerError.deserializeError(type: EmmCreateExceptionsReportDetails.self, json: json)
            }
        }
    }

    /// The EmmCreateExceptionsReportType struct
    public class EmmCreateExceptionsReportType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try EmmCreateExceptionsReportTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try EmmCreateExceptionsReportTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for EmmCreateExceptionsReportType: \(error)"
            }
        }
    }

    public class EmmCreateExceptionsReportTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: EmmCreateExceptionsReportType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> EmmCreateExceptionsReportType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return EmmCreateExceptionsReportType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: EmmCreateExceptionsReportType.self, json: json)
            }
        }
    }

    /// Created EMM mobile app usage report.
    public class EmmCreateUsageReportDetails: CustomStringConvertible, JSONRepresentable {
        func json() throws -> JSON {
            try EmmCreateUsageReportDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try EmmCreateUsageReportDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for EmmCreateUsageReportDetails: \(error)"
            }
        }
    }

    public class EmmCreateUsageReportDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: EmmCreateUsageReportDetails) throws -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> EmmCreateUsageReportDetails {
            switch json {
            case .dictionary:
                return EmmCreateUsageReportDetails()
            default:
                throw JSONSerializerError.deserializeError(type: EmmCreateUsageReportDetails.self, json: json)
            }
        }
    }

    /// The EmmCreateUsageReportType struct
    public class EmmCreateUsageReportType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try EmmCreateUsageReportTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try EmmCreateUsageReportTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for EmmCreateUsageReportType: \(error)"
            }
        }
    }

    public class EmmCreateUsageReportTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: EmmCreateUsageReportType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> EmmCreateUsageReportType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return EmmCreateUsageReportType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: EmmCreateUsageReportType.self, json: json)
            }
        }
    }

    /// Failed to sign in via EMM.
    public class EmmErrorDetails: CustomStringConvertible, JSONRepresentable {
        /// Error details.
        public let errorDetails: TeamLog.FailureDetailsLogInfo
        public init(errorDetails: TeamLog.FailureDetailsLogInfo) {
            self.errorDetails = errorDetails
        }

        func json() throws -> JSON {
            try EmmErrorDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try EmmErrorDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for EmmErrorDetails: \(error)"
            }
        }
    }

    public class EmmErrorDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: EmmErrorDetails) throws -> JSON {
            let output = [
                "error_details": try TeamLog.FailureDetailsLogInfoSerializer().serialize(value.errorDetails),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> EmmErrorDetails {
            switch json {
            case .dictionary(let dict):
                let errorDetails = try TeamLog.FailureDetailsLogInfoSerializer().deserialize(dict["error_details"] ?? .null)
                return EmmErrorDetails(errorDetails: errorDetails)
            default:
                throw JSONSerializerError.deserializeError(type: EmmErrorDetails.self, json: json)
            }
        }
    }

    /// The EmmErrorType struct
    public class EmmErrorType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try EmmErrorTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try EmmErrorTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for EmmErrorType: \(error)"
            }
        }
    }

    public class EmmErrorTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: EmmErrorType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> EmmErrorType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return EmmErrorType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: EmmErrorType.self, json: json)
            }
        }
    }

    /// Refreshed auth token used for setting up EMM.
    public class EmmRefreshAuthTokenDetails: CustomStringConvertible, JSONRepresentable {
        func json() throws -> JSON {
            try EmmRefreshAuthTokenDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try EmmRefreshAuthTokenDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for EmmRefreshAuthTokenDetails: \(error)"
            }
        }
    }

    public class EmmRefreshAuthTokenDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: EmmRefreshAuthTokenDetails) throws -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> EmmRefreshAuthTokenDetails {
            switch json {
            case .dictionary:
                return EmmRefreshAuthTokenDetails()
            default:
                throw JSONSerializerError.deserializeError(type: EmmRefreshAuthTokenDetails.self, json: json)
            }
        }
    }

    /// The EmmRefreshAuthTokenType struct
    public class EmmRefreshAuthTokenType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try EmmRefreshAuthTokenTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try EmmRefreshAuthTokenTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for EmmRefreshAuthTokenType: \(error)"
            }
        }
    }

    public class EmmRefreshAuthTokenTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: EmmRefreshAuthTokenType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> EmmRefreshAuthTokenType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return EmmRefreshAuthTokenType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: EmmRefreshAuthTokenType.self, json: json)
            }
        }
    }

    /// Removed members from EMM exception list.
    public class EmmRemoveExceptionDetails: CustomStringConvertible, JSONRepresentable {
        func json() throws -> JSON {
            try EmmRemoveExceptionDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try EmmRemoveExceptionDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for EmmRemoveExceptionDetails: \(error)"
            }
        }
    }

    public class EmmRemoveExceptionDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: EmmRemoveExceptionDetails) throws -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> EmmRemoveExceptionDetails {
            switch json {
            case .dictionary:
                return EmmRemoveExceptionDetails()
            default:
                throw JSONSerializerError.deserializeError(type: EmmRemoveExceptionDetails.self, json: json)
            }
        }
    }

    /// The EmmRemoveExceptionType struct
    public class EmmRemoveExceptionType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try EmmRemoveExceptionTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try EmmRemoveExceptionTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for EmmRemoveExceptionType: \(error)"
            }
        }
    }

    public class EmmRemoveExceptionTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: EmmRemoveExceptionType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> EmmRemoveExceptionType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return EmmRemoveExceptionType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: EmmRemoveExceptionType.self, json: json)
            }
        }
    }

    /// Enabled domain invites.
    public class EnabledDomainInvitesDetails: CustomStringConvertible, JSONRepresentable {
        func json() throws -> JSON {
            try EnabledDomainInvitesDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try EnabledDomainInvitesDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for EnabledDomainInvitesDetails: \(error)"
            }
        }
    }

    public class EnabledDomainInvitesDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: EnabledDomainInvitesDetails) throws -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> EnabledDomainInvitesDetails {
            switch json {
            case .dictionary:
                return EnabledDomainInvitesDetails()
            default:
                throw JSONSerializerError.deserializeError(type: EnabledDomainInvitesDetails.self, json: json)
            }
        }
    }

    /// The EnabledDomainInvitesType struct
    public class EnabledDomainInvitesType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try EnabledDomainInvitesTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try EnabledDomainInvitesTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for EnabledDomainInvitesType: \(error)"
            }
        }
    }

    public class EnabledDomainInvitesTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: EnabledDomainInvitesType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> EnabledDomainInvitesType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return EnabledDomainInvitesType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: EnabledDomainInvitesType.self, json: json)
            }
        }
    }

    /// Ended enterprise admin session.
    public class EndedEnterpriseAdminSessionDeprecatedDetails: CustomStringConvertible, JSONRepresentable {
        /// More information about the organization or team.
        public let federationExtraDetails: TeamLog.FedExtraDetails
        public init(federationExtraDetails: TeamLog.FedExtraDetails) {
            self.federationExtraDetails = federationExtraDetails
        }

        func json() throws -> JSON {
            try EndedEnterpriseAdminSessionDeprecatedDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try EndedEnterpriseAdminSessionDeprecatedDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for EndedEnterpriseAdminSessionDeprecatedDetails: \(error)"
            }
        }
    }

    public class EndedEnterpriseAdminSessionDeprecatedDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: EndedEnterpriseAdminSessionDeprecatedDetails) throws -> JSON {
            let output = [
                "federation_extra_details": try TeamLog.FedExtraDetailsSerializer().serialize(value.federationExtraDetails),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> EndedEnterpriseAdminSessionDeprecatedDetails {
            switch json {
            case .dictionary(let dict):
                let federationExtraDetails = try TeamLog.FedExtraDetailsSerializer().deserialize(dict["federation_extra_details"] ?? .null)
                return EndedEnterpriseAdminSessionDeprecatedDetails(federationExtraDetails: federationExtraDetails)
            default:
                throw JSONSerializerError.deserializeError(type: EndedEnterpriseAdminSessionDeprecatedDetails.self, json: json)
            }
        }
    }

    /// The EndedEnterpriseAdminSessionDeprecatedType struct
    public class EndedEnterpriseAdminSessionDeprecatedType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try EndedEnterpriseAdminSessionDeprecatedTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try EndedEnterpriseAdminSessionDeprecatedTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for EndedEnterpriseAdminSessionDeprecatedType: \(error)"
            }
        }
    }

    public class EndedEnterpriseAdminSessionDeprecatedTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: EndedEnterpriseAdminSessionDeprecatedType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> EndedEnterpriseAdminSessionDeprecatedType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return EndedEnterpriseAdminSessionDeprecatedType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: EndedEnterpriseAdminSessionDeprecatedType.self, json: json)
            }
        }
    }

    /// Ended enterprise admin session.
    public class EndedEnterpriseAdminSessionDetails: CustomStringConvertible, JSONRepresentable {
        func json() throws -> JSON {
            try EndedEnterpriseAdminSessionDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try EndedEnterpriseAdminSessionDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for EndedEnterpriseAdminSessionDetails: \(error)"
            }
        }
    }

    public class EndedEnterpriseAdminSessionDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: EndedEnterpriseAdminSessionDetails) throws -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> EndedEnterpriseAdminSessionDetails {
            switch json {
            case .dictionary:
                return EndedEnterpriseAdminSessionDetails()
            default:
                throw JSONSerializerError.deserializeError(type: EndedEnterpriseAdminSessionDetails.self, json: json)
            }
        }
    }

    /// The EndedEnterpriseAdminSessionType struct
    public class EndedEnterpriseAdminSessionType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try EndedEnterpriseAdminSessionTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try EndedEnterpriseAdminSessionTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for EndedEnterpriseAdminSessionType: \(error)"
            }
        }
    }

    public class EndedEnterpriseAdminSessionTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: EndedEnterpriseAdminSessionType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> EndedEnterpriseAdminSessionType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return EndedEnterpriseAdminSessionType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: EndedEnterpriseAdminSessionType.self, json: json)
            }
        }
    }

    /// Policy for deciding whether password must be enforced when an externally shared link is updated
    public enum EnforceLinkPasswordPolicy: CustomStringConvertible, JSONRepresentable {
        /// An unspecified error.
        case optional
        /// An unspecified error.
        case required
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try EnforceLinkPasswordPolicySerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try EnforceLinkPasswordPolicySerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for EnforceLinkPasswordPolicy: \(error)"
            }
        }
    }

    public class EnforceLinkPasswordPolicySerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: EnforceLinkPasswordPolicy) throws -> JSON {
            switch value {
            case .optional:
                var d = [String: JSON]()
                d[".tag"] = .str("optional")
                return .dictionary(d)
            case .required:
                var d = [String: JSON]()
                d[".tag"] = .str("required")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> EnforceLinkPasswordPolicy {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "optional":
                    return EnforceLinkPasswordPolicy.optional
                case "required":
                    return EnforceLinkPasswordPolicy.required
                case "other":
                    return EnforceLinkPasswordPolicy.other
                default:
                    return EnforceLinkPasswordPolicy.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: EnforceLinkPasswordPolicy.self, json: json)
            }
        }
    }

    /// Changed who can update a setting.
    public class EnterpriseSettingsLockingDetails: CustomStringConvertible, JSONRepresentable {
        /// The secondary team name.
        public let teamName: String
        /// Settings page name.
        public let settingsPageName: String
        /// Previous locked settings page state.
        public let previousSettingsPageLockingState: String
        /// New locked settings page state.
        public let newSettingsPageLockingState: String
        public init(teamName: String, settingsPageName: String, previousSettingsPageLockingState: String, newSettingsPageLockingState: String) {
            stringValidator()(teamName)
            self.teamName = teamName
            stringValidator()(settingsPageName)
            self.settingsPageName = settingsPageName
            stringValidator()(previousSettingsPageLockingState)
            self.previousSettingsPageLockingState = previousSettingsPageLockingState
            stringValidator()(newSettingsPageLockingState)
            self.newSettingsPageLockingState = newSettingsPageLockingState
        }

        func json() throws -> JSON {
            try EnterpriseSettingsLockingDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try EnterpriseSettingsLockingDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for EnterpriseSettingsLockingDetails: \(error)"
            }
        }
    }

    public class EnterpriseSettingsLockingDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: EnterpriseSettingsLockingDetails) throws -> JSON {
            let output = [
                "team_name": try Serialization._StringSerializer.serialize(value.teamName),
                "settings_page_name": try Serialization._StringSerializer.serialize(value.settingsPageName),
                "previous_settings_page_locking_state": try Serialization._StringSerializer.serialize(value.previousSettingsPageLockingState),
                "new_settings_page_locking_state": try Serialization._StringSerializer.serialize(value.newSettingsPageLockingState),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> EnterpriseSettingsLockingDetails {
            switch json {
            case .dictionary(let dict):
                let teamName = try Serialization._StringSerializer.deserialize(dict["team_name"] ?? .null)
                let settingsPageName = try Serialization._StringSerializer.deserialize(dict["settings_page_name"] ?? .null)
                let previousSettingsPageLockingState = try Serialization._StringSerializer
                    .deserialize(dict["previous_settings_page_locking_state"] ?? .null)
                let newSettingsPageLockingState = try Serialization._StringSerializer.deserialize(dict["new_settings_page_locking_state"] ?? .null)
                return EnterpriseSettingsLockingDetails(
                    teamName: teamName,
                    settingsPageName: settingsPageName,
                    previousSettingsPageLockingState: previousSettingsPageLockingState,
                    newSettingsPageLockingState: newSettingsPageLockingState
                )
            default:
                throw JSONSerializerError.deserializeError(type: EnterpriseSettingsLockingDetails.self, json: json)
            }
        }
    }

    /// The EnterpriseSettingsLockingType struct
    public class EnterpriseSettingsLockingType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try EnterpriseSettingsLockingTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try EnterpriseSettingsLockingTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for EnterpriseSettingsLockingType: \(error)"
            }
        }
    }

    public class EnterpriseSettingsLockingTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: EnterpriseSettingsLockingType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> EnterpriseSettingsLockingType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return EnterpriseSettingsLockingType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: EnterpriseSettingsLockingType.self, json: json)
            }
        }
    }

    /// Category of events in event audit log.
    public enum EventCategory: CustomStringConvertible, JSONRepresentable {
        /// Events that involve team related alerts.
        case adminAlerting
        /// Events that apply to management of linked apps.
        case apps
        /// Events that have to do with comments on files and Paper documents.
        case comments
        /// Events that involve data governance actions
        case dataGovernance
        /// Events that apply to linked devices on mobile, desktop and Web platforms.
        case devices
        /// Events that involve domain management feature: domain verification, invite enforcement and account capture.
        case domains
        /// Events that involve encryption.
        case encryption
        /// Events that have to do with filesystem operations on files and folders: copy, move, delete, etc.
        case fileOperations
        /// Events that apply to the file requests feature.
        case fileRequests
        /// Events that involve group management.
        case groups
        /// Events that involve users signing in to or out of Dropbox.
        case logins
        /// Events that involve team member management.
        case members
        /// Events that apply to Dropbox Paper.
        case paper
        /// Events that involve using, changing or resetting passwords.
        case passwords
        /// Events that concern generation of admin reports, including team activity and device usage.
        case reports
        /// Events that apply to all types of sharing and collaboration.
        case sharing
        /// Events that apply to Dropbox Showcase.
        case showcase
        /// Events that involve using or configuring single sign-on as well as administrative policies concerning single
        /// sign-on.
        case sso
        /// Events that involve team folder management.
        case teamFolders
        /// Events that involve a change in team-wide policies.
        case teamPolicies
        /// Events that involve a change in the team profile.
        case teamProfile
        /// Events that involve using or configuring two factor authentication as well as administrative policies
        /// concerning two factor authentication.
        case tfa
        /// Events that apply to cross-team trust establishment.
        case trustedTeams
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try EventCategorySerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try EventCategorySerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for EventCategory: \(error)"
            }
        }
    }

    public class EventCategorySerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: EventCategory) throws -> JSON {
            switch value {
            case .adminAlerting:
                var d = [String: JSON]()
                d[".tag"] = .str("admin_alerting")
                return .dictionary(d)
            case .apps:
                var d = [String: JSON]()
                d[".tag"] = .str("apps")
                return .dictionary(d)
            case .comments:
                var d = [String: JSON]()
                d[".tag"] = .str("comments")
                return .dictionary(d)
            case .dataGovernance:
                var d = [String: JSON]()
                d[".tag"] = .str("data_governance")
                return .dictionary(d)
            case .devices:
                var d = [String: JSON]()
                d[".tag"] = .str("devices")
                return .dictionary(d)
            case .domains:
                var d = [String: JSON]()
                d[".tag"] = .str("domains")
                return .dictionary(d)
            case .encryption:
                var d = [String: JSON]()
                d[".tag"] = .str("encryption")
                return .dictionary(d)
            case .fileOperations:
                var d = [String: JSON]()
                d[".tag"] = .str("file_operations")
                return .dictionary(d)
            case .fileRequests:
                var d = [String: JSON]()
                d[".tag"] = .str("file_requests")
                return .dictionary(d)
            case .groups:
                var d = [String: JSON]()
                d[".tag"] = .str("groups")
                return .dictionary(d)
            case .logins:
                var d = [String: JSON]()
                d[".tag"] = .str("logins")
                return .dictionary(d)
            case .members:
                var d = [String: JSON]()
                d[".tag"] = .str("members")
                return .dictionary(d)
            case .paper:
                var d = [String: JSON]()
                d[".tag"] = .str("paper")
                return .dictionary(d)
            case .passwords:
                var d = [String: JSON]()
                d[".tag"] = .str("passwords")
                return .dictionary(d)
            case .reports:
                var d = [String: JSON]()
                d[".tag"] = .str("reports")
                return .dictionary(d)
            case .sharing:
                var d = [String: JSON]()
                d[".tag"] = .str("sharing")
                return .dictionary(d)
            case .showcase:
                var d = [String: JSON]()
                d[".tag"] = .str("showcase")
                return .dictionary(d)
            case .sso:
                var d = [String: JSON]()
                d[".tag"] = .str("sso")
                return .dictionary(d)
            case .teamFolders:
                var d = [String: JSON]()
                d[".tag"] = .str("team_folders")
                return .dictionary(d)
            case .teamPolicies:
                var d = [String: JSON]()
                d[".tag"] = .str("team_policies")
                return .dictionary(d)
            case .teamProfile:
                var d = [String: JSON]()
                d[".tag"] = .str("team_profile")
                return .dictionary(d)
            case .tfa:
                var d = [String: JSON]()
                d[".tag"] = .str("tfa")
                return .dictionary(d)
            case .trustedTeams:
                var d = [String: JSON]()
                d[".tag"] = .str("trusted_teams")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> EventCategory {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "admin_alerting":
                    return EventCategory.adminAlerting
                case "apps":
                    return EventCategory.apps
                case "comments":
                    return EventCategory.comments
                case "data_governance":
                    return EventCategory.dataGovernance
                case "devices":
                    return EventCategory.devices
                case "domains":
                    return EventCategory.domains
                case "encryption":
                    return EventCategory.encryption
                case "file_operations":
                    return EventCategory.fileOperations
                case "file_requests":
                    return EventCategory.fileRequests
                case "groups":
                    return EventCategory.groups
                case "logins":
                    return EventCategory.logins
                case "members":
                    return EventCategory.members
                case "paper":
                    return EventCategory.paper
                case "passwords":
                    return EventCategory.passwords
                case "reports":
                    return EventCategory.reports
                case "sharing":
                    return EventCategory.sharing
                case "showcase":
                    return EventCategory.showcase
                case "sso":
                    return EventCategory.sso
                case "team_folders":
                    return EventCategory.teamFolders
                case "team_policies":
                    return EventCategory.teamPolicies
                case "team_profile":
                    return EventCategory.teamProfile
                case "tfa":
                    return EventCategory.tfa
                case "trusted_teams":
                    return EventCategory.trustedTeams
                case "other":
                    return EventCategory.other
                default:
                    return EventCategory.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: EventCategory.self, json: json)
            }
        }
    }

    /// Additional fields depending on the event type.
    public enum EventDetails: CustomStringConvertible, JSONRepresentable {
        /// An unspecified error.
        case adminAlertingAlertStateChangedDetails(TeamLog.AdminAlertingAlertStateChangedDetails)
        /// An unspecified error.
        case adminAlertingChangedAlertConfigDetails(TeamLog.AdminAlertingChangedAlertConfigDetails)
        /// An unspecified error.
        case adminAlertingTriggeredAlertDetails(TeamLog.AdminAlertingTriggeredAlertDetails)
        /// An unspecified error.
        case ransomwareRestoreProcessCompletedDetails(TeamLog.RansomwareRestoreProcessCompletedDetails)
        /// An unspecified error.
        case ransomwareRestoreProcessStartedDetails(TeamLog.RansomwareRestoreProcessStartedDetails)
        /// An unspecified error.
        case appBlockedByPermissionsDetails(TeamLog.AppBlockedByPermissionsDetails)
        /// An unspecified error.
        case appLinkTeamDetails(TeamLog.AppLinkTeamDetails)
        /// An unspecified error.
        case appLinkUserDetails(TeamLog.AppLinkUserDetails)
        /// An unspecified error.
        case appUnlinkTeamDetails(TeamLog.AppUnlinkTeamDetails)
        /// An unspecified error.
        case appUnlinkUserDetails(TeamLog.AppUnlinkUserDetails)
        /// An unspecified error.
        case integrationConnectedDetails(TeamLog.IntegrationConnectedDetails)
        /// An unspecified error.
        case integrationDisconnectedDetails(TeamLog.IntegrationDisconnectedDetails)
        /// An unspecified error.
        case fileAddCommentDetails(TeamLog.FileAddCommentDetails)
        /// An unspecified error.
        case fileChangeCommentSubscriptionDetails(TeamLog.FileChangeCommentSubscriptionDetails)
        /// An unspecified error.
        case fileDeleteCommentDetails(TeamLog.FileDeleteCommentDetails)
        /// An unspecified error.
        case fileEditCommentDetails(TeamLog.FileEditCommentDetails)
        /// An unspecified error.
        case fileLikeCommentDetails(TeamLog.FileLikeCommentDetails)
        /// An unspecified error.
        case fileResolveCommentDetails(TeamLog.FileResolveCommentDetails)
        /// An unspecified error.
        case fileUnlikeCommentDetails(TeamLog.FileUnlikeCommentDetails)
        /// An unspecified error.
        case fileUnresolveCommentDetails(TeamLog.FileUnresolveCommentDetails)
        /// An unspecified error.
        case governancePolicyAddFoldersDetails(TeamLog.GovernancePolicyAddFoldersDetails)
        /// An unspecified error.
        case governancePolicyAddFolderFailedDetails(TeamLog.GovernancePolicyAddFolderFailedDetails)
        /// An unspecified error.
        case governancePolicyContentDisposedDetails(TeamLog.GovernancePolicyContentDisposedDetails)
        /// An unspecified error.
        case governancePolicyCreateDetails(TeamLog.GovernancePolicyCreateDetails)
        /// An unspecified error.
        case governancePolicyDeleteDetails(TeamLog.GovernancePolicyDeleteDetails)
        /// An unspecified error.
        case governancePolicyEditDetailsDetails(TeamLog.GovernancePolicyEditDetailsDetails)
        /// An unspecified error.
        case governancePolicyEditDurationDetails(TeamLog.GovernancePolicyEditDurationDetails)
        /// An unspecified error.
        case governancePolicyExportCreatedDetails(TeamLog.GovernancePolicyExportCreatedDetails)
        /// An unspecified error.
        case governancePolicyExportRemovedDetails(TeamLog.GovernancePolicyExportRemovedDetails)
        /// An unspecified error.
        case governancePolicyRemoveFoldersDetails(TeamLog.GovernancePolicyRemoveFoldersDetails)
        /// An unspecified error.
        case governancePolicyReportCreatedDetails(TeamLog.GovernancePolicyReportCreatedDetails)
        /// An unspecified error.
        case governancePolicyZipPartDownloadedDetails(TeamLog.GovernancePolicyZipPartDownloadedDetails)
        /// An unspecified error.
        case legalHoldsActivateAHoldDetails(TeamLog.LegalHoldsActivateAHoldDetails)
        /// An unspecified error.
        case legalHoldsAddMembersDetails(TeamLog.LegalHoldsAddMembersDetails)
        /// An unspecified error.
        case legalHoldsChangeHoldDetailsDetails(TeamLog.LegalHoldsChangeHoldDetailsDetails)
        /// An unspecified error.
        case legalHoldsChangeHoldNameDetails(TeamLog.LegalHoldsChangeHoldNameDetails)
        /// An unspecified error.
        case legalHoldsExportAHoldDetails(TeamLog.LegalHoldsExportAHoldDetails)
        /// An unspecified error.
        case legalHoldsExportCancelledDetails(TeamLog.LegalHoldsExportCancelledDetails)
        /// An unspecified error.
        case legalHoldsExportDownloadedDetails(TeamLog.LegalHoldsExportDownloadedDetails)
        /// An unspecified error.
        case legalHoldsExportRemovedDetails(TeamLog.LegalHoldsExportRemovedDetails)
        /// An unspecified error.
        case legalHoldsReleaseAHoldDetails(TeamLog.LegalHoldsReleaseAHoldDetails)
        /// An unspecified error.
        case legalHoldsRemoveMembersDetails(TeamLog.LegalHoldsRemoveMembersDetails)
        /// An unspecified error.
        case legalHoldsReportAHoldDetails(TeamLog.LegalHoldsReportAHoldDetails)
        /// An unspecified error.
        case deviceChangeIpDesktopDetails(TeamLog.DeviceChangeIpDesktopDetails)
        /// An unspecified error.
        case deviceChangeIpMobileDetails(TeamLog.DeviceChangeIpMobileDetails)
        /// An unspecified error.
        case deviceChangeIpWebDetails(TeamLog.DeviceChangeIpWebDetails)
        /// An unspecified error.
        case deviceDeleteOnUnlinkFailDetails(TeamLog.DeviceDeleteOnUnlinkFailDetails)
        /// An unspecified error.
        case deviceDeleteOnUnlinkSuccessDetails(TeamLog.DeviceDeleteOnUnlinkSuccessDetails)
        /// An unspecified error.
        case deviceLinkFailDetails(TeamLog.DeviceLinkFailDetails)
        /// An unspecified error.
        case deviceLinkSuccessDetails(TeamLog.DeviceLinkSuccessDetails)
        /// An unspecified error.
        case deviceManagementDisabledDetails(TeamLog.DeviceManagementDisabledDetails)
        /// An unspecified error.
        case deviceManagementEnabledDetails(TeamLog.DeviceManagementEnabledDetails)
        /// An unspecified error.
        case deviceSyncBackupStatusChangedDetails(TeamLog.DeviceSyncBackupStatusChangedDetails)
        /// An unspecified error.
        case deviceUnlinkDetails(TeamLog.DeviceUnlinkDetails)
        /// An unspecified error.
        case dropboxPasswordsExportedDetails(TeamLog.DropboxPasswordsExportedDetails)
        /// An unspecified error.
        case dropboxPasswordsNewDeviceEnrolledDetails(TeamLog.DropboxPasswordsNewDeviceEnrolledDetails)
        /// An unspecified error.
        case emmRefreshAuthTokenDetails(TeamLog.EmmRefreshAuthTokenDetails)
        /// An unspecified error.
        case externalDriveBackupEligibilityStatusCheckedDetails(TeamLog.ExternalDriveBackupEligibilityStatusCheckedDetails)
        /// An unspecified error.
        case externalDriveBackupStatusChangedDetails(TeamLog.ExternalDriveBackupStatusChangedDetails)
        /// An unspecified error.
        case accountCaptureChangeAvailabilityDetails(TeamLog.AccountCaptureChangeAvailabilityDetails)
        /// An unspecified error.
        case accountCaptureMigrateAccountDetails(TeamLog.AccountCaptureMigrateAccountDetails)
        /// An unspecified error.
        case accountCaptureNotificationEmailsSentDetails(TeamLog.AccountCaptureNotificationEmailsSentDetails)
        /// An unspecified error.
        case accountCaptureRelinquishAccountDetails(TeamLog.AccountCaptureRelinquishAccountDetails)
        /// An unspecified error.
        case disabledDomainInvitesDetails(TeamLog.DisabledDomainInvitesDetails)
        /// An unspecified error.
        case domainInvitesApproveRequestToJoinTeamDetails(TeamLog.DomainInvitesApproveRequestToJoinTeamDetails)
        /// An unspecified error.
        case domainInvitesDeclineRequestToJoinTeamDetails(TeamLog.DomainInvitesDeclineRequestToJoinTeamDetails)
        /// An unspecified error.
        case domainInvitesEmailExistingUsersDetails(TeamLog.DomainInvitesEmailExistingUsersDetails)
        /// An unspecified error.
        case domainInvitesRequestToJoinTeamDetails(TeamLog.DomainInvitesRequestToJoinTeamDetails)
        /// An unspecified error.
        case domainInvitesSetInviteNewUserPrefToNoDetails(TeamLog.DomainInvitesSetInviteNewUserPrefToNoDetails)
        /// An unspecified error.
        case domainInvitesSetInviteNewUserPrefToYesDetails(TeamLog.DomainInvitesSetInviteNewUserPrefToYesDetails)
        /// An unspecified error.
        case domainVerificationAddDomainFailDetails(TeamLog.DomainVerificationAddDomainFailDetails)
        /// An unspecified error.
        case domainVerificationAddDomainSuccessDetails(TeamLog.DomainVerificationAddDomainSuccessDetails)
        /// An unspecified error.
        case domainVerificationRemoveDomainDetails(TeamLog.DomainVerificationRemoveDomainDetails)
        /// An unspecified error.
        case enabledDomainInvitesDetails(TeamLog.EnabledDomainInvitesDetails)
        /// An unspecified error.
        case teamEncryptionKeyCancelKeyDeletionDetails(TeamLog.TeamEncryptionKeyCancelKeyDeletionDetails)
        /// An unspecified error.
        case teamEncryptionKeyCreateKeyDetails(TeamLog.TeamEncryptionKeyCreateKeyDetails)
        /// An unspecified error.
        case teamEncryptionKeyDeleteKeyDetails(TeamLog.TeamEncryptionKeyDeleteKeyDetails)
        /// An unspecified error.
        case teamEncryptionKeyDisableKeyDetails(TeamLog.TeamEncryptionKeyDisableKeyDetails)
        /// An unspecified error.
        case teamEncryptionKeyEnableKeyDetails(TeamLog.TeamEncryptionKeyEnableKeyDetails)
        /// An unspecified error.
        case teamEncryptionKeyRotateKeyDetails(TeamLog.TeamEncryptionKeyRotateKeyDetails)
        /// An unspecified error.
        case teamEncryptionKeyScheduleKeyDeletionDetails(TeamLog.TeamEncryptionKeyScheduleKeyDeletionDetails)
        /// An unspecified error.
        case applyNamingConventionDetails(TeamLog.ApplyNamingConventionDetails)
        /// An unspecified error.
        case createFolderDetails(TeamLog.CreateFolderDetails)
        /// An unspecified error.
        case fileAddDetails(TeamLog.FileAddDetails)
        /// An unspecified error.
        case fileAddFromAutomationDetails(TeamLog.FileAddFromAutomationDetails)
        /// An unspecified error.
        case fileCopyDetails(TeamLog.FileCopyDetails)
        /// An unspecified error.
        case fileDeleteDetails(TeamLog.FileDeleteDetails)
        /// An unspecified error.
        case fileDownloadDetails(TeamLog.FileDownloadDetails)
        /// An unspecified error.
        case fileEditDetails(TeamLog.FileEditDetails)
        /// An unspecified error.
        case fileGetCopyReferenceDetails(TeamLog.FileGetCopyReferenceDetails)
        /// An unspecified error.
        case fileLockingLockStatusChangedDetails(TeamLog.FileLockingLockStatusChangedDetails)
        /// An unspecified error.
        case fileMoveDetails(TeamLog.FileMoveDetails)
        /// An unspecified error.
        case filePermanentlyDeleteDetails(TeamLog.FilePermanentlyDeleteDetails)
        /// An unspecified error.
        case filePreviewDetails(TeamLog.FilePreviewDetails)
        /// An unspecified error.
        case fileRenameDetails(TeamLog.FileRenameDetails)
        /// An unspecified error.
        case fileRestoreDetails(TeamLog.FileRestoreDetails)
        /// An unspecified error.
        case fileRevertDetails(TeamLog.FileRevertDetails)
        /// An unspecified error.
        case fileRollbackChangesDetails(TeamLog.FileRollbackChangesDetails)
        /// An unspecified error.
        case fileSaveCopyReferenceDetails(TeamLog.FileSaveCopyReferenceDetails)
        /// An unspecified error.
        case folderOverviewDescriptionChangedDetails(TeamLog.FolderOverviewDescriptionChangedDetails)
        /// An unspecified error.
        case folderOverviewItemPinnedDetails(TeamLog.FolderOverviewItemPinnedDetails)
        /// An unspecified error.
        case folderOverviewItemUnpinnedDetails(TeamLog.FolderOverviewItemUnpinnedDetails)
        /// An unspecified error.
        case objectLabelAddedDetails(TeamLog.ObjectLabelAddedDetails)
        /// An unspecified error.
        case objectLabelRemovedDetails(TeamLog.ObjectLabelRemovedDetails)
        /// An unspecified error.
        case objectLabelUpdatedValueDetails(TeamLog.ObjectLabelUpdatedValueDetails)
        /// An unspecified error.
        case organizeFolderWithTidyDetails(TeamLog.OrganizeFolderWithTidyDetails)
        /// An unspecified error.
        case replayFileDeleteDetails(TeamLog.ReplayFileDeleteDetails)
        /// An unspecified error.
        case rewindFolderDetails(TeamLog.RewindFolderDetails)
        /// An unspecified error.
        case undoNamingConventionDetails(TeamLog.UndoNamingConventionDetails)
        /// An unspecified error.
        case undoOrganizeFolderWithTidyDetails(TeamLog.UndoOrganizeFolderWithTidyDetails)
        /// An unspecified error.
        case userTagsAddedDetails(TeamLog.UserTagsAddedDetails)
        /// An unspecified error.
        case userTagsRemovedDetails(TeamLog.UserTagsRemovedDetails)
        /// An unspecified error.
        case emailIngestReceiveFileDetails(TeamLog.EmailIngestReceiveFileDetails)
        /// An unspecified error.
        case fileRequestChangeDetails(TeamLog.FileRequestChangeDetails)
        /// An unspecified error.
        case fileRequestCloseDetails(TeamLog.FileRequestCloseDetails)
        /// An unspecified error.
        case fileRequestCreateDetails(TeamLog.FileRequestCreateDetails)
        /// An unspecified error.
        case fileRequestDeleteDetails(TeamLog.FileRequestDeleteDetails)
        /// An unspecified error.
        case fileRequestReceiveFileDetails(TeamLog.FileRequestReceiveFileDetails)
        /// An unspecified error.
        case groupAddExternalIdDetails(TeamLog.GroupAddExternalIdDetails)
        /// An unspecified error.
        case groupAddMemberDetails(TeamLog.GroupAddMemberDetails)
        /// An unspecified error.
        case groupChangeExternalIdDetails(TeamLog.GroupChangeExternalIdDetails)
        /// An unspecified error.
        case groupChangeManagementTypeDetails(TeamLog.GroupChangeManagementTypeDetails)
        /// An unspecified error.
        case groupChangeMemberRoleDetails(TeamLog.GroupChangeMemberRoleDetails)
        /// An unspecified error.
        case groupCreateDetails(TeamLog.GroupCreateDetails)
        /// An unspecified error.
        case groupDeleteDetails(TeamLog.GroupDeleteDetails)
        /// An unspecified error.
        case groupDescriptionUpdatedDetails(TeamLog.GroupDescriptionUpdatedDetails)
        /// An unspecified error.
        case groupJoinPolicyUpdatedDetails(TeamLog.GroupJoinPolicyUpdatedDetails)
        /// An unspecified error.
        case groupMovedDetails(TeamLog.GroupMovedDetails)
        /// An unspecified error.
        case groupRemoveExternalIdDetails(TeamLog.GroupRemoveExternalIdDetails)
        /// An unspecified error.
        case groupRemoveMemberDetails(TeamLog.GroupRemoveMemberDetails)
        /// An unspecified error.
        case groupRenameDetails(TeamLog.GroupRenameDetails)
        /// An unspecified error.
        case accountLockOrUnlockedDetails(TeamLog.AccountLockOrUnlockedDetails)
        /// An unspecified error.
        case emmErrorDetails(TeamLog.EmmErrorDetails)
        /// An unspecified error.
        case guestAdminSignedInViaTrustedTeamsDetails(TeamLog.GuestAdminSignedInViaTrustedTeamsDetails)
        /// An unspecified error.
        case guestAdminSignedOutViaTrustedTeamsDetails(TeamLog.GuestAdminSignedOutViaTrustedTeamsDetails)
        /// An unspecified error.
        case loginFailDetails(TeamLog.LoginFailDetails)
        /// An unspecified error.
        case loginSuccessDetails(TeamLog.LoginSuccessDetails)
        /// An unspecified error.
        case logoutDetails(TeamLog.LogoutDetails)
        /// An unspecified error.
        case resellerSupportSessionEndDetails(TeamLog.ResellerSupportSessionEndDetails)
        /// An unspecified error.
        case resellerSupportSessionStartDetails(TeamLog.ResellerSupportSessionStartDetails)
        /// An unspecified error.
        case signInAsSessionEndDetails(TeamLog.SignInAsSessionEndDetails)
        /// An unspecified error.
        case signInAsSessionStartDetails(TeamLog.SignInAsSessionStartDetails)
        /// An unspecified error.
        case ssoErrorDetails(TeamLog.SsoErrorDetails)
        /// An unspecified error.
        case backupAdminInvitationSentDetails(TeamLog.BackupAdminInvitationSentDetails)
        /// An unspecified error.
        case backupInvitationOpenedDetails(TeamLog.BackupInvitationOpenedDetails)
        /// An unspecified error.
        case createTeamInviteLinkDetails(TeamLog.CreateTeamInviteLinkDetails)
        /// An unspecified error.
        case deleteTeamInviteLinkDetails(TeamLog.DeleteTeamInviteLinkDetails)
        /// An unspecified error.
        case memberAddExternalIdDetails(TeamLog.MemberAddExternalIdDetails)
        /// An unspecified error.
        case memberAddNameDetails(TeamLog.MemberAddNameDetails)
        /// An unspecified error.
        case memberChangeAdminRoleDetails(TeamLog.MemberChangeAdminRoleDetails)
        /// An unspecified error.
        case memberChangeEmailDetails(TeamLog.MemberChangeEmailDetails)
        /// An unspecified error.
        case memberChangeExternalIdDetails(TeamLog.MemberChangeExternalIdDetails)
        /// An unspecified error.
        case memberChangeMembershipTypeDetails(TeamLog.MemberChangeMembershipTypeDetails)
        /// An unspecified error.
        case memberChangeNameDetails(TeamLog.MemberChangeNameDetails)
        /// An unspecified error.
        case memberChangeResellerRoleDetails(TeamLog.MemberChangeResellerRoleDetails)
        /// An unspecified error.
        case memberChangeStatusDetails(TeamLog.MemberChangeStatusDetails)
        /// An unspecified error.
        case memberDeleteManualContactsDetails(TeamLog.MemberDeleteManualContactsDetails)
        /// An unspecified error.
        case memberDeleteProfilePhotoDetails(TeamLog.MemberDeleteProfilePhotoDetails)
        /// An unspecified error.
        case memberPermanentlyDeleteAccountContentsDetails(TeamLog.MemberPermanentlyDeleteAccountContentsDetails)
        /// An unspecified error.
        case memberRemoveExternalIdDetails(TeamLog.MemberRemoveExternalIdDetails)
        /// An unspecified error.
        case memberSetProfilePhotoDetails(TeamLog.MemberSetProfilePhotoDetails)
        /// An unspecified error.
        case memberSpaceLimitsAddCustomQuotaDetails(TeamLog.MemberSpaceLimitsAddCustomQuotaDetails)
        /// An unspecified error.
        case memberSpaceLimitsChangeCustomQuotaDetails(TeamLog.MemberSpaceLimitsChangeCustomQuotaDetails)
        /// An unspecified error.
        case memberSpaceLimitsChangeStatusDetails(TeamLog.MemberSpaceLimitsChangeStatusDetails)
        /// An unspecified error.
        case memberSpaceLimitsRemoveCustomQuotaDetails(TeamLog.MemberSpaceLimitsRemoveCustomQuotaDetails)
        /// An unspecified error.
        case memberSuggestDetails(TeamLog.MemberSuggestDetails)
        /// An unspecified error.
        case memberTransferAccountContentsDetails(TeamLog.MemberTransferAccountContentsDetails)
        /// An unspecified error.
        case pendingSecondaryEmailAddedDetails(TeamLog.PendingSecondaryEmailAddedDetails)
        /// An unspecified error.
        case secondaryEmailDeletedDetails(TeamLog.SecondaryEmailDeletedDetails)
        /// An unspecified error.
        case secondaryEmailVerifiedDetails(TeamLog.SecondaryEmailVerifiedDetails)
        /// An unspecified error.
        case secondaryMailsPolicyChangedDetails(TeamLog.SecondaryMailsPolicyChangedDetails)
        /// An unspecified error.
        case binderAddPageDetails(TeamLog.BinderAddPageDetails)
        /// An unspecified error.
        case binderAddSectionDetails(TeamLog.BinderAddSectionDetails)
        /// An unspecified error.
        case binderRemovePageDetails(TeamLog.BinderRemovePageDetails)
        /// An unspecified error.
        case binderRemoveSectionDetails(TeamLog.BinderRemoveSectionDetails)
        /// An unspecified error.
        case binderRenamePageDetails(TeamLog.BinderRenamePageDetails)
        /// An unspecified error.
        case binderRenameSectionDetails(TeamLog.BinderRenameSectionDetails)
        /// An unspecified error.
        case binderReorderPageDetails(TeamLog.BinderReorderPageDetails)
        /// An unspecified error.
        case binderReorderSectionDetails(TeamLog.BinderReorderSectionDetails)
        /// An unspecified error.
        case paperContentAddMemberDetails(TeamLog.PaperContentAddMemberDetails)
        /// An unspecified error.
        case paperContentAddToFolderDetails(TeamLog.PaperContentAddToFolderDetails)
        /// An unspecified error.
        case paperContentArchiveDetails(TeamLog.PaperContentArchiveDetails)
        /// An unspecified error.
        case paperContentCreateDetails(TeamLog.PaperContentCreateDetails)
        /// An unspecified error.
        case paperContentPermanentlyDeleteDetails(TeamLog.PaperContentPermanentlyDeleteDetails)
        /// An unspecified error.
        case paperContentRemoveFromFolderDetails(TeamLog.PaperContentRemoveFromFolderDetails)
        /// An unspecified error.
        case paperContentRemoveMemberDetails(TeamLog.PaperContentRemoveMemberDetails)
        /// An unspecified error.
        case paperContentRenameDetails(TeamLog.PaperContentRenameDetails)
        /// An unspecified error.
        case paperContentRestoreDetails(TeamLog.PaperContentRestoreDetails)
        /// An unspecified error.
        case paperDocAddCommentDetails(TeamLog.PaperDocAddCommentDetails)
        /// An unspecified error.
        case paperDocChangeMemberRoleDetails(TeamLog.PaperDocChangeMemberRoleDetails)
        /// An unspecified error.
        case paperDocChangeSharingPolicyDetails(TeamLog.PaperDocChangeSharingPolicyDetails)
        /// An unspecified error.
        case paperDocChangeSubscriptionDetails(TeamLog.PaperDocChangeSubscriptionDetails)
        /// An unspecified error.
        case paperDocDeletedDetails(TeamLog.PaperDocDeletedDetails)
        /// An unspecified error.
        case paperDocDeleteCommentDetails(TeamLog.PaperDocDeleteCommentDetails)
        /// An unspecified error.
        case paperDocDownloadDetails(TeamLog.PaperDocDownloadDetails)
        /// An unspecified error.
        case paperDocEditDetails(TeamLog.PaperDocEditDetails)
        /// An unspecified error.
        case paperDocEditCommentDetails(TeamLog.PaperDocEditCommentDetails)
        /// An unspecified error.
        case paperDocFollowedDetails(TeamLog.PaperDocFollowedDetails)
        /// An unspecified error.
        case paperDocMentionDetails(TeamLog.PaperDocMentionDetails)
        /// An unspecified error.
        case paperDocOwnershipChangedDetails(TeamLog.PaperDocOwnershipChangedDetails)
        /// An unspecified error.
        case paperDocRequestAccessDetails(TeamLog.PaperDocRequestAccessDetails)
        /// An unspecified error.
        case paperDocResolveCommentDetails(TeamLog.PaperDocResolveCommentDetails)
        /// An unspecified error.
        case paperDocRevertDetails(TeamLog.PaperDocRevertDetails)
        /// An unspecified error.
        case paperDocSlackShareDetails(TeamLog.PaperDocSlackShareDetails)
        /// An unspecified error.
        case paperDocTeamInviteDetails(TeamLog.PaperDocTeamInviteDetails)
        /// An unspecified error.
        case paperDocTrashedDetails(TeamLog.PaperDocTrashedDetails)
        /// An unspecified error.
        case paperDocUnresolveCommentDetails(TeamLog.PaperDocUnresolveCommentDetails)
        /// An unspecified error.
        case paperDocUntrashedDetails(TeamLog.PaperDocUntrashedDetails)
        /// An unspecified error.
        case paperDocViewDetails(TeamLog.PaperDocViewDetails)
        /// An unspecified error.
        case paperExternalViewAllowDetails(TeamLog.PaperExternalViewAllowDetails)
        /// An unspecified error.
        case paperExternalViewDefaultTeamDetails(TeamLog.PaperExternalViewDefaultTeamDetails)
        /// An unspecified error.
        case paperExternalViewForbidDetails(TeamLog.PaperExternalViewForbidDetails)
        /// An unspecified error.
        case paperFolderChangeSubscriptionDetails(TeamLog.PaperFolderChangeSubscriptionDetails)
        /// An unspecified error.
        case paperFolderDeletedDetails(TeamLog.PaperFolderDeletedDetails)
        /// An unspecified error.
        case paperFolderFollowedDetails(TeamLog.PaperFolderFollowedDetails)
        /// An unspecified error.
        case paperFolderTeamInviteDetails(TeamLog.PaperFolderTeamInviteDetails)
        /// An unspecified error.
        case paperPublishedLinkChangePermissionDetails(TeamLog.PaperPublishedLinkChangePermissionDetails)
        /// An unspecified error.
        case paperPublishedLinkCreateDetails(TeamLog.PaperPublishedLinkCreateDetails)
        /// An unspecified error.
        case paperPublishedLinkDisabledDetails(TeamLog.PaperPublishedLinkDisabledDetails)
        /// An unspecified error.
        case paperPublishedLinkViewDetails(TeamLog.PaperPublishedLinkViewDetails)
        /// An unspecified error.
        case passwordChangeDetails(TeamLog.PasswordChangeDetails)
        /// An unspecified error.
        case passwordResetDetails(TeamLog.PasswordResetDetails)
        /// An unspecified error.
        case passwordResetAllDetails(TeamLog.PasswordResetAllDetails)
        /// An unspecified error.
        case classificationCreateReportDetails(TeamLog.ClassificationCreateReportDetails)
        /// An unspecified error.
        case classificationCreateReportFailDetails(TeamLog.ClassificationCreateReportFailDetails)
        /// An unspecified error.
        case emmCreateExceptionsReportDetails(TeamLog.EmmCreateExceptionsReportDetails)
        /// An unspecified error.
        case emmCreateUsageReportDetails(TeamLog.EmmCreateUsageReportDetails)
        /// An unspecified error.
        case exportMembersReportDetails(TeamLog.ExportMembersReportDetails)
        /// An unspecified error.
        case exportMembersReportFailDetails(TeamLog.ExportMembersReportFailDetails)
        /// An unspecified error.
        case externalSharingCreateReportDetails(TeamLog.ExternalSharingCreateReportDetails)
        /// An unspecified error.
        case externalSharingReportFailedDetails(TeamLog.ExternalSharingReportFailedDetails)
        /// An unspecified error.
        case noExpirationLinkGenCreateReportDetails(TeamLog.NoExpirationLinkGenCreateReportDetails)
        /// An unspecified error.
        case noExpirationLinkGenReportFailedDetails(TeamLog.NoExpirationLinkGenReportFailedDetails)
        /// An unspecified error.
        case noPasswordLinkGenCreateReportDetails(TeamLog.NoPasswordLinkGenCreateReportDetails)
        /// An unspecified error.
        case noPasswordLinkGenReportFailedDetails(TeamLog.NoPasswordLinkGenReportFailedDetails)
        /// An unspecified error.
        case noPasswordLinkViewCreateReportDetails(TeamLog.NoPasswordLinkViewCreateReportDetails)
        /// An unspecified error.
        case noPasswordLinkViewReportFailedDetails(TeamLog.NoPasswordLinkViewReportFailedDetails)
        /// An unspecified error.
        case outdatedLinkViewCreateReportDetails(TeamLog.OutdatedLinkViewCreateReportDetails)
        /// An unspecified error.
        case outdatedLinkViewReportFailedDetails(TeamLog.OutdatedLinkViewReportFailedDetails)
        /// An unspecified error.
        case paperAdminExportStartDetails(TeamLog.PaperAdminExportStartDetails)
        /// An unspecified error.
        case ransomwareAlertCreateReportDetails(TeamLog.RansomwareAlertCreateReportDetails)
        /// An unspecified error.
        case ransomwareAlertCreateReportFailedDetails(TeamLog.RansomwareAlertCreateReportFailedDetails)
        /// An unspecified error.
        case smartSyncCreateAdminPrivilegeReportDetails(TeamLog.SmartSyncCreateAdminPrivilegeReportDetails)
        /// An unspecified error.
        case teamActivityCreateReportDetails(TeamLog.TeamActivityCreateReportDetails)
        /// An unspecified error.
        case teamActivityCreateReportFailDetails(TeamLog.TeamActivityCreateReportFailDetails)
        /// An unspecified error.
        case collectionShareDetails(TeamLog.CollectionShareDetails)
        /// An unspecified error.
        case fileTransfersFileAddDetails(TeamLog.FileTransfersFileAddDetails)
        /// An unspecified error.
        case fileTransfersTransferDeleteDetails(TeamLog.FileTransfersTransferDeleteDetails)
        /// An unspecified error.
        case fileTransfersTransferDownloadDetails(TeamLog.FileTransfersTransferDownloadDetails)
        /// An unspecified error.
        case fileTransfersTransferSendDetails(TeamLog.FileTransfersTransferSendDetails)
        /// An unspecified error.
        case fileTransfersTransferViewDetails(TeamLog.FileTransfersTransferViewDetails)
        /// An unspecified error.
        case noteAclInviteOnlyDetails(TeamLog.NoteAclInviteOnlyDetails)
        /// An unspecified error.
        case noteAclLinkDetails(TeamLog.NoteAclLinkDetails)
        /// An unspecified error.
        case noteAclTeamLinkDetails(TeamLog.NoteAclTeamLinkDetails)
        /// An unspecified error.
        case noteSharedDetails(TeamLog.NoteSharedDetails)
        /// An unspecified error.
        case noteShareReceiveDetails(TeamLog.NoteShareReceiveDetails)
        /// An unspecified error.
        case openNoteSharedDetails(TeamLog.OpenNoteSharedDetails)
        /// An unspecified error.
        case replayFileSharedLinkCreatedDetails(TeamLog.ReplayFileSharedLinkCreatedDetails)
        /// An unspecified error.
        case replayFileSharedLinkModifiedDetails(TeamLog.ReplayFileSharedLinkModifiedDetails)
        /// An unspecified error.
        case replayProjectTeamAddDetails(TeamLog.ReplayProjectTeamAddDetails)
        /// An unspecified error.
        case replayProjectTeamDeleteDetails(TeamLog.ReplayProjectTeamDeleteDetails)
        /// An unspecified error.
        case sfAddGroupDetails(TeamLog.SfAddGroupDetails)
        /// An unspecified error.
        case sfAllowNonMembersToViewSharedLinksDetails(TeamLog.SfAllowNonMembersToViewSharedLinksDetails)
        /// An unspecified error.
        case sfExternalInviteWarnDetails(TeamLog.SfExternalInviteWarnDetails)
        /// An unspecified error.
        case sfFbInviteDetails(TeamLog.SfFbInviteDetails)
        /// An unspecified error.
        case sfFbInviteChangeRoleDetails(TeamLog.SfFbInviteChangeRoleDetails)
        /// An unspecified error.
        case sfFbUninviteDetails(TeamLog.SfFbUninviteDetails)
        /// An unspecified error.
        case sfInviteGroupDetails(TeamLog.SfInviteGroupDetails)
        /// An unspecified error.
        case sfTeamGrantAccessDetails(TeamLog.SfTeamGrantAccessDetails)
        /// An unspecified error.
        case sfTeamInviteDetails(TeamLog.SfTeamInviteDetails)
        /// An unspecified error.
        case sfTeamInviteChangeRoleDetails(TeamLog.SfTeamInviteChangeRoleDetails)
        /// An unspecified error.
        case sfTeamJoinDetails(TeamLog.SfTeamJoinDetails)
        /// An unspecified error.
        case sfTeamJoinFromOobLinkDetails(TeamLog.SfTeamJoinFromOobLinkDetails)
        /// An unspecified error.
        case sfTeamUninviteDetails(TeamLog.SfTeamUninviteDetails)
        /// An unspecified error.
        case sharedContentAddInviteesDetails(TeamLog.SharedContentAddInviteesDetails)
        /// An unspecified error.
        case sharedContentAddLinkExpiryDetails(TeamLog.SharedContentAddLinkExpiryDetails)
        /// An unspecified error.
        case sharedContentAddLinkPasswordDetails(TeamLog.SharedContentAddLinkPasswordDetails)
        /// An unspecified error.
        case sharedContentAddMemberDetails(TeamLog.SharedContentAddMemberDetails)
        /// An unspecified error.
        case sharedContentChangeDownloadsPolicyDetails(TeamLog.SharedContentChangeDownloadsPolicyDetails)
        /// An unspecified error.
        case sharedContentChangeInviteeRoleDetails(TeamLog.SharedContentChangeInviteeRoleDetails)
        /// An unspecified error.
        case sharedContentChangeLinkAudienceDetails(TeamLog.SharedContentChangeLinkAudienceDetails)
        /// An unspecified error.
        case sharedContentChangeLinkExpiryDetails(TeamLog.SharedContentChangeLinkExpiryDetails)
        /// An unspecified error.
        case sharedContentChangeLinkPasswordDetails(TeamLog.SharedContentChangeLinkPasswordDetails)
        /// An unspecified error.
        case sharedContentChangeMemberRoleDetails(TeamLog.SharedContentChangeMemberRoleDetails)
        /// An unspecified error.
        case sharedContentChangeViewerInfoPolicyDetails(TeamLog.SharedContentChangeViewerInfoPolicyDetails)
        /// An unspecified error.
        case sharedContentClaimInvitationDetails(TeamLog.SharedContentClaimInvitationDetails)
        /// An unspecified error.
        case sharedContentCopyDetails(TeamLog.SharedContentCopyDetails)
        /// An unspecified error.
        case sharedContentDownloadDetails(TeamLog.SharedContentDownloadDetails)
        /// An unspecified error.
        case sharedContentRelinquishMembershipDetails(TeamLog.SharedContentRelinquishMembershipDetails)
        /// An unspecified error.
        case sharedContentRemoveInviteesDetails(TeamLog.SharedContentRemoveInviteesDetails)
        /// An unspecified error.
        case sharedContentRemoveLinkExpiryDetails(TeamLog.SharedContentRemoveLinkExpiryDetails)
        /// An unspecified error.
        case sharedContentRemoveLinkPasswordDetails(TeamLog.SharedContentRemoveLinkPasswordDetails)
        /// An unspecified error.
        case sharedContentRemoveMemberDetails(TeamLog.SharedContentRemoveMemberDetails)
        /// An unspecified error.
        case sharedContentRequestAccessDetails(TeamLog.SharedContentRequestAccessDetails)
        /// An unspecified error.
        case sharedContentRestoreInviteesDetails(TeamLog.SharedContentRestoreInviteesDetails)
        /// An unspecified error.
        case sharedContentRestoreMemberDetails(TeamLog.SharedContentRestoreMemberDetails)
        /// An unspecified error.
        case sharedContentUnshareDetails(TeamLog.SharedContentUnshareDetails)
        /// An unspecified error.
        case sharedContentViewDetails(TeamLog.SharedContentViewDetails)
        /// An unspecified error.
        case sharedFolderChangeLinkPolicyDetails(TeamLog.SharedFolderChangeLinkPolicyDetails)
        /// An unspecified error.
        case sharedFolderChangeMembersInheritancePolicyDetails(TeamLog.SharedFolderChangeMembersInheritancePolicyDetails)
        /// An unspecified error.
        case sharedFolderChangeMembersManagementPolicyDetails(TeamLog.SharedFolderChangeMembersManagementPolicyDetails)
        /// An unspecified error.
        case sharedFolderChangeMembersPolicyDetails(TeamLog.SharedFolderChangeMembersPolicyDetails)
        /// An unspecified error.
        case sharedFolderCreateDetails(TeamLog.SharedFolderCreateDetails)
        /// An unspecified error.
        case sharedFolderDeclineInvitationDetails(TeamLog.SharedFolderDeclineInvitationDetails)
        /// An unspecified error.
        case sharedFolderMountDetails(TeamLog.SharedFolderMountDetails)
        /// An unspecified error.
        case sharedFolderNestDetails(TeamLog.SharedFolderNestDetails)
        /// An unspecified error.
        case sharedFolderTransferOwnershipDetails(TeamLog.SharedFolderTransferOwnershipDetails)
        /// An unspecified error.
        case sharedFolderUnmountDetails(TeamLog.SharedFolderUnmountDetails)
        /// An unspecified error.
        case sharedLinkAddExpiryDetails(TeamLog.SharedLinkAddExpiryDetails)
        /// An unspecified error.
        case sharedLinkChangeExpiryDetails(TeamLog.SharedLinkChangeExpiryDetails)
        /// An unspecified error.
        case sharedLinkChangeVisibilityDetails(TeamLog.SharedLinkChangeVisibilityDetails)
        /// An unspecified error.
        case sharedLinkCopyDetails(TeamLog.SharedLinkCopyDetails)
        /// An unspecified error.
        case sharedLinkCreateDetails(TeamLog.SharedLinkCreateDetails)
        /// An unspecified error.
        case sharedLinkDisableDetails(TeamLog.SharedLinkDisableDetails)
        /// An unspecified error.
        case sharedLinkDownloadDetails(TeamLog.SharedLinkDownloadDetails)
        /// An unspecified error.
        case sharedLinkRemoveExpiryDetails(TeamLog.SharedLinkRemoveExpiryDetails)
        /// An unspecified error.
        case sharedLinkSettingsAddExpirationDetails(TeamLog.SharedLinkSettingsAddExpirationDetails)
        /// An unspecified error.
        case sharedLinkSettingsAddPasswordDetails(TeamLog.SharedLinkSettingsAddPasswordDetails)
        /// An unspecified error.
        case sharedLinkSettingsAllowDownloadDisabledDetails(TeamLog.SharedLinkSettingsAllowDownloadDisabledDetails)
        /// An unspecified error.
        case sharedLinkSettingsAllowDownloadEnabledDetails(TeamLog.SharedLinkSettingsAllowDownloadEnabledDetails)
        /// An unspecified error.
        case sharedLinkSettingsChangeAudienceDetails(TeamLog.SharedLinkSettingsChangeAudienceDetails)
        /// An unspecified error.
        case sharedLinkSettingsChangeExpirationDetails(TeamLog.SharedLinkSettingsChangeExpirationDetails)
        /// An unspecified error.
        case sharedLinkSettingsChangePasswordDetails(TeamLog.SharedLinkSettingsChangePasswordDetails)
        /// An unspecified error.
        case sharedLinkSettingsRemoveExpirationDetails(TeamLog.SharedLinkSettingsRemoveExpirationDetails)
        /// An unspecified error.
        case sharedLinkSettingsRemovePasswordDetails(TeamLog.SharedLinkSettingsRemovePasswordDetails)
        /// An unspecified error.
        case sharedLinkShareDetails(TeamLog.SharedLinkShareDetails)
        /// An unspecified error.
        case sharedLinkViewDetails(TeamLog.SharedLinkViewDetails)
        /// An unspecified error.
        case sharedNoteOpenedDetails(TeamLog.SharedNoteOpenedDetails)
        /// An unspecified error.
        case shmodelDisableDownloadsDetails(TeamLog.ShmodelDisableDownloadsDetails)
        /// An unspecified error.
        case shmodelEnableDownloadsDetails(TeamLog.ShmodelEnableDownloadsDetails)
        /// An unspecified error.
        case shmodelGroupShareDetails(TeamLog.ShmodelGroupShareDetails)
        /// An unspecified error.
        case showcaseAccessGrantedDetails(TeamLog.ShowcaseAccessGrantedDetails)
        /// An unspecified error.
        case showcaseAddMemberDetails(TeamLog.ShowcaseAddMemberDetails)
        /// An unspecified error.
        case showcaseArchivedDetails(TeamLog.ShowcaseArchivedDetails)
        /// An unspecified error.
        case showcaseCreatedDetails(TeamLog.ShowcaseCreatedDetails)
        /// An unspecified error.
        case showcaseDeleteCommentDetails(TeamLog.ShowcaseDeleteCommentDetails)
        /// An unspecified error.
        case showcaseEditedDetails(TeamLog.ShowcaseEditedDetails)
        /// An unspecified error.
        case showcaseEditCommentDetails(TeamLog.ShowcaseEditCommentDetails)
        /// An unspecified error.
        case showcaseFileAddedDetails(TeamLog.ShowcaseFileAddedDetails)
        /// An unspecified error.
        case showcaseFileDownloadDetails(TeamLog.ShowcaseFileDownloadDetails)
        /// An unspecified error.
        case showcaseFileRemovedDetails(TeamLog.ShowcaseFileRemovedDetails)
        /// An unspecified error.
        case showcaseFileViewDetails(TeamLog.ShowcaseFileViewDetails)
        /// An unspecified error.
        case showcasePermanentlyDeletedDetails(TeamLog.ShowcasePermanentlyDeletedDetails)
        /// An unspecified error.
        case showcasePostCommentDetails(TeamLog.ShowcasePostCommentDetails)
        /// An unspecified error.
        case showcaseRemoveMemberDetails(TeamLog.ShowcaseRemoveMemberDetails)
        /// An unspecified error.
        case showcaseRenamedDetails(TeamLog.ShowcaseRenamedDetails)
        /// An unspecified error.
        case showcaseRequestAccessDetails(TeamLog.ShowcaseRequestAccessDetails)
        /// An unspecified error.
        case showcaseResolveCommentDetails(TeamLog.ShowcaseResolveCommentDetails)
        /// An unspecified error.
        case showcaseRestoredDetails(TeamLog.ShowcaseRestoredDetails)
        /// An unspecified error.
        case showcaseTrashedDetails(TeamLog.ShowcaseTrashedDetails)
        /// An unspecified error.
        case showcaseTrashedDeprecatedDetails(TeamLog.ShowcaseTrashedDeprecatedDetails)
        /// An unspecified error.
        case showcaseUnresolveCommentDetails(TeamLog.ShowcaseUnresolveCommentDetails)
        /// An unspecified error.
        case showcaseUntrashedDetails(TeamLog.ShowcaseUntrashedDetails)
        /// An unspecified error.
        case showcaseUntrashedDeprecatedDetails(TeamLog.ShowcaseUntrashedDeprecatedDetails)
        /// An unspecified error.
        case showcaseViewDetails(TeamLog.ShowcaseViewDetails)
        /// An unspecified error.
        case ssoAddCertDetails(TeamLog.SsoAddCertDetails)
        /// An unspecified error.
        case ssoAddLoginUrlDetails(TeamLog.SsoAddLoginUrlDetails)
        /// An unspecified error.
        case ssoAddLogoutUrlDetails(TeamLog.SsoAddLogoutUrlDetails)
        /// An unspecified error.
        case ssoChangeCertDetails(TeamLog.SsoChangeCertDetails)
        /// An unspecified error.
        case ssoChangeLoginUrlDetails(TeamLog.SsoChangeLoginUrlDetails)
        /// An unspecified error.
        case ssoChangeLogoutUrlDetails(TeamLog.SsoChangeLogoutUrlDetails)
        /// An unspecified error.
        case ssoChangeSamlIdentityModeDetails(TeamLog.SsoChangeSamlIdentityModeDetails)
        /// An unspecified error.
        case ssoRemoveCertDetails(TeamLog.SsoRemoveCertDetails)
        /// An unspecified error.
        case ssoRemoveLoginUrlDetails(TeamLog.SsoRemoveLoginUrlDetails)
        /// An unspecified error.
        case ssoRemoveLogoutUrlDetails(TeamLog.SsoRemoveLogoutUrlDetails)
        /// An unspecified error.
        case teamFolderChangeStatusDetails(TeamLog.TeamFolderChangeStatusDetails)
        /// An unspecified error.
        case teamFolderCreateDetails(TeamLog.TeamFolderCreateDetails)
        /// An unspecified error.
        case teamFolderDowngradeDetails(TeamLog.TeamFolderDowngradeDetails)
        /// An unspecified error.
        case teamFolderPermanentlyDeleteDetails(TeamLog.TeamFolderPermanentlyDeleteDetails)
        /// An unspecified error.
        case teamFolderRenameDetails(TeamLog.TeamFolderRenameDetails)
        /// An unspecified error.
        case teamSelectiveSyncSettingsChangedDetails(TeamLog.TeamSelectiveSyncSettingsChangedDetails)
        /// An unspecified error.
        case accountCaptureChangePolicyDetails(TeamLog.AccountCaptureChangePolicyDetails)
        /// An unspecified error.
        case adminEmailRemindersChangedDetails(TeamLog.AdminEmailRemindersChangedDetails)
        /// An unspecified error.
        case allowDownloadDisabledDetails(TeamLog.AllowDownloadDisabledDetails)
        /// An unspecified error.
        case allowDownloadEnabledDetails(TeamLog.AllowDownloadEnabledDetails)
        /// An unspecified error.
        case appPermissionsChangedDetails(TeamLog.AppPermissionsChangedDetails)
        /// An unspecified error.
        case cameraUploadsPolicyChangedDetails(TeamLog.CameraUploadsPolicyChangedDetails)
        /// An unspecified error.
        case captureTranscriptPolicyChangedDetails(TeamLog.CaptureTranscriptPolicyChangedDetails)
        /// An unspecified error.
        case classificationChangePolicyDetails(TeamLog.ClassificationChangePolicyDetails)
        /// An unspecified error.
        case computerBackupPolicyChangedDetails(TeamLog.ComputerBackupPolicyChangedDetails)
        /// An unspecified error.
        case contentAdministrationPolicyChangedDetails(TeamLog.ContentAdministrationPolicyChangedDetails)
        /// An unspecified error.
        case dataPlacementRestrictionChangePolicyDetails(TeamLog.DataPlacementRestrictionChangePolicyDetails)
        /// An unspecified error.
        case dataPlacementRestrictionSatisfyPolicyDetails(TeamLog.DataPlacementRestrictionSatisfyPolicyDetails)
        /// An unspecified error.
        case deviceApprovalsAddExceptionDetails(TeamLog.DeviceApprovalsAddExceptionDetails)
        /// An unspecified error.
        case deviceApprovalsChangeDesktopPolicyDetails(TeamLog.DeviceApprovalsChangeDesktopPolicyDetails)
        /// An unspecified error.
        case deviceApprovalsChangeMobilePolicyDetails(TeamLog.DeviceApprovalsChangeMobilePolicyDetails)
        /// An unspecified error.
        case deviceApprovalsChangeOverageActionDetails(TeamLog.DeviceApprovalsChangeOverageActionDetails)
        /// An unspecified error.
        case deviceApprovalsChangeUnlinkActionDetails(TeamLog.DeviceApprovalsChangeUnlinkActionDetails)
        /// An unspecified error.
        case deviceApprovalsRemoveExceptionDetails(TeamLog.DeviceApprovalsRemoveExceptionDetails)
        /// An unspecified error.
        case directoryRestrictionsAddMembersDetails(TeamLog.DirectoryRestrictionsAddMembersDetails)
        /// An unspecified error.
        case directoryRestrictionsRemoveMembersDetails(TeamLog.DirectoryRestrictionsRemoveMembersDetails)
        /// An unspecified error.
        case dropboxPasswordsPolicyChangedDetails(TeamLog.DropboxPasswordsPolicyChangedDetails)
        /// An unspecified error.
        case emailIngestPolicyChangedDetails(TeamLog.EmailIngestPolicyChangedDetails)
        /// An unspecified error.
        case emmAddExceptionDetails(TeamLog.EmmAddExceptionDetails)
        /// An unspecified error.
        case emmChangePolicyDetails(TeamLog.EmmChangePolicyDetails)
        /// An unspecified error.
        case emmRemoveExceptionDetails(TeamLog.EmmRemoveExceptionDetails)
        /// An unspecified error.
        case extendedVersionHistoryChangePolicyDetails(TeamLog.ExtendedVersionHistoryChangePolicyDetails)
        /// An unspecified error.
        case externalDriveBackupPolicyChangedDetails(TeamLog.ExternalDriveBackupPolicyChangedDetails)
        /// An unspecified error.
        case fileCommentsChangePolicyDetails(TeamLog.FileCommentsChangePolicyDetails)
        /// An unspecified error.
        case fileLockingPolicyChangedDetails(TeamLog.FileLockingPolicyChangedDetails)
        /// An unspecified error.
        case fileProviderMigrationPolicyChangedDetails(TeamLog.FileProviderMigrationPolicyChangedDetails)
        /// An unspecified error.
        case fileRequestsChangePolicyDetails(TeamLog.FileRequestsChangePolicyDetails)
        /// An unspecified error.
        case fileRequestsEmailsEnabledDetails(TeamLog.FileRequestsEmailsEnabledDetails)
        /// An unspecified error.
        case fileRequestsEmailsRestrictedToTeamOnlyDetails(TeamLog.FileRequestsEmailsRestrictedToTeamOnlyDetails)
        /// An unspecified error.
        case fileTransfersPolicyChangedDetails(TeamLog.FileTransfersPolicyChangedDetails)
        /// An unspecified error.
        case folderLinkRestrictionPolicyChangedDetails(TeamLog.FolderLinkRestrictionPolicyChangedDetails)
        /// An unspecified error.
        case googleSsoChangePolicyDetails(TeamLog.GoogleSsoChangePolicyDetails)
        /// An unspecified error.
        case groupUserManagementChangePolicyDetails(TeamLog.GroupUserManagementChangePolicyDetails)
        /// An unspecified error.
        case integrationPolicyChangedDetails(TeamLog.IntegrationPolicyChangedDetails)
        /// An unspecified error.
        case inviteAcceptanceEmailPolicyChangedDetails(TeamLog.InviteAcceptanceEmailPolicyChangedDetails)
        /// An unspecified error.
        case memberRequestsChangePolicyDetails(TeamLog.MemberRequestsChangePolicyDetails)
        /// An unspecified error.
        case memberSendInvitePolicyChangedDetails(TeamLog.MemberSendInvitePolicyChangedDetails)
        /// An unspecified error.
        case memberSpaceLimitsAddExceptionDetails(TeamLog.MemberSpaceLimitsAddExceptionDetails)
        /// An unspecified error.
        case memberSpaceLimitsChangeCapsTypePolicyDetails(TeamLog.MemberSpaceLimitsChangeCapsTypePolicyDetails)
        /// An unspecified error.
        case memberSpaceLimitsChangePolicyDetails(TeamLog.MemberSpaceLimitsChangePolicyDetails)
        /// An unspecified error.
        case memberSpaceLimitsRemoveExceptionDetails(TeamLog.MemberSpaceLimitsRemoveExceptionDetails)
        /// An unspecified error.
        case memberSuggestionsChangePolicyDetails(TeamLog.MemberSuggestionsChangePolicyDetails)
        /// An unspecified error.
        case microsoftOfficeAddinChangePolicyDetails(TeamLog.MicrosoftOfficeAddinChangePolicyDetails)
        /// An unspecified error.
        case networkControlChangePolicyDetails(TeamLog.NetworkControlChangePolicyDetails)
        /// An unspecified error.
        case paperChangeDeploymentPolicyDetails(TeamLog.PaperChangeDeploymentPolicyDetails)
        /// An unspecified error.
        case paperChangeMemberLinkPolicyDetails(TeamLog.PaperChangeMemberLinkPolicyDetails)
        /// An unspecified error.
        case paperChangeMemberPolicyDetails(TeamLog.PaperChangeMemberPolicyDetails)
        /// An unspecified error.
        case paperChangePolicyDetails(TeamLog.PaperChangePolicyDetails)
        /// An unspecified error.
        case paperDefaultFolderPolicyChangedDetails(TeamLog.PaperDefaultFolderPolicyChangedDetails)
        /// An unspecified error.
        case paperDesktopPolicyChangedDetails(TeamLog.PaperDesktopPolicyChangedDetails)
        /// An unspecified error.
        case paperEnabledUsersGroupAdditionDetails(TeamLog.PaperEnabledUsersGroupAdditionDetails)
        /// An unspecified error.
        case paperEnabledUsersGroupRemovalDetails(TeamLog.PaperEnabledUsersGroupRemovalDetails)
        /// An unspecified error.
        case passwordStrengthRequirementsChangePolicyDetails(TeamLog.PasswordStrengthRequirementsChangePolicyDetails)
        /// An unspecified error.
        case permanentDeleteChangePolicyDetails(TeamLog.PermanentDeleteChangePolicyDetails)
        /// An unspecified error.
        case resellerSupportChangePolicyDetails(TeamLog.ResellerSupportChangePolicyDetails)
        /// An unspecified error.
        case rewindPolicyChangedDetails(TeamLog.RewindPolicyChangedDetails)
        /// An unspecified error.
        case sendForSignaturePolicyChangedDetails(TeamLog.SendForSignaturePolicyChangedDetails)
        /// An unspecified error.
        case sharingChangeFolderJoinPolicyDetails(TeamLog.SharingChangeFolderJoinPolicyDetails)
        /// An unspecified error.
        case sharingChangeLinkAllowChangeExpirationPolicyDetails(TeamLog.SharingChangeLinkAllowChangeExpirationPolicyDetails)
        /// An unspecified error.
        case sharingChangeLinkDefaultExpirationPolicyDetails(TeamLog.SharingChangeLinkDefaultExpirationPolicyDetails)
        /// An unspecified error.
        case sharingChangeLinkEnforcePasswordPolicyDetails(TeamLog.SharingChangeLinkEnforcePasswordPolicyDetails)
        /// An unspecified error.
        case sharingChangeLinkPolicyDetails(TeamLog.SharingChangeLinkPolicyDetails)
        /// An unspecified error.
        case sharingChangeMemberPolicyDetails(TeamLog.SharingChangeMemberPolicyDetails)
        /// An unspecified error.
        case showcaseChangeDownloadPolicyDetails(TeamLog.ShowcaseChangeDownloadPolicyDetails)
        /// An unspecified error.
        case showcaseChangeEnabledPolicyDetails(TeamLog.ShowcaseChangeEnabledPolicyDetails)
        /// An unspecified error.
        case showcaseChangeExternalSharingPolicyDetails(TeamLog.ShowcaseChangeExternalSharingPolicyDetails)
        /// An unspecified error.
        case smarterSmartSyncPolicyChangedDetails(TeamLog.SmarterSmartSyncPolicyChangedDetails)
        /// An unspecified error.
        case smartSyncChangePolicyDetails(TeamLog.SmartSyncChangePolicyDetails)
        /// An unspecified error.
        case smartSyncNotOptOutDetails(TeamLog.SmartSyncNotOptOutDetails)
        /// An unspecified error.
        case smartSyncOptOutDetails(TeamLog.SmartSyncOptOutDetails)
        /// An unspecified error.
        case ssoChangePolicyDetails(TeamLog.SsoChangePolicyDetails)
        /// An unspecified error.
        case teamBrandingPolicyChangedDetails(TeamLog.TeamBrandingPolicyChangedDetails)
        /// An unspecified error.
        case teamExtensionsPolicyChangedDetails(TeamLog.TeamExtensionsPolicyChangedDetails)
        /// An unspecified error.
        case teamSelectiveSyncPolicyChangedDetails(TeamLog.TeamSelectiveSyncPolicyChangedDetails)
        /// An unspecified error.
        case teamSharingWhitelistSubjectsChangedDetails(TeamLog.TeamSharingWhitelistSubjectsChangedDetails)
        /// An unspecified error.
        case tfaAddExceptionDetails(TeamLog.TfaAddExceptionDetails)
        /// An unspecified error.
        case tfaChangePolicyDetails(TeamLog.TfaChangePolicyDetails)
        /// An unspecified error.
        case tfaRemoveExceptionDetails(TeamLog.TfaRemoveExceptionDetails)
        /// An unspecified error.
        case twoAccountChangePolicyDetails(TeamLog.TwoAccountChangePolicyDetails)
        /// An unspecified error.
        case viewerInfoPolicyChangedDetails(TeamLog.ViewerInfoPolicyChangedDetails)
        /// An unspecified error.
        case watermarkingPolicyChangedDetails(TeamLog.WatermarkingPolicyChangedDetails)
        /// An unspecified error.
        case webSessionsChangeActiveSessionLimitDetails(TeamLog.WebSessionsChangeActiveSessionLimitDetails)
        /// An unspecified error.
        case webSessionsChangeFixedLengthPolicyDetails(TeamLog.WebSessionsChangeFixedLengthPolicyDetails)
        /// An unspecified error.
        case webSessionsChangeIdleLengthPolicyDetails(TeamLog.WebSessionsChangeIdleLengthPolicyDetails)
        /// An unspecified error.
        case dataResidencyMigrationRequestSuccessfulDetails(TeamLog.DataResidencyMigrationRequestSuccessfulDetails)
        /// An unspecified error.
        case dataResidencyMigrationRequestUnsuccessfulDetails(TeamLog.DataResidencyMigrationRequestUnsuccessfulDetails)
        /// An unspecified error.
        case teamMergeFromDetails(TeamLog.TeamMergeFromDetails)
        /// An unspecified error.
        case teamMergeToDetails(TeamLog.TeamMergeToDetails)
        /// An unspecified error.
        case teamProfileAddBackgroundDetails(TeamLog.TeamProfileAddBackgroundDetails)
        /// An unspecified error.
        case teamProfileAddLogoDetails(TeamLog.TeamProfileAddLogoDetails)
        /// An unspecified error.
        case teamProfileChangeBackgroundDetails(TeamLog.TeamProfileChangeBackgroundDetails)
        /// An unspecified error.
        case teamProfileChangeDefaultLanguageDetails(TeamLog.TeamProfileChangeDefaultLanguageDetails)
        /// An unspecified error.
        case teamProfileChangeLogoDetails(TeamLog.TeamProfileChangeLogoDetails)
        /// An unspecified error.
        case teamProfileChangeNameDetails(TeamLog.TeamProfileChangeNameDetails)
        /// An unspecified error.
        case teamProfileRemoveBackgroundDetails(TeamLog.TeamProfileRemoveBackgroundDetails)
        /// An unspecified error.
        case teamProfileRemoveLogoDetails(TeamLog.TeamProfileRemoveLogoDetails)
        /// An unspecified error.
        case tfaAddBackupPhoneDetails(TeamLog.TfaAddBackupPhoneDetails)
        /// An unspecified error.
        case tfaAddSecurityKeyDetails(TeamLog.TfaAddSecurityKeyDetails)
        /// An unspecified error.
        case tfaChangeBackupPhoneDetails(TeamLog.TfaChangeBackupPhoneDetails)
        /// An unspecified error.
        case tfaChangeStatusDetails(TeamLog.TfaChangeStatusDetails)
        /// An unspecified error.
        case tfaRemoveBackupPhoneDetails(TeamLog.TfaRemoveBackupPhoneDetails)
        /// An unspecified error.
        case tfaRemoveSecurityKeyDetails(TeamLog.TfaRemoveSecurityKeyDetails)
        /// An unspecified error.
        case tfaResetDetails(TeamLog.TfaResetDetails)
        /// An unspecified error.
        case changedEnterpriseAdminRoleDetails(TeamLog.ChangedEnterpriseAdminRoleDetails)
        /// An unspecified error.
        case changedEnterpriseConnectedTeamStatusDetails(TeamLog.ChangedEnterpriseConnectedTeamStatusDetails)
        /// An unspecified error.
        case endedEnterpriseAdminSessionDetails(TeamLog.EndedEnterpriseAdminSessionDetails)
        /// An unspecified error.
        case endedEnterpriseAdminSessionDeprecatedDetails(TeamLog.EndedEnterpriseAdminSessionDeprecatedDetails)
        /// An unspecified error.
        case enterpriseSettingsLockingDetails(TeamLog.EnterpriseSettingsLockingDetails)
        /// An unspecified error.
        case guestAdminChangeStatusDetails(TeamLog.GuestAdminChangeStatusDetails)
        /// An unspecified error.
        case startedEnterpriseAdminSessionDetails(TeamLog.StartedEnterpriseAdminSessionDetails)
        /// An unspecified error.
        case teamMergeRequestAcceptedDetails(TeamLog.TeamMergeRequestAcceptedDetails)
        /// An unspecified error.
        case teamMergeRequestAcceptedShownToPrimaryTeamDetails(TeamLog.TeamMergeRequestAcceptedShownToPrimaryTeamDetails)
        /// An unspecified error.
        case teamMergeRequestAcceptedShownToSecondaryTeamDetails(TeamLog.TeamMergeRequestAcceptedShownToSecondaryTeamDetails)
        /// An unspecified error.
        case teamMergeRequestAutoCanceledDetails(TeamLog.TeamMergeRequestAutoCanceledDetails)
        /// An unspecified error.
        case teamMergeRequestCanceledDetails(TeamLog.TeamMergeRequestCanceledDetails)
        /// An unspecified error.
        case teamMergeRequestCanceledShownToPrimaryTeamDetails(TeamLog.TeamMergeRequestCanceledShownToPrimaryTeamDetails)
        /// An unspecified error.
        case teamMergeRequestCanceledShownToSecondaryTeamDetails(TeamLog.TeamMergeRequestCanceledShownToSecondaryTeamDetails)
        /// An unspecified error.
        case teamMergeRequestExpiredDetails(TeamLog.TeamMergeRequestExpiredDetails)
        /// An unspecified error.
        case teamMergeRequestExpiredShownToPrimaryTeamDetails(TeamLog.TeamMergeRequestExpiredShownToPrimaryTeamDetails)
        /// An unspecified error.
        case teamMergeRequestExpiredShownToSecondaryTeamDetails(TeamLog.TeamMergeRequestExpiredShownToSecondaryTeamDetails)
        /// An unspecified error.
        case teamMergeRequestRejectedShownToPrimaryTeamDetails(TeamLog.TeamMergeRequestRejectedShownToPrimaryTeamDetails)
        /// An unspecified error.
        case teamMergeRequestRejectedShownToSecondaryTeamDetails(TeamLog.TeamMergeRequestRejectedShownToSecondaryTeamDetails)
        /// An unspecified error.
        case teamMergeRequestReminderDetails(TeamLog.TeamMergeRequestReminderDetails)
        /// An unspecified error.
        case teamMergeRequestReminderShownToPrimaryTeamDetails(TeamLog.TeamMergeRequestReminderShownToPrimaryTeamDetails)
        /// An unspecified error.
        case teamMergeRequestReminderShownToSecondaryTeamDetails(TeamLog.TeamMergeRequestReminderShownToSecondaryTeamDetails)
        /// An unspecified error.
        case teamMergeRequestRevokedDetails(TeamLog.TeamMergeRequestRevokedDetails)
        /// An unspecified error.
        case teamMergeRequestSentShownToPrimaryTeamDetails(TeamLog.TeamMergeRequestSentShownToPrimaryTeamDetails)
        /// An unspecified error.
        case teamMergeRequestSentShownToSecondaryTeamDetails(TeamLog.TeamMergeRequestSentShownToSecondaryTeamDetails)
        /// Hints that this event was returned with missing details due to an internal error.
        case missingDetails(TeamLog.MissingDetails)
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try EventDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try EventDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for EventDetails: \(error)"
            }
        }
    }

    public class EventDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: EventDetails) throws -> JSON {
            switch value {
            case .adminAlertingAlertStateChangedDetails(let arg):
                var d = try Serialization.getFields(TeamLog.AdminAlertingAlertStateChangedDetailsSerializer().serialize(arg))
                d[".tag"] = .str("admin_alerting_alert_state_changed_details")
                return .dictionary(d)
            case .adminAlertingChangedAlertConfigDetails(let arg):
                var d = try Serialization.getFields(TeamLog.AdminAlertingChangedAlertConfigDetailsSerializer().serialize(arg))
                d[".tag"] = .str("admin_alerting_changed_alert_config_details")
                return .dictionary(d)
            case .adminAlertingTriggeredAlertDetails(let arg):
                var d = try Serialization.getFields(TeamLog.AdminAlertingTriggeredAlertDetailsSerializer().serialize(arg))
                d[".tag"] = .str("admin_alerting_triggered_alert_details")
                return .dictionary(d)
            case .ransomwareRestoreProcessCompletedDetails(let arg):
                var d = try Serialization.getFields(TeamLog.RansomwareRestoreProcessCompletedDetailsSerializer().serialize(arg))
                d[".tag"] = .str("ransomware_restore_process_completed_details")
                return .dictionary(d)
            case .ransomwareRestoreProcessStartedDetails(let arg):
                var d = try Serialization.getFields(TeamLog.RansomwareRestoreProcessStartedDetailsSerializer().serialize(arg))
                d[".tag"] = .str("ransomware_restore_process_started_details")
                return .dictionary(d)
            case .appBlockedByPermissionsDetails(let arg):
                var d = try Serialization.getFields(TeamLog.AppBlockedByPermissionsDetailsSerializer().serialize(arg))
                d[".tag"] = .str("app_blocked_by_permissions_details")
                return .dictionary(d)
            case .appLinkTeamDetails(let arg):
                var d = try Serialization.getFields(TeamLog.AppLinkTeamDetailsSerializer().serialize(arg))
                d[".tag"] = .str("app_link_team_details")
                return .dictionary(d)
            case .appLinkUserDetails(let arg):
                var d = try Serialization.getFields(TeamLog.AppLinkUserDetailsSerializer().serialize(arg))
                d[".tag"] = .str("app_link_user_details")
                return .dictionary(d)
            case .appUnlinkTeamDetails(let arg):
                var d = try Serialization.getFields(TeamLog.AppUnlinkTeamDetailsSerializer().serialize(arg))
                d[".tag"] = .str("app_unlink_team_details")
                return .dictionary(d)
            case .appUnlinkUserDetails(let arg):
                var d = try Serialization.getFields(TeamLog.AppUnlinkUserDetailsSerializer().serialize(arg))
                d[".tag"] = .str("app_unlink_user_details")
                return .dictionary(d)
            case .integrationConnectedDetails(let arg):
                var d = try Serialization.getFields(TeamLog.IntegrationConnectedDetailsSerializer().serialize(arg))
                d[".tag"] = .str("integration_connected_details")
                return .dictionary(d)
            case .integrationDisconnectedDetails(let arg):
                var d = try Serialization.getFields(TeamLog.IntegrationDisconnectedDetailsSerializer().serialize(arg))
                d[".tag"] = .str("integration_disconnected_details")
                return .dictionary(d)
            case .fileAddCommentDetails(let arg):
                var d = try Serialization.getFields(TeamLog.FileAddCommentDetailsSerializer().serialize(arg))
                d[".tag"] = .str("file_add_comment_details")
                return .dictionary(d)
            case .fileChangeCommentSubscriptionDetails(let arg):
                var d = try Serialization.getFields(TeamLog.FileChangeCommentSubscriptionDetailsSerializer().serialize(arg))
                d[".tag"] = .str("file_change_comment_subscription_details")
                return .dictionary(d)
            case .fileDeleteCommentDetails(let arg):
                var d = try Serialization.getFields(TeamLog.FileDeleteCommentDetailsSerializer().serialize(arg))
                d[".tag"] = .str("file_delete_comment_details")
                return .dictionary(d)
            case .fileEditCommentDetails(let arg):
                var d = try Serialization.getFields(TeamLog.FileEditCommentDetailsSerializer().serialize(arg))
                d[".tag"] = .str("file_edit_comment_details")
                return .dictionary(d)
            case .fileLikeCommentDetails(let arg):
                var d = try Serialization.getFields(TeamLog.FileLikeCommentDetailsSerializer().serialize(arg))
                d[".tag"] = .str("file_like_comment_details")
                return .dictionary(d)
            case .fileResolveCommentDetails(let arg):
                var d = try Serialization.getFields(TeamLog.FileResolveCommentDetailsSerializer().serialize(arg))
                d[".tag"] = .str("file_resolve_comment_details")
                return .dictionary(d)
            case .fileUnlikeCommentDetails(let arg):
                var d = try Serialization.getFields(TeamLog.FileUnlikeCommentDetailsSerializer().serialize(arg))
                d[".tag"] = .str("file_unlike_comment_details")
                return .dictionary(d)
            case .fileUnresolveCommentDetails(let arg):
                var d = try Serialization.getFields(TeamLog.FileUnresolveCommentDetailsSerializer().serialize(arg))
                d[".tag"] = .str("file_unresolve_comment_details")
                return .dictionary(d)
            case .governancePolicyAddFoldersDetails(let arg):
                var d = try Serialization.getFields(TeamLog.GovernancePolicyAddFoldersDetailsSerializer().serialize(arg))
                d[".tag"] = .str("governance_policy_add_folders_details")
                return .dictionary(d)
            case .governancePolicyAddFolderFailedDetails(let arg):
                var d = try Serialization.getFields(TeamLog.GovernancePolicyAddFolderFailedDetailsSerializer().serialize(arg))
                d[".tag"] = .str("governance_policy_add_folder_failed_details")
                return .dictionary(d)
            case .governancePolicyContentDisposedDetails(let arg):
                var d = try Serialization.getFields(TeamLog.GovernancePolicyContentDisposedDetailsSerializer().serialize(arg))
                d[".tag"] = .str("governance_policy_content_disposed_details")
                return .dictionary(d)
            case .governancePolicyCreateDetails(let arg):
                var d = try Serialization.getFields(TeamLog.GovernancePolicyCreateDetailsSerializer().serialize(arg))
                d[".tag"] = .str("governance_policy_create_details")
                return .dictionary(d)
            case .governancePolicyDeleteDetails(let arg):
                var d = try Serialization.getFields(TeamLog.GovernancePolicyDeleteDetailsSerializer().serialize(arg))
                d[".tag"] = .str("governance_policy_delete_details")
                return .dictionary(d)
            case .governancePolicyEditDetailsDetails(let arg):
                var d = try Serialization.getFields(TeamLog.GovernancePolicyEditDetailsDetailsSerializer().serialize(arg))
                d[".tag"] = .str("governance_policy_edit_details_details")
                return .dictionary(d)
            case .governancePolicyEditDurationDetails(let arg):
                var d = try Serialization.getFields(TeamLog.GovernancePolicyEditDurationDetailsSerializer().serialize(arg))
                d[".tag"] = .str("governance_policy_edit_duration_details")
                return .dictionary(d)
            case .governancePolicyExportCreatedDetails(let arg):
                var d = try Serialization.getFields(TeamLog.GovernancePolicyExportCreatedDetailsSerializer().serialize(arg))
                d[".tag"] = .str("governance_policy_export_created_details")
                return .dictionary(d)
            case .governancePolicyExportRemovedDetails(let arg):
                var d = try Serialization.getFields(TeamLog.GovernancePolicyExportRemovedDetailsSerializer().serialize(arg))
                d[".tag"] = .str("governance_policy_export_removed_details")
                return .dictionary(d)
            case .governancePolicyRemoveFoldersDetails(let arg):
                var d = try Serialization.getFields(TeamLog.GovernancePolicyRemoveFoldersDetailsSerializer().serialize(arg))
                d[".tag"] = .str("governance_policy_remove_folders_details")
                return .dictionary(d)
            case .governancePolicyReportCreatedDetails(let arg):
                var d = try Serialization.getFields(TeamLog.GovernancePolicyReportCreatedDetailsSerializer().serialize(arg))
                d[".tag"] = .str("governance_policy_report_created_details")
                return .dictionary(d)
            case .governancePolicyZipPartDownloadedDetails(let arg):
                var d = try Serialization.getFields(TeamLog.GovernancePolicyZipPartDownloadedDetailsSerializer().serialize(arg))
                d[".tag"] = .str("governance_policy_zip_part_downloaded_details")
                return .dictionary(d)
            case .legalHoldsActivateAHoldDetails(let arg):
                var d = try Serialization.getFields(TeamLog.LegalHoldsActivateAHoldDetailsSerializer().serialize(arg))
                d[".tag"] = .str("legal_holds_activate_a_hold_details")
                return .dictionary(d)
            case .legalHoldsAddMembersDetails(let arg):
                var d = try Serialization.getFields(TeamLog.LegalHoldsAddMembersDetailsSerializer().serialize(arg))
                d[".tag"] = .str("legal_holds_add_members_details")
                return .dictionary(d)
            case .legalHoldsChangeHoldDetailsDetails(let arg):
                var d = try Serialization.getFields(TeamLog.LegalHoldsChangeHoldDetailsDetailsSerializer().serialize(arg))
                d[".tag"] = .str("legal_holds_change_hold_details_details")
                return .dictionary(d)
            case .legalHoldsChangeHoldNameDetails(let arg):
                var d = try Serialization.getFields(TeamLog.LegalHoldsChangeHoldNameDetailsSerializer().serialize(arg))
                d[".tag"] = .str("legal_holds_change_hold_name_details")
                return .dictionary(d)
            case .legalHoldsExportAHoldDetails(let arg):
                var d = try Serialization.getFields(TeamLog.LegalHoldsExportAHoldDetailsSerializer().serialize(arg))
                d[".tag"] = .str("legal_holds_export_a_hold_details")
                return .dictionary(d)
            case .legalHoldsExportCancelledDetails(let arg):
                var d = try Serialization.getFields(TeamLog.LegalHoldsExportCancelledDetailsSerializer().serialize(arg))
                d[".tag"] = .str("legal_holds_export_cancelled_details")
                return .dictionary(d)
            case .legalHoldsExportDownloadedDetails(let arg):
                var d = try Serialization.getFields(TeamLog.LegalHoldsExportDownloadedDetailsSerializer().serialize(arg))
                d[".tag"] = .str("legal_holds_export_downloaded_details")
                return .dictionary(d)
            case .legalHoldsExportRemovedDetails(let arg):
                var d = try Serialization.getFields(TeamLog.LegalHoldsExportRemovedDetailsSerializer().serialize(arg))
                d[".tag"] = .str("legal_holds_export_removed_details")
                return .dictionary(d)
            case .legalHoldsReleaseAHoldDetails(let arg):
                var d = try Serialization.getFields(TeamLog.LegalHoldsReleaseAHoldDetailsSerializer().serialize(arg))
                d[".tag"] = .str("legal_holds_release_a_hold_details")
                return .dictionary(d)
            case .legalHoldsRemoveMembersDetails(let arg):
                var d = try Serialization.getFields(TeamLog.LegalHoldsRemoveMembersDetailsSerializer().serialize(arg))
                d[".tag"] = .str("legal_holds_remove_members_details")
                return .dictionary(d)
            case .legalHoldsReportAHoldDetails(let arg):
                var d = try Serialization.getFields(TeamLog.LegalHoldsReportAHoldDetailsSerializer().serialize(arg))
                d[".tag"] = .str("legal_holds_report_a_hold_details")
                return .dictionary(d)
            case .deviceChangeIpDesktopDetails(let arg):
                var d = try Serialization.getFields(TeamLog.DeviceChangeIpDesktopDetailsSerializer().serialize(arg))
                d[".tag"] = .str("device_change_ip_desktop_details")
                return .dictionary(d)
            case .deviceChangeIpMobileDetails(let arg):
                var d = try Serialization.getFields(TeamLog.DeviceChangeIpMobileDetailsSerializer().serialize(arg))
                d[".tag"] = .str("device_change_ip_mobile_details")
                return .dictionary(d)
            case .deviceChangeIpWebDetails(let arg):
                var d = try Serialization.getFields(TeamLog.DeviceChangeIpWebDetailsSerializer().serialize(arg))
                d[".tag"] = .str("device_change_ip_web_details")
                return .dictionary(d)
            case .deviceDeleteOnUnlinkFailDetails(let arg):
                var d = try Serialization.getFields(TeamLog.DeviceDeleteOnUnlinkFailDetailsSerializer().serialize(arg))
                d[".tag"] = .str("device_delete_on_unlink_fail_details")
                return .dictionary(d)
            case .deviceDeleteOnUnlinkSuccessDetails(let arg):
                var d = try Serialization.getFields(TeamLog.DeviceDeleteOnUnlinkSuccessDetailsSerializer().serialize(arg))
                d[".tag"] = .str("device_delete_on_unlink_success_details")
                return .dictionary(d)
            case .deviceLinkFailDetails(let arg):
                var d = try Serialization.getFields(TeamLog.DeviceLinkFailDetailsSerializer().serialize(arg))
                d[".tag"] = .str("device_link_fail_details")
                return .dictionary(d)
            case .deviceLinkSuccessDetails(let arg):
                var d = try Serialization.getFields(TeamLog.DeviceLinkSuccessDetailsSerializer().serialize(arg))
                d[".tag"] = .str("device_link_success_details")
                return .dictionary(d)
            case .deviceManagementDisabledDetails(let arg):
                var d = try Serialization.getFields(TeamLog.DeviceManagementDisabledDetailsSerializer().serialize(arg))
                d[".tag"] = .str("device_management_disabled_details")
                return .dictionary(d)
            case .deviceManagementEnabledDetails(let arg):
                var d = try Serialization.getFields(TeamLog.DeviceManagementEnabledDetailsSerializer().serialize(arg))
                d[".tag"] = .str("device_management_enabled_details")
                return .dictionary(d)
            case .deviceSyncBackupStatusChangedDetails(let arg):
                var d = try Serialization.getFields(TeamLog.DeviceSyncBackupStatusChangedDetailsSerializer().serialize(arg))
                d[".tag"] = .str("device_sync_backup_status_changed_details")
                return .dictionary(d)
            case .deviceUnlinkDetails(let arg):
                var d = try Serialization.getFields(TeamLog.DeviceUnlinkDetailsSerializer().serialize(arg))
                d[".tag"] = .str("device_unlink_details")
                return .dictionary(d)
            case .dropboxPasswordsExportedDetails(let arg):
                var d = try Serialization.getFields(TeamLog.DropboxPasswordsExportedDetailsSerializer().serialize(arg))
                d[".tag"] = .str("dropbox_passwords_exported_details")
                return .dictionary(d)
            case .dropboxPasswordsNewDeviceEnrolledDetails(let arg):
                var d = try Serialization.getFields(TeamLog.DropboxPasswordsNewDeviceEnrolledDetailsSerializer().serialize(arg))
                d[".tag"] = .str("dropbox_passwords_new_device_enrolled_details")
                return .dictionary(d)
            case .emmRefreshAuthTokenDetails(let arg):
                var d = try Serialization.getFields(TeamLog.EmmRefreshAuthTokenDetailsSerializer().serialize(arg))
                d[".tag"] = .str("emm_refresh_auth_token_details")
                return .dictionary(d)
            case .externalDriveBackupEligibilityStatusCheckedDetails(let arg):
                var d = try Serialization.getFields(TeamLog.ExternalDriveBackupEligibilityStatusCheckedDetailsSerializer().serialize(arg))
                d[".tag"] = .str("external_drive_backup_eligibility_status_checked_details")
                return .dictionary(d)
            case .externalDriveBackupStatusChangedDetails(let arg):
                var d = try Serialization.getFields(TeamLog.ExternalDriveBackupStatusChangedDetailsSerializer().serialize(arg))
                d[".tag"] = .str("external_drive_backup_status_changed_details")
                return .dictionary(d)
            case .accountCaptureChangeAvailabilityDetails(let arg):
                var d = try Serialization.getFields(TeamLog.AccountCaptureChangeAvailabilityDetailsSerializer().serialize(arg))
                d[".tag"] = .str("account_capture_change_availability_details")
                return .dictionary(d)
            case .accountCaptureMigrateAccountDetails(let arg):
                var d = try Serialization.getFields(TeamLog.AccountCaptureMigrateAccountDetailsSerializer().serialize(arg))
                d[".tag"] = .str("account_capture_migrate_account_details")
                return .dictionary(d)
            case .accountCaptureNotificationEmailsSentDetails(let arg):
                var d = try Serialization.getFields(TeamLog.AccountCaptureNotificationEmailsSentDetailsSerializer().serialize(arg))
                d[".tag"] = .str("account_capture_notification_emails_sent_details")
                return .dictionary(d)
            case .accountCaptureRelinquishAccountDetails(let arg):
                var d = try Serialization.getFields(TeamLog.AccountCaptureRelinquishAccountDetailsSerializer().serialize(arg))
                d[".tag"] = .str("account_capture_relinquish_account_details")
                return .dictionary(d)
            case .disabledDomainInvitesDetails(let arg):
                var d = try Serialization.getFields(TeamLog.DisabledDomainInvitesDetailsSerializer().serialize(arg))
                d[".tag"] = .str("disabled_domain_invites_details")
                return .dictionary(d)
            case .domainInvitesApproveRequestToJoinTeamDetails(let arg):
                var d = try Serialization.getFields(TeamLog.DomainInvitesApproveRequestToJoinTeamDetailsSerializer().serialize(arg))
                d[".tag"] = .str("domain_invites_approve_request_to_join_team_details")
                return .dictionary(d)
            case .domainInvitesDeclineRequestToJoinTeamDetails(let arg):
                var d = try Serialization.getFields(TeamLog.DomainInvitesDeclineRequestToJoinTeamDetailsSerializer().serialize(arg))
                d[".tag"] = .str("domain_invites_decline_request_to_join_team_details")
                return .dictionary(d)
            case .domainInvitesEmailExistingUsersDetails(let arg):
                var d = try Serialization.getFields(TeamLog.DomainInvitesEmailExistingUsersDetailsSerializer().serialize(arg))
                d[".tag"] = .str("domain_invites_email_existing_users_details")
                return .dictionary(d)
            case .domainInvitesRequestToJoinTeamDetails(let arg):
                var d = try Serialization.getFields(TeamLog.DomainInvitesRequestToJoinTeamDetailsSerializer().serialize(arg))
                d[".tag"] = .str("domain_invites_request_to_join_team_details")
                return .dictionary(d)
            case .domainInvitesSetInviteNewUserPrefToNoDetails(let arg):
                var d = try Serialization.getFields(TeamLog.DomainInvitesSetInviteNewUserPrefToNoDetailsSerializer().serialize(arg))
                d[".tag"] = .str("domain_invites_set_invite_new_user_pref_to_no_details")
                return .dictionary(d)
            case .domainInvitesSetInviteNewUserPrefToYesDetails(let arg):
                var d = try Serialization.getFields(TeamLog.DomainInvitesSetInviteNewUserPrefToYesDetailsSerializer().serialize(arg))
                d[".tag"] = .str("domain_invites_set_invite_new_user_pref_to_yes_details")
                return .dictionary(d)
            case .domainVerificationAddDomainFailDetails(let arg):
                var d = try Serialization.getFields(TeamLog.DomainVerificationAddDomainFailDetailsSerializer().serialize(arg))
                d[".tag"] = .str("domain_verification_add_domain_fail_details")
                return .dictionary(d)
            case .domainVerificationAddDomainSuccessDetails(let arg):
                var d = try Serialization.getFields(TeamLog.DomainVerificationAddDomainSuccessDetailsSerializer().serialize(arg))
                d[".tag"] = .str("domain_verification_add_domain_success_details")
                return .dictionary(d)
            case .domainVerificationRemoveDomainDetails(let arg):
                var d = try Serialization.getFields(TeamLog.DomainVerificationRemoveDomainDetailsSerializer().serialize(arg))
                d[".tag"] = .str("domain_verification_remove_domain_details")
                return .dictionary(d)
            case .enabledDomainInvitesDetails(let arg):
                var d = try Serialization.getFields(TeamLog.EnabledDomainInvitesDetailsSerializer().serialize(arg))
                d[".tag"] = .str("enabled_domain_invites_details")
                return .dictionary(d)
            case .teamEncryptionKeyCancelKeyDeletionDetails(let arg):
                var d = try Serialization.getFields(TeamLog.TeamEncryptionKeyCancelKeyDeletionDetailsSerializer().serialize(arg))
                d[".tag"] = .str("team_encryption_key_cancel_key_deletion_details")
                return .dictionary(d)
            case .teamEncryptionKeyCreateKeyDetails(let arg):
                var d = try Serialization.getFields(TeamLog.TeamEncryptionKeyCreateKeyDetailsSerializer().serialize(arg))
                d[".tag"] = .str("team_encryption_key_create_key_details")
                return .dictionary(d)
            case .teamEncryptionKeyDeleteKeyDetails(let arg):
                var d = try Serialization.getFields(TeamLog.TeamEncryptionKeyDeleteKeyDetailsSerializer().serialize(arg))
                d[".tag"] = .str("team_encryption_key_delete_key_details")
                return .dictionary(d)
            case .teamEncryptionKeyDisableKeyDetails(let arg):
                var d = try Serialization.getFields(TeamLog.TeamEncryptionKeyDisableKeyDetailsSerializer().serialize(arg))
                d[".tag"] = .str("team_encryption_key_disable_key_details")
                return .dictionary(d)
            case .teamEncryptionKeyEnableKeyDetails(let arg):
                var d = try Serialization.getFields(TeamLog.TeamEncryptionKeyEnableKeyDetailsSerializer().serialize(arg))
                d[".tag"] = .str("team_encryption_key_enable_key_details")
                return .dictionary(d)
            case .teamEncryptionKeyRotateKeyDetails(let arg):
                var d = try Serialization.getFields(TeamLog.TeamEncryptionKeyRotateKeyDetailsSerializer().serialize(arg))
                d[".tag"] = .str("team_encryption_key_rotate_key_details")
                return .dictionary(d)
            case .teamEncryptionKeyScheduleKeyDeletionDetails(let arg):
                var d = try Serialization.getFields(TeamLog.TeamEncryptionKeyScheduleKeyDeletionDetailsSerializer().serialize(arg))
                d[".tag"] = .str("team_encryption_key_schedule_key_deletion_details")
                return .dictionary(d)
            case .applyNamingConventionDetails(let arg):
                var d = try Serialization.getFields(TeamLog.ApplyNamingConventionDetailsSerializer().serialize(arg))
                d[".tag"] = .str("apply_naming_convention_details")
                return .dictionary(d)
            case .createFolderDetails(let arg):
                var d = try Serialization.getFields(TeamLog.CreateFolderDetailsSerializer().serialize(arg))
                d[".tag"] = .str("create_folder_details")
                return .dictionary(d)
            case .fileAddDetails(let arg):
                var d = try Serialization.getFields(TeamLog.FileAddDetailsSerializer().serialize(arg))
                d[".tag"] = .str("file_add_details")
                return .dictionary(d)
            case .fileAddFromAutomationDetails(let arg):
                var d = try Serialization.getFields(TeamLog.FileAddFromAutomationDetailsSerializer().serialize(arg))
                d[".tag"] = .str("file_add_from_automation_details")
                return .dictionary(d)
            case .fileCopyDetails(let arg):
                var d = try Serialization.getFields(TeamLog.FileCopyDetailsSerializer().serialize(arg))
                d[".tag"] = .str("file_copy_details")
                return .dictionary(d)
            case .fileDeleteDetails(let arg):
                var d = try Serialization.getFields(TeamLog.FileDeleteDetailsSerializer().serialize(arg))
                d[".tag"] = .str("file_delete_details")
                return .dictionary(d)
            case .fileDownloadDetails(let arg):
                var d = try Serialization.getFields(TeamLog.FileDownloadDetailsSerializer().serialize(arg))
                d[".tag"] = .str("file_download_details")
                return .dictionary(d)
            case .fileEditDetails(let arg):
                var d = try Serialization.getFields(TeamLog.FileEditDetailsSerializer().serialize(arg))
                d[".tag"] = .str("file_edit_details")
                return .dictionary(d)
            case .fileGetCopyReferenceDetails(let arg):
                var d = try Serialization.getFields(TeamLog.FileGetCopyReferenceDetailsSerializer().serialize(arg))
                d[".tag"] = .str("file_get_copy_reference_details")
                return .dictionary(d)
            case .fileLockingLockStatusChangedDetails(let arg):
                var d = try Serialization.getFields(TeamLog.FileLockingLockStatusChangedDetailsSerializer().serialize(arg))
                d[".tag"] = .str("file_locking_lock_status_changed_details")
                return .dictionary(d)
            case .fileMoveDetails(let arg):
                var d = try Serialization.getFields(TeamLog.FileMoveDetailsSerializer().serialize(arg))
                d[".tag"] = .str("file_move_details")
                return .dictionary(d)
            case .filePermanentlyDeleteDetails(let arg):
                var d = try Serialization.getFields(TeamLog.FilePermanentlyDeleteDetailsSerializer().serialize(arg))
                d[".tag"] = .str("file_permanently_delete_details")
                return .dictionary(d)
            case .filePreviewDetails(let arg):
                var d = try Serialization.getFields(TeamLog.FilePreviewDetailsSerializer().serialize(arg))
                d[".tag"] = .str("file_preview_details")
                return .dictionary(d)
            case .fileRenameDetails(let arg):
                var d = try Serialization.getFields(TeamLog.FileRenameDetailsSerializer().serialize(arg))
                d[".tag"] = .str("file_rename_details")
                return .dictionary(d)
            case .fileRestoreDetails(let arg):
                var d = try Serialization.getFields(TeamLog.FileRestoreDetailsSerializer().serialize(arg))
                d[".tag"] = .str("file_restore_details")
                return .dictionary(d)
            case .fileRevertDetails(let arg):
                var d = try Serialization.getFields(TeamLog.FileRevertDetailsSerializer().serialize(arg))
                d[".tag"] = .str("file_revert_details")
                return .dictionary(d)
            case .fileRollbackChangesDetails(let arg):
                var d = try Serialization.getFields(TeamLog.FileRollbackChangesDetailsSerializer().serialize(arg))
                d[".tag"] = .str("file_rollback_changes_details")
                return .dictionary(d)
            case .fileSaveCopyReferenceDetails(let arg):
                var d = try Serialization.getFields(TeamLog.FileSaveCopyReferenceDetailsSerializer().serialize(arg))
                d[".tag"] = .str("file_save_copy_reference_details")
                return .dictionary(d)
            case .folderOverviewDescriptionChangedDetails(let arg):
                var d = try Serialization.getFields(TeamLog.FolderOverviewDescriptionChangedDetailsSerializer().serialize(arg))
                d[".tag"] = .str("folder_overview_description_changed_details")
                return .dictionary(d)
            case .folderOverviewItemPinnedDetails(let arg):
                var d = try Serialization.getFields(TeamLog.FolderOverviewItemPinnedDetailsSerializer().serialize(arg))
                d[".tag"] = .str("folder_overview_item_pinned_details")
                return .dictionary(d)
            case .folderOverviewItemUnpinnedDetails(let arg):
                var d = try Serialization.getFields(TeamLog.FolderOverviewItemUnpinnedDetailsSerializer().serialize(arg))
                d[".tag"] = .str("folder_overview_item_unpinned_details")
                return .dictionary(d)
            case .objectLabelAddedDetails(let arg):
                var d = try Serialization.getFields(TeamLog.ObjectLabelAddedDetailsSerializer().serialize(arg))
                d[".tag"] = .str("object_label_added_details")
                return .dictionary(d)
            case .objectLabelRemovedDetails(let arg):
                var d = try Serialization.getFields(TeamLog.ObjectLabelRemovedDetailsSerializer().serialize(arg))
                d[".tag"] = .str("object_label_removed_details")
                return .dictionary(d)
            case .objectLabelUpdatedValueDetails(let arg):
                var d = try Serialization.getFields(TeamLog.ObjectLabelUpdatedValueDetailsSerializer().serialize(arg))
                d[".tag"] = .str("object_label_updated_value_details")
                return .dictionary(d)
            case .organizeFolderWithTidyDetails(let arg):
                var d = try Serialization.getFields(TeamLog.OrganizeFolderWithTidyDetailsSerializer().serialize(arg))
                d[".tag"] = .str("organize_folder_with_tidy_details")
                return .dictionary(d)
            case .replayFileDeleteDetails(let arg):
                var d = try Serialization.getFields(TeamLog.ReplayFileDeleteDetailsSerializer().serialize(arg))
                d[".tag"] = .str("replay_file_delete_details")
                return .dictionary(d)
            case .rewindFolderDetails(let arg):
                var d = try Serialization.getFields(TeamLog.RewindFolderDetailsSerializer().serialize(arg))
                d[".tag"] = .str("rewind_folder_details")
                return .dictionary(d)
            case .undoNamingConventionDetails(let arg):
                var d = try Serialization.getFields(TeamLog.UndoNamingConventionDetailsSerializer().serialize(arg))
                d[".tag"] = .str("undo_naming_convention_details")
                return .dictionary(d)
            case .undoOrganizeFolderWithTidyDetails(let arg):
                var d = try Serialization.getFields(TeamLog.UndoOrganizeFolderWithTidyDetailsSerializer().serialize(arg))
                d[".tag"] = .str("undo_organize_folder_with_tidy_details")
                return .dictionary(d)
            case .userTagsAddedDetails(let arg):
                var d = try Serialization.getFields(TeamLog.UserTagsAddedDetailsSerializer().serialize(arg))
                d[".tag"] = .str("user_tags_added_details")
                return .dictionary(d)
            case .userTagsRemovedDetails(let arg):
                var d = try Serialization.getFields(TeamLog.UserTagsRemovedDetailsSerializer().serialize(arg))
                d[".tag"] = .str("user_tags_removed_details")
                return .dictionary(d)
            case .emailIngestReceiveFileDetails(let arg):
                var d = try Serialization.getFields(TeamLog.EmailIngestReceiveFileDetailsSerializer().serialize(arg))
                d[".tag"] = .str("email_ingest_receive_file_details")
                return .dictionary(d)
            case .fileRequestChangeDetails(let arg):
                var d = try Serialization.getFields(TeamLog.FileRequestChangeDetailsSerializer().serialize(arg))
                d[".tag"] = .str("file_request_change_details")
                return .dictionary(d)
            case .fileRequestCloseDetails(let arg):
                var d = try Serialization.getFields(TeamLog.FileRequestCloseDetailsSerializer().serialize(arg))
                d[".tag"] = .str("file_request_close_details")
                return .dictionary(d)
            case .fileRequestCreateDetails(let arg):
                var d = try Serialization.getFields(TeamLog.FileRequestCreateDetailsSerializer().serialize(arg))
                d[".tag"] = .str("file_request_create_details")
                return .dictionary(d)
            case .fileRequestDeleteDetails(let arg):
                var d = try Serialization.getFields(TeamLog.FileRequestDeleteDetailsSerializer().serialize(arg))
                d[".tag"] = .str("file_request_delete_details")
                return .dictionary(d)
            case .fileRequestReceiveFileDetails(let arg):
                var d = try Serialization.getFields(TeamLog.FileRequestReceiveFileDetailsSerializer().serialize(arg))
                d[".tag"] = .str("file_request_receive_file_details")
                return .dictionary(d)
            case .groupAddExternalIdDetails(let arg):
                var d = try Serialization.getFields(TeamLog.GroupAddExternalIdDetailsSerializer().serialize(arg))
                d[".tag"] = .str("group_add_external_id_details")
                return .dictionary(d)
            case .groupAddMemberDetails(let arg):
                var d = try Serialization.getFields(TeamLog.GroupAddMemberDetailsSerializer().serialize(arg))
                d[".tag"] = .str("group_add_member_details")
                return .dictionary(d)
            case .groupChangeExternalIdDetails(let arg):
                var d = try Serialization.getFields(TeamLog.GroupChangeExternalIdDetailsSerializer().serialize(arg))
                d[".tag"] = .str("group_change_external_id_details")
                return .dictionary(d)
            case .groupChangeManagementTypeDetails(let arg):
                var d = try Serialization.getFields(TeamLog.GroupChangeManagementTypeDetailsSerializer().serialize(arg))
                d[".tag"] = .str("group_change_management_type_details")
                return .dictionary(d)
            case .groupChangeMemberRoleDetails(let arg):
                var d = try Serialization.getFields(TeamLog.GroupChangeMemberRoleDetailsSerializer().serialize(arg))
                d[".tag"] = .str("group_change_member_role_details")
                return .dictionary(d)
            case .groupCreateDetails(let arg):
                var d = try Serialization.getFields(TeamLog.GroupCreateDetailsSerializer().serialize(arg))
                d[".tag"] = .str("group_create_details")
                return .dictionary(d)
            case .groupDeleteDetails(let arg):
                var d = try Serialization.getFields(TeamLog.GroupDeleteDetailsSerializer().serialize(arg))
                d[".tag"] = .str("group_delete_details")
                return .dictionary(d)
            case .groupDescriptionUpdatedDetails(let arg):
                var d = try Serialization.getFields(TeamLog.GroupDescriptionUpdatedDetailsSerializer().serialize(arg))
                d[".tag"] = .str("group_description_updated_details")
                return .dictionary(d)
            case .groupJoinPolicyUpdatedDetails(let arg):
                var d = try Serialization.getFields(TeamLog.GroupJoinPolicyUpdatedDetailsSerializer().serialize(arg))
                d[".tag"] = .str("group_join_policy_updated_details")
                return .dictionary(d)
            case .groupMovedDetails(let arg):
                var d = try Serialization.getFields(TeamLog.GroupMovedDetailsSerializer().serialize(arg))
                d[".tag"] = .str("group_moved_details")
                return .dictionary(d)
            case .groupRemoveExternalIdDetails(let arg):
                var d = try Serialization.getFields(TeamLog.GroupRemoveExternalIdDetailsSerializer().serialize(arg))
                d[".tag"] = .str("group_remove_external_id_details")
                return .dictionary(d)
            case .groupRemoveMemberDetails(let arg):
                var d = try Serialization.getFields(TeamLog.GroupRemoveMemberDetailsSerializer().serialize(arg))
                d[".tag"] = .str("group_remove_member_details")
                return .dictionary(d)
            case .groupRenameDetails(let arg):
                var d = try Serialization.getFields(TeamLog.GroupRenameDetailsSerializer().serialize(arg))
                d[".tag"] = .str("group_rename_details")
                return .dictionary(d)
            case .accountLockOrUnlockedDetails(let arg):
                var d = try Serialization.getFields(TeamLog.AccountLockOrUnlockedDetailsSerializer().serialize(arg))
                d[".tag"] = .str("account_lock_or_unlocked_details")
                return .dictionary(d)
            case .emmErrorDetails(let arg):
                var d = try Serialization.getFields(TeamLog.EmmErrorDetailsSerializer().serialize(arg))
                d[".tag"] = .str("emm_error_details")
                return .dictionary(d)
            case .guestAdminSignedInViaTrustedTeamsDetails(let arg):
                var d = try Serialization.getFields(TeamLog.GuestAdminSignedInViaTrustedTeamsDetailsSerializer().serialize(arg))
                d[".tag"] = .str("guest_admin_signed_in_via_trusted_teams_details")
                return .dictionary(d)
            case .guestAdminSignedOutViaTrustedTeamsDetails(let arg):
                var d = try Serialization.getFields(TeamLog.GuestAdminSignedOutViaTrustedTeamsDetailsSerializer().serialize(arg))
                d[".tag"] = .str("guest_admin_signed_out_via_trusted_teams_details")
                return .dictionary(d)
            case .loginFailDetails(let arg):
                var d = try Serialization.getFields(TeamLog.LoginFailDetailsSerializer().serialize(arg))
                d[".tag"] = .str("login_fail_details")
                return .dictionary(d)
            case .loginSuccessDetails(let arg):
                var d = try Serialization.getFields(TeamLog.LoginSuccessDetailsSerializer().serialize(arg))
                d[".tag"] = .str("login_success_details")
                return .dictionary(d)
            case .logoutDetails(let arg):
                var d = try Serialization.getFields(TeamLog.LogoutDetailsSerializer().serialize(arg))
                d[".tag"] = .str("logout_details")
                return .dictionary(d)
            case .resellerSupportSessionEndDetails(let arg):
                var d = try Serialization.getFields(TeamLog.ResellerSupportSessionEndDetailsSerializer().serialize(arg))
                d[".tag"] = .str("reseller_support_session_end_details")
                return .dictionary(d)
            case .resellerSupportSessionStartDetails(let arg):
                var d = try Serialization.getFields(TeamLog.ResellerSupportSessionStartDetailsSerializer().serialize(arg))
                d[".tag"] = .str("reseller_support_session_start_details")
                return .dictionary(d)
            case .signInAsSessionEndDetails(let arg):
                var d = try Serialization.getFields(TeamLog.SignInAsSessionEndDetailsSerializer().serialize(arg))
                d[".tag"] = .str("sign_in_as_session_end_details")
                return .dictionary(d)
            case .signInAsSessionStartDetails(let arg):
                var d = try Serialization.getFields(TeamLog.SignInAsSessionStartDetailsSerializer().serialize(arg))
                d[".tag"] = .str("sign_in_as_session_start_details")
                return .dictionary(d)
            case .ssoErrorDetails(let arg):
                var d = try Serialization.getFields(TeamLog.SsoErrorDetailsSerializer().serialize(arg))
                d[".tag"] = .str("sso_error_details")
                return .dictionary(d)
            case .backupAdminInvitationSentDetails(let arg):
                var d = try Serialization.getFields(TeamLog.BackupAdminInvitationSentDetailsSerializer().serialize(arg))
                d[".tag"] = .str("backup_admin_invitation_sent_details")
                return .dictionary(d)
            case .backupInvitationOpenedDetails(let arg):
                var d = try Serialization.getFields(TeamLog.BackupInvitationOpenedDetailsSerializer().serialize(arg))
                d[".tag"] = .str("backup_invitation_opened_details")
                return .dictionary(d)
            case .createTeamInviteLinkDetails(let arg):
                var d = try Serialization.getFields(TeamLog.CreateTeamInviteLinkDetailsSerializer().serialize(arg))
                d[".tag"] = .str("create_team_invite_link_details")
                return .dictionary(d)
            case .deleteTeamInviteLinkDetails(let arg):
                var d = try Serialization.getFields(TeamLog.DeleteTeamInviteLinkDetailsSerializer().serialize(arg))
                d[".tag"] = .str("delete_team_invite_link_details")
                return .dictionary(d)
            case .memberAddExternalIdDetails(let arg):
                var d = try Serialization.getFields(TeamLog.MemberAddExternalIdDetailsSerializer().serialize(arg))
                d[".tag"] = .str("member_add_external_id_details")
                return .dictionary(d)
            case .memberAddNameDetails(let arg):
                var d = try Serialization.getFields(TeamLog.MemberAddNameDetailsSerializer().serialize(arg))
                d[".tag"] = .str("member_add_name_details")
                return .dictionary(d)
            case .memberChangeAdminRoleDetails(let arg):
                var d = try Serialization.getFields(TeamLog.MemberChangeAdminRoleDetailsSerializer().serialize(arg))
                d[".tag"] = .str("member_change_admin_role_details")
                return .dictionary(d)
            case .memberChangeEmailDetails(let arg):
                var d = try Serialization.getFields(TeamLog.MemberChangeEmailDetailsSerializer().serialize(arg))
                d[".tag"] = .str("member_change_email_details")
                return .dictionary(d)
            case .memberChangeExternalIdDetails(let arg):
                var d = try Serialization.getFields(TeamLog.MemberChangeExternalIdDetailsSerializer().serialize(arg))
                d[".tag"] = .str("member_change_external_id_details")
                return .dictionary(d)
            case .memberChangeMembershipTypeDetails(let arg):
                var d = try Serialization.getFields(TeamLog.MemberChangeMembershipTypeDetailsSerializer().serialize(arg))
                d[".tag"] = .str("member_change_membership_type_details")
                return .dictionary(d)
            case .memberChangeNameDetails(let arg):
                var d = try Serialization.getFields(TeamLog.MemberChangeNameDetailsSerializer().serialize(arg))
                d[".tag"] = .str("member_change_name_details")
                return .dictionary(d)
            case .memberChangeResellerRoleDetails(let arg):
                var d = try Serialization.getFields(TeamLog.MemberChangeResellerRoleDetailsSerializer().serialize(arg))
                d[".tag"] = .str("member_change_reseller_role_details")
                return .dictionary(d)
            case .memberChangeStatusDetails(let arg):
                var d = try Serialization.getFields(TeamLog.MemberChangeStatusDetailsSerializer().serialize(arg))
                d[".tag"] = .str("member_change_status_details")
                return .dictionary(d)
            case .memberDeleteManualContactsDetails(let arg):
                var d = try Serialization.getFields(TeamLog.MemberDeleteManualContactsDetailsSerializer().serialize(arg))
                d[".tag"] = .str("member_delete_manual_contacts_details")
                return .dictionary(d)
            case .memberDeleteProfilePhotoDetails(let arg):
                var d = try Serialization.getFields(TeamLog.MemberDeleteProfilePhotoDetailsSerializer().serialize(arg))
                d[".tag"] = .str("member_delete_profile_photo_details")
                return .dictionary(d)
            case .memberPermanentlyDeleteAccountContentsDetails(let arg):
                var d = try Serialization.getFields(TeamLog.MemberPermanentlyDeleteAccountContentsDetailsSerializer().serialize(arg))
                d[".tag"] = .str("member_permanently_delete_account_contents_details")
                return .dictionary(d)
            case .memberRemoveExternalIdDetails(let arg):
                var d = try Serialization.getFields(TeamLog.MemberRemoveExternalIdDetailsSerializer().serialize(arg))
                d[".tag"] = .str("member_remove_external_id_details")
                return .dictionary(d)
            case .memberSetProfilePhotoDetails(let arg):
                var d = try Serialization.getFields(TeamLog.MemberSetProfilePhotoDetailsSerializer().serialize(arg))
                d[".tag"] = .str("member_set_profile_photo_details")
                return .dictionary(d)
            case .memberSpaceLimitsAddCustomQuotaDetails(let arg):
                var d = try Serialization.getFields(TeamLog.MemberSpaceLimitsAddCustomQuotaDetailsSerializer().serialize(arg))
                d[".tag"] = .str("member_space_limits_add_custom_quota_details")
                return .dictionary(d)
            case .memberSpaceLimitsChangeCustomQuotaDetails(let arg):
                var d = try Serialization.getFields(TeamLog.MemberSpaceLimitsChangeCustomQuotaDetailsSerializer().serialize(arg))
                d[".tag"] = .str("member_space_limits_change_custom_quota_details")
                return .dictionary(d)
            case .memberSpaceLimitsChangeStatusDetails(let arg):
                var d = try Serialization.getFields(TeamLog.MemberSpaceLimitsChangeStatusDetailsSerializer().serialize(arg))
                d[".tag"] = .str("member_space_limits_change_status_details")
                return .dictionary(d)
            case .memberSpaceLimitsRemoveCustomQuotaDetails(let arg):
                var d = try Serialization.getFields(TeamLog.MemberSpaceLimitsRemoveCustomQuotaDetailsSerializer().serialize(arg))
                d[".tag"] = .str("member_space_limits_remove_custom_quota_details")
                return .dictionary(d)
            case .memberSuggestDetails(let arg):
                var d = try Serialization.getFields(TeamLog.MemberSuggestDetailsSerializer().serialize(arg))
                d[".tag"] = .str("member_suggest_details")
                return .dictionary(d)
            case .memberTransferAccountContentsDetails(let arg):
                var d = try Serialization.getFields(TeamLog.MemberTransferAccountContentsDetailsSerializer().serialize(arg))
                d[".tag"] = .str("member_transfer_account_contents_details")
                return .dictionary(d)
            case .pendingSecondaryEmailAddedDetails(let arg):
                var d = try Serialization.getFields(TeamLog.PendingSecondaryEmailAddedDetailsSerializer().serialize(arg))
                d[".tag"] = .str("pending_secondary_email_added_details")
                return .dictionary(d)
            case .secondaryEmailDeletedDetails(let arg):
                var d = try Serialization.getFields(TeamLog.SecondaryEmailDeletedDetailsSerializer().serialize(arg))
                d[".tag"] = .str("secondary_email_deleted_details")
                return .dictionary(d)
            case .secondaryEmailVerifiedDetails(let arg):
                var d = try Serialization.getFields(TeamLog.SecondaryEmailVerifiedDetailsSerializer().serialize(arg))
                d[".tag"] = .str("secondary_email_verified_details")
                return .dictionary(d)
            case .secondaryMailsPolicyChangedDetails(let arg):
                var d = try Serialization.getFields(TeamLog.SecondaryMailsPolicyChangedDetailsSerializer().serialize(arg))
                d[".tag"] = .str("secondary_mails_policy_changed_details")
                return .dictionary(d)
            case .binderAddPageDetails(let arg):
                var d = try Serialization.getFields(TeamLog.BinderAddPageDetailsSerializer().serialize(arg))
                d[".tag"] = .str("binder_add_page_details")
                return .dictionary(d)
            case .binderAddSectionDetails(let arg):
                var d = try Serialization.getFields(TeamLog.BinderAddSectionDetailsSerializer().serialize(arg))
                d[".tag"] = .str("binder_add_section_details")
                return .dictionary(d)
            case .binderRemovePageDetails(let arg):
                var d = try Serialization.getFields(TeamLog.BinderRemovePageDetailsSerializer().serialize(arg))
                d[".tag"] = .str("binder_remove_page_details")
                return .dictionary(d)
            case .binderRemoveSectionDetails(let arg):
                var d = try Serialization.getFields(TeamLog.BinderRemoveSectionDetailsSerializer().serialize(arg))
                d[".tag"] = .str("binder_remove_section_details")
                return .dictionary(d)
            case .binderRenamePageDetails(let arg):
                var d = try Serialization.getFields(TeamLog.BinderRenamePageDetailsSerializer().serialize(arg))
                d[".tag"] = .str("binder_rename_page_details")
                return .dictionary(d)
            case .binderRenameSectionDetails(let arg):
                var d = try Serialization.getFields(TeamLog.BinderRenameSectionDetailsSerializer().serialize(arg))
                d[".tag"] = .str("binder_rename_section_details")
                return .dictionary(d)
            case .binderReorderPageDetails(let arg):
                var d = try Serialization.getFields(TeamLog.BinderReorderPageDetailsSerializer().serialize(arg))
                d[".tag"] = .str("binder_reorder_page_details")
                return .dictionary(d)
            case .binderReorderSectionDetails(let arg):
                var d = try Serialization.getFields(TeamLog.BinderReorderSectionDetailsSerializer().serialize(arg))
                d[".tag"] = .str("binder_reorder_section_details")
                return .dictionary(d)
            case .paperContentAddMemberDetails(let arg):
                var d = try Serialization.getFields(TeamLog.PaperContentAddMemberDetailsSerializer().serialize(arg))
                d[".tag"] = .str("paper_content_add_member_details")
                return .dictionary(d)
            case .paperContentAddToFolderDetails(let arg):
                var d = try Serialization.getFields(TeamLog.PaperContentAddToFolderDetailsSerializer().serialize(arg))
                d[".tag"] = .str("paper_content_add_to_folder_details")
                return .dictionary(d)
            case .paperContentArchiveDetails(let arg):
                var d = try Serialization.getFields(TeamLog.PaperContentArchiveDetailsSerializer().serialize(arg))
                d[".tag"] = .str("paper_content_archive_details")
                return .dictionary(d)
            case .paperContentCreateDetails(let arg):
                var d = try Serialization.getFields(TeamLog.PaperContentCreateDetailsSerializer().serialize(arg))
                d[".tag"] = .str("paper_content_create_details")
                return .dictionary(d)
            case .paperContentPermanentlyDeleteDetails(let arg):
                var d = try Serialization.getFields(TeamLog.PaperContentPermanentlyDeleteDetailsSerializer().serialize(arg))
                d[".tag"] = .str("paper_content_permanently_delete_details")
                return .dictionary(d)
            case .paperContentRemoveFromFolderDetails(let arg):
                var d = try Serialization.getFields(TeamLog.PaperContentRemoveFromFolderDetailsSerializer().serialize(arg))
                d[".tag"] = .str("paper_content_remove_from_folder_details")
                return .dictionary(d)
            case .paperContentRemoveMemberDetails(let arg):
                var d = try Serialization.getFields(TeamLog.PaperContentRemoveMemberDetailsSerializer().serialize(arg))
                d[".tag"] = .str("paper_content_remove_member_details")
                return .dictionary(d)
            case .paperContentRenameDetails(let arg):
                var d = try Serialization.getFields(TeamLog.PaperContentRenameDetailsSerializer().serialize(arg))
                d[".tag"] = .str("paper_content_rename_details")
                return .dictionary(d)
            case .paperContentRestoreDetails(let arg):
                var d = try Serialization.getFields(TeamLog.PaperContentRestoreDetailsSerializer().serialize(arg))
                d[".tag"] = .str("paper_content_restore_details")
                return .dictionary(d)
            case .paperDocAddCommentDetails(let arg):
                var d = try Serialization.getFields(TeamLog.PaperDocAddCommentDetailsSerializer().serialize(arg))
                d[".tag"] = .str("paper_doc_add_comment_details")
                return .dictionary(d)
            case .paperDocChangeMemberRoleDetails(let arg):
                var d = try Serialization.getFields(TeamLog.PaperDocChangeMemberRoleDetailsSerializer().serialize(arg))
                d[".tag"] = .str("paper_doc_change_member_role_details")
                return .dictionary(d)
            case .paperDocChangeSharingPolicyDetails(let arg):
                var d = try Serialization.getFields(TeamLog.PaperDocChangeSharingPolicyDetailsSerializer().serialize(arg))
                d[".tag"] = .str("paper_doc_change_sharing_policy_details")
                return .dictionary(d)
            case .paperDocChangeSubscriptionDetails(let arg):
                var d = try Serialization.getFields(TeamLog.PaperDocChangeSubscriptionDetailsSerializer().serialize(arg))
                d[".tag"] = .str("paper_doc_change_subscription_details")
                return .dictionary(d)
            case .paperDocDeletedDetails(let arg):
                var d = try Serialization.getFields(TeamLog.PaperDocDeletedDetailsSerializer().serialize(arg))
                d[".tag"] = .str("paper_doc_deleted_details")
                return .dictionary(d)
            case .paperDocDeleteCommentDetails(let arg):
                var d = try Serialization.getFields(TeamLog.PaperDocDeleteCommentDetailsSerializer().serialize(arg))
                d[".tag"] = .str("paper_doc_delete_comment_details")
                return .dictionary(d)
            case .paperDocDownloadDetails(let arg):
                var d = try Serialization.getFields(TeamLog.PaperDocDownloadDetailsSerializer().serialize(arg))
                d[".tag"] = .str("paper_doc_download_details")
                return .dictionary(d)
            case .paperDocEditDetails(let arg):
                var d = try Serialization.getFields(TeamLog.PaperDocEditDetailsSerializer().serialize(arg))
                d[".tag"] = .str("paper_doc_edit_details")
                return .dictionary(d)
            case .paperDocEditCommentDetails(let arg):
                var d = try Serialization.getFields(TeamLog.PaperDocEditCommentDetailsSerializer().serialize(arg))
                d[".tag"] = .str("paper_doc_edit_comment_details")
                return .dictionary(d)
            case .paperDocFollowedDetails(let arg):
                var d = try Serialization.getFields(TeamLog.PaperDocFollowedDetailsSerializer().serialize(arg))
                d[".tag"] = .str("paper_doc_followed_details")
                return .dictionary(d)
            case .paperDocMentionDetails(let arg):
                var d = try Serialization.getFields(TeamLog.PaperDocMentionDetailsSerializer().serialize(arg))
                d[".tag"] = .str("paper_doc_mention_details")
                return .dictionary(d)
            case .paperDocOwnershipChangedDetails(let arg):
                var d = try Serialization.getFields(TeamLog.PaperDocOwnershipChangedDetailsSerializer().serialize(arg))
                d[".tag"] = .str("paper_doc_ownership_changed_details")
                return .dictionary(d)
            case .paperDocRequestAccessDetails(let arg):
                var d = try Serialization.getFields(TeamLog.PaperDocRequestAccessDetailsSerializer().serialize(arg))
                d[".tag"] = .str("paper_doc_request_access_details")
                return .dictionary(d)
            case .paperDocResolveCommentDetails(let arg):
                var d = try Serialization.getFields(TeamLog.PaperDocResolveCommentDetailsSerializer().serialize(arg))
                d[".tag"] = .str("paper_doc_resolve_comment_details")
                return .dictionary(d)
            case .paperDocRevertDetails(let arg):
                var d = try Serialization.getFields(TeamLog.PaperDocRevertDetailsSerializer().serialize(arg))
                d[".tag"] = .str("paper_doc_revert_details")
                return .dictionary(d)
            case .paperDocSlackShareDetails(let arg):
                var d = try Serialization.getFields(TeamLog.PaperDocSlackShareDetailsSerializer().serialize(arg))
                d[".tag"] = .str("paper_doc_slack_share_details")
                return .dictionary(d)
            case .paperDocTeamInviteDetails(let arg):
                var d = try Serialization.getFields(TeamLog.PaperDocTeamInviteDetailsSerializer().serialize(arg))
                d[".tag"] = .str("paper_doc_team_invite_details")
                return .dictionary(d)
            case .paperDocTrashedDetails(let arg):
                var d = try Serialization.getFields(TeamLog.PaperDocTrashedDetailsSerializer().serialize(arg))
                d[".tag"] = .str("paper_doc_trashed_details")
                return .dictionary(d)
            case .paperDocUnresolveCommentDetails(let arg):
                var d = try Serialization.getFields(TeamLog.PaperDocUnresolveCommentDetailsSerializer().serialize(arg))
                d[".tag"] = .str("paper_doc_unresolve_comment_details")
                return .dictionary(d)
            case .paperDocUntrashedDetails(let arg):
                var d = try Serialization.getFields(TeamLog.PaperDocUntrashedDetailsSerializer().serialize(arg))
                d[".tag"] = .str("paper_doc_untrashed_details")
                return .dictionary(d)
            case .paperDocViewDetails(let arg):
                var d = try Serialization.getFields(TeamLog.PaperDocViewDetailsSerializer().serialize(arg))
                d[".tag"] = .str("paper_doc_view_details")
                return .dictionary(d)
            case .paperExternalViewAllowDetails(let arg):
                var d = try Serialization.getFields(TeamLog.PaperExternalViewAllowDetailsSerializer().serialize(arg))
                d[".tag"] = .str("paper_external_view_allow_details")
                return .dictionary(d)
            case .paperExternalViewDefaultTeamDetails(let arg):
                var d = try Serialization.getFields(TeamLog.PaperExternalViewDefaultTeamDetailsSerializer().serialize(arg))
                d[".tag"] = .str("paper_external_view_default_team_details")
                return .dictionary(d)
            case .paperExternalViewForbidDetails(let arg):
                var d = try Serialization.getFields(TeamLog.PaperExternalViewForbidDetailsSerializer().serialize(arg))
                d[".tag"] = .str("paper_external_view_forbid_details")
                return .dictionary(d)
            case .paperFolderChangeSubscriptionDetails(let arg):
                var d = try Serialization.getFields(TeamLog.PaperFolderChangeSubscriptionDetailsSerializer().serialize(arg))
                d[".tag"] = .str("paper_folder_change_subscription_details")
                return .dictionary(d)
            case .paperFolderDeletedDetails(let arg):
                var d = try Serialization.getFields(TeamLog.PaperFolderDeletedDetailsSerializer().serialize(arg))
                d[".tag"] = .str("paper_folder_deleted_details")
                return .dictionary(d)
            case .paperFolderFollowedDetails(let arg):
                var d = try Serialization.getFields(TeamLog.PaperFolderFollowedDetailsSerializer().serialize(arg))
                d[".tag"] = .str("paper_folder_followed_details")
                return .dictionary(d)
            case .paperFolderTeamInviteDetails(let arg):
                var d = try Serialization.getFields(TeamLog.PaperFolderTeamInviteDetailsSerializer().serialize(arg))
                d[".tag"] = .str("paper_folder_team_invite_details")
                return .dictionary(d)
            case .paperPublishedLinkChangePermissionDetails(let arg):
                var d = try Serialization.getFields(TeamLog.PaperPublishedLinkChangePermissionDetailsSerializer().serialize(arg))
                d[".tag"] = .str("paper_published_link_change_permission_details")
                return .dictionary(d)
            case .paperPublishedLinkCreateDetails(let arg):
                var d = try Serialization.getFields(TeamLog.PaperPublishedLinkCreateDetailsSerializer().serialize(arg))
                d[".tag"] = .str("paper_published_link_create_details")
                return .dictionary(d)
            case .paperPublishedLinkDisabledDetails(let arg):
                var d = try Serialization.getFields(TeamLog.PaperPublishedLinkDisabledDetailsSerializer().serialize(arg))
                d[".tag"] = .str("paper_published_link_disabled_details")
                return .dictionary(d)
            case .paperPublishedLinkViewDetails(let arg):
                var d = try Serialization.getFields(TeamLog.PaperPublishedLinkViewDetailsSerializer().serialize(arg))
                d[".tag"] = .str("paper_published_link_view_details")
                return .dictionary(d)
            case .passwordChangeDetails(let arg):
                var d = try Serialization.getFields(TeamLog.PasswordChangeDetailsSerializer().serialize(arg))
                d[".tag"] = .str("password_change_details")
                return .dictionary(d)
            case .passwordResetDetails(let arg):
                var d = try Serialization.getFields(TeamLog.PasswordResetDetailsSerializer().serialize(arg))
                d[".tag"] = .str("password_reset_details")
                return .dictionary(d)
            case .passwordResetAllDetails(let arg):
                var d = try Serialization.getFields(TeamLog.PasswordResetAllDetailsSerializer().serialize(arg))
                d[".tag"] = .str("password_reset_all_details")
                return .dictionary(d)
            case .classificationCreateReportDetails(let arg):
                var d = try Serialization.getFields(TeamLog.ClassificationCreateReportDetailsSerializer().serialize(arg))
                d[".tag"] = .str("classification_create_report_details")
                return .dictionary(d)
            case .classificationCreateReportFailDetails(let arg):
                var d = try Serialization.getFields(TeamLog.ClassificationCreateReportFailDetailsSerializer().serialize(arg))
                d[".tag"] = .str("classification_create_report_fail_details")
                return .dictionary(d)
            case .emmCreateExceptionsReportDetails(let arg):
                var d = try Serialization.getFields(TeamLog.EmmCreateExceptionsReportDetailsSerializer().serialize(arg))
                d[".tag"] = .str("emm_create_exceptions_report_details")
                return .dictionary(d)
            case .emmCreateUsageReportDetails(let arg):
                var d = try Serialization.getFields(TeamLog.EmmCreateUsageReportDetailsSerializer().serialize(arg))
                d[".tag"] = .str("emm_create_usage_report_details")
                return .dictionary(d)
            case .exportMembersReportDetails(let arg):
                var d = try Serialization.getFields(TeamLog.ExportMembersReportDetailsSerializer().serialize(arg))
                d[".tag"] = .str("export_members_report_details")
                return .dictionary(d)
            case .exportMembersReportFailDetails(let arg):
                var d = try Serialization.getFields(TeamLog.ExportMembersReportFailDetailsSerializer().serialize(arg))
                d[".tag"] = .str("export_members_report_fail_details")
                return .dictionary(d)
            case .externalSharingCreateReportDetails(let arg):
                var d = try Serialization.getFields(TeamLog.ExternalSharingCreateReportDetailsSerializer().serialize(arg))
                d[".tag"] = .str("external_sharing_create_report_details")
                return .dictionary(d)
            case .externalSharingReportFailedDetails(let arg):
                var d = try Serialization.getFields(TeamLog.ExternalSharingReportFailedDetailsSerializer().serialize(arg))
                d[".tag"] = .str("external_sharing_report_failed_details")
                return .dictionary(d)
            case .noExpirationLinkGenCreateReportDetails(let arg):
                var d = try Serialization.getFields(TeamLog.NoExpirationLinkGenCreateReportDetailsSerializer().serialize(arg))
                d[".tag"] = .str("no_expiration_link_gen_create_report_details")
                return .dictionary(d)
            case .noExpirationLinkGenReportFailedDetails(let arg):
                var d = try Serialization.getFields(TeamLog.NoExpirationLinkGenReportFailedDetailsSerializer().serialize(arg))
                d[".tag"] = .str("no_expiration_link_gen_report_failed_details")
                return .dictionary(d)
            case .noPasswordLinkGenCreateReportDetails(let arg):
                var d = try Serialization.getFields(TeamLog.NoPasswordLinkGenCreateReportDetailsSerializer().serialize(arg))
                d[".tag"] = .str("no_password_link_gen_create_report_details")
                return .dictionary(d)
            case .noPasswordLinkGenReportFailedDetails(let arg):
                var d = try Serialization.getFields(TeamLog.NoPasswordLinkGenReportFailedDetailsSerializer().serialize(arg))
                d[".tag"] = .str("no_password_link_gen_report_failed_details")
                return .dictionary(d)
            case .noPasswordLinkViewCreateReportDetails(let arg):
                var d = try Serialization.getFields(TeamLog.NoPasswordLinkViewCreateReportDetailsSerializer().serialize(arg))
                d[".tag"] = .str("no_password_link_view_create_report_details")
                return .dictionary(d)
            case .noPasswordLinkViewReportFailedDetails(let arg):
                var d = try Serialization.getFields(TeamLog.NoPasswordLinkViewReportFailedDetailsSerializer().serialize(arg))
                d[".tag"] = .str("no_password_link_view_report_failed_details")
                return .dictionary(d)
            case .outdatedLinkViewCreateReportDetails(let arg):
                var d = try Serialization.getFields(TeamLog.OutdatedLinkViewCreateReportDetailsSerializer().serialize(arg))
                d[".tag"] = .str("outdated_link_view_create_report_details")
                return .dictionary(d)
            case .outdatedLinkViewReportFailedDetails(let arg):
                var d = try Serialization.getFields(TeamLog.OutdatedLinkViewReportFailedDetailsSerializer().serialize(arg))
                d[".tag"] = .str("outdated_link_view_report_failed_details")
                return .dictionary(d)
            case .paperAdminExportStartDetails(let arg):
                var d = try Serialization.getFields(TeamLog.PaperAdminExportStartDetailsSerializer().serialize(arg))
                d[".tag"] = .str("paper_admin_export_start_details")
                return .dictionary(d)
            case .ransomwareAlertCreateReportDetails(let arg):
                var d = try Serialization.getFields(TeamLog.RansomwareAlertCreateReportDetailsSerializer().serialize(arg))
                d[".tag"] = .str("ransomware_alert_create_report_details")
                return .dictionary(d)
            case .ransomwareAlertCreateReportFailedDetails(let arg):
                var d = try Serialization.getFields(TeamLog.RansomwareAlertCreateReportFailedDetailsSerializer().serialize(arg))
                d[".tag"] = .str("ransomware_alert_create_report_failed_details")
                return .dictionary(d)
            case .smartSyncCreateAdminPrivilegeReportDetails(let arg):
                var d = try Serialization.getFields(TeamLog.SmartSyncCreateAdminPrivilegeReportDetailsSerializer().serialize(arg))
                d[".tag"] = .str("smart_sync_create_admin_privilege_report_details")
                return .dictionary(d)
            case .teamActivityCreateReportDetails(let arg):
                var d = try Serialization.getFields(TeamLog.TeamActivityCreateReportDetailsSerializer().serialize(arg))
                d[".tag"] = .str("team_activity_create_report_details")
                return .dictionary(d)
            case .teamActivityCreateReportFailDetails(let arg):
                var d = try Serialization.getFields(TeamLog.TeamActivityCreateReportFailDetailsSerializer().serialize(arg))
                d[".tag"] = .str("team_activity_create_report_fail_details")
                return .dictionary(d)
            case .collectionShareDetails(let arg):
                var d = try Serialization.getFields(TeamLog.CollectionShareDetailsSerializer().serialize(arg))
                d[".tag"] = .str("collection_share_details")
                return .dictionary(d)
            case .fileTransfersFileAddDetails(let arg):
                var d = try Serialization.getFields(TeamLog.FileTransfersFileAddDetailsSerializer().serialize(arg))
                d[".tag"] = .str("file_transfers_file_add_details")
                return .dictionary(d)
            case .fileTransfersTransferDeleteDetails(let arg):
                var d = try Serialization.getFields(TeamLog.FileTransfersTransferDeleteDetailsSerializer().serialize(arg))
                d[".tag"] = .str("file_transfers_transfer_delete_details")
                return .dictionary(d)
            case .fileTransfersTransferDownloadDetails(let arg):
                var d = try Serialization.getFields(TeamLog.FileTransfersTransferDownloadDetailsSerializer().serialize(arg))
                d[".tag"] = .str("file_transfers_transfer_download_details")
                return .dictionary(d)
            case .fileTransfersTransferSendDetails(let arg):
                var d = try Serialization.getFields(TeamLog.FileTransfersTransferSendDetailsSerializer().serialize(arg))
                d[".tag"] = .str("file_transfers_transfer_send_details")
                return .dictionary(d)
            case .fileTransfersTransferViewDetails(let arg):
                var d = try Serialization.getFields(TeamLog.FileTransfersTransferViewDetailsSerializer().serialize(arg))
                d[".tag"] = .str("file_transfers_transfer_view_details")
                return .dictionary(d)
            case .noteAclInviteOnlyDetails(let arg):
                var d = try Serialization.getFields(TeamLog.NoteAclInviteOnlyDetailsSerializer().serialize(arg))
                d[".tag"] = .str("note_acl_invite_only_details")
                return .dictionary(d)
            case .noteAclLinkDetails(let arg):
                var d = try Serialization.getFields(TeamLog.NoteAclLinkDetailsSerializer().serialize(arg))
                d[".tag"] = .str("note_acl_link_details")
                return .dictionary(d)
            case .noteAclTeamLinkDetails(let arg):
                var d = try Serialization.getFields(TeamLog.NoteAclTeamLinkDetailsSerializer().serialize(arg))
                d[".tag"] = .str("note_acl_team_link_details")
                return .dictionary(d)
            case .noteSharedDetails(let arg):
                var d = try Serialization.getFields(TeamLog.NoteSharedDetailsSerializer().serialize(arg))
                d[".tag"] = .str("note_shared_details")
                return .dictionary(d)
            case .noteShareReceiveDetails(let arg):
                var d = try Serialization.getFields(TeamLog.NoteShareReceiveDetailsSerializer().serialize(arg))
                d[".tag"] = .str("note_share_receive_details")
                return .dictionary(d)
            case .openNoteSharedDetails(let arg):
                var d = try Serialization.getFields(TeamLog.OpenNoteSharedDetailsSerializer().serialize(arg))
                d[".tag"] = .str("open_note_shared_details")
                return .dictionary(d)
            case .replayFileSharedLinkCreatedDetails(let arg):
                var d = try Serialization.getFields(TeamLog.ReplayFileSharedLinkCreatedDetailsSerializer().serialize(arg))
                d[".tag"] = .str("replay_file_shared_link_created_details")
                return .dictionary(d)
            case .replayFileSharedLinkModifiedDetails(let arg):
                var d = try Serialization.getFields(TeamLog.ReplayFileSharedLinkModifiedDetailsSerializer().serialize(arg))
                d[".tag"] = .str("replay_file_shared_link_modified_details")
                return .dictionary(d)
            case .replayProjectTeamAddDetails(let arg):
                var d = try Serialization.getFields(TeamLog.ReplayProjectTeamAddDetailsSerializer().serialize(arg))
                d[".tag"] = .str("replay_project_team_add_details")
                return .dictionary(d)
            case .replayProjectTeamDeleteDetails(let arg):
                var d = try Serialization.getFields(TeamLog.ReplayProjectTeamDeleteDetailsSerializer().serialize(arg))
                d[".tag"] = .str("replay_project_team_delete_details")
                return .dictionary(d)
            case .sfAddGroupDetails(let arg):
                var d = try Serialization.getFields(TeamLog.SfAddGroupDetailsSerializer().serialize(arg))
                d[".tag"] = .str("sf_add_group_details")
                return .dictionary(d)
            case .sfAllowNonMembersToViewSharedLinksDetails(let arg):
                var d = try Serialization.getFields(TeamLog.SfAllowNonMembersToViewSharedLinksDetailsSerializer().serialize(arg))
                d[".tag"] = .str("sf_allow_non_members_to_view_shared_links_details")
                return .dictionary(d)
            case .sfExternalInviteWarnDetails(let arg):
                var d = try Serialization.getFields(TeamLog.SfExternalInviteWarnDetailsSerializer().serialize(arg))
                d[".tag"] = .str("sf_external_invite_warn_details")
                return .dictionary(d)
            case .sfFbInviteDetails(let arg):
                var d = try Serialization.getFields(TeamLog.SfFbInviteDetailsSerializer().serialize(arg))
                d[".tag"] = .str("sf_fb_invite_details")
                return .dictionary(d)
            case .sfFbInviteChangeRoleDetails(let arg):
                var d = try Serialization.getFields(TeamLog.SfFbInviteChangeRoleDetailsSerializer().serialize(arg))
                d[".tag"] = .str("sf_fb_invite_change_role_details")
                return .dictionary(d)
            case .sfFbUninviteDetails(let arg):
                var d = try Serialization.getFields(TeamLog.SfFbUninviteDetailsSerializer().serialize(arg))
                d[".tag"] = .str("sf_fb_uninvite_details")
                return .dictionary(d)
            case .sfInviteGroupDetails(let arg):
                var d = try Serialization.getFields(TeamLog.SfInviteGroupDetailsSerializer().serialize(arg))
                d[".tag"] = .str("sf_invite_group_details")
                return .dictionary(d)
            case .sfTeamGrantAccessDetails(let arg):
                var d = try Serialization.getFields(TeamLog.SfTeamGrantAccessDetailsSerializer().serialize(arg))
                d[".tag"] = .str("sf_team_grant_access_details")
                return .dictionary(d)
            case .sfTeamInviteDetails(let arg):
                var d = try Serialization.getFields(TeamLog.SfTeamInviteDetailsSerializer().serialize(arg))
                d[".tag"] = .str("sf_team_invite_details")
                return .dictionary(d)
            case .sfTeamInviteChangeRoleDetails(let arg):
                var d = try Serialization.getFields(TeamLog.SfTeamInviteChangeRoleDetailsSerializer().serialize(arg))
                d[".tag"] = .str("sf_team_invite_change_role_details")
                return .dictionary(d)
            case .sfTeamJoinDetails(let arg):
                var d = try Serialization.getFields(TeamLog.SfTeamJoinDetailsSerializer().serialize(arg))
                d[".tag"] = .str("sf_team_join_details")
                return .dictionary(d)
            case .sfTeamJoinFromOobLinkDetails(let arg):
                var d = try Serialization.getFields(TeamLog.SfTeamJoinFromOobLinkDetailsSerializer().serialize(arg))
                d[".tag"] = .str("sf_team_join_from_oob_link_details")
                return .dictionary(d)
            case .sfTeamUninviteDetails(let arg):
                var d = try Serialization.getFields(TeamLog.SfTeamUninviteDetailsSerializer().serialize(arg))
                d[".tag"] = .str("sf_team_uninvite_details")
                return .dictionary(d)
            case .sharedContentAddInviteesDetails(let arg):
                var d = try Serialization.getFields(TeamLog.SharedContentAddInviteesDetailsSerializer().serialize(arg))
                d[".tag"] = .str("shared_content_add_invitees_details")
                return .dictionary(d)
            case .sharedContentAddLinkExpiryDetails(let arg):
                var d = try Serialization.getFields(TeamLog.SharedContentAddLinkExpiryDetailsSerializer().serialize(arg))
                d[".tag"] = .str("shared_content_add_link_expiry_details")
                return .dictionary(d)
            case .sharedContentAddLinkPasswordDetails(let arg):
                var d = try Serialization.getFields(TeamLog.SharedContentAddLinkPasswordDetailsSerializer().serialize(arg))
                d[".tag"] = .str("shared_content_add_link_password_details")
                return .dictionary(d)
            case .sharedContentAddMemberDetails(let arg):
                var d = try Serialization.getFields(TeamLog.SharedContentAddMemberDetailsSerializer().serialize(arg))
                d[".tag"] = .str("shared_content_add_member_details")
                return .dictionary(d)
            case .sharedContentChangeDownloadsPolicyDetails(let arg):
                var d = try Serialization.getFields(TeamLog.SharedContentChangeDownloadsPolicyDetailsSerializer().serialize(arg))
                d[".tag"] = .str("shared_content_change_downloads_policy_details")
                return .dictionary(d)
            case .sharedContentChangeInviteeRoleDetails(let arg):
                var d = try Serialization.getFields(TeamLog.SharedContentChangeInviteeRoleDetailsSerializer().serialize(arg))
                d[".tag"] = .str("shared_content_change_invitee_role_details")
                return .dictionary(d)
            case .sharedContentChangeLinkAudienceDetails(let arg):
                var d = try Serialization.getFields(TeamLog.SharedContentChangeLinkAudienceDetailsSerializer().serialize(arg))
                d[".tag"] = .str("shared_content_change_link_audience_details")
                return .dictionary(d)
            case .sharedContentChangeLinkExpiryDetails(let arg):
                var d = try Serialization.getFields(TeamLog.SharedContentChangeLinkExpiryDetailsSerializer().serialize(arg))
                d[".tag"] = .str("shared_content_change_link_expiry_details")
                return .dictionary(d)
            case .sharedContentChangeLinkPasswordDetails(let arg):
                var d = try Serialization.getFields(TeamLog.SharedContentChangeLinkPasswordDetailsSerializer().serialize(arg))
                d[".tag"] = .str("shared_content_change_link_password_details")
                return .dictionary(d)
            case .sharedContentChangeMemberRoleDetails(let arg):
                var d = try Serialization.getFields(TeamLog.SharedContentChangeMemberRoleDetailsSerializer().serialize(arg))
                d[".tag"] = .str("shared_content_change_member_role_details")
                return .dictionary(d)
            case .sharedContentChangeViewerInfoPolicyDetails(let arg):
                var d = try Serialization.getFields(TeamLog.SharedContentChangeViewerInfoPolicyDetailsSerializer().serialize(arg))
                d[".tag"] = .str("shared_content_change_viewer_info_policy_details")
                return .dictionary(d)
            case .sharedContentClaimInvitationDetails(let arg):
                var d = try Serialization.getFields(TeamLog.SharedContentClaimInvitationDetailsSerializer().serialize(arg))
                d[".tag"] = .str("shared_content_claim_invitation_details")
                return .dictionary(d)
            case .sharedContentCopyDetails(let arg):
                var d = try Serialization.getFields(TeamLog.SharedContentCopyDetailsSerializer().serialize(arg))
                d[".tag"] = .str("shared_content_copy_details")
                return .dictionary(d)
            case .sharedContentDownloadDetails(let arg):
                var d = try Serialization.getFields(TeamLog.SharedContentDownloadDetailsSerializer().serialize(arg))
                d[".tag"] = .str("shared_content_download_details")
                return .dictionary(d)
            case .sharedContentRelinquishMembershipDetails(let arg):
                var d = try Serialization.getFields(TeamLog.SharedContentRelinquishMembershipDetailsSerializer().serialize(arg))
                d[".tag"] = .str("shared_content_relinquish_membership_details")
                return .dictionary(d)
            case .sharedContentRemoveInviteesDetails(let arg):
                var d = try Serialization.getFields(TeamLog.SharedContentRemoveInviteesDetailsSerializer().serialize(arg))
                d[".tag"] = .str("shared_content_remove_invitees_details")
                return .dictionary(d)
            case .sharedContentRemoveLinkExpiryDetails(let arg):
                var d = try Serialization.getFields(TeamLog.SharedContentRemoveLinkExpiryDetailsSerializer().serialize(arg))
                d[".tag"] = .str("shared_content_remove_link_expiry_details")
                return .dictionary(d)
            case .sharedContentRemoveLinkPasswordDetails(let arg):
                var d = try Serialization.getFields(TeamLog.SharedContentRemoveLinkPasswordDetailsSerializer().serialize(arg))
                d[".tag"] = .str("shared_content_remove_link_password_details")
                return .dictionary(d)
            case .sharedContentRemoveMemberDetails(let arg):
                var d = try Serialization.getFields(TeamLog.SharedContentRemoveMemberDetailsSerializer().serialize(arg))
                d[".tag"] = .str("shared_content_remove_member_details")
                return .dictionary(d)
            case .sharedContentRequestAccessDetails(let arg):
                var d = try Serialization.getFields(TeamLog.SharedContentRequestAccessDetailsSerializer().serialize(arg))
                d[".tag"] = .str("shared_content_request_access_details")
                return .dictionary(d)
            case .sharedContentRestoreInviteesDetails(let arg):
                var d = try Serialization.getFields(TeamLog.SharedContentRestoreInviteesDetailsSerializer().serialize(arg))
                d[".tag"] = .str("shared_content_restore_invitees_details")
                return .dictionary(d)
            case .sharedContentRestoreMemberDetails(let arg):
                var d = try Serialization.getFields(TeamLog.SharedContentRestoreMemberDetailsSerializer().serialize(arg))
                d[".tag"] = .str("shared_content_restore_member_details")
                return .dictionary(d)
            case .sharedContentUnshareDetails(let arg):
                var d = try Serialization.getFields(TeamLog.SharedContentUnshareDetailsSerializer().serialize(arg))
                d[".tag"] = .str("shared_content_unshare_details")
                return .dictionary(d)
            case .sharedContentViewDetails(let arg):
                var d = try Serialization.getFields(TeamLog.SharedContentViewDetailsSerializer().serialize(arg))
                d[".tag"] = .str("shared_content_view_details")
                return .dictionary(d)
            case .sharedFolderChangeLinkPolicyDetails(let arg):
                var d = try Serialization.getFields(TeamLog.SharedFolderChangeLinkPolicyDetailsSerializer().serialize(arg))
                d[".tag"] = .str("shared_folder_change_link_policy_details")
                return .dictionary(d)
            case .sharedFolderChangeMembersInheritancePolicyDetails(let arg):
                var d = try Serialization.getFields(TeamLog.SharedFolderChangeMembersInheritancePolicyDetailsSerializer().serialize(arg))
                d[".tag"] = .str("shared_folder_change_members_inheritance_policy_details")
                return .dictionary(d)
            case .sharedFolderChangeMembersManagementPolicyDetails(let arg):
                var d = try Serialization.getFields(TeamLog.SharedFolderChangeMembersManagementPolicyDetailsSerializer().serialize(arg))
                d[".tag"] = .str("shared_folder_change_members_management_policy_details")
                return .dictionary(d)
            case .sharedFolderChangeMembersPolicyDetails(let arg):
                var d = try Serialization.getFields(TeamLog.SharedFolderChangeMembersPolicyDetailsSerializer().serialize(arg))
                d[".tag"] = .str("shared_folder_change_members_policy_details")
                return .dictionary(d)
            case .sharedFolderCreateDetails(let arg):
                var d = try Serialization.getFields(TeamLog.SharedFolderCreateDetailsSerializer().serialize(arg))
                d[".tag"] = .str("shared_folder_create_details")
                return .dictionary(d)
            case .sharedFolderDeclineInvitationDetails(let arg):
                var d = try Serialization.getFields(TeamLog.SharedFolderDeclineInvitationDetailsSerializer().serialize(arg))
                d[".tag"] = .str("shared_folder_decline_invitation_details")
                return .dictionary(d)
            case .sharedFolderMountDetails(let arg):
                var d = try Serialization.getFields(TeamLog.SharedFolderMountDetailsSerializer().serialize(arg))
                d[".tag"] = .str("shared_folder_mount_details")
                return .dictionary(d)
            case .sharedFolderNestDetails(let arg):
                var d = try Serialization.getFields(TeamLog.SharedFolderNestDetailsSerializer().serialize(arg))
                d[".tag"] = .str("shared_folder_nest_details")
                return .dictionary(d)
            case .sharedFolderTransferOwnershipDetails(let arg):
                var d = try Serialization.getFields(TeamLog.SharedFolderTransferOwnershipDetailsSerializer().serialize(arg))
                d[".tag"] = .str("shared_folder_transfer_ownership_details")
                return .dictionary(d)
            case .sharedFolderUnmountDetails(let arg):
                var d = try Serialization.getFields(TeamLog.SharedFolderUnmountDetailsSerializer().serialize(arg))
                d[".tag"] = .str("shared_folder_unmount_details")
                return .dictionary(d)
            case .sharedLinkAddExpiryDetails(let arg):
                var d = try Serialization.getFields(TeamLog.SharedLinkAddExpiryDetailsSerializer().serialize(arg))
                d[".tag"] = .str("shared_link_add_expiry_details")
                return .dictionary(d)
            case .sharedLinkChangeExpiryDetails(let arg):
                var d = try Serialization.getFields(TeamLog.SharedLinkChangeExpiryDetailsSerializer().serialize(arg))
                d[".tag"] = .str("shared_link_change_expiry_details")
                return .dictionary(d)
            case .sharedLinkChangeVisibilityDetails(let arg):
                var d = try Serialization.getFields(TeamLog.SharedLinkChangeVisibilityDetailsSerializer().serialize(arg))
                d[".tag"] = .str("shared_link_change_visibility_details")
                return .dictionary(d)
            case .sharedLinkCopyDetails(let arg):
                var d = try Serialization.getFields(TeamLog.SharedLinkCopyDetailsSerializer().serialize(arg))
                d[".tag"] = .str("shared_link_copy_details")
                return .dictionary(d)
            case .sharedLinkCreateDetails(let arg):
                var d = try Serialization.getFields(TeamLog.SharedLinkCreateDetailsSerializer().serialize(arg))
                d[".tag"] = .str("shared_link_create_details")
                return .dictionary(d)
            case .sharedLinkDisableDetails(let arg):
                var d = try Serialization.getFields(TeamLog.SharedLinkDisableDetailsSerializer().serialize(arg))
                d[".tag"] = .str("shared_link_disable_details")
                return .dictionary(d)
            case .sharedLinkDownloadDetails(let arg):
                var d = try Serialization.getFields(TeamLog.SharedLinkDownloadDetailsSerializer().serialize(arg))
                d[".tag"] = .str("shared_link_download_details")
                return .dictionary(d)
            case .sharedLinkRemoveExpiryDetails(let arg):
                var d = try Serialization.getFields(TeamLog.SharedLinkRemoveExpiryDetailsSerializer().serialize(arg))
                d[".tag"] = .str("shared_link_remove_expiry_details")
                return .dictionary(d)
            case .sharedLinkSettingsAddExpirationDetails(let arg):
                var d = try Serialization.getFields(TeamLog.SharedLinkSettingsAddExpirationDetailsSerializer().serialize(arg))
                d[".tag"] = .str("shared_link_settings_add_expiration_details")
                return .dictionary(d)
            case .sharedLinkSettingsAddPasswordDetails(let arg):
                var d = try Serialization.getFields(TeamLog.SharedLinkSettingsAddPasswordDetailsSerializer().serialize(arg))
                d[".tag"] = .str("shared_link_settings_add_password_details")
                return .dictionary(d)
            case .sharedLinkSettingsAllowDownloadDisabledDetails(let arg):
                var d = try Serialization.getFields(TeamLog.SharedLinkSettingsAllowDownloadDisabledDetailsSerializer().serialize(arg))
                d[".tag"] = .str("shared_link_settings_allow_download_disabled_details")
                return .dictionary(d)
            case .sharedLinkSettingsAllowDownloadEnabledDetails(let arg):
                var d = try Serialization.getFields(TeamLog.SharedLinkSettingsAllowDownloadEnabledDetailsSerializer().serialize(arg))
                d[".tag"] = .str("shared_link_settings_allow_download_enabled_details")
                return .dictionary(d)
            case .sharedLinkSettingsChangeAudienceDetails(let arg):
                var d = try Serialization.getFields(TeamLog.SharedLinkSettingsChangeAudienceDetailsSerializer().serialize(arg))
                d[".tag"] = .str("shared_link_settings_change_audience_details")
                return .dictionary(d)
            case .sharedLinkSettingsChangeExpirationDetails(let arg):
                var d = try Serialization.getFields(TeamLog.SharedLinkSettingsChangeExpirationDetailsSerializer().serialize(arg))
                d[".tag"] = .str("shared_link_settings_change_expiration_details")
                return .dictionary(d)
            case .sharedLinkSettingsChangePasswordDetails(let arg):
                var d = try Serialization.getFields(TeamLog.SharedLinkSettingsChangePasswordDetailsSerializer().serialize(arg))
                d[".tag"] = .str("shared_link_settings_change_password_details")
                return .dictionary(d)
            case .sharedLinkSettingsRemoveExpirationDetails(let arg):
                var d = try Serialization.getFields(TeamLog.SharedLinkSettingsRemoveExpirationDetailsSerializer().serialize(arg))
                d[".tag"] = .str("shared_link_settings_remove_expiration_details")
                return .dictionary(d)
            case .sharedLinkSettingsRemovePasswordDetails(let arg):
                var d = try Serialization.getFields(TeamLog.SharedLinkSettingsRemovePasswordDetailsSerializer().serialize(arg))
                d[".tag"] = .str("shared_link_settings_remove_password_details")
                return .dictionary(d)
            case .sharedLinkShareDetails(let arg):
                var d = try Serialization.getFields(TeamLog.SharedLinkShareDetailsSerializer().serialize(arg))
                d[".tag"] = .str("shared_link_share_details")
                return .dictionary(d)
            case .sharedLinkViewDetails(let arg):
                var d = try Serialization.getFields(TeamLog.SharedLinkViewDetailsSerializer().serialize(arg))
                d[".tag"] = .str("shared_link_view_details")
                return .dictionary(d)
            case .sharedNoteOpenedDetails(let arg):
                var d = try Serialization.getFields(TeamLog.SharedNoteOpenedDetailsSerializer().serialize(arg))
                d[".tag"] = .str("shared_note_opened_details")
                return .dictionary(d)
            case .shmodelDisableDownloadsDetails(let arg):
                var d = try Serialization.getFields(TeamLog.ShmodelDisableDownloadsDetailsSerializer().serialize(arg))
                d[".tag"] = .str("shmodel_disable_downloads_details")
                return .dictionary(d)
            case .shmodelEnableDownloadsDetails(let arg):
                var d = try Serialization.getFields(TeamLog.ShmodelEnableDownloadsDetailsSerializer().serialize(arg))
                d[".tag"] = .str("shmodel_enable_downloads_details")
                return .dictionary(d)
            case .shmodelGroupShareDetails(let arg):
                var d = try Serialization.getFields(TeamLog.ShmodelGroupShareDetailsSerializer().serialize(arg))
                d[".tag"] = .str("shmodel_group_share_details")
                return .dictionary(d)
            case .showcaseAccessGrantedDetails(let arg):
                var d = try Serialization.getFields(TeamLog.ShowcaseAccessGrantedDetailsSerializer().serialize(arg))
                d[".tag"] = .str("showcase_access_granted_details")
                return .dictionary(d)
            case .showcaseAddMemberDetails(let arg):
                var d = try Serialization.getFields(TeamLog.ShowcaseAddMemberDetailsSerializer().serialize(arg))
                d[".tag"] = .str("showcase_add_member_details")
                return .dictionary(d)
            case .showcaseArchivedDetails(let arg):
                var d = try Serialization.getFields(TeamLog.ShowcaseArchivedDetailsSerializer().serialize(arg))
                d[".tag"] = .str("showcase_archived_details")
                return .dictionary(d)
            case .showcaseCreatedDetails(let arg):
                var d = try Serialization.getFields(TeamLog.ShowcaseCreatedDetailsSerializer().serialize(arg))
                d[".tag"] = .str("showcase_created_details")
                return .dictionary(d)
            case .showcaseDeleteCommentDetails(let arg):
                var d = try Serialization.getFields(TeamLog.ShowcaseDeleteCommentDetailsSerializer().serialize(arg))
                d[".tag"] = .str("showcase_delete_comment_details")
                return .dictionary(d)
            case .showcaseEditedDetails(let arg):
                var d = try Serialization.getFields(TeamLog.ShowcaseEditedDetailsSerializer().serialize(arg))
                d[".tag"] = .str("showcase_edited_details")
                return .dictionary(d)
            case .showcaseEditCommentDetails(let arg):
                var d = try Serialization.getFields(TeamLog.ShowcaseEditCommentDetailsSerializer().serialize(arg))
                d[".tag"] = .str("showcase_edit_comment_details")
                return .dictionary(d)
            case .showcaseFileAddedDetails(let arg):
                var d = try Serialization.getFields(TeamLog.ShowcaseFileAddedDetailsSerializer().serialize(arg))
                d[".tag"] = .str("showcase_file_added_details")
                return .dictionary(d)
            case .showcaseFileDownloadDetails(let arg):
                var d = try Serialization.getFields(TeamLog.ShowcaseFileDownloadDetailsSerializer().serialize(arg))
                d[".tag"] = .str("showcase_file_download_details")
                return .dictionary(d)
            case .showcaseFileRemovedDetails(let arg):
                var d = try Serialization.getFields(TeamLog.ShowcaseFileRemovedDetailsSerializer().serialize(arg))
                d[".tag"] = .str("showcase_file_removed_details")
                return .dictionary(d)
            case .showcaseFileViewDetails(let arg):
                var d = try Serialization.getFields(TeamLog.ShowcaseFileViewDetailsSerializer().serialize(arg))
                d[".tag"] = .str("showcase_file_view_details")
                return .dictionary(d)
            case .showcasePermanentlyDeletedDetails(let arg):
                var d = try Serialization.getFields(TeamLog.ShowcasePermanentlyDeletedDetailsSerializer().serialize(arg))
                d[".tag"] = .str("showcase_permanently_deleted_details")
                return .dictionary(d)
            case .showcasePostCommentDetails(let arg):
                var d = try Serialization.getFields(TeamLog.ShowcasePostCommentDetailsSerializer().serialize(arg))
                d[".tag"] = .str("showcase_post_comment_details")
                return .dictionary(d)
            case .showcaseRemoveMemberDetails(let arg):
                var d = try Serialization.getFields(TeamLog.ShowcaseRemoveMemberDetailsSerializer().serialize(arg))
                d[".tag"] = .str("showcase_remove_member_details")
                return .dictionary(d)
            case .showcaseRenamedDetails(let arg):
                var d = try Serialization.getFields(TeamLog.ShowcaseRenamedDetailsSerializer().serialize(arg))
                d[".tag"] = .str("showcase_renamed_details")
                return .dictionary(d)
            case .showcaseRequestAccessDetails(let arg):
                var d = try Serialization.getFields(TeamLog.ShowcaseRequestAccessDetailsSerializer().serialize(arg))
                d[".tag"] = .str("showcase_request_access_details")
                return .dictionary(d)
            case .showcaseResolveCommentDetails(let arg):
                var d = try Serialization.getFields(TeamLog.ShowcaseResolveCommentDetailsSerializer().serialize(arg))
                d[".tag"] = .str("showcase_resolve_comment_details")
                return .dictionary(d)
            case .showcaseRestoredDetails(let arg):
                var d = try Serialization.getFields(TeamLog.ShowcaseRestoredDetailsSerializer().serialize(arg))
                d[".tag"] = .str("showcase_restored_details")
                return .dictionary(d)
            case .showcaseTrashedDetails(let arg):
                var d = try Serialization.getFields(TeamLog.ShowcaseTrashedDetailsSerializer().serialize(arg))
                d[".tag"] = .str("showcase_trashed_details")
                return .dictionary(d)
            case .showcaseTrashedDeprecatedDetails(let arg):
                var d = try Serialization.getFields(TeamLog.ShowcaseTrashedDeprecatedDetailsSerializer().serialize(arg))
                d[".tag"] = .str("showcase_trashed_deprecated_details")
                return .dictionary(d)
            case .showcaseUnresolveCommentDetails(let arg):
                var d = try Serialization.getFields(TeamLog.ShowcaseUnresolveCommentDetailsSerializer().serialize(arg))
                d[".tag"] = .str("showcase_unresolve_comment_details")
                return .dictionary(d)
            case .showcaseUntrashedDetails(let arg):
                var d = try Serialization.getFields(TeamLog.ShowcaseUntrashedDetailsSerializer().serialize(arg))
                d[".tag"] = .str("showcase_untrashed_details")
                return .dictionary(d)
            case .showcaseUntrashedDeprecatedDetails(let arg):
                var d = try Serialization.getFields(TeamLog.ShowcaseUntrashedDeprecatedDetailsSerializer().serialize(arg))
                d[".tag"] = .str("showcase_untrashed_deprecated_details")
                return .dictionary(d)
            case .showcaseViewDetails(let arg):
                var d = try Serialization.getFields(TeamLog.ShowcaseViewDetailsSerializer().serialize(arg))
                d[".tag"] = .str("showcase_view_details")
                return .dictionary(d)
            case .ssoAddCertDetails(let arg):
                var d = try Serialization.getFields(TeamLog.SsoAddCertDetailsSerializer().serialize(arg))
                d[".tag"] = .str("sso_add_cert_details")
                return .dictionary(d)
            case .ssoAddLoginUrlDetails(let arg):
                var d = try Serialization.getFields(TeamLog.SsoAddLoginUrlDetailsSerializer().serialize(arg))
                d[".tag"] = .str("sso_add_login_url_details")
                return .dictionary(d)
            case .ssoAddLogoutUrlDetails(let arg):
                var d = try Serialization.getFields(TeamLog.SsoAddLogoutUrlDetailsSerializer().serialize(arg))
                d[".tag"] = .str("sso_add_logout_url_details")
                return .dictionary(d)
            case .ssoChangeCertDetails(let arg):
                var d = try Serialization.getFields(TeamLog.SsoChangeCertDetailsSerializer().serialize(arg))
                d[".tag"] = .str("sso_change_cert_details")
                return .dictionary(d)
            case .ssoChangeLoginUrlDetails(let arg):
                var d = try Serialization.getFields(TeamLog.SsoChangeLoginUrlDetailsSerializer().serialize(arg))
                d[".tag"] = .str("sso_change_login_url_details")
                return .dictionary(d)
            case .ssoChangeLogoutUrlDetails(let arg):
                var d = try Serialization.getFields(TeamLog.SsoChangeLogoutUrlDetailsSerializer().serialize(arg))
                d[".tag"] = .str("sso_change_logout_url_details")
                return .dictionary(d)
            case .ssoChangeSamlIdentityModeDetails(let arg):
                var d = try Serialization.getFields(TeamLog.SsoChangeSamlIdentityModeDetailsSerializer().serialize(arg))
                d[".tag"] = .str("sso_change_saml_identity_mode_details")
                return .dictionary(d)
            case .ssoRemoveCertDetails(let arg):
                var d = try Serialization.getFields(TeamLog.SsoRemoveCertDetailsSerializer().serialize(arg))
                d[".tag"] = .str("sso_remove_cert_details")
                return .dictionary(d)
            case .ssoRemoveLoginUrlDetails(let arg):
                var d = try Serialization.getFields(TeamLog.SsoRemoveLoginUrlDetailsSerializer().serialize(arg))
                d[".tag"] = .str("sso_remove_login_url_details")
                return .dictionary(d)
            case .ssoRemoveLogoutUrlDetails(let arg):
                var d = try Serialization.getFields(TeamLog.SsoRemoveLogoutUrlDetailsSerializer().serialize(arg))
                d[".tag"] = .str("sso_remove_logout_url_details")
                return .dictionary(d)
            case .teamFolderChangeStatusDetails(let arg):
                var d = try Serialization.getFields(TeamLog.TeamFolderChangeStatusDetailsSerializer().serialize(arg))
                d[".tag"] = .str("team_folder_change_status_details")
                return .dictionary(d)
            case .teamFolderCreateDetails(let arg):
                var d = try Serialization.getFields(TeamLog.TeamFolderCreateDetailsSerializer().serialize(arg))
                d[".tag"] = .str("team_folder_create_details")
                return .dictionary(d)
            case .teamFolderDowngradeDetails(let arg):
                var d = try Serialization.getFields(TeamLog.TeamFolderDowngradeDetailsSerializer().serialize(arg))
                d[".tag"] = .str("team_folder_downgrade_details")
                return .dictionary(d)
            case .teamFolderPermanentlyDeleteDetails(let arg):
                var d = try Serialization.getFields(TeamLog.TeamFolderPermanentlyDeleteDetailsSerializer().serialize(arg))
                d[".tag"] = .str("team_folder_permanently_delete_details")
                return .dictionary(d)
            case .teamFolderRenameDetails(let arg):
                var d = try Serialization.getFields(TeamLog.TeamFolderRenameDetailsSerializer().serialize(arg))
                d[".tag"] = .str("team_folder_rename_details")
                return .dictionary(d)
            case .teamSelectiveSyncSettingsChangedDetails(let arg):
                var d = try Serialization.getFields(TeamLog.TeamSelectiveSyncSettingsChangedDetailsSerializer().serialize(arg))
                d[".tag"] = .str("team_selective_sync_settings_changed_details")
                return .dictionary(d)
            case .accountCaptureChangePolicyDetails(let arg):
                var d = try Serialization.getFields(TeamLog.AccountCaptureChangePolicyDetailsSerializer().serialize(arg))
                d[".tag"] = .str("account_capture_change_policy_details")
                return .dictionary(d)
            case .adminEmailRemindersChangedDetails(let arg):
                var d = try Serialization.getFields(TeamLog.AdminEmailRemindersChangedDetailsSerializer().serialize(arg))
                d[".tag"] = .str("admin_email_reminders_changed_details")
                return .dictionary(d)
            case .allowDownloadDisabledDetails(let arg):
                var d = try Serialization.getFields(TeamLog.AllowDownloadDisabledDetailsSerializer().serialize(arg))
                d[".tag"] = .str("allow_download_disabled_details")
                return .dictionary(d)
            case .allowDownloadEnabledDetails(let arg):
                var d = try Serialization.getFields(TeamLog.AllowDownloadEnabledDetailsSerializer().serialize(arg))
                d[".tag"] = .str("allow_download_enabled_details")
                return .dictionary(d)
            case .appPermissionsChangedDetails(let arg):
                var d = try Serialization.getFields(TeamLog.AppPermissionsChangedDetailsSerializer().serialize(arg))
                d[".tag"] = .str("app_permissions_changed_details")
                return .dictionary(d)
            case .cameraUploadsPolicyChangedDetails(let arg):
                var d = try Serialization.getFields(TeamLog.CameraUploadsPolicyChangedDetailsSerializer().serialize(arg))
                d[".tag"] = .str("camera_uploads_policy_changed_details")
                return .dictionary(d)
            case .captureTranscriptPolicyChangedDetails(let arg):
                var d = try Serialization.getFields(TeamLog.CaptureTranscriptPolicyChangedDetailsSerializer().serialize(arg))
                d[".tag"] = .str("capture_transcript_policy_changed_details")
                return .dictionary(d)
            case .classificationChangePolicyDetails(let arg):
                var d = try Serialization.getFields(TeamLog.ClassificationChangePolicyDetailsSerializer().serialize(arg))
                d[".tag"] = .str("classification_change_policy_details")
                return .dictionary(d)
            case .computerBackupPolicyChangedDetails(let arg):
                var d = try Serialization.getFields(TeamLog.ComputerBackupPolicyChangedDetailsSerializer().serialize(arg))
                d[".tag"] = .str("computer_backup_policy_changed_details")
                return .dictionary(d)
            case .contentAdministrationPolicyChangedDetails(let arg):
                var d = try Serialization.getFields(TeamLog.ContentAdministrationPolicyChangedDetailsSerializer().serialize(arg))
                d[".tag"] = .str("content_administration_policy_changed_details")
                return .dictionary(d)
            case .dataPlacementRestrictionChangePolicyDetails(let arg):
                var d = try Serialization.getFields(TeamLog.DataPlacementRestrictionChangePolicyDetailsSerializer().serialize(arg))
                d[".tag"] = .str("data_placement_restriction_change_policy_details")
                return .dictionary(d)
            case .dataPlacementRestrictionSatisfyPolicyDetails(let arg):
                var d = try Serialization.getFields(TeamLog.DataPlacementRestrictionSatisfyPolicyDetailsSerializer().serialize(arg))
                d[".tag"] = .str("data_placement_restriction_satisfy_policy_details")
                return .dictionary(d)
            case .deviceApprovalsAddExceptionDetails(let arg):
                var d = try Serialization.getFields(TeamLog.DeviceApprovalsAddExceptionDetailsSerializer().serialize(arg))
                d[".tag"] = .str("device_approvals_add_exception_details")
                return .dictionary(d)
            case .deviceApprovalsChangeDesktopPolicyDetails(let arg):
                var d = try Serialization.getFields(TeamLog.DeviceApprovalsChangeDesktopPolicyDetailsSerializer().serialize(arg))
                d[".tag"] = .str("device_approvals_change_desktop_policy_details")
                return .dictionary(d)
            case .deviceApprovalsChangeMobilePolicyDetails(let arg):
                var d = try Serialization.getFields(TeamLog.DeviceApprovalsChangeMobilePolicyDetailsSerializer().serialize(arg))
                d[".tag"] = .str("device_approvals_change_mobile_policy_details")
                return .dictionary(d)
            case .deviceApprovalsChangeOverageActionDetails(let arg):
                var d = try Serialization.getFields(TeamLog.DeviceApprovalsChangeOverageActionDetailsSerializer().serialize(arg))
                d[".tag"] = .str("device_approvals_change_overage_action_details")
                return .dictionary(d)
            case .deviceApprovalsChangeUnlinkActionDetails(let arg):
                var d = try Serialization.getFields(TeamLog.DeviceApprovalsChangeUnlinkActionDetailsSerializer().serialize(arg))
                d[".tag"] = .str("device_approvals_change_unlink_action_details")
                return .dictionary(d)
            case .deviceApprovalsRemoveExceptionDetails(let arg):
                var d = try Serialization.getFields(TeamLog.DeviceApprovalsRemoveExceptionDetailsSerializer().serialize(arg))
                d[".tag"] = .str("device_approvals_remove_exception_details")
                return .dictionary(d)
            case .directoryRestrictionsAddMembersDetails(let arg):
                var d = try Serialization.getFields(TeamLog.DirectoryRestrictionsAddMembersDetailsSerializer().serialize(arg))
                d[".tag"] = .str("directory_restrictions_add_members_details")
                return .dictionary(d)
            case .directoryRestrictionsRemoveMembersDetails(let arg):
                var d = try Serialization.getFields(TeamLog.DirectoryRestrictionsRemoveMembersDetailsSerializer().serialize(arg))
                d[".tag"] = .str("directory_restrictions_remove_members_details")
                return .dictionary(d)
            case .dropboxPasswordsPolicyChangedDetails(let arg):
                var d = try Serialization.getFields(TeamLog.DropboxPasswordsPolicyChangedDetailsSerializer().serialize(arg))
                d[".tag"] = .str("dropbox_passwords_policy_changed_details")
                return .dictionary(d)
            case .emailIngestPolicyChangedDetails(let arg):
                var d = try Serialization.getFields(TeamLog.EmailIngestPolicyChangedDetailsSerializer().serialize(arg))
                d[".tag"] = .str("email_ingest_policy_changed_details")
                return .dictionary(d)
            case .emmAddExceptionDetails(let arg):
                var d = try Serialization.getFields(TeamLog.EmmAddExceptionDetailsSerializer().serialize(arg))
                d[".tag"] = .str("emm_add_exception_details")
                return .dictionary(d)
            case .emmChangePolicyDetails(let arg):
                var d = try Serialization.getFields(TeamLog.EmmChangePolicyDetailsSerializer().serialize(arg))
                d[".tag"] = .str("emm_change_policy_details")
                return .dictionary(d)
            case .emmRemoveExceptionDetails(let arg):
                var d = try Serialization.getFields(TeamLog.EmmRemoveExceptionDetailsSerializer().serialize(arg))
                d[".tag"] = .str("emm_remove_exception_details")
                return .dictionary(d)
            case .extendedVersionHistoryChangePolicyDetails(let arg):
                var d = try Serialization.getFields(TeamLog.ExtendedVersionHistoryChangePolicyDetailsSerializer().serialize(arg))
                d[".tag"] = .str("extended_version_history_change_policy_details")
                return .dictionary(d)
            case .externalDriveBackupPolicyChangedDetails(let arg):
                var d = try Serialization.getFields(TeamLog.ExternalDriveBackupPolicyChangedDetailsSerializer().serialize(arg))
                d[".tag"] = .str("external_drive_backup_policy_changed_details")
                return .dictionary(d)
            case .fileCommentsChangePolicyDetails(let arg):
                var d = try Serialization.getFields(TeamLog.FileCommentsChangePolicyDetailsSerializer().serialize(arg))
                d[".tag"] = .str("file_comments_change_policy_details")
                return .dictionary(d)
            case .fileLockingPolicyChangedDetails(let arg):
                var d = try Serialization.getFields(TeamLog.FileLockingPolicyChangedDetailsSerializer().serialize(arg))
                d[".tag"] = .str("file_locking_policy_changed_details")
                return .dictionary(d)
            case .fileProviderMigrationPolicyChangedDetails(let arg):
                var d = try Serialization.getFields(TeamLog.FileProviderMigrationPolicyChangedDetailsSerializer().serialize(arg))
                d[".tag"] = .str("file_provider_migration_policy_changed_details")
                return .dictionary(d)
            case .fileRequestsChangePolicyDetails(let arg):
                var d = try Serialization.getFields(TeamLog.FileRequestsChangePolicyDetailsSerializer().serialize(arg))
                d[".tag"] = .str("file_requests_change_policy_details")
                return .dictionary(d)
            case .fileRequestsEmailsEnabledDetails(let arg):
                var d = try Serialization.getFields(TeamLog.FileRequestsEmailsEnabledDetailsSerializer().serialize(arg))
                d[".tag"] = .str("file_requests_emails_enabled_details")
                return .dictionary(d)
            case .fileRequestsEmailsRestrictedToTeamOnlyDetails(let arg):
                var d = try Serialization.getFields(TeamLog.FileRequestsEmailsRestrictedToTeamOnlyDetailsSerializer().serialize(arg))
                d[".tag"] = .str("file_requests_emails_restricted_to_team_only_details")
                return .dictionary(d)
            case .fileTransfersPolicyChangedDetails(let arg):
                var d = try Serialization.getFields(TeamLog.FileTransfersPolicyChangedDetailsSerializer().serialize(arg))
                d[".tag"] = .str("file_transfers_policy_changed_details")
                return .dictionary(d)
            case .folderLinkRestrictionPolicyChangedDetails(let arg):
                var d = try Serialization.getFields(TeamLog.FolderLinkRestrictionPolicyChangedDetailsSerializer().serialize(arg))
                d[".tag"] = .str("folder_link_restriction_policy_changed_details")
                return .dictionary(d)
            case .googleSsoChangePolicyDetails(let arg):
                var d = try Serialization.getFields(TeamLog.GoogleSsoChangePolicyDetailsSerializer().serialize(arg))
                d[".tag"] = .str("google_sso_change_policy_details")
                return .dictionary(d)
            case .groupUserManagementChangePolicyDetails(let arg):
                var d = try Serialization.getFields(TeamLog.GroupUserManagementChangePolicyDetailsSerializer().serialize(arg))
                d[".tag"] = .str("group_user_management_change_policy_details")
                return .dictionary(d)
            case .integrationPolicyChangedDetails(let arg):
                var d = try Serialization.getFields(TeamLog.IntegrationPolicyChangedDetailsSerializer().serialize(arg))
                d[".tag"] = .str("integration_policy_changed_details")
                return .dictionary(d)
            case .inviteAcceptanceEmailPolicyChangedDetails(let arg):
                var d = try Serialization.getFields(TeamLog.InviteAcceptanceEmailPolicyChangedDetailsSerializer().serialize(arg))
                d[".tag"] = .str("invite_acceptance_email_policy_changed_details")
                return .dictionary(d)
            case .memberRequestsChangePolicyDetails(let arg):
                var d = try Serialization.getFields(TeamLog.MemberRequestsChangePolicyDetailsSerializer().serialize(arg))
                d[".tag"] = .str("member_requests_change_policy_details")
                return .dictionary(d)
            case .memberSendInvitePolicyChangedDetails(let arg):
                var d = try Serialization.getFields(TeamLog.MemberSendInvitePolicyChangedDetailsSerializer().serialize(arg))
                d[".tag"] = .str("member_send_invite_policy_changed_details")
                return .dictionary(d)
            case .memberSpaceLimitsAddExceptionDetails(let arg):
                var d = try Serialization.getFields(TeamLog.MemberSpaceLimitsAddExceptionDetailsSerializer().serialize(arg))
                d[".tag"] = .str("member_space_limits_add_exception_details")
                return .dictionary(d)
            case .memberSpaceLimitsChangeCapsTypePolicyDetails(let arg):
                var d = try Serialization.getFields(TeamLog.MemberSpaceLimitsChangeCapsTypePolicyDetailsSerializer().serialize(arg))
                d[".tag"] = .str("member_space_limits_change_caps_type_policy_details")
                return .dictionary(d)
            case .memberSpaceLimitsChangePolicyDetails(let arg):
                var d = try Serialization.getFields(TeamLog.MemberSpaceLimitsChangePolicyDetailsSerializer().serialize(arg))
                d[".tag"] = .str("member_space_limits_change_policy_details")
                return .dictionary(d)
            case .memberSpaceLimitsRemoveExceptionDetails(let arg):
                var d = try Serialization.getFields(TeamLog.MemberSpaceLimitsRemoveExceptionDetailsSerializer().serialize(arg))
                d[".tag"] = .str("member_space_limits_remove_exception_details")
                return .dictionary(d)
            case .memberSuggestionsChangePolicyDetails(let arg):
                var d = try Serialization.getFields(TeamLog.MemberSuggestionsChangePolicyDetailsSerializer().serialize(arg))
                d[".tag"] = .str("member_suggestions_change_policy_details")
                return .dictionary(d)
            case .microsoftOfficeAddinChangePolicyDetails(let arg):
                var d = try Serialization.getFields(TeamLog.MicrosoftOfficeAddinChangePolicyDetailsSerializer().serialize(arg))
                d[".tag"] = .str("microsoft_office_addin_change_policy_details")
                return .dictionary(d)
            case .networkControlChangePolicyDetails(let arg):
                var d = try Serialization.getFields(TeamLog.NetworkControlChangePolicyDetailsSerializer().serialize(arg))
                d[".tag"] = .str("network_control_change_policy_details")
                return .dictionary(d)
            case .paperChangeDeploymentPolicyDetails(let arg):
                var d = try Serialization.getFields(TeamLog.PaperChangeDeploymentPolicyDetailsSerializer().serialize(arg))
                d[".tag"] = .str("paper_change_deployment_policy_details")
                return .dictionary(d)
            case .paperChangeMemberLinkPolicyDetails(let arg):
                var d = try Serialization.getFields(TeamLog.PaperChangeMemberLinkPolicyDetailsSerializer().serialize(arg))
                d[".tag"] = .str("paper_change_member_link_policy_details")
                return .dictionary(d)
            case .paperChangeMemberPolicyDetails(let arg):
                var d = try Serialization.getFields(TeamLog.PaperChangeMemberPolicyDetailsSerializer().serialize(arg))
                d[".tag"] = .str("paper_change_member_policy_details")
                return .dictionary(d)
            case .paperChangePolicyDetails(let arg):
                var d = try Serialization.getFields(TeamLog.PaperChangePolicyDetailsSerializer().serialize(arg))
                d[".tag"] = .str("paper_change_policy_details")
                return .dictionary(d)
            case .paperDefaultFolderPolicyChangedDetails(let arg):
                var d = try Serialization.getFields(TeamLog.PaperDefaultFolderPolicyChangedDetailsSerializer().serialize(arg))
                d[".tag"] = .str("paper_default_folder_policy_changed_details")
                return .dictionary(d)
            case .paperDesktopPolicyChangedDetails(let arg):
                var d = try Serialization.getFields(TeamLog.PaperDesktopPolicyChangedDetailsSerializer().serialize(arg))
                d[".tag"] = .str("paper_desktop_policy_changed_details")
                return .dictionary(d)
            case .paperEnabledUsersGroupAdditionDetails(let arg):
                var d = try Serialization.getFields(TeamLog.PaperEnabledUsersGroupAdditionDetailsSerializer().serialize(arg))
                d[".tag"] = .str("paper_enabled_users_group_addition_details")
                return .dictionary(d)
            case .paperEnabledUsersGroupRemovalDetails(let arg):
                var d = try Serialization.getFields(TeamLog.PaperEnabledUsersGroupRemovalDetailsSerializer().serialize(arg))
                d[".tag"] = .str("paper_enabled_users_group_removal_details")
                return .dictionary(d)
            case .passwordStrengthRequirementsChangePolicyDetails(let arg):
                var d = try Serialization.getFields(TeamLog.PasswordStrengthRequirementsChangePolicyDetailsSerializer().serialize(arg))
                d[".tag"] = .str("password_strength_requirements_change_policy_details")
                return .dictionary(d)
            case .permanentDeleteChangePolicyDetails(let arg):
                var d = try Serialization.getFields(TeamLog.PermanentDeleteChangePolicyDetailsSerializer().serialize(arg))
                d[".tag"] = .str("permanent_delete_change_policy_details")
                return .dictionary(d)
            case .resellerSupportChangePolicyDetails(let arg):
                var d = try Serialization.getFields(TeamLog.ResellerSupportChangePolicyDetailsSerializer().serialize(arg))
                d[".tag"] = .str("reseller_support_change_policy_details")
                return .dictionary(d)
            case .rewindPolicyChangedDetails(let arg):
                var d = try Serialization.getFields(TeamLog.RewindPolicyChangedDetailsSerializer().serialize(arg))
                d[".tag"] = .str("rewind_policy_changed_details")
                return .dictionary(d)
            case .sendForSignaturePolicyChangedDetails(let arg):
                var d = try Serialization.getFields(TeamLog.SendForSignaturePolicyChangedDetailsSerializer().serialize(arg))
                d[".tag"] = .str("send_for_signature_policy_changed_details")
                return .dictionary(d)
            case .sharingChangeFolderJoinPolicyDetails(let arg):
                var d = try Serialization.getFields(TeamLog.SharingChangeFolderJoinPolicyDetailsSerializer().serialize(arg))
                d[".tag"] = .str("sharing_change_folder_join_policy_details")
                return .dictionary(d)
            case .sharingChangeLinkAllowChangeExpirationPolicyDetails(let arg):
                var d = try Serialization.getFields(TeamLog.SharingChangeLinkAllowChangeExpirationPolicyDetailsSerializer().serialize(arg))
                d[".tag"] = .str("sharing_change_link_allow_change_expiration_policy_details")
                return .dictionary(d)
            case .sharingChangeLinkDefaultExpirationPolicyDetails(let arg):
                var d = try Serialization.getFields(TeamLog.SharingChangeLinkDefaultExpirationPolicyDetailsSerializer().serialize(arg))
                d[".tag"] = .str("sharing_change_link_default_expiration_policy_details")
                return .dictionary(d)
            case .sharingChangeLinkEnforcePasswordPolicyDetails(let arg):
                var d = try Serialization.getFields(TeamLog.SharingChangeLinkEnforcePasswordPolicyDetailsSerializer().serialize(arg))
                d[".tag"] = .str("sharing_change_link_enforce_password_policy_details")
                return .dictionary(d)
            case .sharingChangeLinkPolicyDetails(let arg):
                var d = try Serialization.getFields(TeamLog.SharingChangeLinkPolicyDetailsSerializer().serialize(arg))
                d[".tag"] = .str("sharing_change_link_policy_details")
                return .dictionary(d)
            case .sharingChangeMemberPolicyDetails(let arg):
                var d = try Serialization.getFields(TeamLog.SharingChangeMemberPolicyDetailsSerializer().serialize(arg))
                d[".tag"] = .str("sharing_change_member_policy_details")
                return .dictionary(d)
            case .showcaseChangeDownloadPolicyDetails(let arg):
                var d = try Serialization.getFields(TeamLog.ShowcaseChangeDownloadPolicyDetailsSerializer().serialize(arg))
                d[".tag"] = .str("showcase_change_download_policy_details")
                return .dictionary(d)
            case .showcaseChangeEnabledPolicyDetails(let arg):
                var d = try Serialization.getFields(TeamLog.ShowcaseChangeEnabledPolicyDetailsSerializer().serialize(arg))
                d[".tag"] = .str("showcase_change_enabled_policy_details")
                return .dictionary(d)
            case .showcaseChangeExternalSharingPolicyDetails(let arg):
                var d = try Serialization.getFields(TeamLog.ShowcaseChangeExternalSharingPolicyDetailsSerializer().serialize(arg))
                d[".tag"] = .str("showcase_change_external_sharing_policy_details")
                return .dictionary(d)
            case .smarterSmartSyncPolicyChangedDetails(let arg):
                var d = try Serialization.getFields(TeamLog.SmarterSmartSyncPolicyChangedDetailsSerializer().serialize(arg))
                d[".tag"] = .str("smarter_smart_sync_policy_changed_details")
                return .dictionary(d)
            case .smartSyncChangePolicyDetails(let arg):
                var d = try Serialization.getFields(TeamLog.SmartSyncChangePolicyDetailsSerializer().serialize(arg))
                d[".tag"] = .str("smart_sync_change_policy_details")
                return .dictionary(d)
            case .smartSyncNotOptOutDetails(let arg):
                var d = try Serialization.getFields(TeamLog.SmartSyncNotOptOutDetailsSerializer().serialize(arg))
                d[".tag"] = .str("smart_sync_not_opt_out_details")
                return .dictionary(d)
            case .smartSyncOptOutDetails(let arg):
                var d = try Serialization.getFields(TeamLog.SmartSyncOptOutDetailsSerializer().serialize(arg))
                d[".tag"] = .str("smart_sync_opt_out_details")
                return .dictionary(d)
            case .ssoChangePolicyDetails(let arg):
                var d = try Serialization.getFields(TeamLog.SsoChangePolicyDetailsSerializer().serialize(arg))
                d[".tag"] = .str("sso_change_policy_details")
                return .dictionary(d)
            case .teamBrandingPolicyChangedDetails(let arg):
                var d = try Serialization.getFields(TeamLog.TeamBrandingPolicyChangedDetailsSerializer().serialize(arg))
                d[".tag"] = .str("team_branding_policy_changed_details")
                return .dictionary(d)
            case .teamExtensionsPolicyChangedDetails(let arg):
                var d = try Serialization.getFields(TeamLog.TeamExtensionsPolicyChangedDetailsSerializer().serialize(arg))
                d[".tag"] = .str("team_extensions_policy_changed_details")
                return .dictionary(d)
            case .teamSelectiveSyncPolicyChangedDetails(let arg):
                var d = try Serialization.getFields(TeamLog.TeamSelectiveSyncPolicyChangedDetailsSerializer().serialize(arg))
                d[".tag"] = .str("team_selective_sync_policy_changed_details")
                return .dictionary(d)
            case .teamSharingWhitelistSubjectsChangedDetails(let arg):
                var d = try Serialization.getFields(TeamLog.TeamSharingWhitelistSubjectsChangedDetailsSerializer().serialize(arg))
                d[".tag"] = .str("team_sharing_whitelist_subjects_changed_details")
                return .dictionary(d)
            case .tfaAddExceptionDetails(let arg):
                var d = try Serialization.getFields(TeamLog.TfaAddExceptionDetailsSerializer().serialize(arg))
                d[".tag"] = .str("tfa_add_exception_details")
                return .dictionary(d)
            case .tfaChangePolicyDetails(let arg):
                var d = try Serialization.getFields(TeamLog.TfaChangePolicyDetailsSerializer().serialize(arg))
                d[".tag"] = .str("tfa_change_policy_details")
                return .dictionary(d)
            case .tfaRemoveExceptionDetails(let arg):
                var d = try Serialization.getFields(TeamLog.TfaRemoveExceptionDetailsSerializer().serialize(arg))
                d[".tag"] = .str("tfa_remove_exception_details")
                return .dictionary(d)
            case .twoAccountChangePolicyDetails(let arg):
                var d = try Serialization.getFields(TeamLog.TwoAccountChangePolicyDetailsSerializer().serialize(arg))
                d[".tag"] = .str("two_account_change_policy_details")
                return .dictionary(d)
            case .viewerInfoPolicyChangedDetails(let arg):
                var d = try Serialization.getFields(TeamLog.ViewerInfoPolicyChangedDetailsSerializer().serialize(arg))
                d[".tag"] = .str("viewer_info_policy_changed_details")
                return .dictionary(d)
            case .watermarkingPolicyChangedDetails(let arg):
                var d = try Serialization.getFields(TeamLog.WatermarkingPolicyChangedDetailsSerializer().serialize(arg))
                d[".tag"] = .str("watermarking_policy_changed_details")
                return .dictionary(d)
            case .webSessionsChangeActiveSessionLimitDetails(let arg):
                var d = try Serialization.getFields(TeamLog.WebSessionsChangeActiveSessionLimitDetailsSerializer().serialize(arg))
                d[".tag"] = .str("web_sessions_change_active_session_limit_details")
                return .dictionary(d)
            case .webSessionsChangeFixedLengthPolicyDetails(let arg):
                var d = try Serialization.getFields(TeamLog.WebSessionsChangeFixedLengthPolicyDetailsSerializer().serialize(arg))
                d[".tag"] = .str("web_sessions_change_fixed_length_policy_details")
                return .dictionary(d)
            case .webSessionsChangeIdleLengthPolicyDetails(let arg):
                var d = try Serialization.getFields(TeamLog.WebSessionsChangeIdleLengthPolicyDetailsSerializer().serialize(arg))
                d[".tag"] = .str("web_sessions_change_idle_length_policy_details")
                return .dictionary(d)
            case .dataResidencyMigrationRequestSuccessfulDetails(let arg):
                var d = try Serialization.getFields(TeamLog.DataResidencyMigrationRequestSuccessfulDetailsSerializer().serialize(arg))
                d[".tag"] = .str("data_residency_migration_request_successful_details")
                return .dictionary(d)
            case .dataResidencyMigrationRequestUnsuccessfulDetails(let arg):
                var d = try Serialization.getFields(TeamLog.DataResidencyMigrationRequestUnsuccessfulDetailsSerializer().serialize(arg))
                d[".tag"] = .str("data_residency_migration_request_unsuccessful_details")
                return .dictionary(d)
            case .teamMergeFromDetails(let arg):
                var d = try Serialization.getFields(TeamLog.TeamMergeFromDetailsSerializer().serialize(arg))
                d[".tag"] = .str("team_merge_from_details")
                return .dictionary(d)
            case .teamMergeToDetails(let arg):
                var d = try Serialization.getFields(TeamLog.TeamMergeToDetailsSerializer().serialize(arg))
                d[".tag"] = .str("team_merge_to_details")
                return .dictionary(d)
            case .teamProfileAddBackgroundDetails(let arg):
                var d = try Serialization.getFields(TeamLog.TeamProfileAddBackgroundDetailsSerializer().serialize(arg))
                d[".tag"] = .str("team_profile_add_background_details")
                return .dictionary(d)
            case .teamProfileAddLogoDetails(let arg):
                var d = try Serialization.getFields(TeamLog.TeamProfileAddLogoDetailsSerializer().serialize(arg))
                d[".tag"] = .str("team_profile_add_logo_details")
                return .dictionary(d)
            case .teamProfileChangeBackgroundDetails(let arg):
                var d = try Serialization.getFields(TeamLog.TeamProfileChangeBackgroundDetailsSerializer().serialize(arg))
                d[".tag"] = .str("team_profile_change_background_details")
                return .dictionary(d)
            case .teamProfileChangeDefaultLanguageDetails(let arg):
                var d = try Serialization.getFields(TeamLog.TeamProfileChangeDefaultLanguageDetailsSerializer().serialize(arg))
                d[".tag"] = .str("team_profile_change_default_language_details")
                return .dictionary(d)
            case .teamProfileChangeLogoDetails(let arg):
                var d = try Serialization.getFields(TeamLog.TeamProfileChangeLogoDetailsSerializer().serialize(arg))
                d[".tag"] = .str("team_profile_change_logo_details")
                return .dictionary(d)
            case .teamProfileChangeNameDetails(let arg):
                var d = try Serialization.getFields(TeamLog.TeamProfileChangeNameDetailsSerializer().serialize(arg))
                d[".tag"] = .str("team_profile_change_name_details")
                return .dictionary(d)
            case .teamProfileRemoveBackgroundDetails(let arg):
                var d = try Serialization.getFields(TeamLog.TeamProfileRemoveBackgroundDetailsSerializer().serialize(arg))
                d[".tag"] = .str("team_profile_remove_background_details")
                return .dictionary(d)
            case .teamProfileRemoveLogoDetails(let arg):
                var d = try Serialization.getFields(TeamLog.TeamProfileRemoveLogoDetailsSerializer().serialize(arg))
                d[".tag"] = .str("team_profile_remove_logo_details")
                return .dictionary(d)
            case .tfaAddBackupPhoneDetails(let arg):
                var d = try Serialization.getFields(TeamLog.TfaAddBackupPhoneDetailsSerializer().serialize(arg))
                d[".tag"] = .str("tfa_add_backup_phone_details")
                return .dictionary(d)
            case .tfaAddSecurityKeyDetails(let arg):
                var d = try Serialization.getFields(TeamLog.TfaAddSecurityKeyDetailsSerializer().serialize(arg))
                d[".tag"] = .str("tfa_add_security_key_details")
                return .dictionary(d)
            case .tfaChangeBackupPhoneDetails(let arg):
                var d = try Serialization.getFields(TeamLog.TfaChangeBackupPhoneDetailsSerializer().serialize(arg))
                d[".tag"] = .str("tfa_change_backup_phone_details")
                return .dictionary(d)
            case .tfaChangeStatusDetails(let arg):
                var d = try Serialization.getFields(TeamLog.TfaChangeStatusDetailsSerializer().serialize(arg))
                d[".tag"] = .str("tfa_change_status_details")
                return .dictionary(d)
            case .tfaRemoveBackupPhoneDetails(let arg):
                var d = try Serialization.getFields(TeamLog.TfaRemoveBackupPhoneDetailsSerializer().serialize(arg))
                d[".tag"] = .str("tfa_remove_backup_phone_details")
                return .dictionary(d)
            case .tfaRemoveSecurityKeyDetails(let arg):
                var d = try Serialization.getFields(TeamLog.TfaRemoveSecurityKeyDetailsSerializer().serialize(arg))
                d[".tag"] = .str("tfa_remove_security_key_details")
                return .dictionary(d)
            case .tfaResetDetails(let arg):
                var d = try Serialization.getFields(TeamLog.TfaResetDetailsSerializer().serialize(arg))
                d[".tag"] = .str("tfa_reset_details")
                return .dictionary(d)
            case .changedEnterpriseAdminRoleDetails(let arg):
                var d = try Serialization.getFields(TeamLog.ChangedEnterpriseAdminRoleDetailsSerializer().serialize(arg))
                d[".tag"] = .str("changed_enterprise_admin_role_details")
                return .dictionary(d)
            case .changedEnterpriseConnectedTeamStatusDetails(let arg):
                var d = try Serialization.getFields(TeamLog.ChangedEnterpriseConnectedTeamStatusDetailsSerializer().serialize(arg))
                d[".tag"] = .str("changed_enterprise_connected_team_status_details")
                return .dictionary(d)
            case .endedEnterpriseAdminSessionDetails(let arg):
                var d = try Serialization.getFields(TeamLog.EndedEnterpriseAdminSessionDetailsSerializer().serialize(arg))
                d[".tag"] = .str("ended_enterprise_admin_session_details")
                return .dictionary(d)
            case .endedEnterpriseAdminSessionDeprecatedDetails(let arg):
                var d = try Serialization.getFields(TeamLog.EndedEnterpriseAdminSessionDeprecatedDetailsSerializer().serialize(arg))
                d[".tag"] = .str("ended_enterprise_admin_session_deprecated_details")
                return .dictionary(d)
            case .enterpriseSettingsLockingDetails(let arg):
                var d = try Serialization.getFields(TeamLog.EnterpriseSettingsLockingDetailsSerializer().serialize(arg))
                d[".tag"] = .str("enterprise_settings_locking_details")
                return .dictionary(d)
            case .guestAdminChangeStatusDetails(let arg):
                var d = try Serialization.getFields(TeamLog.GuestAdminChangeStatusDetailsSerializer().serialize(arg))
                d[".tag"] = .str("guest_admin_change_status_details")
                return .dictionary(d)
            case .startedEnterpriseAdminSessionDetails(let arg):
                var d = try Serialization.getFields(TeamLog.StartedEnterpriseAdminSessionDetailsSerializer().serialize(arg))
                d[".tag"] = .str("started_enterprise_admin_session_details")
                return .dictionary(d)
            case .teamMergeRequestAcceptedDetails(let arg):
                var d = try Serialization.getFields(TeamLog.TeamMergeRequestAcceptedDetailsSerializer().serialize(arg))
                d[".tag"] = .str("team_merge_request_accepted_details")
                return .dictionary(d)
            case .teamMergeRequestAcceptedShownToPrimaryTeamDetails(let arg):
                var d = try Serialization.getFields(TeamLog.TeamMergeRequestAcceptedShownToPrimaryTeamDetailsSerializer().serialize(arg))
                d[".tag"] = .str("team_merge_request_accepted_shown_to_primary_team_details")
                return .dictionary(d)
            case .teamMergeRequestAcceptedShownToSecondaryTeamDetails(let arg):
                var d = try Serialization.getFields(TeamLog.TeamMergeRequestAcceptedShownToSecondaryTeamDetailsSerializer().serialize(arg))
                d[".tag"] = .str("team_merge_request_accepted_shown_to_secondary_team_details")
                return .dictionary(d)
            case .teamMergeRequestAutoCanceledDetails(let arg):
                var d = try Serialization.getFields(TeamLog.TeamMergeRequestAutoCanceledDetailsSerializer().serialize(arg))
                d[".tag"] = .str("team_merge_request_auto_canceled_details")
                return .dictionary(d)
            case .teamMergeRequestCanceledDetails(let arg):
                var d = try Serialization.getFields(TeamLog.TeamMergeRequestCanceledDetailsSerializer().serialize(arg))
                d[".tag"] = .str("team_merge_request_canceled_details")
                return .dictionary(d)
            case .teamMergeRequestCanceledShownToPrimaryTeamDetails(let arg):
                var d = try Serialization.getFields(TeamLog.TeamMergeRequestCanceledShownToPrimaryTeamDetailsSerializer().serialize(arg))
                d[".tag"] = .str("team_merge_request_canceled_shown_to_primary_team_details")
                return .dictionary(d)
            case .teamMergeRequestCanceledShownToSecondaryTeamDetails(let arg):
                var d = try Serialization.getFields(TeamLog.TeamMergeRequestCanceledShownToSecondaryTeamDetailsSerializer().serialize(arg))
                d[".tag"] = .str("team_merge_request_canceled_shown_to_secondary_team_details")
                return .dictionary(d)
            case .teamMergeRequestExpiredDetails(let arg):
                var d = try Serialization.getFields(TeamLog.TeamMergeRequestExpiredDetailsSerializer().serialize(arg))
                d[".tag"] = .str("team_merge_request_expired_details")
                return .dictionary(d)
            case .teamMergeRequestExpiredShownToPrimaryTeamDetails(let arg):
                var d = try Serialization.getFields(TeamLog.TeamMergeRequestExpiredShownToPrimaryTeamDetailsSerializer().serialize(arg))
                d[".tag"] = .str("team_merge_request_expired_shown_to_primary_team_details")
                return .dictionary(d)
            case .teamMergeRequestExpiredShownToSecondaryTeamDetails(let arg):
                var d = try Serialization.getFields(TeamLog.TeamMergeRequestExpiredShownToSecondaryTeamDetailsSerializer().serialize(arg))
                d[".tag"] = .str("team_merge_request_expired_shown_to_secondary_team_details")
                return .dictionary(d)
            case .teamMergeRequestRejectedShownToPrimaryTeamDetails(let arg):
                var d = try Serialization.getFields(TeamLog.TeamMergeRequestRejectedShownToPrimaryTeamDetailsSerializer().serialize(arg))
                d[".tag"] = .str("team_merge_request_rejected_shown_to_primary_team_details")
                return .dictionary(d)
            case .teamMergeRequestRejectedShownToSecondaryTeamDetails(let arg):
                var d = try Serialization.getFields(TeamLog.TeamMergeRequestRejectedShownToSecondaryTeamDetailsSerializer().serialize(arg))
                d[".tag"] = .str("team_merge_request_rejected_shown_to_secondary_team_details")
                return .dictionary(d)
            case .teamMergeRequestReminderDetails(let arg):
                var d = try Serialization.getFields(TeamLog.TeamMergeRequestReminderDetailsSerializer().serialize(arg))
                d[".tag"] = .str("team_merge_request_reminder_details")
                return .dictionary(d)
            case .teamMergeRequestReminderShownToPrimaryTeamDetails(let arg):
                var d = try Serialization.getFields(TeamLog.TeamMergeRequestReminderShownToPrimaryTeamDetailsSerializer().serialize(arg))
                d[".tag"] = .str("team_merge_request_reminder_shown_to_primary_team_details")
                return .dictionary(d)
            case .teamMergeRequestReminderShownToSecondaryTeamDetails(let arg):
                var d = try Serialization.getFields(TeamLog.TeamMergeRequestReminderShownToSecondaryTeamDetailsSerializer().serialize(arg))
                d[".tag"] = .str("team_merge_request_reminder_shown_to_secondary_team_details")
                return .dictionary(d)
            case .teamMergeRequestRevokedDetails(let arg):
                var d = try Serialization.getFields(TeamLog.TeamMergeRequestRevokedDetailsSerializer().serialize(arg))
                d[".tag"] = .str("team_merge_request_revoked_details")
                return .dictionary(d)
            case .teamMergeRequestSentShownToPrimaryTeamDetails(let arg):
                var d = try Serialization.getFields(TeamLog.TeamMergeRequestSentShownToPrimaryTeamDetailsSerializer().serialize(arg))
                d[".tag"] = .str("team_merge_request_sent_shown_to_primary_team_details")
                return .dictionary(d)
            case .teamMergeRequestSentShownToSecondaryTeamDetails(let arg):
                var d = try Serialization.getFields(TeamLog.TeamMergeRequestSentShownToSecondaryTeamDetailsSerializer().serialize(arg))
                d[".tag"] = .str("team_merge_request_sent_shown_to_secondary_team_details")
                return .dictionary(d)
            case .missingDetails(let arg):
                var d = try Serialization.getFields(TeamLog.MissingDetailsSerializer().serialize(arg))
                d[".tag"] = .str("missing_details")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> EventDetails {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "admin_alerting_alert_state_changed_details":
                    let v = try TeamLog.AdminAlertingAlertStateChangedDetailsSerializer().deserialize(json)
                    return EventDetails.adminAlertingAlertStateChangedDetails(v)
                case "admin_alerting_changed_alert_config_details":
                    let v = try TeamLog.AdminAlertingChangedAlertConfigDetailsSerializer().deserialize(json)
                    return EventDetails.adminAlertingChangedAlertConfigDetails(v)
                case "admin_alerting_triggered_alert_details":
                    let v = try TeamLog.AdminAlertingTriggeredAlertDetailsSerializer().deserialize(json)
                    return EventDetails.adminAlertingTriggeredAlertDetails(v)
                case "ransomware_restore_process_completed_details":
                    let v = try TeamLog.RansomwareRestoreProcessCompletedDetailsSerializer().deserialize(json)
                    return EventDetails.ransomwareRestoreProcessCompletedDetails(v)
                case "ransomware_restore_process_started_details":
                    let v = try TeamLog.RansomwareRestoreProcessStartedDetailsSerializer().deserialize(json)
                    return EventDetails.ransomwareRestoreProcessStartedDetails(v)
                case "app_blocked_by_permissions_details":
                    let v = try TeamLog.AppBlockedByPermissionsDetailsSerializer().deserialize(json)
                    return EventDetails.appBlockedByPermissionsDetails(v)
                case "app_link_team_details":
                    let v = try TeamLog.AppLinkTeamDetailsSerializer().deserialize(json)
                    return EventDetails.appLinkTeamDetails(v)
                case "app_link_user_details":
                    let v = try TeamLog.AppLinkUserDetailsSerializer().deserialize(json)
                    return EventDetails.appLinkUserDetails(v)
                case "app_unlink_team_details":
                    let v = try TeamLog.AppUnlinkTeamDetailsSerializer().deserialize(json)
                    return EventDetails.appUnlinkTeamDetails(v)
                case "app_unlink_user_details":
                    let v = try TeamLog.AppUnlinkUserDetailsSerializer().deserialize(json)
                    return EventDetails.appUnlinkUserDetails(v)
                case "integration_connected_details":
                    let v = try TeamLog.IntegrationConnectedDetailsSerializer().deserialize(json)
                    return EventDetails.integrationConnectedDetails(v)
                case "integration_disconnected_details":
                    let v = try TeamLog.IntegrationDisconnectedDetailsSerializer().deserialize(json)
                    return EventDetails.integrationDisconnectedDetails(v)
                case "file_add_comment_details":
                    let v = try TeamLog.FileAddCommentDetailsSerializer().deserialize(json)
                    return EventDetails.fileAddCommentDetails(v)
                case "file_change_comment_subscription_details":
                    let v = try TeamLog.FileChangeCommentSubscriptionDetailsSerializer().deserialize(json)
                    return EventDetails.fileChangeCommentSubscriptionDetails(v)
                case "file_delete_comment_details":
                    let v = try TeamLog.FileDeleteCommentDetailsSerializer().deserialize(json)
                    return EventDetails.fileDeleteCommentDetails(v)
                case "file_edit_comment_details":
                    let v = try TeamLog.FileEditCommentDetailsSerializer().deserialize(json)
                    return EventDetails.fileEditCommentDetails(v)
                case "file_like_comment_details":
                    let v = try TeamLog.FileLikeCommentDetailsSerializer().deserialize(json)
                    return EventDetails.fileLikeCommentDetails(v)
                case "file_resolve_comment_details":
                    let v = try TeamLog.FileResolveCommentDetailsSerializer().deserialize(json)
                    return EventDetails.fileResolveCommentDetails(v)
                case "file_unlike_comment_details":
                    let v = try TeamLog.FileUnlikeCommentDetailsSerializer().deserialize(json)
                    return EventDetails.fileUnlikeCommentDetails(v)
                case "file_unresolve_comment_details":
                    let v = try TeamLog.FileUnresolveCommentDetailsSerializer().deserialize(json)
                    return EventDetails.fileUnresolveCommentDetails(v)
                case "governance_policy_add_folders_details":
                    let v = try TeamLog.GovernancePolicyAddFoldersDetailsSerializer().deserialize(json)
                    return EventDetails.governancePolicyAddFoldersDetails(v)
                case "governance_policy_add_folder_failed_details":
                    let v = try TeamLog.GovernancePolicyAddFolderFailedDetailsSerializer().deserialize(json)
                    return EventDetails.governancePolicyAddFolderFailedDetails(v)
                case "governance_policy_content_disposed_details":
                    let v = try TeamLog.GovernancePolicyContentDisposedDetailsSerializer().deserialize(json)
                    return EventDetails.governancePolicyContentDisposedDetails(v)
                case "governance_policy_create_details":
                    let v = try TeamLog.GovernancePolicyCreateDetailsSerializer().deserialize(json)
                    return EventDetails.governancePolicyCreateDetails(v)
                case "governance_policy_delete_details":
                    let v = try TeamLog.GovernancePolicyDeleteDetailsSerializer().deserialize(json)
                    return EventDetails.governancePolicyDeleteDetails(v)
                case "governance_policy_edit_details_details":
                    let v = try TeamLog.GovernancePolicyEditDetailsDetailsSerializer().deserialize(json)
                    return EventDetails.governancePolicyEditDetailsDetails(v)
                case "governance_policy_edit_duration_details":
                    let v = try TeamLog.GovernancePolicyEditDurationDetailsSerializer().deserialize(json)
                    return EventDetails.governancePolicyEditDurationDetails(v)
                case "governance_policy_export_created_details":
                    let v = try TeamLog.GovernancePolicyExportCreatedDetailsSerializer().deserialize(json)
                    return EventDetails.governancePolicyExportCreatedDetails(v)
                case "governance_policy_export_removed_details":
                    let v = try TeamLog.GovernancePolicyExportRemovedDetailsSerializer().deserialize(json)
                    return EventDetails.governancePolicyExportRemovedDetails(v)
                case "governance_policy_remove_folders_details":
                    let v = try TeamLog.GovernancePolicyRemoveFoldersDetailsSerializer().deserialize(json)
                    return EventDetails.governancePolicyRemoveFoldersDetails(v)
                case "governance_policy_report_created_details":
                    let v = try TeamLog.GovernancePolicyReportCreatedDetailsSerializer().deserialize(json)
                    return EventDetails.governancePolicyReportCreatedDetails(v)
                case "governance_policy_zip_part_downloaded_details":
                    let v = try TeamLog.GovernancePolicyZipPartDownloadedDetailsSerializer().deserialize(json)
                    return EventDetails.governancePolicyZipPartDownloadedDetails(v)
                case "legal_holds_activate_a_hold_details":
                    let v = try TeamLog.LegalHoldsActivateAHoldDetailsSerializer().deserialize(json)
                    return EventDetails.legalHoldsActivateAHoldDetails(v)
                case "legal_holds_add_members_details":
                    let v = try TeamLog.LegalHoldsAddMembersDetailsSerializer().deserialize(json)
                    return EventDetails.legalHoldsAddMembersDetails(v)
                case "legal_holds_change_hold_details_details":
                    let v = try TeamLog.LegalHoldsChangeHoldDetailsDetailsSerializer().deserialize(json)
                    return EventDetails.legalHoldsChangeHoldDetailsDetails(v)
                case "legal_holds_change_hold_name_details":
                    let v = try TeamLog.LegalHoldsChangeHoldNameDetailsSerializer().deserialize(json)
                    return EventDetails.legalHoldsChangeHoldNameDetails(v)
                case "legal_holds_export_a_hold_details":
                    let v = try TeamLog.LegalHoldsExportAHoldDetailsSerializer().deserialize(json)
                    return EventDetails.legalHoldsExportAHoldDetails(v)
                case "legal_holds_export_cancelled_details":
                    let v = try TeamLog.LegalHoldsExportCancelledDetailsSerializer().deserialize(json)
                    return EventDetails.legalHoldsExportCancelledDetails(v)
                case "legal_holds_export_downloaded_details":
                    let v = try TeamLog.LegalHoldsExportDownloadedDetailsSerializer().deserialize(json)
                    return EventDetails.legalHoldsExportDownloadedDetails(v)
                case "legal_holds_export_removed_details":
                    let v = try TeamLog.LegalHoldsExportRemovedDetailsSerializer().deserialize(json)
                    return EventDetails.legalHoldsExportRemovedDetails(v)
                case "legal_holds_release_a_hold_details":
                    let v = try TeamLog.LegalHoldsReleaseAHoldDetailsSerializer().deserialize(json)
                    return EventDetails.legalHoldsReleaseAHoldDetails(v)
                case "legal_holds_remove_members_details":
                    let v = try TeamLog.LegalHoldsRemoveMembersDetailsSerializer().deserialize(json)
                    return EventDetails.legalHoldsRemoveMembersDetails(v)
                case "legal_holds_report_a_hold_details":
                    let v = try TeamLog.LegalHoldsReportAHoldDetailsSerializer().deserialize(json)
                    return EventDetails.legalHoldsReportAHoldDetails(v)
                case "device_change_ip_desktop_details":
                    let v = try TeamLog.DeviceChangeIpDesktopDetailsSerializer().deserialize(json)
                    return EventDetails.deviceChangeIpDesktopDetails(v)
                case "device_change_ip_mobile_details":
                    let v = try TeamLog.DeviceChangeIpMobileDetailsSerializer().deserialize(json)
                    return EventDetails.deviceChangeIpMobileDetails(v)
                case "device_change_ip_web_details":
                    let v = try TeamLog.DeviceChangeIpWebDetailsSerializer().deserialize(json)
                    return EventDetails.deviceChangeIpWebDetails(v)
                case "device_delete_on_unlink_fail_details":
                    let v = try TeamLog.DeviceDeleteOnUnlinkFailDetailsSerializer().deserialize(json)
                    return EventDetails.deviceDeleteOnUnlinkFailDetails(v)
                case "device_delete_on_unlink_success_details":
                    let v = try TeamLog.DeviceDeleteOnUnlinkSuccessDetailsSerializer().deserialize(json)
                    return EventDetails.deviceDeleteOnUnlinkSuccessDetails(v)
                case "device_link_fail_details":
                    let v = try TeamLog.DeviceLinkFailDetailsSerializer().deserialize(json)
                    return EventDetails.deviceLinkFailDetails(v)
                case "device_link_success_details":
                    let v = try TeamLog.DeviceLinkSuccessDetailsSerializer().deserialize(json)
                    return EventDetails.deviceLinkSuccessDetails(v)
                case "device_management_disabled_details":
                    let v = try TeamLog.DeviceManagementDisabledDetailsSerializer().deserialize(json)
                    return EventDetails.deviceManagementDisabledDetails(v)
                case "device_management_enabled_details":
                    let v = try TeamLog.DeviceManagementEnabledDetailsSerializer().deserialize(json)
                    return EventDetails.deviceManagementEnabledDetails(v)
                case "device_sync_backup_status_changed_details":
                    let v = try TeamLog.DeviceSyncBackupStatusChangedDetailsSerializer().deserialize(json)
                    return EventDetails.deviceSyncBackupStatusChangedDetails(v)
                case "device_unlink_details":
                    let v = try TeamLog.DeviceUnlinkDetailsSerializer().deserialize(json)
                    return EventDetails.deviceUnlinkDetails(v)
                case "dropbox_passwords_exported_details":
                    let v = try TeamLog.DropboxPasswordsExportedDetailsSerializer().deserialize(json)
                    return EventDetails.dropboxPasswordsExportedDetails(v)
                case "dropbox_passwords_new_device_enrolled_details":
                    let v = try TeamLog.DropboxPasswordsNewDeviceEnrolledDetailsSerializer().deserialize(json)
                    return EventDetails.dropboxPasswordsNewDeviceEnrolledDetails(v)
                case "emm_refresh_auth_token_details":
                    let v = try TeamLog.EmmRefreshAuthTokenDetailsSerializer().deserialize(json)
                    return EventDetails.emmRefreshAuthTokenDetails(v)
                case "external_drive_backup_eligibility_status_checked_details":
                    let v = try TeamLog.ExternalDriveBackupEligibilityStatusCheckedDetailsSerializer().deserialize(json)
                    return EventDetails.externalDriveBackupEligibilityStatusCheckedDetails(v)
                case "external_drive_backup_status_changed_details":
                    let v = try TeamLog.ExternalDriveBackupStatusChangedDetailsSerializer().deserialize(json)
                    return EventDetails.externalDriveBackupStatusChangedDetails(v)
                case "account_capture_change_availability_details":
                    let v = try TeamLog.AccountCaptureChangeAvailabilityDetailsSerializer().deserialize(json)
                    return EventDetails.accountCaptureChangeAvailabilityDetails(v)
                case "account_capture_migrate_account_details":
                    let v = try TeamLog.AccountCaptureMigrateAccountDetailsSerializer().deserialize(json)
                    return EventDetails.accountCaptureMigrateAccountDetails(v)
                case "account_capture_notification_emails_sent_details":
                    let v = try TeamLog.AccountCaptureNotificationEmailsSentDetailsSerializer().deserialize(json)
                    return EventDetails.accountCaptureNotificationEmailsSentDetails(v)
                case "account_capture_relinquish_account_details":
                    let v = try TeamLog.AccountCaptureRelinquishAccountDetailsSerializer().deserialize(json)
                    return EventDetails.accountCaptureRelinquishAccountDetails(v)
                case "disabled_domain_invites_details":
                    let v = try TeamLog.DisabledDomainInvitesDetailsSerializer().deserialize(json)
                    return EventDetails.disabledDomainInvitesDetails(v)
                case "domain_invites_approve_request_to_join_team_details":
                    let v = try TeamLog.DomainInvitesApproveRequestToJoinTeamDetailsSerializer().deserialize(json)
                    return EventDetails.domainInvitesApproveRequestToJoinTeamDetails(v)
                case "domain_invites_decline_request_to_join_team_details":
                    let v = try TeamLog.DomainInvitesDeclineRequestToJoinTeamDetailsSerializer().deserialize(json)
                    return EventDetails.domainInvitesDeclineRequestToJoinTeamDetails(v)
                case "domain_invites_email_existing_users_details":
                    let v = try TeamLog.DomainInvitesEmailExistingUsersDetailsSerializer().deserialize(json)
                    return EventDetails.domainInvitesEmailExistingUsersDetails(v)
                case "domain_invites_request_to_join_team_details":
                    let v = try TeamLog.DomainInvitesRequestToJoinTeamDetailsSerializer().deserialize(json)
                    return EventDetails.domainInvitesRequestToJoinTeamDetails(v)
                case "domain_invites_set_invite_new_user_pref_to_no_details":
                    let v = try TeamLog.DomainInvitesSetInviteNewUserPrefToNoDetailsSerializer().deserialize(json)
                    return EventDetails.domainInvitesSetInviteNewUserPrefToNoDetails(v)
                case "domain_invites_set_invite_new_user_pref_to_yes_details":
                    let v = try TeamLog.DomainInvitesSetInviteNewUserPrefToYesDetailsSerializer().deserialize(json)
                    return EventDetails.domainInvitesSetInviteNewUserPrefToYesDetails(v)
                case "domain_verification_add_domain_fail_details":
                    let v = try TeamLog.DomainVerificationAddDomainFailDetailsSerializer().deserialize(json)
                    return EventDetails.domainVerificationAddDomainFailDetails(v)
                case "domain_verification_add_domain_success_details":
                    let v = try TeamLog.DomainVerificationAddDomainSuccessDetailsSerializer().deserialize(json)
                    return EventDetails.domainVerificationAddDomainSuccessDetails(v)
                case "domain_verification_remove_domain_details":
                    let v = try TeamLog.DomainVerificationRemoveDomainDetailsSerializer().deserialize(json)
                    return EventDetails.domainVerificationRemoveDomainDetails(v)
                case "enabled_domain_invites_details":
                    let v = try TeamLog.EnabledDomainInvitesDetailsSerializer().deserialize(json)
                    return EventDetails.enabledDomainInvitesDetails(v)
                case "team_encryption_key_cancel_key_deletion_details":
                    let v = try TeamLog.TeamEncryptionKeyCancelKeyDeletionDetailsSerializer().deserialize(json)
                    return EventDetails.teamEncryptionKeyCancelKeyDeletionDetails(v)
                case "team_encryption_key_create_key_details":
                    let v = try TeamLog.TeamEncryptionKeyCreateKeyDetailsSerializer().deserialize(json)
                    return EventDetails.teamEncryptionKeyCreateKeyDetails(v)
                case "team_encryption_key_delete_key_details":
                    let v = try TeamLog.TeamEncryptionKeyDeleteKeyDetailsSerializer().deserialize(json)
                    return EventDetails.teamEncryptionKeyDeleteKeyDetails(v)
                case "team_encryption_key_disable_key_details":
                    let v = try TeamLog.TeamEncryptionKeyDisableKeyDetailsSerializer().deserialize(json)
                    return EventDetails.teamEncryptionKeyDisableKeyDetails(v)
                case "team_encryption_key_enable_key_details":
                    let v = try TeamLog.TeamEncryptionKeyEnableKeyDetailsSerializer().deserialize(json)
                    return EventDetails.teamEncryptionKeyEnableKeyDetails(v)
                case "team_encryption_key_rotate_key_details":
                    let v = try TeamLog.TeamEncryptionKeyRotateKeyDetailsSerializer().deserialize(json)
                    return EventDetails.teamEncryptionKeyRotateKeyDetails(v)
                case "team_encryption_key_schedule_key_deletion_details":
                    let v = try TeamLog.TeamEncryptionKeyScheduleKeyDeletionDetailsSerializer().deserialize(json)
                    return EventDetails.teamEncryptionKeyScheduleKeyDeletionDetails(v)
                case "apply_naming_convention_details":
                    let v = try TeamLog.ApplyNamingConventionDetailsSerializer().deserialize(json)
                    return EventDetails.applyNamingConventionDetails(v)
                case "create_folder_details":
                    let v = try TeamLog.CreateFolderDetailsSerializer().deserialize(json)
                    return EventDetails.createFolderDetails(v)
                case "file_add_details":
                    let v = try TeamLog.FileAddDetailsSerializer().deserialize(json)
                    return EventDetails.fileAddDetails(v)
                case "file_add_from_automation_details":
                    let v = try TeamLog.FileAddFromAutomationDetailsSerializer().deserialize(json)
                    return EventDetails.fileAddFromAutomationDetails(v)
                case "file_copy_details":
                    let v = try TeamLog.FileCopyDetailsSerializer().deserialize(json)
                    return EventDetails.fileCopyDetails(v)
                case "file_delete_details":
                    let v = try TeamLog.FileDeleteDetailsSerializer().deserialize(json)
                    return EventDetails.fileDeleteDetails(v)
                case "file_download_details":
                    let v = try TeamLog.FileDownloadDetailsSerializer().deserialize(json)
                    return EventDetails.fileDownloadDetails(v)
                case "file_edit_details":
                    let v = try TeamLog.FileEditDetailsSerializer().deserialize(json)
                    return EventDetails.fileEditDetails(v)
                case "file_get_copy_reference_details":
                    let v = try TeamLog.FileGetCopyReferenceDetailsSerializer().deserialize(json)
                    return EventDetails.fileGetCopyReferenceDetails(v)
                case "file_locking_lock_status_changed_details":
                    let v = try TeamLog.FileLockingLockStatusChangedDetailsSerializer().deserialize(json)
                    return EventDetails.fileLockingLockStatusChangedDetails(v)
                case "file_move_details":
                    let v = try TeamLog.FileMoveDetailsSerializer().deserialize(json)
                    return EventDetails.fileMoveDetails(v)
                case "file_permanently_delete_details":
                    let v = try TeamLog.FilePermanentlyDeleteDetailsSerializer().deserialize(json)
                    return EventDetails.filePermanentlyDeleteDetails(v)
                case "file_preview_details":
                    let v = try TeamLog.FilePreviewDetailsSerializer().deserialize(json)
                    return EventDetails.filePreviewDetails(v)
                case "file_rename_details":
                    let v = try TeamLog.FileRenameDetailsSerializer().deserialize(json)
                    return EventDetails.fileRenameDetails(v)
                case "file_restore_details":
                    let v = try TeamLog.FileRestoreDetailsSerializer().deserialize(json)
                    return EventDetails.fileRestoreDetails(v)
                case "file_revert_details":
                    let v = try TeamLog.FileRevertDetailsSerializer().deserialize(json)
                    return EventDetails.fileRevertDetails(v)
                case "file_rollback_changes_details":
                    let v = try TeamLog.FileRollbackChangesDetailsSerializer().deserialize(json)
                    return EventDetails.fileRollbackChangesDetails(v)
                case "file_save_copy_reference_details":
                    let v = try TeamLog.FileSaveCopyReferenceDetailsSerializer().deserialize(json)
                    return EventDetails.fileSaveCopyReferenceDetails(v)
                case "folder_overview_description_changed_details":
                    let v = try TeamLog.FolderOverviewDescriptionChangedDetailsSerializer().deserialize(json)
                    return EventDetails.folderOverviewDescriptionChangedDetails(v)
                case "folder_overview_item_pinned_details":
                    let v = try TeamLog.FolderOverviewItemPinnedDetailsSerializer().deserialize(json)
                    return EventDetails.folderOverviewItemPinnedDetails(v)
                case "folder_overview_item_unpinned_details":
                    let v = try TeamLog.FolderOverviewItemUnpinnedDetailsSerializer().deserialize(json)
                    return EventDetails.folderOverviewItemUnpinnedDetails(v)
                case "object_label_added_details":
                    let v = try TeamLog.ObjectLabelAddedDetailsSerializer().deserialize(json)
                    return EventDetails.objectLabelAddedDetails(v)
                case "object_label_removed_details":
                    let v = try TeamLog.ObjectLabelRemovedDetailsSerializer().deserialize(json)
                    return EventDetails.objectLabelRemovedDetails(v)
                case "object_label_updated_value_details":
                    let v = try TeamLog.ObjectLabelUpdatedValueDetailsSerializer().deserialize(json)
                    return EventDetails.objectLabelUpdatedValueDetails(v)
                case "organize_folder_with_tidy_details":
                    let v = try TeamLog.OrganizeFolderWithTidyDetailsSerializer().deserialize(json)
                    return EventDetails.organizeFolderWithTidyDetails(v)
                case "replay_file_delete_details":
                    let v = try TeamLog.ReplayFileDeleteDetailsSerializer().deserialize(json)
                    return EventDetails.replayFileDeleteDetails(v)
                case "rewind_folder_details":
                    let v = try TeamLog.RewindFolderDetailsSerializer().deserialize(json)
                    return EventDetails.rewindFolderDetails(v)
                case "undo_naming_convention_details":
                    let v = try TeamLog.UndoNamingConventionDetailsSerializer().deserialize(json)
                    return EventDetails.undoNamingConventionDetails(v)
                case "undo_organize_folder_with_tidy_details":
                    let v = try TeamLog.UndoOrganizeFolderWithTidyDetailsSerializer().deserialize(json)
                    return EventDetails.undoOrganizeFolderWithTidyDetails(v)
                case "user_tags_added_details":
                    let v = try TeamLog.UserTagsAddedDetailsSerializer().deserialize(json)
                    return EventDetails.userTagsAddedDetails(v)
                case "user_tags_removed_details":
                    let v = try TeamLog.UserTagsRemovedDetailsSerializer().deserialize(json)
                    return EventDetails.userTagsRemovedDetails(v)
                case "email_ingest_receive_file_details":
                    let v = try TeamLog.EmailIngestReceiveFileDetailsSerializer().deserialize(json)
                    return EventDetails.emailIngestReceiveFileDetails(v)
                case "file_request_change_details":
                    let v = try TeamLog.FileRequestChangeDetailsSerializer().deserialize(json)
                    return EventDetails.fileRequestChangeDetails(v)
                case "file_request_close_details":
                    let v = try TeamLog.FileRequestCloseDetailsSerializer().deserialize(json)
                    return EventDetails.fileRequestCloseDetails(v)
                case "file_request_create_details":
                    let v = try TeamLog.FileRequestCreateDetailsSerializer().deserialize(json)
                    return EventDetails.fileRequestCreateDetails(v)
                case "file_request_delete_details":
                    let v = try TeamLog.FileRequestDeleteDetailsSerializer().deserialize(json)
                    return EventDetails.fileRequestDeleteDetails(v)
                case "file_request_receive_file_details":
                    let v = try TeamLog.FileRequestReceiveFileDetailsSerializer().deserialize(json)
                    return EventDetails.fileRequestReceiveFileDetails(v)
                case "group_add_external_id_details":
                    let v = try TeamLog.GroupAddExternalIdDetailsSerializer().deserialize(json)
                    return EventDetails.groupAddExternalIdDetails(v)
                case "group_add_member_details":
                    let v = try TeamLog.GroupAddMemberDetailsSerializer().deserialize(json)
                    return EventDetails.groupAddMemberDetails(v)
                case "group_change_external_id_details":
                    let v = try TeamLog.GroupChangeExternalIdDetailsSerializer().deserialize(json)
                    return EventDetails.groupChangeExternalIdDetails(v)
                case "group_change_management_type_details":
                    let v = try TeamLog.GroupChangeManagementTypeDetailsSerializer().deserialize(json)
                    return EventDetails.groupChangeManagementTypeDetails(v)
                case "group_change_member_role_details":
                    let v = try TeamLog.GroupChangeMemberRoleDetailsSerializer().deserialize(json)
                    return EventDetails.groupChangeMemberRoleDetails(v)
                case "group_create_details":
                    let v = try TeamLog.GroupCreateDetailsSerializer().deserialize(json)
                    return EventDetails.groupCreateDetails(v)
                case "group_delete_details":
                    let v = try TeamLog.GroupDeleteDetailsSerializer().deserialize(json)
                    return EventDetails.groupDeleteDetails(v)
                case "group_description_updated_details":
                    let v = try TeamLog.GroupDescriptionUpdatedDetailsSerializer().deserialize(json)
                    return EventDetails.groupDescriptionUpdatedDetails(v)
                case "group_join_policy_updated_details":
                    let v = try TeamLog.GroupJoinPolicyUpdatedDetailsSerializer().deserialize(json)
                    return EventDetails.groupJoinPolicyUpdatedDetails(v)
                case "group_moved_details":
                    let v = try TeamLog.GroupMovedDetailsSerializer().deserialize(json)
                    return EventDetails.groupMovedDetails(v)
                case "group_remove_external_id_details":
                    let v = try TeamLog.GroupRemoveExternalIdDetailsSerializer().deserialize(json)
                    return EventDetails.groupRemoveExternalIdDetails(v)
                case "group_remove_member_details":
                    let v = try TeamLog.GroupRemoveMemberDetailsSerializer().deserialize(json)
                    return EventDetails.groupRemoveMemberDetails(v)
                case "group_rename_details":
                    let v = try TeamLog.GroupRenameDetailsSerializer().deserialize(json)
                    return EventDetails.groupRenameDetails(v)
                case "account_lock_or_unlocked_details":
                    let v = try TeamLog.AccountLockOrUnlockedDetailsSerializer().deserialize(json)
                    return EventDetails.accountLockOrUnlockedDetails(v)
                case "emm_error_details":
                    let v = try TeamLog.EmmErrorDetailsSerializer().deserialize(json)
                    return EventDetails.emmErrorDetails(v)
                case "guest_admin_signed_in_via_trusted_teams_details":
                    let v = try TeamLog.GuestAdminSignedInViaTrustedTeamsDetailsSerializer().deserialize(json)
                    return EventDetails.guestAdminSignedInViaTrustedTeamsDetails(v)
                case "guest_admin_signed_out_via_trusted_teams_details":
                    let v = try TeamLog.GuestAdminSignedOutViaTrustedTeamsDetailsSerializer().deserialize(json)
                    return EventDetails.guestAdminSignedOutViaTrustedTeamsDetails(v)
                case "login_fail_details":
                    let v = try TeamLog.LoginFailDetailsSerializer().deserialize(json)
                    return EventDetails.loginFailDetails(v)
                case "login_success_details":
                    let v = try TeamLog.LoginSuccessDetailsSerializer().deserialize(json)
                    return EventDetails.loginSuccessDetails(v)
                case "logout_details":
                    let v = try TeamLog.LogoutDetailsSerializer().deserialize(json)
                    return EventDetails.logoutDetails(v)
                case "reseller_support_session_end_details":
                    let v = try TeamLog.ResellerSupportSessionEndDetailsSerializer().deserialize(json)
                    return EventDetails.resellerSupportSessionEndDetails(v)
                case "reseller_support_session_start_details":
                    let v = try TeamLog.ResellerSupportSessionStartDetailsSerializer().deserialize(json)
                    return EventDetails.resellerSupportSessionStartDetails(v)
                case "sign_in_as_session_end_details":
                    let v = try TeamLog.SignInAsSessionEndDetailsSerializer().deserialize(json)
                    return EventDetails.signInAsSessionEndDetails(v)
                case "sign_in_as_session_start_details":
                    let v = try TeamLog.SignInAsSessionStartDetailsSerializer().deserialize(json)
                    return EventDetails.signInAsSessionStartDetails(v)
                case "sso_error_details":
                    let v = try TeamLog.SsoErrorDetailsSerializer().deserialize(json)
                    return EventDetails.ssoErrorDetails(v)
                case "backup_admin_invitation_sent_details":
                    let v = try TeamLog.BackupAdminInvitationSentDetailsSerializer().deserialize(json)
                    return EventDetails.backupAdminInvitationSentDetails(v)
                case "backup_invitation_opened_details":
                    let v = try TeamLog.BackupInvitationOpenedDetailsSerializer().deserialize(json)
                    return EventDetails.backupInvitationOpenedDetails(v)
                case "create_team_invite_link_details":
                    let v = try TeamLog.CreateTeamInviteLinkDetailsSerializer().deserialize(json)
                    return EventDetails.createTeamInviteLinkDetails(v)
                case "delete_team_invite_link_details":
                    let v = try TeamLog.DeleteTeamInviteLinkDetailsSerializer().deserialize(json)
                    return EventDetails.deleteTeamInviteLinkDetails(v)
                case "member_add_external_id_details":
                    let v = try TeamLog.MemberAddExternalIdDetailsSerializer().deserialize(json)
                    return EventDetails.memberAddExternalIdDetails(v)
                case "member_add_name_details":
                    let v = try TeamLog.MemberAddNameDetailsSerializer().deserialize(json)
                    return EventDetails.memberAddNameDetails(v)
                case "member_change_admin_role_details":
                    let v = try TeamLog.MemberChangeAdminRoleDetailsSerializer().deserialize(json)
                    return EventDetails.memberChangeAdminRoleDetails(v)
                case "member_change_email_details":
                    let v = try TeamLog.MemberChangeEmailDetailsSerializer().deserialize(json)
                    return EventDetails.memberChangeEmailDetails(v)
                case "member_change_external_id_details":
                    let v = try TeamLog.MemberChangeExternalIdDetailsSerializer().deserialize(json)
                    return EventDetails.memberChangeExternalIdDetails(v)
                case "member_change_membership_type_details":
                    let v = try TeamLog.MemberChangeMembershipTypeDetailsSerializer().deserialize(json)
                    return EventDetails.memberChangeMembershipTypeDetails(v)
                case "member_change_name_details":
                    let v = try TeamLog.MemberChangeNameDetailsSerializer().deserialize(json)
                    return EventDetails.memberChangeNameDetails(v)
                case "member_change_reseller_role_details":
                    let v = try TeamLog.MemberChangeResellerRoleDetailsSerializer().deserialize(json)
                    return EventDetails.memberChangeResellerRoleDetails(v)
                case "member_change_status_details":
                    let v = try TeamLog.MemberChangeStatusDetailsSerializer().deserialize(json)
                    return EventDetails.memberChangeStatusDetails(v)
                case "member_delete_manual_contacts_details":
                    let v = try TeamLog.MemberDeleteManualContactsDetailsSerializer().deserialize(json)
                    return EventDetails.memberDeleteManualContactsDetails(v)
                case "member_delete_profile_photo_details":
                    let v = try TeamLog.MemberDeleteProfilePhotoDetailsSerializer().deserialize(json)
                    return EventDetails.memberDeleteProfilePhotoDetails(v)
                case "member_permanently_delete_account_contents_details":
                    let v = try TeamLog.MemberPermanentlyDeleteAccountContentsDetailsSerializer().deserialize(json)
                    return EventDetails.memberPermanentlyDeleteAccountContentsDetails(v)
                case "member_remove_external_id_details":
                    let v = try TeamLog.MemberRemoveExternalIdDetailsSerializer().deserialize(json)
                    return EventDetails.memberRemoveExternalIdDetails(v)
                case "member_set_profile_photo_details":
                    let v = try TeamLog.MemberSetProfilePhotoDetailsSerializer().deserialize(json)
                    return EventDetails.memberSetProfilePhotoDetails(v)
                case "member_space_limits_add_custom_quota_details":
                    let v = try TeamLog.MemberSpaceLimitsAddCustomQuotaDetailsSerializer().deserialize(json)
                    return EventDetails.memberSpaceLimitsAddCustomQuotaDetails(v)
                case "member_space_limits_change_custom_quota_details":
                    let v = try TeamLog.MemberSpaceLimitsChangeCustomQuotaDetailsSerializer().deserialize(json)
                    return EventDetails.memberSpaceLimitsChangeCustomQuotaDetails(v)
                case "member_space_limits_change_status_details":
                    let v = try TeamLog.MemberSpaceLimitsChangeStatusDetailsSerializer().deserialize(json)
                    return EventDetails.memberSpaceLimitsChangeStatusDetails(v)
                case "member_space_limits_remove_custom_quota_details":
                    let v = try TeamLog.MemberSpaceLimitsRemoveCustomQuotaDetailsSerializer().deserialize(json)
                    return EventDetails.memberSpaceLimitsRemoveCustomQuotaDetails(v)
                case "member_suggest_details":
                    let v = try TeamLog.MemberSuggestDetailsSerializer().deserialize(json)
                    return EventDetails.memberSuggestDetails(v)
                case "member_transfer_account_contents_details":
                    let v = try TeamLog.MemberTransferAccountContentsDetailsSerializer().deserialize(json)
                    return EventDetails.memberTransferAccountContentsDetails(v)
                case "pending_secondary_email_added_details":
                    let v = try TeamLog.PendingSecondaryEmailAddedDetailsSerializer().deserialize(json)
                    return EventDetails.pendingSecondaryEmailAddedDetails(v)
                case "secondary_email_deleted_details":
                    let v = try TeamLog.SecondaryEmailDeletedDetailsSerializer().deserialize(json)
                    return EventDetails.secondaryEmailDeletedDetails(v)
                case "secondary_email_verified_details":
                    let v = try TeamLog.SecondaryEmailVerifiedDetailsSerializer().deserialize(json)
                    return EventDetails.secondaryEmailVerifiedDetails(v)
                case "secondary_mails_policy_changed_details":
                    let v = try TeamLog.SecondaryMailsPolicyChangedDetailsSerializer().deserialize(json)
                    return EventDetails.secondaryMailsPolicyChangedDetails(v)
                case "binder_add_page_details":
                    let v = try TeamLog.BinderAddPageDetailsSerializer().deserialize(json)
                    return EventDetails.binderAddPageDetails(v)
                case "binder_add_section_details":
                    let v = try TeamLog.BinderAddSectionDetailsSerializer().deserialize(json)
                    return EventDetails.binderAddSectionDetails(v)
                case "binder_remove_page_details":
                    let v = try TeamLog.BinderRemovePageDetailsSerializer().deserialize(json)
                    return EventDetails.binderRemovePageDetails(v)
                case "binder_remove_section_details":
                    let v = try TeamLog.BinderRemoveSectionDetailsSerializer().deserialize(json)
                    return EventDetails.binderRemoveSectionDetails(v)
                case "binder_rename_page_details":
                    let v = try TeamLog.BinderRenamePageDetailsSerializer().deserialize(json)
                    return EventDetails.binderRenamePageDetails(v)
                case "binder_rename_section_details":
                    let v = try TeamLog.BinderRenameSectionDetailsSerializer().deserialize(json)
                    return EventDetails.binderRenameSectionDetails(v)
                case "binder_reorder_page_details":
                    let v = try TeamLog.BinderReorderPageDetailsSerializer().deserialize(json)
                    return EventDetails.binderReorderPageDetails(v)
                case "binder_reorder_section_details":
                    let v = try TeamLog.BinderReorderSectionDetailsSerializer().deserialize(json)
                    return EventDetails.binderReorderSectionDetails(v)
                case "paper_content_add_member_details":
                    let v = try TeamLog.PaperContentAddMemberDetailsSerializer().deserialize(json)
                    return EventDetails.paperContentAddMemberDetails(v)
                case "paper_content_add_to_folder_details":
                    let v = try TeamLog.PaperContentAddToFolderDetailsSerializer().deserialize(json)
                    return EventDetails.paperContentAddToFolderDetails(v)
                case "paper_content_archive_details":
                    let v = try TeamLog.PaperContentArchiveDetailsSerializer().deserialize(json)
                    return EventDetails.paperContentArchiveDetails(v)
                case "paper_content_create_details":
                    let v = try TeamLog.PaperContentCreateDetailsSerializer().deserialize(json)
                    return EventDetails.paperContentCreateDetails(v)
                case "paper_content_permanently_delete_details":
                    let v = try TeamLog.PaperContentPermanentlyDeleteDetailsSerializer().deserialize(json)
                    return EventDetails.paperContentPermanentlyDeleteDetails(v)
                case "paper_content_remove_from_folder_details":
                    let v = try TeamLog.PaperContentRemoveFromFolderDetailsSerializer().deserialize(json)
                    return EventDetails.paperContentRemoveFromFolderDetails(v)
                case "paper_content_remove_member_details":
                    let v = try TeamLog.PaperContentRemoveMemberDetailsSerializer().deserialize(json)
                    return EventDetails.paperContentRemoveMemberDetails(v)
                case "paper_content_rename_details":
                    let v = try TeamLog.PaperContentRenameDetailsSerializer().deserialize(json)
                    return EventDetails.paperContentRenameDetails(v)
                case "paper_content_restore_details":
                    let v = try TeamLog.PaperContentRestoreDetailsSerializer().deserialize(json)
                    return EventDetails.paperContentRestoreDetails(v)
                case "paper_doc_add_comment_details":
                    let v = try TeamLog.PaperDocAddCommentDetailsSerializer().deserialize(json)
                    return EventDetails.paperDocAddCommentDetails(v)
                case "paper_doc_change_member_role_details":
                    let v = try TeamLog.PaperDocChangeMemberRoleDetailsSerializer().deserialize(json)
                    return EventDetails.paperDocChangeMemberRoleDetails(v)
                case "paper_doc_change_sharing_policy_details":
                    let v = try TeamLog.PaperDocChangeSharingPolicyDetailsSerializer().deserialize(json)
                    return EventDetails.paperDocChangeSharingPolicyDetails(v)
                case "paper_doc_change_subscription_details":
                    let v = try TeamLog.PaperDocChangeSubscriptionDetailsSerializer().deserialize(json)
                    return EventDetails.paperDocChangeSubscriptionDetails(v)
                case "paper_doc_deleted_details":
                    let v = try TeamLog.PaperDocDeletedDetailsSerializer().deserialize(json)
                    return EventDetails.paperDocDeletedDetails(v)
                case "paper_doc_delete_comment_details":
                    let v = try TeamLog.PaperDocDeleteCommentDetailsSerializer().deserialize(json)
                    return EventDetails.paperDocDeleteCommentDetails(v)
                case "paper_doc_download_details":
                    let v = try TeamLog.PaperDocDownloadDetailsSerializer().deserialize(json)
                    return EventDetails.paperDocDownloadDetails(v)
                case "paper_doc_edit_details":
                    let v = try TeamLog.PaperDocEditDetailsSerializer().deserialize(json)
                    return EventDetails.paperDocEditDetails(v)
                case "paper_doc_edit_comment_details":
                    let v = try TeamLog.PaperDocEditCommentDetailsSerializer().deserialize(json)
                    return EventDetails.paperDocEditCommentDetails(v)
                case "paper_doc_followed_details":
                    let v = try TeamLog.PaperDocFollowedDetailsSerializer().deserialize(json)
                    return EventDetails.paperDocFollowedDetails(v)
                case "paper_doc_mention_details":
                    let v = try TeamLog.PaperDocMentionDetailsSerializer().deserialize(json)
                    return EventDetails.paperDocMentionDetails(v)
                case "paper_doc_ownership_changed_details":
                    let v = try TeamLog.PaperDocOwnershipChangedDetailsSerializer().deserialize(json)
                    return EventDetails.paperDocOwnershipChangedDetails(v)
                case "paper_doc_request_access_details":
                    let v = try TeamLog.PaperDocRequestAccessDetailsSerializer().deserialize(json)
                    return EventDetails.paperDocRequestAccessDetails(v)
                case "paper_doc_resolve_comment_details":
                    let v = try TeamLog.PaperDocResolveCommentDetailsSerializer().deserialize(json)
                    return EventDetails.paperDocResolveCommentDetails(v)
                case "paper_doc_revert_details":
                    let v = try TeamLog.PaperDocRevertDetailsSerializer().deserialize(json)
                    return EventDetails.paperDocRevertDetails(v)
                case "paper_doc_slack_share_details":
                    let v = try TeamLog.PaperDocSlackShareDetailsSerializer().deserialize(json)
                    return EventDetails.paperDocSlackShareDetails(v)
                case "paper_doc_team_invite_details":
                    let v = try TeamLog.PaperDocTeamInviteDetailsSerializer().deserialize(json)
                    return EventDetails.paperDocTeamInviteDetails(v)
                case "paper_doc_trashed_details":
                    let v = try TeamLog.PaperDocTrashedDetailsSerializer().deserialize(json)
                    return EventDetails.paperDocTrashedDetails(v)
                case "paper_doc_unresolve_comment_details":
                    let v = try TeamLog.PaperDocUnresolveCommentDetailsSerializer().deserialize(json)
                    return EventDetails.paperDocUnresolveCommentDetails(v)
                case "paper_doc_untrashed_details":
                    let v = try TeamLog.PaperDocUntrashedDetailsSerializer().deserialize(json)
                    return EventDetails.paperDocUntrashedDetails(v)
                case "paper_doc_view_details":
                    let v = try TeamLog.PaperDocViewDetailsSerializer().deserialize(json)
                    return EventDetails.paperDocViewDetails(v)
                case "paper_external_view_allow_details":
                    let v = try TeamLog.PaperExternalViewAllowDetailsSerializer().deserialize(json)
                    return EventDetails.paperExternalViewAllowDetails(v)
                case "paper_external_view_default_team_details":
                    let v = try TeamLog.PaperExternalViewDefaultTeamDetailsSerializer().deserialize(json)
                    return EventDetails.paperExternalViewDefaultTeamDetails(v)
                case "paper_external_view_forbid_details":
                    let v = try TeamLog.PaperExternalViewForbidDetailsSerializer().deserialize(json)
                    return EventDetails.paperExternalViewForbidDetails(v)
                case "paper_folder_change_subscription_details":
                    let v = try TeamLog.PaperFolderChangeSubscriptionDetailsSerializer().deserialize(json)
                    return EventDetails.paperFolderChangeSubscriptionDetails(v)
                case "paper_folder_deleted_details":
                    let v = try TeamLog.PaperFolderDeletedDetailsSerializer().deserialize(json)
                    return EventDetails.paperFolderDeletedDetails(v)
                case "paper_folder_followed_details":
                    let v = try TeamLog.PaperFolderFollowedDetailsSerializer().deserialize(json)
                    return EventDetails.paperFolderFollowedDetails(v)
                case "paper_folder_team_invite_details":
                    let v = try TeamLog.PaperFolderTeamInviteDetailsSerializer().deserialize(json)
                    return EventDetails.paperFolderTeamInviteDetails(v)
                case "paper_published_link_change_permission_details":
                    let v = try TeamLog.PaperPublishedLinkChangePermissionDetailsSerializer().deserialize(json)
                    return EventDetails.paperPublishedLinkChangePermissionDetails(v)
                case "paper_published_link_create_details":
                    let v = try TeamLog.PaperPublishedLinkCreateDetailsSerializer().deserialize(json)
                    return EventDetails.paperPublishedLinkCreateDetails(v)
                case "paper_published_link_disabled_details":
                    let v = try TeamLog.PaperPublishedLinkDisabledDetailsSerializer().deserialize(json)
                    return EventDetails.paperPublishedLinkDisabledDetails(v)
                case "paper_published_link_view_details":
                    let v = try TeamLog.PaperPublishedLinkViewDetailsSerializer().deserialize(json)
                    return EventDetails.paperPublishedLinkViewDetails(v)
                case "password_change_details":
                    let v = try TeamLog.PasswordChangeDetailsSerializer().deserialize(json)
                    return EventDetails.passwordChangeDetails(v)
                case "password_reset_details":
                    let v = try TeamLog.PasswordResetDetailsSerializer().deserialize(json)
                    return EventDetails.passwordResetDetails(v)
                case "password_reset_all_details":
                    let v = try TeamLog.PasswordResetAllDetailsSerializer().deserialize(json)
                    return EventDetails.passwordResetAllDetails(v)
                case "classification_create_report_details":
                    let v = try TeamLog.ClassificationCreateReportDetailsSerializer().deserialize(json)
                    return EventDetails.classificationCreateReportDetails(v)
                case "classification_create_report_fail_details":
                    let v = try TeamLog.ClassificationCreateReportFailDetailsSerializer().deserialize(json)
                    return EventDetails.classificationCreateReportFailDetails(v)
                case "emm_create_exceptions_report_details":
                    let v = try TeamLog.EmmCreateExceptionsReportDetailsSerializer().deserialize(json)
                    return EventDetails.emmCreateExceptionsReportDetails(v)
                case "emm_create_usage_report_details":
                    let v = try TeamLog.EmmCreateUsageReportDetailsSerializer().deserialize(json)
                    return EventDetails.emmCreateUsageReportDetails(v)
                case "export_members_report_details":
                    let v = try TeamLog.ExportMembersReportDetailsSerializer().deserialize(json)
                    return EventDetails.exportMembersReportDetails(v)
                case "export_members_report_fail_details":
                    let v = try TeamLog.ExportMembersReportFailDetailsSerializer().deserialize(json)
                    return EventDetails.exportMembersReportFailDetails(v)
                case "external_sharing_create_report_details":
                    let v = try TeamLog.ExternalSharingCreateReportDetailsSerializer().deserialize(json)
                    return EventDetails.externalSharingCreateReportDetails(v)
                case "external_sharing_report_failed_details":
                    let v = try TeamLog.ExternalSharingReportFailedDetailsSerializer().deserialize(json)
                    return EventDetails.externalSharingReportFailedDetails(v)
                case "no_expiration_link_gen_create_report_details":
                    let v = try TeamLog.NoExpirationLinkGenCreateReportDetailsSerializer().deserialize(json)
                    return EventDetails.noExpirationLinkGenCreateReportDetails(v)
                case "no_expiration_link_gen_report_failed_details":
                    let v = try TeamLog.NoExpirationLinkGenReportFailedDetailsSerializer().deserialize(json)
                    return EventDetails.noExpirationLinkGenReportFailedDetails(v)
                case "no_password_link_gen_create_report_details":
                    let v = try TeamLog.NoPasswordLinkGenCreateReportDetailsSerializer().deserialize(json)
                    return EventDetails.noPasswordLinkGenCreateReportDetails(v)
                case "no_password_link_gen_report_failed_details":
                    let v = try TeamLog.NoPasswordLinkGenReportFailedDetailsSerializer().deserialize(json)
                    return EventDetails.noPasswordLinkGenReportFailedDetails(v)
                case "no_password_link_view_create_report_details":
                    let v = try TeamLog.NoPasswordLinkViewCreateReportDetailsSerializer().deserialize(json)
                    return EventDetails.noPasswordLinkViewCreateReportDetails(v)
                case "no_password_link_view_report_failed_details":
                    let v = try TeamLog.NoPasswordLinkViewReportFailedDetailsSerializer().deserialize(json)
                    return EventDetails.noPasswordLinkViewReportFailedDetails(v)
                case "outdated_link_view_create_report_details":
                    let v = try TeamLog.OutdatedLinkViewCreateReportDetailsSerializer().deserialize(json)
                    return EventDetails.outdatedLinkViewCreateReportDetails(v)
                case "outdated_link_view_report_failed_details":
                    let v = try TeamLog.OutdatedLinkViewReportFailedDetailsSerializer().deserialize(json)
                    return EventDetails.outdatedLinkViewReportFailedDetails(v)
                case "paper_admin_export_start_details":
                    let v = try TeamLog.PaperAdminExportStartDetailsSerializer().deserialize(json)
                    return EventDetails.paperAdminExportStartDetails(v)
                case "ransomware_alert_create_report_details":
                    let v = try TeamLog.RansomwareAlertCreateReportDetailsSerializer().deserialize(json)
                    return EventDetails.ransomwareAlertCreateReportDetails(v)
                case "ransomware_alert_create_report_failed_details":
                    let v = try TeamLog.RansomwareAlertCreateReportFailedDetailsSerializer().deserialize(json)
                    return EventDetails.ransomwareAlertCreateReportFailedDetails(v)
                case "smart_sync_create_admin_privilege_report_details":
                    let v = try TeamLog.SmartSyncCreateAdminPrivilegeReportDetailsSerializer().deserialize(json)
                    return EventDetails.smartSyncCreateAdminPrivilegeReportDetails(v)
                case "team_activity_create_report_details":
                    let v = try TeamLog.TeamActivityCreateReportDetailsSerializer().deserialize(json)
                    return EventDetails.teamActivityCreateReportDetails(v)
                case "team_activity_create_report_fail_details":
                    let v = try TeamLog.TeamActivityCreateReportFailDetailsSerializer().deserialize(json)
                    return EventDetails.teamActivityCreateReportFailDetails(v)
                case "collection_share_details":
                    let v = try TeamLog.CollectionShareDetailsSerializer().deserialize(json)
                    return EventDetails.collectionShareDetails(v)
                case "file_transfers_file_add_details":
                    let v = try TeamLog.FileTransfersFileAddDetailsSerializer().deserialize(json)
                    return EventDetails.fileTransfersFileAddDetails(v)
                case "file_transfers_transfer_delete_details":
                    let v = try TeamLog.FileTransfersTransferDeleteDetailsSerializer().deserialize(json)
                    return EventDetails.fileTransfersTransferDeleteDetails(v)
                case "file_transfers_transfer_download_details":
                    let v = try TeamLog.FileTransfersTransferDownloadDetailsSerializer().deserialize(json)
                    return EventDetails.fileTransfersTransferDownloadDetails(v)
                case "file_transfers_transfer_send_details":
                    let v = try TeamLog.FileTransfersTransferSendDetailsSerializer().deserialize(json)
                    return EventDetails.fileTransfersTransferSendDetails(v)
                case "file_transfers_transfer_view_details":
                    let v = try TeamLog.FileTransfersTransferViewDetailsSerializer().deserialize(json)
                    return EventDetails.fileTransfersTransferViewDetails(v)
                case "note_acl_invite_only_details":
                    let v = try TeamLog.NoteAclInviteOnlyDetailsSerializer().deserialize(json)
                    return EventDetails.noteAclInviteOnlyDetails(v)
                case "note_acl_link_details":
                    let v = try TeamLog.NoteAclLinkDetailsSerializer().deserialize(json)
                    return EventDetails.noteAclLinkDetails(v)
                case "note_acl_team_link_details":
                    let v = try TeamLog.NoteAclTeamLinkDetailsSerializer().deserialize(json)
                    return EventDetails.noteAclTeamLinkDetails(v)
                case "note_shared_details":
                    let v = try TeamLog.NoteSharedDetailsSerializer().deserialize(json)
                    return EventDetails.noteSharedDetails(v)
                case "note_share_receive_details":
                    let v = try TeamLog.NoteShareReceiveDetailsSerializer().deserialize(json)
                    return EventDetails.noteShareReceiveDetails(v)
                case "open_note_shared_details":
                    let v = try TeamLog.OpenNoteSharedDetailsSerializer().deserialize(json)
                    return EventDetails.openNoteSharedDetails(v)
                case "replay_file_shared_link_created_details":
                    let v = try TeamLog.ReplayFileSharedLinkCreatedDetailsSerializer().deserialize(json)
                    return EventDetails.replayFileSharedLinkCreatedDetails(v)
                case "replay_file_shared_link_modified_details":
                    let v = try TeamLog.ReplayFileSharedLinkModifiedDetailsSerializer().deserialize(json)
                    return EventDetails.replayFileSharedLinkModifiedDetails(v)
                case "replay_project_team_add_details":
                    let v = try TeamLog.ReplayProjectTeamAddDetailsSerializer().deserialize(json)
                    return EventDetails.replayProjectTeamAddDetails(v)
                case "replay_project_team_delete_details":
                    let v = try TeamLog.ReplayProjectTeamDeleteDetailsSerializer().deserialize(json)
                    return EventDetails.replayProjectTeamDeleteDetails(v)
                case "sf_add_group_details":
                    let v = try TeamLog.SfAddGroupDetailsSerializer().deserialize(json)
                    return EventDetails.sfAddGroupDetails(v)
                case "sf_allow_non_members_to_view_shared_links_details":
                    let v = try TeamLog.SfAllowNonMembersToViewSharedLinksDetailsSerializer().deserialize(json)
                    return EventDetails.sfAllowNonMembersToViewSharedLinksDetails(v)
                case "sf_external_invite_warn_details":
                    let v = try TeamLog.SfExternalInviteWarnDetailsSerializer().deserialize(json)
                    return EventDetails.sfExternalInviteWarnDetails(v)
                case "sf_fb_invite_details":
                    let v = try TeamLog.SfFbInviteDetailsSerializer().deserialize(json)
                    return EventDetails.sfFbInviteDetails(v)
                case "sf_fb_invite_change_role_details":
                    let v = try TeamLog.SfFbInviteChangeRoleDetailsSerializer().deserialize(json)
                    return EventDetails.sfFbInviteChangeRoleDetails(v)
                case "sf_fb_uninvite_details":
                    let v = try TeamLog.SfFbUninviteDetailsSerializer().deserialize(json)
                    return EventDetails.sfFbUninviteDetails(v)
                case "sf_invite_group_details":
                    let v = try TeamLog.SfInviteGroupDetailsSerializer().deserialize(json)
                    return EventDetails.sfInviteGroupDetails(v)
                case "sf_team_grant_access_details":
                    let v = try TeamLog.SfTeamGrantAccessDetailsSerializer().deserialize(json)
                    return EventDetails.sfTeamGrantAccessDetails(v)
                case "sf_team_invite_details":
                    let v = try TeamLog.SfTeamInviteDetailsSerializer().deserialize(json)
                    return EventDetails.sfTeamInviteDetails(v)
                case "sf_team_invite_change_role_details":
                    let v = try TeamLog.SfTeamInviteChangeRoleDetailsSerializer().deserialize(json)
                    return EventDetails.sfTeamInviteChangeRoleDetails(v)
                case "sf_team_join_details":
                    let v = try TeamLog.SfTeamJoinDetailsSerializer().deserialize(json)
                    return EventDetails.sfTeamJoinDetails(v)
                case "sf_team_join_from_oob_link_details":
                    let v = try TeamLog.SfTeamJoinFromOobLinkDetailsSerializer().deserialize(json)
                    return EventDetails.sfTeamJoinFromOobLinkDetails(v)
                case "sf_team_uninvite_details":
                    let v = try TeamLog.SfTeamUninviteDetailsSerializer().deserialize(json)
                    return EventDetails.sfTeamUninviteDetails(v)
                case "shared_content_add_invitees_details":
                    let v = try TeamLog.SharedContentAddInviteesDetailsSerializer().deserialize(json)
                    return EventDetails.sharedContentAddInviteesDetails(v)
                case "shared_content_add_link_expiry_details":
                    let v = try TeamLog.SharedContentAddLinkExpiryDetailsSerializer().deserialize(json)
                    return EventDetails.sharedContentAddLinkExpiryDetails(v)
                case "shared_content_add_link_password_details":
                    let v = try TeamLog.SharedContentAddLinkPasswordDetailsSerializer().deserialize(json)
                    return EventDetails.sharedContentAddLinkPasswordDetails(v)
                case "shared_content_add_member_details":
                    let v = try TeamLog.SharedContentAddMemberDetailsSerializer().deserialize(json)
                    return EventDetails.sharedContentAddMemberDetails(v)
                case "shared_content_change_downloads_policy_details":
                    let v = try TeamLog.SharedContentChangeDownloadsPolicyDetailsSerializer().deserialize(json)
                    return EventDetails.sharedContentChangeDownloadsPolicyDetails(v)
                case "shared_content_change_invitee_role_details":
                    let v = try TeamLog.SharedContentChangeInviteeRoleDetailsSerializer().deserialize(json)
                    return EventDetails.sharedContentChangeInviteeRoleDetails(v)
                case "shared_content_change_link_audience_details":
                    let v = try TeamLog.SharedContentChangeLinkAudienceDetailsSerializer().deserialize(json)
                    return EventDetails.sharedContentChangeLinkAudienceDetails(v)
                case "shared_content_change_link_expiry_details":
                    let v = try TeamLog.SharedContentChangeLinkExpiryDetailsSerializer().deserialize(json)
                    return EventDetails.sharedContentChangeLinkExpiryDetails(v)
                case "shared_content_change_link_password_details":
                    let v = try TeamLog.SharedContentChangeLinkPasswordDetailsSerializer().deserialize(json)
                    return EventDetails.sharedContentChangeLinkPasswordDetails(v)
                case "shared_content_change_member_role_details":
                    let v = try TeamLog.SharedContentChangeMemberRoleDetailsSerializer().deserialize(json)
                    return EventDetails.sharedContentChangeMemberRoleDetails(v)
                case "shared_content_change_viewer_info_policy_details":
                    let v = try TeamLog.SharedContentChangeViewerInfoPolicyDetailsSerializer().deserialize(json)
                    return EventDetails.sharedContentChangeViewerInfoPolicyDetails(v)
                case "shared_content_claim_invitation_details":
                    let v = try TeamLog.SharedContentClaimInvitationDetailsSerializer().deserialize(json)
                    return EventDetails.sharedContentClaimInvitationDetails(v)
                case "shared_content_copy_details":
                    let v = try TeamLog.SharedContentCopyDetailsSerializer().deserialize(json)
                    return EventDetails.sharedContentCopyDetails(v)
                case "shared_content_download_details":
                    let v = try TeamLog.SharedContentDownloadDetailsSerializer().deserialize(json)
                    return EventDetails.sharedContentDownloadDetails(v)
                case "shared_content_relinquish_membership_details":
                    let v = try TeamLog.SharedContentRelinquishMembershipDetailsSerializer().deserialize(json)
                    return EventDetails.sharedContentRelinquishMembershipDetails(v)
                case "shared_content_remove_invitees_details":
                    let v = try TeamLog.SharedContentRemoveInviteesDetailsSerializer().deserialize(json)
                    return EventDetails.sharedContentRemoveInviteesDetails(v)
                case "shared_content_remove_link_expiry_details":
                    let v = try TeamLog.SharedContentRemoveLinkExpiryDetailsSerializer().deserialize(json)
                    return EventDetails.sharedContentRemoveLinkExpiryDetails(v)
                case "shared_content_remove_link_password_details":
                    let v = try TeamLog.SharedContentRemoveLinkPasswordDetailsSerializer().deserialize(json)
                    return EventDetails.sharedContentRemoveLinkPasswordDetails(v)
                case "shared_content_remove_member_details":
                    let v = try TeamLog.SharedContentRemoveMemberDetailsSerializer().deserialize(json)
                    return EventDetails.sharedContentRemoveMemberDetails(v)
                case "shared_content_request_access_details":
                    let v = try TeamLog.SharedContentRequestAccessDetailsSerializer().deserialize(json)
                    return EventDetails.sharedContentRequestAccessDetails(v)
                case "shared_content_restore_invitees_details":
                    let v = try TeamLog.SharedContentRestoreInviteesDetailsSerializer().deserialize(json)
                    return EventDetails.sharedContentRestoreInviteesDetails(v)
                case "shared_content_restore_member_details":
                    let v = try TeamLog.SharedContentRestoreMemberDetailsSerializer().deserialize(json)
                    return EventDetails.sharedContentRestoreMemberDetails(v)
                case "shared_content_unshare_details":
                    let v = try TeamLog.SharedContentUnshareDetailsSerializer().deserialize(json)
                    return EventDetails.sharedContentUnshareDetails(v)
                case "shared_content_view_details":
                    let v = try TeamLog.SharedContentViewDetailsSerializer().deserialize(json)
                    return EventDetails.sharedContentViewDetails(v)
                case "shared_folder_change_link_policy_details":
                    let v = try TeamLog.SharedFolderChangeLinkPolicyDetailsSerializer().deserialize(json)
                    return EventDetails.sharedFolderChangeLinkPolicyDetails(v)
                case "shared_folder_change_members_inheritance_policy_details":
                    let v = try TeamLog.SharedFolderChangeMembersInheritancePolicyDetailsSerializer().deserialize(json)
                    return EventDetails.sharedFolderChangeMembersInheritancePolicyDetails(v)
                case "shared_folder_change_members_management_policy_details":
                    let v = try TeamLog.SharedFolderChangeMembersManagementPolicyDetailsSerializer().deserialize(json)
                    return EventDetails.sharedFolderChangeMembersManagementPolicyDetails(v)
                case "shared_folder_change_members_policy_details":
                    let v = try TeamLog.SharedFolderChangeMembersPolicyDetailsSerializer().deserialize(json)
                    return EventDetails.sharedFolderChangeMembersPolicyDetails(v)
                case "shared_folder_create_details":
                    let v = try TeamLog.SharedFolderCreateDetailsSerializer().deserialize(json)
                    return EventDetails.sharedFolderCreateDetails(v)
                case "shared_folder_decline_invitation_details":
                    let v = try TeamLog.SharedFolderDeclineInvitationDetailsSerializer().deserialize(json)
                    return EventDetails.sharedFolderDeclineInvitationDetails(v)
                case "shared_folder_mount_details":
                    let v = try TeamLog.SharedFolderMountDetailsSerializer().deserialize(json)
                    return EventDetails.sharedFolderMountDetails(v)
                case "shared_folder_nest_details":
                    let v = try TeamLog.SharedFolderNestDetailsSerializer().deserialize(json)
                    return EventDetails.sharedFolderNestDetails(v)
                case "shared_folder_transfer_ownership_details":
                    let v = try TeamLog.SharedFolderTransferOwnershipDetailsSerializer().deserialize(json)
                    return EventDetails.sharedFolderTransferOwnershipDetails(v)
                case "shared_folder_unmount_details":
                    let v = try TeamLog.SharedFolderUnmountDetailsSerializer().deserialize(json)
                    return EventDetails.sharedFolderUnmountDetails(v)
                case "shared_link_add_expiry_details":
                    let v = try TeamLog.SharedLinkAddExpiryDetailsSerializer().deserialize(json)
                    return EventDetails.sharedLinkAddExpiryDetails(v)
                case "shared_link_change_expiry_details":
                    let v = try TeamLog.SharedLinkChangeExpiryDetailsSerializer().deserialize(json)
                    return EventDetails.sharedLinkChangeExpiryDetails(v)
                case "shared_link_change_visibility_details":
                    let v = try TeamLog.SharedLinkChangeVisibilityDetailsSerializer().deserialize(json)
                    return EventDetails.sharedLinkChangeVisibilityDetails(v)
                case "shared_link_copy_details":
                    let v = try TeamLog.SharedLinkCopyDetailsSerializer().deserialize(json)
                    return EventDetails.sharedLinkCopyDetails(v)
                case "shared_link_create_details":
                    let v = try TeamLog.SharedLinkCreateDetailsSerializer().deserialize(json)
                    return EventDetails.sharedLinkCreateDetails(v)
                case "shared_link_disable_details":
                    let v = try TeamLog.SharedLinkDisableDetailsSerializer().deserialize(json)
                    return EventDetails.sharedLinkDisableDetails(v)
                case "shared_link_download_details":
                    let v = try TeamLog.SharedLinkDownloadDetailsSerializer().deserialize(json)
                    return EventDetails.sharedLinkDownloadDetails(v)
                case "shared_link_remove_expiry_details":
                    let v = try TeamLog.SharedLinkRemoveExpiryDetailsSerializer().deserialize(json)
                    return EventDetails.sharedLinkRemoveExpiryDetails(v)
                case "shared_link_settings_add_expiration_details":
                    let v = try TeamLog.SharedLinkSettingsAddExpirationDetailsSerializer().deserialize(json)
                    return EventDetails.sharedLinkSettingsAddExpirationDetails(v)
                case "shared_link_settings_add_password_details":
                    let v = try TeamLog.SharedLinkSettingsAddPasswordDetailsSerializer().deserialize(json)
                    return EventDetails.sharedLinkSettingsAddPasswordDetails(v)
                case "shared_link_settings_allow_download_disabled_details":
                    let v = try TeamLog.SharedLinkSettingsAllowDownloadDisabledDetailsSerializer().deserialize(json)
                    return EventDetails.sharedLinkSettingsAllowDownloadDisabledDetails(v)
                case "shared_link_settings_allow_download_enabled_details":
                    let v = try TeamLog.SharedLinkSettingsAllowDownloadEnabledDetailsSerializer().deserialize(json)
                    return EventDetails.sharedLinkSettingsAllowDownloadEnabledDetails(v)
                case "shared_link_settings_change_audience_details":
                    let v = try TeamLog.SharedLinkSettingsChangeAudienceDetailsSerializer().deserialize(json)
                    return EventDetails.sharedLinkSettingsChangeAudienceDetails(v)
                case "shared_link_settings_change_expiration_details":
                    let v = try TeamLog.SharedLinkSettingsChangeExpirationDetailsSerializer().deserialize(json)
                    return EventDetails.sharedLinkSettingsChangeExpirationDetails(v)
                case "shared_link_settings_change_password_details":
                    let v = try TeamLog.SharedLinkSettingsChangePasswordDetailsSerializer().deserialize(json)
                    return EventDetails.sharedLinkSettingsChangePasswordDetails(v)
                case "shared_link_settings_remove_expiration_details":
                    let v = try TeamLog.SharedLinkSettingsRemoveExpirationDetailsSerializer().deserialize(json)
                    return EventDetails.sharedLinkSettingsRemoveExpirationDetails(v)
                case "shared_link_settings_remove_password_details":
                    let v = try TeamLog.SharedLinkSettingsRemovePasswordDetailsSerializer().deserialize(json)
                    return EventDetails.sharedLinkSettingsRemovePasswordDetails(v)
                case "shared_link_share_details":
                    let v = try TeamLog.SharedLinkShareDetailsSerializer().deserialize(json)
                    return EventDetails.sharedLinkShareDetails(v)
                case "shared_link_view_details":
                    let v = try TeamLog.SharedLinkViewDetailsSerializer().deserialize(json)
                    return EventDetails.sharedLinkViewDetails(v)
                case "shared_note_opened_details":
                    let v = try TeamLog.SharedNoteOpenedDetailsSerializer().deserialize(json)
                    return EventDetails.sharedNoteOpenedDetails(v)
                case "shmodel_disable_downloads_details":
                    let v = try TeamLog.ShmodelDisableDownloadsDetailsSerializer().deserialize(json)
                    return EventDetails.shmodelDisableDownloadsDetails(v)
                case "shmodel_enable_downloads_details":
                    let v = try TeamLog.ShmodelEnableDownloadsDetailsSerializer().deserialize(json)
                    return EventDetails.shmodelEnableDownloadsDetails(v)
                case "shmodel_group_share_details":
                    let v = try TeamLog.ShmodelGroupShareDetailsSerializer().deserialize(json)
                    return EventDetails.shmodelGroupShareDetails(v)
                case "showcase_access_granted_details":
                    let v = try TeamLog.ShowcaseAccessGrantedDetailsSerializer().deserialize(json)
                    return EventDetails.showcaseAccessGrantedDetails(v)
                case "showcase_add_member_details":
                    let v = try TeamLog.ShowcaseAddMemberDetailsSerializer().deserialize(json)
                    return EventDetails.showcaseAddMemberDetails(v)
                case "showcase_archived_details":
                    let v = try TeamLog.ShowcaseArchivedDetailsSerializer().deserialize(json)
                    return EventDetails.showcaseArchivedDetails(v)
                case "showcase_created_details":
                    let v = try TeamLog.ShowcaseCreatedDetailsSerializer().deserialize(json)
                    return EventDetails.showcaseCreatedDetails(v)
                case "showcase_delete_comment_details":
                    let v = try TeamLog.ShowcaseDeleteCommentDetailsSerializer().deserialize(json)
                    return EventDetails.showcaseDeleteCommentDetails(v)
                case "showcase_edited_details":
                    let v = try TeamLog.ShowcaseEditedDetailsSerializer().deserialize(json)
                    return EventDetails.showcaseEditedDetails(v)
                case "showcase_edit_comment_details":
                    let v = try TeamLog.ShowcaseEditCommentDetailsSerializer().deserialize(json)
                    return EventDetails.showcaseEditCommentDetails(v)
                case "showcase_file_added_details":
                    let v = try TeamLog.ShowcaseFileAddedDetailsSerializer().deserialize(json)
                    return EventDetails.showcaseFileAddedDetails(v)
                case "showcase_file_download_details":
                    let v = try TeamLog.ShowcaseFileDownloadDetailsSerializer().deserialize(json)
                    return EventDetails.showcaseFileDownloadDetails(v)
                case "showcase_file_removed_details":
                    let v = try TeamLog.ShowcaseFileRemovedDetailsSerializer().deserialize(json)
                    return EventDetails.showcaseFileRemovedDetails(v)
                case "showcase_file_view_details":
                    let v = try TeamLog.ShowcaseFileViewDetailsSerializer().deserialize(json)
                    return EventDetails.showcaseFileViewDetails(v)
                case "showcase_permanently_deleted_details":
                    let v = try TeamLog.ShowcasePermanentlyDeletedDetailsSerializer().deserialize(json)
                    return EventDetails.showcasePermanentlyDeletedDetails(v)
                case "showcase_post_comment_details":
                    let v = try TeamLog.ShowcasePostCommentDetailsSerializer().deserialize(json)
                    return EventDetails.showcasePostCommentDetails(v)
                case "showcase_remove_member_details":
                    let v = try TeamLog.ShowcaseRemoveMemberDetailsSerializer().deserialize(json)
                    return EventDetails.showcaseRemoveMemberDetails(v)
                case "showcase_renamed_details":
                    let v = try TeamLog.ShowcaseRenamedDetailsSerializer().deserialize(json)
                    return EventDetails.showcaseRenamedDetails(v)
                case "showcase_request_access_details":
                    let v = try TeamLog.ShowcaseRequestAccessDetailsSerializer().deserialize(json)
                    return EventDetails.showcaseRequestAccessDetails(v)
                case "showcase_resolve_comment_details":
                    let v = try TeamLog.ShowcaseResolveCommentDetailsSerializer().deserialize(json)
                    return EventDetails.showcaseResolveCommentDetails(v)
                case "showcase_restored_details":
                    let v = try TeamLog.ShowcaseRestoredDetailsSerializer().deserialize(json)
                    return EventDetails.showcaseRestoredDetails(v)
                case "showcase_trashed_details":
                    let v = try TeamLog.ShowcaseTrashedDetailsSerializer().deserialize(json)
                    return EventDetails.showcaseTrashedDetails(v)
                case "showcase_trashed_deprecated_details":
                    let v = try TeamLog.ShowcaseTrashedDeprecatedDetailsSerializer().deserialize(json)
                    return EventDetails.showcaseTrashedDeprecatedDetails(v)
                case "showcase_unresolve_comment_details":
                    let v = try TeamLog.ShowcaseUnresolveCommentDetailsSerializer().deserialize(json)
                    return EventDetails.showcaseUnresolveCommentDetails(v)
                case "showcase_untrashed_details":
                    let v = try TeamLog.ShowcaseUntrashedDetailsSerializer().deserialize(json)
                    return EventDetails.showcaseUntrashedDetails(v)
                case "showcase_untrashed_deprecated_details":
                    let v = try TeamLog.ShowcaseUntrashedDeprecatedDetailsSerializer().deserialize(json)
                    return EventDetails.showcaseUntrashedDeprecatedDetails(v)
                case "showcase_view_details":
                    let v = try TeamLog.ShowcaseViewDetailsSerializer().deserialize(json)
                    return EventDetails.showcaseViewDetails(v)
                case "sso_add_cert_details":
                    let v = try TeamLog.SsoAddCertDetailsSerializer().deserialize(json)
                    return EventDetails.ssoAddCertDetails(v)
                case "sso_add_login_url_details":
                    let v = try TeamLog.SsoAddLoginUrlDetailsSerializer().deserialize(json)
                    return EventDetails.ssoAddLoginUrlDetails(v)
                case "sso_add_logout_url_details":
                    let v = try TeamLog.SsoAddLogoutUrlDetailsSerializer().deserialize(json)
                    return EventDetails.ssoAddLogoutUrlDetails(v)
                case "sso_change_cert_details":
                    let v = try TeamLog.SsoChangeCertDetailsSerializer().deserialize(json)
                    return EventDetails.ssoChangeCertDetails(v)
                case "sso_change_login_url_details":
                    let v = try TeamLog.SsoChangeLoginUrlDetailsSerializer().deserialize(json)
                    return EventDetails.ssoChangeLoginUrlDetails(v)
                case "sso_change_logout_url_details":
                    let v = try TeamLog.SsoChangeLogoutUrlDetailsSerializer().deserialize(json)
                    return EventDetails.ssoChangeLogoutUrlDetails(v)
                case "sso_change_saml_identity_mode_details":
                    let v = try TeamLog.SsoChangeSamlIdentityModeDetailsSerializer().deserialize(json)
                    return EventDetails.ssoChangeSamlIdentityModeDetails(v)
                case "sso_remove_cert_details":
                    let v = try TeamLog.SsoRemoveCertDetailsSerializer().deserialize(json)
                    return EventDetails.ssoRemoveCertDetails(v)
                case "sso_remove_login_url_details":
                    let v = try TeamLog.SsoRemoveLoginUrlDetailsSerializer().deserialize(json)
                    return EventDetails.ssoRemoveLoginUrlDetails(v)
                case "sso_remove_logout_url_details":
                    let v = try TeamLog.SsoRemoveLogoutUrlDetailsSerializer().deserialize(json)
                    return EventDetails.ssoRemoveLogoutUrlDetails(v)
                case "team_folder_change_status_details":
                    let v = try TeamLog.TeamFolderChangeStatusDetailsSerializer().deserialize(json)
                    return EventDetails.teamFolderChangeStatusDetails(v)
                case "team_folder_create_details":
                    let v = try TeamLog.TeamFolderCreateDetailsSerializer().deserialize(json)
                    return EventDetails.teamFolderCreateDetails(v)
                case "team_folder_downgrade_details":
                    let v = try TeamLog.TeamFolderDowngradeDetailsSerializer().deserialize(json)
                    return EventDetails.teamFolderDowngradeDetails(v)
                case "team_folder_permanently_delete_details":
                    let v = try TeamLog.TeamFolderPermanentlyDeleteDetailsSerializer().deserialize(json)
                    return EventDetails.teamFolderPermanentlyDeleteDetails(v)
                case "team_folder_rename_details":
                    let v = try TeamLog.TeamFolderRenameDetailsSerializer().deserialize(json)
                    return EventDetails.teamFolderRenameDetails(v)
                case "team_selective_sync_settings_changed_details":
                    let v = try TeamLog.TeamSelectiveSyncSettingsChangedDetailsSerializer().deserialize(json)
                    return EventDetails.teamSelectiveSyncSettingsChangedDetails(v)
                case "account_capture_change_policy_details":
                    let v = try TeamLog.AccountCaptureChangePolicyDetailsSerializer().deserialize(json)
                    return EventDetails.accountCaptureChangePolicyDetails(v)
                case "admin_email_reminders_changed_details":
                    let v = try TeamLog.AdminEmailRemindersChangedDetailsSerializer().deserialize(json)
                    return EventDetails.adminEmailRemindersChangedDetails(v)
                case "allow_download_disabled_details":
                    let v = try TeamLog.AllowDownloadDisabledDetailsSerializer().deserialize(json)
                    return EventDetails.allowDownloadDisabledDetails(v)
                case "allow_download_enabled_details":
                    let v = try TeamLog.AllowDownloadEnabledDetailsSerializer().deserialize(json)
                    return EventDetails.allowDownloadEnabledDetails(v)
                case "app_permissions_changed_details":
                    let v = try TeamLog.AppPermissionsChangedDetailsSerializer().deserialize(json)
                    return EventDetails.appPermissionsChangedDetails(v)
                case "camera_uploads_policy_changed_details":
                    let v = try TeamLog.CameraUploadsPolicyChangedDetailsSerializer().deserialize(json)
                    return EventDetails.cameraUploadsPolicyChangedDetails(v)
                case "capture_transcript_policy_changed_details":
                    let v = try TeamLog.CaptureTranscriptPolicyChangedDetailsSerializer().deserialize(json)
                    return EventDetails.captureTranscriptPolicyChangedDetails(v)
                case "classification_change_policy_details":
                    let v = try TeamLog.ClassificationChangePolicyDetailsSerializer().deserialize(json)
                    return EventDetails.classificationChangePolicyDetails(v)
                case "computer_backup_policy_changed_details":
                    let v = try TeamLog.ComputerBackupPolicyChangedDetailsSerializer().deserialize(json)
                    return EventDetails.computerBackupPolicyChangedDetails(v)
                case "content_administration_policy_changed_details":
                    let v = try TeamLog.ContentAdministrationPolicyChangedDetailsSerializer().deserialize(json)
                    return EventDetails.contentAdministrationPolicyChangedDetails(v)
                case "data_placement_restriction_change_policy_details":
                    let v = try TeamLog.DataPlacementRestrictionChangePolicyDetailsSerializer().deserialize(json)
                    return EventDetails.dataPlacementRestrictionChangePolicyDetails(v)
                case "data_placement_restriction_satisfy_policy_details":
                    let v = try TeamLog.DataPlacementRestrictionSatisfyPolicyDetailsSerializer().deserialize(json)
                    return EventDetails.dataPlacementRestrictionSatisfyPolicyDetails(v)
                case "device_approvals_add_exception_details":
                    let v = try TeamLog.DeviceApprovalsAddExceptionDetailsSerializer().deserialize(json)
                    return EventDetails.deviceApprovalsAddExceptionDetails(v)
                case "device_approvals_change_desktop_policy_details":
                    let v = try TeamLog.DeviceApprovalsChangeDesktopPolicyDetailsSerializer().deserialize(json)
                    return EventDetails.deviceApprovalsChangeDesktopPolicyDetails(v)
                case "device_approvals_change_mobile_policy_details":
                    let v = try TeamLog.DeviceApprovalsChangeMobilePolicyDetailsSerializer().deserialize(json)
                    return EventDetails.deviceApprovalsChangeMobilePolicyDetails(v)
                case "device_approvals_change_overage_action_details":
                    let v = try TeamLog.DeviceApprovalsChangeOverageActionDetailsSerializer().deserialize(json)
                    return EventDetails.deviceApprovalsChangeOverageActionDetails(v)
                case "device_approvals_change_unlink_action_details":
                    let v = try TeamLog.DeviceApprovalsChangeUnlinkActionDetailsSerializer().deserialize(json)
                    return EventDetails.deviceApprovalsChangeUnlinkActionDetails(v)
                case "device_approvals_remove_exception_details":
                    let v = try TeamLog.DeviceApprovalsRemoveExceptionDetailsSerializer().deserialize(json)
                    return EventDetails.deviceApprovalsRemoveExceptionDetails(v)
                case "directory_restrictions_add_members_details":
                    let v = try TeamLog.DirectoryRestrictionsAddMembersDetailsSerializer().deserialize(json)
                    return EventDetails.directoryRestrictionsAddMembersDetails(v)
                case "directory_restrictions_remove_members_details":
                    let v = try TeamLog.DirectoryRestrictionsRemoveMembersDetailsSerializer().deserialize(json)
                    return EventDetails.directoryRestrictionsRemoveMembersDetails(v)
                case "dropbox_passwords_policy_changed_details":
                    let v = try TeamLog.DropboxPasswordsPolicyChangedDetailsSerializer().deserialize(json)
                    return EventDetails.dropboxPasswordsPolicyChangedDetails(v)
                case "email_ingest_policy_changed_details":
                    let v = try TeamLog.EmailIngestPolicyChangedDetailsSerializer().deserialize(json)
                    return EventDetails.emailIngestPolicyChangedDetails(v)
                case "emm_add_exception_details":
                    let v = try TeamLog.EmmAddExceptionDetailsSerializer().deserialize(json)
                    return EventDetails.emmAddExceptionDetails(v)
                case "emm_change_policy_details":
                    let v = try TeamLog.EmmChangePolicyDetailsSerializer().deserialize(json)
                    return EventDetails.emmChangePolicyDetails(v)
                case "emm_remove_exception_details":
                    let v = try TeamLog.EmmRemoveExceptionDetailsSerializer().deserialize(json)
                    return EventDetails.emmRemoveExceptionDetails(v)
                case "extended_version_history_change_policy_details":
                    let v = try TeamLog.ExtendedVersionHistoryChangePolicyDetailsSerializer().deserialize(json)
                    return EventDetails.extendedVersionHistoryChangePolicyDetails(v)
                case "external_drive_backup_policy_changed_details":
                    let v = try TeamLog.ExternalDriveBackupPolicyChangedDetailsSerializer().deserialize(json)
                    return EventDetails.externalDriveBackupPolicyChangedDetails(v)
                case "file_comments_change_policy_details":
                    let v = try TeamLog.FileCommentsChangePolicyDetailsSerializer().deserialize(json)
                    return EventDetails.fileCommentsChangePolicyDetails(v)
                case "file_locking_policy_changed_details":
                    let v = try TeamLog.FileLockingPolicyChangedDetailsSerializer().deserialize(json)
                    return EventDetails.fileLockingPolicyChangedDetails(v)
                case "file_provider_migration_policy_changed_details":
                    let v = try TeamLog.FileProviderMigrationPolicyChangedDetailsSerializer().deserialize(json)
                    return EventDetails.fileProviderMigrationPolicyChangedDetails(v)
                case "file_requests_change_policy_details":
                    let v = try TeamLog.FileRequestsChangePolicyDetailsSerializer().deserialize(json)
                    return EventDetails.fileRequestsChangePolicyDetails(v)
                case "file_requests_emails_enabled_details":
                    let v = try TeamLog.FileRequestsEmailsEnabledDetailsSerializer().deserialize(json)
                    return EventDetails.fileRequestsEmailsEnabledDetails(v)
                case "file_requests_emails_restricted_to_team_only_details":
                    let v = try TeamLog.FileRequestsEmailsRestrictedToTeamOnlyDetailsSerializer().deserialize(json)
                    return EventDetails.fileRequestsEmailsRestrictedToTeamOnlyDetails(v)
                case "file_transfers_policy_changed_details":
                    let v = try TeamLog.FileTransfersPolicyChangedDetailsSerializer().deserialize(json)
                    return EventDetails.fileTransfersPolicyChangedDetails(v)
                case "folder_link_restriction_policy_changed_details":
                    let v = try TeamLog.FolderLinkRestrictionPolicyChangedDetailsSerializer().deserialize(json)
                    return EventDetails.folderLinkRestrictionPolicyChangedDetails(v)
                case "google_sso_change_policy_details":
                    let v = try TeamLog.GoogleSsoChangePolicyDetailsSerializer().deserialize(json)
                    return EventDetails.googleSsoChangePolicyDetails(v)
                case "group_user_management_change_policy_details":
                    let v = try TeamLog.GroupUserManagementChangePolicyDetailsSerializer().deserialize(json)
                    return EventDetails.groupUserManagementChangePolicyDetails(v)
                case "integration_policy_changed_details":
                    let v = try TeamLog.IntegrationPolicyChangedDetailsSerializer().deserialize(json)
                    return EventDetails.integrationPolicyChangedDetails(v)
                case "invite_acceptance_email_policy_changed_details":
                    let v = try TeamLog.InviteAcceptanceEmailPolicyChangedDetailsSerializer().deserialize(json)
                    return EventDetails.inviteAcceptanceEmailPolicyChangedDetails(v)
                case "member_requests_change_policy_details":
                    let v = try TeamLog.MemberRequestsChangePolicyDetailsSerializer().deserialize(json)
                    return EventDetails.memberRequestsChangePolicyDetails(v)
                case "member_send_invite_policy_changed_details":
                    let v = try TeamLog.MemberSendInvitePolicyChangedDetailsSerializer().deserialize(json)
                    return EventDetails.memberSendInvitePolicyChangedDetails(v)
                case "member_space_limits_add_exception_details":
                    let v = try TeamLog.MemberSpaceLimitsAddExceptionDetailsSerializer().deserialize(json)
                    return EventDetails.memberSpaceLimitsAddExceptionDetails(v)
                case "member_space_limits_change_caps_type_policy_details":
                    let v = try TeamLog.MemberSpaceLimitsChangeCapsTypePolicyDetailsSerializer().deserialize(json)
                    return EventDetails.memberSpaceLimitsChangeCapsTypePolicyDetails(v)
                case "member_space_limits_change_policy_details":
                    let v = try TeamLog.MemberSpaceLimitsChangePolicyDetailsSerializer().deserialize(json)
                    return EventDetails.memberSpaceLimitsChangePolicyDetails(v)
                case "member_space_limits_remove_exception_details":
                    let v = try TeamLog.MemberSpaceLimitsRemoveExceptionDetailsSerializer().deserialize(json)
                    return EventDetails.memberSpaceLimitsRemoveExceptionDetails(v)
                case "member_suggestions_change_policy_details":
                    let v = try TeamLog.MemberSuggestionsChangePolicyDetailsSerializer().deserialize(json)
                    return EventDetails.memberSuggestionsChangePolicyDetails(v)
                case "microsoft_office_addin_change_policy_details":
                    let v = try TeamLog.MicrosoftOfficeAddinChangePolicyDetailsSerializer().deserialize(json)
                    return EventDetails.microsoftOfficeAddinChangePolicyDetails(v)
                case "network_control_change_policy_details":
                    let v = try TeamLog.NetworkControlChangePolicyDetailsSerializer().deserialize(json)
                    return EventDetails.networkControlChangePolicyDetails(v)
                case "paper_change_deployment_policy_details":
                    let v = try TeamLog.PaperChangeDeploymentPolicyDetailsSerializer().deserialize(json)
                    return EventDetails.paperChangeDeploymentPolicyDetails(v)
                case "paper_change_member_link_policy_details":
                    let v = try TeamLog.PaperChangeMemberLinkPolicyDetailsSerializer().deserialize(json)
                    return EventDetails.paperChangeMemberLinkPolicyDetails(v)
                case "paper_change_member_policy_details":
                    let v = try TeamLog.PaperChangeMemberPolicyDetailsSerializer().deserialize(json)
                    return EventDetails.paperChangeMemberPolicyDetails(v)
                case "paper_change_policy_details":
                    let v = try TeamLog.PaperChangePolicyDetailsSerializer().deserialize(json)
                    return EventDetails.paperChangePolicyDetails(v)
                case "paper_default_folder_policy_changed_details":
                    let v = try TeamLog.PaperDefaultFolderPolicyChangedDetailsSerializer().deserialize(json)
                    return EventDetails.paperDefaultFolderPolicyChangedDetails(v)
                case "paper_desktop_policy_changed_details":
                    let v = try TeamLog.PaperDesktopPolicyChangedDetailsSerializer().deserialize(json)
                    return EventDetails.paperDesktopPolicyChangedDetails(v)
                case "paper_enabled_users_group_addition_details":
                    let v = try TeamLog.PaperEnabledUsersGroupAdditionDetailsSerializer().deserialize(json)
                    return EventDetails.paperEnabledUsersGroupAdditionDetails(v)
                case "paper_enabled_users_group_removal_details":
                    let v = try TeamLog.PaperEnabledUsersGroupRemovalDetailsSerializer().deserialize(json)
                    return EventDetails.paperEnabledUsersGroupRemovalDetails(v)
                case "password_strength_requirements_change_policy_details":
                    let v = try TeamLog.PasswordStrengthRequirementsChangePolicyDetailsSerializer().deserialize(json)
                    return EventDetails.passwordStrengthRequirementsChangePolicyDetails(v)
                case "permanent_delete_change_policy_details":
                    let v = try TeamLog.PermanentDeleteChangePolicyDetailsSerializer().deserialize(json)
                    return EventDetails.permanentDeleteChangePolicyDetails(v)
                case "reseller_support_change_policy_details":
                    let v = try TeamLog.ResellerSupportChangePolicyDetailsSerializer().deserialize(json)
                    return EventDetails.resellerSupportChangePolicyDetails(v)
                case "rewind_policy_changed_details":
                    let v = try TeamLog.RewindPolicyChangedDetailsSerializer().deserialize(json)
                    return EventDetails.rewindPolicyChangedDetails(v)
                case "send_for_signature_policy_changed_details":
                    let v = try TeamLog.SendForSignaturePolicyChangedDetailsSerializer().deserialize(json)
                    return EventDetails.sendForSignaturePolicyChangedDetails(v)
                case "sharing_change_folder_join_policy_details":
                    let v = try TeamLog.SharingChangeFolderJoinPolicyDetailsSerializer().deserialize(json)
                    return EventDetails.sharingChangeFolderJoinPolicyDetails(v)
                case "sharing_change_link_allow_change_expiration_policy_details":
                    let v = try TeamLog.SharingChangeLinkAllowChangeExpirationPolicyDetailsSerializer().deserialize(json)
                    return EventDetails.sharingChangeLinkAllowChangeExpirationPolicyDetails(v)
                case "sharing_change_link_default_expiration_policy_details":
                    let v = try TeamLog.SharingChangeLinkDefaultExpirationPolicyDetailsSerializer().deserialize(json)
                    return EventDetails.sharingChangeLinkDefaultExpirationPolicyDetails(v)
                case "sharing_change_link_enforce_password_policy_details":
                    let v = try TeamLog.SharingChangeLinkEnforcePasswordPolicyDetailsSerializer().deserialize(json)
                    return EventDetails.sharingChangeLinkEnforcePasswordPolicyDetails(v)
                case "sharing_change_link_policy_details":
                    let v = try TeamLog.SharingChangeLinkPolicyDetailsSerializer().deserialize(json)
                    return EventDetails.sharingChangeLinkPolicyDetails(v)
                case "sharing_change_member_policy_details":
                    let v = try TeamLog.SharingChangeMemberPolicyDetailsSerializer().deserialize(json)
                    return EventDetails.sharingChangeMemberPolicyDetails(v)
                case "showcase_change_download_policy_details":
                    let v = try TeamLog.ShowcaseChangeDownloadPolicyDetailsSerializer().deserialize(json)
                    return EventDetails.showcaseChangeDownloadPolicyDetails(v)
                case "showcase_change_enabled_policy_details":
                    let v = try TeamLog.ShowcaseChangeEnabledPolicyDetailsSerializer().deserialize(json)
                    return EventDetails.showcaseChangeEnabledPolicyDetails(v)
                case "showcase_change_external_sharing_policy_details":
                    let v = try TeamLog.ShowcaseChangeExternalSharingPolicyDetailsSerializer().deserialize(json)
                    return EventDetails.showcaseChangeExternalSharingPolicyDetails(v)
                case "smarter_smart_sync_policy_changed_details":
                    let v = try TeamLog.SmarterSmartSyncPolicyChangedDetailsSerializer().deserialize(json)
                    return EventDetails.smarterSmartSyncPolicyChangedDetails(v)
                case "smart_sync_change_policy_details":
                    let v = try TeamLog.SmartSyncChangePolicyDetailsSerializer().deserialize(json)
                    return EventDetails.smartSyncChangePolicyDetails(v)
                case "smart_sync_not_opt_out_details":
                    let v = try TeamLog.SmartSyncNotOptOutDetailsSerializer().deserialize(json)
                    return EventDetails.smartSyncNotOptOutDetails(v)
                case "smart_sync_opt_out_details":
                    let v = try TeamLog.SmartSyncOptOutDetailsSerializer().deserialize(json)
                    return EventDetails.smartSyncOptOutDetails(v)
                case "sso_change_policy_details":
                    let v = try TeamLog.SsoChangePolicyDetailsSerializer().deserialize(json)
                    return EventDetails.ssoChangePolicyDetails(v)
                case "team_branding_policy_changed_details":
                    let v = try TeamLog.TeamBrandingPolicyChangedDetailsSerializer().deserialize(json)
                    return EventDetails.teamBrandingPolicyChangedDetails(v)
                case "team_extensions_policy_changed_details":
                    let v = try TeamLog.TeamExtensionsPolicyChangedDetailsSerializer().deserialize(json)
                    return EventDetails.teamExtensionsPolicyChangedDetails(v)
                case "team_selective_sync_policy_changed_details":
                    let v = try TeamLog.TeamSelectiveSyncPolicyChangedDetailsSerializer().deserialize(json)
                    return EventDetails.teamSelectiveSyncPolicyChangedDetails(v)
                case "team_sharing_whitelist_subjects_changed_details":
                    let v = try TeamLog.TeamSharingWhitelistSubjectsChangedDetailsSerializer().deserialize(json)
                    return EventDetails.teamSharingWhitelistSubjectsChangedDetails(v)
                case "tfa_add_exception_details":
                    let v = try TeamLog.TfaAddExceptionDetailsSerializer().deserialize(json)
                    return EventDetails.tfaAddExceptionDetails(v)
                case "tfa_change_policy_details":
                    let v = try TeamLog.TfaChangePolicyDetailsSerializer().deserialize(json)
                    return EventDetails.tfaChangePolicyDetails(v)
                case "tfa_remove_exception_details":
                    let v = try TeamLog.TfaRemoveExceptionDetailsSerializer().deserialize(json)
                    return EventDetails.tfaRemoveExceptionDetails(v)
                case "two_account_change_policy_details":
                    let v = try TeamLog.TwoAccountChangePolicyDetailsSerializer().deserialize(json)
                    return EventDetails.twoAccountChangePolicyDetails(v)
                case "viewer_info_policy_changed_details":
                    let v = try TeamLog.ViewerInfoPolicyChangedDetailsSerializer().deserialize(json)
                    return EventDetails.viewerInfoPolicyChangedDetails(v)
                case "watermarking_policy_changed_details":
                    let v = try TeamLog.WatermarkingPolicyChangedDetailsSerializer().deserialize(json)
                    return EventDetails.watermarkingPolicyChangedDetails(v)
                case "web_sessions_change_active_session_limit_details":
                    let v = try TeamLog.WebSessionsChangeActiveSessionLimitDetailsSerializer().deserialize(json)
                    return EventDetails.webSessionsChangeActiveSessionLimitDetails(v)
                case "web_sessions_change_fixed_length_policy_details":
                    let v = try TeamLog.WebSessionsChangeFixedLengthPolicyDetailsSerializer().deserialize(json)
                    return EventDetails.webSessionsChangeFixedLengthPolicyDetails(v)
                case "web_sessions_change_idle_length_policy_details":
                    let v = try TeamLog.WebSessionsChangeIdleLengthPolicyDetailsSerializer().deserialize(json)
                    return EventDetails.webSessionsChangeIdleLengthPolicyDetails(v)
                case "data_residency_migration_request_successful_details":
                    let v = try TeamLog.DataResidencyMigrationRequestSuccessfulDetailsSerializer().deserialize(json)
                    return EventDetails.dataResidencyMigrationRequestSuccessfulDetails(v)
                case "data_residency_migration_request_unsuccessful_details":
                    let v = try TeamLog.DataResidencyMigrationRequestUnsuccessfulDetailsSerializer().deserialize(json)
                    return EventDetails.dataResidencyMigrationRequestUnsuccessfulDetails(v)
                case "team_merge_from_details":
                    let v = try TeamLog.TeamMergeFromDetailsSerializer().deserialize(json)
                    return EventDetails.teamMergeFromDetails(v)
                case "team_merge_to_details":
                    let v = try TeamLog.TeamMergeToDetailsSerializer().deserialize(json)
                    return EventDetails.teamMergeToDetails(v)
                case "team_profile_add_background_details":
                    let v = try TeamLog.TeamProfileAddBackgroundDetailsSerializer().deserialize(json)
                    return EventDetails.teamProfileAddBackgroundDetails(v)
                case "team_profile_add_logo_details":
                    let v = try TeamLog.TeamProfileAddLogoDetailsSerializer().deserialize(json)
                    return EventDetails.teamProfileAddLogoDetails(v)
                case "team_profile_change_background_details":
                    let v = try TeamLog.TeamProfileChangeBackgroundDetailsSerializer().deserialize(json)
                    return EventDetails.teamProfileChangeBackgroundDetails(v)
                case "team_profile_change_default_language_details":
                    let v = try TeamLog.TeamProfileChangeDefaultLanguageDetailsSerializer().deserialize(json)
                    return EventDetails.teamProfileChangeDefaultLanguageDetails(v)
                case "team_profile_change_logo_details":
                    let v = try TeamLog.TeamProfileChangeLogoDetailsSerializer().deserialize(json)
                    return EventDetails.teamProfileChangeLogoDetails(v)
                case "team_profile_change_name_details":
                    let v = try TeamLog.TeamProfileChangeNameDetailsSerializer().deserialize(json)
                    return EventDetails.teamProfileChangeNameDetails(v)
                case "team_profile_remove_background_details":
                    let v = try TeamLog.TeamProfileRemoveBackgroundDetailsSerializer().deserialize(json)
                    return EventDetails.teamProfileRemoveBackgroundDetails(v)
                case "team_profile_remove_logo_details":
                    let v = try TeamLog.TeamProfileRemoveLogoDetailsSerializer().deserialize(json)
                    return EventDetails.teamProfileRemoveLogoDetails(v)
                case "tfa_add_backup_phone_details":
                    let v = try TeamLog.TfaAddBackupPhoneDetailsSerializer().deserialize(json)
                    return EventDetails.tfaAddBackupPhoneDetails(v)
                case "tfa_add_security_key_details":
                    let v = try TeamLog.TfaAddSecurityKeyDetailsSerializer().deserialize(json)
                    return EventDetails.tfaAddSecurityKeyDetails(v)
                case "tfa_change_backup_phone_details":
                    let v = try TeamLog.TfaChangeBackupPhoneDetailsSerializer().deserialize(json)
                    return EventDetails.tfaChangeBackupPhoneDetails(v)
                case "tfa_change_status_details":
                    let v = try TeamLog.TfaChangeStatusDetailsSerializer().deserialize(json)
                    return EventDetails.tfaChangeStatusDetails(v)
                case "tfa_remove_backup_phone_details":
                    let v = try TeamLog.TfaRemoveBackupPhoneDetailsSerializer().deserialize(json)
                    return EventDetails.tfaRemoveBackupPhoneDetails(v)
                case "tfa_remove_security_key_details":
                    let v = try TeamLog.TfaRemoveSecurityKeyDetailsSerializer().deserialize(json)
                    return EventDetails.tfaRemoveSecurityKeyDetails(v)
                case "tfa_reset_details":
                    let v = try TeamLog.TfaResetDetailsSerializer().deserialize(json)
                    return EventDetails.tfaResetDetails(v)
                case "changed_enterprise_admin_role_details":
                    let v = try TeamLog.ChangedEnterpriseAdminRoleDetailsSerializer().deserialize(json)
                    return EventDetails.changedEnterpriseAdminRoleDetails(v)
                case "changed_enterprise_connected_team_status_details":
                    let v = try TeamLog.ChangedEnterpriseConnectedTeamStatusDetailsSerializer().deserialize(json)
                    return EventDetails.changedEnterpriseConnectedTeamStatusDetails(v)
                case "ended_enterprise_admin_session_details":
                    let v = try TeamLog.EndedEnterpriseAdminSessionDetailsSerializer().deserialize(json)
                    return EventDetails.endedEnterpriseAdminSessionDetails(v)
                case "ended_enterprise_admin_session_deprecated_details":
                    let v = try TeamLog.EndedEnterpriseAdminSessionDeprecatedDetailsSerializer().deserialize(json)
                    return EventDetails.endedEnterpriseAdminSessionDeprecatedDetails(v)
                case "enterprise_settings_locking_details":
                    let v = try TeamLog.EnterpriseSettingsLockingDetailsSerializer().deserialize(json)
                    return EventDetails.enterpriseSettingsLockingDetails(v)
                case "guest_admin_change_status_details":
                    let v = try TeamLog.GuestAdminChangeStatusDetailsSerializer().deserialize(json)
                    return EventDetails.guestAdminChangeStatusDetails(v)
                case "started_enterprise_admin_session_details":
                    let v = try TeamLog.StartedEnterpriseAdminSessionDetailsSerializer().deserialize(json)
                    return EventDetails.startedEnterpriseAdminSessionDetails(v)
                case "team_merge_request_accepted_details":
                    let v = try TeamLog.TeamMergeRequestAcceptedDetailsSerializer().deserialize(json)
                    return EventDetails.teamMergeRequestAcceptedDetails(v)
                case "team_merge_request_accepted_shown_to_primary_team_details":
                    let v = try TeamLog.TeamMergeRequestAcceptedShownToPrimaryTeamDetailsSerializer().deserialize(json)
                    return EventDetails.teamMergeRequestAcceptedShownToPrimaryTeamDetails(v)
                case "team_merge_request_accepted_shown_to_secondary_team_details":
                    let v = try TeamLog.TeamMergeRequestAcceptedShownToSecondaryTeamDetailsSerializer().deserialize(json)
                    return EventDetails.teamMergeRequestAcceptedShownToSecondaryTeamDetails(v)
                case "team_merge_request_auto_canceled_details":
                    let v = try TeamLog.TeamMergeRequestAutoCanceledDetailsSerializer().deserialize(json)
                    return EventDetails.teamMergeRequestAutoCanceledDetails(v)
                case "team_merge_request_canceled_details":
                    let v = try TeamLog.TeamMergeRequestCanceledDetailsSerializer().deserialize(json)
                    return EventDetails.teamMergeRequestCanceledDetails(v)
                case "team_merge_request_canceled_shown_to_primary_team_details":
                    let v = try TeamLog.TeamMergeRequestCanceledShownToPrimaryTeamDetailsSerializer().deserialize(json)
                    return EventDetails.teamMergeRequestCanceledShownToPrimaryTeamDetails(v)
                case "team_merge_request_canceled_shown_to_secondary_team_details":
                    let v = try TeamLog.TeamMergeRequestCanceledShownToSecondaryTeamDetailsSerializer().deserialize(json)
                    return EventDetails.teamMergeRequestCanceledShownToSecondaryTeamDetails(v)
                case "team_merge_request_expired_details":
                    let v = try TeamLog.TeamMergeRequestExpiredDetailsSerializer().deserialize(json)
                    return EventDetails.teamMergeRequestExpiredDetails(v)
                case "team_merge_request_expired_shown_to_primary_team_details":
                    let v = try TeamLog.TeamMergeRequestExpiredShownToPrimaryTeamDetailsSerializer().deserialize(json)
                    return EventDetails.teamMergeRequestExpiredShownToPrimaryTeamDetails(v)
                case "team_merge_request_expired_shown_to_secondary_team_details":
                    let v = try TeamLog.TeamMergeRequestExpiredShownToSecondaryTeamDetailsSerializer().deserialize(json)
                    return EventDetails.teamMergeRequestExpiredShownToSecondaryTeamDetails(v)
                case "team_merge_request_rejected_shown_to_primary_team_details":
                    let v = try TeamLog.TeamMergeRequestRejectedShownToPrimaryTeamDetailsSerializer().deserialize(json)
                    return EventDetails.teamMergeRequestRejectedShownToPrimaryTeamDetails(v)
                case "team_merge_request_rejected_shown_to_secondary_team_details":
                    let v = try TeamLog.TeamMergeRequestRejectedShownToSecondaryTeamDetailsSerializer().deserialize(json)
                    return EventDetails.teamMergeRequestRejectedShownToSecondaryTeamDetails(v)
                case "team_merge_request_reminder_details":
                    let v = try TeamLog.TeamMergeRequestReminderDetailsSerializer().deserialize(json)
                    return EventDetails.teamMergeRequestReminderDetails(v)
                case "team_merge_request_reminder_shown_to_primary_team_details":
                    let v = try TeamLog.TeamMergeRequestReminderShownToPrimaryTeamDetailsSerializer().deserialize(json)
                    return EventDetails.teamMergeRequestReminderShownToPrimaryTeamDetails(v)
                case "team_merge_request_reminder_shown_to_secondary_team_details":
                    let v = try TeamLog.TeamMergeRequestReminderShownToSecondaryTeamDetailsSerializer().deserialize(json)
                    return EventDetails.teamMergeRequestReminderShownToSecondaryTeamDetails(v)
                case "team_merge_request_revoked_details":
                    let v = try TeamLog.TeamMergeRequestRevokedDetailsSerializer().deserialize(json)
                    return EventDetails.teamMergeRequestRevokedDetails(v)
                case "team_merge_request_sent_shown_to_primary_team_details":
                    let v = try TeamLog.TeamMergeRequestSentShownToPrimaryTeamDetailsSerializer().deserialize(json)
                    return EventDetails.teamMergeRequestSentShownToPrimaryTeamDetails(v)
                case "team_merge_request_sent_shown_to_secondary_team_details":
                    let v = try TeamLog.TeamMergeRequestSentShownToSecondaryTeamDetailsSerializer().deserialize(json)
                    return EventDetails.teamMergeRequestSentShownToSecondaryTeamDetails(v)
                case "missing_details":
                    let v = try TeamLog.MissingDetailsSerializer().deserialize(json)
                    return EventDetails.missingDetails(v)
                case "other":
                    return EventDetails.other
                default:
                    return EventDetails.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: EventDetails.self, json: json)
            }
        }
    }

    /// The type of the event with description.
    public enum EventType: CustomStringConvertible, JSONRepresentable {
        /// (admin_alerting) Changed an alert state
        case adminAlertingAlertStateChanged(TeamLog.AdminAlertingAlertStateChangedType)
        /// (admin_alerting) Changed an alert setting
        case adminAlertingChangedAlertConfig(TeamLog.AdminAlertingChangedAlertConfigType)
        /// (admin_alerting) Triggered security alert
        case adminAlertingTriggeredAlert(TeamLog.AdminAlertingTriggeredAlertType)
        /// (admin_alerting) Completed ransomware restore process
        case ransomwareRestoreProcessCompleted(TeamLog.RansomwareRestoreProcessCompletedType)
        /// (admin_alerting) Started ransomware restore process
        case ransomwareRestoreProcessStarted(TeamLog.RansomwareRestoreProcessStartedType)
        /// (apps) Failed to connect app for member
        case appBlockedByPermissions(TeamLog.AppBlockedByPermissionsType)
        /// (apps) Linked app for team
        case appLinkTeam(TeamLog.AppLinkTeamType)
        /// (apps) Linked app for member
        case appLinkUser(TeamLog.AppLinkUserType)
        /// (apps) Unlinked app for team
        case appUnlinkTeam(TeamLog.AppUnlinkTeamType)
        /// (apps) Unlinked app for member
        case appUnlinkUser(TeamLog.AppUnlinkUserType)
        /// (apps) Connected integration for member
        case integrationConnected(TeamLog.IntegrationConnectedType)
        /// (apps) Disconnected integration for member
        case integrationDisconnected(TeamLog.IntegrationDisconnectedType)
        /// (comments) Added file comment
        case fileAddComment(TeamLog.FileAddCommentType)
        /// (comments) Subscribed to or unsubscribed from comment notifications for file
        case fileChangeCommentSubscription(TeamLog.FileChangeCommentSubscriptionType)
        /// (comments) Deleted file comment
        case fileDeleteComment(TeamLog.FileDeleteCommentType)
        /// (comments) Edited file comment
        case fileEditComment(TeamLog.FileEditCommentType)
        /// (comments) Liked file comment (deprecated, no longer logged)
        case fileLikeComment(TeamLog.FileLikeCommentType)
        /// (comments) Resolved file comment
        case fileResolveComment(TeamLog.FileResolveCommentType)
        /// (comments) Unliked file comment (deprecated, no longer logged)
        case fileUnlikeComment(TeamLog.FileUnlikeCommentType)
        /// (comments) Unresolved file comment
        case fileUnresolveComment(TeamLog.FileUnresolveCommentType)
        /// (data_governance) Added folders to policy
        case governancePolicyAddFolders(TeamLog.GovernancePolicyAddFoldersType)
        /// (data_governance) Couldn't add a folder to a policy
        case governancePolicyAddFolderFailed(TeamLog.GovernancePolicyAddFolderFailedType)
        /// (data_governance) Content disposed
        case governancePolicyContentDisposed(TeamLog.GovernancePolicyContentDisposedType)
        /// (data_governance) Activated a new policy
        case governancePolicyCreate(TeamLog.GovernancePolicyCreateType)
        /// (data_governance) Deleted a policy
        case governancePolicyDelete(TeamLog.GovernancePolicyDeleteType)
        /// (data_governance) Edited policy
        case governancePolicyEditDetails(TeamLog.GovernancePolicyEditDetailsType)
        /// (data_governance) Changed policy duration
        case governancePolicyEditDuration(TeamLog.GovernancePolicyEditDurationType)
        /// (data_governance) Created a policy download
        case governancePolicyExportCreated(TeamLog.GovernancePolicyExportCreatedType)
        /// (data_governance) Removed a policy download
        case governancePolicyExportRemoved(TeamLog.GovernancePolicyExportRemovedType)
        /// (data_governance) Removed folders from policy
        case governancePolicyRemoveFolders(TeamLog.GovernancePolicyRemoveFoldersType)
        /// (data_governance) Created a summary report for a policy
        case governancePolicyReportCreated(TeamLog.GovernancePolicyReportCreatedType)
        /// (data_governance) Downloaded content from a policy
        case governancePolicyZipPartDownloaded(TeamLog.GovernancePolicyZipPartDownloadedType)
        /// (data_governance) Activated a hold
        case legalHoldsActivateAHold(TeamLog.LegalHoldsActivateAHoldType)
        /// (data_governance) Added members to a hold
        case legalHoldsAddMembers(TeamLog.LegalHoldsAddMembersType)
        /// (data_governance) Edited details for a hold
        case legalHoldsChangeHoldDetails(TeamLog.LegalHoldsChangeHoldDetailsType)
        /// (data_governance) Renamed a hold
        case legalHoldsChangeHoldName(TeamLog.LegalHoldsChangeHoldNameType)
        /// (data_governance) Exported hold
        case legalHoldsExportAHold(TeamLog.LegalHoldsExportAHoldType)
        /// (data_governance) Canceled export for a hold
        case legalHoldsExportCancelled(TeamLog.LegalHoldsExportCancelledType)
        /// (data_governance) Downloaded export for a hold
        case legalHoldsExportDownloaded(TeamLog.LegalHoldsExportDownloadedType)
        /// (data_governance) Removed export for a hold
        case legalHoldsExportRemoved(TeamLog.LegalHoldsExportRemovedType)
        /// (data_governance) Released a hold
        case legalHoldsReleaseAHold(TeamLog.LegalHoldsReleaseAHoldType)
        /// (data_governance) Removed members from a hold
        case legalHoldsRemoveMembers(TeamLog.LegalHoldsRemoveMembersType)
        /// (data_governance) Created a summary report for a hold
        case legalHoldsReportAHold(TeamLog.LegalHoldsReportAHoldType)
        /// (devices) Changed IP address associated with active desktop session
        case deviceChangeIpDesktop(TeamLog.DeviceChangeIpDesktopType)
        /// (devices) Changed IP address associated with active mobile session
        case deviceChangeIpMobile(TeamLog.DeviceChangeIpMobileType)
        /// (devices) Changed IP address associated with active web session
        case deviceChangeIpWeb(TeamLog.DeviceChangeIpWebType)
        /// (devices) Failed to delete all files from unlinked device
        case deviceDeleteOnUnlinkFail(TeamLog.DeviceDeleteOnUnlinkFailType)
        /// (devices) Deleted all files from unlinked device
        case deviceDeleteOnUnlinkSuccess(TeamLog.DeviceDeleteOnUnlinkSuccessType)
        /// (devices) Failed to link device
        case deviceLinkFail(TeamLog.DeviceLinkFailType)
        /// (devices) Linked device
        case deviceLinkSuccess(TeamLog.DeviceLinkSuccessType)
        /// (devices) Disabled device management (deprecated, no longer logged)
        case deviceManagementDisabled(TeamLog.DeviceManagementDisabledType)
        /// (devices) Enabled device management (deprecated, no longer logged)
        case deviceManagementEnabled(TeamLog.DeviceManagementEnabledType)
        /// (devices) Enabled/disabled backup for computer
        case deviceSyncBackupStatusChanged(TeamLog.DeviceSyncBackupStatusChangedType)
        /// (devices) Disconnected device
        case deviceUnlink(TeamLog.DeviceUnlinkType)
        /// (devices) Exported passwords
        case dropboxPasswordsExported(TeamLog.DropboxPasswordsExportedType)
        /// (devices) Enrolled new Dropbox Passwords device
        case dropboxPasswordsNewDeviceEnrolled(TeamLog.DropboxPasswordsNewDeviceEnrolledType)
        /// (devices) Refreshed auth token used for setting up EMM
        case emmRefreshAuthToken(TeamLog.EmmRefreshAuthTokenType)
        /// (devices) Checked external drive backup eligibility status
        case externalDriveBackupEligibilityStatusChecked(TeamLog.ExternalDriveBackupEligibilityStatusCheckedType)
        /// (devices) Modified external drive backup
        case externalDriveBackupStatusChanged(TeamLog.ExternalDriveBackupStatusChangedType)
        /// (domains) Granted/revoked option to enable account capture on team domains
        case accountCaptureChangeAvailability(TeamLog.AccountCaptureChangeAvailabilityType)
        /// (domains) Account-captured user migrated account to team
        case accountCaptureMigrateAccount(TeamLog.AccountCaptureMigrateAccountType)
        /// (domains) Sent account capture email to all unmanaged members
        case accountCaptureNotificationEmailsSent(TeamLog.AccountCaptureNotificationEmailsSentType)
        /// (domains) Account-captured user changed account email to personal email
        case accountCaptureRelinquishAccount(TeamLog.AccountCaptureRelinquishAccountType)
        /// (domains) Disabled domain invites (deprecated, no longer logged)
        case disabledDomainInvites(TeamLog.DisabledDomainInvitesType)
        /// (domains) Approved user's request to join team
        case domainInvitesApproveRequestToJoinTeam(TeamLog.DomainInvitesApproveRequestToJoinTeamType)
        /// (domains) Declined user's request to join team
        case domainInvitesDeclineRequestToJoinTeam(TeamLog.DomainInvitesDeclineRequestToJoinTeamType)
        /// (domains) Sent domain invites to existing domain accounts (deprecated, no longer logged)
        case domainInvitesEmailExistingUsers(TeamLog.DomainInvitesEmailExistingUsersType)
        /// (domains) Requested to join team
        case domainInvitesRequestToJoinTeam(TeamLog.DomainInvitesRequestToJoinTeamType)
        /// (domains) Disabled "Automatically invite new users" (deprecated, no longer logged)
        case domainInvitesSetInviteNewUserPrefToNo(TeamLog.DomainInvitesSetInviteNewUserPrefToNoType)
        /// (domains) Enabled "Automatically invite new users" (deprecated, no longer logged)
        case domainInvitesSetInviteNewUserPrefToYes(TeamLog.DomainInvitesSetInviteNewUserPrefToYesType)
        /// (domains) Failed to verify team domain
        case domainVerificationAddDomainFail(TeamLog.DomainVerificationAddDomainFailType)
        /// (domains) Verified team domain
        case domainVerificationAddDomainSuccess(TeamLog.DomainVerificationAddDomainSuccessType)
        /// (domains) Removed domain from list of verified team domains
        case domainVerificationRemoveDomain(TeamLog.DomainVerificationRemoveDomainType)
        /// (domains) Enabled domain invites (deprecated, no longer logged)
        case enabledDomainInvites(TeamLog.EnabledDomainInvitesType)
        /// (encryption) Canceled team encryption key deletion
        case teamEncryptionKeyCancelKeyDeletion(TeamLog.TeamEncryptionKeyCancelKeyDeletionType)
        /// (encryption) Created team encryption key
        case teamEncryptionKeyCreateKey(TeamLog.TeamEncryptionKeyCreateKeyType)
        /// (encryption) Deleted team encryption key
        case teamEncryptionKeyDeleteKey(TeamLog.TeamEncryptionKeyDeleteKeyType)
        /// (encryption) Disabled team encryption key
        case teamEncryptionKeyDisableKey(TeamLog.TeamEncryptionKeyDisableKeyType)
        /// (encryption) Enabled team encryption key
        case teamEncryptionKeyEnableKey(TeamLog.TeamEncryptionKeyEnableKeyType)
        /// (encryption) Rotated team encryption key (deprecated, no longer logged)
        case teamEncryptionKeyRotateKey(TeamLog.TeamEncryptionKeyRotateKeyType)
        /// (encryption) Scheduled encryption key deletion
        case teamEncryptionKeyScheduleKeyDeletion(TeamLog.TeamEncryptionKeyScheduleKeyDeletionType)
        /// (file_operations) Applied naming convention
        case applyNamingConvention(TeamLog.ApplyNamingConventionType)
        /// (file_operations) Created folders (deprecated, no longer logged)
        case createFolder(TeamLog.CreateFolderType)
        /// (file_operations) Added files and/or folders
        case fileAdd(TeamLog.FileAddType)
        /// (file_operations) Added files and/or folders from automation
        case fileAddFromAutomation(TeamLog.FileAddFromAutomationType)
        /// (file_operations) Copied files and/or folders
        case fileCopy(TeamLog.FileCopyType)
        /// (file_operations) Deleted files and/or folders
        case fileDelete(TeamLog.FileDeleteType)
        /// (file_operations) Downloaded files and/or folders
        case fileDownload(TeamLog.FileDownloadType)
        /// (file_operations) Edited files
        case fileEdit(TeamLog.FileEditType)
        /// (file_operations) Created copy reference to file/folder
        case fileGetCopyReference(TeamLog.FileGetCopyReferenceType)
        /// (file_operations) Locked/unlocked editing for a file
        case fileLockingLockStatusChanged(TeamLog.FileLockingLockStatusChangedType)
        /// (file_operations) Moved files and/or folders
        case fileMove(TeamLog.FileMoveType)
        /// (file_operations) Permanently deleted files and/or folders
        case filePermanentlyDelete(TeamLog.FilePermanentlyDeleteType)
        /// (file_operations) Previewed files and/or folders
        case filePreview(TeamLog.FilePreviewType)
        /// (file_operations) Renamed files and/or folders
        case fileRename(TeamLog.FileRenameType)
        /// (file_operations) Restored deleted files and/or folders
        case fileRestore(TeamLog.FileRestoreType)
        /// (file_operations) Reverted files to previous version
        case fileRevert(TeamLog.FileRevertType)
        /// (file_operations) Rolled back file actions
        case fileRollbackChanges(TeamLog.FileRollbackChangesType)
        /// (file_operations) Saved file/folder using copy reference
        case fileSaveCopyReference(TeamLog.FileSaveCopyReferenceType)
        /// (file_operations) Updated folder overview
        case folderOverviewDescriptionChanged(TeamLog.FolderOverviewDescriptionChangedType)
        /// (file_operations) Pinned item to folder overview
        case folderOverviewItemPinned(TeamLog.FolderOverviewItemPinnedType)
        /// (file_operations) Unpinned item from folder overview
        case folderOverviewItemUnpinned(TeamLog.FolderOverviewItemUnpinnedType)
        /// (file_operations) Added a label
        case objectLabelAdded(TeamLog.ObjectLabelAddedType)
        /// (file_operations) Removed a label
        case objectLabelRemoved(TeamLog.ObjectLabelRemovedType)
        /// (file_operations) Updated a label's value
        case objectLabelUpdatedValue(TeamLog.ObjectLabelUpdatedValueType)
        /// (file_operations) Organized a folder with multi-file organize
        case organizeFolderWithTidy(TeamLog.OrganizeFolderWithTidyType)
        /// (file_operations) Deleted files in Replay
        case replayFileDelete(TeamLog.ReplayFileDeleteType)
        /// (file_operations) Rewound a folder
        case rewindFolder(TeamLog.RewindFolderType)
        /// (file_operations) Reverted naming convention
        case undoNamingConvention(TeamLog.UndoNamingConventionType)
        /// (file_operations) Removed multi-file organize
        case undoOrganizeFolderWithTidy(TeamLog.UndoOrganizeFolderWithTidyType)
        /// (file_operations) Tagged a file
        case userTagsAdded(TeamLog.UserTagsAddedType)
        /// (file_operations) Removed tags
        case userTagsRemoved(TeamLog.UserTagsRemovedType)
        /// (file_requests) Received files via Email to Dropbox
        case emailIngestReceiveFile(TeamLog.EmailIngestReceiveFileType)
        /// (file_requests) Changed file request
        case fileRequestChange(TeamLog.FileRequestChangeType)
        /// (file_requests) Closed file request
        case fileRequestClose(TeamLog.FileRequestCloseType)
        /// (file_requests) Created file request
        case fileRequestCreate(TeamLog.FileRequestCreateType)
        /// (file_requests) Delete file request
        case fileRequestDelete(TeamLog.FileRequestDeleteType)
        /// (file_requests) Received files for file request
        case fileRequestReceiveFile(TeamLog.FileRequestReceiveFileType)
        /// (groups) Added external ID for group
        case groupAddExternalId(TeamLog.GroupAddExternalIdType)
        /// (groups) Added team members to group
        case groupAddMember(TeamLog.GroupAddMemberType)
        /// (groups) Changed external ID for group
        case groupChangeExternalId(TeamLog.GroupChangeExternalIdType)
        /// (groups) Changed group management type
        case groupChangeManagementType(TeamLog.GroupChangeManagementTypeType)
        /// (groups) Changed manager permissions of group member
        case groupChangeMemberRole(TeamLog.GroupChangeMemberRoleType)
        /// (groups) Created group
        case groupCreate(TeamLog.GroupCreateType)
        /// (groups) Deleted group
        case groupDelete(TeamLog.GroupDeleteType)
        /// (groups) Updated group (deprecated, no longer logged)
        case groupDescriptionUpdated(TeamLog.GroupDescriptionUpdatedType)
        /// (groups) Updated group join policy (deprecated, no longer logged)
        case groupJoinPolicyUpdated(TeamLog.GroupJoinPolicyUpdatedType)
        /// (groups) Moved group (deprecated, no longer logged)
        case groupMoved(TeamLog.GroupMovedType)
        /// (groups) Removed external ID for group
        case groupRemoveExternalId(TeamLog.GroupRemoveExternalIdType)
        /// (groups) Removed team members from group
        case groupRemoveMember(TeamLog.GroupRemoveMemberType)
        /// (groups) Renamed group
        case groupRename(TeamLog.GroupRenameType)
        /// (logins) Unlocked/locked account after failed sign in attempts
        case accountLockOrUnlocked(TeamLog.AccountLockOrUnlockedType)
        /// (logins) Failed to sign in via EMM (deprecated, replaced by 'Failed to sign in')
        case emmError(TeamLog.EmmErrorType)
        /// (logins) Started trusted team admin session
        case guestAdminSignedInViaTrustedTeams(TeamLog.GuestAdminSignedInViaTrustedTeamsType)
        /// (logins) Ended trusted team admin session
        case guestAdminSignedOutViaTrustedTeams(TeamLog.GuestAdminSignedOutViaTrustedTeamsType)
        /// (logins) Failed to sign in
        case loginFail(TeamLog.LoginFailType)
        /// (logins) Signed in
        case loginSuccess(TeamLog.LoginSuccessType)
        /// (logins) Signed out
        case logout(TeamLog.LogoutType)
        /// (logins) Ended reseller support session
        case resellerSupportSessionEnd(TeamLog.ResellerSupportSessionEndType)
        /// (logins) Started reseller support session
        case resellerSupportSessionStart(TeamLog.ResellerSupportSessionStartType)
        /// (logins) Ended admin sign-in-as session
        case signInAsSessionEnd(TeamLog.SignInAsSessionEndType)
        /// (logins) Started admin sign-in-as session
        case signInAsSessionStart(TeamLog.SignInAsSessionStartType)
        /// (logins) Failed to sign in via SSO (deprecated, replaced by 'Failed to sign in')
        case ssoError(TeamLog.SsoErrorType)
        /// (members) Invited members to activate Backup
        case backupAdminInvitationSent(TeamLog.BackupAdminInvitationSentType)
        /// (members) Opened Backup invite
        case backupInvitationOpened(TeamLog.BackupInvitationOpenedType)
        /// (members) Created team invite link
        case createTeamInviteLink(TeamLog.CreateTeamInviteLinkType)
        /// (members) Deleted team invite link
        case deleteTeamInviteLink(TeamLog.DeleteTeamInviteLinkType)
        /// (members) Added an external ID for team member
        case memberAddExternalId(TeamLog.MemberAddExternalIdType)
        /// (members) Added team member name
        case memberAddName(TeamLog.MemberAddNameType)
        /// (members) Changed team member admin role
        case memberChangeAdminRole(TeamLog.MemberChangeAdminRoleType)
        /// (members) Changed team member email
        case memberChangeEmail(TeamLog.MemberChangeEmailType)
        /// (members) Changed the external ID for team member
        case memberChangeExternalId(TeamLog.MemberChangeExternalIdType)
        /// (members) Changed membership type (limited/full) of member (deprecated, no longer logged)
        case memberChangeMembershipType(TeamLog.MemberChangeMembershipTypeType)
        /// (members) Changed team member name
        case memberChangeName(TeamLog.MemberChangeNameType)
        /// (members) Changed team member reseller role
        case memberChangeResellerRole(TeamLog.MemberChangeResellerRoleType)
        /// (members) Changed member status (invited, joined, suspended, etc.)
        case memberChangeStatus(TeamLog.MemberChangeStatusType)
        /// (members) Cleared manually added contacts
        case memberDeleteManualContacts(TeamLog.MemberDeleteManualContactsType)
        /// (members) Deleted team member profile photo
        case memberDeleteProfilePhoto(TeamLog.MemberDeleteProfilePhotoType)
        /// (members) Permanently deleted contents of deleted team member account
        case memberPermanentlyDeleteAccountContents(TeamLog.MemberPermanentlyDeleteAccountContentsType)
        /// (members) Removed the external ID for team member
        case memberRemoveExternalId(TeamLog.MemberRemoveExternalIdType)
        /// (members) Set team member profile photo
        case memberSetProfilePhoto(TeamLog.MemberSetProfilePhotoType)
        /// (members) Set custom member space limit
        case memberSpaceLimitsAddCustomQuota(TeamLog.MemberSpaceLimitsAddCustomQuotaType)
        /// (members) Changed custom member space limit
        case memberSpaceLimitsChangeCustomQuota(TeamLog.MemberSpaceLimitsChangeCustomQuotaType)
        /// (members) Changed space limit status
        case memberSpaceLimitsChangeStatus(TeamLog.MemberSpaceLimitsChangeStatusType)
        /// (members) Removed custom member space limit
        case memberSpaceLimitsRemoveCustomQuota(TeamLog.MemberSpaceLimitsRemoveCustomQuotaType)
        /// (members) Suggested person to add to team
        case memberSuggest(TeamLog.MemberSuggestType)
        /// (members) Transferred contents of deleted member account to another member
        case memberTransferAccountContents(TeamLog.MemberTransferAccountContentsType)
        /// (members) Added pending secondary email
        case pendingSecondaryEmailAdded(TeamLog.PendingSecondaryEmailAddedType)
        /// (members) Deleted secondary email
        case secondaryEmailDeleted(TeamLog.SecondaryEmailDeletedType)
        /// (members) Verified secondary email
        case secondaryEmailVerified(TeamLog.SecondaryEmailVerifiedType)
        /// (members) Secondary mails policy changed
        case secondaryMailsPolicyChanged(TeamLog.SecondaryMailsPolicyChangedType)
        /// (paper) Added Binder page (deprecated, replaced by 'Edited files')
        case binderAddPage(TeamLog.BinderAddPageType)
        /// (paper) Added Binder section (deprecated, replaced by 'Edited files')
        case binderAddSection(TeamLog.BinderAddSectionType)
        /// (paper) Removed Binder page (deprecated, replaced by 'Edited files')
        case binderRemovePage(TeamLog.BinderRemovePageType)
        /// (paper) Removed Binder section (deprecated, replaced by 'Edited files')
        case binderRemoveSection(TeamLog.BinderRemoveSectionType)
        /// (paper) Renamed Binder page (deprecated, replaced by 'Edited files')
        case binderRenamePage(TeamLog.BinderRenamePageType)
        /// (paper) Renamed Binder section (deprecated, replaced by 'Edited files')
        case binderRenameSection(TeamLog.BinderRenameSectionType)
        /// (paper) Reordered Binder page (deprecated, replaced by 'Edited files')
        case binderReorderPage(TeamLog.BinderReorderPageType)
        /// (paper) Reordered Binder section (deprecated, replaced by 'Edited files')
        case binderReorderSection(TeamLog.BinderReorderSectionType)
        /// (paper) Added users and/or groups to Paper doc/folder
        case paperContentAddMember(TeamLog.PaperContentAddMemberType)
        /// (paper) Added Paper doc/folder to folder
        case paperContentAddToFolder(TeamLog.PaperContentAddToFolderType)
        /// (paper) Archived Paper doc/folder
        case paperContentArchive(TeamLog.PaperContentArchiveType)
        /// (paper) Created Paper doc/folder
        case paperContentCreate(TeamLog.PaperContentCreateType)
        /// (paper) Permanently deleted Paper doc/folder
        case paperContentPermanentlyDelete(TeamLog.PaperContentPermanentlyDeleteType)
        /// (paper) Removed Paper doc/folder from folder
        case paperContentRemoveFromFolder(TeamLog.PaperContentRemoveFromFolderType)
        /// (paper) Removed users and/or groups from Paper doc/folder
        case paperContentRemoveMember(TeamLog.PaperContentRemoveMemberType)
        /// (paper) Renamed Paper doc/folder
        case paperContentRename(TeamLog.PaperContentRenameType)
        /// (paper) Restored archived Paper doc/folder
        case paperContentRestore(TeamLog.PaperContentRestoreType)
        /// (paper) Added Paper doc comment
        case paperDocAddComment(TeamLog.PaperDocAddCommentType)
        /// (paper) Changed member permissions for Paper doc
        case paperDocChangeMemberRole(TeamLog.PaperDocChangeMemberRoleType)
        /// (paper) Changed sharing setting for Paper doc
        case paperDocChangeSharingPolicy(TeamLog.PaperDocChangeSharingPolicyType)
        /// (paper) Followed/unfollowed Paper doc
        case paperDocChangeSubscription(TeamLog.PaperDocChangeSubscriptionType)
        /// (paper) Archived Paper doc (deprecated, no longer logged)
        case paperDocDeleted(TeamLog.PaperDocDeletedType)
        /// (paper) Deleted Paper doc comment
        case paperDocDeleteComment(TeamLog.PaperDocDeleteCommentType)
        /// (paper) Downloaded Paper doc in specific format
        case paperDocDownload(TeamLog.PaperDocDownloadType)
        /// (paper) Edited Paper doc
        case paperDocEdit(TeamLog.PaperDocEditType)
        /// (paper) Edited Paper doc comment
        case paperDocEditComment(TeamLog.PaperDocEditCommentType)
        /// (paper) Followed Paper doc (deprecated, replaced by 'Followed/unfollowed Paper doc')
        case paperDocFollowed(TeamLog.PaperDocFollowedType)
        /// (paper) Mentioned user in Paper doc
        case paperDocMention(TeamLog.PaperDocMentionType)
        /// (paper) Transferred ownership of Paper doc
        case paperDocOwnershipChanged(TeamLog.PaperDocOwnershipChangedType)
        /// (paper) Requested access to Paper doc
        case paperDocRequestAccess(TeamLog.PaperDocRequestAccessType)
        /// (paper) Resolved Paper doc comment
        case paperDocResolveComment(TeamLog.PaperDocResolveCommentType)
        /// (paper) Restored Paper doc to previous version
        case paperDocRevert(TeamLog.PaperDocRevertType)
        /// (paper) Shared Paper doc via Slack
        case paperDocSlackShare(TeamLog.PaperDocSlackShareType)
        /// (paper) Shared Paper doc with users and/or groups (deprecated, no longer logged)
        case paperDocTeamInvite(TeamLog.PaperDocTeamInviteType)
        /// (paper) Deleted Paper doc
        case paperDocTrashed(TeamLog.PaperDocTrashedType)
        /// (paper) Unresolved Paper doc comment
        case paperDocUnresolveComment(TeamLog.PaperDocUnresolveCommentType)
        /// (paper) Restored Paper doc
        case paperDocUntrashed(TeamLog.PaperDocUntrashedType)
        /// (paper) Viewed Paper doc
        case paperDocView(TeamLog.PaperDocViewType)
        /// (paper) Changed Paper external sharing setting to anyone (deprecated, no longer logged)
        case paperExternalViewAllow(TeamLog.PaperExternalViewAllowType)
        /// (paper) Changed Paper external sharing setting to default team (deprecated, no longer logged)
        case paperExternalViewDefaultTeam(TeamLog.PaperExternalViewDefaultTeamType)
        /// (paper) Changed Paper external sharing setting to team-only (deprecated, no longer logged)
        case paperExternalViewForbid(TeamLog.PaperExternalViewForbidType)
        /// (paper) Followed/unfollowed Paper folder
        case paperFolderChangeSubscription(TeamLog.PaperFolderChangeSubscriptionType)
        /// (paper) Archived Paper folder (deprecated, no longer logged)
        case paperFolderDeleted(TeamLog.PaperFolderDeletedType)
        /// (paper) Followed Paper folder (deprecated, replaced by 'Followed/unfollowed Paper folder')
        case paperFolderFollowed(TeamLog.PaperFolderFollowedType)
        /// (paper) Shared Paper folder with users and/or groups (deprecated, no longer logged)
        case paperFolderTeamInvite(TeamLog.PaperFolderTeamInviteType)
        /// (paper) Changed permissions for published doc
        case paperPublishedLinkChangePermission(TeamLog.PaperPublishedLinkChangePermissionType)
        /// (paper) Published doc
        case paperPublishedLinkCreate(TeamLog.PaperPublishedLinkCreateType)
        /// (paper) Unpublished doc
        case paperPublishedLinkDisabled(TeamLog.PaperPublishedLinkDisabledType)
        /// (paper) Viewed published doc
        case paperPublishedLinkView(TeamLog.PaperPublishedLinkViewType)
        /// (passwords) Changed password
        case passwordChange(TeamLog.PasswordChangeType)
        /// (passwords) Reset password
        case passwordReset(TeamLog.PasswordResetType)
        /// (passwords) Reset all team member passwords
        case passwordResetAll(TeamLog.PasswordResetAllType)
        /// (reports) Created Classification report
        case classificationCreateReport(TeamLog.ClassificationCreateReportType)
        /// (reports) Couldn't create Classification report
        case classificationCreateReportFail(TeamLog.ClassificationCreateReportFailType)
        /// (reports) Created EMM-excluded users report
        case emmCreateExceptionsReport(TeamLog.EmmCreateExceptionsReportType)
        /// (reports) Created EMM mobile app usage report
        case emmCreateUsageReport(TeamLog.EmmCreateUsageReportType)
        /// (reports) Created member data report
        case exportMembersReport(TeamLog.ExportMembersReportType)
        /// (reports) Failed to create members data report
        case exportMembersReportFail(TeamLog.ExportMembersReportFailType)
        /// (reports) Created External sharing report
        case externalSharingCreateReport(TeamLog.ExternalSharingCreateReportType)
        /// (reports) Couldn't create External sharing report
        case externalSharingReportFailed(TeamLog.ExternalSharingReportFailedType)
        /// (reports) Report created: Links created with no expiration
        case noExpirationLinkGenCreateReport(TeamLog.NoExpirationLinkGenCreateReportType)
        /// (reports) Couldn't create report: Links created with no expiration
        case noExpirationLinkGenReportFailed(TeamLog.NoExpirationLinkGenReportFailedType)
        /// (reports) Report created: Links created without passwords
        case noPasswordLinkGenCreateReport(TeamLog.NoPasswordLinkGenCreateReportType)
        /// (reports) Couldn't create report: Links created without passwords
        case noPasswordLinkGenReportFailed(TeamLog.NoPasswordLinkGenReportFailedType)
        /// (reports) Report created: Views of links without passwords
        case noPasswordLinkViewCreateReport(TeamLog.NoPasswordLinkViewCreateReportType)
        /// (reports) Couldn't create report: Views of links without passwords
        case noPasswordLinkViewReportFailed(TeamLog.NoPasswordLinkViewReportFailedType)
        /// (reports) Report created: Views of old links
        case outdatedLinkViewCreateReport(TeamLog.OutdatedLinkViewCreateReportType)
        /// (reports) Couldn't create report: Views of old links
        case outdatedLinkViewReportFailed(TeamLog.OutdatedLinkViewReportFailedType)
        /// (reports) Exported all team Paper docs
        case paperAdminExportStart(TeamLog.PaperAdminExportStartType)
        /// (reports) Created ransomware report
        case ransomwareAlertCreateReport(TeamLog.RansomwareAlertCreateReportType)
        /// (reports) Couldn't generate ransomware report
        case ransomwareAlertCreateReportFailed(TeamLog.RansomwareAlertCreateReportFailedType)
        /// (reports) Created Smart Sync non-admin devices report
        case smartSyncCreateAdminPrivilegeReport(TeamLog.SmartSyncCreateAdminPrivilegeReportType)
        /// (reports) Created team activity report
        case teamActivityCreateReport(TeamLog.TeamActivityCreateReportType)
        /// (reports) Couldn't generate team activity report
        case teamActivityCreateReportFail(TeamLog.TeamActivityCreateReportFailType)
        /// (sharing) Shared album
        case collectionShare(TeamLog.CollectionShareType)
        /// (sharing) Transfer files added
        case fileTransfersFileAdd(TeamLog.FileTransfersFileAddType)
        /// (sharing) Deleted transfer
        case fileTransfersTransferDelete(TeamLog.FileTransfersTransferDeleteType)
        /// (sharing) Transfer downloaded
        case fileTransfersTransferDownload(TeamLog.FileTransfersTransferDownloadType)
        /// (sharing) Sent transfer
        case fileTransfersTransferSend(TeamLog.FileTransfersTransferSendType)
        /// (sharing) Viewed transfer
        case fileTransfersTransferView(TeamLog.FileTransfersTransferViewType)
        /// (sharing) Changed Paper doc to invite-only (deprecated, no longer logged)
        case noteAclInviteOnly(TeamLog.NoteAclInviteOnlyType)
        /// (sharing) Changed Paper doc to link-accessible (deprecated, no longer logged)
        case noteAclLink(TeamLog.NoteAclLinkType)
        /// (sharing) Changed Paper doc to link-accessible for team (deprecated, no longer logged)
        case noteAclTeamLink(TeamLog.NoteAclTeamLinkType)
        /// (sharing) Shared Paper doc (deprecated, no longer logged)
        case noteShared(TeamLog.NoteSharedType)
        /// (sharing) Shared received Paper doc (deprecated, no longer logged)
        case noteShareReceive(TeamLog.NoteShareReceiveType)
        /// (sharing) Opened shared Paper doc (deprecated, no longer logged)
        case openNoteShared(TeamLog.OpenNoteSharedType)
        /// (sharing) Created shared link in Replay
        case replayFileSharedLinkCreated(TeamLog.ReplayFileSharedLinkCreatedType)
        /// (sharing) Modified shared link in Replay
        case replayFileSharedLinkModified(TeamLog.ReplayFileSharedLinkModifiedType)
        /// (sharing) Added member to Replay Project
        case replayProjectTeamAdd(TeamLog.ReplayProjectTeamAddType)
        /// (sharing) Removed member from Replay Project
        case replayProjectTeamDelete(TeamLog.ReplayProjectTeamDeleteType)
        /// (sharing) Added team to shared folder (deprecated, no longer logged)
        case sfAddGroup(TeamLog.SfAddGroupType)
        /// (sharing) Allowed non-collaborators to view links to files in shared folder (deprecated, no longer logged)
        case sfAllowNonMembersToViewSharedLinks(TeamLog.SfAllowNonMembersToViewSharedLinksType)
        /// (sharing) Set team members to see warning before sharing folders outside team (deprecated, no longer logged)
        case sfExternalInviteWarn(TeamLog.SfExternalInviteWarnType)
        /// (sharing) Invited Facebook users to shared folder (deprecated, no longer logged)
        case sfFbInvite(TeamLog.SfFbInviteType)
        /// (sharing) Changed Facebook user's role in shared folder (deprecated, no longer logged)
        case sfFbInviteChangeRole(TeamLog.SfFbInviteChangeRoleType)
        /// (sharing) Uninvited Facebook user from shared folder (deprecated, no longer logged)
        case sfFbUninvite(TeamLog.SfFbUninviteType)
        /// (sharing) Invited group to shared folder (deprecated, no longer logged)
        case sfInviteGroup(TeamLog.SfInviteGroupType)
        /// (sharing) Granted access to shared folder (deprecated, no longer logged)
        case sfTeamGrantAccess(TeamLog.SfTeamGrantAccessType)
        /// (sharing) Invited team members to shared folder (deprecated, replaced by 'Invited user to Dropbox and added
        /// them to shared file/folder')
        case sfTeamInvite(TeamLog.SfTeamInviteType)
        /// (sharing) Changed team member's role in shared folder (deprecated, no longer logged)
        case sfTeamInviteChangeRole(TeamLog.SfTeamInviteChangeRoleType)
        /// (sharing) Joined team member's shared folder (deprecated, no longer logged)
        case sfTeamJoin(TeamLog.SfTeamJoinType)
        /// (sharing) Joined team member's shared folder from link (deprecated, no longer logged)
        case sfTeamJoinFromOobLink(TeamLog.SfTeamJoinFromOobLinkType)
        /// (sharing) Unshared folder with team member (deprecated, replaced by 'Removed invitee from shared file/folder
        /// before invite was accepted')
        case sfTeamUninvite(TeamLog.SfTeamUninviteType)
        /// (sharing) Invited user to Dropbox and added them to shared file/folder
        case sharedContentAddInvitees(TeamLog.SharedContentAddInviteesType)
        /// (sharing) Added expiration date to link for shared file/folder (deprecated, no longer logged)
        case sharedContentAddLinkExpiry(TeamLog.SharedContentAddLinkExpiryType)
        /// (sharing) Added password to link for shared file/folder (deprecated, no longer logged)
        case sharedContentAddLinkPassword(TeamLog.SharedContentAddLinkPasswordType)
        /// (sharing) Added users and/or groups to shared file/folder
        case sharedContentAddMember(TeamLog.SharedContentAddMemberType)
        /// (sharing) Changed whether members can download shared file/folder (deprecated, no longer logged)
        case sharedContentChangeDownloadsPolicy(TeamLog.SharedContentChangeDownloadsPolicyType)
        /// (sharing) Changed access type of invitee to shared file/folder before invite was accepted
        case sharedContentChangeInviteeRole(TeamLog.SharedContentChangeInviteeRoleType)
        /// (sharing) Changed link audience of shared file/folder (deprecated, no longer logged)
        case sharedContentChangeLinkAudience(TeamLog.SharedContentChangeLinkAudienceType)
        /// (sharing) Changed link expiration of shared file/folder (deprecated, no longer logged)
        case sharedContentChangeLinkExpiry(TeamLog.SharedContentChangeLinkExpiryType)
        /// (sharing) Changed link password of shared file/folder (deprecated, no longer logged)
        case sharedContentChangeLinkPassword(TeamLog.SharedContentChangeLinkPasswordType)
        /// (sharing) Changed access type of shared file/folder member
        case sharedContentChangeMemberRole(TeamLog.SharedContentChangeMemberRoleType)
        /// (sharing) Changed whether members can see who viewed shared file/folder
        case sharedContentChangeViewerInfoPolicy(TeamLog.SharedContentChangeViewerInfoPolicyType)
        /// (sharing) Acquired membership of shared file/folder by accepting invite
        case sharedContentClaimInvitation(TeamLog.SharedContentClaimInvitationType)
        /// (sharing) Copied shared file/folder to own Dropbox
        case sharedContentCopy(TeamLog.SharedContentCopyType)
        /// (sharing) Downloaded shared file/folder
        case sharedContentDownload(TeamLog.SharedContentDownloadType)
        /// (sharing) Left shared file/folder
        case sharedContentRelinquishMembership(TeamLog.SharedContentRelinquishMembershipType)
        /// (sharing) Removed invitee from shared file/folder before invite was accepted
        case sharedContentRemoveInvitees(TeamLog.SharedContentRemoveInviteesType)
        /// (sharing) Removed link expiration date of shared file/folder (deprecated, no longer logged)
        case sharedContentRemoveLinkExpiry(TeamLog.SharedContentRemoveLinkExpiryType)
        /// (sharing) Removed link password of shared file/folder (deprecated, no longer logged)
        case sharedContentRemoveLinkPassword(TeamLog.SharedContentRemoveLinkPasswordType)
        /// (sharing) Removed user/group from shared file/folder
        case sharedContentRemoveMember(TeamLog.SharedContentRemoveMemberType)
        /// (sharing) Requested access to shared file/folder
        case sharedContentRequestAccess(TeamLog.SharedContentRequestAccessType)
        /// (sharing) Restored shared file/folder invitees
        case sharedContentRestoreInvitees(TeamLog.SharedContentRestoreInviteesType)
        /// (sharing) Restored users and/or groups to membership of shared file/folder
        case sharedContentRestoreMember(TeamLog.SharedContentRestoreMemberType)
        /// (sharing) Unshared file/folder by clearing membership
        case sharedContentUnshare(TeamLog.SharedContentUnshareType)
        /// (sharing) Previewed shared file/folder
        case sharedContentView(TeamLog.SharedContentViewType)
        /// (sharing) Changed who can access shared folder via link
        case sharedFolderChangeLinkPolicy(TeamLog.SharedFolderChangeLinkPolicyType)
        /// (sharing) Changed whether shared folder inherits members from parent folder
        case sharedFolderChangeMembersInheritancePolicy(TeamLog.SharedFolderChangeMembersInheritancePolicyType)
        /// (sharing) Changed who can add/remove members of shared folder
        case sharedFolderChangeMembersManagementPolicy(TeamLog.SharedFolderChangeMembersManagementPolicyType)
        /// (sharing) Changed who can become member of shared folder
        case sharedFolderChangeMembersPolicy(TeamLog.SharedFolderChangeMembersPolicyType)
        /// (sharing) Created shared folder
        case sharedFolderCreate(TeamLog.SharedFolderCreateType)
        /// (sharing) Declined team member's invite to shared folder
        case sharedFolderDeclineInvitation(TeamLog.SharedFolderDeclineInvitationType)
        /// (sharing) Added shared folder to own Dropbox
        case sharedFolderMount(TeamLog.SharedFolderMountType)
        /// (sharing) Changed parent of shared folder
        case sharedFolderNest(TeamLog.SharedFolderNestType)
        /// (sharing) Transferred ownership of shared folder to another member
        case sharedFolderTransferOwnership(TeamLog.SharedFolderTransferOwnershipType)
        /// (sharing) Deleted shared folder from Dropbox
        case sharedFolderUnmount(TeamLog.SharedFolderUnmountType)
        /// (sharing) Added shared link expiration date
        case sharedLinkAddExpiry(TeamLog.SharedLinkAddExpiryType)
        /// (sharing) Changed shared link expiration date
        case sharedLinkChangeExpiry(TeamLog.SharedLinkChangeExpiryType)
        /// (sharing) Changed visibility of shared link
        case sharedLinkChangeVisibility(TeamLog.SharedLinkChangeVisibilityType)
        /// (sharing) Added file/folder to Dropbox from shared link
        case sharedLinkCopy(TeamLog.SharedLinkCopyType)
        /// (sharing) Created shared link
        case sharedLinkCreate(TeamLog.SharedLinkCreateType)
        /// (sharing) Removed shared link
        case sharedLinkDisable(TeamLog.SharedLinkDisableType)
        /// (sharing) Downloaded file/folder from shared link
        case sharedLinkDownload(TeamLog.SharedLinkDownloadType)
        /// (sharing) Removed shared link expiration date
        case sharedLinkRemoveExpiry(TeamLog.SharedLinkRemoveExpiryType)
        /// (sharing) Added an expiration date to the shared link
        case sharedLinkSettingsAddExpiration(TeamLog.SharedLinkSettingsAddExpirationType)
        /// (sharing) Added a password to the shared link
        case sharedLinkSettingsAddPassword(TeamLog.SharedLinkSettingsAddPasswordType)
        /// (sharing) Disabled downloads
        case sharedLinkSettingsAllowDownloadDisabled(TeamLog.SharedLinkSettingsAllowDownloadDisabledType)
        /// (sharing) Enabled downloads
        case sharedLinkSettingsAllowDownloadEnabled(TeamLog.SharedLinkSettingsAllowDownloadEnabledType)
        /// (sharing) Changed the audience of the shared link
        case sharedLinkSettingsChangeAudience(TeamLog.SharedLinkSettingsChangeAudienceType)
        /// (sharing) Changed the expiration date of the shared link
        case sharedLinkSettingsChangeExpiration(TeamLog.SharedLinkSettingsChangeExpirationType)
        /// (sharing) Changed the password of the shared link
        case sharedLinkSettingsChangePassword(TeamLog.SharedLinkSettingsChangePasswordType)
        /// (sharing) Removed the expiration date from the shared link
        case sharedLinkSettingsRemoveExpiration(TeamLog.SharedLinkSettingsRemoveExpirationType)
        /// (sharing) Removed the password from the shared link
        case sharedLinkSettingsRemovePassword(TeamLog.SharedLinkSettingsRemovePasswordType)
        /// (sharing) Added members as audience of shared link
        case sharedLinkShare(TeamLog.SharedLinkShareType)
        /// (sharing) Opened shared link
        case sharedLinkView(TeamLog.SharedLinkViewType)
        /// (sharing) Opened shared Paper doc (deprecated, no longer logged)
        case sharedNoteOpened(TeamLog.SharedNoteOpenedType)
        /// (sharing) Disabled downloads for link (deprecated, no longer logged)
        case shmodelDisableDownloads(TeamLog.ShmodelDisableDownloadsType)
        /// (sharing) Enabled downloads for link (deprecated, no longer logged)
        case shmodelEnableDownloads(TeamLog.ShmodelEnableDownloadsType)
        /// (sharing) Shared link with group (deprecated, no longer logged)
        case shmodelGroupShare(TeamLog.ShmodelGroupShareType)
        /// (showcase) Granted access to showcase
        case showcaseAccessGranted(TeamLog.ShowcaseAccessGrantedType)
        /// (showcase) Added member to showcase
        case showcaseAddMember(TeamLog.ShowcaseAddMemberType)
        /// (showcase) Archived showcase
        case showcaseArchived(TeamLog.ShowcaseArchivedType)
        /// (showcase) Created showcase
        case showcaseCreated(TeamLog.ShowcaseCreatedType)
        /// (showcase) Deleted showcase comment
        case showcaseDeleteComment(TeamLog.ShowcaseDeleteCommentType)
        /// (showcase) Edited showcase
        case showcaseEdited(TeamLog.ShowcaseEditedType)
        /// (showcase) Edited showcase comment
        case showcaseEditComment(TeamLog.ShowcaseEditCommentType)
        /// (showcase) Added file to showcase
        case showcaseFileAdded(TeamLog.ShowcaseFileAddedType)
        /// (showcase) Downloaded file from showcase
        case showcaseFileDownload(TeamLog.ShowcaseFileDownloadType)
        /// (showcase) Removed file from showcase
        case showcaseFileRemoved(TeamLog.ShowcaseFileRemovedType)
        /// (showcase) Viewed file in showcase
        case showcaseFileView(TeamLog.ShowcaseFileViewType)
        /// (showcase) Permanently deleted showcase
        case showcasePermanentlyDeleted(TeamLog.ShowcasePermanentlyDeletedType)
        /// (showcase) Added showcase comment
        case showcasePostComment(TeamLog.ShowcasePostCommentType)
        /// (showcase) Removed member from showcase
        case showcaseRemoveMember(TeamLog.ShowcaseRemoveMemberType)
        /// (showcase) Renamed showcase
        case showcaseRenamed(TeamLog.ShowcaseRenamedType)
        /// (showcase) Requested access to showcase
        case showcaseRequestAccess(TeamLog.ShowcaseRequestAccessType)
        /// (showcase) Resolved showcase comment
        case showcaseResolveComment(TeamLog.ShowcaseResolveCommentType)
        /// (showcase) Unarchived showcase
        case showcaseRestored(TeamLog.ShowcaseRestoredType)
        /// (showcase) Deleted showcase
        case showcaseTrashed(TeamLog.ShowcaseTrashedType)
        /// (showcase) Deleted showcase (old version) (deprecated, replaced by 'Deleted showcase')
        case showcaseTrashedDeprecated(TeamLog.ShowcaseTrashedDeprecatedType)
        /// (showcase) Unresolved showcase comment
        case showcaseUnresolveComment(TeamLog.ShowcaseUnresolveCommentType)
        /// (showcase) Restored showcase
        case showcaseUntrashed(TeamLog.ShowcaseUntrashedType)
        /// (showcase) Restored showcase (old version) (deprecated, replaced by 'Restored showcase')
        case showcaseUntrashedDeprecated(TeamLog.ShowcaseUntrashedDeprecatedType)
        /// (showcase) Viewed showcase
        case showcaseView(TeamLog.ShowcaseViewType)
        /// (sso) Added X.509 certificate for SSO
        case ssoAddCert(TeamLog.SsoAddCertType)
        /// (sso) Added sign-in URL for SSO
        case ssoAddLoginUrl(TeamLog.SsoAddLoginUrlType)
        /// (sso) Added sign-out URL for SSO
        case ssoAddLogoutUrl(TeamLog.SsoAddLogoutUrlType)
        /// (sso) Changed X.509 certificate for SSO
        case ssoChangeCert(TeamLog.SsoChangeCertType)
        /// (sso) Changed sign-in URL for SSO
        case ssoChangeLoginUrl(TeamLog.SsoChangeLoginUrlType)
        /// (sso) Changed sign-out URL for SSO
        case ssoChangeLogoutUrl(TeamLog.SsoChangeLogoutUrlType)
        /// (sso) Changed SAML identity mode for SSO
        case ssoChangeSamlIdentityMode(TeamLog.SsoChangeSamlIdentityModeType)
        /// (sso) Removed X.509 certificate for SSO
        case ssoRemoveCert(TeamLog.SsoRemoveCertType)
        /// (sso) Removed sign-in URL for SSO
        case ssoRemoveLoginUrl(TeamLog.SsoRemoveLoginUrlType)
        /// (sso) Removed sign-out URL for SSO
        case ssoRemoveLogoutUrl(TeamLog.SsoRemoveLogoutUrlType)
        /// (team_folders) Changed archival status of team folder
        case teamFolderChangeStatus(TeamLog.TeamFolderChangeStatusType)
        /// (team_folders) Created team folder in active status
        case teamFolderCreate(TeamLog.TeamFolderCreateType)
        /// (team_folders) Downgraded team folder to regular shared folder
        case teamFolderDowngrade(TeamLog.TeamFolderDowngradeType)
        /// (team_folders) Permanently deleted archived team folder
        case teamFolderPermanentlyDelete(TeamLog.TeamFolderPermanentlyDeleteType)
        /// (team_folders) Renamed active/archived team folder
        case teamFolderRename(TeamLog.TeamFolderRenameType)
        /// (team_folders) Changed sync default
        case teamSelectiveSyncSettingsChanged(TeamLog.TeamSelectiveSyncSettingsChangedType)
        /// (team_policies) Changed account capture setting on team domain
        case accountCaptureChangePolicy(TeamLog.AccountCaptureChangePolicyType)
        /// (team_policies) Changed admin reminder settings for requests to join the team
        case adminEmailRemindersChanged(TeamLog.AdminEmailRemindersChangedType)
        /// (team_policies) Disabled downloads (deprecated, no longer logged)
        case allowDownloadDisabled(TeamLog.AllowDownloadDisabledType)
        /// (team_policies) Enabled downloads (deprecated, no longer logged)
        case allowDownloadEnabled(TeamLog.AllowDownloadEnabledType)
        /// (team_policies) Changed app permissions
        case appPermissionsChanged(TeamLog.AppPermissionsChangedType)
        /// (team_policies) Changed camera uploads setting for team
        case cameraUploadsPolicyChanged(TeamLog.CameraUploadsPolicyChangedType)
        /// (team_policies) Changed Capture transcription policy for team
        case captureTranscriptPolicyChanged(TeamLog.CaptureTranscriptPolicyChangedType)
        /// (team_policies) Changed classification policy for team
        case classificationChangePolicy(TeamLog.ClassificationChangePolicyType)
        /// (team_policies) Changed computer backup policy for team
        case computerBackupPolicyChanged(TeamLog.ComputerBackupPolicyChangedType)
        /// (team_policies) Changed content management setting
        case contentAdministrationPolicyChanged(TeamLog.ContentAdministrationPolicyChangedType)
        /// (team_policies) Set restrictions on data center locations where team data resides
        case dataPlacementRestrictionChangePolicy(TeamLog.DataPlacementRestrictionChangePolicyType)
        /// (team_policies) Completed restrictions on data center locations where team data resides
        case dataPlacementRestrictionSatisfyPolicy(TeamLog.DataPlacementRestrictionSatisfyPolicyType)
        /// (team_policies) Added members to device approvals exception list
        case deviceApprovalsAddException(TeamLog.DeviceApprovalsAddExceptionType)
        /// (team_policies) Set/removed limit on number of computers member can link to team Dropbox account
        case deviceApprovalsChangeDesktopPolicy(TeamLog.DeviceApprovalsChangeDesktopPolicyType)
        /// (team_policies) Set/removed limit on number of mobile devices member can link to team Dropbox account
        case deviceApprovalsChangeMobilePolicy(TeamLog.DeviceApprovalsChangeMobilePolicyType)
        /// (team_policies) Changed device approvals setting when member is over limit
        case deviceApprovalsChangeOverageAction(TeamLog.DeviceApprovalsChangeOverageActionType)
        /// (team_policies) Changed device approvals setting when member unlinks approved device
        case deviceApprovalsChangeUnlinkAction(TeamLog.DeviceApprovalsChangeUnlinkActionType)
        /// (team_policies) Removed members from device approvals exception list
        case deviceApprovalsRemoveException(TeamLog.DeviceApprovalsRemoveExceptionType)
        /// (team_policies) Added members to directory restrictions list
        case directoryRestrictionsAddMembers(TeamLog.DirectoryRestrictionsAddMembersType)
        /// (team_policies) Removed members from directory restrictions list
        case directoryRestrictionsRemoveMembers(TeamLog.DirectoryRestrictionsRemoveMembersType)
        /// (team_policies) Changed Dropbox Passwords policy for team
        case dropboxPasswordsPolicyChanged(TeamLog.DropboxPasswordsPolicyChangedType)
        /// (team_policies) Changed email to Dropbox policy for team
        case emailIngestPolicyChanged(TeamLog.EmailIngestPolicyChangedType)
        /// (team_policies) Added members to EMM exception list
        case emmAddException(TeamLog.EmmAddExceptionType)
        /// (team_policies) Enabled/disabled enterprise mobility management for members
        case emmChangePolicy(TeamLog.EmmChangePolicyType)
        /// (team_policies) Removed members from EMM exception list
        case emmRemoveException(TeamLog.EmmRemoveExceptionType)
        /// (team_policies) Accepted/opted out of extended version history
        case extendedVersionHistoryChangePolicy(TeamLog.ExtendedVersionHistoryChangePolicyType)
        /// (team_policies) Changed external drive backup policy for team
        case externalDriveBackupPolicyChanged(TeamLog.ExternalDriveBackupPolicyChangedType)
        /// (team_policies) Enabled/disabled commenting on team files
        case fileCommentsChangePolicy(TeamLog.FileCommentsChangePolicyType)
        /// (team_policies) Changed file locking policy for team
        case fileLockingPolicyChanged(TeamLog.FileLockingPolicyChangedType)
        /// (team_policies) Changed File Provider Migration policy for team
        case fileProviderMigrationPolicyChanged(TeamLog.FileProviderMigrationPolicyChangedType)
        /// (team_policies) Enabled/disabled file requests
        case fileRequestsChangePolicy(TeamLog.FileRequestsChangePolicyType)
        /// (team_policies) Enabled file request emails for everyone (deprecated, no longer logged)
        case fileRequestsEmailsEnabled(TeamLog.FileRequestsEmailsEnabledType)
        /// (team_policies) Enabled file request emails for team (deprecated, no longer logged)
        case fileRequestsEmailsRestrictedToTeamOnly(TeamLog.FileRequestsEmailsRestrictedToTeamOnlyType)
        /// (team_policies) Changed file transfers policy for team
        case fileTransfersPolicyChanged(TeamLog.FileTransfersPolicyChangedType)
        /// (team_policies) Changed folder link restrictions policy for team
        case folderLinkRestrictionPolicyChanged(TeamLog.FolderLinkRestrictionPolicyChangedType)
        /// (team_policies) Enabled/disabled Google single sign-on for team
        case googleSsoChangePolicy(TeamLog.GoogleSsoChangePolicyType)
        /// (team_policies) Changed who can create groups
        case groupUserManagementChangePolicy(TeamLog.GroupUserManagementChangePolicyType)
        /// (team_policies) Changed integration policy for team
        case integrationPolicyChanged(TeamLog.IntegrationPolicyChangedType)
        /// (team_policies) Changed invite accept email policy for team
        case inviteAcceptanceEmailPolicyChanged(TeamLog.InviteAcceptanceEmailPolicyChangedType)
        /// (team_policies) Changed whether users can find team when not invited
        case memberRequestsChangePolicy(TeamLog.MemberRequestsChangePolicyType)
        /// (team_policies) Changed member send invite policy for team
        case memberSendInvitePolicyChanged(TeamLog.MemberSendInvitePolicyChangedType)
        /// (team_policies) Added members to member space limit exception list
        case memberSpaceLimitsAddException(TeamLog.MemberSpaceLimitsAddExceptionType)
        /// (team_policies) Changed member space limit type for team
        case memberSpaceLimitsChangeCapsTypePolicy(TeamLog.MemberSpaceLimitsChangeCapsTypePolicyType)
        /// (team_policies) Changed team default member space limit
        case memberSpaceLimitsChangePolicy(TeamLog.MemberSpaceLimitsChangePolicyType)
        /// (team_policies) Removed members from member space limit exception list
        case memberSpaceLimitsRemoveException(TeamLog.MemberSpaceLimitsRemoveExceptionType)
        /// (team_policies) Enabled/disabled option for team members to suggest people to add to team
        case memberSuggestionsChangePolicy(TeamLog.MemberSuggestionsChangePolicyType)
        /// (team_policies) Enabled/disabled Microsoft Office add-in
        case microsoftOfficeAddinChangePolicy(TeamLog.MicrosoftOfficeAddinChangePolicyType)
        /// (team_policies) Enabled/disabled network control
        case networkControlChangePolicy(TeamLog.NetworkControlChangePolicyType)
        /// (team_policies) Changed whether Dropbox Paper, when enabled, is deployed to all members or to specific
        /// members
        case paperChangeDeploymentPolicy(TeamLog.PaperChangeDeploymentPolicyType)
        /// (team_policies) Changed whether non-members can view Paper docs with link (deprecated, no longer logged)
        case paperChangeMemberLinkPolicy(TeamLog.PaperChangeMemberLinkPolicyType)
        /// (team_policies) Changed whether members can share Paper docs outside team, and if docs are accessible only
        /// by team members or anyone by default
        case paperChangeMemberPolicy(TeamLog.PaperChangeMemberPolicyType)
        /// (team_policies) Enabled/disabled Dropbox Paper for team
        case paperChangePolicy(TeamLog.PaperChangePolicyType)
        /// (team_policies) Changed Paper Default Folder Policy setting for team
        case paperDefaultFolderPolicyChanged(TeamLog.PaperDefaultFolderPolicyChangedType)
        /// (team_policies) Enabled/disabled Paper Desktop for team
        case paperDesktopPolicyChanged(TeamLog.PaperDesktopPolicyChangedType)
        /// (team_policies) Added users to Paper-enabled users list
        case paperEnabledUsersGroupAddition(TeamLog.PaperEnabledUsersGroupAdditionType)
        /// (team_policies) Removed users from Paper-enabled users list
        case paperEnabledUsersGroupRemoval(TeamLog.PaperEnabledUsersGroupRemovalType)
        /// (team_policies) Changed team password strength requirements
        case passwordStrengthRequirementsChangePolicy(TeamLog.PasswordStrengthRequirementsChangePolicyType)
        /// (team_policies) Enabled/disabled ability of team members to permanently delete content
        case permanentDeleteChangePolicy(TeamLog.PermanentDeleteChangePolicyType)
        /// (team_policies) Enabled/disabled reseller support
        case resellerSupportChangePolicy(TeamLog.ResellerSupportChangePolicyType)
        /// (team_policies) Changed Rewind policy for team
        case rewindPolicyChanged(TeamLog.RewindPolicyChangedType)
        /// (team_policies) Changed send for signature policy for team
        case sendForSignaturePolicyChanged(TeamLog.SendForSignaturePolicyChangedType)
        /// (team_policies) Changed whether team members can join shared folders owned outside team
        case sharingChangeFolderJoinPolicy(TeamLog.SharingChangeFolderJoinPolicyType)
        /// (team_policies) Changed the allow remove or change expiration policy for the links shared outside of the
        /// team
        case sharingChangeLinkAllowChangeExpirationPolicy(TeamLog.SharingChangeLinkAllowChangeExpirationPolicyType)
        /// (team_policies) Changed the default expiration for the links shared outside of the team
        case sharingChangeLinkDefaultExpirationPolicy(TeamLog.SharingChangeLinkDefaultExpirationPolicyType)
        /// (team_policies) Changed the password requirement for the links shared outside of the team
        case sharingChangeLinkEnforcePasswordPolicy(TeamLog.SharingChangeLinkEnforcePasswordPolicyType)
        /// (team_policies) Changed whether members can share links outside team, and if links are accessible only by
        /// team members or anyone by default
        case sharingChangeLinkPolicy(TeamLog.SharingChangeLinkPolicyType)
        /// (team_policies) Changed whether members can share files/folders outside team
        case sharingChangeMemberPolicy(TeamLog.SharingChangeMemberPolicyType)
        /// (team_policies) Enabled/disabled downloading files from Dropbox Showcase for team
        case showcaseChangeDownloadPolicy(TeamLog.ShowcaseChangeDownloadPolicyType)
        /// (team_policies) Enabled/disabled Dropbox Showcase for team
        case showcaseChangeEnabledPolicy(TeamLog.ShowcaseChangeEnabledPolicyType)
        /// (team_policies) Enabled/disabled sharing Dropbox Showcase externally for team
        case showcaseChangeExternalSharingPolicy(TeamLog.ShowcaseChangeExternalSharingPolicyType)
        /// (team_policies) Changed automatic Smart Sync setting for team
        case smarterSmartSyncPolicyChanged(TeamLog.SmarterSmartSyncPolicyChangedType)
        /// (team_policies) Changed default Smart Sync setting for team members
        case smartSyncChangePolicy(TeamLog.SmartSyncChangePolicyType)
        /// (team_policies) Opted team into Smart Sync
        case smartSyncNotOptOut(TeamLog.SmartSyncNotOptOutType)
        /// (team_policies) Opted team out of Smart Sync
        case smartSyncOptOut(TeamLog.SmartSyncOptOutType)
        /// (team_policies) Changed single sign-on setting for team
        case ssoChangePolicy(TeamLog.SsoChangePolicyType)
        /// (team_policies) Changed team branding policy for team
        case teamBrandingPolicyChanged(TeamLog.TeamBrandingPolicyChangedType)
        /// (team_policies) Changed App Integrations setting for team
        case teamExtensionsPolicyChanged(TeamLog.TeamExtensionsPolicyChangedType)
        /// (team_policies) Enabled/disabled Team Selective Sync for team
        case teamSelectiveSyncPolicyChanged(TeamLog.TeamSelectiveSyncPolicyChangedType)
        /// (team_policies) Edited the approved list for sharing externally
        case teamSharingWhitelistSubjectsChanged(TeamLog.TeamSharingWhitelistSubjectsChangedType)
        /// (team_policies) Added members to two factor authentication exception list
        case tfaAddException(TeamLog.TfaAddExceptionType)
        /// (team_policies) Changed two-step verification setting for team
        case tfaChangePolicy(TeamLog.TfaChangePolicyType)
        /// (team_policies) Removed members from two factor authentication exception list
        case tfaRemoveException(TeamLog.TfaRemoveExceptionType)
        /// (team_policies) Enabled/disabled option for members to link personal Dropbox account and team account to
        /// same computer
        case twoAccountChangePolicy(TeamLog.TwoAccountChangePolicyType)
        /// (team_policies) Changed team policy for viewer info
        case viewerInfoPolicyChanged(TeamLog.ViewerInfoPolicyChangedType)
        /// (team_policies) Changed watermarking policy for team
        case watermarkingPolicyChanged(TeamLog.WatermarkingPolicyChangedType)
        /// (team_policies) Changed limit on active sessions per member
        case webSessionsChangeActiveSessionLimit(TeamLog.WebSessionsChangeActiveSessionLimitType)
        /// (team_policies) Changed how long members can stay signed in to Dropbox.com
        case webSessionsChangeFixedLengthPolicy(TeamLog.WebSessionsChangeFixedLengthPolicyType)
        /// (team_policies) Changed how long team members can be idle while signed in to Dropbox.com
        case webSessionsChangeIdleLengthPolicy(TeamLog.WebSessionsChangeIdleLengthPolicyType)
        /// (team_profile) Requested data residency migration for team data
        case dataResidencyMigrationRequestSuccessful(TeamLog.DataResidencyMigrationRequestSuccessfulType)
        /// (team_profile) Request for data residency migration for team data has failed
        case dataResidencyMigrationRequestUnsuccessful(TeamLog.DataResidencyMigrationRequestUnsuccessfulType)
        /// (team_profile) Merged another team into this team
        case teamMergeFrom(TeamLog.TeamMergeFromType)
        /// (team_profile) Merged this team into another team
        case teamMergeTo(TeamLog.TeamMergeToType)
        /// (team_profile) Added team background to display on shared link headers
        case teamProfileAddBackground(TeamLog.TeamProfileAddBackgroundType)
        /// (team_profile) Added team logo to display on shared link headers
        case teamProfileAddLogo(TeamLog.TeamProfileAddLogoType)
        /// (team_profile) Changed team background displayed on shared link headers
        case teamProfileChangeBackground(TeamLog.TeamProfileChangeBackgroundType)
        /// (team_profile) Changed default language for team
        case teamProfileChangeDefaultLanguage(TeamLog.TeamProfileChangeDefaultLanguageType)
        /// (team_profile) Changed team logo displayed on shared link headers
        case teamProfileChangeLogo(TeamLog.TeamProfileChangeLogoType)
        /// (team_profile) Changed team name
        case teamProfileChangeName(TeamLog.TeamProfileChangeNameType)
        /// (team_profile) Removed team background displayed on shared link headers
        case teamProfileRemoveBackground(TeamLog.TeamProfileRemoveBackgroundType)
        /// (team_profile) Removed team logo displayed on shared link headers
        case teamProfileRemoveLogo(TeamLog.TeamProfileRemoveLogoType)
        /// (tfa) Added backup phone for two-step verification
        case tfaAddBackupPhone(TeamLog.TfaAddBackupPhoneType)
        /// (tfa) Added security key for two-step verification
        case tfaAddSecurityKey(TeamLog.TfaAddSecurityKeyType)
        /// (tfa) Changed backup phone for two-step verification
        case tfaChangeBackupPhone(TeamLog.TfaChangeBackupPhoneType)
        /// (tfa) Enabled/disabled/changed two-step verification setting
        case tfaChangeStatus(TeamLog.TfaChangeStatusType)
        /// (tfa) Removed backup phone for two-step verification
        case tfaRemoveBackupPhone(TeamLog.TfaRemoveBackupPhoneType)
        /// (tfa) Removed security key for two-step verification
        case tfaRemoveSecurityKey(TeamLog.TfaRemoveSecurityKeyType)
        /// (tfa) Reset two-step verification for team member
        case tfaReset(TeamLog.TfaResetType)
        /// (trusted_teams) Changed enterprise admin role
        case changedEnterpriseAdminRole(TeamLog.ChangedEnterpriseAdminRoleType)
        /// (trusted_teams) Changed enterprise-connected team status
        case changedEnterpriseConnectedTeamStatus(TeamLog.ChangedEnterpriseConnectedTeamStatusType)
        /// (trusted_teams) Ended enterprise admin session
        case endedEnterpriseAdminSession(TeamLog.EndedEnterpriseAdminSessionType)
        /// (trusted_teams) Ended enterprise admin session (deprecated, replaced by 'Ended enterprise admin session')
        case endedEnterpriseAdminSessionDeprecated(TeamLog.EndedEnterpriseAdminSessionDeprecatedType)
        /// (trusted_teams) Changed who can update a setting
        case enterpriseSettingsLocking(TeamLog.EnterpriseSettingsLockingType)
        /// (trusted_teams) Changed guest team admin status
        case guestAdminChangeStatus(TeamLog.GuestAdminChangeStatusType)
        /// (trusted_teams) Started enterprise admin session
        case startedEnterpriseAdminSession(TeamLog.StartedEnterpriseAdminSessionType)
        /// (trusted_teams) Accepted a team merge request
        case teamMergeRequestAccepted(TeamLog.TeamMergeRequestAcceptedType)
        /// (trusted_teams) Accepted a team merge request (deprecated, replaced by 'Accepted a team merge request')
        case teamMergeRequestAcceptedShownToPrimaryTeam(TeamLog.TeamMergeRequestAcceptedShownToPrimaryTeamType)
        /// (trusted_teams) Accepted a team merge request (deprecated, replaced by 'Accepted a team merge request')
        case teamMergeRequestAcceptedShownToSecondaryTeam(TeamLog.TeamMergeRequestAcceptedShownToSecondaryTeamType)
        /// (trusted_teams) Automatically canceled team merge request
        case teamMergeRequestAutoCanceled(TeamLog.TeamMergeRequestAutoCanceledType)
        /// (trusted_teams) Canceled a team merge request
        case teamMergeRequestCanceled(TeamLog.TeamMergeRequestCanceledType)
        /// (trusted_teams) Canceled a team merge request (deprecated, replaced by 'Canceled a team merge request')
        case teamMergeRequestCanceledShownToPrimaryTeam(TeamLog.TeamMergeRequestCanceledShownToPrimaryTeamType)
        /// (trusted_teams) Canceled a team merge request (deprecated, replaced by 'Canceled a team merge request')
        case teamMergeRequestCanceledShownToSecondaryTeam(TeamLog.TeamMergeRequestCanceledShownToSecondaryTeamType)
        /// (trusted_teams) Team merge request expired
        case teamMergeRequestExpired(TeamLog.TeamMergeRequestExpiredType)
        /// (trusted_teams) Team merge request expired (deprecated, replaced by 'Team merge request expired')
        case teamMergeRequestExpiredShownToPrimaryTeam(TeamLog.TeamMergeRequestExpiredShownToPrimaryTeamType)
        /// (trusted_teams) Team merge request expired (deprecated, replaced by 'Team merge request expired')
        case teamMergeRequestExpiredShownToSecondaryTeam(TeamLog.TeamMergeRequestExpiredShownToSecondaryTeamType)
        /// (trusted_teams) Rejected a team merge request (deprecated, no longer logged)
        case teamMergeRequestRejectedShownToPrimaryTeam(TeamLog.TeamMergeRequestRejectedShownToPrimaryTeamType)
        /// (trusted_teams) Rejected a team merge request (deprecated, no longer logged)
        case teamMergeRequestRejectedShownToSecondaryTeam(TeamLog.TeamMergeRequestRejectedShownToSecondaryTeamType)
        /// (trusted_teams) Sent a team merge request reminder
        case teamMergeRequestReminder(TeamLog.TeamMergeRequestReminderType)
        /// (trusted_teams) Sent a team merge request reminder (deprecated, replaced by 'Sent a team merge request
        /// reminder')
        case teamMergeRequestReminderShownToPrimaryTeam(TeamLog.TeamMergeRequestReminderShownToPrimaryTeamType)
        /// (trusted_teams) Sent a team merge request reminder (deprecated, replaced by 'Sent a team merge request
        /// reminder')
        case teamMergeRequestReminderShownToSecondaryTeam(TeamLog.TeamMergeRequestReminderShownToSecondaryTeamType)
        /// (trusted_teams) Canceled the team merge
        case teamMergeRequestRevoked(TeamLog.TeamMergeRequestRevokedType)
        /// (trusted_teams) Requested to merge their Dropbox team into yours
        case teamMergeRequestSentShownToPrimaryTeam(TeamLog.TeamMergeRequestSentShownToPrimaryTeamType)
        /// (trusted_teams) Requested to merge your team into another Dropbox team
        case teamMergeRequestSentShownToSecondaryTeam(TeamLog.TeamMergeRequestSentShownToSecondaryTeamType)
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try EventTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try EventTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for EventType: \(error)"
            }
        }
    }

    public class EventTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: EventType) throws -> JSON {
            switch value {
            case .adminAlertingAlertStateChanged(let arg):
                var d = try Serialization.getFields(TeamLog.AdminAlertingAlertStateChangedTypeSerializer().serialize(arg))
                d[".tag"] = .str("admin_alerting_alert_state_changed")
                return .dictionary(d)
            case .adminAlertingChangedAlertConfig(let arg):
                var d = try Serialization.getFields(TeamLog.AdminAlertingChangedAlertConfigTypeSerializer().serialize(arg))
                d[".tag"] = .str("admin_alerting_changed_alert_config")
                return .dictionary(d)
            case .adminAlertingTriggeredAlert(let arg):
                var d = try Serialization.getFields(TeamLog.AdminAlertingTriggeredAlertTypeSerializer().serialize(arg))
                d[".tag"] = .str("admin_alerting_triggered_alert")
                return .dictionary(d)
            case .ransomwareRestoreProcessCompleted(let arg):
                var d = try Serialization.getFields(TeamLog.RansomwareRestoreProcessCompletedTypeSerializer().serialize(arg))
                d[".tag"] = .str("ransomware_restore_process_completed")
                return .dictionary(d)
            case .ransomwareRestoreProcessStarted(let arg):
                var d = try Serialization.getFields(TeamLog.RansomwareRestoreProcessStartedTypeSerializer().serialize(arg))
                d[".tag"] = .str("ransomware_restore_process_started")
                return .dictionary(d)
            case .appBlockedByPermissions(let arg):
                var d = try Serialization.getFields(TeamLog.AppBlockedByPermissionsTypeSerializer().serialize(arg))
                d[".tag"] = .str("app_blocked_by_permissions")
                return .dictionary(d)
            case .appLinkTeam(let arg):
                var d = try Serialization.getFields(TeamLog.AppLinkTeamTypeSerializer().serialize(arg))
                d[".tag"] = .str("app_link_team")
                return .dictionary(d)
            case .appLinkUser(let arg):
                var d = try Serialization.getFields(TeamLog.AppLinkUserTypeSerializer().serialize(arg))
                d[".tag"] = .str("app_link_user")
                return .dictionary(d)
            case .appUnlinkTeam(let arg):
                var d = try Serialization.getFields(TeamLog.AppUnlinkTeamTypeSerializer().serialize(arg))
                d[".tag"] = .str("app_unlink_team")
                return .dictionary(d)
            case .appUnlinkUser(let arg):
                var d = try Serialization.getFields(TeamLog.AppUnlinkUserTypeSerializer().serialize(arg))
                d[".tag"] = .str("app_unlink_user")
                return .dictionary(d)
            case .integrationConnected(let arg):
                var d = try Serialization.getFields(TeamLog.IntegrationConnectedTypeSerializer().serialize(arg))
                d[".tag"] = .str("integration_connected")
                return .dictionary(d)
            case .integrationDisconnected(let arg):
                var d = try Serialization.getFields(TeamLog.IntegrationDisconnectedTypeSerializer().serialize(arg))
                d[".tag"] = .str("integration_disconnected")
                return .dictionary(d)
            case .fileAddComment(let arg):
                var d = try Serialization.getFields(TeamLog.FileAddCommentTypeSerializer().serialize(arg))
                d[".tag"] = .str("file_add_comment")
                return .dictionary(d)
            case .fileChangeCommentSubscription(let arg):
                var d = try Serialization.getFields(TeamLog.FileChangeCommentSubscriptionTypeSerializer().serialize(arg))
                d[".tag"] = .str("file_change_comment_subscription")
                return .dictionary(d)
            case .fileDeleteComment(let arg):
                var d = try Serialization.getFields(TeamLog.FileDeleteCommentTypeSerializer().serialize(arg))
                d[".tag"] = .str("file_delete_comment")
                return .dictionary(d)
            case .fileEditComment(let arg):
                var d = try Serialization.getFields(TeamLog.FileEditCommentTypeSerializer().serialize(arg))
                d[".tag"] = .str("file_edit_comment")
                return .dictionary(d)
            case .fileLikeComment(let arg):
                var d = try Serialization.getFields(TeamLog.FileLikeCommentTypeSerializer().serialize(arg))
                d[".tag"] = .str("file_like_comment")
                return .dictionary(d)
            case .fileResolveComment(let arg):
                var d = try Serialization.getFields(TeamLog.FileResolveCommentTypeSerializer().serialize(arg))
                d[".tag"] = .str("file_resolve_comment")
                return .dictionary(d)
            case .fileUnlikeComment(let arg):
                var d = try Serialization.getFields(TeamLog.FileUnlikeCommentTypeSerializer().serialize(arg))
                d[".tag"] = .str("file_unlike_comment")
                return .dictionary(d)
            case .fileUnresolveComment(let arg):
                var d = try Serialization.getFields(TeamLog.FileUnresolveCommentTypeSerializer().serialize(arg))
                d[".tag"] = .str("file_unresolve_comment")
                return .dictionary(d)
            case .governancePolicyAddFolders(let arg):
                var d = try Serialization.getFields(TeamLog.GovernancePolicyAddFoldersTypeSerializer().serialize(arg))
                d[".tag"] = .str("governance_policy_add_folders")
                return .dictionary(d)
            case .governancePolicyAddFolderFailed(let arg):
                var d = try Serialization.getFields(TeamLog.GovernancePolicyAddFolderFailedTypeSerializer().serialize(arg))
                d[".tag"] = .str("governance_policy_add_folder_failed")
                return .dictionary(d)
            case .governancePolicyContentDisposed(let arg):
                var d = try Serialization.getFields(TeamLog.GovernancePolicyContentDisposedTypeSerializer().serialize(arg))
                d[".tag"] = .str("governance_policy_content_disposed")
                return .dictionary(d)
            case .governancePolicyCreate(let arg):
                var d = try Serialization.getFields(TeamLog.GovernancePolicyCreateTypeSerializer().serialize(arg))
                d[".tag"] = .str("governance_policy_create")
                return .dictionary(d)
            case .governancePolicyDelete(let arg):
                var d = try Serialization.getFields(TeamLog.GovernancePolicyDeleteTypeSerializer().serialize(arg))
                d[".tag"] = .str("governance_policy_delete")
                return .dictionary(d)
            case .governancePolicyEditDetails(let arg):
                var d = try Serialization.getFields(TeamLog.GovernancePolicyEditDetailsTypeSerializer().serialize(arg))
                d[".tag"] = .str("governance_policy_edit_details")
                return .dictionary(d)
            case .governancePolicyEditDuration(let arg):
                var d = try Serialization.getFields(TeamLog.GovernancePolicyEditDurationTypeSerializer().serialize(arg))
                d[".tag"] = .str("governance_policy_edit_duration")
                return .dictionary(d)
            case .governancePolicyExportCreated(let arg):
                var d = try Serialization.getFields(TeamLog.GovernancePolicyExportCreatedTypeSerializer().serialize(arg))
                d[".tag"] = .str("governance_policy_export_created")
                return .dictionary(d)
            case .governancePolicyExportRemoved(let arg):
                var d = try Serialization.getFields(TeamLog.GovernancePolicyExportRemovedTypeSerializer().serialize(arg))
                d[".tag"] = .str("governance_policy_export_removed")
                return .dictionary(d)
            case .governancePolicyRemoveFolders(let arg):
                var d = try Serialization.getFields(TeamLog.GovernancePolicyRemoveFoldersTypeSerializer().serialize(arg))
                d[".tag"] = .str("governance_policy_remove_folders")
                return .dictionary(d)
            case .governancePolicyReportCreated(let arg):
                var d = try Serialization.getFields(TeamLog.GovernancePolicyReportCreatedTypeSerializer().serialize(arg))
                d[".tag"] = .str("governance_policy_report_created")
                return .dictionary(d)
            case .governancePolicyZipPartDownloaded(let arg):
                var d = try Serialization.getFields(TeamLog.GovernancePolicyZipPartDownloadedTypeSerializer().serialize(arg))
                d[".tag"] = .str("governance_policy_zip_part_downloaded")
                return .dictionary(d)
            case .legalHoldsActivateAHold(let arg):
                var d = try Serialization.getFields(TeamLog.LegalHoldsActivateAHoldTypeSerializer().serialize(arg))
                d[".tag"] = .str("legal_holds_activate_a_hold")
                return .dictionary(d)
            case .legalHoldsAddMembers(let arg):
                var d = try Serialization.getFields(TeamLog.LegalHoldsAddMembersTypeSerializer().serialize(arg))
                d[".tag"] = .str("legal_holds_add_members")
                return .dictionary(d)
            case .legalHoldsChangeHoldDetails(let arg):
                var d = try Serialization.getFields(TeamLog.LegalHoldsChangeHoldDetailsTypeSerializer().serialize(arg))
                d[".tag"] = .str("legal_holds_change_hold_details")
                return .dictionary(d)
            case .legalHoldsChangeHoldName(let arg):
                var d = try Serialization.getFields(TeamLog.LegalHoldsChangeHoldNameTypeSerializer().serialize(arg))
                d[".tag"] = .str("legal_holds_change_hold_name")
                return .dictionary(d)
            case .legalHoldsExportAHold(let arg):
                var d = try Serialization.getFields(TeamLog.LegalHoldsExportAHoldTypeSerializer().serialize(arg))
                d[".tag"] = .str("legal_holds_export_a_hold")
                return .dictionary(d)
            case .legalHoldsExportCancelled(let arg):
                var d = try Serialization.getFields(TeamLog.LegalHoldsExportCancelledTypeSerializer().serialize(arg))
                d[".tag"] = .str("legal_holds_export_cancelled")
                return .dictionary(d)
            case .legalHoldsExportDownloaded(let arg):
                var d = try Serialization.getFields(TeamLog.LegalHoldsExportDownloadedTypeSerializer().serialize(arg))
                d[".tag"] = .str("legal_holds_export_downloaded")
                return .dictionary(d)
            case .legalHoldsExportRemoved(let arg):
                var d = try Serialization.getFields(TeamLog.LegalHoldsExportRemovedTypeSerializer().serialize(arg))
                d[".tag"] = .str("legal_holds_export_removed")
                return .dictionary(d)
            case .legalHoldsReleaseAHold(let arg):
                var d = try Serialization.getFields(TeamLog.LegalHoldsReleaseAHoldTypeSerializer().serialize(arg))
                d[".tag"] = .str("legal_holds_release_a_hold")
                return .dictionary(d)
            case .legalHoldsRemoveMembers(let arg):
                var d = try Serialization.getFields(TeamLog.LegalHoldsRemoveMembersTypeSerializer().serialize(arg))
                d[".tag"] = .str("legal_holds_remove_members")
                return .dictionary(d)
            case .legalHoldsReportAHold(let arg):
                var d = try Serialization.getFields(TeamLog.LegalHoldsReportAHoldTypeSerializer().serialize(arg))
                d[".tag"] = .str("legal_holds_report_a_hold")
                return .dictionary(d)
            case .deviceChangeIpDesktop(let arg):
                var d = try Serialization.getFields(TeamLog.DeviceChangeIpDesktopTypeSerializer().serialize(arg))
                d[".tag"] = .str("device_change_ip_desktop")
                return .dictionary(d)
            case .deviceChangeIpMobile(let arg):
                var d = try Serialization.getFields(TeamLog.DeviceChangeIpMobileTypeSerializer().serialize(arg))
                d[".tag"] = .str("device_change_ip_mobile")
                return .dictionary(d)
            case .deviceChangeIpWeb(let arg):
                var d = try Serialization.getFields(TeamLog.DeviceChangeIpWebTypeSerializer().serialize(arg))
                d[".tag"] = .str("device_change_ip_web")
                return .dictionary(d)
            case .deviceDeleteOnUnlinkFail(let arg):
                var d = try Serialization.getFields(TeamLog.DeviceDeleteOnUnlinkFailTypeSerializer().serialize(arg))
                d[".tag"] = .str("device_delete_on_unlink_fail")
                return .dictionary(d)
            case .deviceDeleteOnUnlinkSuccess(let arg):
                var d = try Serialization.getFields(TeamLog.DeviceDeleteOnUnlinkSuccessTypeSerializer().serialize(arg))
                d[".tag"] = .str("device_delete_on_unlink_success")
                return .dictionary(d)
            case .deviceLinkFail(let arg):
                var d = try Serialization.getFields(TeamLog.DeviceLinkFailTypeSerializer().serialize(arg))
                d[".tag"] = .str("device_link_fail")
                return .dictionary(d)
            case .deviceLinkSuccess(let arg):
                var d = try Serialization.getFields(TeamLog.DeviceLinkSuccessTypeSerializer().serialize(arg))
                d[".tag"] = .str("device_link_success")
                return .dictionary(d)
            case .deviceManagementDisabled(let arg):
                var d = try Serialization.getFields(TeamLog.DeviceManagementDisabledTypeSerializer().serialize(arg))
                d[".tag"] = .str("device_management_disabled")
                return .dictionary(d)
            case .deviceManagementEnabled(let arg):
                var d = try Serialization.getFields(TeamLog.DeviceManagementEnabledTypeSerializer().serialize(arg))
                d[".tag"] = .str("device_management_enabled")
                return .dictionary(d)
            case .deviceSyncBackupStatusChanged(let arg):
                var d = try Serialization.getFields(TeamLog.DeviceSyncBackupStatusChangedTypeSerializer().serialize(arg))
                d[".tag"] = .str("device_sync_backup_status_changed")
                return .dictionary(d)
            case .deviceUnlink(let arg):
                var d = try Serialization.getFields(TeamLog.DeviceUnlinkTypeSerializer().serialize(arg))
                d[".tag"] = .str("device_unlink")
                return .dictionary(d)
            case .dropboxPasswordsExported(let arg):
                var d = try Serialization.getFields(TeamLog.DropboxPasswordsExportedTypeSerializer().serialize(arg))
                d[".tag"] = .str("dropbox_passwords_exported")
                return .dictionary(d)
            case .dropboxPasswordsNewDeviceEnrolled(let arg):
                var d = try Serialization.getFields(TeamLog.DropboxPasswordsNewDeviceEnrolledTypeSerializer().serialize(arg))
                d[".tag"] = .str("dropbox_passwords_new_device_enrolled")
                return .dictionary(d)
            case .emmRefreshAuthToken(let arg):
                var d = try Serialization.getFields(TeamLog.EmmRefreshAuthTokenTypeSerializer().serialize(arg))
                d[".tag"] = .str("emm_refresh_auth_token")
                return .dictionary(d)
            case .externalDriveBackupEligibilityStatusChecked(let arg):
                var d = try Serialization.getFields(TeamLog.ExternalDriveBackupEligibilityStatusCheckedTypeSerializer().serialize(arg))
                d[".tag"] = .str("external_drive_backup_eligibility_status_checked")
                return .dictionary(d)
            case .externalDriveBackupStatusChanged(let arg):
                var d = try Serialization.getFields(TeamLog.ExternalDriveBackupStatusChangedTypeSerializer().serialize(arg))
                d[".tag"] = .str("external_drive_backup_status_changed")
                return .dictionary(d)
            case .accountCaptureChangeAvailability(let arg):
                var d = try Serialization.getFields(TeamLog.AccountCaptureChangeAvailabilityTypeSerializer().serialize(arg))
                d[".tag"] = .str("account_capture_change_availability")
                return .dictionary(d)
            case .accountCaptureMigrateAccount(let arg):
                var d = try Serialization.getFields(TeamLog.AccountCaptureMigrateAccountTypeSerializer().serialize(arg))
                d[".tag"] = .str("account_capture_migrate_account")
                return .dictionary(d)
            case .accountCaptureNotificationEmailsSent(let arg):
                var d = try Serialization.getFields(TeamLog.AccountCaptureNotificationEmailsSentTypeSerializer().serialize(arg))
                d[".tag"] = .str("account_capture_notification_emails_sent")
                return .dictionary(d)
            case .accountCaptureRelinquishAccount(let arg):
                var d = try Serialization.getFields(TeamLog.AccountCaptureRelinquishAccountTypeSerializer().serialize(arg))
                d[".tag"] = .str("account_capture_relinquish_account")
                return .dictionary(d)
            case .disabledDomainInvites(let arg):
                var d = try Serialization.getFields(TeamLog.DisabledDomainInvitesTypeSerializer().serialize(arg))
                d[".tag"] = .str("disabled_domain_invites")
                return .dictionary(d)
            case .domainInvitesApproveRequestToJoinTeam(let arg):
                var d = try Serialization.getFields(TeamLog.DomainInvitesApproveRequestToJoinTeamTypeSerializer().serialize(arg))
                d[".tag"] = .str("domain_invites_approve_request_to_join_team")
                return .dictionary(d)
            case .domainInvitesDeclineRequestToJoinTeam(let arg):
                var d = try Serialization.getFields(TeamLog.DomainInvitesDeclineRequestToJoinTeamTypeSerializer().serialize(arg))
                d[".tag"] = .str("domain_invites_decline_request_to_join_team")
                return .dictionary(d)
            case .domainInvitesEmailExistingUsers(let arg):
                var d = try Serialization.getFields(TeamLog.DomainInvitesEmailExistingUsersTypeSerializer().serialize(arg))
                d[".tag"] = .str("domain_invites_email_existing_users")
                return .dictionary(d)
            case .domainInvitesRequestToJoinTeam(let arg):
                var d = try Serialization.getFields(TeamLog.DomainInvitesRequestToJoinTeamTypeSerializer().serialize(arg))
                d[".tag"] = .str("domain_invites_request_to_join_team")
                return .dictionary(d)
            case .domainInvitesSetInviteNewUserPrefToNo(let arg):
                var d = try Serialization.getFields(TeamLog.DomainInvitesSetInviteNewUserPrefToNoTypeSerializer().serialize(arg))
                d[".tag"] = .str("domain_invites_set_invite_new_user_pref_to_no")
                return .dictionary(d)
            case .domainInvitesSetInviteNewUserPrefToYes(let arg):
                var d = try Serialization.getFields(TeamLog.DomainInvitesSetInviteNewUserPrefToYesTypeSerializer().serialize(arg))
                d[".tag"] = .str("domain_invites_set_invite_new_user_pref_to_yes")
                return .dictionary(d)
            case .domainVerificationAddDomainFail(let arg):
                var d = try Serialization.getFields(TeamLog.DomainVerificationAddDomainFailTypeSerializer().serialize(arg))
                d[".tag"] = .str("domain_verification_add_domain_fail")
                return .dictionary(d)
            case .domainVerificationAddDomainSuccess(let arg):
                var d = try Serialization.getFields(TeamLog.DomainVerificationAddDomainSuccessTypeSerializer().serialize(arg))
                d[".tag"] = .str("domain_verification_add_domain_success")
                return .dictionary(d)
            case .domainVerificationRemoveDomain(let arg):
                var d = try Serialization.getFields(TeamLog.DomainVerificationRemoveDomainTypeSerializer().serialize(arg))
                d[".tag"] = .str("domain_verification_remove_domain")
                return .dictionary(d)
            case .enabledDomainInvites(let arg):
                var d = try Serialization.getFields(TeamLog.EnabledDomainInvitesTypeSerializer().serialize(arg))
                d[".tag"] = .str("enabled_domain_invites")
                return .dictionary(d)
            case .teamEncryptionKeyCancelKeyDeletion(let arg):
                var d = try Serialization.getFields(TeamLog.TeamEncryptionKeyCancelKeyDeletionTypeSerializer().serialize(arg))
                d[".tag"] = .str("team_encryption_key_cancel_key_deletion")
                return .dictionary(d)
            case .teamEncryptionKeyCreateKey(let arg):
                var d = try Serialization.getFields(TeamLog.TeamEncryptionKeyCreateKeyTypeSerializer().serialize(arg))
                d[".tag"] = .str("team_encryption_key_create_key")
                return .dictionary(d)
            case .teamEncryptionKeyDeleteKey(let arg):
                var d = try Serialization.getFields(TeamLog.TeamEncryptionKeyDeleteKeyTypeSerializer().serialize(arg))
                d[".tag"] = .str("team_encryption_key_delete_key")
                return .dictionary(d)
            case .teamEncryptionKeyDisableKey(let arg):
                var d = try Serialization.getFields(TeamLog.TeamEncryptionKeyDisableKeyTypeSerializer().serialize(arg))
                d[".tag"] = .str("team_encryption_key_disable_key")
                return .dictionary(d)
            case .teamEncryptionKeyEnableKey(let arg):
                var d = try Serialization.getFields(TeamLog.TeamEncryptionKeyEnableKeyTypeSerializer().serialize(arg))
                d[".tag"] = .str("team_encryption_key_enable_key")
                return .dictionary(d)
            case .teamEncryptionKeyRotateKey(let arg):
                var d = try Serialization.getFields(TeamLog.TeamEncryptionKeyRotateKeyTypeSerializer().serialize(arg))
                d[".tag"] = .str("team_encryption_key_rotate_key")
                return .dictionary(d)
            case .teamEncryptionKeyScheduleKeyDeletion(let arg):
                var d = try Serialization.getFields(TeamLog.TeamEncryptionKeyScheduleKeyDeletionTypeSerializer().serialize(arg))
                d[".tag"] = .str("team_encryption_key_schedule_key_deletion")
                return .dictionary(d)
            case .applyNamingConvention(let arg):
                var d = try Serialization.getFields(TeamLog.ApplyNamingConventionTypeSerializer().serialize(arg))
                d[".tag"] = .str("apply_naming_convention")
                return .dictionary(d)
            case .createFolder(let arg):
                var d = try Serialization.getFields(TeamLog.CreateFolderTypeSerializer().serialize(arg))
                d[".tag"] = .str("create_folder")
                return .dictionary(d)
            case .fileAdd(let arg):
                var d = try Serialization.getFields(TeamLog.FileAddTypeSerializer().serialize(arg))
                d[".tag"] = .str("file_add")
                return .dictionary(d)
            case .fileAddFromAutomation(let arg):
                var d = try Serialization.getFields(TeamLog.FileAddFromAutomationTypeSerializer().serialize(arg))
                d[".tag"] = .str("file_add_from_automation")
                return .dictionary(d)
            case .fileCopy(let arg):
                var d = try Serialization.getFields(TeamLog.FileCopyTypeSerializer().serialize(arg))
                d[".tag"] = .str("file_copy")
                return .dictionary(d)
            case .fileDelete(let arg):
                var d = try Serialization.getFields(TeamLog.FileDeleteTypeSerializer().serialize(arg))
                d[".tag"] = .str("file_delete")
                return .dictionary(d)
            case .fileDownload(let arg):
                var d = try Serialization.getFields(TeamLog.FileDownloadTypeSerializer().serialize(arg))
                d[".tag"] = .str("file_download")
                return .dictionary(d)
            case .fileEdit(let arg):
                var d = try Serialization.getFields(TeamLog.FileEditTypeSerializer().serialize(arg))
                d[".tag"] = .str("file_edit")
                return .dictionary(d)
            case .fileGetCopyReference(let arg):
                var d = try Serialization.getFields(TeamLog.FileGetCopyReferenceTypeSerializer().serialize(arg))
                d[".tag"] = .str("file_get_copy_reference")
                return .dictionary(d)
            case .fileLockingLockStatusChanged(let arg):
                var d = try Serialization.getFields(TeamLog.FileLockingLockStatusChangedTypeSerializer().serialize(arg))
                d[".tag"] = .str("file_locking_lock_status_changed")
                return .dictionary(d)
            case .fileMove(let arg):
                var d = try Serialization.getFields(TeamLog.FileMoveTypeSerializer().serialize(arg))
                d[".tag"] = .str("file_move")
                return .dictionary(d)
            case .filePermanentlyDelete(let arg):
                var d = try Serialization.getFields(TeamLog.FilePermanentlyDeleteTypeSerializer().serialize(arg))
                d[".tag"] = .str("file_permanently_delete")
                return .dictionary(d)
            case .filePreview(let arg):
                var d = try Serialization.getFields(TeamLog.FilePreviewTypeSerializer().serialize(arg))
                d[".tag"] = .str("file_preview")
                return .dictionary(d)
            case .fileRename(let arg):
                var d = try Serialization.getFields(TeamLog.FileRenameTypeSerializer().serialize(arg))
                d[".tag"] = .str("file_rename")
                return .dictionary(d)
            case .fileRestore(let arg):
                var d = try Serialization.getFields(TeamLog.FileRestoreTypeSerializer().serialize(arg))
                d[".tag"] = .str("file_restore")
                return .dictionary(d)
            case .fileRevert(let arg):
                var d = try Serialization.getFields(TeamLog.FileRevertTypeSerializer().serialize(arg))
                d[".tag"] = .str("file_revert")
                return .dictionary(d)
            case .fileRollbackChanges(let arg):
                var d = try Serialization.getFields(TeamLog.FileRollbackChangesTypeSerializer().serialize(arg))
                d[".tag"] = .str("file_rollback_changes")
                return .dictionary(d)
            case .fileSaveCopyReference(let arg):
                var d = try Serialization.getFields(TeamLog.FileSaveCopyReferenceTypeSerializer().serialize(arg))
                d[".tag"] = .str("file_save_copy_reference")
                return .dictionary(d)
            case .folderOverviewDescriptionChanged(let arg):
                var d = try Serialization.getFields(TeamLog.FolderOverviewDescriptionChangedTypeSerializer().serialize(arg))
                d[".tag"] = .str("folder_overview_description_changed")
                return .dictionary(d)
            case .folderOverviewItemPinned(let arg):
                var d = try Serialization.getFields(TeamLog.FolderOverviewItemPinnedTypeSerializer().serialize(arg))
                d[".tag"] = .str("folder_overview_item_pinned")
                return .dictionary(d)
            case .folderOverviewItemUnpinned(let arg):
                var d = try Serialization.getFields(TeamLog.FolderOverviewItemUnpinnedTypeSerializer().serialize(arg))
                d[".tag"] = .str("folder_overview_item_unpinned")
                return .dictionary(d)
            case .objectLabelAdded(let arg):
                var d = try Serialization.getFields(TeamLog.ObjectLabelAddedTypeSerializer().serialize(arg))
                d[".tag"] = .str("object_label_added")
                return .dictionary(d)
            case .objectLabelRemoved(let arg):
                var d = try Serialization.getFields(TeamLog.ObjectLabelRemovedTypeSerializer().serialize(arg))
                d[".tag"] = .str("object_label_removed")
                return .dictionary(d)
            case .objectLabelUpdatedValue(let arg):
                var d = try Serialization.getFields(TeamLog.ObjectLabelUpdatedValueTypeSerializer().serialize(arg))
                d[".tag"] = .str("object_label_updated_value")
                return .dictionary(d)
            case .organizeFolderWithTidy(let arg):
                var d = try Serialization.getFields(TeamLog.OrganizeFolderWithTidyTypeSerializer().serialize(arg))
                d[".tag"] = .str("organize_folder_with_tidy")
                return .dictionary(d)
            case .replayFileDelete(let arg):
                var d = try Serialization.getFields(TeamLog.ReplayFileDeleteTypeSerializer().serialize(arg))
                d[".tag"] = .str("replay_file_delete")
                return .dictionary(d)
            case .rewindFolder(let arg):
                var d = try Serialization.getFields(TeamLog.RewindFolderTypeSerializer().serialize(arg))
                d[".tag"] = .str("rewind_folder")
                return .dictionary(d)
            case .undoNamingConvention(let arg):
                var d = try Serialization.getFields(TeamLog.UndoNamingConventionTypeSerializer().serialize(arg))
                d[".tag"] = .str("undo_naming_convention")
                return .dictionary(d)
            case .undoOrganizeFolderWithTidy(let arg):
                var d = try Serialization.getFields(TeamLog.UndoOrganizeFolderWithTidyTypeSerializer().serialize(arg))
                d[".tag"] = .str("undo_organize_folder_with_tidy")
                return .dictionary(d)
            case .userTagsAdded(let arg):
                var d = try Serialization.getFields(TeamLog.UserTagsAddedTypeSerializer().serialize(arg))
                d[".tag"] = .str("user_tags_added")
                return .dictionary(d)
            case .userTagsRemoved(let arg):
                var d = try Serialization.getFields(TeamLog.UserTagsRemovedTypeSerializer().serialize(arg))
                d[".tag"] = .str("user_tags_removed")
                return .dictionary(d)
            case .emailIngestReceiveFile(let arg):
                var d = try Serialization.getFields(TeamLog.EmailIngestReceiveFileTypeSerializer().serialize(arg))
                d[".tag"] = .str("email_ingest_receive_file")
                return .dictionary(d)
            case .fileRequestChange(let arg):
                var d = try Serialization.getFields(TeamLog.FileRequestChangeTypeSerializer().serialize(arg))
                d[".tag"] = .str("file_request_change")
                return .dictionary(d)
            case .fileRequestClose(let arg):
                var d = try Serialization.getFields(TeamLog.FileRequestCloseTypeSerializer().serialize(arg))
                d[".tag"] = .str("file_request_close")
                return .dictionary(d)
            case .fileRequestCreate(let arg):
                var d = try Serialization.getFields(TeamLog.FileRequestCreateTypeSerializer().serialize(arg))
                d[".tag"] = .str("file_request_create")
                return .dictionary(d)
            case .fileRequestDelete(let arg):
                var d = try Serialization.getFields(TeamLog.FileRequestDeleteTypeSerializer().serialize(arg))
                d[".tag"] = .str("file_request_delete")
                return .dictionary(d)
            case .fileRequestReceiveFile(let arg):
                var d = try Serialization.getFields(TeamLog.FileRequestReceiveFileTypeSerializer().serialize(arg))
                d[".tag"] = .str("file_request_receive_file")
                return .dictionary(d)
            case .groupAddExternalId(let arg):
                var d = try Serialization.getFields(TeamLog.GroupAddExternalIdTypeSerializer().serialize(arg))
                d[".tag"] = .str("group_add_external_id")
                return .dictionary(d)
            case .groupAddMember(let arg):
                var d = try Serialization.getFields(TeamLog.GroupAddMemberTypeSerializer().serialize(arg))
                d[".tag"] = .str("group_add_member")
                return .dictionary(d)
            case .groupChangeExternalId(let arg):
                var d = try Serialization.getFields(TeamLog.GroupChangeExternalIdTypeSerializer().serialize(arg))
                d[".tag"] = .str("group_change_external_id")
                return .dictionary(d)
            case .groupChangeManagementType(let arg):
                var d = try Serialization.getFields(TeamLog.GroupChangeManagementTypeTypeSerializer().serialize(arg))
                d[".tag"] = .str("group_change_management_type")
                return .dictionary(d)
            case .groupChangeMemberRole(let arg):
                var d = try Serialization.getFields(TeamLog.GroupChangeMemberRoleTypeSerializer().serialize(arg))
                d[".tag"] = .str("group_change_member_role")
                return .dictionary(d)
            case .groupCreate(let arg):
                var d = try Serialization.getFields(TeamLog.GroupCreateTypeSerializer().serialize(arg))
                d[".tag"] = .str("group_create")
                return .dictionary(d)
            case .groupDelete(let arg):
                var d = try Serialization.getFields(TeamLog.GroupDeleteTypeSerializer().serialize(arg))
                d[".tag"] = .str("group_delete")
                return .dictionary(d)
            case .groupDescriptionUpdated(let arg):
                var d = try Serialization.getFields(TeamLog.GroupDescriptionUpdatedTypeSerializer().serialize(arg))
                d[".tag"] = .str("group_description_updated")
                return .dictionary(d)
            case .groupJoinPolicyUpdated(let arg):
                var d = try Serialization.getFields(TeamLog.GroupJoinPolicyUpdatedTypeSerializer().serialize(arg))
                d[".tag"] = .str("group_join_policy_updated")
                return .dictionary(d)
            case .groupMoved(let arg):
                var d = try Serialization.getFields(TeamLog.GroupMovedTypeSerializer().serialize(arg))
                d[".tag"] = .str("group_moved")
                return .dictionary(d)
            case .groupRemoveExternalId(let arg):
                var d = try Serialization.getFields(TeamLog.GroupRemoveExternalIdTypeSerializer().serialize(arg))
                d[".tag"] = .str("group_remove_external_id")
                return .dictionary(d)
            case .groupRemoveMember(let arg):
                var d = try Serialization.getFields(TeamLog.GroupRemoveMemberTypeSerializer().serialize(arg))
                d[".tag"] = .str("group_remove_member")
                return .dictionary(d)
            case .groupRename(let arg):
                var d = try Serialization.getFields(TeamLog.GroupRenameTypeSerializer().serialize(arg))
                d[".tag"] = .str("group_rename")
                return .dictionary(d)
            case .accountLockOrUnlocked(let arg):
                var d = try Serialization.getFields(TeamLog.AccountLockOrUnlockedTypeSerializer().serialize(arg))
                d[".tag"] = .str("account_lock_or_unlocked")
                return .dictionary(d)
            case .emmError(let arg):
                var d = try Serialization.getFields(TeamLog.EmmErrorTypeSerializer().serialize(arg))
                d[".tag"] = .str("emm_error")
                return .dictionary(d)
            case .guestAdminSignedInViaTrustedTeams(let arg):
                var d = try Serialization.getFields(TeamLog.GuestAdminSignedInViaTrustedTeamsTypeSerializer().serialize(arg))
                d[".tag"] = .str("guest_admin_signed_in_via_trusted_teams")
                return .dictionary(d)
            case .guestAdminSignedOutViaTrustedTeams(let arg):
                var d = try Serialization.getFields(TeamLog.GuestAdminSignedOutViaTrustedTeamsTypeSerializer().serialize(arg))
                d[".tag"] = .str("guest_admin_signed_out_via_trusted_teams")
                return .dictionary(d)
            case .loginFail(let arg):
                var d = try Serialization.getFields(TeamLog.LoginFailTypeSerializer().serialize(arg))
                d[".tag"] = .str("login_fail")
                return .dictionary(d)
            case .loginSuccess(let arg):
                var d = try Serialization.getFields(TeamLog.LoginSuccessTypeSerializer().serialize(arg))
                d[".tag"] = .str("login_success")
                return .dictionary(d)
            case .logout(let arg):
                var d = try Serialization.getFields(TeamLog.LogoutTypeSerializer().serialize(arg))
                d[".tag"] = .str("logout")
                return .dictionary(d)
            case .resellerSupportSessionEnd(let arg):
                var d = try Serialization.getFields(TeamLog.ResellerSupportSessionEndTypeSerializer().serialize(arg))
                d[".tag"] = .str("reseller_support_session_end")
                return .dictionary(d)
            case .resellerSupportSessionStart(let arg):
                var d = try Serialization.getFields(TeamLog.ResellerSupportSessionStartTypeSerializer().serialize(arg))
                d[".tag"] = .str("reseller_support_session_start")
                return .dictionary(d)
            case .signInAsSessionEnd(let arg):
                var d = try Serialization.getFields(TeamLog.SignInAsSessionEndTypeSerializer().serialize(arg))
                d[".tag"] = .str("sign_in_as_session_end")
                return .dictionary(d)
            case .signInAsSessionStart(let arg):
                var d = try Serialization.getFields(TeamLog.SignInAsSessionStartTypeSerializer().serialize(arg))
                d[".tag"] = .str("sign_in_as_session_start")
                return .dictionary(d)
            case .ssoError(let arg):
                var d = try Serialization.getFields(TeamLog.SsoErrorTypeSerializer().serialize(arg))
                d[".tag"] = .str("sso_error")
                return .dictionary(d)
            case .backupAdminInvitationSent(let arg):
                var d = try Serialization.getFields(TeamLog.BackupAdminInvitationSentTypeSerializer().serialize(arg))
                d[".tag"] = .str("backup_admin_invitation_sent")
                return .dictionary(d)
            case .backupInvitationOpened(let arg):
                var d = try Serialization.getFields(TeamLog.BackupInvitationOpenedTypeSerializer().serialize(arg))
                d[".tag"] = .str("backup_invitation_opened")
                return .dictionary(d)
            case .createTeamInviteLink(let arg):
                var d = try Serialization.getFields(TeamLog.CreateTeamInviteLinkTypeSerializer().serialize(arg))
                d[".tag"] = .str("create_team_invite_link")
                return .dictionary(d)
            case .deleteTeamInviteLink(let arg):
                var d = try Serialization.getFields(TeamLog.DeleteTeamInviteLinkTypeSerializer().serialize(arg))
                d[".tag"] = .str("delete_team_invite_link")
                return .dictionary(d)
            case .memberAddExternalId(let arg):
                var d = try Serialization.getFields(TeamLog.MemberAddExternalIdTypeSerializer().serialize(arg))
                d[".tag"] = .str("member_add_external_id")
                return .dictionary(d)
            case .memberAddName(let arg):
                var d = try Serialization.getFields(TeamLog.MemberAddNameTypeSerializer().serialize(arg))
                d[".tag"] = .str("member_add_name")
                return .dictionary(d)
            case .memberChangeAdminRole(let arg):
                var d = try Serialization.getFields(TeamLog.MemberChangeAdminRoleTypeSerializer().serialize(arg))
                d[".tag"] = .str("member_change_admin_role")
                return .dictionary(d)
            case .memberChangeEmail(let arg):
                var d = try Serialization.getFields(TeamLog.MemberChangeEmailTypeSerializer().serialize(arg))
                d[".tag"] = .str("member_change_email")
                return .dictionary(d)
            case .memberChangeExternalId(let arg):
                var d = try Serialization.getFields(TeamLog.MemberChangeExternalIdTypeSerializer().serialize(arg))
                d[".tag"] = .str("member_change_external_id")
                return .dictionary(d)
            case .memberChangeMembershipType(let arg):
                var d = try Serialization.getFields(TeamLog.MemberChangeMembershipTypeTypeSerializer().serialize(arg))
                d[".tag"] = .str("member_change_membership_type")
                return .dictionary(d)
            case .memberChangeName(let arg):
                var d = try Serialization.getFields(TeamLog.MemberChangeNameTypeSerializer().serialize(arg))
                d[".tag"] = .str("member_change_name")
                return .dictionary(d)
            case .memberChangeResellerRole(let arg):
                var d = try Serialization.getFields(TeamLog.MemberChangeResellerRoleTypeSerializer().serialize(arg))
                d[".tag"] = .str("member_change_reseller_role")
                return .dictionary(d)
            case .memberChangeStatus(let arg):
                var d = try Serialization.getFields(TeamLog.MemberChangeStatusTypeSerializer().serialize(arg))
                d[".tag"] = .str("member_change_status")
                return .dictionary(d)
            case .memberDeleteManualContacts(let arg):
                var d = try Serialization.getFields(TeamLog.MemberDeleteManualContactsTypeSerializer().serialize(arg))
                d[".tag"] = .str("member_delete_manual_contacts")
                return .dictionary(d)
            case .memberDeleteProfilePhoto(let arg):
                var d = try Serialization.getFields(TeamLog.MemberDeleteProfilePhotoTypeSerializer().serialize(arg))
                d[".tag"] = .str("member_delete_profile_photo")
                return .dictionary(d)
            case .memberPermanentlyDeleteAccountContents(let arg):
                var d = try Serialization.getFields(TeamLog.MemberPermanentlyDeleteAccountContentsTypeSerializer().serialize(arg))
                d[".tag"] = .str("member_permanently_delete_account_contents")
                return .dictionary(d)
            case .memberRemoveExternalId(let arg):
                var d = try Serialization.getFields(TeamLog.MemberRemoveExternalIdTypeSerializer().serialize(arg))
                d[".tag"] = .str("member_remove_external_id")
                return .dictionary(d)
            case .memberSetProfilePhoto(let arg):
                var d = try Serialization.getFields(TeamLog.MemberSetProfilePhotoTypeSerializer().serialize(arg))
                d[".tag"] = .str("member_set_profile_photo")
                return .dictionary(d)
            case .memberSpaceLimitsAddCustomQuota(let arg):
                var d = try Serialization.getFields(TeamLog.MemberSpaceLimitsAddCustomQuotaTypeSerializer().serialize(arg))
                d[".tag"] = .str("member_space_limits_add_custom_quota")
                return .dictionary(d)
            case .memberSpaceLimitsChangeCustomQuota(let arg):
                var d = try Serialization.getFields(TeamLog.MemberSpaceLimitsChangeCustomQuotaTypeSerializer().serialize(arg))
                d[".tag"] = .str("member_space_limits_change_custom_quota")
                return .dictionary(d)
            case .memberSpaceLimitsChangeStatus(let arg):
                var d = try Serialization.getFields(TeamLog.MemberSpaceLimitsChangeStatusTypeSerializer().serialize(arg))
                d[".tag"] = .str("member_space_limits_change_status")
                return .dictionary(d)
            case .memberSpaceLimitsRemoveCustomQuota(let arg):
                var d = try Serialization.getFields(TeamLog.MemberSpaceLimitsRemoveCustomQuotaTypeSerializer().serialize(arg))
                d[".tag"] = .str("member_space_limits_remove_custom_quota")
                return .dictionary(d)
            case .memberSuggest(let arg):
                var d = try Serialization.getFields(TeamLog.MemberSuggestTypeSerializer().serialize(arg))
                d[".tag"] = .str("member_suggest")
                return .dictionary(d)
            case .memberTransferAccountContents(let arg):
                var d = try Serialization.getFields(TeamLog.MemberTransferAccountContentsTypeSerializer().serialize(arg))
                d[".tag"] = .str("member_transfer_account_contents")
                return .dictionary(d)
            case .pendingSecondaryEmailAdded(let arg):
                var d = try Serialization.getFields(TeamLog.PendingSecondaryEmailAddedTypeSerializer().serialize(arg))
                d[".tag"] = .str("pending_secondary_email_added")
                return .dictionary(d)
            case .secondaryEmailDeleted(let arg):
                var d = try Serialization.getFields(TeamLog.SecondaryEmailDeletedTypeSerializer().serialize(arg))
                d[".tag"] = .str("secondary_email_deleted")
                return .dictionary(d)
            case .secondaryEmailVerified(let arg):
                var d = try Serialization.getFields(TeamLog.SecondaryEmailVerifiedTypeSerializer().serialize(arg))
                d[".tag"] = .str("secondary_email_verified")
                return .dictionary(d)
            case .secondaryMailsPolicyChanged(let arg):
                var d = try Serialization.getFields(TeamLog.SecondaryMailsPolicyChangedTypeSerializer().serialize(arg))
                d[".tag"] = .str("secondary_mails_policy_changed")
                return .dictionary(d)
            case .binderAddPage(let arg):
                var d = try Serialization.getFields(TeamLog.BinderAddPageTypeSerializer().serialize(arg))
                d[".tag"] = .str("binder_add_page")
                return .dictionary(d)
            case .binderAddSection(let arg):
                var d = try Serialization.getFields(TeamLog.BinderAddSectionTypeSerializer().serialize(arg))
                d[".tag"] = .str("binder_add_section")
                return .dictionary(d)
            case .binderRemovePage(let arg):
                var d = try Serialization.getFields(TeamLog.BinderRemovePageTypeSerializer().serialize(arg))
                d[".tag"] = .str("binder_remove_page")
                return .dictionary(d)
            case .binderRemoveSection(let arg):
                var d = try Serialization.getFields(TeamLog.BinderRemoveSectionTypeSerializer().serialize(arg))
                d[".tag"] = .str("binder_remove_section")
                return .dictionary(d)
            case .binderRenamePage(let arg):
                var d = try Serialization.getFields(TeamLog.BinderRenamePageTypeSerializer().serialize(arg))
                d[".tag"] = .str("binder_rename_page")
                return .dictionary(d)
            case .binderRenameSection(let arg):
                var d = try Serialization.getFields(TeamLog.BinderRenameSectionTypeSerializer().serialize(arg))
                d[".tag"] = .str("binder_rename_section")
                return .dictionary(d)
            case .binderReorderPage(let arg):
                var d = try Serialization.getFields(TeamLog.BinderReorderPageTypeSerializer().serialize(arg))
                d[".tag"] = .str("binder_reorder_page")
                return .dictionary(d)
            case .binderReorderSection(let arg):
                var d = try Serialization.getFields(TeamLog.BinderReorderSectionTypeSerializer().serialize(arg))
                d[".tag"] = .str("binder_reorder_section")
                return .dictionary(d)
            case .paperContentAddMember(let arg):
                var d = try Serialization.getFields(TeamLog.PaperContentAddMemberTypeSerializer().serialize(arg))
                d[".tag"] = .str("paper_content_add_member")
                return .dictionary(d)
            case .paperContentAddToFolder(let arg):
                var d = try Serialization.getFields(TeamLog.PaperContentAddToFolderTypeSerializer().serialize(arg))
                d[".tag"] = .str("paper_content_add_to_folder")
                return .dictionary(d)
            case .paperContentArchive(let arg):
                var d = try Serialization.getFields(TeamLog.PaperContentArchiveTypeSerializer().serialize(arg))
                d[".tag"] = .str("paper_content_archive")
                return .dictionary(d)
            case .paperContentCreate(let arg):
                var d = try Serialization.getFields(TeamLog.PaperContentCreateTypeSerializer().serialize(arg))
                d[".tag"] = .str("paper_content_create")
                return .dictionary(d)
            case .paperContentPermanentlyDelete(let arg):
                var d = try Serialization.getFields(TeamLog.PaperContentPermanentlyDeleteTypeSerializer().serialize(arg))
                d[".tag"] = .str("paper_content_permanently_delete")
                return .dictionary(d)
            case .paperContentRemoveFromFolder(let arg):
                var d = try Serialization.getFields(TeamLog.PaperContentRemoveFromFolderTypeSerializer().serialize(arg))
                d[".tag"] = .str("paper_content_remove_from_folder")
                return .dictionary(d)
            case .paperContentRemoveMember(let arg):
                var d = try Serialization.getFields(TeamLog.PaperContentRemoveMemberTypeSerializer().serialize(arg))
                d[".tag"] = .str("paper_content_remove_member")
                return .dictionary(d)
            case .paperContentRename(let arg):
                var d = try Serialization.getFields(TeamLog.PaperContentRenameTypeSerializer().serialize(arg))
                d[".tag"] = .str("paper_content_rename")
                return .dictionary(d)
            case .paperContentRestore(let arg):
                var d = try Serialization.getFields(TeamLog.PaperContentRestoreTypeSerializer().serialize(arg))
                d[".tag"] = .str("paper_content_restore")
                return .dictionary(d)
            case .paperDocAddComment(let arg):
                var d = try Serialization.getFields(TeamLog.PaperDocAddCommentTypeSerializer().serialize(arg))
                d[".tag"] = .str("paper_doc_add_comment")
                return .dictionary(d)
            case .paperDocChangeMemberRole(let arg):
                var d = try Serialization.getFields(TeamLog.PaperDocChangeMemberRoleTypeSerializer().serialize(arg))
                d[".tag"] = .str("paper_doc_change_member_role")
                return .dictionary(d)
            case .paperDocChangeSharingPolicy(let arg):
                var d = try Serialization.getFields(TeamLog.PaperDocChangeSharingPolicyTypeSerializer().serialize(arg))
                d[".tag"] = .str("paper_doc_change_sharing_policy")
                return .dictionary(d)
            case .paperDocChangeSubscription(let arg):
                var d = try Serialization.getFields(TeamLog.PaperDocChangeSubscriptionTypeSerializer().serialize(arg))
                d[".tag"] = .str("paper_doc_change_subscription")
                return .dictionary(d)
            case .paperDocDeleted(let arg):
                var d = try Serialization.getFields(TeamLog.PaperDocDeletedTypeSerializer().serialize(arg))
                d[".tag"] = .str("paper_doc_deleted")
                return .dictionary(d)
            case .paperDocDeleteComment(let arg):
                var d = try Serialization.getFields(TeamLog.PaperDocDeleteCommentTypeSerializer().serialize(arg))
                d[".tag"] = .str("paper_doc_delete_comment")
                return .dictionary(d)
            case .paperDocDownload(let arg):
                var d = try Serialization.getFields(TeamLog.PaperDocDownloadTypeSerializer().serialize(arg))
                d[".tag"] = .str("paper_doc_download")
                return .dictionary(d)
            case .paperDocEdit(let arg):
                var d = try Serialization.getFields(TeamLog.PaperDocEditTypeSerializer().serialize(arg))
                d[".tag"] = .str("paper_doc_edit")
                return .dictionary(d)
            case .paperDocEditComment(let arg):
                var d = try Serialization.getFields(TeamLog.PaperDocEditCommentTypeSerializer().serialize(arg))
                d[".tag"] = .str("paper_doc_edit_comment")
                return .dictionary(d)
            case .paperDocFollowed(let arg):
                var d = try Serialization.getFields(TeamLog.PaperDocFollowedTypeSerializer().serialize(arg))
                d[".tag"] = .str("paper_doc_followed")
                return .dictionary(d)
            case .paperDocMention(let arg):
                var d = try Serialization.getFields(TeamLog.PaperDocMentionTypeSerializer().serialize(arg))
                d[".tag"] = .str("paper_doc_mention")
                return .dictionary(d)
            case .paperDocOwnershipChanged(let arg):
                var d = try Serialization.getFields(TeamLog.PaperDocOwnershipChangedTypeSerializer().serialize(arg))
                d[".tag"] = .str("paper_doc_ownership_changed")
                return .dictionary(d)
            case .paperDocRequestAccess(let arg):
                var d = try Serialization.getFields(TeamLog.PaperDocRequestAccessTypeSerializer().serialize(arg))
                d[".tag"] = .str("paper_doc_request_access")
                return .dictionary(d)
            case .paperDocResolveComment(let arg):
                var d = try Serialization.getFields(TeamLog.PaperDocResolveCommentTypeSerializer().serialize(arg))
                d[".tag"] = .str("paper_doc_resolve_comment")
                return .dictionary(d)
            case .paperDocRevert(let arg):
                var d = try Serialization.getFields(TeamLog.PaperDocRevertTypeSerializer().serialize(arg))
                d[".tag"] = .str("paper_doc_revert")
                return .dictionary(d)
            case .paperDocSlackShare(let arg):
                var d = try Serialization.getFields(TeamLog.PaperDocSlackShareTypeSerializer().serialize(arg))
                d[".tag"] = .str("paper_doc_slack_share")
                return .dictionary(d)
            case .paperDocTeamInvite(let arg):
                var d = try Serialization.getFields(TeamLog.PaperDocTeamInviteTypeSerializer().serialize(arg))
                d[".tag"] = .str("paper_doc_team_invite")
                return .dictionary(d)
            case .paperDocTrashed(let arg):
                var d = try Serialization.getFields(TeamLog.PaperDocTrashedTypeSerializer().serialize(arg))
                d[".tag"] = .str("paper_doc_trashed")
                return .dictionary(d)
            case .paperDocUnresolveComment(let arg):
                var d = try Serialization.getFields(TeamLog.PaperDocUnresolveCommentTypeSerializer().serialize(arg))
                d[".tag"] = .str("paper_doc_unresolve_comment")
                return .dictionary(d)
            case .paperDocUntrashed(let arg):
                var d = try Serialization.getFields(TeamLog.PaperDocUntrashedTypeSerializer().serialize(arg))
                d[".tag"] = .str("paper_doc_untrashed")
                return .dictionary(d)
            case .paperDocView(let arg):
                var d = try Serialization.getFields(TeamLog.PaperDocViewTypeSerializer().serialize(arg))
                d[".tag"] = .str("paper_doc_view")
                return .dictionary(d)
            case .paperExternalViewAllow(let arg):
                var d = try Serialization.getFields(TeamLog.PaperExternalViewAllowTypeSerializer().serialize(arg))
                d[".tag"] = .str("paper_external_view_allow")
                return .dictionary(d)
            case .paperExternalViewDefaultTeam(let arg):
                var d = try Serialization.getFields(TeamLog.PaperExternalViewDefaultTeamTypeSerializer().serialize(arg))
                d[".tag"] = .str("paper_external_view_default_team")
                return .dictionary(d)
            case .paperExternalViewForbid(let arg):
                var d = try Serialization.getFields(TeamLog.PaperExternalViewForbidTypeSerializer().serialize(arg))
                d[".tag"] = .str("paper_external_view_forbid")
                return .dictionary(d)
            case .paperFolderChangeSubscription(let arg):
                var d = try Serialization.getFields(TeamLog.PaperFolderChangeSubscriptionTypeSerializer().serialize(arg))
                d[".tag"] = .str("paper_folder_change_subscription")
                return .dictionary(d)
            case .paperFolderDeleted(let arg):
                var d = try Serialization.getFields(TeamLog.PaperFolderDeletedTypeSerializer().serialize(arg))
                d[".tag"] = .str("paper_folder_deleted")
                return .dictionary(d)
            case .paperFolderFollowed(let arg):
                var d = try Serialization.getFields(TeamLog.PaperFolderFollowedTypeSerializer().serialize(arg))
                d[".tag"] = .str("paper_folder_followed")
                return .dictionary(d)
            case .paperFolderTeamInvite(let arg):
                var d = try Serialization.getFields(TeamLog.PaperFolderTeamInviteTypeSerializer().serialize(arg))
                d[".tag"] = .str("paper_folder_team_invite")
                return .dictionary(d)
            case .paperPublishedLinkChangePermission(let arg):
                var d = try Serialization.getFields(TeamLog.PaperPublishedLinkChangePermissionTypeSerializer().serialize(arg))
                d[".tag"] = .str("paper_published_link_change_permission")
                return .dictionary(d)
            case .paperPublishedLinkCreate(let arg):
                var d = try Serialization.getFields(TeamLog.PaperPublishedLinkCreateTypeSerializer().serialize(arg))
                d[".tag"] = .str("paper_published_link_create")
                return .dictionary(d)
            case .paperPublishedLinkDisabled(let arg):
                var d = try Serialization.getFields(TeamLog.PaperPublishedLinkDisabledTypeSerializer().serialize(arg))
                d[".tag"] = .str("paper_published_link_disabled")
                return .dictionary(d)
            case .paperPublishedLinkView(let arg):
                var d = try Serialization.getFields(TeamLog.PaperPublishedLinkViewTypeSerializer().serialize(arg))
                d[".tag"] = .str("paper_published_link_view")
                return .dictionary(d)
            case .passwordChange(let arg):
                var d = try Serialization.getFields(TeamLog.PasswordChangeTypeSerializer().serialize(arg))
                d[".tag"] = .str("password_change")
                return .dictionary(d)
            case .passwordReset(let arg):
                var d = try Serialization.getFields(TeamLog.PasswordResetTypeSerializer().serialize(arg))
                d[".tag"] = .str("password_reset")
                return .dictionary(d)
            case .passwordResetAll(let arg):
                var d = try Serialization.getFields(TeamLog.PasswordResetAllTypeSerializer().serialize(arg))
                d[".tag"] = .str("password_reset_all")
                return .dictionary(d)
            case .classificationCreateReport(let arg):
                var d = try Serialization.getFields(TeamLog.ClassificationCreateReportTypeSerializer().serialize(arg))
                d[".tag"] = .str("classification_create_report")
                return .dictionary(d)
            case .classificationCreateReportFail(let arg):
                var d = try Serialization.getFields(TeamLog.ClassificationCreateReportFailTypeSerializer().serialize(arg))
                d[".tag"] = .str("classification_create_report_fail")
                return .dictionary(d)
            case .emmCreateExceptionsReport(let arg):
                var d = try Serialization.getFields(TeamLog.EmmCreateExceptionsReportTypeSerializer().serialize(arg))
                d[".tag"] = .str("emm_create_exceptions_report")
                return .dictionary(d)
            case .emmCreateUsageReport(let arg):
                var d = try Serialization.getFields(TeamLog.EmmCreateUsageReportTypeSerializer().serialize(arg))
                d[".tag"] = .str("emm_create_usage_report")
                return .dictionary(d)
            case .exportMembersReport(let arg):
                var d = try Serialization.getFields(TeamLog.ExportMembersReportTypeSerializer().serialize(arg))
                d[".tag"] = .str("export_members_report")
                return .dictionary(d)
            case .exportMembersReportFail(let arg):
                var d = try Serialization.getFields(TeamLog.ExportMembersReportFailTypeSerializer().serialize(arg))
                d[".tag"] = .str("export_members_report_fail")
                return .dictionary(d)
            case .externalSharingCreateReport(let arg):
                var d = try Serialization.getFields(TeamLog.ExternalSharingCreateReportTypeSerializer().serialize(arg))
                d[".tag"] = .str("external_sharing_create_report")
                return .dictionary(d)
            case .externalSharingReportFailed(let arg):
                var d = try Serialization.getFields(TeamLog.ExternalSharingReportFailedTypeSerializer().serialize(arg))
                d[".tag"] = .str("external_sharing_report_failed")
                return .dictionary(d)
            case .noExpirationLinkGenCreateReport(let arg):
                var d = try Serialization.getFields(TeamLog.NoExpirationLinkGenCreateReportTypeSerializer().serialize(arg))
                d[".tag"] = .str("no_expiration_link_gen_create_report")
                return .dictionary(d)
            case .noExpirationLinkGenReportFailed(let arg):
                var d = try Serialization.getFields(TeamLog.NoExpirationLinkGenReportFailedTypeSerializer().serialize(arg))
                d[".tag"] = .str("no_expiration_link_gen_report_failed")
                return .dictionary(d)
            case .noPasswordLinkGenCreateReport(let arg):
                var d = try Serialization.getFields(TeamLog.NoPasswordLinkGenCreateReportTypeSerializer().serialize(arg))
                d[".tag"] = .str("no_password_link_gen_create_report")
                return .dictionary(d)
            case .noPasswordLinkGenReportFailed(let arg):
                var d = try Serialization.getFields(TeamLog.NoPasswordLinkGenReportFailedTypeSerializer().serialize(arg))
                d[".tag"] = .str("no_password_link_gen_report_failed")
                return .dictionary(d)
            case .noPasswordLinkViewCreateReport(let arg):
                var d = try Serialization.getFields(TeamLog.NoPasswordLinkViewCreateReportTypeSerializer().serialize(arg))
                d[".tag"] = .str("no_password_link_view_create_report")
                return .dictionary(d)
            case .noPasswordLinkViewReportFailed(let arg):
                var d = try Serialization.getFields(TeamLog.NoPasswordLinkViewReportFailedTypeSerializer().serialize(arg))
                d[".tag"] = .str("no_password_link_view_report_failed")
                return .dictionary(d)
            case .outdatedLinkViewCreateReport(let arg):
                var d = try Serialization.getFields(TeamLog.OutdatedLinkViewCreateReportTypeSerializer().serialize(arg))
                d[".tag"] = .str("outdated_link_view_create_report")
                return .dictionary(d)
            case .outdatedLinkViewReportFailed(let arg):
                var d = try Serialization.getFields(TeamLog.OutdatedLinkViewReportFailedTypeSerializer().serialize(arg))
                d[".tag"] = .str("outdated_link_view_report_failed")
                return .dictionary(d)
            case .paperAdminExportStart(let arg):
                var d = try Serialization.getFields(TeamLog.PaperAdminExportStartTypeSerializer().serialize(arg))
                d[".tag"] = .str("paper_admin_export_start")
                return .dictionary(d)
            case .ransomwareAlertCreateReport(let arg):
                var d = try Serialization.getFields(TeamLog.RansomwareAlertCreateReportTypeSerializer().serialize(arg))
                d[".tag"] = .str("ransomware_alert_create_report")
                return .dictionary(d)
            case .ransomwareAlertCreateReportFailed(let arg):
                var d = try Serialization.getFields(TeamLog.RansomwareAlertCreateReportFailedTypeSerializer().serialize(arg))
                d[".tag"] = .str("ransomware_alert_create_report_failed")
                return .dictionary(d)
            case .smartSyncCreateAdminPrivilegeReport(let arg):
                var d = try Serialization.getFields(TeamLog.SmartSyncCreateAdminPrivilegeReportTypeSerializer().serialize(arg))
                d[".tag"] = .str("smart_sync_create_admin_privilege_report")
                return .dictionary(d)
            case .teamActivityCreateReport(let arg):
                var d = try Serialization.getFields(TeamLog.TeamActivityCreateReportTypeSerializer().serialize(arg))
                d[".tag"] = .str("team_activity_create_report")
                return .dictionary(d)
            case .teamActivityCreateReportFail(let arg):
                var d = try Serialization.getFields(TeamLog.TeamActivityCreateReportFailTypeSerializer().serialize(arg))
                d[".tag"] = .str("team_activity_create_report_fail")
                return .dictionary(d)
            case .collectionShare(let arg):
                var d = try Serialization.getFields(TeamLog.CollectionShareTypeSerializer().serialize(arg))
                d[".tag"] = .str("collection_share")
                return .dictionary(d)
            case .fileTransfersFileAdd(let arg):
                var d = try Serialization.getFields(TeamLog.FileTransfersFileAddTypeSerializer().serialize(arg))
                d[".tag"] = .str("file_transfers_file_add")
                return .dictionary(d)
            case .fileTransfersTransferDelete(let arg):
                var d = try Serialization.getFields(TeamLog.FileTransfersTransferDeleteTypeSerializer().serialize(arg))
                d[".tag"] = .str("file_transfers_transfer_delete")
                return .dictionary(d)
            case .fileTransfersTransferDownload(let arg):
                var d = try Serialization.getFields(TeamLog.FileTransfersTransferDownloadTypeSerializer().serialize(arg))
                d[".tag"] = .str("file_transfers_transfer_download")
                return .dictionary(d)
            case .fileTransfersTransferSend(let arg):
                var d = try Serialization.getFields(TeamLog.FileTransfersTransferSendTypeSerializer().serialize(arg))
                d[".tag"] = .str("file_transfers_transfer_send")
                return .dictionary(d)
            case .fileTransfersTransferView(let arg):
                var d = try Serialization.getFields(TeamLog.FileTransfersTransferViewTypeSerializer().serialize(arg))
                d[".tag"] = .str("file_transfers_transfer_view")
                return .dictionary(d)
            case .noteAclInviteOnly(let arg):
                var d = try Serialization.getFields(TeamLog.NoteAclInviteOnlyTypeSerializer().serialize(arg))
                d[".tag"] = .str("note_acl_invite_only")
                return .dictionary(d)
            case .noteAclLink(let arg):
                var d = try Serialization.getFields(TeamLog.NoteAclLinkTypeSerializer().serialize(arg))
                d[".tag"] = .str("note_acl_link")
                return .dictionary(d)
            case .noteAclTeamLink(let arg):
                var d = try Serialization.getFields(TeamLog.NoteAclTeamLinkTypeSerializer().serialize(arg))
                d[".tag"] = .str("note_acl_team_link")
                return .dictionary(d)
            case .noteShared(let arg):
                var d = try Serialization.getFields(TeamLog.NoteSharedTypeSerializer().serialize(arg))
                d[".tag"] = .str("note_shared")
                return .dictionary(d)
            case .noteShareReceive(let arg):
                var d = try Serialization.getFields(TeamLog.NoteShareReceiveTypeSerializer().serialize(arg))
                d[".tag"] = .str("note_share_receive")
                return .dictionary(d)
            case .openNoteShared(let arg):
                var d = try Serialization.getFields(TeamLog.OpenNoteSharedTypeSerializer().serialize(arg))
                d[".tag"] = .str("open_note_shared")
                return .dictionary(d)
            case .replayFileSharedLinkCreated(let arg):
                var d = try Serialization.getFields(TeamLog.ReplayFileSharedLinkCreatedTypeSerializer().serialize(arg))
                d[".tag"] = .str("replay_file_shared_link_created")
                return .dictionary(d)
            case .replayFileSharedLinkModified(let arg):
                var d = try Serialization.getFields(TeamLog.ReplayFileSharedLinkModifiedTypeSerializer().serialize(arg))
                d[".tag"] = .str("replay_file_shared_link_modified")
                return .dictionary(d)
            case .replayProjectTeamAdd(let arg):
                var d = try Serialization.getFields(TeamLog.ReplayProjectTeamAddTypeSerializer().serialize(arg))
                d[".tag"] = .str("replay_project_team_add")
                return .dictionary(d)
            case .replayProjectTeamDelete(let arg):
                var d = try Serialization.getFields(TeamLog.ReplayProjectTeamDeleteTypeSerializer().serialize(arg))
                d[".tag"] = .str("replay_project_team_delete")
                return .dictionary(d)
            case .sfAddGroup(let arg):
                var d = try Serialization.getFields(TeamLog.SfAddGroupTypeSerializer().serialize(arg))
                d[".tag"] = .str("sf_add_group")
                return .dictionary(d)
            case .sfAllowNonMembersToViewSharedLinks(let arg):
                var d = try Serialization.getFields(TeamLog.SfAllowNonMembersToViewSharedLinksTypeSerializer().serialize(arg))
                d[".tag"] = .str("sf_allow_non_members_to_view_shared_links")
                return .dictionary(d)
            case .sfExternalInviteWarn(let arg):
                var d = try Serialization.getFields(TeamLog.SfExternalInviteWarnTypeSerializer().serialize(arg))
                d[".tag"] = .str("sf_external_invite_warn")
                return .dictionary(d)
            case .sfFbInvite(let arg):
                var d = try Serialization.getFields(TeamLog.SfFbInviteTypeSerializer().serialize(arg))
                d[".tag"] = .str("sf_fb_invite")
                return .dictionary(d)
            case .sfFbInviteChangeRole(let arg):
                var d = try Serialization.getFields(TeamLog.SfFbInviteChangeRoleTypeSerializer().serialize(arg))
                d[".tag"] = .str("sf_fb_invite_change_role")
                return .dictionary(d)
            case .sfFbUninvite(let arg):
                var d = try Serialization.getFields(TeamLog.SfFbUninviteTypeSerializer().serialize(arg))
                d[".tag"] = .str("sf_fb_uninvite")
                return .dictionary(d)
            case .sfInviteGroup(let arg):
                var d = try Serialization.getFields(TeamLog.SfInviteGroupTypeSerializer().serialize(arg))
                d[".tag"] = .str("sf_invite_group")
                return .dictionary(d)
            case .sfTeamGrantAccess(let arg):
                var d = try Serialization.getFields(TeamLog.SfTeamGrantAccessTypeSerializer().serialize(arg))
                d[".tag"] = .str("sf_team_grant_access")
                return .dictionary(d)
            case .sfTeamInvite(let arg):
                var d = try Serialization.getFields(TeamLog.SfTeamInviteTypeSerializer().serialize(arg))
                d[".tag"] = .str("sf_team_invite")
                return .dictionary(d)
            case .sfTeamInviteChangeRole(let arg):
                var d = try Serialization.getFields(TeamLog.SfTeamInviteChangeRoleTypeSerializer().serialize(arg))
                d[".tag"] = .str("sf_team_invite_change_role")
                return .dictionary(d)
            case .sfTeamJoin(let arg):
                var d = try Serialization.getFields(TeamLog.SfTeamJoinTypeSerializer().serialize(arg))
                d[".tag"] = .str("sf_team_join")
                return .dictionary(d)
            case .sfTeamJoinFromOobLink(let arg):
                var d = try Serialization.getFields(TeamLog.SfTeamJoinFromOobLinkTypeSerializer().serialize(arg))
                d[".tag"] = .str("sf_team_join_from_oob_link")
                return .dictionary(d)
            case .sfTeamUninvite(let arg):
                var d = try Serialization.getFields(TeamLog.SfTeamUninviteTypeSerializer().serialize(arg))
                d[".tag"] = .str("sf_team_uninvite")
                return .dictionary(d)
            case .sharedContentAddInvitees(let arg):
                var d = try Serialization.getFields(TeamLog.SharedContentAddInviteesTypeSerializer().serialize(arg))
                d[".tag"] = .str("shared_content_add_invitees")
                return .dictionary(d)
            case .sharedContentAddLinkExpiry(let arg):
                var d = try Serialization.getFields(TeamLog.SharedContentAddLinkExpiryTypeSerializer().serialize(arg))
                d[".tag"] = .str("shared_content_add_link_expiry")
                return .dictionary(d)
            case .sharedContentAddLinkPassword(let arg):
                var d = try Serialization.getFields(TeamLog.SharedContentAddLinkPasswordTypeSerializer().serialize(arg))
                d[".tag"] = .str("shared_content_add_link_password")
                return .dictionary(d)
            case .sharedContentAddMember(let arg):
                var d = try Serialization.getFields(TeamLog.SharedContentAddMemberTypeSerializer().serialize(arg))
                d[".tag"] = .str("shared_content_add_member")
                return .dictionary(d)
            case .sharedContentChangeDownloadsPolicy(let arg):
                var d = try Serialization.getFields(TeamLog.SharedContentChangeDownloadsPolicyTypeSerializer().serialize(arg))
                d[".tag"] = .str("shared_content_change_downloads_policy")
                return .dictionary(d)
            case .sharedContentChangeInviteeRole(let arg):
                var d = try Serialization.getFields(TeamLog.SharedContentChangeInviteeRoleTypeSerializer().serialize(arg))
                d[".tag"] = .str("shared_content_change_invitee_role")
                return .dictionary(d)
            case .sharedContentChangeLinkAudience(let arg):
                var d = try Serialization.getFields(TeamLog.SharedContentChangeLinkAudienceTypeSerializer().serialize(arg))
                d[".tag"] = .str("shared_content_change_link_audience")
                return .dictionary(d)
            case .sharedContentChangeLinkExpiry(let arg):
                var d = try Serialization.getFields(TeamLog.SharedContentChangeLinkExpiryTypeSerializer().serialize(arg))
                d[".tag"] = .str("shared_content_change_link_expiry")
                return .dictionary(d)
            case .sharedContentChangeLinkPassword(let arg):
                var d = try Serialization.getFields(TeamLog.SharedContentChangeLinkPasswordTypeSerializer().serialize(arg))
                d[".tag"] = .str("shared_content_change_link_password")
                return .dictionary(d)
            case .sharedContentChangeMemberRole(let arg):
                var d = try Serialization.getFields(TeamLog.SharedContentChangeMemberRoleTypeSerializer().serialize(arg))
                d[".tag"] = .str("shared_content_change_member_role")
                return .dictionary(d)
            case .sharedContentChangeViewerInfoPolicy(let arg):
                var d = try Serialization.getFields(TeamLog.SharedContentChangeViewerInfoPolicyTypeSerializer().serialize(arg))
                d[".tag"] = .str("shared_content_change_viewer_info_policy")
                return .dictionary(d)
            case .sharedContentClaimInvitation(let arg):
                var d = try Serialization.getFields(TeamLog.SharedContentClaimInvitationTypeSerializer().serialize(arg))
                d[".tag"] = .str("shared_content_claim_invitation")
                return .dictionary(d)
            case .sharedContentCopy(let arg):
                var d = try Serialization.getFields(TeamLog.SharedContentCopyTypeSerializer().serialize(arg))
                d[".tag"] = .str("shared_content_copy")
                return .dictionary(d)
            case .sharedContentDownload(let arg):
                var d = try Serialization.getFields(TeamLog.SharedContentDownloadTypeSerializer().serialize(arg))
                d[".tag"] = .str("shared_content_download")
                return .dictionary(d)
            case .sharedContentRelinquishMembership(let arg):
                var d = try Serialization.getFields(TeamLog.SharedContentRelinquishMembershipTypeSerializer().serialize(arg))
                d[".tag"] = .str("shared_content_relinquish_membership")
                return .dictionary(d)
            case .sharedContentRemoveInvitees(let arg):
                var d = try Serialization.getFields(TeamLog.SharedContentRemoveInviteesTypeSerializer().serialize(arg))
                d[".tag"] = .str("shared_content_remove_invitees")
                return .dictionary(d)
            case .sharedContentRemoveLinkExpiry(let arg):
                var d = try Serialization.getFields(TeamLog.SharedContentRemoveLinkExpiryTypeSerializer().serialize(arg))
                d[".tag"] = .str("shared_content_remove_link_expiry")
                return .dictionary(d)
            case .sharedContentRemoveLinkPassword(let arg):
                var d = try Serialization.getFields(TeamLog.SharedContentRemoveLinkPasswordTypeSerializer().serialize(arg))
                d[".tag"] = .str("shared_content_remove_link_password")
                return .dictionary(d)
            case .sharedContentRemoveMember(let arg):
                var d = try Serialization.getFields(TeamLog.SharedContentRemoveMemberTypeSerializer().serialize(arg))
                d[".tag"] = .str("shared_content_remove_member")
                return .dictionary(d)
            case .sharedContentRequestAccess(let arg):
                var d = try Serialization.getFields(TeamLog.SharedContentRequestAccessTypeSerializer().serialize(arg))
                d[".tag"] = .str("shared_content_request_access")
                return .dictionary(d)
            case .sharedContentRestoreInvitees(let arg):
                var d = try Serialization.getFields(TeamLog.SharedContentRestoreInviteesTypeSerializer().serialize(arg))
                d[".tag"] = .str("shared_content_restore_invitees")
                return .dictionary(d)
            case .sharedContentRestoreMember(let arg):
                var d = try Serialization.getFields(TeamLog.SharedContentRestoreMemberTypeSerializer().serialize(arg))
                d[".tag"] = .str("shared_content_restore_member")
                return .dictionary(d)
            case .sharedContentUnshare(let arg):
                var d = try Serialization.getFields(TeamLog.SharedContentUnshareTypeSerializer().serialize(arg))
                d[".tag"] = .str("shared_content_unshare")
                return .dictionary(d)
            case .sharedContentView(let arg):
                var d = try Serialization.getFields(TeamLog.SharedContentViewTypeSerializer().serialize(arg))
                d[".tag"] = .str("shared_content_view")
                return .dictionary(d)
            case .sharedFolderChangeLinkPolicy(let arg):
                var d = try Serialization.getFields(TeamLog.SharedFolderChangeLinkPolicyTypeSerializer().serialize(arg))
                d[".tag"] = .str("shared_folder_change_link_policy")
                return .dictionary(d)
            case .sharedFolderChangeMembersInheritancePolicy(let arg):
                var d = try Serialization.getFields(TeamLog.SharedFolderChangeMembersInheritancePolicyTypeSerializer().serialize(arg))
                d[".tag"] = .str("shared_folder_change_members_inheritance_policy")
                return .dictionary(d)
            case .sharedFolderChangeMembersManagementPolicy(let arg):
                var d = try Serialization.getFields(TeamLog.SharedFolderChangeMembersManagementPolicyTypeSerializer().serialize(arg))
                d[".tag"] = .str("shared_folder_change_members_management_policy")
                return .dictionary(d)
            case .sharedFolderChangeMembersPolicy(let arg):
                var d = try Serialization.getFields(TeamLog.SharedFolderChangeMembersPolicyTypeSerializer().serialize(arg))
                d[".tag"] = .str("shared_folder_change_members_policy")
                return .dictionary(d)
            case .sharedFolderCreate(let arg):
                var d = try Serialization.getFields(TeamLog.SharedFolderCreateTypeSerializer().serialize(arg))
                d[".tag"] = .str("shared_folder_create")
                return .dictionary(d)
            case .sharedFolderDeclineInvitation(let arg):
                var d = try Serialization.getFields(TeamLog.SharedFolderDeclineInvitationTypeSerializer().serialize(arg))
                d[".tag"] = .str("shared_folder_decline_invitation")
                return .dictionary(d)
            case .sharedFolderMount(let arg):
                var d = try Serialization.getFields(TeamLog.SharedFolderMountTypeSerializer().serialize(arg))
                d[".tag"] = .str("shared_folder_mount")
                return .dictionary(d)
            case .sharedFolderNest(let arg):
                var d = try Serialization.getFields(TeamLog.SharedFolderNestTypeSerializer().serialize(arg))
                d[".tag"] = .str("shared_folder_nest")
                return .dictionary(d)
            case .sharedFolderTransferOwnership(let arg):
                var d = try Serialization.getFields(TeamLog.SharedFolderTransferOwnershipTypeSerializer().serialize(arg))
                d[".tag"] = .str("shared_folder_transfer_ownership")
                return .dictionary(d)
            case .sharedFolderUnmount(let arg):
                var d = try Serialization.getFields(TeamLog.SharedFolderUnmountTypeSerializer().serialize(arg))
                d[".tag"] = .str("shared_folder_unmount")
                return .dictionary(d)
            case .sharedLinkAddExpiry(let arg):
                var d = try Serialization.getFields(TeamLog.SharedLinkAddExpiryTypeSerializer().serialize(arg))
                d[".tag"] = .str("shared_link_add_expiry")
                return .dictionary(d)
            case .sharedLinkChangeExpiry(let arg):
                var d = try Serialization.getFields(TeamLog.SharedLinkChangeExpiryTypeSerializer().serialize(arg))
                d[".tag"] = .str("shared_link_change_expiry")
                return .dictionary(d)
            case .sharedLinkChangeVisibility(let arg):
                var d = try Serialization.getFields(TeamLog.SharedLinkChangeVisibilityTypeSerializer().serialize(arg))
                d[".tag"] = .str("shared_link_change_visibility")
                return .dictionary(d)
            case .sharedLinkCopy(let arg):
                var d = try Serialization.getFields(TeamLog.SharedLinkCopyTypeSerializer().serialize(arg))
                d[".tag"] = .str("shared_link_copy")
                return .dictionary(d)
            case .sharedLinkCreate(let arg):
                var d = try Serialization.getFields(TeamLog.SharedLinkCreateTypeSerializer().serialize(arg))
                d[".tag"] = .str("shared_link_create")
                return .dictionary(d)
            case .sharedLinkDisable(let arg):
                var d = try Serialization.getFields(TeamLog.SharedLinkDisableTypeSerializer().serialize(arg))
                d[".tag"] = .str("shared_link_disable")
                return .dictionary(d)
            case .sharedLinkDownload(let arg):
                var d = try Serialization.getFields(TeamLog.SharedLinkDownloadTypeSerializer().serialize(arg))
                d[".tag"] = .str("shared_link_download")
                return .dictionary(d)
            case .sharedLinkRemoveExpiry(let arg):
                var d = try Serialization.getFields(TeamLog.SharedLinkRemoveExpiryTypeSerializer().serialize(arg))
                d[".tag"] = .str("shared_link_remove_expiry")
                return .dictionary(d)
            case .sharedLinkSettingsAddExpiration(let arg):
                var d = try Serialization.getFields(TeamLog.SharedLinkSettingsAddExpirationTypeSerializer().serialize(arg))
                d[".tag"] = .str("shared_link_settings_add_expiration")
                return .dictionary(d)
            case .sharedLinkSettingsAddPassword(let arg):
                var d = try Serialization.getFields(TeamLog.SharedLinkSettingsAddPasswordTypeSerializer().serialize(arg))
                d[".tag"] = .str("shared_link_settings_add_password")
                return .dictionary(d)
            case .sharedLinkSettingsAllowDownloadDisabled(let arg):
                var d = try Serialization.getFields(TeamLog.SharedLinkSettingsAllowDownloadDisabledTypeSerializer().serialize(arg))
                d[".tag"] = .str("shared_link_settings_allow_download_disabled")
                return .dictionary(d)
            case .sharedLinkSettingsAllowDownloadEnabled(let arg):
                var d = try Serialization.getFields(TeamLog.SharedLinkSettingsAllowDownloadEnabledTypeSerializer().serialize(arg))
                d[".tag"] = .str("shared_link_settings_allow_download_enabled")
                return .dictionary(d)
            case .sharedLinkSettingsChangeAudience(let arg):
                var d = try Serialization.getFields(TeamLog.SharedLinkSettingsChangeAudienceTypeSerializer().serialize(arg))
                d[".tag"] = .str("shared_link_settings_change_audience")
                return .dictionary(d)
            case .sharedLinkSettingsChangeExpiration(let arg):
                var d = try Serialization.getFields(TeamLog.SharedLinkSettingsChangeExpirationTypeSerializer().serialize(arg))
                d[".tag"] = .str("shared_link_settings_change_expiration")
                return .dictionary(d)
            case .sharedLinkSettingsChangePassword(let arg):
                var d = try Serialization.getFields(TeamLog.SharedLinkSettingsChangePasswordTypeSerializer().serialize(arg))
                d[".tag"] = .str("shared_link_settings_change_password")
                return .dictionary(d)
            case .sharedLinkSettingsRemoveExpiration(let arg):
                var d = try Serialization.getFields(TeamLog.SharedLinkSettingsRemoveExpirationTypeSerializer().serialize(arg))
                d[".tag"] = .str("shared_link_settings_remove_expiration")
                return .dictionary(d)
            case .sharedLinkSettingsRemovePassword(let arg):
                var d = try Serialization.getFields(TeamLog.SharedLinkSettingsRemovePasswordTypeSerializer().serialize(arg))
                d[".tag"] = .str("shared_link_settings_remove_password")
                return .dictionary(d)
            case .sharedLinkShare(let arg):
                var d = try Serialization.getFields(TeamLog.SharedLinkShareTypeSerializer().serialize(arg))
                d[".tag"] = .str("shared_link_share")
                return .dictionary(d)
            case .sharedLinkView(let arg):
                var d = try Serialization.getFields(TeamLog.SharedLinkViewTypeSerializer().serialize(arg))
                d[".tag"] = .str("shared_link_view")
                return .dictionary(d)
            case .sharedNoteOpened(let arg):
                var d = try Serialization.getFields(TeamLog.SharedNoteOpenedTypeSerializer().serialize(arg))
                d[".tag"] = .str("shared_note_opened")
                return .dictionary(d)
            case .shmodelDisableDownloads(let arg):
                var d = try Serialization.getFields(TeamLog.ShmodelDisableDownloadsTypeSerializer().serialize(arg))
                d[".tag"] = .str("shmodel_disable_downloads")
                return .dictionary(d)
            case .shmodelEnableDownloads(let arg):
                var d = try Serialization.getFields(TeamLog.ShmodelEnableDownloadsTypeSerializer().serialize(arg))
                d[".tag"] = .str("shmodel_enable_downloads")
                return .dictionary(d)
            case .shmodelGroupShare(let arg):
                var d = try Serialization.getFields(TeamLog.ShmodelGroupShareTypeSerializer().serialize(arg))
                d[".tag"] = .str("shmodel_group_share")
                return .dictionary(d)
            case .showcaseAccessGranted(let arg):
                var d = try Serialization.getFields(TeamLog.ShowcaseAccessGrantedTypeSerializer().serialize(arg))
                d[".tag"] = .str("showcase_access_granted")
                return .dictionary(d)
            case .showcaseAddMember(let arg):
                var d = try Serialization.getFields(TeamLog.ShowcaseAddMemberTypeSerializer().serialize(arg))
                d[".tag"] = .str("showcase_add_member")
                return .dictionary(d)
            case .showcaseArchived(let arg):
                var d = try Serialization.getFields(TeamLog.ShowcaseArchivedTypeSerializer().serialize(arg))
                d[".tag"] = .str("showcase_archived")
                return .dictionary(d)
            case .showcaseCreated(let arg):
                var d = try Serialization.getFields(TeamLog.ShowcaseCreatedTypeSerializer().serialize(arg))
                d[".tag"] = .str("showcase_created")
                return .dictionary(d)
            case .showcaseDeleteComment(let arg):
                var d = try Serialization.getFields(TeamLog.ShowcaseDeleteCommentTypeSerializer().serialize(arg))
                d[".tag"] = .str("showcase_delete_comment")
                return .dictionary(d)
            case .showcaseEdited(let arg):
                var d = try Serialization.getFields(TeamLog.ShowcaseEditedTypeSerializer().serialize(arg))
                d[".tag"] = .str("showcase_edited")
                return .dictionary(d)
            case .showcaseEditComment(let arg):
                var d = try Serialization.getFields(TeamLog.ShowcaseEditCommentTypeSerializer().serialize(arg))
                d[".tag"] = .str("showcase_edit_comment")
                return .dictionary(d)
            case .showcaseFileAdded(let arg):
                var d = try Serialization.getFields(TeamLog.ShowcaseFileAddedTypeSerializer().serialize(arg))
                d[".tag"] = .str("showcase_file_added")
                return .dictionary(d)
            case .showcaseFileDownload(let arg):
                var d = try Serialization.getFields(TeamLog.ShowcaseFileDownloadTypeSerializer().serialize(arg))
                d[".tag"] = .str("showcase_file_download")
                return .dictionary(d)
            case .showcaseFileRemoved(let arg):
                var d = try Serialization.getFields(TeamLog.ShowcaseFileRemovedTypeSerializer().serialize(arg))
                d[".tag"] = .str("showcase_file_removed")
                return .dictionary(d)
            case .showcaseFileView(let arg):
                var d = try Serialization.getFields(TeamLog.ShowcaseFileViewTypeSerializer().serialize(arg))
                d[".tag"] = .str("showcase_file_view")
                return .dictionary(d)
            case .showcasePermanentlyDeleted(let arg):
                var d = try Serialization.getFields(TeamLog.ShowcasePermanentlyDeletedTypeSerializer().serialize(arg))
                d[".tag"] = .str("showcase_permanently_deleted")
                return .dictionary(d)
            case .showcasePostComment(let arg):
                var d = try Serialization.getFields(TeamLog.ShowcasePostCommentTypeSerializer().serialize(arg))
                d[".tag"] = .str("showcase_post_comment")
                return .dictionary(d)
            case .showcaseRemoveMember(let arg):
                var d = try Serialization.getFields(TeamLog.ShowcaseRemoveMemberTypeSerializer().serialize(arg))
                d[".tag"] = .str("showcase_remove_member")
                return .dictionary(d)
            case .showcaseRenamed(let arg):
                var d = try Serialization.getFields(TeamLog.ShowcaseRenamedTypeSerializer().serialize(arg))
                d[".tag"] = .str("showcase_renamed")
                return .dictionary(d)
            case .showcaseRequestAccess(let arg):
                var d = try Serialization.getFields(TeamLog.ShowcaseRequestAccessTypeSerializer().serialize(arg))
                d[".tag"] = .str("showcase_request_access")
                return .dictionary(d)
            case .showcaseResolveComment(let arg):
                var d = try Serialization.getFields(TeamLog.ShowcaseResolveCommentTypeSerializer().serialize(arg))
                d[".tag"] = .str("showcase_resolve_comment")
                return .dictionary(d)
            case .showcaseRestored(let arg):
                var d = try Serialization.getFields(TeamLog.ShowcaseRestoredTypeSerializer().serialize(arg))
                d[".tag"] = .str("showcase_restored")
                return .dictionary(d)
            case .showcaseTrashed(let arg):
                var d = try Serialization.getFields(TeamLog.ShowcaseTrashedTypeSerializer().serialize(arg))
                d[".tag"] = .str("showcase_trashed")
                return .dictionary(d)
            case .showcaseTrashedDeprecated(let arg):
                var d = try Serialization.getFields(TeamLog.ShowcaseTrashedDeprecatedTypeSerializer().serialize(arg))
                d[".tag"] = .str("showcase_trashed_deprecated")
                return .dictionary(d)
            case .showcaseUnresolveComment(let arg):
                var d = try Serialization.getFields(TeamLog.ShowcaseUnresolveCommentTypeSerializer().serialize(arg))
                d[".tag"] = .str("showcase_unresolve_comment")
                return .dictionary(d)
            case .showcaseUntrashed(let arg):
                var d = try Serialization.getFields(TeamLog.ShowcaseUntrashedTypeSerializer().serialize(arg))
                d[".tag"] = .str("showcase_untrashed")
                return .dictionary(d)
            case .showcaseUntrashedDeprecated(let arg):
                var d = try Serialization.getFields(TeamLog.ShowcaseUntrashedDeprecatedTypeSerializer().serialize(arg))
                d[".tag"] = .str("showcase_untrashed_deprecated")
                return .dictionary(d)
            case .showcaseView(let arg):
                var d = try Serialization.getFields(TeamLog.ShowcaseViewTypeSerializer().serialize(arg))
                d[".tag"] = .str("showcase_view")
                return .dictionary(d)
            case .ssoAddCert(let arg):
                var d = try Serialization.getFields(TeamLog.SsoAddCertTypeSerializer().serialize(arg))
                d[".tag"] = .str("sso_add_cert")
                return .dictionary(d)
            case .ssoAddLoginUrl(let arg):
                var d = try Serialization.getFields(TeamLog.SsoAddLoginUrlTypeSerializer().serialize(arg))
                d[".tag"] = .str("sso_add_login_url")
                return .dictionary(d)
            case .ssoAddLogoutUrl(let arg):
                var d = try Serialization.getFields(TeamLog.SsoAddLogoutUrlTypeSerializer().serialize(arg))
                d[".tag"] = .str("sso_add_logout_url")
                return .dictionary(d)
            case .ssoChangeCert(let arg):
                var d = try Serialization.getFields(TeamLog.SsoChangeCertTypeSerializer().serialize(arg))
                d[".tag"] = .str("sso_change_cert")
                return .dictionary(d)
            case .ssoChangeLoginUrl(let arg):
                var d = try Serialization.getFields(TeamLog.SsoChangeLoginUrlTypeSerializer().serialize(arg))
                d[".tag"] = .str("sso_change_login_url")
                return .dictionary(d)
            case .ssoChangeLogoutUrl(let arg):
                var d = try Serialization.getFields(TeamLog.SsoChangeLogoutUrlTypeSerializer().serialize(arg))
                d[".tag"] = .str("sso_change_logout_url")
                return .dictionary(d)
            case .ssoChangeSamlIdentityMode(let arg):
                var d = try Serialization.getFields(TeamLog.SsoChangeSamlIdentityModeTypeSerializer().serialize(arg))
                d[".tag"] = .str("sso_change_saml_identity_mode")
                return .dictionary(d)
            case .ssoRemoveCert(let arg):
                var d = try Serialization.getFields(TeamLog.SsoRemoveCertTypeSerializer().serialize(arg))
                d[".tag"] = .str("sso_remove_cert")
                return .dictionary(d)
            case .ssoRemoveLoginUrl(let arg):
                var d = try Serialization.getFields(TeamLog.SsoRemoveLoginUrlTypeSerializer().serialize(arg))
                d[".tag"] = .str("sso_remove_login_url")
                return .dictionary(d)
            case .ssoRemoveLogoutUrl(let arg):
                var d = try Serialization.getFields(TeamLog.SsoRemoveLogoutUrlTypeSerializer().serialize(arg))
                d[".tag"] = .str("sso_remove_logout_url")
                return .dictionary(d)
            case .teamFolderChangeStatus(let arg):
                var d = try Serialization.getFields(TeamLog.TeamFolderChangeStatusTypeSerializer().serialize(arg))
                d[".tag"] = .str("team_folder_change_status")
                return .dictionary(d)
            case .teamFolderCreate(let arg):
                var d = try Serialization.getFields(TeamLog.TeamFolderCreateTypeSerializer().serialize(arg))
                d[".tag"] = .str("team_folder_create")
                return .dictionary(d)
            case .teamFolderDowngrade(let arg):
                var d = try Serialization.getFields(TeamLog.TeamFolderDowngradeTypeSerializer().serialize(arg))
                d[".tag"] = .str("team_folder_downgrade")
                return .dictionary(d)
            case .teamFolderPermanentlyDelete(let arg):
                var d = try Serialization.getFields(TeamLog.TeamFolderPermanentlyDeleteTypeSerializer().serialize(arg))
                d[".tag"] = .str("team_folder_permanently_delete")
                return .dictionary(d)
            case .teamFolderRename(let arg):
                var d = try Serialization.getFields(TeamLog.TeamFolderRenameTypeSerializer().serialize(arg))
                d[".tag"] = .str("team_folder_rename")
                return .dictionary(d)
            case .teamSelectiveSyncSettingsChanged(let arg):
                var d = try Serialization.getFields(TeamLog.TeamSelectiveSyncSettingsChangedTypeSerializer().serialize(arg))
                d[".tag"] = .str("team_selective_sync_settings_changed")
                return .dictionary(d)
            case .accountCaptureChangePolicy(let arg):
                var d = try Serialization.getFields(TeamLog.AccountCaptureChangePolicyTypeSerializer().serialize(arg))
                d[".tag"] = .str("account_capture_change_policy")
                return .dictionary(d)
            case .adminEmailRemindersChanged(let arg):
                var d = try Serialization.getFields(TeamLog.AdminEmailRemindersChangedTypeSerializer().serialize(arg))
                d[".tag"] = .str("admin_email_reminders_changed")
                return .dictionary(d)
            case .allowDownloadDisabled(let arg):
                var d = try Serialization.getFields(TeamLog.AllowDownloadDisabledTypeSerializer().serialize(arg))
                d[".tag"] = .str("allow_download_disabled")
                return .dictionary(d)
            case .allowDownloadEnabled(let arg):
                var d = try Serialization.getFields(TeamLog.AllowDownloadEnabledTypeSerializer().serialize(arg))
                d[".tag"] = .str("allow_download_enabled")
                return .dictionary(d)
            case .appPermissionsChanged(let arg):
                var d = try Serialization.getFields(TeamLog.AppPermissionsChangedTypeSerializer().serialize(arg))
                d[".tag"] = .str("app_permissions_changed")
                return .dictionary(d)
            case .cameraUploadsPolicyChanged(let arg):
                var d = try Serialization.getFields(TeamLog.CameraUploadsPolicyChangedTypeSerializer().serialize(arg))
                d[".tag"] = .str("camera_uploads_policy_changed")
                return .dictionary(d)
            case .captureTranscriptPolicyChanged(let arg):
                var d = try Serialization.getFields(TeamLog.CaptureTranscriptPolicyChangedTypeSerializer().serialize(arg))
                d[".tag"] = .str("capture_transcript_policy_changed")
                return .dictionary(d)
            case .classificationChangePolicy(let arg):
                var d = try Serialization.getFields(TeamLog.ClassificationChangePolicyTypeSerializer().serialize(arg))
                d[".tag"] = .str("classification_change_policy")
                return .dictionary(d)
            case .computerBackupPolicyChanged(let arg):
                var d = try Serialization.getFields(TeamLog.ComputerBackupPolicyChangedTypeSerializer().serialize(arg))
                d[".tag"] = .str("computer_backup_policy_changed")
                return .dictionary(d)
            case .contentAdministrationPolicyChanged(let arg):
                var d = try Serialization.getFields(TeamLog.ContentAdministrationPolicyChangedTypeSerializer().serialize(arg))
                d[".tag"] = .str("content_administration_policy_changed")
                return .dictionary(d)
            case .dataPlacementRestrictionChangePolicy(let arg):
                var d = try Serialization.getFields(TeamLog.DataPlacementRestrictionChangePolicyTypeSerializer().serialize(arg))
                d[".tag"] = .str("data_placement_restriction_change_policy")
                return .dictionary(d)
            case .dataPlacementRestrictionSatisfyPolicy(let arg):
                var d = try Serialization.getFields(TeamLog.DataPlacementRestrictionSatisfyPolicyTypeSerializer().serialize(arg))
                d[".tag"] = .str("data_placement_restriction_satisfy_policy")
                return .dictionary(d)
            case .deviceApprovalsAddException(let arg):
                var d = try Serialization.getFields(TeamLog.DeviceApprovalsAddExceptionTypeSerializer().serialize(arg))
                d[".tag"] = .str("device_approvals_add_exception")
                return .dictionary(d)
            case .deviceApprovalsChangeDesktopPolicy(let arg):
                var d = try Serialization.getFields(TeamLog.DeviceApprovalsChangeDesktopPolicyTypeSerializer().serialize(arg))
                d[".tag"] = .str("device_approvals_change_desktop_policy")
                return .dictionary(d)
            case .deviceApprovalsChangeMobilePolicy(let arg):
                var d = try Serialization.getFields(TeamLog.DeviceApprovalsChangeMobilePolicyTypeSerializer().serialize(arg))
                d[".tag"] = .str("device_approvals_change_mobile_policy")
                return .dictionary(d)
            case .deviceApprovalsChangeOverageAction(let arg):
                var d = try Serialization.getFields(TeamLog.DeviceApprovalsChangeOverageActionTypeSerializer().serialize(arg))
                d[".tag"] = .str("device_approvals_change_overage_action")
                return .dictionary(d)
            case .deviceApprovalsChangeUnlinkAction(let arg):
                var d = try Serialization.getFields(TeamLog.DeviceApprovalsChangeUnlinkActionTypeSerializer().serialize(arg))
                d[".tag"] = .str("device_approvals_change_unlink_action")
                return .dictionary(d)
            case .deviceApprovalsRemoveException(let arg):
                var d = try Serialization.getFields(TeamLog.DeviceApprovalsRemoveExceptionTypeSerializer().serialize(arg))
                d[".tag"] = .str("device_approvals_remove_exception")
                return .dictionary(d)
            case .directoryRestrictionsAddMembers(let arg):
                var d = try Serialization.getFields(TeamLog.DirectoryRestrictionsAddMembersTypeSerializer().serialize(arg))
                d[".tag"] = .str("directory_restrictions_add_members")
                return .dictionary(d)
            case .directoryRestrictionsRemoveMembers(let arg):
                var d = try Serialization.getFields(TeamLog.DirectoryRestrictionsRemoveMembersTypeSerializer().serialize(arg))
                d[".tag"] = .str("directory_restrictions_remove_members")
                return .dictionary(d)
            case .dropboxPasswordsPolicyChanged(let arg):
                var d = try Serialization.getFields(TeamLog.DropboxPasswordsPolicyChangedTypeSerializer().serialize(arg))
                d[".tag"] = .str("dropbox_passwords_policy_changed")
                return .dictionary(d)
            case .emailIngestPolicyChanged(let arg):
                var d = try Serialization.getFields(TeamLog.EmailIngestPolicyChangedTypeSerializer().serialize(arg))
                d[".tag"] = .str("email_ingest_policy_changed")
                return .dictionary(d)
            case .emmAddException(let arg):
                var d = try Serialization.getFields(TeamLog.EmmAddExceptionTypeSerializer().serialize(arg))
                d[".tag"] = .str("emm_add_exception")
                return .dictionary(d)
            case .emmChangePolicy(let arg):
                var d = try Serialization.getFields(TeamLog.EmmChangePolicyTypeSerializer().serialize(arg))
                d[".tag"] = .str("emm_change_policy")
                return .dictionary(d)
            case .emmRemoveException(let arg):
                var d = try Serialization.getFields(TeamLog.EmmRemoveExceptionTypeSerializer().serialize(arg))
                d[".tag"] = .str("emm_remove_exception")
                return .dictionary(d)
            case .extendedVersionHistoryChangePolicy(let arg):
                var d = try Serialization.getFields(TeamLog.ExtendedVersionHistoryChangePolicyTypeSerializer().serialize(arg))
                d[".tag"] = .str("extended_version_history_change_policy")
                return .dictionary(d)
            case .externalDriveBackupPolicyChanged(let arg):
                var d = try Serialization.getFields(TeamLog.ExternalDriveBackupPolicyChangedTypeSerializer().serialize(arg))
                d[".tag"] = .str("external_drive_backup_policy_changed")
                return .dictionary(d)
            case .fileCommentsChangePolicy(let arg):
                var d = try Serialization.getFields(TeamLog.FileCommentsChangePolicyTypeSerializer().serialize(arg))
                d[".tag"] = .str("file_comments_change_policy")
                return .dictionary(d)
            case .fileLockingPolicyChanged(let arg):
                var d = try Serialization.getFields(TeamLog.FileLockingPolicyChangedTypeSerializer().serialize(arg))
                d[".tag"] = .str("file_locking_policy_changed")
                return .dictionary(d)
            case .fileProviderMigrationPolicyChanged(let arg):
                var d = try Serialization.getFields(TeamLog.FileProviderMigrationPolicyChangedTypeSerializer().serialize(arg))
                d[".tag"] = .str("file_provider_migration_policy_changed")
                return .dictionary(d)
            case .fileRequestsChangePolicy(let arg):
                var d = try Serialization.getFields(TeamLog.FileRequestsChangePolicyTypeSerializer().serialize(arg))
                d[".tag"] = .str("file_requests_change_policy")
                return .dictionary(d)
            case .fileRequestsEmailsEnabled(let arg):
                var d = try Serialization.getFields(TeamLog.FileRequestsEmailsEnabledTypeSerializer().serialize(arg))
                d[".tag"] = .str("file_requests_emails_enabled")
                return .dictionary(d)
            case .fileRequestsEmailsRestrictedToTeamOnly(let arg):
                var d = try Serialization.getFields(TeamLog.FileRequestsEmailsRestrictedToTeamOnlyTypeSerializer().serialize(arg))
                d[".tag"] = .str("file_requests_emails_restricted_to_team_only")
                return .dictionary(d)
            case .fileTransfersPolicyChanged(let arg):
                var d = try Serialization.getFields(TeamLog.FileTransfersPolicyChangedTypeSerializer().serialize(arg))
                d[".tag"] = .str("file_transfers_policy_changed")
                return .dictionary(d)
            case .folderLinkRestrictionPolicyChanged(let arg):
                var d = try Serialization.getFields(TeamLog.FolderLinkRestrictionPolicyChangedTypeSerializer().serialize(arg))
                d[".tag"] = .str("folder_link_restriction_policy_changed")
                return .dictionary(d)
            case .googleSsoChangePolicy(let arg):
                var d = try Serialization.getFields(TeamLog.GoogleSsoChangePolicyTypeSerializer().serialize(arg))
                d[".tag"] = .str("google_sso_change_policy")
                return .dictionary(d)
            case .groupUserManagementChangePolicy(let arg):
                var d = try Serialization.getFields(TeamLog.GroupUserManagementChangePolicyTypeSerializer().serialize(arg))
                d[".tag"] = .str("group_user_management_change_policy")
                return .dictionary(d)
            case .integrationPolicyChanged(let arg):
                var d = try Serialization.getFields(TeamLog.IntegrationPolicyChangedTypeSerializer().serialize(arg))
                d[".tag"] = .str("integration_policy_changed")
                return .dictionary(d)
            case .inviteAcceptanceEmailPolicyChanged(let arg):
                var d = try Serialization.getFields(TeamLog.InviteAcceptanceEmailPolicyChangedTypeSerializer().serialize(arg))
                d[".tag"] = .str("invite_acceptance_email_policy_changed")
                return .dictionary(d)
            case .memberRequestsChangePolicy(let arg):
                var d = try Serialization.getFields(TeamLog.MemberRequestsChangePolicyTypeSerializer().serialize(arg))
                d[".tag"] = .str("member_requests_change_policy")
                return .dictionary(d)
            case .memberSendInvitePolicyChanged(let arg):
                var d = try Serialization.getFields(TeamLog.MemberSendInvitePolicyChangedTypeSerializer().serialize(arg))
                d[".tag"] = .str("member_send_invite_policy_changed")
                return .dictionary(d)
            case .memberSpaceLimitsAddException(let arg):
                var d = try Serialization.getFields(TeamLog.MemberSpaceLimitsAddExceptionTypeSerializer().serialize(arg))
                d[".tag"] = .str("member_space_limits_add_exception")
                return .dictionary(d)
            case .memberSpaceLimitsChangeCapsTypePolicy(let arg):
                var d = try Serialization.getFields(TeamLog.MemberSpaceLimitsChangeCapsTypePolicyTypeSerializer().serialize(arg))
                d[".tag"] = .str("member_space_limits_change_caps_type_policy")
                return .dictionary(d)
            case .memberSpaceLimitsChangePolicy(let arg):
                var d = try Serialization.getFields(TeamLog.MemberSpaceLimitsChangePolicyTypeSerializer().serialize(arg))
                d[".tag"] = .str("member_space_limits_change_policy")
                return .dictionary(d)
            case .memberSpaceLimitsRemoveException(let arg):
                var d = try Serialization.getFields(TeamLog.MemberSpaceLimitsRemoveExceptionTypeSerializer().serialize(arg))
                d[".tag"] = .str("member_space_limits_remove_exception")
                return .dictionary(d)
            case .memberSuggestionsChangePolicy(let arg):
                var d = try Serialization.getFields(TeamLog.MemberSuggestionsChangePolicyTypeSerializer().serialize(arg))
                d[".tag"] = .str("member_suggestions_change_policy")
                return .dictionary(d)
            case .microsoftOfficeAddinChangePolicy(let arg):
                var d = try Serialization.getFields(TeamLog.MicrosoftOfficeAddinChangePolicyTypeSerializer().serialize(arg))
                d[".tag"] = .str("microsoft_office_addin_change_policy")
                return .dictionary(d)
            case .networkControlChangePolicy(let arg):
                var d = try Serialization.getFields(TeamLog.NetworkControlChangePolicyTypeSerializer().serialize(arg))
                d[".tag"] = .str("network_control_change_policy")
                return .dictionary(d)
            case .paperChangeDeploymentPolicy(let arg):
                var d = try Serialization.getFields(TeamLog.PaperChangeDeploymentPolicyTypeSerializer().serialize(arg))
                d[".tag"] = .str("paper_change_deployment_policy")
                return .dictionary(d)
            case .paperChangeMemberLinkPolicy(let arg):
                var d = try Serialization.getFields(TeamLog.PaperChangeMemberLinkPolicyTypeSerializer().serialize(arg))
                d[".tag"] = .str("paper_change_member_link_policy")
                return .dictionary(d)
            case .paperChangeMemberPolicy(let arg):
                var d = try Serialization.getFields(TeamLog.PaperChangeMemberPolicyTypeSerializer().serialize(arg))
                d[".tag"] = .str("paper_change_member_policy")
                return .dictionary(d)
            case .paperChangePolicy(let arg):
                var d = try Serialization.getFields(TeamLog.PaperChangePolicyTypeSerializer().serialize(arg))
                d[".tag"] = .str("paper_change_policy")
                return .dictionary(d)
            case .paperDefaultFolderPolicyChanged(let arg):
                var d = try Serialization.getFields(TeamLog.PaperDefaultFolderPolicyChangedTypeSerializer().serialize(arg))
                d[".tag"] = .str("paper_default_folder_policy_changed")
                return .dictionary(d)
            case .paperDesktopPolicyChanged(let arg):
                var d = try Serialization.getFields(TeamLog.PaperDesktopPolicyChangedTypeSerializer().serialize(arg))
                d[".tag"] = .str("paper_desktop_policy_changed")
                return .dictionary(d)
            case .paperEnabledUsersGroupAddition(let arg):
                var d = try Serialization.getFields(TeamLog.PaperEnabledUsersGroupAdditionTypeSerializer().serialize(arg))
                d[".tag"] = .str("paper_enabled_users_group_addition")
                return .dictionary(d)
            case .paperEnabledUsersGroupRemoval(let arg):
                var d = try Serialization.getFields(TeamLog.PaperEnabledUsersGroupRemovalTypeSerializer().serialize(arg))
                d[".tag"] = .str("paper_enabled_users_group_removal")
                return .dictionary(d)
            case .passwordStrengthRequirementsChangePolicy(let arg):
                var d = try Serialization.getFields(TeamLog.PasswordStrengthRequirementsChangePolicyTypeSerializer().serialize(arg))
                d[".tag"] = .str("password_strength_requirements_change_policy")
                return .dictionary(d)
            case .permanentDeleteChangePolicy(let arg):
                var d = try Serialization.getFields(TeamLog.PermanentDeleteChangePolicyTypeSerializer().serialize(arg))
                d[".tag"] = .str("permanent_delete_change_policy")
                return .dictionary(d)
            case .resellerSupportChangePolicy(let arg):
                var d = try Serialization.getFields(TeamLog.ResellerSupportChangePolicyTypeSerializer().serialize(arg))
                d[".tag"] = .str("reseller_support_change_policy")
                return .dictionary(d)
            case .rewindPolicyChanged(let arg):
                var d = try Serialization.getFields(TeamLog.RewindPolicyChangedTypeSerializer().serialize(arg))
                d[".tag"] = .str("rewind_policy_changed")
                return .dictionary(d)
            case .sendForSignaturePolicyChanged(let arg):
                var d = try Serialization.getFields(TeamLog.SendForSignaturePolicyChangedTypeSerializer().serialize(arg))
                d[".tag"] = .str("send_for_signature_policy_changed")
                return .dictionary(d)
            case .sharingChangeFolderJoinPolicy(let arg):
                var d = try Serialization.getFields(TeamLog.SharingChangeFolderJoinPolicyTypeSerializer().serialize(arg))
                d[".tag"] = .str("sharing_change_folder_join_policy")
                return .dictionary(d)
            case .sharingChangeLinkAllowChangeExpirationPolicy(let arg):
                var d = try Serialization.getFields(TeamLog.SharingChangeLinkAllowChangeExpirationPolicyTypeSerializer().serialize(arg))
                d[".tag"] = .str("sharing_change_link_allow_change_expiration_policy")
                return .dictionary(d)
            case .sharingChangeLinkDefaultExpirationPolicy(let arg):
                var d = try Serialization.getFields(TeamLog.SharingChangeLinkDefaultExpirationPolicyTypeSerializer().serialize(arg))
                d[".tag"] = .str("sharing_change_link_default_expiration_policy")
                return .dictionary(d)
            case .sharingChangeLinkEnforcePasswordPolicy(let arg):
                var d = try Serialization.getFields(TeamLog.SharingChangeLinkEnforcePasswordPolicyTypeSerializer().serialize(arg))
                d[".tag"] = .str("sharing_change_link_enforce_password_policy")
                return .dictionary(d)
            case .sharingChangeLinkPolicy(let arg):
                var d = try Serialization.getFields(TeamLog.SharingChangeLinkPolicyTypeSerializer().serialize(arg))
                d[".tag"] = .str("sharing_change_link_policy")
                return .dictionary(d)
            case .sharingChangeMemberPolicy(let arg):
                var d = try Serialization.getFields(TeamLog.SharingChangeMemberPolicyTypeSerializer().serialize(arg))
                d[".tag"] = .str("sharing_change_member_policy")
                return .dictionary(d)
            case .showcaseChangeDownloadPolicy(let arg):
                var d = try Serialization.getFields(TeamLog.ShowcaseChangeDownloadPolicyTypeSerializer().serialize(arg))
                d[".tag"] = .str("showcase_change_download_policy")
                return .dictionary(d)
            case .showcaseChangeEnabledPolicy(let arg):
                var d = try Serialization.getFields(TeamLog.ShowcaseChangeEnabledPolicyTypeSerializer().serialize(arg))
                d[".tag"] = .str("showcase_change_enabled_policy")
                return .dictionary(d)
            case .showcaseChangeExternalSharingPolicy(let arg):
                var d = try Serialization.getFields(TeamLog.ShowcaseChangeExternalSharingPolicyTypeSerializer().serialize(arg))
                d[".tag"] = .str("showcase_change_external_sharing_policy")
                return .dictionary(d)
            case .smarterSmartSyncPolicyChanged(let arg):
                var d = try Serialization.getFields(TeamLog.SmarterSmartSyncPolicyChangedTypeSerializer().serialize(arg))
                d[".tag"] = .str("smarter_smart_sync_policy_changed")
                return .dictionary(d)
            case .smartSyncChangePolicy(let arg):
                var d = try Serialization.getFields(TeamLog.SmartSyncChangePolicyTypeSerializer().serialize(arg))
                d[".tag"] = .str("smart_sync_change_policy")
                return .dictionary(d)
            case .smartSyncNotOptOut(let arg):
                var d = try Serialization.getFields(TeamLog.SmartSyncNotOptOutTypeSerializer().serialize(arg))
                d[".tag"] = .str("smart_sync_not_opt_out")
                return .dictionary(d)
            case .smartSyncOptOut(let arg):
                var d = try Serialization.getFields(TeamLog.SmartSyncOptOutTypeSerializer().serialize(arg))
                d[".tag"] = .str("smart_sync_opt_out")
                return .dictionary(d)
            case .ssoChangePolicy(let arg):
                var d = try Serialization.getFields(TeamLog.SsoChangePolicyTypeSerializer().serialize(arg))
                d[".tag"] = .str("sso_change_policy")
                return .dictionary(d)
            case .teamBrandingPolicyChanged(let arg):
                var d = try Serialization.getFields(TeamLog.TeamBrandingPolicyChangedTypeSerializer().serialize(arg))
                d[".tag"] = .str("team_branding_policy_changed")
                return .dictionary(d)
            case .teamExtensionsPolicyChanged(let arg):
                var d = try Serialization.getFields(TeamLog.TeamExtensionsPolicyChangedTypeSerializer().serialize(arg))
                d[".tag"] = .str("team_extensions_policy_changed")
                return .dictionary(d)
            case .teamSelectiveSyncPolicyChanged(let arg):
                var d = try Serialization.getFields(TeamLog.TeamSelectiveSyncPolicyChangedTypeSerializer().serialize(arg))
                d[".tag"] = .str("team_selective_sync_policy_changed")
                return .dictionary(d)
            case .teamSharingWhitelistSubjectsChanged(let arg):
                var d = try Serialization.getFields(TeamLog.TeamSharingWhitelistSubjectsChangedTypeSerializer().serialize(arg))
                d[".tag"] = .str("team_sharing_whitelist_subjects_changed")
                return .dictionary(d)
            case .tfaAddException(let arg):
                var d = try Serialization.getFields(TeamLog.TfaAddExceptionTypeSerializer().serialize(arg))
                d[".tag"] = .str("tfa_add_exception")
                return .dictionary(d)
            case .tfaChangePolicy(let arg):
                var d = try Serialization.getFields(TeamLog.TfaChangePolicyTypeSerializer().serialize(arg))
                d[".tag"] = .str("tfa_change_policy")
                return .dictionary(d)
            case .tfaRemoveException(let arg):
                var d = try Serialization.getFields(TeamLog.TfaRemoveExceptionTypeSerializer().serialize(arg))
                d[".tag"] = .str("tfa_remove_exception")
                return .dictionary(d)
            case .twoAccountChangePolicy(let arg):
                var d = try Serialization.getFields(TeamLog.TwoAccountChangePolicyTypeSerializer().serialize(arg))
                d[".tag"] = .str("two_account_change_policy")
                return .dictionary(d)
            case .viewerInfoPolicyChanged(let arg):
                var d = try Serialization.getFields(TeamLog.ViewerInfoPolicyChangedTypeSerializer().serialize(arg))
                d[".tag"] = .str("viewer_info_policy_changed")
                return .dictionary(d)
            case .watermarkingPolicyChanged(let arg):
                var d = try Serialization.getFields(TeamLog.WatermarkingPolicyChangedTypeSerializer().serialize(arg))
                d[".tag"] = .str("watermarking_policy_changed")
                return .dictionary(d)
            case .webSessionsChangeActiveSessionLimit(let arg):
                var d = try Serialization.getFields(TeamLog.WebSessionsChangeActiveSessionLimitTypeSerializer().serialize(arg))
                d[".tag"] = .str("web_sessions_change_active_session_limit")
                return .dictionary(d)
            case .webSessionsChangeFixedLengthPolicy(let arg):
                var d = try Serialization.getFields(TeamLog.WebSessionsChangeFixedLengthPolicyTypeSerializer().serialize(arg))
                d[".tag"] = .str("web_sessions_change_fixed_length_policy")
                return .dictionary(d)
            case .webSessionsChangeIdleLengthPolicy(let arg):
                var d = try Serialization.getFields(TeamLog.WebSessionsChangeIdleLengthPolicyTypeSerializer().serialize(arg))
                d[".tag"] = .str("web_sessions_change_idle_length_policy")
                return .dictionary(d)
            case .dataResidencyMigrationRequestSuccessful(let arg):
                var d = try Serialization.getFields(TeamLog.DataResidencyMigrationRequestSuccessfulTypeSerializer().serialize(arg))
                d[".tag"] = .str("data_residency_migration_request_successful")
                return .dictionary(d)
            case .dataResidencyMigrationRequestUnsuccessful(let arg):
                var d = try Serialization.getFields(TeamLog.DataResidencyMigrationRequestUnsuccessfulTypeSerializer().serialize(arg))
                d[".tag"] = .str("data_residency_migration_request_unsuccessful")
                return .dictionary(d)
            case .teamMergeFrom(let arg):
                var d = try Serialization.getFields(TeamLog.TeamMergeFromTypeSerializer().serialize(arg))
                d[".tag"] = .str("team_merge_from")
                return .dictionary(d)
            case .teamMergeTo(let arg):
                var d = try Serialization.getFields(TeamLog.TeamMergeToTypeSerializer().serialize(arg))
                d[".tag"] = .str("team_merge_to")
                return .dictionary(d)
            case .teamProfileAddBackground(let arg):
                var d = try Serialization.getFields(TeamLog.TeamProfileAddBackgroundTypeSerializer().serialize(arg))
                d[".tag"] = .str("team_profile_add_background")
                return .dictionary(d)
            case .teamProfileAddLogo(let arg):
                var d = try Serialization.getFields(TeamLog.TeamProfileAddLogoTypeSerializer().serialize(arg))
                d[".tag"] = .str("team_profile_add_logo")
                return .dictionary(d)
            case .teamProfileChangeBackground(let arg):
                var d = try Serialization.getFields(TeamLog.TeamProfileChangeBackgroundTypeSerializer().serialize(arg))
                d[".tag"] = .str("team_profile_change_background")
                return .dictionary(d)
            case .teamProfileChangeDefaultLanguage(let arg):
                var d = try Serialization.getFields(TeamLog.TeamProfileChangeDefaultLanguageTypeSerializer().serialize(arg))
                d[".tag"] = .str("team_profile_change_default_language")
                return .dictionary(d)
            case .teamProfileChangeLogo(let arg):
                var d = try Serialization.getFields(TeamLog.TeamProfileChangeLogoTypeSerializer().serialize(arg))
                d[".tag"] = .str("team_profile_change_logo")
                return .dictionary(d)
            case .teamProfileChangeName(let arg):
                var d = try Serialization.getFields(TeamLog.TeamProfileChangeNameTypeSerializer().serialize(arg))
                d[".tag"] = .str("team_profile_change_name")
                return .dictionary(d)
            case .teamProfileRemoveBackground(let arg):
                var d = try Serialization.getFields(TeamLog.TeamProfileRemoveBackgroundTypeSerializer().serialize(arg))
                d[".tag"] = .str("team_profile_remove_background")
                return .dictionary(d)
            case .teamProfileRemoveLogo(let arg):
                var d = try Serialization.getFields(TeamLog.TeamProfileRemoveLogoTypeSerializer().serialize(arg))
                d[".tag"] = .str("team_profile_remove_logo")
                return .dictionary(d)
            case .tfaAddBackupPhone(let arg):
                var d = try Serialization.getFields(TeamLog.TfaAddBackupPhoneTypeSerializer().serialize(arg))
                d[".tag"] = .str("tfa_add_backup_phone")
                return .dictionary(d)
            case .tfaAddSecurityKey(let arg):
                var d = try Serialization.getFields(TeamLog.TfaAddSecurityKeyTypeSerializer().serialize(arg))
                d[".tag"] = .str("tfa_add_security_key")
                return .dictionary(d)
            case .tfaChangeBackupPhone(let arg):
                var d = try Serialization.getFields(TeamLog.TfaChangeBackupPhoneTypeSerializer().serialize(arg))
                d[".tag"] = .str("tfa_change_backup_phone")
                return .dictionary(d)
            case .tfaChangeStatus(let arg):
                var d = try Serialization.getFields(TeamLog.TfaChangeStatusTypeSerializer().serialize(arg))
                d[".tag"] = .str("tfa_change_status")
                return .dictionary(d)
            case .tfaRemoveBackupPhone(let arg):
                var d = try Serialization.getFields(TeamLog.TfaRemoveBackupPhoneTypeSerializer().serialize(arg))
                d[".tag"] = .str("tfa_remove_backup_phone")
                return .dictionary(d)
            case .tfaRemoveSecurityKey(let arg):
                var d = try Serialization.getFields(TeamLog.TfaRemoveSecurityKeyTypeSerializer().serialize(arg))
                d[".tag"] = .str("tfa_remove_security_key")
                return .dictionary(d)
            case .tfaReset(let arg):
                var d = try Serialization.getFields(TeamLog.TfaResetTypeSerializer().serialize(arg))
                d[".tag"] = .str("tfa_reset")
                return .dictionary(d)
            case .changedEnterpriseAdminRole(let arg):
                var d = try Serialization.getFields(TeamLog.ChangedEnterpriseAdminRoleTypeSerializer().serialize(arg))
                d[".tag"] = .str("changed_enterprise_admin_role")
                return .dictionary(d)
            case .changedEnterpriseConnectedTeamStatus(let arg):
                var d = try Serialization.getFields(TeamLog.ChangedEnterpriseConnectedTeamStatusTypeSerializer().serialize(arg))
                d[".tag"] = .str("changed_enterprise_connected_team_status")
                return .dictionary(d)
            case .endedEnterpriseAdminSession(let arg):
                var d = try Serialization.getFields(TeamLog.EndedEnterpriseAdminSessionTypeSerializer().serialize(arg))
                d[".tag"] = .str("ended_enterprise_admin_session")
                return .dictionary(d)
            case .endedEnterpriseAdminSessionDeprecated(let arg):
                var d = try Serialization.getFields(TeamLog.EndedEnterpriseAdminSessionDeprecatedTypeSerializer().serialize(arg))
                d[".tag"] = .str("ended_enterprise_admin_session_deprecated")
                return .dictionary(d)
            case .enterpriseSettingsLocking(let arg):
                var d = try Serialization.getFields(TeamLog.EnterpriseSettingsLockingTypeSerializer().serialize(arg))
                d[".tag"] = .str("enterprise_settings_locking")
                return .dictionary(d)
            case .guestAdminChangeStatus(let arg):
                var d = try Serialization.getFields(TeamLog.GuestAdminChangeStatusTypeSerializer().serialize(arg))
                d[".tag"] = .str("guest_admin_change_status")
                return .dictionary(d)
            case .startedEnterpriseAdminSession(let arg):
                var d = try Serialization.getFields(TeamLog.StartedEnterpriseAdminSessionTypeSerializer().serialize(arg))
                d[".tag"] = .str("started_enterprise_admin_session")
                return .dictionary(d)
            case .teamMergeRequestAccepted(let arg):
                var d = try Serialization.getFields(TeamLog.TeamMergeRequestAcceptedTypeSerializer().serialize(arg))
                d[".tag"] = .str("team_merge_request_accepted")
                return .dictionary(d)
            case .teamMergeRequestAcceptedShownToPrimaryTeam(let arg):
                var d = try Serialization.getFields(TeamLog.TeamMergeRequestAcceptedShownToPrimaryTeamTypeSerializer().serialize(arg))
                d[".tag"] = .str("team_merge_request_accepted_shown_to_primary_team")
                return .dictionary(d)
            case .teamMergeRequestAcceptedShownToSecondaryTeam(let arg):
                var d = try Serialization.getFields(TeamLog.TeamMergeRequestAcceptedShownToSecondaryTeamTypeSerializer().serialize(arg))
                d[".tag"] = .str("team_merge_request_accepted_shown_to_secondary_team")
                return .dictionary(d)
            case .teamMergeRequestAutoCanceled(let arg):
                var d = try Serialization.getFields(TeamLog.TeamMergeRequestAutoCanceledTypeSerializer().serialize(arg))
                d[".tag"] = .str("team_merge_request_auto_canceled")
                return .dictionary(d)
            case .teamMergeRequestCanceled(let arg):
                var d = try Serialization.getFields(TeamLog.TeamMergeRequestCanceledTypeSerializer().serialize(arg))
                d[".tag"] = .str("team_merge_request_canceled")
                return .dictionary(d)
            case .teamMergeRequestCanceledShownToPrimaryTeam(let arg):
                var d = try Serialization.getFields(TeamLog.TeamMergeRequestCanceledShownToPrimaryTeamTypeSerializer().serialize(arg))
                d[".tag"] = .str("team_merge_request_canceled_shown_to_primary_team")
                return .dictionary(d)
            case .teamMergeRequestCanceledShownToSecondaryTeam(let arg):
                var d = try Serialization.getFields(TeamLog.TeamMergeRequestCanceledShownToSecondaryTeamTypeSerializer().serialize(arg))
                d[".tag"] = .str("team_merge_request_canceled_shown_to_secondary_team")
                return .dictionary(d)
            case .teamMergeRequestExpired(let arg):
                var d = try Serialization.getFields(TeamLog.TeamMergeRequestExpiredTypeSerializer().serialize(arg))
                d[".tag"] = .str("team_merge_request_expired")
                return .dictionary(d)
            case .teamMergeRequestExpiredShownToPrimaryTeam(let arg):
                var d = try Serialization.getFields(TeamLog.TeamMergeRequestExpiredShownToPrimaryTeamTypeSerializer().serialize(arg))
                d[".tag"] = .str("team_merge_request_expired_shown_to_primary_team")
                return .dictionary(d)
            case .teamMergeRequestExpiredShownToSecondaryTeam(let arg):
                var d = try Serialization.getFields(TeamLog.TeamMergeRequestExpiredShownToSecondaryTeamTypeSerializer().serialize(arg))
                d[".tag"] = .str("team_merge_request_expired_shown_to_secondary_team")
                return .dictionary(d)
            case .teamMergeRequestRejectedShownToPrimaryTeam(let arg):
                var d = try Serialization.getFields(TeamLog.TeamMergeRequestRejectedShownToPrimaryTeamTypeSerializer().serialize(arg))
                d[".tag"] = .str("team_merge_request_rejected_shown_to_primary_team")
                return .dictionary(d)
            case .teamMergeRequestRejectedShownToSecondaryTeam(let arg):
                var d = try Serialization.getFields(TeamLog.TeamMergeRequestRejectedShownToSecondaryTeamTypeSerializer().serialize(arg))
                d[".tag"] = .str("team_merge_request_rejected_shown_to_secondary_team")
                return .dictionary(d)
            case .teamMergeRequestReminder(let arg):
                var d = try Serialization.getFields(TeamLog.TeamMergeRequestReminderTypeSerializer().serialize(arg))
                d[".tag"] = .str("team_merge_request_reminder")
                return .dictionary(d)
            case .teamMergeRequestReminderShownToPrimaryTeam(let arg):
                var d = try Serialization.getFields(TeamLog.TeamMergeRequestReminderShownToPrimaryTeamTypeSerializer().serialize(arg))
                d[".tag"] = .str("team_merge_request_reminder_shown_to_primary_team")
                return .dictionary(d)
            case .teamMergeRequestReminderShownToSecondaryTeam(let arg):
                var d = try Serialization.getFields(TeamLog.TeamMergeRequestReminderShownToSecondaryTeamTypeSerializer().serialize(arg))
                d[".tag"] = .str("team_merge_request_reminder_shown_to_secondary_team")
                return .dictionary(d)
            case .teamMergeRequestRevoked(let arg):
                var d = try Serialization.getFields(TeamLog.TeamMergeRequestRevokedTypeSerializer().serialize(arg))
                d[".tag"] = .str("team_merge_request_revoked")
                return .dictionary(d)
            case .teamMergeRequestSentShownToPrimaryTeam(let arg):
                var d = try Serialization.getFields(TeamLog.TeamMergeRequestSentShownToPrimaryTeamTypeSerializer().serialize(arg))
                d[".tag"] = .str("team_merge_request_sent_shown_to_primary_team")
                return .dictionary(d)
            case .teamMergeRequestSentShownToSecondaryTeam(let arg):
                var d = try Serialization.getFields(TeamLog.TeamMergeRequestSentShownToSecondaryTeamTypeSerializer().serialize(arg))
                d[".tag"] = .str("team_merge_request_sent_shown_to_secondary_team")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> EventType {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "admin_alerting_alert_state_changed":
                    let v = try TeamLog.AdminAlertingAlertStateChangedTypeSerializer().deserialize(json)
                    return EventType.adminAlertingAlertStateChanged(v)
                case "admin_alerting_changed_alert_config":
                    let v = try TeamLog.AdminAlertingChangedAlertConfigTypeSerializer().deserialize(json)
                    return EventType.adminAlertingChangedAlertConfig(v)
                case "admin_alerting_triggered_alert":
                    let v = try TeamLog.AdminAlertingTriggeredAlertTypeSerializer().deserialize(json)
                    return EventType.adminAlertingTriggeredAlert(v)
                case "ransomware_restore_process_completed":
                    let v = try TeamLog.RansomwareRestoreProcessCompletedTypeSerializer().deserialize(json)
                    return EventType.ransomwareRestoreProcessCompleted(v)
                case "ransomware_restore_process_started":
                    let v = try TeamLog.RansomwareRestoreProcessStartedTypeSerializer().deserialize(json)
                    return EventType.ransomwareRestoreProcessStarted(v)
                case "app_blocked_by_permissions":
                    let v = try TeamLog.AppBlockedByPermissionsTypeSerializer().deserialize(json)
                    return EventType.appBlockedByPermissions(v)
                case "app_link_team":
                    let v = try TeamLog.AppLinkTeamTypeSerializer().deserialize(json)
                    return EventType.appLinkTeam(v)
                case "app_link_user":
                    let v = try TeamLog.AppLinkUserTypeSerializer().deserialize(json)
                    return EventType.appLinkUser(v)
                case "app_unlink_team":
                    let v = try TeamLog.AppUnlinkTeamTypeSerializer().deserialize(json)
                    return EventType.appUnlinkTeam(v)
                case "app_unlink_user":
                    let v = try TeamLog.AppUnlinkUserTypeSerializer().deserialize(json)
                    return EventType.appUnlinkUser(v)
                case "integration_connected":
                    let v = try TeamLog.IntegrationConnectedTypeSerializer().deserialize(json)
                    return EventType.integrationConnected(v)
                case "integration_disconnected":
                    let v = try TeamLog.IntegrationDisconnectedTypeSerializer().deserialize(json)
                    return EventType.integrationDisconnected(v)
                case "file_add_comment":
                    let v = try TeamLog.FileAddCommentTypeSerializer().deserialize(json)
                    return EventType.fileAddComment(v)
                case "file_change_comment_subscription":
                    let v = try TeamLog.FileChangeCommentSubscriptionTypeSerializer().deserialize(json)
                    return EventType.fileChangeCommentSubscription(v)
                case "file_delete_comment":
                    let v = try TeamLog.FileDeleteCommentTypeSerializer().deserialize(json)
                    return EventType.fileDeleteComment(v)
                case "file_edit_comment":
                    let v = try TeamLog.FileEditCommentTypeSerializer().deserialize(json)
                    return EventType.fileEditComment(v)
                case "file_like_comment":
                    let v = try TeamLog.FileLikeCommentTypeSerializer().deserialize(json)
                    return EventType.fileLikeComment(v)
                case "file_resolve_comment":
                    let v = try TeamLog.FileResolveCommentTypeSerializer().deserialize(json)
                    return EventType.fileResolveComment(v)
                case "file_unlike_comment":
                    let v = try TeamLog.FileUnlikeCommentTypeSerializer().deserialize(json)
                    return EventType.fileUnlikeComment(v)
                case "file_unresolve_comment":
                    let v = try TeamLog.FileUnresolveCommentTypeSerializer().deserialize(json)
                    return EventType.fileUnresolveComment(v)
                case "governance_policy_add_folders":
                    let v = try TeamLog.GovernancePolicyAddFoldersTypeSerializer().deserialize(json)
                    return EventType.governancePolicyAddFolders(v)
                case "governance_policy_add_folder_failed":
                    let v = try TeamLog.GovernancePolicyAddFolderFailedTypeSerializer().deserialize(json)
                    return EventType.governancePolicyAddFolderFailed(v)
                case "governance_policy_content_disposed":
                    let v = try TeamLog.GovernancePolicyContentDisposedTypeSerializer().deserialize(json)
                    return EventType.governancePolicyContentDisposed(v)
                case "governance_policy_create":
                    let v = try TeamLog.GovernancePolicyCreateTypeSerializer().deserialize(json)
                    return EventType.governancePolicyCreate(v)
                case "governance_policy_delete":
                    let v = try TeamLog.GovernancePolicyDeleteTypeSerializer().deserialize(json)
                    return EventType.governancePolicyDelete(v)
                case "governance_policy_edit_details":
                    let v = try TeamLog.GovernancePolicyEditDetailsTypeSerializer().deserialize(json)
                    return EventType.governancePolicyEditDetails(v)
                case "governance_policy_edit_duration":
                    let v = try TeamLog.GovernancePolicyEditDurationTypeSerializer().deserialize(json)
                    return EventType.governancePolicyEditDuration(v)
                case "governance_policy_export_created":
                    let v = try TeamLog.GovernancePolicyExportCreatedTypeSerializer().deserialize(json)
                    return EventType.governancePolicyExportCreated(v)
                case "governance_policy_export_removed":
                    let v = try TeamLog.GovernancePolicyExportRemovedTypeSerializer().deserialize(json)
                    return EventType.governancePolicyExportRemoved(v)
                case "governance_policy_remove_folders":
                    let v = try TeamLog.GovernancePolicyRemoveFoldersTypeSerializer().deserialize(json)
                    return EventType.governancePolicyRemoveFolders(v)
                case "governance_policy_report_created":
                    let v = try TeamLog.GovernancePolicyReportCreatedTypeSerializer().deserialize(json)
                    return EventType.governancePolicyReportCreated(v)
                case "governance_policy_zip_part_downloaded":
                    let v = try TeamLog.GovernancePolicyZipPartDownloadedTypeSerializer().deserialize(json)
                    return EventType.governancePolicyZipPartDownloaded(v)
                case "legal_holds_activate_a_hold":
                    let v = try TeamLog.LegalHoldsActivateAHoldTypeSerializer().deserialize(json)
                    return EventType.legalHoldsActivateAHold(v)
                case "legal_holds_add_members":
                    let v = try TeamLog.LegalHoldsAddMembersTypeSerializer().deserialize(json)
                    return EventType.legalHoldsAddMembers(v)
                case "legal_holds_change_hold_details":
                    let v = try TeamLog.LegalHoldsChangeHoldDetailsTypeSerializer().deserialize(json)
                    return EventType.legalHoldsChangeHoldDetails(v)
                case "legal_holds_change_hold_name":
                    let v = try TeamLog.LegalHoldsChangeHoldNameTypeSerializer().deserialize(json)
                    return EventType.legalHoldsChangeHoldName(v)
                case "legal_holds_export_a_hold":
                    let v = try TeamLog.LegalHoldsExportAHoldTypeSerializer().deserialize(json)
                    return EventType.legalHoldsExportAHold(v)
                case "legal_holds_export_cancelled":
                    let v = try TeamLog.LegalHoldsExportCancelledTypeSerializer().deserialize(json)
                    return EventType.legalHoldsExportCancelled(v)
                case "legal_holds_export_downloaded":
                    let v = try TeamLog.LegalHoldsExportDownloadedTypeSerializer().deserialize(json)
                    return EventType.legalHoldsExportDownloaded(v)
                case "legal_holds_export_removed":
                    let v = try TeamLog.LegalHoldsExportRemovedTypeSerializer().deserialize(json)
                    return EventType.legalHoldsExportRemoved(v)
                case "legal_holds_release_a_hold":
                    let v = try TeamLog.LegalHoldsReleaseAHoldTypeSerializer().deserialize(json)
                    return EventType.legalHoldsReleaseAHold(v)
                case "legal_holds_remove_members":
                    let v = try TeamLog.LegalHoldsRemoveMembersTypeSerializer().deserialize(json)
                    return EventType.legalHoldsRemoveMembers(v)
                case "legal_holds_report_a_hold":
                    let v = try TeamLog.LegalHoldsReportAHoldTypeSerializer().deserialize(json)
                    return EventType.legalHoldsReportAHold(v)
                case "device_change_ip_desktop":
                    let v = try TeamLog.DeviceChangeIpDesktopTypeSerializer().deserialize(json)
                    return EventType.deviceChangeIpDesktop(v)
                case "device_change_ip_mobile":
                    let v = try TeamLog.DeviceChangeIpMobileTypeSerializer().deserialize(json)
                    return EventType.deviceChangeIpMobile(v)
                case "device_change_ip_web":
                    let v = try TeamLog.DeviceChangeIpWebTypeSerializer().deserialize(json)
                    return EventType.deviceChangeIpWeb(v)
                case "device_delete_on_unlink_fail":
                    let v = try TeamLog.DeviceDeleteOnUnlinkFailTypeSerializer().deserialize(json)
                    return EventType.deviceDeleteOnUnlinkFail(v)
                case "device_delete_on_unlink_success":
                    let v = try TeamLog.DeviceDeleteOnUnlinkSuccessTypeSerializer().deserialize(json)
                    return EventType.deviceDeleteOnUnlinkSuccess(v)
                case "device_link_fail":
                    let v = try TeamLog.DeviceLinkFailTypeSerializer().deserialize(json)
                    return EventType.deviceLinkFail(v)
                case "device_link_success":
                    let v = try TeamLog.DeviceLinkSuccessTypeSerializer().deserialize(json)
                    return EventType.deviceLinkSuccess(v)
                case "device_management_disabled":
                    let v = try TeamLog.DeviceManagementDisabledTypeSerializer().deserialize(json)
                    return EventType.deviceManagementDisabled(v)
                case "device_management_enabled":
                    let v = try TeamLog.DeviceManagementEnabledTypeSerializer().deserialize(json)
                    return EventType.deviceManagementEnabled(v)
                case "device_sync_backup_status_changed":
                    let v = try TeamLog.DeviceSyncBackupStatusChangedTypeSerializer().deserialize(json)
                    return EventType.deviceSyncBackupStatusChanged(v)
                case "device_unlink":
                    let v = try TeamLog.DeviceUnlinkTypeSerializer().deserialize(json)
                    return EventType.deviceUnlink(v)
                case "dropbox_passwords_exported":
                    let v = try TeamLog.DropboxPasswordsExportedTypeSerializer().deserialize(json)
                    return EventType.dropboxPasswordsExported(v)
                case "dropbox_passwords_new_device_enrolled":
                    let v = try TeamLog.DropboxPasswordsNewDeviceEnrolledTypeSerializer().deserialize(json)
                    return EventType.dropboxPasswordsNewDeviceEnrolled(v)
                case "emm_refresh_auth_token":
                    let v = try TeamLog.EmmRefreshAuthTokenTypeSerializer().deserialize(json)
                    return EventType.emmRefreshAuthToken(v)
                case "external_drive_backup_eligibility_status_checked":
                    let v = try TeamLog.ExternalDriveBackupEligibilityStatusCheckedTypeSerializer().deserialize(json)
                    return EventType.externalDriveBackupEligibilityStatusChecked(v)
                case "external_drive_backup_status_changed":
                    let v = try TeamLog.ExternalDriveBackupStatusChangedTypeSerializer().deserialize(json)
                    return EventType.externalDriveBackupStatusChanged(v)
                case "account_capture_change_availability":
                    let v = try TeamLog.AccountCaptureChangeAvailabilityTypeSerializer().deserialize(json)
                    return EventType.accountCaptureChangeAvailability(v)
                case "account_capture_migrate_account":
                    let v = try TeamLog.AccountCaptureMigrateAccountTypeSerializer().deserialize(json)
                    return EventType.accountCaptureMigrateAccount(v)
                case "account_capture_notification_emails_sent":
                    let v = try TeamLog.AccountCaptureNotificationEmailsSentTypeSerializer().deserialize(json)
                    return EventType.accountCaptureNotificationEmailsSent(v)
                case "account_capture_relinquish_account":
                    let v = try TeamLog.AccountCaptureRelinquishAccountTypeSerializer().deserialize(json)
                    return EventType.accountCaptureRelinquishAccount(v)
                case "disabled_domain_invites":
                    let v = try TeamLog.DisabledDomainInvitesTypeSerializer().deserialize(json)
                    return EventType.disabledDomainInvites(v)
                case "domain_invites_approve_request_to_join_team":
                    let v = try TeamLog.DomainInvitesApproveRequestToJoinTeamTypeSerializer().deserialize(json)
                    return EventType.domainInvitesApproveRequestToJoinTeam(v)
                case "domain_invites_decline_request_to_join_team":
                    let v = try TeamLog.DomainInvitesDeclineRequestToJoinTeamTypeSerializer().deserialize(json)
                    return EventType.domainInvitesDeclineRequestToJoinTeam(v)
                case "domain_invites_email_existing_users":
                    let v = try TeamLog.DomainInvitesEmailExistingUsersTypeSerializer().deserialize(json)
                    return EventType.domainInvitesEmailExistingUsers(v)
                case "domain_invites_request_to_join_team":
                    let v = try TeamLog.DomainInvitesRequestToJoinTeamTypeSerializer().deserialize(json)
                    return EventType.domainInvitesRequestToJoinTeam(v)
                case "domain_invites_set_invite_new_user_pref_to_no":
                    let v = try TeamLog.DomainInvitesSetInviteNewUserPrefToNoTypeSerializer().deserialize(json)
                    return EventType.domainInvitesSetInviteNewUserPrefToNo(v)
                case "domain_invites_set_invite_new_user_pref_to_yes":
                    let v = try TeamLog.DomainInvitesSetInviteNewUserPrefToYesTypeSerializer().deserialize(json)
                    return EventType.domainInvitesSetInviteNewUserPrefToYes(v)
                case "domain_verification_add_domain_fail":
                    let v = try TeamLog.DomainVerificationAddDomainFailTypeSerializer().deserialize(json)
                    return EventType.domainVerificationAddDomainFail(v)
                case "domain_verification_add_domain_success":
                    let v = try TeamLog.DomainVerificationAddDomainSuccessTypeSerializer().deserialize(json)
                    return EventType.domainVerificationAddDomainSuccess(v)
                case "domain_verification_remove_domain":
                    let v = try TeamLog.DomainVerificationRemoveDomainTypeSerializer().deserialize(json)
                    return EventType.domainVerificationRemoveDomain(v)
                case "enabled_domain_invites":
                    let v = try TeamLog.EnabledDomainInvitesTypeSerializer().deserialize(json)
                    return EventType.enabledDomainInvites(v)
                case "team_encryption_key_cancel_key_deletion":
                    let v = try TeamLog.TeamEncryptionKeyCancelKeyDeletionTypeSerializer().deserialize(json)
                    return EventType.teamEncryptionKeyCancelKeyDeletion(v)
                case "team_encryption_key_create_key":
                    let v = try TeamLog.TeamEncryptionKeyCreateKeyTypeSerializer().deserialize(json)
                    return EventType.teamEncryptionKeyCreateKey(v)
                case "team_encryption_key_delete_key":
                    let v = try TeamLog.TeamEncryptionKeyDeleteKeyTypeSerializer().deserialize(json)
                    return EventType.teamEncryptionKeyDeleteKey(v)
                case "team_encryption_key_disable_key":
                    let v = try TeamLog.TeamEncryptionKeyDisableKeyTypeSerializer().deserialize(json)
                    return EventType.teamEncryptionKeyDisableKey(v)
                case "team_encryption_key_enable_key":
                    let v = try TeamLog.TeamEncryptionKeyEnableKeyTypeSerializer().deserialize(json)
                    return EventType.teamEncryptionKeyEnableKey(v)
                case "team_encryption_key_rotate_key":
                    let v = try TeamLog.TeamEncryptionKeyRotateKeyTypeSerializer().deserialize(json)
                    return EventType.teamEncryptionKeyRotateKey(v)
                case "team_encryption_key_schedule_key_deletion":
                    let v = try TeamLog.TeamEncryptionKeyScheduleKeyDeletionTypeSerializer().deserialize(json)
                    return EventType.teamEncryptionKeyScheduleKeyDeletion(v)
                case "apply_naming_convention":
                    let v = try TeamLog.ApplyNamingConventionTypeSerializer().deserialize(json)
                    return EventType.applyNamingConvention(v)
                case "create_folder":
                    let v = try TeamLog.CreateFolderTypeSerializer().deserialize(json)
                    return EventType.createFolder(v)
                case "file_add":
                    let v = try TeamLog.FileAddTypeSerializer().deserialize(json)
                    return EventType.fileAdd(v)
                case "file_add_from_automation":
                    let v = try TeamLog.FileAddFromAutomationTypeSerializer().deserialize(json)
                    return EventType.fileAddFromAutomation(v)
                case "file_copy":
                    let v = try TeamLog.FileCopyTypeSerializer().deserialize(json)
                    return EventType.fileCopy(v)
                case "file_delete":
                    let v = try TeamLog.FileDeleteTypeSerializer().deserialize(json)
                    return EventType.fileDelete(v)
                case "file_download":
                    let v = try TeamLog.FileDownloadTypeSerializer().deserialize(json)
                    return EventType.fileDownload(v)
                case "file_edit":
                    let v = try TeamLog.FileEditTypeSerializer().deserialize(json)
                    return EventType.fileEdit(v)
                case "file_get_copy_reference":
                    let v = try TeamLog.FileGetCopyReferenceTypeSerializer().deserialize(json)
                    return EventType.fileGetCopyReference(v)
                case "file_locking_lock_status_changed":
                    let v = try TeamLog.FileLockingLockStatusChangedTypeSerializer().deserialize(json)
                    return EventType.fileLockingLockStatusChanged(v)
                case "file_move":
                    let v = try TeamLog.FileMoveTypeSerializer().deserialize(json)
                    return EventType.fileMove(v)
                case "file_permanently_delete":
                    let v = try TeamLog.FilePermanentlyDeleteTypeSerializer().deserialize(json)
                    return EventType.filePermanentlyDelete(v)
                case "file_preview":
                    let v = try TeamLog.FilePreviewTypeSerializer().deserialize(json)
                    return EventType.filePreview(v)
                case "file_rename":
                    let v = try TeamLog.FileRenameTypeSerializer().deserialize(json)
                    return EventType.fileRename(v)
                case "file_restore":
                    let v = try TeamLog.FileRestoreTypeSerializer().deserialize(json)
                    return EventType.fileRestore(v)
                case "file_revert":
                    let v = try TeamLog.FileRevertTypeSerializer().deserialize(json)
                    return EventType.fileRevert(v)
                case "file_rollback_changes":
                    let v = try TeamLog.FileRollbackChangesTypeSerializer().deserialize(json)
                    return EventType.fileRollbackChanges(v)
                case "file_save_copy_reference":
                    let v = try TeamLog.FileSaveCopyReferenceTypeSerializer().deserialize(json)
                    return EventType.fileSaveCopyReference(v)
                case "folder_overview_description_changed":
                    let v = try TeamLog.FolderOverviewDescriptionChangedTypeSerializer().deserialize(json)
                    return EventType.folderOverviewDescriptionChanged(v)
                case "folder_overview_item_pinned":
                    let v = try TeamLog.FolderOverviewItemPinnedTypeSerializer().deserialize(json)
                    return EventType.folderOverviewItemPinned(v)
                case "folder_overview_item_unpinned":
                    let v = try TeamLog.FolderOverviewItemUnpinnedTypeSerializer().deserialize(json)
                    return EventType.folderOverviewItemUnpinned(v)
                case "object_label_added":
                    let v = try TeamLog.ObjectLabelAddedTypeSerializer().deserialize(json)
                    return EventType.objectLabelAdded(v)
                case "object_label_removed":
                    let v = try TeamLog.ObjectLabelRemovedTypeSerializer().deserialize(json)
                    return EventType.objectLabelRemoved(v)
                case "object_label_updated_value":
                    let v = try TeamLog.ObjectLabelUpdatedValueTypeSerializer().deserialize(json)
                    return EventType.objectLabelUpdatedValue(v)
                case "organize_folder_with_tidy":
                    let v = try TeamLog.OrganizeFolderWithTidyTypeSerializer().deserialize(json)
                    return EventType.organizeFolderWithTidy(v)
                case "replay_file_delete":
                    let v = try TeamLog.ReplayFileDeleteTypeSerializer().deserialize(json)
                    return EventType.replayFileDelete(v)
                case "rewind_folder":
                    let v = try TeamLog.RewindFolderTypeSerializer().deserialize(json)
                    return EventType.rewindFolder(v)
                case "undo_naming_convention":
                    let v = try TeamLog.UndoNamingConventionTypeSerializer().deserialize(json)
                    return EventType.undoNamingConvention(v)
                case "undo_organize_folder_with_tidy":
                    let v = try TeamLog.UndoOrganizeFolderWithTidyTypeSerializer().deserialize(json)
                    return EventType.undoOrganizeFolderWithTidy(v)
                case "user_tags_added":
                    let v = try TeamLog.UserTagsAddedTypeSerializer().deserialize(json)
                    return EventType.userTagsAdded(v)
                case "user_tags_removed":
                    let v = try TeamLog.UserTagsRemovedTypeSerializer().deserialize(json)
                    return EventType.userTagsRemoved(v)
                case "email_ingest_receive_file":
                    let v = try TeamLog.EmailIngestReceiveFileTypeSerializer().deserialize(json)
                    return EventType.emailIngestReceiveFile(v)
                case "file_request_change":
                    let v = try TeamLog.FileRequestChangeTypeSerializer().deserialize(json)
                    return EventType.fileRequestChange(v)
                case "file_request_close":
                    let v = try TeamLog.FileRequestCloseTypeSerializer().deserialize(json)
                    return EventType.fileRequestClose(v)
                case "file_request_create":
                    let v = try TeamLog.FileRequestCreateTypeSerializer().deserialize(json)
                    return EventType.fileRequestCreate(v)
                case "file_request_delete":
                    let v = try TeamLog.FileRequestDeleteTypeSerializer().deserialize(json)
                    return EventType.fileRequestDelete(v)
                case "file_request_receive_file":
                    let v = try TeamLog.FileRequestReceiveFileTypeSerializer().deserialize(json)
                    return EventType.fileRequestReceiveFile(v)
                case "group_add_external_id":
                    let v = try TeamLog.GroupAddExternalIdTypeSerializer().deserialize(json)
                    return EventType.groupAddExternalId(v)
                case "group_add_member":
                    let v = try TeamLog.GroupAddMemberTypeSerializer().deserialize(json)
                    return EventType.groupAddMember(v)
                case "group_change_external_id":
                    let v = try TeamLog.GroupChangeExternalIdTypeSerializer().deserialize(json)
                    return EventType.groupChangeExternalId(v)
                case "group_change_management_type":
                    let v = try TeamLog.GroupChangeManagementTypeTypeSerializer().deserialize(json)
                    return EventType.groupChangeManagementType(v)
                case "group_change_member_role":
                    let v = try TeamLog.GroupChangeMemberRoleTypeSerializer().deserialize(json)
                    return EventType.groupChangeMemberRole(v)
                case "group_create":
                    let v = try TeamLog.GroupCreateTypeSerializer().deserialize(json)
                    return EventType.groupCreate(v)
                case "group_delete":
                    let v = try TeamLog.GroupDeleteTypeSerializer().deserialize(json)
                    return EventType.groupDelete(v)
                case "group_description_updated":
                    let v = try TeamLog.GroupDescriptionUpdatedTypeSerializer().deserialize(json)
                    return EventType.groupDescriptionUpdated(v)
                case "group_join_policy_updated":
                    let v = try TeamLog.GroupJoinPolicyUpdatedTypeSerializer().deserialize(json)
                    return EventType.groupJoinPolicyUpdated(v)
                case "group_moved":
                    let v = try TeamLog.GroupMovedTypeSerializer().deserialize(json)
                    return EventType.groupMoved(v)
                case "group_remove_external_id":
                    let v = try TeamLog.GroupRemoveExternalIdTypeSerializer().deserialize(json)
                    return EventType.groupRemoveExternalId(v)
                case "group_remove_member":
                    let v = try TeamLog.GroupRemoveMemberTypeSerializer().deserialize(json)
                    return EventType.groupRemoveMember(v)
                case "group_rename":
                    let v = try TeamLog.GroupRenameTypeSerializer().deserialize(json)
                    return EventType.groupRename(v)
                case "account_lock_or_unlocked":
                    let v = try TeamLog.AccountLockOrUnlockedTypeSerializer().deserialize(json)
                    return EventType.accountLockOrUnlocked(v)
                case "emm_error":
                    let v = try TeamLog.EmmErrorTypeSerializer().deserialize(json)
                    return EventType.emmError(v)
                case "guest_admin_signed_in_via_trusted_teams":
                    let v = try TeamLog.GuestAdminSignedInViaTrustedTeamsTypeSerializer().deserialize(json)
                    return EventType.guestAdminSignedInViaTrustedTeams(v)
                case "guest_admin_signed_out_via_trusted_teams":
                    let v = try TeamLog.GuestAdminSignedOutViaTrustedTeamsTypeSerializer().deserialize(json)
                    return EventType.guestAdminSignedOutViaTrustedTeams(v)
                case "login_fail":
                    let v = try TeamLog.LoginFailTypeSerializer().deserialize(json)
                    return EventType.loginFail(v)
                case "login_success":
                    let v = try TeamLog.LoginSuccessTypeSerializer().deserialize(json)
                    return EventType.loginSuccess(v)
                case "logout":
                    let v = try TeamLog.LogoutTypeSerializer().deserialize(json)
                    return EventType.logout(v)
                case "reseller_support_session_end":
                    let v = try TeamLog.ResellerSupportSessionEndTypeSerializer().deserialize(json)
                    return EventType.resellerSupportSessionEnd(v)
                case "reseller_support_session_start":
                    let v = try TeamLog.ResellerSupportSessionStartTypeSerializer().deserialize(json)
                    return EventType.resellerSupportSessionStart(v)
                case "sign_in_as_session_end":
                    let v = try TeamLog.SignInAsSessionEndTypeSerializer().deserialize(json)
                    return EventType.signInAsSessionEnd(v)
                case "sign_in_as_session_start":
                    let v = try TeamLog.SignInAsSessionStartTypeSerializer().deserialize(json)
                    return EventType.signInAsSessionStart(v)
                case "sso_error":
                    let v = try TeamLog.SsoErrorTypeSerializer().deserialize(json)
                    return EventType.ssoError(v)
                case "backup_admin_invitation_sent":
                    let v = try TeamLog.BackupAdminInvitationSentTypeSerializer().deserialize(json)
                    return EventType.backupAdminInvitationSent(v)
                case "backup_invitation_opened":
                    let v = try TeamLog.BackupInvitationOpenedTypeSerializer().deserialize(json)
                    return EventType.backupInvitationOpened(v)
                case "create_team_invite_link":
                    let v = try TeamLog.CreateTeamInviteLinkTypeSerializer().deserialize(json)
                    return EventType.createTeamInviteLink(v)
                case "delete_team_invite_link":
                    let v = try TeamLog.DeleteTeamInviteLinkTypeSerializer().deserialize(json)
                    return EventType.deleteTeamInviteLink(v)
                case "member_add_external_id":
                    let v = try TeamLog.MemberAddExternalIdTypeSerializer().deserialize(json)
                    return EventType.memberAddExternalId(v)
                case "member_add_name":
                    let v = try TeamLog.MemberAddNameTypeSerializer().deserialize(json)
                    return EventType.memberAddName(v)
                case "member_change_admin_role":
                    let v = try TeamLog.MemberChangeAdminRoleTypeSerializer().deserialize(json)
                    return EventType.memberChangeAdminRole(v)
                case "member_change_email":
                    let v = try TeamLog.MemberChangeEmailTypeSerializer().deserialize(json)
                    return EventType.memberChangeEmail(v)
                case "member_change_external_id":
                    let v = try TeamLog.MemberChangeExternalIdTypeSerializer().deserialize(json)
                    return EventType.memberChangeExternalId(v)
                case "member_change_membership_type":
                    let v = try TeamLog.MemberChangeMembershipTypeTypeSerializer().deserialize(json)
                    return EventType.memberChangeMembershipType(v)
                case "member_change_name":
                    let v = try TeamLog.MemberChangeNameTypeSerializer().deserialize(json)
                    return EventType.memberChangeName(v)
                case "member_change_reseller_role":
                    let v = try TeamLog.MemberChangeResellerRoleTypeSerializer().deserialize(json)
                    return EventType.memberChangeResellerRole(v)
                case "member_change_status":
                    let v = try TeamLog.MemberChangeStatusTypeSerializer().deserialize(json)
                    return EventType.memberChangeStatus(v)
                case "member_delete_manual_contacts":
                    let v = try TeamLog.MemberDeleteManualContactsTypeSerializer().deserialize(json)
                    return EventType.memberDeleteManualContacts(v)
                case "member_delete_profile_photo":
                    let v = try TeamLog.MemberDeleteProfilePhotoTypeSerializer().deserialize(json)
                    return EventType.memberDeleteProfilePhoto(v)
                case "member_permanently_delete_account_contents":
                    let v = try TeamLog.MemberPermanentlyDeleteAccountContentsTypeSerializer().deserialize(json)
                    return EventType.memberPermanentlyDeleteAccountContents(v)
                case "member_remove_external_id":
                    let v = try TeamLog.MemberRemoveExternalIdTypeSerializer().deserialize(json)
                    return EventType.memberRemoveExternalId(v)
                case "member_set_profile_photo":
                    let v = try TeamLog.MemberSetProfilePhotoTypeSerializer().deserialize(json)
                    return EventType.memberSetProfilePhoto(v)
                case "member_space_limits_add_custom_quota":
                    let v = try TeamLog.MemberSpaceLimitsAddCustomQuotaTypeSerializer().deserialize(json)
                    return EventType.memberSpaceLimitsAddCustomQuota(v)
                case "member_space_limits_change_custom_quota":
                    let v = try TeamLog.MemberSpaceLimitsChangeCustomQuotaTypeSerializer().deserialize(json)
                    return EventType.memberSpaceLimitsChangeCustomQuota(v)
                case "member_space_limits_change_status":
                    let v = try TeamLog.MemberSpaceLimitsChangeStatusTypeSerializer().deserialize(json)
                    return EventType.memberSpaceLimitsChangeStatus(v)
                case "member_space_limits_remove_custom_quota":
                    let v = try TeamLog.MemberSpaceLimitsRemoveCustomQuotaTypeSerializer().deserialize(json)
                    return EventType.memberSpaceLimitsRemoveCustomQuota(v)
                case "member_suggest":
                    let v = try TeamLog.MemberSuggestTypeSerializer().deserialize(json)
                    return EventType.memberSuggest(v)
                case "member_transfer_account_contents":
                    let v = try TeamLog.MemberTransferAccountContentsTypeSerializer().deserialize(json)
                    return EventType.memberTransferAccountContents(v)
                case "pending_secondary_email_added":
                    let v = try TeamLog.PendingSecondaryEmailAddedTypeSerializer().deserialize(json)
                    return EventType.pendingSecondaryEmailAdded(v)
                case "secondary_email_deleted":
                    let v = try TeamLog.SecondaryEmailDeletedTypeSerializer().deserialize(json)
                    return EventType.secondaryEmailDeleted(v)
                case "secondary_email_verified":
                    let v = try TeamLog.SecondaryEmailVerifiedTypeSerializer().deserialize(json)
                    return EventType.secondaryEmailVerified(v)
                case "secondary_mails_policy_changed":
                    let v = try TeamLog.SecondaryMailsPolicyChangedTypeSerializer().deserialize(json)
                    return EventType.secondaryMailsPolicyChanged(v)
                case "binder_add_page":
                    let v = try TeamLog.BinderAddPageTypeSerializer().deserialize(json)
                    return EventType.binderAddPage(v)
                case "binder_add_section":
                    let v = try TeamLog.BinderAddSectionTypeSerializer().deserialize(json)
                    return EventType.binderAddSection(v)
                case "binder_remove_page":
                    let v = try TeamLog.BinderRemovePageTypeSerializer().deserialize(json)
                    return EventType.binderRemovePage(v)
                case "binder_remove_section":
                    let v = try TeamLog.BinderRemoveSectionTypeSerializer().deserialize(json)
                    return EventType.binderRemoveSection(v)
                case "binder_rename_page":
                    let v = try TeamLog.BinderRenamePageTypeSerializer().deserialize(json)
                    return EventType.binderRenamePage(v)
                case "binder_rename_section":
                    let v = try TeamLog.BinderRenameSectionTypeSerializer().deserialize(json)
                    return EventType.binderRenameSection(v)
                case "binder_reorder_page":
                    let v = try TeamLog.BinderReorderPageTypeSerializer().deserialize(json)
                    return EventType.binderReorderPage(v)
                case "binder_reorder_section":
                    let v = try TeamLog.BinderReorderSectionTypeSerializer().deserialize(json)
                    return EventType.binderReorderSection(v)
                case "paper_content_add_member":
                    let v = try TeamLog.PaperContentAddMemberTypeSerializer().deserialize(json)
                    return EventType.paperContentAddMember(v)
                case "paper_content_add_to_folder":
                    let v = try TeamLog.PaperContentAddToFolderTypeSerializer().deserialize(json)
                    return EventType.paperContentAddToFolder(v)
                case "paper_content_archive":
                    let v = try TeamLog.PaperContentArchiveTypeSerializer().deserialize(json)
                    return EventType.paperContentArchive(v)
                case "paper_content_create":
                    let v = try TeamLog.PaperContentCreateTypeSerializer().deserialize(json)
                    return EventType.paperContentCreate(v)
                case "paper_content_permanently_delete":
                    let v = try TeamLog.PaperContentPermanentlyDeleteTypeSerializer().deserialize(json)
                    return EventType.paperContentPermanentlyDelete(v)
                case "paper_content_remove_from_folder":
                    let v = try TeamLog.PaperContentRemoveFromFolderTypeSerializer().deserialize(json)
                    return EventType.paperContentRemoveFromFolder(v)
                case "paper_content_remove_member":
                    let v = try TeamLog.PaperContentRemoveMemberTypeSerializer().deserialize(json)
                    return EventType.paperContentRemoveMember(v)
                case "paper_content_rename":
                    let v = try TeamLog.PaperContentRenameTypeSerializer().deserialize(json)
                    return EventType.paperContentRename(v)
                case "paper_content_restore":
                    let v = try TeamLog.PaperContentRestoreTypeSerializer().deserialize(json)
                    return EventType.paperContentRestore(v)
                case "paper_doc_add_comment":
                    let v = try TeamLog.PaperDocAddCommentTypeSerializer().deserialize(json)
                    return EventType.paperDocAddComment(v)
                case "paper_doc_change_member_role":
                    let v = try TeamLog.PaperDocChangeMemberRoleTypeSerializer().deserialize(json)
                    return EventType.paperDocChangeMemberRole(v)
                case "paper_doc_change_sharing_policy":
                    let v = try TeamLog.PaperDocChangeSharingPolicyTypeSerializer().deserialize(json)
                    return EventType.paperDocChangeSharingPolicy(v)
                case "paper_doc_change_subscription":
                    let v = try TeamLog.PaperDocChangeSubscriptionTypeSerializer().deserialize(json)
                    return EventType.paperDocChangeSubscription(v)
                case "paper_doc_deleted":
                    let v = try TeamLog.PaperDocDeletedTypeSerializer().deserialize(json)
                    return EventType.paperDocDeleted(v)
                case "paper_doc_delete_comment":
                    let v = try TeamLog.PaperDocDeleteCommentTypeSerializer().deserialize(json)
                    return EventType.paperDocDeleteComment(v)
                case "paper_doc_download":
                    let v = try TeamLog.PaperDocDownloadTypeSerializer().deserialize(json)
                    return EventType.paperDocDownload(v)
                case "paper_doc_edit":
                    let v = try TeamLog.PaperDocEditTypeSerializer().deserialize(json)
                    return EventType.paperDocEdit(v)
                case "paper_doc_edit_comment":
                    let v = try TeamLog.PaperDocEditCommentTypeSerializer().deserialize(json)
                    return EventType.paperDocEditComment(v)
                case "paper_doc_followed":
                    let v = try TeamLog.PaperDocFollowedTypeSerializer().deserialize(json)
                    return EventType.paperDocFollowed(v)
                case "paper_doc_mention":
                    let v = try TeamLog.PaperDocMentionTypeSerializer().deserialize(json)
                    return EventType.paperDocMention(v)
                case "paper_doc_ownership_changed":
                    let v = try TeamLog.PaperDocOwnershipChangedTypeSerializer().deserialize(json)
                    return EventType.paperDocOwnershipChanged(v)
                case "paper_doc_request_access":
                    let v = try TeamLog.PaperDocRequestAccessTypeSerializer().deserialize(json)
                    return EventType.paperDocRequestAccess(v)
                case "paper_doc_resolve_comment":
                    let v = try TeamLog.PaperDocResolveCommentTypeSerializer().deserialize(json)
                    return EventType.paperDocResolveComment(v)
                case "paper_doc_revert":
                    let v = try TeamLog.PaperDocRevertTypeSerializer().deserialize(json)
                    return EventType.paperDocRevert(v)
                case "paper_doc_slack_share":
                    let v = try TeamLog.PaperDocSlackShareTypeSerializer().deserialize(json)
                    return EventType.paperDocSlackShare(v)
                case "paper_doc_team_invite":
                    let v = try TeamLog.PaperDocTeamInviteTypeSerializer().deserialize(json)
                    return EventType.paperDocTeamInvite(v)
                case "paper_doc_trashed":
                    let v = try TeamLog.PaperDocTrashedTypeSerializer().deserialize(json)
                    return EventType.paperDocTrashed(v)
                case "paper_doc_unresolve_comment":
                    let v = try TeamLog.PaperDocUnresolveCommentTypeSerializer().deserialize(json)
                    return EventType.paperDocUnresolveComment(v)
                case "paper_doc_untrashed":
                    let v = try TeamLog.PaperDocUntrashedTypeSerializer().deserialize(json)
                    return EventType.paperDocUntrashed(v)
                case "paper_doc_view":
                    let v = try TeamLog.PaperDocViewTypeSerializer().deserialize(json)
                    return EventType.paperDocView(v)
                case "paper_external_view_allow":
                    let v = try TeamLog.PaperExternalViewAllowTypeSerializer().deserialize(json)
                    return EventType.paperExternalViewAllow(v)
                case "paper_external_view_default_team":
                    let v = try TeamLog.PaperExternalViewDefaultTeamTypeSerializer().deserialize(json)
                    return EventType.paperExternalViewDefaultTeam(v)
                case "paper_external_view_forbid":
                    let v = try TeamLog.PaperExternalViewForbidTypeSerializer().deserialize(json)
                    return EventType.paperExternalViewForbid(v)
                case "paper_folder_change_subscription":
                    let v = try TeamLog.PaperFolderChangeSubscriptionTypeSerializer().deserialize(json)
                    return EventType.paperFolderChangeSubscription(v)
                case "paper_folder_deleted":
                    let v = try TeamLog.PaperFolderDeletedTypeSerializer().deserialize(json)
                    return EventType.paperFolderDeleted(v)
                case "paper_folder_followed":
                    let v = try TeamLog.PaperFolderFollowedTypeSerializer().deserialize(json)
                    return EventType.paperFolderFollowed(v)
                case "paper_folder_team_invite":
                    let v = try TeamLog.PaperFolderTeamInviteTypeSerializer().deserialize(json)
                    return EventType.paperFolderTeamInvite(v)
                case "paper_published_link_change_permission":
                    let v = try TeamLog.PaperPublishedLinkChangePermissionTypeSerializer().deserialize(json)
                    return EventType.paperPublishedLinkChangePermission(v)
                case "paper_published_link_create":
                    let v = try TeamLog.PaperPublishedLinkCreateTypeSerializer().deserialize(json)
                    return EventType.paperPublishedLinkCreate(v)
                case "paper_published_link_disabled":
                    let v = try TeamLog.PaperPublishedLinkDisabledTypeSerializer().deserialize(json)
                    return EventType.paperPublishedLinkDisabled(v)
                case "paper_published_link_view":
                    let v = try TeamLog.PaperPublishedLinkViewTypeSerializer().deserialize(json)
                    return EventType.paperPublishedLinkView(v)
                case "password_change":
                    let v = try TeamLog.PasswordChangeTypeSerializer().deserialize(json)
                    return EventType.passwordChange(v)
                case "password_reset":
                    let v = try TeamLog.PasswordResetTypeSerializer().deserialize(json)
                    return EventType.passwordReset(v)
                case "password_reset_all":
                    let v = try TeamLog.PasswordResetAllTypeSerializer().deserialize(json)
                    return EventType.passwordResetAll(v)
                case "classification_create_report":
                    let v = try TeamLog.ClassificationCreateReportTypeSerializer().deserialize(json)
                    return EventType.classificationCreateReport(v)
                case "classification_create_report_fail":
                    let v = try TeamLog.ClassificationCreateReportFailTypeSerializer().deserialize(json)
                    return EventType.classificationCreateReportFail(v)
                case "emm_create_exceptions_report":
                    let v = try TeamLog.EmmCreateExceptionsReportTypeSerializer().deserialize(json)
                    return EventType.emmCreateExceptionsReport(v)
                case "emm_create_usage_report":
                    let v = try TeamLog.EmmCreateUsageReportTypeSerializer().deserialize(json)
                    return EventType.emmCreateUsageReport(v)
                case "export_members_report":
                    let v = try TeamLog.ExportMembersReportTypeSerializer().deserialize(json)
                    return EventType.exportMembersReport(v)
                case "export_members_report_fail":
                    let v = try TeamLog.ExportMembersReportFailTypeSerializer().deserialize(json)
                    return EventType.exportMembersReportFail(v)
                case "external_sharing_create_report":
                    let v = try TeamLog.ExternalSharingCreateReportTypeSerializer().deserialize(json)
                    return EventType.externalSharingCreateReport(v)
                case "external_sharing_report_failed":
                    let v = try TeamLog.ExternalSharingReportFailedTypeSerializer().deserialize(json)
                    return EventType.externalSharingReportFailed(v)
                case "no_expiration_link_gen_create_report":
                    let v = try TeamLog.NoExpirationLinkGenCreateReportTypeSerializer().deserialize(json)
                    return EventType.noExpirationLinkGenCreateReport(v)
                case "no_expiration_link_gen_report_failed":
                    let v = try TeamLog.NoExpirationLinkGenReportFailedTypeSerializer().deserialize(json)
                    return EventType.noExpirationLinkGenReportFailed(v)
                case "no_password_link_gen_create_report":
                    let v = try TeamLog.NoPasswordLinkGenCreateReportTypeSerializer().deserialize(json)
                    return EventType.noPasswordLinkGenCreateReport(v)
                case "no_password_link_gen_report_failed":
                    let v = try TeamLog.NoPasswordLinkGenReportFailedTypeSerializer().deserialize(json)
                    return EventType.noPasswordLinkGenReportFailed(v)
                case "no_password_link_view_create_report":
                    let v = try TeamLog.NoPasswordLinkViewCreateReportTypeSerializer().deserialize(json)
                    return EventType.noPasswordLinkViewCreateReport(v)
                case "no_password_link_view_report_failed":
                    let v = try TeamLog.NoPasswordLinkViewReportFailedTypeSerializer().deserialize(json)
                    return EventType.noPasswordLinkViewReportFailed(v)
                case "outdated_link_view_create_report":
                    let v = try TeamLog.OutdatedLinkViewCreateReportTypeSerializer().deserialize(json)
                    return EventType.outdatedLinkViewCreateReport(v)
                case "outdated_link_view_report_failed":
                    let v = try TeamLog.OutdatedLinkViewReportFailedTypeSerializer().deserialize(json)
                    return EventType.outdatedLinkViewReportFailed(v)
                case "paper_admin_export_start":
                    let v = try TeamLog.PaperAdminExportStartTypeSerializer().deserialize(json)
                    return EventType.paperAdminExportStart(v)
                case "ransomware_alert_create_report":
                    let v = try TeamLog.RansomwareAlertCreateReportTypeSerializer().deserialize(json)
                    return EventType.ransomwareAlertCreateReport(v)
                case "ransomware_alert_create_report_failed":
                    let v = try TeamLog.RansomwareAlertCreateReportFailedTypeSerializer().deserialize(json)
                    return EventType.ransomwareAlertCreateReportFailed(v)
                case "smart_sync_create_admin_privilege_report":
                    let v = try TeamLog.SmartSyncCreateAdminPrivilegeReportTypeSerializer().deserialize(json)
                    return EventType.smartSyncCreateAdminPrivilegeReport(v)
                case "team_activity_create_report":
                    let v = try TeamLog.TeamActivityCreateReportTypeSerializer().deserialize(json)
                    return EventType.teamActivityCreateReport(v)
                case "team_activity_create_report_fail":
                    let v = try TeamLog.TeamActivityCreateReportFailTypeSerializer().deserialize(json)
                    return EventType.teamActivityCreateReportFail(v)
                case "collection_share":
                    let v = try TeamLog.CollectionShareTypeSerializer().deserialize(json)
                    return EventType.collectionShare(v)
                case "file_transfers_file_add":
                    let v = try TeamLog.FileTransfersFileAddTypeSerializer().deserialize(json)
                    return EventType.fileTransfersFileAdd(v)
                case "file_transfers_transfer_delete":
                    let v = try TeamLog.FileTransfersTransferDeleteTypeSerializer().deserialize(json)
                    return EventType.fileTransfersTransferDelete(v)
                case "file_transfers_transfer_download":
                    let v = try TeamLog.FileTransfersTransferDownloadTypeSerializer().deserialize(json)
                    return EventType.fileTransfersTransferDownload(v)
                case "file_transfers_transfer_send":
                    let v = try TeamLog.FileTransfersTransferSendTypeSerializer().deserialize(json)
                    return EventType.fileTransfersTransferSend(v)
                case "file_transfers_transfer_view":
                    let v = try TeamLog.FileTransfersTransferViewTypeSerializer().deserialize(json)
                    return EventType.fileTransfersTransferView(v)
                case "note_acl_invite_only":
                    let v = try TeamLog.NoteAclInviteOnlyTypeSerializer().deserialize(json)
                    return EventType.noteAclInviteOnly(v)
                case "note_acl_link":
                    let v = try TeamLog.NoteAclLinkTypeSerializer().deserialize(json)
                    return EventType.noteAclLink(v)
                case "note_acl_team_link":
                    let v = try TeamLog.NoteAclTeamLinkTypeSerializer().deserialize(json)
                    return EventType.noteAclTeamLink(v)
                case "note_shared":
                    let v = try TeamLog.NoteSharedTypeSerializer().deserialize(json)
                    return EventType.noteShared(v)
                case "note_share_receive":
                    let v = try TeamLog.NoteShareReceiveTypeSerializer().deserialize(json)
                    return EventType.noteShareReceive(v)
                case "open_note_shared":
                    let v = try TeamLog.OpenNoteSharedTypeSerializer().deserialize(json)
                    return EventType.openNoteShared(v)
                case "replay_file_shared_link_created":
                    let v = try TeamLog.ReplayFileSharedLinkCreatedTypeSerializer().deserialize(json)
                    return EventType.replayFileSharedLinkCreated(v)
                case "replay_file_shared_link_modified":
                    let v = try TeamLog.ReplayFileSharedLinkModifiedTypeSerializer().deserialize(json)
                    return EventType.replayFileSharedLinkModified(v)
                case "replay_project_team_add":
                    let v = try TeamLog.ReplayProjectTeamAddTypeSerializer().deserialize(json)
                    return EventType.replayProjectTeamAdd(v)
                case "replay_project_team_delete":
                    let v = try TeamLog.ReplayProjectTeamDeleteTypeSerializer().deserialize(json)
                    return EventType.replayProjectTeamDelete(v)
                case "sf_add_group":
                    let v = try TeamLog.SfAddGroupTypeSerializer().deserialize(json)
                    return EventType.sfAddGroup(v)
                case "sf_allow_non_members_to_view_shared_links":
                    let v = try TeamLog.SfAllowNonMembersToViewSharedLinksTypeSerializer().deserialize(json)
                    return EventType.sfAllowNonMembersToViewSharedLinks(v)
                case "sf_external_invite_warn":
                    let v = try TeamLog.SfExternalInviteWarnTypeSerializer().deserialize(json)
                    return EventType.sfExternalInviteWarn(v)
                case "sf_fb_invite":
                    let v = try TeamLog.SfFbInviteTypeSerializer().deserialize(json)
                    return EventType.sfFbInvite(v)
                case "sf_fb_invite_change_role":
                    let v = try TeamLog.SfFbInviteChangeRoleTypeSerializer().deserialize(json)
                    return EventType.sfFbInviteChangeRole(v)
                case "sf_fb_uninvite":
                    let v = try TeamLog.SfFbUninviteTypeSerializer().deserialize(json)
                    return EventType.sfFbUninvite(v)
                case "sf_invite_group":
                    let v = try TeamLog.SfInviteGroupTypeSerializer().deserialize(json)
                    return EventType.sfInviteGroup(v)
                case "sf_team_grant_access":
                    let v = try TeamLog.SfTeamGrantAccessTypeSerializer().deserialize(json)
                    return EventType.sfTeamGrantAccess(v)
                case "sf_team_invite":
                    let v = try TeamLog.SfTeamInviteTypeSerializer().deserialize(json)
                    return EventType.sfTeamInvite(v)
                case "sf_team_invite_change_role":
                    let v = try TeamLog.SfTeamInviteChangeRoleTypeSerializer().deserialize(json)
                    return EventType.sfTeamInviteChangeRole(v)
                case "sf_team_join":
                    let v = try TeamLog.SfTeamJoinTypeSerializer().deserialize(json)
                    return EventType.sfTeamJoin(v)
                case "sf_team_join_from_oob_link":
                    let v = try TeamLog.SfTeamJoinFromOobLinkTypeSerializer().deserialize(json)
                    return EventType.sfTeamJoinFromOobLink(v)
                case "sf_team_uninvite":
                    let v = try TeamLog.SfTeamUninviteTypeSerializer().deserialize(json)
                    return EventType.sfTeamUninvite(v)
                case "shared_content_add_invitees":
                    let v = try TeamLog.SharedContentAddInviteesTypeSerializer().deserialize(json)
                    return EventType.sharedContentAddInvitees(v)
                case "shared_content_add_link_expiry":
                    let v = try TeamLog.SharedContentAddLinkExpiryTypeSerializer().deserialize(json)
                    return EventType.sharedContentAddLinkExpiry(v)
                case "shared_content_add_link_password":
                    let v = try TeamLog.SharedContentAddLinkPasswordTypeSerializer().deserialize(json)
                    return EventType.sharedContentAddLinkPassword(v)
                case "shared_content_add_member":
                    let v = try TeamLog.SharedContentAddMemberTypeSerializer().deserialize(json)
                    return EventType.sharedContentAddMember(v)
                case "shared_content_change_downloads_policy":
                    let v = try TeamLog.SharedContentChangeDownloadsPolicyTypeSerializer().deserialize(json)
                    return EventType.sharedContentChangeDownloadsPolicy(v)
                case "shared_content_change_invitee_role":
                    let v = try TeamLog.SharedContentChangeInviteeRoleTypeSerializer().deserialize(json)
                    return EventType.sharedContentChangeInviteeRole(v)
                case "shared_content_change_link_audience":
                    let v = try TeamLog.SharedContentChangeLinkAudienceTypeSerializer().deserialize(json)
                    return EventType.sharedContentChangeLinkAudience(v)
                case "shared_content_change_link_expiry":
                    let v = try TeamLog.SharedContentChangeLinkExpiryTypeSerializer().deserialize(json)
                    return EventType.sharedContentChangeLinkExpiry(v)
                case "shared_content_change_link_password":
                    let v = try TeamLog.SharedContentChangeLinkPasswordTypeSerializer().deserialize(json)
                    return EventType.sharedContentChangeLinkPassword(v)
                case "shared_content_change_member_role":
                    let v = try TeamLog.SharedContentChangeMemberRoleTypeSerializer().deserialize(json)
                    return EventType.sharedContentChangeMemberRole(v)
                case "shared_content_change_viewer_info_policy":
                    let v = try TeamLog.SharedContentChangeViewerInfoPolicyTypeSerializer().deserialize(json)
                    return EventType.sharedContentChangeViewerInfoPolicy(v)
                case "shared_content_claim_invitation":
                    let v = try TeamLog.SharedContentClaimInvitationTypeSerializer().deserialize(json)
                    return EventType.sharedContentClaimInvitation(v)
                case "shared_content_copy":
                    let v = try TeamLog.SharedContentCopyTypeSerializer().deserialize(json)
                    return EventType.sharedContentCopy(v)
                case "shared_content_download":
                    let v = try TeamLog.SharedContentDownloadTypeSerializer().deserialize(json)
                    return EventType.sharedContentDownload(v)
                case "shared_content_relinquish_membership":
                    let v = try TeamLog.SharedContentRelinquishMembershipTypeSerializer().deserialize(json)
                    return EventType.sharedContentRelinquishMembership(v)
                case "shared_content_remove_invitees":
                    let v = try TeamLog.SharedContentRemoveInviteesTypeSerializer().deserialize(json)
                    return EventType.sharedContentRemoveInvitees(v)
                case "shared_content_remove_link_expiry":
                    let v = try TeamLog.SharedContentRemoveLinkExpiryTypeSerializer().deserialize(json)
                    return EventType.sharedContentRemoveLinkExpiry(v)
                case "shared_content_remove_link_password":
                    let v = try TeamLog.SharedContentRemoveLinkPasswordTypeSerializer().deserialize(json)
                    return EventType.sharedContentRemoveLinkPassword(v)
                case "shared_content_remove_member":
                    let v = try TeamLog.SharedContentRemoveMemberTypeSerializer().deserialize(json)
                    return EventType.sharedContentRemoveMember(v)
                case "shared_content_request_access":
                    let v = try TeamLog.SharedContentRequestAccessTypeSerializer().deserialize(json)
                    return EventType.sharedContentRequestAccess(v)
                case "shared_content_restore_invitees":
                    let v = try TeamLog.SharedContentRestoreInviteesTypeSerializer().deserialize(json)
                    return EventType.sharedContentRestoreInvitees(v)
                case "shared_content_restore_member":
                    let v = try TeamLog.SharedContentRestoreMemberTypeSerializer().deserialize(json)
                    return EventType.sharedContentRestoreMember(v)
                case "shared_content_unshare":
                    let v = try TeamLog.SharedContentUnshareTypeSerializer().deserialize(json)
                    return EventType.sharedContentUnshare(v)
                case "shared_content_view":
                    let v = try TeamLog.SharedContentViewTypeSerializer().deserialize(json)
                    return EventType.sharedContentView(v)
                case "shared_folder_change_link_policy":
                    let v = try TeamLog.SharedFolderChangeLinkPolicyTypeSerializer().deserialize(json)
                    return EventType.sharedFolderChangeLinkPolicy(v)
                case "shared_folder_change_members_inheritance_policy":
                    let v = try TeamLog.SharedFolderChangeMembersInheritancePolicyTypeSerializer().deserialize(json)
                    return EventType.sharedFolderChangeMembersInheritancePolicy(v)
                case "shared_folder_change_members_management_policy":
                    let v = try TeamLog.SharedFolderChangeMembersManagementPolicyTypeSerializer().deserialize(json)
                    return EventType.sharedFolderChangeMembersManagementPolicy(v)
                case "shared_folder_change_members_policy":
                    let v = try TeamLog.SharedFolderChangeMembersPolicyTypeSerializer().deserialize(json)
                    return EventType.sharedFolderChangeMembersPolicy(v)
                case "shared_folder_create":
                    let v = try TeamLog.SharedFolderCreateTypeSerializer().deserialize(json)
                    return EventType.sharedFolderCreate(v)
                case "shared_folder_decline_invitation":
                    let v = try TeamLog.SharedFolderDeclineInvitationTypeSerializer().deserialize(json)
                    return EventType.sharedFolderDeclineInvitation(v)
                case "shared_folder_mount":
                    let v = try TeamLog.SharedFolderMountTypeSerializer().deserialize(json)
                    return EventType.sharedFolderMount(v)
                case "shared_folder_nest":
                    let v = try TeamLog.SharedFolderNestTypeSerializer().deserialize(json)
                    return EventType.sharedFolderNest(v)
                case "shared_folder_transfer_ownership":
                    let v = try TeamLog.SharedFolderTransferOwnershipTypeSerializer().deserialize(json)
                    return EventType.sharedFolderTransferOwnership(v)
                case "shared_folder_unmount":
                    let v = try TeamLog.SharedFolderUnmountTypeSerializer().deserialize(json)
                    return EventType.sharedFolderUnmount(v)
                case "shared_link_add_expiry":
                    let v = try TeamLog.SharedLinkAddExpiryTypeSerializer().deserialize(json)
                    return EventType.sharedLinkAddExpiry(v)
                case "shared_link_change_expiry":
                    let v = try TeamLog.SharedLinkChangeExpiryTypeSerializer().deserialize(json)
                    return EventType.sharedLinkChangeExpiry(v)
                case "shared_link_change_visibility":
                    let v = try TeamLog.SharedLinkChangeVisibilityTypeSerializer().deserialize(json)
                    return EventType.sharedLinkChangeVisibility(v)
                case "shared_link_copy":
                    let v = try TeamLog.SharedLinkCopyTypeSerializer().deserialize(json)
                    return EventType.sharedLinkCopy(v)
                case "shared_link_create":
                    let v = try TeamLog.SharedLinkCreateTypeSerializer().deserialize(json)
                    return EventType.sharedLinkCreate(v)
                case "shared_link_disable":
                    let v = try TeamLog.SharedLinkDisableTypeSerializer().deserialize(json)
                    return EventType.sharedLinkDisable(v)
                case "shared_link_download":
                    let v = try TeamLog.SharedLinkDownloadTypeSerializer().deserialize(json)
                    return EventType.sharedLinkDownload(v)
                case "shared_link_remove_expiry":
                    let v = try TeamLog.SharedLinkRemoveExpiryTypeSerializer().deserialize(json)
                    return EventType.sharedLinkRemoveExpiry(v)
                case "shared_link_settings_add_expiration":
                    let v = try TeamLog.SharedLinkSettingsAddExpirationTypeSerializer().deserialize(json)
                    return EventType.sharedLinkSettingsAddExpiration(v)
                case "shared_link_settings_add_password":
                    let v = try TeamLog.SharedLinkSettingsAddPasswordTypeSerializer().deserialize(json)
                    return EventType.sharedLinkSettingsAddPassword(v)
                case "shared_link_settings_allow_download_disabled":
                    let v = try TeamLog.SharedLinkSettingsAllowDownloadDisabledTypeSerializer().deserialize(json)
                    return EventType.sharedLinkSettingsAllowDownloadDisabled(v)
                case "shared_link_settings_allow_download_enabled":
                    let v = try TeamLog.SharedLinkSettingsAllowDownloadEnabledTypeSerializer().deserialize(json)
                    return EventType.sharedLinkSettingsAllowDownloadEnabled(v)
                case "shared_link_settings_change_audience":
                    let v = try TeamLog.SharedLinkSettingsChangeAudienceTypeSerializer().deserialize(json)
                    return EventType.sharedLinkSettingsChangeAudience(v)
                case "shared_link_settings_change_expiration":
                    let v = try TeamLog.SharedLinkSettingsChangeExpirationTypeSerializer().deserialize(json)
                    return EventType.sharedLinkSettingsChangeExpiration(v)
                case "shared_link_settings_change_password":
                    let v = try TeamLog.SharedLinkSettingsChangePasswordTypeSerializer().deserialize(json)
                    return EventType.sharedLinkSettingsChangePassword(v)
                case "shared_link_settings_remove_expiration":
                    let v = try TeamLog.SharedLinkSettingsRemoveExpirationTypeSerializer().deserialize(json)
                    return EventType.sharedLinkSettingsRemoveExpiration(v)
                case "shared_link_settings_remove_password":
                    let v = try TeamLog.SharedLinkSettingsRemovePasswordTypeSerializer().deserialize(json)
                    return EventType.sharedLinkSettingsRemovePassword(v)
                case "shared_link_share":
                    let v = try TeamLog.SharedLinkShareTypeSerializer().deserialize(json)
                    return EventType.sharedLinkShare(v)
                case "shared_link_view":
                    let v = try TeamLog.SharedLinkViewTypeSerializer().deserialize(json)
                    return EventType.sharedLinkView(v)
                case "shared_note_opened":
                    let v = try TeamLog.SharedNoteOpenedTypeSerializer().deserialize(json)
                    return EventType.sharedNoteOpened(v)
                case "shmodel_disable_downloads":
                    let v = try TeamLog.ShmodelDisableDownloadsTypeSerializer().deserialize(json)
                    return EventType.shmodelDisableDownloads(v)
                case "shmodel_enable_downloads":
                    let v = try TeamLog.ShmodelEnableDownloadsTypeSerializer().deserialize(json)
                    return EventType.shmodelEnableDownloads(v)
                case "shmodel_group_share":
                    let v = try TeamLog.ShmodelGroupShareTypeSerializer().deserialize(json)
                    return EventType.shmodelGroupShare(v)
                case "showcase_access_granted":
                    let v = try TeamLog.ShowcaseAccessGrantedTypeSerializer().deserialize(json)
                    return EventType.showcaseAccessGranted(v)
                case "showcase_add_member":
                    let v = try TeamLog.ShowcaseAddMemberTypeSerializer().deserialize(json)
                    return EventType.showcaseAddMember(v)
                case "showcase_archived":
                    let v = try TeamLog.ShowcaseArchivedTypeSerializer().deserialize(json)
                    return EventType.showcaseArchived(v)
                case "showcase_created":
                    let v = try TeamLog.ShowcaseCreatedTypeSerializer().deserialize(json)
                    return EventType.showcaseCreated(v)
                case "showcase_delete_comment":
                    let v = try TeamLog.ShowcaseDeleteCommentTypeSerializer().deserialize(json)
                    return EventType.showcaseDeleteComment(v)
                case "showcase_edited":
                    let v = try TeamLog.ShowcaseEditedTypeSerializer().deserialize(json)
                    return EventType.showcaseEdited(v)
                case "showcase_edit_comment":
                    let v = try TeamLog.ShowcaseEditCommentTypeSerializer().deserialize(json)
                    return EventType.showcaseEditComment(v)
                case "showcase_file_added":
                    let v = try TeamLog.ShowcaseFileAddedTypeSerializer().deserialize(json)
                    return EventType.showcaseFileAdded(v)
                case "showcase_file_download":
                    let v = try TeamLog.ShowcaseFileDownloadTypeSerializer().deserialize(json)
                    return EventType.showcaseFileDownload(v)
                case "showcase_file_removed":
                    let v = try TeamLog.ShowcaseFileRemovedTypeSerializer().deserialize(json)
                    return EventType.showcaseFileRemoved(v)
                case "showcase_file_view":
                    let v = try TeamLog.ShowcaseFileViewTypeSerializer().deserialize(json)
                    return EventType.showcaseFileView(v)
                case "showcase_permanently_deleted":
                    let v = try TeamLog.ShowcasePermanentlyDeletedTypeSerializer().deserialize(json)
                    return EventType.showcasePermanentlyDeleted(v)
                case "showcase_post_comment":
                    let v = try TeamLog.ShowcasePostCommentTypeSerializer().deserialize(json)
                    return EventType.showcasePostComment(v)
                case "showcase_remove_member":
                    let v = try TeamLog.ShowcaseRemoveMemberTypeSerializer().deserialize(json)
                    return EventType.showcaseRemoveMember(v)
                case "showcase_renamed":
                    let v = try TeamLog.ShowcaseRenamedTypeSerializer().deserialize(json)
                    return EventType.showcaseRenamed(v)
                case "showcase_request_access":
                    let v = try TeamLog.ShowcaseRequestAccessTypeSerializer().deserialize(json)
                    return EventType.showcaseRequestAccess(v)
                case "showcase_resolve_comment":
                    let v = try TeamLog.ShowcaseResolveCommentTypeSerializer().deserialize(json)
                    return EventType.showcaseResolveComment(v)
                case "showcase_restored":
                    let v = try TeamLog.ShowcaseRestoredTypeSerializer().deserialize(json)
                    return EventType.showcaseRestored(v)
                case "showcase_trashed":
                    let v = try TeamLog.ShowcaseTrashedTypeSerializer().deserialize(json)
                    return EventType.showcaseTrashed(v)
                case "showcase_trashed_deprecated":
                    let v = try TeamLog.ShowcaseTrashedDeprecatedTypeSerializer().deserialize(json)
                    return EventType.showcaseTrashedDeprecated(v)
                case "showcase_unresolve_comment":
                    let v = try TeamLog.ShowcaseUnresolveCommentTypeSerializer().deserialize(json)
                    return EventType.showcaseUnresolveComment(v)
                case "showcase_untrashed":
                    let v = try TeamLog.ShowcaseUntrashedTypeSerializer().deserialize(json)
                    return EventType.showcaseUntrashed(v)
                case "showcase_untrashed_deprecated":
                    let v = try TeamLog.ShowcaseUntrashedDeprecatedTypeSerializer().deserialize(json)
                    return EventType.showcaseUntrashedDeprecated(v)
                case "showcase_view":
                    let v = try TeamLog.ShowcaseViewTypeSerializer().deserialize(json)
                    return EventType.showcaseView(v)
                case "sso_add_cert":
                    let v = try TeamLog.SsoAddCertTypeSerializer().deserialize(json)
                    return EventType.ssoAddCert(v)
                case "sso_add_login_url":
                    let v = try TeamLog.SsoAddLoginUrlTypeSerializer().deserialize(json)
                    return EventType.ssoAddLoginUrl(v)
                case "sso_add_logout_url":
                    let v = try TeamLog.SsoAddLogoutUrlTypeSerializer().deserialize(json)
                    return EventType.ssoAddLogoutUrl(v)
                case "sso_change_cert":
                    let v = try TeamLog.SsoChangeCertTypeSerializer().deserialize(json)
                    return EventType.ssoChangeCert(v)
                case "sso_change_login_url":
                    let v = try TeamLog.SsoChangeLoginUrlTypeSerializer().deserialize(json)
                    return EventType.ssoChangeLoginUrl(v)
                case "sso_change_logout_url":
                    let v = try TeamLog.SsoChangeLogoutUrlTypeSerializer().deserialize(json)
                    return EventType.ssoChangeLogoutUrl(v)
                case "sso_change_saml_identity_mode":
                    let v = try TeamLog.SsoChangeSamlIdentityModeTypeSerializer().deserialize(json)
                    return EventType.ssoChangeSamlIdentityMode(v)
                case "sso_remove_cert":
                    let v = try TeamLog.SsoRemoveCertTypeSerializer().deserialize(json)
                    return EventType.ssoRemoveCert(v)
                case "sso_remove_login_url":
                    let v = try TeamLog.SsoRemoveLoginUrlTypeSerializer().deserialize(json)
                    return EventType.ssoRemoveLoginUrl(v)
                case "sso_remove_logout_url":
                    let v = try TeamLog.SsoRemoveLogoutUrlTypeSerializer().deserialize(json)
                    return EventType.ssoRemoveLogoutUrl(v)
                case "team_folder_change_status":
                    let v = try TeamLog.TeamFolderChangeStatusTypeSerializer().deserialize(json)
                    return EventType.teamFolderChangeStatus(v)
                case "team_folder_create":
                    let v = try TeamLog.TeamFolderCreateTypeSerializer().deserialize(json)
                    return EventType.teamFolderCreate(v)
                case "team_folder_downgrade":
                    let v = try TeamLog.TeamFolderDowngradeTypeSerializer().deserialize(json)
                    return EventType.teamFolderDowngrade(v)
                case "team_folder_permanently_delete":
                    let v = try TeamLog.TeamFolderPermanentlyDeleteTypeSerializer().deserialize(json)
                    return EventType.teamFolderPermanentlyDelete(v)
                case "team_folder_rename":
                    let v = try TeamLog.TeamFolderRenameTypeSerializer().deserialize(json)
                    return EventType.teamFolderRename(v)
                case "team_selective_sync_settings_changed":
                    let v = try TeamLog.TeamSelectiveSyncSettingsChangedTypeSerializer().deserialize(json)
                    return EventType.teamSelectiveSyncSettingsChanged(v)
                case "account_capture_change_policy":
                    let v = try TeamLog.AccountCaptureChangePolicyTypeSerializer().deserialize(json)
                    return EventType.accountCaptureChangePolicy(v)
                case "admin_email_reminders_changed":
                    let v = try TeamLog.AdminEmailRemindersChangedTypeSerializer().deserialize(json)
                    return EventType.adminEmailRemindersChanged(v)
                case "allow_download_disabled":
                    let v = try TeamLog.AllowDownloadDisabledTypeSerializer().deserialize(json)
                    return EventType.allowDownloadDisabled(v)
                case "allow_download_enabled":
                    let v = try TeamLog.AllowDownloadEnabledTypeSerializer().deserialize(json)
                    return EventType.allowDownloadEnabled(v)
                case "app_permissions_changed":
                    let v = try TeamLog.AppPermissionsChangedTypeSerializer().deserialize(json)
                    return EventType.appPermissionsChanged(v)
                case "camera_uploads_policy_changed":
                    let v = try TeamLog.CameraUploadsPolicyChangedTypeSerializer().deserialize(json)
                    return EventType.cameraUploadsPolicyChanged(v)
                case "capture_transcript_policy_changed":
                    let v = try TeamLog.CaptureTranscriptPolicyChangedTypeSerializer().deserialize(json)
                    return EventType.captureTranscriptPolicyChanged(v)
                case "classification_change_policy":
                    let v = try TeamLog.ClassificationChangePolicyTypeSerializer().deserialize(json)
                    return EventType.classificationChangePolicy(v)
                case "computer_backup_policy_changed":
                    let v = try TeamLog.ComputerBackupPolicyChangedTypeSerializer().deserialize(json)
                    return EventType.computerBackupPolicyChanged(v)
                case "content_administration_policy_changed":
                    let v = try TeamLog.ContentAdministrationPolicyChangedTypeSerializer().deserialize(json)
                    return EventType.contentAdministrationPolicyChanged(v)
                case "data_placement_restriction_change_policy":
                    let v = try TeamLog.DataPlacementRestrictionChangePolicyTypeSerializer().deserialize(json)
                    return EventType.dataPlacementRestrictionChangePolicy(v)
                case "data_placement_restriction_satisfy_policy":
                    let v = try TeamLog.DataPlacementRestrictionSatisfyPolicyTypeSerializer().deserialize(json)
                    return EventType.dataPlacementRestrictionSatisfyPolicy(v)
                case "device_approvals_add_exception":
                    let v = try TeamLog.DeviceApprovalsAddExceptionTypeSerializer().deserialize(json)
                    return EventType.deviceApprovalsAddException(v)
                case "device_approvals_change_desktop_policy":
                    let v = try TeamLog.DeviceApprovalsChangeDesktopPolicyTypeSerializer().deserialize(json)
                    return EventType.deviceApprovalsChangeDesktopPolicy(v)
                case "device_approvals_change_mobile_policy":
                    let v = try TeamLog.DeviceApprovalsChangeMobilePolicyTypeSerializer().deserialize(json)
                    return EventType.deviceApprovalsChangeMobilePolicy(v)
                case "device_approvals_change_overage_action":
                    let v = try TeamLog.DeviceApprovalsChangeOverageActionTypeSerializer().deserialize(json)
                    return EventType.deviceApprovalsChangeOverageAction(v)
                case "device_approvals_change_unlink_action":
                    let v = try TeamLog.DeviceApprovalsChangeUnlinkActionTypeSerializer().deserialize(json)
                    return EventType.deviceApprovalsChangeUnlinkAction(v)
                case "device_approvals_remove_exception":
                    let v = try TeamLog.DeviceApprovalsRemoveExceptionTypeSerializer().deserialize(json)
                    return EventType.deviceApprovalsRemoveException(v)
                case "directory_restrictions_add_members":
                    let v = try TeamLog.DirectoryRestrictionsAddMembersTypeSerializer().deserialize(json)
                    return EventType.directoryRestrictionsAddMembers(v)
                case "directory_restrictions_remove_members":
                    let v = try TeamLog.DirectoryRestrictionsRemoveMembersTypeSerializer().deserialize(json)
                    return EventType.directoryRestrictionsRemoveMembers(v)
                case "dropbox_passwords_policy_changed":
                    let v = try TeamLog.DropboxPasswordsPolicyChangedTypeSerializer().deserialize(json)
                    return EventType.dropboxPasswordsPolicyChanged(v)
                case "email_ingest_policy_changed":
                    let v = try TeamLog.EmailIngestPolicyChangedTypeSerializer().deserialize(json)
                    return EventType.emailIngestPolicyChanged(v)
                case "emm_add_exception":
                    let v = try TeamLog.EmmAddExceptionTypeSerializer().deserialize(json)
                    return EventType.emmAddException(v)
                case "emm_change_policy":
                    let v = try TeamLog.EmmChangePolicyTypeSerializer().deserialize(json)
                    return EventType.emmChangePolicy(v)
                case "emm_remove_exception":
                    let v = try TeamLog.EmmRemoveExceptionTypeSerializer().deserialize(json)
                    return EventType.emmRemoveException(v)
                case "extended_version_history_change_policy":
                    let v = try TeamLog.ExtendedVersionHistoryChangePolicyTypeSerializer().deserialize(json)
                    return EventType.extendedVersionHistoryChangePolicy(v)
                case "external_drive_backup_policy_changed":
                    let v = try TeamLog.ExternalDriveBackupPolicyChangedTypeSerializer().deserialize(json)
                    return EventType.externalDriveBackupPolicyChanged(v)
                case "file_comments_change_policy":
                    let v = try TeamLog.FileCommentsChangePolicyTypeSerializer().deserialize(json)
                    return EventType.fileCommentsChangePolicy(v)
                case "file_locking_policy_changed":
                    let v = try TeamLog.FileLockingPolicyChangedTypeSerializer().deserialize(json)
                    return EventType.fileLockingPolicyChanged(v)
                case "file_provider_migration_policy_changed":
                    let v = try TeamLog.FileProviderMigrationPolicyChangedTypeSerializer().deserialize(json)
                    return EventType.fileProviderMigrationPolicyChanged(v)
                case "file_requests_change_policy":
                    let v = try TeamLog.FileRequestsChangePolicyTypeSerializer().deserialize(json)
                    return EventType.fileRequestsChangePolicy(v)
                case "file_requests_emails_enabled":
                    let v = try TeamLog.FileRequestsEmailsEnabledTypeSerializer().deserialize(json)
                    return EventType.fileRequestsEmailsEnabled(v)
                case "file_requests_emails_restricted_to_team_only":
                    let v = try TeamLog.FileRequestsEmailsRestrictedToTeamOnlyTypeSerializer().deserialize(json)
                    return EventType.fileRequestsEmailsRestrictedToTeamOnly(v)
                case "file_transfers_policy_changed":
                    let v = try TeamLog.FileTransfersPolicyChangedTypeSerializer().deserialize(json)
                    return EventType.fileTransfersPolicyChanged(v)
                case "folder_link_restriction_policy_changed":
                    let v = try TeamLog.FolderLinkRestrictionPolicyChangedTypeSerializer().deserialize(json)
                    return EventType.folderLinkRestrictionPolicyChanged(v)
                case "google_sso_change_policy":
                    let v = try TeamLog.GoogleSsoChangePolicyTypeSerializer().deserialize(json)
                    return EventType.googleSsoChangePolicy(v)
                case "group_user_management_change_policy":
                    let v = try TeamLog.GroupUserManagementChangePolicyTypeSerializer().deserialize(json)
                    return EventType.groupUserManagementChangePolicy(v)
                case "integration_policy_changed":
                    let v = try TeamLog.IntegrationPolicyChangedTypeSerializer().deserialize(json)
                    return EventType.integrationPolicyChanged(v)
                case "invite_acceptance_email_policy_changed":
                    let v = try TeamLog.InviteAcceptanceEmailPolicyChangedTypeSerializer().deserialize(json)
                    return EventType.inviteAcceptanceEmailPolicyChanged(v)
                case "member_requests_change_policy":
                    let v = try TeamLog.MemberRequestsChangePolicyTypeSerializer().deserialize(json)
                    return EventType.memberRequestsChangePolicy(v)
                case "member_send_invite_policy_changed":
                    let v = try TeamLog.MemberSendInvitePolicyChangedTypeSerializer().deserialize(json)
                    return EventType.memberSendInvitePolicyChanged(v)
                case "member_space_limits_add_exception":
                    let v = try TeamLog.MemberSpaceLimitsAddExceptionTypeSerializer().deserialize(json)
                    return EventType.memberSpaceLimitsAddException(v)
                case "member_space_limits_change_caps_type_policy":
                    let v = try TeamLog.MemberSpaceLimitsChangeCapsTypePolicyTypeSerializer().deserialize(json)
                    return EventType.memberSpaceLimitsChangeCapsTypePolicy(v)
                case "member_space_limits_change_policy":
                    let v = try TeamLog.MemberSpaceLimitsChangePolicyTypeSerializer().deserialize(json)
                    return EventType.memberSpaceLimitsChangePolicy(v)
                case "member_space_limits_remove_exception":
                    let v = try TeamLog.MemberSpaceLimitsRemoveExceptionTypeSerializer().deserialize(json)
                    return EventType.memberSpaceLimitsRemoveException(v)
                case "member_suggestions_change_policy":
                    let v = try TeamLog.MemberSuggestionsChangePolicyTypeSerializer().deserialize(json)
                    return EventType.memberSuggestionsChangePolicy(v)
                case "microsoft_office_addin_change_policy":
                    let v = try TeamLog.MicrosoftOfficeAddinChangePolicyTypeSerializer().deserialize(json)
                    return EventType.microsoftOfficeAddinChangePolicy(v)
                case "network_control_change_policy":
                    let v = try TeamLog.NetworkControlChangePolicyTypeSerializer().deserialize(json)
                    return EventType.networkControlChangePolicy(v)
                case "paper_change_deployment_policy":
                    let v = try TeamLog.PaperChangeDeploymentPolicyTypeSerializer().deserialize(json)
                    return EventType.paperChangeDeploymentPolicy(v)
                case "paper_change_member_link_policy":
                    let v = try TeamLog.PaperChangeMemberLinkPolicyTypeSerializer().deserialize(json)
                    return EventType.paperChangeMemberLinkPolicy(v)
                case "paper_change_member_policy":
                    let v = try TeamLog.PaperChangeMemberPolicyTypeSerializer().deserialize(json)
                    return EventType.paperChangeMemberPolicy(v)
                case "paper_change_policy":
                    let v = try TeamLog.PaperChangePolicyTypeSerializer().deserialize(json)
                    return EventType.paperChangePolicy(v)
                case "paper_default_folder_policy_changed":
                    let v = try TeamLog.PaperDefaultFolderPolicyChangedTypeSerializer().deserialize(json)
                    return EventType.paperDefaultFolderPolicyChanged(v)
                case "paper_desktop_policy_changed":
                    let v = try TeamLog.PaperDesktopPolicyChangedTypeSerializer().deserialize(json)
                    return EventType.paperDesktopPolicyChanged(v)
                case "paper_enabled_users_group_addition":
                    let v = try TeamLog.PaperEnabledUsersGroupAdditionTypeSerializer().deserialize(json)
                    return EventType.paperEnabledUsersGroupAddition(v)
                case "paper_enabled_users_group_removal":
                    let v = try TeamLog.PaperEnabledUsersGroupRemovalTypeSerializer().deserialize(json)
                    return EventType.paperEnabledUsersGroupRemoval(v)
                case "password_strength_requirements_change_policy":
                    let v = try TeamLog.PasswordStrengthRequirementsChangePolicyTypeSerializer().deserialize(json)
                    return EventType.passwordStrengthRequirementsChangePolicy(v)
                case "permanent_delete_change_policy":
                    let v = try TeamLog.PermanentDeleteChangePolicyTypeSerializer().deserialize(json)
                    return EventType.permanentDeleteChangePolicy(v)
                case "reseller_support_change_policy":
                    let v = try TeamLog.ResellerSupportChangePolicyTypeSerializer().deserialize(json)
                    return EventType.resellerSupportChangePolicy(v)
                case "rewind_policy_changed":
                    let v = try TeamLog.RewindPolicyChangedTypeSerializer().deserialize(json)
                    return EventType.rewindPolicyChanged(v)
                case "send_for_signature_policy_changed":
                    let v = try TeamLog.SendForSignaturePolicyChangedTypeSerializer().deserialize(json)
                    return EventType.sendForSignaturePolicyChanged(v)
                case "sharing_change_folder_join_policy":
                    let v = try TeamLog.SharingChangeFolderJoinPolicyTypeSerializer().deserialize(json)
                    return EventType.sharingChangeFolderJoinPolicy(v)
                case "sharing_change_link_allow_change_expiration_policy":
                    let v = try TeamLog.SharingChangeLinkAllowChangeExpirationPolicyTypeSerializer().deserialize(json)
                    return EventType.sharingChangeLinkAllowChangeExpirationPolicy(v)
                case "sharing_change_link_default_expiration_policy":
                    let v = try TeamLog.SharingChangeLinkDefaultExpirationPolicyTypeSerializer().deserialize(json)
                    return EventType.sharingChangeLinkDefaultExpirationPolicy(v)
                case "sharing_change_link_enforce_password_policy":
                    let v = try TeamLog.SharingChangeLinkEnforcePasswordPolicyTypeSerializer().deserialize(json)
                    return EventType.sharingChangeLinkEnforcePasswordPolicy(v)
                case "sharing_change_link_policy":
                    let v = try TeamLog.SharingChangeLinkPolicyTypeSerializer().deserialize(json)
                    return EventType.sharingChangeLinkPolicy(v)
                case "sharing_change_member_policy":
                    let v = try TeamLog.SharingChangeMemberPolicyTypeSerializer().deserialize(json)
                    return EventType.sharingChangeMemberPolicy(v)
                case "showcase_change_download_policy":
                    let v = try TeamLog.ShowcaseChangeDownloadPolicyTypeSerializer().deserialize(json)
                    return EventType.showcaseChangeDownloadPolicy(v)
                case "showcase_change_enabled_policy":
                    let v = try TeamLog.ShowcaseChangeEnabledPolicyTypeSerializer().deserialize(json)
                    return EventType.showcaseChangeEnabledPolicy(v)
                case "showcase_change_external_sharing_policy":
                    let v = try TeamLog.ShowcaseChangeExternalSharingPolicyTypeSerializer().deserialize(json)
                    return EventType.showcaseChangeExternalSharingPolicy(v)
                case "smarter_smart_sync_policy_changed":
                    let v = try TeamLog.SmarterSmartSyncPolicyChangedTypeSerializer().deserialize(json)
                    return EventType.smarterSmartSyncPolicyChanged(v)
                case "smart_sync_change_policy":
                    let v = try TeamLog.SmartSyncChangePolicyTypeSerializer().deserialize(json)
                    return EventType.smartSyncChangePolicy(v)
                case "smart_sync_not_opt_out":
                    let v = try TeamLog.SmartSyncNotOptOutTypeSerializer().deserialize(json)
                    return EventType.smartSyncNotOptOut(v)
                case "smart_sync_opt_out":
                    let v = try TeamLog.SmartSyncOptOutTypeSerializer().deserialize(json)
                    return EventType.smartSyncOptOut(v)
                case "sso_change_policy":
                    let v = try TeamLog.SsoChangePolicyTypeSerializer().deserialize(json)
                    return EventType.ssoChangePolicy(v)
                case "team_branding_policy_changed":
                    let v = try TeamLog.TeamBrandingPolicyChangedTypeSerializer().deserialize(json)
                    return EventType.teamBrandingPolicyChanged(v)
                case "team_extensions_policy_changed":
                    let v = try TeamLog.TeamExtensionsPolicyChangedTypeSerializer().deserialize(json)
                    return EventType.teamExtensionsPolicyChanged(v)
                case "team_selective_sync_policy_changed":
                    let v = try TeamLog.TeamSelectiveSyncPolicyChangedTypeSerializer().deserialize(json)
                    return EventType.teamSelectiveSyncPolicyChanged(v)
                case "team_sharing_whitelist_subjects_changed":
                    let v = try TeamLog.TeamSharingWhitelistSubjectsChangedTypeSerializer().deserialize(json)
                    return EventType.teamSharingWhitelistSubjectsChanged(v)
                case "tfa_add_exception":
                    let v = try TeamLog.TfaAddExceptionTypeSerializer().deserialize(json)
                    return EventType.tfaAddException(v)
                case "tfa_change_policy":
                    let v = try TeamLog.TfaChangePolicyTypeSerializer().deserialize(json)
                    return EventType.tfaChangePolicy(v)
                case "tfa_remove_exception":
                    let v = try TeamLog.TfaRemoveExceptionTypeSerializer().deserialize(json)
                    return EventType.tfaRemoveException(v)
                case "two_account_change_policy":
                    let v = try TeamLog.TwoAccountChangePolicyTypeSerializer().deserialize(json)
                    return EventType.twoAccountChangePolicy(v)
                case "viewer_info_policy_changed":
                    let v = try TeamLog.ViewerInfoPolicyChangedTypeSerializer().deserialize(json)
                    return EventType.viewerInfoPolicyChanged(v)
                case "watermarking_policy_changed":
                    let v = try TeamLog.WatermarkingPolicyChangedTypeSerializer().deserialize(json)
                    return EventType.watermarkingPolicyChanged(v)
                case "web_sessions_change_active_session_limit":
                    let v = try TeamLog.WebSessionsChangeActiveSessionLimitTypeSerializer().deserialize(json)
                    return EventType.webSessionsChangeActiveSessionLimit(v)
                case "web_sessions_change_fixed_length_policy":
                    let v = try TeamLog.WebSessionsChangeFixedLengthPolicyTypeSerializer().deserialize(json)
                    return EventType.webSessionsChangeFixedLengthPolicy(v)
                case "web_sessions_change_idle_length_policy":
                    let v = try TeamLog.WebSessionsChangeIdleLengthPolicyTypeSerializer().deserialize(json)
                    return EventType.webSessionsChangeIdleLengthPolicy(v)
                case "data_residency_migration_request_successful":
                    let v = try TeamLog.DataResidencyMigrationRequestSuccessfulTypeSerializer().deserialize(json)
                    return EventType.dataResidencyMigrationRequestSuccessful(v)
                case "data_residency_migration_request_unsuccessful":
                    let v = try TeamLog.DataResidencyMigrationRequestUnsuccessfulTypeSerializer().deserialize(json)
                    return EventType.dataResidencyMigrationRequestUnsuccessful(v)
                case "team_merge_from":
                    let v = try TeamLog.TeamMergeFromTypeSerializer().deserialize(json)
                    return EventType.teamMergeFrom(v)
                case "team_merge_to":
                    let v = try TeamLog.TeamMergeToTypeSerializer().deserialize(json)
                    return EventType.teamMergeTo(v)
                case "team_profile_add_background":
                    let v = try TeamLog.TeamProfileAddBackgroundTypeSerializer().deserialize(json)
                    return EventType.teamProfileAddBackground(v)
                case "team_profile_add_logo":
                    let v = try TeamLog.TeamProfileAddLogoTypeSerializer().deserialize(json)
                    return EventType.teamProfileAddLogo(v)
                case "team_profile_change_background":
                    let v = try TeamLog.TeamProfileChangeBackgroundTypeSerializer().deserialize(json)
                    return EventType.teamProfileChangeBackground(v)
                case "team_profile_change_default_language":
                    let v = try TeamLog.TeamProfileChangeDefaultLanguageTypeSerializer().deserialize(json)
                    return EventType.teamProfileChangeDefaultLanguage(v)
                case "team_profile_change_logo":
                    let v = try TeamLog.TeamProfileChangeLogoTypeSerializer().deserialize(json)
                    return EventType.teamProfileChangeLogo(v)
                case "team_profile_change_name":
                    let v = try TeamLog.TeamProfileChangeNameTypeSerializer().deserialize(json)
                    return EventType.teamProfileChangeName(v)
                case "team_profile_remove_background":
                    let v = try TeamLog.TeamProfileRemoveBackgroundTypeSerializer().deserialize(json)
                    return EventType.teamProfileRemoveBackground(v)
                case "team_profile_remove_logo":
                    let v = try TeamLog.TeamProfileRemoveLogoTypeSerializer().deserialize(json)
                    return EventType.teamProfileRemoveLogo(v)
                case "tfa_add_backup_phone":
                    let v = try TeamLog.TfaAddBackupPhoneTypeSerializer().deserialize(json)
                    return EventType.tfaAddBackupPhone(v)
                case "tfa_add_security_key":
                    let v = try TeamLog.TfaAddSecurityKeyTypeSerializer().deserialize(json)
                    return EventType.tfaAddSecurityKey(v)
                case "tfa_change_backup_phone":
                    let v = try TeamLog.TfaChangeBackupPhoneTypeSerializer().deserialize(json)
                    return EventType.tfaChangeBackupPhone(v)
                case "tfa_change_status":
                    let v = try TeamLog.TfaChangeStatusTypeSerializer().deserialize(json)
                    return EventType.tfaChangeStatus(v)
                case "tfa_remove_backup_phone":
                    let v = try TeamLog.TfaRemoveBackupPhoneTypeSerializer().deserialize(json)
                    return EventType.tfaRemoveBackupPhone(v)
                case "tfa_remove_security_key":
                    let v = try TeamLog.TfaRemoveSecurityKeyTypeSerializer().deserialize(json)
                    return EventType.tfaRemoveSecurityKey(v)
                case "tfa_reset":
                    let v = try TeamLog.TfaResetTypeSerializer().deserialize(json)
                    return EventType.tfaReset(v)
                case "changed_enterprise_admin_role":
                    let v = try TeamLog.ChangedEnterpriseAdminRoleTypeSerializer().deserialize(json)
                    return EventType.changedEnterpriseAdminRole(v)
                case "changed_enterprise_connected_team_status":
                    let v = try TeamLog.ChangedEnterpriseConnectedTeamStatusTypeSerializer().deserialize(json)
                    return EventType.changedEnterpriseConnectedTeamStatus(v)
                case "ended_enterprise_admin_session":
                    let v = try TeamLog.EndedEnterpriseAdminSessionTypeSerializer().deserialize(json)
                    return EventType.endedEnterpriseAdminSession(v)
                case "ended_enterprise_admin_session_deprecated":
                    let v = try TeamLog.EndedEnterpriseAdminSessionDeprecatedTypeSerializer().deserialize(json)
                    return EventType.endedEnterpriseAdminSessionDeprecated(v)
                case "enterprise_settings_locking":
                    let v = try TeamLog.EnterpriseSettingsLockingTypeSerializer().deserialize(json)
                    return EventType.enterpriseSettingsLocking(v)
                case "guest_admin_change_status":
                    let v = try TeamLog.GuestAdminChangeStatusTypeSerializer().deserialize(json)
                    return EventType.guestAdminChangeStatus(v)
                case "started_enterprise_admin_session":
                    let v = try TeamLog.StartedEnterpriseAdminSessionTypeSerializer().deserialize(json)
                    return EventType.startedEnterpriseAdminSession(v)
                case "team_merge_request_accepted":
                    let v = try TeamLog.TeamMergeRequestAcceptedTypeSerializer().deserialize(json)
                    return EventType.teamMergeRequestAccepted(v)
                case "team_merge_request_accepted_shown_to_primary_team":
                    let v = try TeamLog.TeamMergeRequestAcceptedShownToPrimaryTeamTypeSerializer().deserialize(json)
                    return EventType.teamMergeRequestAcceptedShownToPrimaryTeam(v)
                case "team_merge_request_accepted_shown_to_secondary_team":
                    let v = try TeamLog.TeamMergeRequestAcceptedShownToSecondaryTeamTypeSerializer().deserialize(json)
                    return EventType.teamMergeRequestAcceptedShownToSecondaryTeam(v)
                case "team_merge_request_auto_canceled":
                    let v = try TeamLog.TeamMergeRequestAutoCanceledTypeSerializer().deserialize(json)
                    return EventType.teamMergeRequestAutoCanceled(v)
                case "team_merge_request_canceled":
                    let v = try TeamLog.TeamMergeRequestCanceledTypeSerializer().deserialize(json)
                    return EventType.teamMergeRequestCanceled(v)
                case "team_merge_request_canceled_shown_to_primary_team":
                    let v = try TeamLog.TeamMergeRequestCanceledShownToPrimaryTeamTypeSerializer().deserialize(json)
                    return EventType.teamMergeRequestCanceledShownToPrimaryTeam(v)
                case "team_merge_request_canceled_shown_to_secondary_team":
                    let v = try TeamLog.TeamMergeRequestCanceledShownToSecondaryTeamTypeSerializer().deserialize(json)
                    return EventType.teamMergeRequestCanceledShownToSecondaryTeam(v)
                case "team_merge_request_expired":
                    let v = try TeamLog.TeamMergeRequestExpiredTypeSerializer().deserialize(json)
                    return EventType.teamMergeRequestExpired(v)
                case "team_merge_request_expired_shown_to_primary_team":
                    let v = try TeamLog.TeamMergeRequestExpiredShownToPrimaryTeamTypeSerializer().deserialize(json)
                    return EventType.teamMergeRequestExpiredShownToPrimaryTeam(v)
                case "team_merge_request_expired_shown_to_secondary_team":
                    let v = try TeamLog.TeamMergeRequestExpiredShownToSecondaryTeamTypeSerializer().deserialize(json)
                    return EventType.teamMergeRequestExpiredShownToSecondaryTeam(v)
                case "team_merge_request_rejected_shown_to_primary_team":
                    let v = try TeamLog.TeamMergeRequestRejectedShownToPrimaryTeamTypeSerializer().deserialize(json)
                    return EventType.teamMergeRequestRejectedShownToPrimaryTeam(v)
                case "team_merge_request_rejected_shown_to_secondary_team":
                    let v = try TeamLog.TeamMergeRequestRejectedShownToSecondaryTeamTypeSerializer().deserialize(json)
                    return EventType.teamMergeRequestRejectedShownToSecondaryTeam(v)
                case "team_merge_request_reminder":
                    let v = try TeamLog.TeamMergeRequestReminderTypeSerializer().deserialize(json)
                    return EventType.teamMergeRequestReminder(v)
                case "team_merge_request_reminder_shown_to_primary_team":
                    let v = try TeamLog.TeamMergeRequestReminderShownToPrimaryTeamTypeSerializer().deserialize(json)
                    return EventType.teamMergeRequestReminderShownToPrimaryTeam(v)
                case "team_merge_request_reminder_shown_to_secondary_team":
                    let v = try TeamLog.TeamMergeRequestReminderShownToSecondaryTeamTypeSerializer().deserialize(json)
                    return EventType.teamMergeRequestReminderShownToSecondaryTeam(v)
                case "team_merge_request_revoked":
                    let v = try TeamLog.TeamMergeRequestRevokedTypeSerializer().deserialize(json)
                    return EventType.teamMergeRequestRevoked(v)
                case "team_merge_request_sent_shown_to_primary_team":
                    let v = try TeamLog.TeamMergeRequestSentShownToPrimaryTeamTypeSerializer().deserialize(json)
                    return EventType.teamMergeRequestSentShownToPrimaryTeam(v)
                case "team_merge_request_sent_shown_to_secondary_team":
                    let v = try TeamLog.TeamMergeRequestSentShownToSecondaryTeamTypeSerializer().deserialize(json)
                    return EventType.teamMergeRequestSentShownToSecondaryTeam(v)
                case "other":
                    return EventType.other
                default:
                    return EventType.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: EventType.self, json: json)
            }
        }
    }

    /// The type of the event.
    public enum EventTypeArg: CustomStringConvertible, JSONRepresentable {
        /// (admin_alerting) Changed an alert state
        case adminAlertingAlertStateChanged
        /// (admin_alerting) Changed an alert setting
        case adminAlertingChangedAlertConfig
        /// (admin_alerting) Triggered security alert
        case adminAlertingTriggeredAlert
        /// (admin_alerting) Completed ransomware restore process
        case ransomwareRestoreProcessCompleted
        /// (admin_alerting) Started ransomware restore process
        case ransomwareRestoreProcessStarted
        /// (apps) Failed to connect app for member
        case appBlockedByPermissions
        /// (apps) Linked app for team
        case appLinkTeam
        /// (apps) Linked app for member
        case appLinkUser
        /// (apps) Unlinked app for team
        case appUnlinkTeam
        /// (apps) Unlinked app for member
        case appUnlinkUser
        /// (apps) Connected integration for member
        case integrationConnected
        /// (apps) Disconnected integration for member
        case integrationDisconnected
        /// (comments) Added file comment
        case fileAddComment
        /// (comments) Subscribed to or unsubscribed from comment notifications for file
        case fileChangeCommentSubscription
        /// (comments) Deleted file comment
        case fileDeleteComment
        /// (comments) Edited file comment
        case fileEditComment
        /// (comments) Liked file comment (deprecated, no longer logged)
        case fileLikeComment
        /// (comments) Resolved file comment
        case fileResolveComment
        /// (comments) Unliked file comment (deprecated, no longer logged)
        case fileUnlikeComment
        /// (comments) Unresolved file comment
        case fileUnresolveComment
        /// (data_governance) Added folders to policy
        case governancePolicyAddFolders
        /// (data_governance) Couldn't add a folder to a policy
        case governancePolicyAddFolderFailed
        /// (data_governance) Content disposed
        case governancePolicyContentDisposed
        /// (data_governance) Activated a new policy
        case governancePolicyCreate
        /// (data_governance) Deleted a policy
        case governancePolicyDelete
        /// (data_governance) Edited policy
        case governancePolicyEditDetails
        /// (data_governance) Changed policy duration
        case governancePolicyEditDuration
        /// (data_governance) Created a policy download
        case governancePolicyExportCreated
        /// (data_governance) Removed a policy download
        case governancePolicyExportRemoved
        /// (data_governance) Removed folders from policy
        case governancePolicyRemoveFolders
        /// (data_governance) Created a summary report for a policy
        case governancePolicyReportCreated
        /// (data_governance) Downloaded content from a policy
        case governancePolicyZipPartDownloaded
        /// (data_governance) Activated a hold
        case legalHoldsActivateAHold
        /// (data_governance) Added members to a hold
        case legalHoldsAddMembers
        /// (data_governance) Edited details for a hold
        case legalHoldsChangeHoldDetails
        /// (data_governance) Renamed a hold
        case legalHoldsChangeHoldName
        /// (data_governance) Exported hold
        case legalHoldsExportAHold
        /// (data_governance) Canceled export for a hold
        case legalHoldsExportCancelled
        /// (data_governance) Downloaded export for a hold
        case legalHoldsExportDownloaded
        /// (data_governance) Removed export for a hold
        case legalHoldsExportRemoved
        /// (data_governance) Released a hold
        case legalHoldsReleaseAHold
        /// (data_governance) Removed members from a hold
        case legalHoldsRemoveMembers
        /// (data_governance) Created a summary report for a hold
        case legalHoldsReportAHold
        /// (devices) Changed IP address associated with active desktop session
        case deviceChangeIpDesktop
        /// (devices) Changed IP address associated with active mobile session
        case deviceChangeIpMobile
        /// (devices) Changed IP address associated with active web session
        case deviceChangeIpWeb
        /// (devices) Failed to delete all files from unlinked device
        case deviceDeleteOnUnlinkFail
        /// (devices) Deleted all files from unlinked device
        case deviceDeleteOnUnlinkSuccess
        /// (devices) Failed to link device
        case deviceLinkFail
        /// (devices) Linked device
        case deviceLinkSuccess
        /// (devices) Disabled device management (deprecated, no longer logged)
        case deviceManagementDisabled
        /// (devices) Enabled device management (deprecated, no longer logged)
        case deviceManagementEnabled
        /// (devices) Enabled/disabled backup for computer
        case deviceSyncBackupStatusChanged
        /// (devices) Disconnected device
        case deviceUnlink
        /// (devices) Exported passwords
        case dropboxPasswordsExported
        /// (devices) Enrolled new Dropbox Passwords device
        case dropboxPasswordsNewDeviceEnrolled
        /// (devices) Refreshed auth token used for setting up EMM
        case emmRefreshAuthToken
        /// (devices) Checked external drive backup eligibility status
        case externalDriveBackupEligibilityStatusChecked
        /// (devices) Modified external drive backup
        case externalDriveBackupStatusChanged
        /// (domains) Granted/revoked option to enable account capture on team domains
        case accountCaptureChangeAvailability
        /// (domains) Account-captured user migrated account to team
        case accountCaptureMigrateAccount
        /// (domains) Sent account capture email to all unmanaged members
        case accountCaptureNotificationEmailsSent
        /// (domains) Account-captured user changed account email to personal email
        case accountCaptureRelinquishAccount
        /// (domains) Disabled domain invites (deprecated, no longer logged)
        case disabledDomainInvites
        /// (domains) Approved user's request to join team
        case domainInvitesApproveRequestToJoinTeam
        /// (domains) Declined user's request to join team
        case domainInvitesDeclineRequestToJoinTeam
        /// (domains) Sent domain invites to existing domain accounts (deprecated, no longer logged)
        case domainInvitesEmailExistingUsers
        /// (domains) Requested to join team
        case domainInvitesRequestToJoinTeam
        /// (domains) Disabled "Automatically invite new users" (deprecated, no longer logged)
        case domainInvitesSetInviteNewUserPrefToNo
        /// (domains) Enabled "Automatically invite new users" (deprecated, no longer logged)
        case domainInvitesSetInviteNewUserPrefToYes
        /// (domains) Failed to verify team domain
        case domainVerificationAddDomainFail
        /// (domains) Verified team domain
        case domainVerificationAddDomainSuccess
        /// (domains) Removed domain from list of verified team domains
        case domainVerificationRemoveDomain
        /// (domains) Enabled domain invites (deprecated, no longer logged)
        case enabledDomainInvites
        /// (encryption) Canceled team encryption key deletion
        case teamEncryptionKeyCancelKeyDeletion
        /// (encryption) Created team encryption key
        case teamEncryptionKeyCreateKey
        /// (encryption) Deleted team encryption key
        case teamEncryptionKeyDeleteKey
        /// (encryption) Disabled team encryption key
        case teamEncryptionKeyDisableKey
        /// (encryption) Enabled team encryption key
        case teamEncryptionKeyEnableKey
        /// (encryption) Rotated team encryption key (deprecated, no longer logged)
        case teamEncryptionKeyRotateKey
        /// (encryption) Scheduled encryption key deletion
        case teamEncryptionKeyScheduleKeyDeletion
        /// (file_operations) Applied naming convention
        case applyNamingConvention
        /// (file_operations) Created folders (deprecated, no longer logged)
        case createFolder
        /// (file_operations) Added files and/or folders
        case fileAdd
        /// (file_operations) Added files and/or folders from automation
        case fileAddFromAutomation
        /// (file_operations) Copied files and/or folders
        case fileCopy
        /// (file_operations) Deleted files and/or folders
        case fileDelete
        /// (file_operations) Downloaded files and/or folders
        case fileDownload
        /// (file_operations) Edited files
        case fileEdit
        /// (file_operations) Created copy reference to file/folder
        case fileGetCopyReference
        /// (file_operations) Locked/unlocked editing for a file
        case fileLockingLockStatusChanged
        /// (file_operations) Moved files and/or folders
        case fileMove
        /// (file_operations) Permanently deleted files and/or folders
        case filePermanentlyDelete
        /// (file_operations) Previewed files and/or folders
        case filePreview
        /// (file_operations) Renamed files and/or folders
        case fileRename
        /// (file_operations) Restored deleted files and/or folders
        case fileRestore
        /// (file_operations) Reverted files to previous version
        case fileRevert
        /// (file_operations) Rolled back file actions
        case fileRollbackChanges
        /// (file_operations) Saved file/folder using copy reference
        case fileSaveCopyReference
        /// (file_operations) Updated folder overview
        case folderOverviewDescriptionChanged
        /// (file_operations) Pinned item to folder overview
        case folderOverviewItemPinned
        /// (file_operations) Unpinned item from folder overview
        case folderOverviewItemUnpinned
        /// (file_operations) Added a label
        case objectLabelAdded
        /// (file_operations) Removed a label
        case objectLabelRemoved
        /// (file_operations) Updated a label's value
        case objectLabelUpdatedValue
        /// (file_operations) Organized a folder with multi-file organize
        case organizeFolderWithTidy
        /// (file_operations) Deleted files in Replay
        case replayFileDelete
        /// (file_operations) Rewound a folder
        case rewindFolder
        /// (file_operations) Reverted naming convention
        case undoNamingConvention
        /// (file_operations) Removed multi-file organize
        case undoOrganizeFolderWithTidy
        /// (file_operations) Tagged a file
        case userTagsAdded
        /// (file_operations) Removed tags
        case userTagsRemoved
        /// (file_requests) Received files via Email to Dropbox
        case emailIngestReceiveFile
        /// (file_requests) Changed file request
        case fileRequestChange
        /// (file_requests) Closed file request
        case fileRequestClose
        /// (file_requests) Created file request
        case fileRequestCreate
        /// (file_requests) Delete file request
        case fileRequestDelete
        /// (file_requests) Received files for file request
        case fileRequestReceiveFile
        /// (groups) Added external ID for group
        case groupAddExternalId
        /// (groups) Added team members to group
        case groupAddMember
        /// (groups) Changed external ID for group
        case groupChangeExternalId
        /// (groups) Changed group management type
        case groupChangeManagementType
        /// (groups) Changed manager permissions of group member
        case groupChangeMemberRole
        /// (groups) Created group
        case groupCreate
        /// (groups) Deleted group
        case groupDelete
        /// (groups) Updated group (deprecated, no longer logged)
        case groupDescriptionUpdated
        /// (groups) Updated group join policy (deprecated, no longer logged)
        case groupJoinPolicyUpdated
        /// (groups) Moved group (deprecated, no longer logged)
        case groupMoved
        /// (groups) Removed external ID for group
        case groupRemoveExternalId
        /// (groups) Removed team members from group
        case groupRemoveMember
        /// (groups) Renamed group
        case groupRename
        /// (logins) Unlocked/locked account after failed sign in attempts
        case accountLockOrUnlocked
        /// (logins) Failed to sign in via EMM (deprecated, replaced by 'Failed to sign in')
        case emmError
        /// (logins) Started trusted team admin session
        case guestAdminSignedInViaTrustedTeams
        /// (logins) Ended trusted team admin session
        case guestAdminSignedOutViaTrustedTeams
        /// (logins) Failed to sign in
        case loginFail
        /// (logins) Signed in
        case loginSuccess
        /// (logins) Signed out
        case logout
        /// (logins) Ended reseller support session
        case resellerSupportSessionEnd
        /// (logins) Started reseller support session
        case resellerSupportSessionStart
        /// (logins) Ended admin sign-in-as session
        case signInAsSessionEnd
        /// (logins) Started admin sign-in-as session
        case signInAsSessionStart
        /// (logins) Failed to sign in via SSO (deprecated, replaced by 'Failed to sign in')
        case ssoError
        /// (members) Invited members to activate Backup
        case backupAdminInvitationSent
        /// (members) Opened Backup invite
        case backupInvitationOpened
        /// (members) Created team invite link
        case createTeamInviteLink
        /// (members) Deleted team invite link
        case deleteTeamInviteLink
        /// (members) Added an external ID for team member
        case memberAddExternalId
        /// (members) Added team member name
        case memberAddName
        /// (members) Changed team member admin role
        case memberChangeAdminRole
        /// (members) Changed team member email
        case memberChangeEmail
        /// (members) Changed the external ID for team member
        case memberChangeExternalId
        /// (members) Changed membership type (limited/full) of member (deprecated, no longer logged)
        case memberChangeMembershipType
        /// (members) Changed team member name
        case memberChangeName
        /// (members) Changed team member reseller role
        case memberChangeResellerRole
        /// (members) Changed member status (invited, joined, suspended, etc.)
        case memberChangeStatus
        /// (members) Cleared manually added contacts
        case memberDeleteManualContacts
        /// (members) Deleted team member profile photo
        case memberDeleteProfilePhoto
        /// (members) Permanently deleted contents of deleted team member account
        case memberPermanentlyDeleteAccountContents
        /// (members) Removed the external ID for team member
        case memberRemoveExternalId
        /// (members) Set team member profile photo
        case memberSetProfilePhoto
        /// (members) Set custom member space limit
        case memberSpaceLimitsAddCustomQuota
        /// (members) Changed custom member space limit
        case memberSpaceLimitsChangeCustomQuota
        /// (members) Changed space limit status
        case memberSpaceLimitsChangeStatus
        /// (members) Removed custom member space limit
        case memberSpaceLimitsRemoveCustomQuota
        /// (members) Suggested person to add to team
        case memberSuggest
        /// (members) Transferred contents of deleted member account to another member
        case memberTransferAccountContents
        /// (members) Added pending secondary email
        case pendingSecondaryEmailAdded
        /// (members) Deleted secondary email
        case secondaryEmailDeleted
        /// (members) Verified secondary email
        case secondaryEmailVerified
        /// (members) Secondary mails policy changed
        case secondaryMailsPolicyChanged
        /// (paper) Added Binder page (deprecated, replaced by 'Edited files')
        case binderAddPage
        /// (paper) Added Binder section (deprecated, replaced by 'Edited files')
        case binderAddSection
        /// (paper) Removed Binder page (deprecated, replaced by 'Edited files')
        case binderRemovePage
        /// (paper) Removed Binder section (deprecated, replaced by 'Edited files')
        case binderRemoveSection
        /// (paper) Renamed Binder page (deprecated, replaced by 'Edited files')
        case binderRenamePage
        /// (paper) Renamed Binder section (deprecated, replaced by 'Edited files')
        case binderRenameSection
        /// (paper) Reordered Binder page (deprecated, replaced by 'Edited files')
        case binderReorderPage
        /// (paper) Reordered Binder section (deprecated, replaced by 'Edited files')
        case binderReorderSection
        /// (paper) Added users and/or groups to Paper doc/folder
        case paperContentAddMember
        /// (paper) Added Paper doc/folder to folder
        case paperContentAddToFolder
        /// (paper) Archived Paper doc/folder
        case paperContentArchive
        /// (paper) Created Paper doc/folder
        case paperContentCreate
        /// (paper) Permanently deleted Paper doc/folder
        case paperContentPermanentlyDelete
        /// (paper) Removed Paper doc/folder from folder
        case paperContentRemoveFromFolder
        /// (paper) Removed users and/or groups from Paper doc/folder
        case paperContentRemoveMember
        /// (paper) Renamed Paper doc/folder
        case paperContentRename
        /// (paper) Restored archived Paper doc/folder
        case paperContentRestore
        /// (paper) Added Paper doc comment
        case paperDocAddComment
        /// (paper) Changed member permissions for Paper doc
        case paperDocChangeMemberRole
        /// (paper) Changed sharing setting for Paper doc
        case paperDocChangeSharingPolicy
        /// (paper) Followed/unfollowed Paper doc
        case paperDocChangeSubscription
        /// (paper) Archived Paper doc (deprecated, no longer logged)
        case paperDocDeleted
        /// (paper) Deleted Paper doc comment
        case paperDocDeleteComment
        /// (paper) Downloaded Paper doc in specific format
        case paperDocDownload
        /// (paper) Edited Paper doc
        case paperDocEdit
        /// (paper) Edited Paper doc comment
        case paperDocEditComment
        /// (paper) Followed Paper doc (deprecated, replaced by 'Followed/unfollowed Paper doc')
        case paperDocFollowed
        /// (paper) Mentioned user in Paper doc
        case paperDocMention
        /// (paper) Transferred ownership of Paper doc
        case paperDocOwnershipChanged
        /// (paper) Requested access to Paper doc
        case paperDocRequestAccess
        /// (paper) Resolved Paper doc comment
        case paperDocResolveComment
        /// (paper) Restored Paper doc to previous version
        case paperDocRevert
        /// (paper) Shared Paper doc via Slack
        case paperDocSlackShare
        /// (paper) Shared Paper doc with users and/or groups (deprecated, no longer logged)
        case paperDocTeamInvite
        /// (paper) Deleted Paper doc
        case paperDocTrashed
        /// (paper) Unresolved Paper doc comment
        case paperDocUnresolveComment
        /// (paper) Restored Paper doc
        case paperDocUntrashed
        /// (paper) Viewed Paper doc
        case paperDocView
        /// (paper) Changed Paper external sharing setting to anyone (deprecated, no longer logged)
        case paperExternalViewAllow
        /// (paper) Changed Paper external sharing setting to default team (deprecated, no longer logged)
        case paperExternalViewDefaultTeam
        /// (paper) Changed Paper external sharing setting to team-only (deprecated, no longer logged)
        case paperExternalViewForbid
        /// (paper) Followed/unfollowed Paper folder
        case paperFolderChangeSubscription
        /// (paper) Archived Paper folder (deprecated, no longer logged)
        case paperFolderDeleted
        /// (paper) Followed Paper folder (deprecated, replaced by 'Followed/unfollowed Paper folder')
        case paperFolderFollowed
        /// (paper) Shared Paper folder with users and/or groups (deprecated, no longer logged)
        case paperFolderTeamInvite
        /// (paper) Changed permissions for published doc
        case paperPublishedLinkChangePermission
        /// (paper) Published doc
        case paperPublishedLinkCreate
        /// (paper) Unpublished doc
        case paperPublishedLinkDisabled
        /// (paper) Viewed published doc
        case paperPublishedLinkView
        /// (passwords) Changed password
        case passwordChange
        /// (passwords) Reset password
        case passwordReset
        /// (passwords) Reset all team member passwords
        case passwordResetAll
        /// (reports) Created Classification report
        case classificationCreateReport
        /// (reports) Couldn't create Classification report
        case classificationCreateReportFail
        /// (reports) Created EMM-excluded users report
        case emmCreateExceptionsReport
        /// (reports) Created EMM mobile app usage report
        case emmCreateUsageReport
        /// (reports) Created member data report
        case exportMembersReport
        /// (reports) Failed to create members data report
        case exportMembersReportFail
        /// (reports) Created External sharing report
        case externalSharingCreateReport
        /// (reports) Couldn't create External sharing report
        case externalSharingReportFailed
        /// (reports) Report created: Links created with no expiration
        case noExpirationLinkGenCreateReport
        /// (reports) Couldn't create report: Links created with no expiration
        case noExpirationLinkGenReportFailed
        /// (reports) Report created: Links created without passwords
        case noPasswordLinkGenCreateReport
        /// (reports) Couldn't create report: Links created without passwords
        case noPasswordLinkGenReportFailed
        /// (reports) Report created: Views of links without passwords
        case noPasswordLinkViewCreateReport
        /// (reports) Couldn't create report: Views of links without passwords
        case noPasswordLinkViewReportFailed
        /// (reports) Report created: Views of old links
        case outdatedLinkViewCreateReport
        /// (reports) Couldn't create report: Views of old links
        case outdatedLinkViewReportFailed
        /// (reports) Exported all team Paper docs
        case paperAdminExportStart
        /// (reports) Created ransomware report
        case ransomwareAlertCreateReport
        /// (reports) Couldn't generate ransomware report
        case ransomwareAlertCreateReportFailed
        /// (reports) Created Smart Sync non-admin devices report
        case smartSyncCreateAdminPrivilegeReport
        /// (reports) Created team activity report
        case teamActivityCreateReport
        /// (reports) Couldn't generate team activity report
        case teamActivityCreateReportFail
        /// (sharing) Shared album
        case collectionShare
        /// (sharing) Transfer files added
        case fileTransfersFileAdd
        /// (sharing) Deleted transfer
        case fileTransfersTransferDelete
        /// (sharing) Transfer downloaded
        case fileTransfersTransferDownload
        /// (sharing) Sent transfer
        case fileTransfersTransferSend
        /// (sharing) Viewed transfer
        case fileTransfersTransferView
        /// (sharing) Changed Paper doc to invite-only (deprecated, no longer logged)
        case noteAclInviteOnly
        /// (sharing) Changed Paper doc to link-accessible (deprecated, no longer logged)
        case noteAclLink
        /// (sharing) Changed Paper doc to link-accessible for team (deprecated, no longer logged)
        case noteAclTeamLink
        /// (sharing) Shared Paper doc (deprecated, no longer logged)
        case noteShared
        /// (sharing) Shared received Paper doc (deprecated, no longer logged)
        case noteShareReceive
        /// (sharing) Opened shared Paper doc (deprecated, no longer logged)
        case openNoteShared
        /// (sharing) Created shared link in Replay
        case replayFileSharedLinkCreated
        /// (sharing) Modified shared link in Replay
        case replayFileSharedLinkModified
        /// (sharing) Added member to Replay Project
        case replayProjectTeamAdd
        /// (sharing) Removed member from Replay Project
        case replayProjectTeamDelete
        /// (sharing) Added team to shared folder (deprecated, no longer logged)
        case sfAddGroup
        /// (sharing) Allowed non-collaborators to view links to files in shared folder (deprecated, no longer logged)
        case sfAllowNonMembersToViewSharedLinks
        /// (sharing) Set team members to see warning before sharing folders outside team (deprecated, no longer logged)
        case sfExternalInviteWarn
        /// (sharing) Invited Facebook users to shared folder (deprecated, no longer logged)
        case sfFbInvite
        /// (sharing) Changed Facebook user's role in shared folder (deprecated, no longer logged)
        case sfFbInviteChangeRole
        /// (sharing) Uninvited Facebook user from shared folder (deprecated, no longer logged)
        case sfFbUninvite
        /// (sharing) Invited group to shared folder (deprecated, no longer logged)
        case sfInviteGroup
        /// (sharing) Granted access to shared folder (deprecated, no longer logged)
        case sfTeamGrantAccess
        /// (sharing) Invited team members to shared folder (deprecated, replaced by 'Invited user to Dropbox and added
        /// them to shared file/folder')
        case sfTeamInvite
        /// (sharing) Changed team member's role in shared folder (deprecated, no longer logged)
        case sfTeamInviteChangeRole
        /// (sharing) Joined team member's shared folder (deprecated, no longer logged)
        case sfTeamJoin
        /// (sharing) Joined team member's shared folder from link (deprecated, no longer logged)
        case sfTeamJoinFromOobLink
        /// (sharing) Unshared folder with team member (deprecated, replaced by 'Removed invitee from shared file/folder
        /// before invite was accepted')
        case sfTeamUninvite
        /// (sharing) Invited user to Dropbox and added them to shared file/folder
        case sharedContentAddInvitees
        /// (sharing) Added expiration date to link for shared file/folder (deprecated, no longer logged)
        case sharedContentAddLinkExpiry
        /// (sharing) Added password to link for shared file/folder (deprecated, no longer logged)
        case sharedContentAddLinkPassword
        /// (sharing) Added users and/or groups to shared file/folder
        case sharedContentAddMember
        /// (sharing) Changed whether members can download shared file/folder (deprecated, no longer logged)
        case sharedContentChangeDownloadsPolicy
        /// (sharing) Changed access type of invitee to shared file/folder before invite was accepted
        case sharedContentChangeInviteeRole
        /// (sharing) Changed link audience of shared file/folder (deprecated, no longer logged)
        case sharedContentChangeLinkAudience
        /// (sharing) Changed link expiration of shared file/folder (deprecated, no longer logged)
        case sharedContentChangeLinkExpiry
        /// (sharing) Changed link password of shared file/folder (deprecated, no longer logged)
        case sharedContentChangeLinkPassword
        /// (sharing) Changed access type of shared file/folder member
        case sharedContentChangeMemberRole
        /// (sharing) Changed whether members can see who viewed shared file/folder
        case sharedContentChangeViewerInfoPolicy
        /// (sharing) Acquired membership of shared file/folder by accepting invite
        case sharedContentClaimInvitation
        /// (sharing) Copied shared file/folder to own Dropbox
        case sharedContentCopy
        /// (sharing) Downloaded shared file/folder
        case sharedContentDownload
        /// (sharing) Left shared file/folder
        case sharedContentRelinquishMembership
        /// (sharing) Removed invitee from shared file/folder before invite was accepted
        case sharedContentRemoveInvitees
        /// (sharing) Removed link expiration date of shared file/folder (deprecated, no longer logged)
        case sharedContentRemoveLinkExpiry
        /// (sharing) Removed link password of shared file/folder (deprecated, no longer logged)
        case sharedContentRemoveLinkPassword
        /// (sharing) Removed user/group from shared file/folder
        case sharedContentRemoveMember
        /// (sharing) Requested access to shared file/folder
        case sharedContentRequestAccess
        /// (sharing) Restored shared file/folder invitees
        case sharedContentRestoreInvitees
        /// (sharing) Restored users and/or groups to membership of shared file/folder
        case sharedContentRestoreMember
        /// (sharing) Unshared file/folder by clearing membership
        case sharedContentUnshare
        /// (sharing) Previewed shared file/folder
        case sharedContentView
        /// (sharing) Changed who can access shared folder via link
        case sharedFolderChangeLinkPolicy
        /// (sharing) Changed whether shared folder inherits members from parent folder
        case sharedFolderChangeMembersInheritancePolicy
        /// (sharing) Changed who can add/remove members of shared folder
        case sharedFolderChangeMembersManagementPolicy
        /// (sharing) Changed who can become member of shared folder
        case sharedFolderChangeMembersPolicy
        /// (sharing) Created shared folder
        case sharedFolderCreate
        /// (sharing) Declined team member's invite to shared folder
        case sharedFolderDeclineInvitation
        /// (sharing) Added shared folder to own Dropbox
        case sharedFolderMount
        /// (sharing) Changed parent of shared folder
        case sharedFolderNest
        /// (sharing) Transferred ownership of shared folder to another member
        case sharedFolderTransferOwnership
        /// (sharing) Deleted shared folder from Dropbox
        case sharedFolderUnmount
        /// (sharing) Added shared link expiration date
        case sharedLinkAddExpiry
        /// (sharing) Changed shared link expiration date
        case sharedLinkChangeExpiry
        /// (sharing) Changed visibility of shared link
        case sharedLinkChangeVisibility
        /// (sharing) Added file/folder to Dropbox from shared link
        case sharedLinkCopy
        /// (sharing) Created shared link
        case sharedLinkCreate
        /// (sharing) Removed shared link
        case sharedLinkDisable
        /// (sharing) Downloaded file/folder from shared link
        case sharedLinkDownload
        /// (sharing) Removed shared link expiration date
        case sharedLinkRemoveExpiry
        /// (sharing) Added an expiration date to the shared link
        case sharedLinkSettingsAddExpiration
        /// (sharing) Added a password to the shared link
        case sharedLinkSettingsAddPassword
        /// (sharing) Disabled downloads
        case sharedLinkSettingsAllowDownloadDisabled
        /// (sharing) Enabled downloads
        case sharedLinkSettingsAllowDownloadEnabled
        /// (sharing) Changed the audience of the shared link
        case sharedLinkSettingsChangeAudience
        /// (sharing) Changed the expiration date of the shared link
        case sharedLinkSettingsChangeExpiration
        /// (sharing) Changed the password of the shared link
        case sharedLinkSettingsChangePassword
        /// (sharing) Removed the expiration date from the shared link
        case sharedLinkSettingsRemoveExpiration
        /// (sharing) Removed the password from the shared link
        case sharedLinkSettingsRemovePassword
        /// (sharing) Added members as audience of shared link
        case sharedLinkShare
        /// (sharing) Opened shared link
        case sharedLinkView
        /// (sharing) Opened shared Paper doc (deprecated, no longer logged)
        case sharedNoteOpened
        /// (sharing) Disabled downloads for link (deprecated, no longer logged)
        case shmodelDisableDownloads
        /// (sharing) Enabled downloads for link (deprecated, no longer logged)
        case shmodelEnableDownloads
        /// (sharing) Shared link with group (deprecated, no longer logged)
        case shmodelGroupShare
        /// (showcase) Granted access to showcase
        case showcaseAccessGranted
        /// (showcase) Added member to showcase
        case showcaseAddMember
        /// (showcase) Archived showcase
        case showcaseArchived
        /// (showcase) Created showcase
        case showcaseCreated
        /// (showcase) Deleted showcase comment
        case showcaseDeleteComment
        /// (showcase) Edited showcase
        case showcaseEdited
        /// (showcase) Edited showcase comment
        case showcaseEditComment
        /// (showcase) Added file to showcase
        case showcaseFileAdded
        /// (showcase) Downloaded file from showcase
        case showcaseFileDownload
        /// (showcase) Removed file from showcase
        case showcaseFileRemoved
        /// (showcase) Viewed file in showcase
        case showcaseFileView
        /// (showcase) Permanently deleted showcase
        case showcasePermanentlyDeleted
        /// (showcase) Added showcase comment
        case showcasePostComment
        /// (showcase) Removed member from showcase
        case showcaseRemoveMember
        /// (showcase) Renamed showcase
        case showcaseRenamed
        /// (showcase) Requested access to showcase
        case showcaseRequestAccess
        /// (showcase) Resolved showcase comment
        case showcaseResolveComment
        /// (showcase) Unarchived showcase
        case showcaseRestored
        /// (showcase) Deleted showcase
        case showcaseTrashed
        /// (showcase) Deleted showcase (old version) (deprecated, replaced by 'Deleted showcase')
        case showcaseTrashedDeprecated
        /// (showcase) Unresolved showcase comment
        case showcaseUnresolveComment
        /// (showcase) Restored showcase
        case showcaseUntrashed
        /// (showcase) Restored showcase (old version) (deprecated, replaced by 'Restored showcase')
        case showcaseUntrashedDeprecated
        /// (showcase) Viewed showcase
        case showcaseView
        /// (sso) Added X.509 certificate for SSO
        case ssoAddCert
        /// (sso) Added sign-in URL for SSO
        case ssoAddLoginUrl
        /// (sso) Added sign-out URL for SSO
        case ssoAddLogoutUrl
        /// (sso) Changed X.509 certificate for SSO
        case ssoChangeCert
        /// (sso) Changed sign-in URL for SSO
        case ssoChangeLoginUrl
        /// (sso) Changed sign-out URL for SSO
        case ssoChangeLogoutUrl
        /// (sso) Changed SAML identity mode for SSO
        case ssoChangeSamlIdentityMode
        /// (sso) Removed X.509 certificate for SSO
        case ssoRemoveCert
        /// (sso) Removed sign-in URL for SSO
        case ssoRemoveLoginUrl
        /// (sso) Removed sign-out URL for SSO
        case ssoRemoveLogoutUrl
        /// (team_folders) Changed archival status of team folder
        case teamFolderChangeStatus
        /// (team_folders) Created team folder in active status
        case teamFolderCreate
        /// (team_folders) Downgraded team folder to regular shared folder
        case teamFolderDowngrade
        /// (team_folders) Permanently deleted archived team folder
        case teamFolderPermanentlyDelete
        /// (team_folders) Renamed active/archived team folder
        case teamFolderRename
        /// (team_folders) Changed sync default
        case teamSelectiveSyncSettingsChanged
        /// (team_policies) Changed account capture setting on team domain
        case accountCaptureChangePolicy
        /// (team_policies) Changed admin reminder settings for requests to join the team
        case adminEmailRemindersChanged
        /// (team_policies) Disabled downloads (deprecated, no longer logged)
        case allowDownloadDisabled
        /// (team_policies) Enabled downloads (deprecated, no longer logged)
        case allowDownloadEnabled
        /// (team_policies) Changed app permissions
        case appPermissionsChanged
        /// (team_policies) Changed camera uploads setting for team
        case cameraUploadsPolicyChanged
        /// (team_policies) Changed Capture transcription policy for team
        case captureTranscriptPolicyChanged
        /// (team_policies) Changed classification policy for team
        case classificationChangePolicy
        /// (team_policies) Changed computer backup policy for team
        case computerBackupPolicyChanged
        /// (team_policies) Changed content management setting
        case contentAdministrationPolicyChanged
        /// (team_policies) Set restrictions on data center locations where team data resides
        case dataPlacementRestrictionChangePolicy
        /// (team_policies) Completed restrictions on data center locations where team data resides
        case dataPlacementRestrictionSatisfyPolicy
        /// (team_policies) Added members to device approvals exception list
        case deviceApprovalsAddException
        /// (team_policies) Set/removed limit on number of computers member can link to team Dropbox account
        case deviceApprovalsChangeDesktopPolicy
        /// (team_policies) Set/removed limit on number of mobile devices member can link to team Dropbox account
        case deviceApprovalsChangeMobilePolicy
        /// (team_policies) Changed device approvals setting when member is over limit
        case deviceApprovalsChangeOverageAction
        /// (team_policies) Changed device approvals setting when member unlinks approved device
        case deviceApprovalsChangeUnlinkAction
        /// (team_policies) Removed members from device approvals exception list
        case deviceApprovalsRemoveException
        /// (team_policies) Added members to directory restrictions list
        case directoryRestrictionsAddMembers
        /// (team_policies) Removed members from directory restrictions list
        case directoryRestrictionsRemoveMembers
        /// (team_policies) Changed Dropbox Passwords policy for team
        case dropboxPasswordsPolicyChanged
        /// (team_policies) Changed email to Dropbox policy for team
        case emailIngestPolicyChanged
        /// (team_policies) Added members to EMM exception list
        case emmAddException
        /// (team_policies) Enabled/disabled enterprise mobility management for members
        case emmChangePolicy
        /// (team_policies) Removed members from EMM exception list
        case emmRemoveException
        /// (team_policies) Accepted/opted out of extended version history
        case extendedVersionHistoryChangePolicy
        /// (team_policies) Changed external drive backup policy for team
        case externalDriveBackupPolicyChanged
        /// (team_policies) Enabled/disabled commenting on team files
        case fileCommentsChangePolicy
        /// (team_policies) Changed file locking policy for team
        case fileLockingPolicyChanged
        /// (team_policies) Changed File Provider Migration policy for team
        case fileProviderMigrationPolicyChanged
        /// (team_policies) Enabled/disabled file requests
        case fileRequestsChangePolicy
        /// (team_policies) Enabled file request emails for everyone (deprecated, no longer logged)
        case fileRequestsEmailsEnabled
        /// (team_policies) Enabled file request emails for team (deprecated, no longer logged)
        case fileRequestsEmailsRestrictedToTeamOnly
        /// (team_policies) Changed file transfers policy for team
        case fileTransfersPolicyChanged
        /// (team_policies) Changed folder link restrictions policy for team
        case folderLinkRestrictionPolicyChanged
        /// (team_policies) Enabled/disabled Google single sign-on for team
        case googleSsoChangePolicy
        /// (team_policies) Changed who can create groups
        case groupUserManagementChangePolicy
        /// (team_policies) Changed integration policy for team
        case integrationPolicyChanged
        /// (team_policies) Changed invite accept email policy for team
        case inviteAcceptanceEmailPolicyChanged
        /// (team_policies) Changed whether users can find team when not invited
        case memberRequestsChangePolicy
        /// (team_policies) Changed member send invite policy for team
        case memberSendInvitePolicyChanged
        /// (team_policies) Added members to member space limit exception list
        case memberSpaceLimitsAddException
        /// (team_policies) Changed member space limit type for team
        case memberSpaceLimitsChangeCapsTypePolicy
        /// (team_policies) Changed team default member space limit
        case memberSpaceLimitsChangePolicy
        /// (team_policies) Removed members from member space limit exception list
        case memberSpaceLimitsRemoveException
        /// (team_policies) Enabled/disabled option for team members to suggest people to add to team
        case memberSuggestionsChangePolicy
        /// (team_policies) Enabled/disabled Microsoft Office add-in
        case microsoftOfficeAddinChangePolicy
        /// (team_policies) Enabled/disabled network control
        case networkControlChangePolicy
        /// (team_policies) Changed whether Dropbox Paper, when enabled, is deployed to all members or to specific
        /// members
        case paperChangeDeploymentPolicy
        /// (team_policies) Changed whether non-members can view Paper docs with link (deprecated, no longer logged)
        case paperChangeMemberLinkPolicy
        /// (team_policies) Changed whether members can share Paper docs outside team, and if docs are accessible only
        /// by team members or anyone by default
        case paperChangeMemberPolicy
        /// (team_policies) Enabled/disabled Dropbox Paper for team
        case paperChangePolicy
        /// (team_policies) Changed Paper Default Folder Policy setting for team
        case paperDefaultFolderPolicyChanged
        /// (team_policies) Enabled/disabled Paper Desktop for team
        case paperDesktopPolicyChanged
        /// (team_policies) Added users to Paper-enabled users list
        case paperEnabledUsersGroupAddition
        /// (team_policies) Removed users from Paper-enabled users list
        case paperEnabledUsersGroupRemoval
        /// (team_policies) Changed team password strength requirements
        case passwordStrengthRequirementsChangePolicy
        /// (team_policies) Enabled/disabled ability of team members to permanently delete content
        case permanentDeleteChangePolicy
        /// (team_policies) Enabled/disabled reseller support
        case resellerSupportChangePolicy
        /// (team_policies) Changed Rewind policy for team
        case rewindPolicyChanged
        /// (team_policies) Changed send for signature policy for team
        case sendForSignaturePolicyChanged
        /// (team_policies) Changed whether team members can join shared folders owned outside team
        case sharingChangeFolderJoinPolicy
        /// (team_policies) Changed the allow remove or change expiration policy for the links shared outside of the
        /// team
        case sharingChangeLinkAllowChangeExpirationPolicy
        /// (team_policies) Changed the default expiration for the links shared outside of the team
        case sharingChangeLinkDefaultExpirationPolicy
        /// (team_policies) Changed the password requirement for the links shared outside of the team
        case sharingChangeLinkEnforcePasswordPolicy
        /// (team_policies) Changed whether members can share links outside team, and if links are accessible only by
        /// team members or anyone by default
        case sharingChangeLinkPolicy
        /// (team_policies) Changed whether members can share files/folders outside team
        case sharingChangeMemberPolicy
        /// (team_policies) Enabled/disabled downloading files from Dropbox Showcase for team
        case showcaseChangeDownloadPolicy
        /// (team_policies) Enabled/disabled Dropbox Showcase for team
        case showcaseChangeEnabledPolicy
        /// (team_policies) Enabled/disabled sharing Dropbox Showcase externally for team
        case showcaseChangeExternalSharingPolicy
        /// (team_policies) Changed automatic Smart Sync setting for team
        case smarterSmartSyncPolicyChanged
        /// (team_policies) Changed default Smart Sync setting for team members
        case smartSyncChangePolicy
        /// (team_policies) Opted team into Smart Sync
        case smartSyncNotOptOut
        /// (team_policies) Opted team out of Smart Sync
        case smartSyncOptOut
        /// (team_policies) Changed single sign-on setting for team
        case ssoChangePolicy
        /// (team_policies) Changed team branding policy for team
        case teamBrandingPolicyChanged
        /// (team_policies) Changed App Integrations setting for team
        case teamExtensionsPolicyChanged
        /// (team_policies) Enabled/disabled Team Selective Sync for team
        case teamSelectiveSyncPolicyChanged
        /// (team_policies) Edited the approved list for sharing externally
        case teamSharingWhitelistSubjectsChanged
        /// (team_policies) Added members to two factor authentication exception list
        case tfaAddException
        /// (team_policies) Changed two-step verification setting for team
        case tfaChangePolicy
        /// (team_policies) Removed members from two factor authentication exception list
        case tfaRemoveException
        /// (team_policies) Enabled/disabled option for members to link personal Dropbox account and team account to
        /// same computer
        case twoAccountChangePolicy
        /// (team_policies) Changed team policy for viewer info
        case viewerInfoPolicyChanged
        /// (team_policies) Changed watermarking policy for team
        case watermarkingPolicyChanged
        /// (team_policies) Changed limit on active sessions per member
        case webSessionsChangeActiveSessionLimit
        /// (team_policies) Changed how long members can stay signed in to Dropbox.com
        case webSessionsChangeFixedLengthPolicy
        /// (team_policies) Changed how long team members can be idle while signed in to Dropbox.com
        case webSessionsChangeIdleLengthPolicy
        /// (team_profile) Requested data residency migration for team data
        case dataResidencyMigrationRequestSuccessful
        /// (team_profile) Request for data residency migration for team data has failed
        case dataResidencyMigrationRequestUnsuccessful
        /// (team_profile) Merged another team into this team
        case teamMergeFrom
        /// (team_profile) Merged this team into another team
        case teamMergeTo
        /// (team_profile) Added team background to display on shared link headers
        case teamProfileAddBackground
        /// (team_profile) Added team logo to display on shared link headers
        case teamProfileAddLogo
        /// (team_profile) Changed team background displayed on shared link headers
        case teamProfileChangeBackground
        /// (team_profile) Changed default language for team
        case teamProfileChangeDefaultLanguage
        /// (team_profile) Changed team logo displayed on shared link headers
        case teamProfileChangeLogo
        /// (team_profile) Changed team name
        case teamProfileChangeName
        /// (team_profile) Removed team background displayed on shared link headers
        case teamProfileRemoveBackground
        /// (team_profile) Removed team logo displayed on shared link headers
        case teamProfileRemoveLogo
        /// (tfa) Added backup phone for two-step verification
        case tfaAddBackupPhone
        /// (tfa) Added security key for two-step verification
        case tfaAddSecurityKey
        /// (tfa) Changed backup phone for two-step verification
        case tfaChangeBackupPhone
        /// (tfa) Enabled/disabled/changed two-step verification setting
        case tfaChangeStatus
        /// (tfa) Removed backup phone for two-step verification
        case tfaRemoveBackupPhone
        /// (tfa) Removed security key for two-step verification
        case tfaRemoveSecurityKey
        /// (tfa) Reset two-step verification for team member
        case tfaReset
        /// (trusted_teams) Changed enterprise admin role
        case changedEnterpriseAdminRole
        /// (trusted_teams) Changed enterprise-connected team status
        case changedEnterpriseConnectedTeamStatus
        /// (trusted_teams) Ended enterprise admin session
        case endedEnterpriseAdminSession
        /// (trusted_teams) Ended enterprise admin session (deprecated, replaced by 'Ended enterprise admin session')
        case endedEnterpriseAdminSessionDeprecated
        /// (trusted_teams) Changed who can update a setting
        case enterpriseSettingsLocking
        /// (trusted_teams) Changed guest team admin status
        case guestAdminChangeStatus
        /// (trusted_teams) Started enterprise admin session
        case startedEnterpriseAdminSession
        /// (trusted_teams) Accepted a team merge request
        case teamMergeRequestAccepted
        /// (trusted_teams) Accepted a team merge request (deprecated, replaced by 'Accepted a team merge request')
        case teamMergeRequestAcceptedShownToPrimaryTeam
        /// (trusted_teams) Accepted a team merge request (deprecated, replaced by 'Accepted a team merge request')
        case teamMergeRequestAcceptedShownToSecondaryTeam
        /// (trusted_teams) Automatically canceled team merge request
        case teamMergeRequestAutoCanceled
        /// (trusted_teams) Canceled a team merge request
        case teamMergeRequestCanceled
        /// (trusted_teams) Canceled a team merge request (deprecated, replaced by 'Canceled a team merge request')
        case teamMergeRequestCanceledShownToPrimaryTeam
        /// (trusted_teams) Canceled a team merge request (deprecated, replaced by 'Canceled a team merge request')
        case teamMergeRequestCanceledShownToSecondaryTeam
        /// (trusted_teams) Team merge request expired
        case teamMergeRequestExpired
        /// (trusted_teams) Team merge request expired (deprecated, replaced by 'Team merge request expired')
        case teamMergeRequestExpiredShownToPrimaryTeam
        /// (trusted_teams) Team merge request expired (deprecated, replaced by 'Team merge request expired')
        case teamMergeRequestExpiredShownToSecondaryTeam
        /// (trusted_teams) Rejected a team merge request (deprecated, no longer logged)
        case teamMergeRequestRejectedShownToPrimaryTeam
        /// (trusted_teams) Rejected a team merge request (deprecated, no longer logged)
        case teamMergeRequestRejectedShownToSecondaryTeam
        /// (trusted_teams) Sent a team merge request reminder
        case teamMergeRequestReminder
        /// (trusted_teams) Sent a team merge request reminder (deprecated, replaced by 'Sent a team merge request
        /// reminder')
        case teamMergeRequestReminderShownToPrimaryTeam
        /// (trusted_teams) Sent a team merge request reminder (deprecated, replaced by 'Sent a team merge request
        /// reminder')
        case teamMergeRequestReminderShownToSecondaryTeam
        /// (trusted_teams) Canceled the team merge
        case teamMergeRequestRevoked
        /// (trusted_teams) Requested to merge their Dropbox team into yours
        case teamMergeRequestSentShownToPrimaryTeam
        /// (trusted_teams) Requested to merge your team into another Dropbox team
        case teamMergeRequestSentShownToSecondaryTeam
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try EventTypeArgSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try EventTypeArgSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for EventTypeArg: \(error)"
            }
        }
    }

    public class EventTypeArgSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: EventTypeArg) throws -> JSON {
            switch value {
            case .adminAlertingAlertStateChanged:
                var d = [String: JSON]()
                d[".tag"] = .str("admin_alerting_alert_state_changed")
                return .dictionary(d)
            case .adminAlertingChangedAlertConfig:
                var d = [String: JSON]()
                d[".tag"] = .str("admin_alerting_changed_alert_config")
                return .dictionary(d)
            case .adminAlertingTriggeredAlert:
                var d = [String: JSON]()
                d[".tag"] = .str("admin_alerting_triggered_alert")
                return .dictionary(d)
            case .ransomwareRestoreProcessCompleted:
                var d = [String: JSON]()
                d[".tag"] = .str("ransomware_restore_process_completed")
                return .dictionary(d)
            case .ransomwareRestoreProcessStarted:
                var d = [String: JSON]()
                d[".tag"] = .str("ransomware_restore_process_started")
                return .dictionary(d)
            case .appBlockedByPermissions:
                var d = [String: JSON]()
                d[".tag"] = .str("app_blocked_by_permissions")
                return .dictionary(d)
            case .appLinkTeam:
                var d = [String: JSON]()
                d[".tag"] = .str("app_link_team")
                return .dictionary(d)
            case .appLinkUser:
                var d = [String: JSON]()
                d[".tag"] = .str("app_link_user")
                return .dictionary(d)
            case .appUnlinkTeam:
                var d = [String: JSON]()
                d[".tag"] = .str("app_unlink_team")
                return .dictionary(d)
            case .appUnlinkUser:
                var d = [String: JSON]()
                d[".tag"] = .str("app_unlink_user")
                return .dictionary(d)
            case .integrationConnected:
                var d = [String: JSON]()
                d[".tag"] = .str("integration_connected")
                return .dictionary(d)
            case .integrationDisconnected:
                var d = [String: JSON]()
                d[".tag"] = .str("integration_disconnected")
                return .dictionary(d)
            case .fileAddComment:
                var d = [String: JSON]()
                d[".tag"] = .str("file_add_comment")
                return .dictionary(d)
            case .fileChangeCommentSubscription:
                var d = [String: JSON]()
                d[".tag"] = .str("file_change_comment_subscription")
                return .dictionary(d)
            case .fileDeleteComment:
                var d = [String: JSON]()
                d[".tag"] = .str("file_delete_comment")
                return .dictionary(d)
            case .fileEditComment:
                var d = [String: JSON]()
                d[".tag"] = .str("file_edit_comment")
                return .dictionary(d)
            case .fileLikeComment:
                var d = [String: JSON]()
                d[".tag"] = .str("file_like_comment")
                return .dictionary(d)
            case .fileResolveComment:
                var d = [String: JSON]()
                d[".tag"] = .str("file_resolve_comment")
                return .dictionary(d)
            case .fileUnlikeComment:
                var d = [String: JSON]()
                d[".tag"] = .str("file_unlike_comment")
                return .dictionary(d)
            case .fileUnresolveComment:
                var d = [String: JSON]()
                d[".tag"] = .str("file_unresolve_comment")
                return .dictionary(d)
            case .governancePolicyAddFolders:
                var d = [String: JSON]()
                d[".tag"] = .str("governance_policy_add_folders")
                return .dictionary(d)
            case .governancePolicyAddFolderFailed:
                var d = [String: JSON]()
                d[".tag"] = .str("governance_policy_add_folder_failed")
                return .dictionary(d)
            case .governancePolicyContentDisposed:
                var d = [String: JSON]()
                d[".tag"] = .str("governance_policy_content_disposed")
                return .dictionary(d)
            case .governancePolicyCreate:
                var d = [String: JSON]()
                d[".tag"] = .str("governance_policy_create")
                return .dictionary(d)
            case .governancePolicyDelete:
                var d = [String: JSON]()
                d[".tag"] = .str("governance_policy_delete")
                return .dictionary(d)
            case .governancePolicyEditDetails:
                var d = [String: JSON]()
                d[".tag"] = .str("governance_policy_edit_details")
                return .dictionary(d)
            case .governancePolicyEditDuration:
                var d = [String: JSON]()
                d[".tag"] = .str("governance_policy_edit_duration")
                return .dictionary(d)
            case .governancePolicyExportCreated:
                var d = [String: JSON]()
                d[".tag"] = .str("governance_policy_export_created")
                return .dictionary(d)
            case .governancePolicyExportRemoved:
                var d = [String: JSON]()
                d[".tag"] = .str("governance_policy_export_removed")
                return .dictionary(d)
            case .governancePolicyRemoveFolders:
                var d = [String: JSON]()
                d[".tag"] = .str("governance_policy_remove_folders")
                return .dictionary(d)
            case .governancePolicyReportCreated:
                var d = [String: JSON]()
                d[".tag"] = .str("governance_policy_report_created")
                return .dictionary(d)
            case .governancePolicyZipPartDownloaded:
                var d = [String: JSON]()
                d[".tag"] = .str("governance_policy_zip_part_downloaded")
                return .dictionary(d)
            case .legalHoldsActivateAHold:
                var d = [String: JSON]()
                d[".tag"] = .str("legal_holds_activate_a_hold")
                return .dictionary(d)
            case .legalHoldsAddMembers:
                var d = [String: JSON]()
                d[".tag"] = .str("legal_holds_add_members")
                return .dictionary(d)
            case .legalHoldsChangeHoldDetails:
                var d = [String: JSON]()
                d[".tag"] = .str("legal_holds_change_hold_details")
                return .dictionary(d)
            case .legalHoldsChangeHoldName:
                var d = [String: JSON]()
                d[".tag"] = .str("legal_holds_change_hold_name")
                return .dictionary(d)
            case .legalHoldsExportAHold:
                var d = [String: JSON]()
                d[".tag"] = .str("legal_holds_export_a_hold")
                return .dictionary(d)
            case .legalHoldsExportCancelled:
                var d = [String: JSON]()
                d[".tag"] = .str("legal_holds_export_cancelled")
                return .dictionary(d)
            case .legalHoldsExportDownloaded:
                var d = [String: JSON]()
                d[".tag"] = .str("legal_holds_export_downloaded")
                return .dictionary(d)
            case .legalHoldsExportRemoved:
                var d = [String: JSON]()
                d[".tag"] = .str("legal_holds_export_removed")
                return .dictionary(d)
            case .legalHoldsReleaseAHold:
                var d = [String: JSON]()
                d[".tag"] = .str("legal_holds_release_a_hold")
                return .dictionary(d)
            case .legalHoldsRemoveMembers:
                var d = [String: JSON]()
                d[".tag"] = .str("legal_holds_remove_members")
                return .dictionary(d)
            case .legalHoldsReportAHold:
                var d = [String: JSON]()
                d[".tag"] = .str("legal_holds_report_a_hold")
                return .dictionary(d)
            case .deviceChangeIpDesktop:
                var d = [String: JSON]()
                d[".tag"] = .str("device_change_ip_desktop")
                return .dictionary(d)
            case .deviceChangeIpMobile:
                var d = [String: JSON]()
                d[".tag"] = .str("device_change_ip_mobile")
                return .dictionary(d)
            case .deviceChangeIpWeb:
                var d = [String: JSON]()
                d[".tag"] = .str("device_change_ip_web")
                return .dictionary(d)
            case .deviceDeleteOnUnlinkFail:
                var d = [String: JSON]()
                d[".tag"] = .str("device_delete_on_unlink_fail")
                return .dictionary(d)
            case .deviceDeleteOnUnlinkSuccess:
                var d = [String: JSON]()
                d[".tag"] = .str("device_delete_on_unlink_success")
                return .dictionary(d)
            case .deviceLinkFail:
                var d = [String: JSON]()
                d[".tag"] = .str("device_link_fail")
                return .dictionary(d)
            case .deviceLinkSuccess:
                var d = [String: JSON]()
                d[".tag"] = .str("device_link_success")
                return .dictionary(d)
            case .deviceManagementDisabled:
                var d = [String: JSON]()
                d[".tag"] = .str("device_management_disabled")
                return .dictionary(d)
            case .deviceManagementEnabled:
                var d = [String: JSON]()
                d[".tag"] = .str("device_management_enabled")
                return .dictionary(d)
            case .deviceSyncBackupStatusChanged:
                var d = [String: JSON]()
                d[".tag"] = .str("device_sync_backup_status_changed")
                return .dictionary(d)
            case .deviceUnlink:
                var d = [String: JSON]()
                d[".tag"] = .str("device_unlink")
                return .dictionary(d)
            case .dropboxPasswordsExported:
                var d = [String: JSON]()
                d[".tag"] = .str("dropbox_passwords_exported")
                return .dictionary(d)
            case .dropboxPasswordsNewDeviceEnrolled:
                var d = [String: JSON]()
                d[".tag"] = .str("dropbox_passwords_new_device_enrolled")
                return .dictionary(d)
            case .emmRefreshAuthToken:
                var d = [String: JSON]()
                d[".tag"] = .str("emm_refresh_auth_token")
                return .dictionary(d)
            case .externalDriveBackupEligibilityStatusChecked:
                var d = [String: JSON]()
                d[".tag"] = .str("external_drive_backup_eligibility_status_checked")
                return .dictionary(d)
            case .externalDriveBackupStatusChanged:
                var d = [String: JSON]()
                d[".tag"] = .str("external_drive_backup_status_changed")
                return .dictionary(d)
            case .accountCaptureChangeAvailability:
                var d = [String: JSON]()
                d[".tag"] = .str("account_capture_change_availability")
                return .dictionary(d)
            case .accountCaptureMigrateAccount:
                var d = [String: JSON]()
                d[".tag"] = .str("account_capture_migrate_account")
                return .dictionary(d)
            case .accountCaptureNotificationEmailsSent:
                var d = [String: JSON]()
                d[".tag"] = .str("account_capture_notification_emails_sent")
                return .dictionary(d)
            case .accountCaptureRelinquishAccount:
                var d = [String: JSON]()
                d[".tag"] = .str("account_capture_relinquish_account")
                return .dictionary(d)
            case .disabledDomainInvites:
                var d = [String: JSON]()
                d[".tag"] = .str("disabled_domain_invites")
                return .dictionary(d)
            case .domainInvitesApproveRequestToJoinTeam:
                var d = [String: JSON]()
                d[".tag"] = .str("domain_invites_approve_request_to_join_team")
                return .dictionary(d)
            case .domainInvitesDeclineRequestToJoinTeam:
                var d = [String: JSON]()
                d[".tag"] = .str("domain_invites_decline_request_to_join_team")
                return .dictionary(d)
            case .domainInvitesEmailExistingUsers:
                var d = [String: JSON]()
                d[".tag"] = .str("domain_invites_email_existing_users")
                return .dictionary(d)
            case .domainInvitesRequestToJoinTeam:
                var d = [String: JSON]()
                d[".tag"] = .str("domain_invites_request_to_join_team")
                return .dictionary(d)
            case .domainInvitesSetInviteNewUserPrefToNo:
                var d = [String: JSON]()
                d[".tag"] = .str("domain_invites_set_invite_new_user_pref_to_no")
                return .dictionary(d)
            case .domainInvitesSetInviteNewUserPrefToYes:
                var d = [String: JSON]()
                d[".tag"] = .str("domain_invites_set_invite_new_user_pref_to_yes")
                return .dictionary(d)
            case .domainVerificationAddDomainFail:
                var d = [String: JSON]()
                d[".tag"] = .str("domain_verification_add_domain_fail")
                return .dictionary(d)
            case .domainVerificationAddDomainSuccess:
                var d = [String: JSON]()
                d[".tag"] = .str("domain_verification_add_domain_success")
                return .dictionary(d)
            case .domainVerificationRemoveDomain:
                var d = [String: JSON]()
                d[".tag"] = .str("domain_verification_remove_domain")
                return .dictionary(d)
            case .enabledDomainInvites:
                var d = [String: JSON]()
                d[".tag"] = .str("enabled_domain_invites")
                return .dictionary(d)
            case .teamEncryptionKeyCancelKeyDeletion:
                var d = [String: JSON]()
                d[".tag"] = .str("team_encryption_key_cancel_key_deletion")
                return .dictionary(d)
            case .teamEncryptionKeyCreateKey:
                var d = [String: JSON]()
                d[".tag"] = .str("team_encryption_key_create_key")
                return .dictionary(d)
            case .teamEncryptionKeyDeleteKey:
                var d = [String: JSON]()
                d[".tag"] = .str("team_encryption_key_delete_key")
                return .dictionary(d)
            case .teamEncryptionKeyDisableKey:
                var d = [String: JSON]()
                d[".tag"] = .str("team_encryption_key_disable_key")
                return .dictionary(d)
            case .teamEncryptionKeyEnableKey:
                var d = [String: JSON]()
                d[".tag"] = .str("team_encryption_key_enable_key")
                return .dictionary(d)
            case .teamEncryptionKeyRotateKey:
                var d = [String: JSON]()
                d[".tag"] = .str("team_encryption_key_rotate_key")
                return .dictionary(d)
            case .teamEncryptionKeyScheduleKeyDeletion:
                var d = [String: JSON]()
                d[".tag"] = .str("team_encryption_key_schedule_key_deletion")
                return .dictionary(d)
            case .applyNamingConvention:
                var d = [String: JSON]()
                d[".tag"] = .str("apply_naming_convention")
                return .dictionary(d)
            case .createFolder:
                var d = [String: JSON]()
                d[".tag"] = .str("create_folder")
                return .dictionary(d)
            case .fileAdd:
                var d = [String: JSON]()
                d[".tag"] = .str("file_add")
                return .dictionary(d)
            case .fileAddFromAutomation:
                var d = [String: JSON]()
                d[".tag"] = .str("file_add_from_automation")
                return .dictionary(d)
            case .fileCopy:
                var d = [String: JSON]()
                d[".tag"] = .str("file_copy")
                return .dictionary(d)
            case .fileDelete:
                var d = [String: JSON]()
                d[".tag"] = .str("file_delete")
                return .dictionary(d)
            case .fileDownload:
                var d = [String: JSON]()
                d[".tag"] = .str("file_download")
                return .dictionary(d)
            case .fileEdit:
                var d = [String: JSON]()
                d[".tag"] = .str("file_edit")
                return .dictionary(d)
            case .fileGetCopyReference:
                var d = [String: JSON]()
                d[".tag"] = .str("file_get_copy_reference")
                return .dictionary(d)
            case .fileLockingLockStatusChanged:
                var d = [String: JSON]()
                d[".tag"] = .str("file_locking_lock_status_changed")
                return .dictionary(d)
            case .fileMove:
                var d = [String: JSON]()
                d[".tag"] = .str("file_move")
                return .dictionary(d)
            case .filePermanentlyDelete:
                var d = [String: JSON]()
                d[".tag"] = .str("file_permanently_delete")
                return .dictionary(d)
            case .filePreview:
                var d = [String: JSON]()
                d[".tag"] = .str("file_preview")
                return .dictionary(d)
            case .fileRename:
                var d = [String: JSON]()
                d[".tag"] = .str("file_rename")
                return .dictionary(d)
            case .fileRestore:
                var d = [String: JSON]()
                d[".tag"] = .str("file_restore")
                return .dictionary(d)
            case .fileRevert:
                var d = [String: JSON]()
                d[".tag"] = .str("file_revert")
                return .dictionary(d)
            case .fileRollbackChanges:
                var d = [String: JSON]()
                d[".tag"] = .str("file_rollback_changes")
                return .dictionary(d)
            case .fileSaveCopyReference:
                var d = [String: JSON]()
                d[".tag"] = .str("file_save_copy_reference")
                return .dictionary(d)
            case .folderOverviewDescriptionChanged:
                var d = [String: JSON]()
                d[".tag"] = .str("folder_overview_description_changed")
                return .dictionary(d)
            case .folderOverviewItemPinned:
                var d = [String: JSON]()
                d[".tag"] = .str("folder_overview_item_pinned")
                return .dictionary(d)
            case .folderOverviewItemUnpinned:
                var d = [String: JSON]()
                d[".tag"] = .str("folder_overview_item_unpinned")
                return .dictionary(d)
            case .objectLabelAdded:
                var d = [String: JSON]()
                d[".tag"] = .str("object_label_added")
                return .dictionary(d)
            case .objectLabelRemoved:
                var d = [String: JSON]()
                d[".tag"] = .str("object_label_removed")
                return .dictionary(d)
            case .objectLabelUpdatedValue:
                var d = [String: JSON]()
                d[".tag"] = .str("object_label_updated_value")
                return .dictionary(d)
            case .organizeFolderWithTidy:
                var d = [String: JSON]()
                d[".tag"] = .str("organize_folder_with_tidy")
                return .dictionary(d)
            case .replayFileDelete:
                var d = [String: JSON]()
                d[".tag"] = .str("replay_file_delete")
                return .dictionary(d)
            case .rewindFolder:
                var d = [String: JSON]()
                d[".tag"] = .str("rewind_folder")
                return .dictionary(d)
            case .undoNamingConvention:
                var d = [String: JSON]()
                d[".tag"] = .str("undo_naming_convention")
                return .dictionary(d)
            case .undoOrganizeFolderWithTidy:
                var d = [String: JSON]()
                d[".tag"] = .str("undo_organize_folder_with_tidy")
                return .dictionary(d)
            case .userTagsAdded:
                var d = [String: JSON]()
                d[".tag"] = .str("user_tags_added")
                return .dictionary(d)
            case .userTagsRemoved:
                var d = [String: JSON]()
                d[".tag"] = .str("user_tags_removed")
                return .dictionary(d)
            case .emailIngestReceiveFile:
                var d = [String: JSON]()
                d[".tag"] = .str("email_ingest_receive_file")
                return .dictionary(d)
            case .fileRequestChange:
                var d = [String: JSON]()
                d[".tag"] = .str("file_request_change")
                return .dictionary(d)
            case .fileRequestClose:
                var d = [String: JSON]()
                d[".tag"] = .str("file_request_close")
                return .dictionary(d)
            case .fileRequestCreate:
                var d = [String: JSON]()
                d[".tag"] = .str("file_request_create")
                return .dictionary(d)
            case .fileRequestDelete:
                var d = [String: JSON]()
                d[".tag"] = .str("file_request_delete")
                return .dictionary(d)
            case .fileRequestReceiveFile:
                var d = [String: JSON]()
                d[".tag"] = .str("file_request_receive_file")
                return .dictionary(d)
            case .groupAddExternalId:
                var d = [String: JSON]()
                d[".tag"] = .str("group_add_external_id")
                return .dictionary(d)
            case .groupAddMember:
                var d = [String: JSON]()
                d[".tag"] = .str("group_add_member")
                return .dictionary(d)
            case .groupChangeExternalId:
                var d = [String: JSON]()
                d[".tag"] = .str("group_change_external_id")
                return .dictionary(d)
            case .groupChangeManagementType:
                var d = [String: JSON]()
                d[".tag"] = .str("group_change_management_type")
                return .dictionary(d)
            case .groupChangeMemberRole:
                var d = [String: JSON]()
                d[".tag"] = .str("group_change_member_role")
                return .dictionary(d)
            case .groupCreate:
                var d = [String: JSON]()
                d[".tag"] = .str("group_create")
                return .dictionary(d)
            case .groupDelete:
                var d = [String: JSON]()
                d[".tag"] = .str("group_delete")
                return .dictionary(d)
            case .groupDescriptionUpdated:
                var d = [String: JSON]()
                d[".tag"] = .str("group_description_updated")
                return .dictionary(d)
            case .groupJoinPolicyUpdated:
                var d = [String: JSON]()
                d[".tag"] = .str("group_join_policy_updated")
                return .dictionary(d)
            case .groupMoved:
                var d = [String: JSON]()
                d[".tag"] = .str("group_moved")
                return .dictionary(d)
            case .groupRemoveExternalId:
                var d = [String: JSON]()
                d[".tag"] = .str("group_remove_external_id")
                return .dictionary(d)
            case .groupRemoveMember:
                var d = [String: JSON]()
                d[".tag"] = .str("group_remove_member")
                return .dictionary(d)
            case .groupRename:
                var d = [String: JSON]()
                d[".tag"] = .str("group_rename")
                return .dictionary(d)
            case .accountLockOrUnlocked:
                var d = [String: JSON]()
                d[".tag"] = .str("account_lock_or_unlocked")
                return .dictionary(d)
            case .emmError:
                var d = [String: JSON]()
                d[".tag"] = .str("emm_error")
                return .dictionary(d)
            case .guestAdminSignedInViaTrustedTeams:
                var d = [String: JSON]()
                d[".tag"] = .str("guest_admin_signed_in_via_trusted_teams")
                return .dictionary(d)
            case .guestAdminSignedOutViaTrustedTeams:
                var d = [String: JSON]()
                d[".tag"] = .str("guest_admin_signed_out_via_trusted_teams")
                return .dictionary(d)
            case .loginFail:
                var d = [String: JSON]()
                d[".tag"] = .str("login_fail")
                return .dictionary(d)
            case .loginSuccess:
                var d = [String: JSON]()
                d[".tag"] = .str("login_success")
                return .dictionary(d)
            case .logout:
                var d = [String: JSON]()
                d[".tag"] = .str("logout")
                return .dictionary(d)
            case .resellerSupportSessionEnd:
                var d = [String: JSON]()
                d[".tag"] = .str("reseller_support_session_end")
                return .dictionary(d)
            case .resellerSupportSessionStart:
                var d = [String: JSON]()
                d[".tag"] = .str("reseller_support_session_start")
                return .dictionary(d)
            case .signInAsSessionEnd:
                var d = [String: JSON]()
                d[".tag"] = .str("sign_in_as_session_end")
                return .dictionary(d)
            case .signInAsSessionStart:
                var d = [String: JSON]()
                d[".tag"] = .str("sign_in_as_session_start")
                return .dictionary(d)
            case .ssoError:
                var d = [String: JSON]()
                d[".tag"] = .str("sso_error")
                return .dictionary(d)
            case .backupAdminInvitationSent:
                var d = [String: JSON]()
                d[".tag"] = .str("backup_admin_invitation_sent")
                return .dictionary(d)
            case .backupInvitationOpened:
                var d = [String: JSON]()
                d[".tag"] = .str("backup_invitation_opened")
                return .dictionary(d)
            case .createTeamInviteLink:
                var d = [String: JSON]()
                d[".tag"] = .str("create_team_invite_link")
                return .dictionary(d)
            case .deleteTeamInviteLink:
                var d = [String: JSON]()
                d[".tag"] = .str("delete_team_invite_link")
                return .dictionary(d)
            case .memberAddExternalId:
                var d = [String: JSON]()
                d[".tag"] = .str("member_add_external_id")
                return .dictionary(d)
            case .memberAddName:
                var d = [String: JSON]()
                d[".tag"] = .str("member_add_name")
                return .dictionary(d)
            case .memberChangeAdminRole:
                var d = [String: JSON]()
                d[".tag"] = .str("member_change_admin_role")
                return .dictionary(d)
            case .memberChangeEmail:
                var d = [String: JSON]()
                d[".tag"] = .str("member_change_email")
                return .dictionary(d)
            case .memberChangeExternalId:
                var d = [String: JSON]()
                d[".tag"] = .str("member_change_external_id")
                return .dictionary(d)
            case .memberChangeMembershipType:
                var d = [String: JSON]()
                d[".tag"] = .str("member_change_membership_type")
                return .dictionary(d)
            case .memberChangeName:
                var d = [String: JSON]()
                d[".tag"] = .str("member_change_name")
                return .dictionary(d)
            case .memberChangeResellerRole:
                var d = [String: JSON]()
                d[".tag"] = .str("member_change_reseller_role")
                return .dictionary(d)
            case .memberChangeStatus:
                var d = [String: JSON]()
                d[".tag"] = .str("member_change_status")
                return .dictionary(d)
            case .memberDeleteManualContacts:
                var d = [String: JSON]()
                d[".tag"] = .str("member_delete_manual_contacts")
                return .dictionary(d)
            case .memberDeleteProfilePhoto:
                var d = [String: JSON]()
                d[".tag"] = .str("member_delete_profile_photo")
                return .dictionary(d)
            case .memberPermanentlyDeleteAccountContents:
                var d = [String: JSON]()
                d[".tag"] = .str("member_permanently_delete_account_contents")
                return .dictionary(d)
            case .memberRemoveExternalId:
                var d = [String: JSON]()
                d[".tag"] = .str("member_remove_external_id")
                return .dictionary(d)
            case .memberSetProfilePhoto:
                var d = [String: JSON]()
                d[".tag"] = .str("member_set_profile_photo")
                return .dictionary(d)
            case .memberSpaceLimitsAddCustomQuota:
                var d = [String: JSON]()
                d[".tag"] = .str("member_space_limits_add_custom_quota")
                return .dictionary(d)
            case .memberSpaceLimitsChangeCustomQuota:
                var d = [String: JSON]()
                d[".tag"] = .str("member_space_limits_change_custom_quota")
                return .dictionary(d)
            case .memberSpaceLimitsChangeStatus:
                var d = [String: JSON]()
                d[".tag"] = .str("member_space_limits_change_status")
                return .dictionary(d)
            case .memberSpaceLimitsRemoveCustomQuota:
                var d = [String: JSON]()
                d[".tag"] = .str("member_space_limits_remove_custom_quota")
                return .dictionary(d)
            case .memberSuggest:
                var d = [String: JSON]()
                d[".tag"] = .str("member_suggest")
                return .dictionary(d)
            case .memberTransferAccountContents:
                var d = [String: JSON]()
                d[".tag"] = .str("member_transfer_account_contents")
                return .dictionary(d)
            case .pendingSecondaryEmailAdded:
                var d = [String: JSON]()
                d[".tag"] = .str("pending_secondary_email_added")
                return .dictionary(d)
            case .secondaryEmailDeleted:
                var d = [String: JSON]()
                d[".tag"] = .str("secondary_email_deleted")
                return .dictionary(d)
            case .secondaryEmailVerified:
                var d = [String: JSON]()
                d[".tag"] = .str("secondary_email_verified")
                return .dictionary(d)
            case .secondaryMailsPolicyChanged:
                var d = [String: JSON]()
                d[".tag"] = .str("secondary_mails_policy_changed")
                return .dictionary(d)
            case .binderAddPage:
                var d = [String: JSON]()
                d[".tag"] = .str("binder_add_page")
                return .dictionary(d)
            case .binderAddSection:
                var d = [String: JSON]()
                d[".tag"] = .str("binder_add_section")
                return .dictionary(d)
            case .binderRemovePage:
                var d = [String: JSON]()
                d[".tag"] = .str("binder_remove_page")
                return .dictionary(d)
            case .binderRemoveSection:
                var d = [String: JSON]()
                d[".tag"] = .str("binder_remove_section")
                return .dictionary(d)
            case .binderRenamePage:
                var d = [String: JSON]()
                d[".tag"] = .str("binder_rename_page")
                return .dictionary(d)
            case .binderRenameSection:
                var d = [String: JSON]()
                d[".tag"] = .str("binder_rename_section")
                return .dictionary(d)
            case .binderReorderPage:
                var d = [String: JSON]()
                d[".tag"] = .str("binder_reorder_page")
                return .dictionary(d)
            case .binderReorderSection:
                var d = [String: JSON]()
                d[".tag"] = .str("binder_reorder_section")
                return .dictionary(d)
            case .paperContentAddMember:
                var d = [String: JSON]()
                d[".tag"] = .str("paper_content_add_member")
                return .dictionary(d)
            case .paperContentAddToFolder:
                var d = [String: JSON]()
                d[".tag"] = .str("paper_content_add_to_folder")
                return .dictionary(d)
            case .paperContentArchive:
                var d = [String: JSON]()
                d[".tag"] = .str("paper_content_archive")
                return .dictionary(d)
            case .paperContentCreate:
                var d = [String: JSON]()
                d[".tag"] = .str("paper_content_create")
                return .dictionary(d)
            case .paperContentPermanentlyDelete:
                var d = [String: JSON]()
                d[".tag"] = .str("paper_content_permanently_delete")
                return .dictionary(d)
            case .paperContentRemoveFromFolder:
                var d = [String: JSON]()
                d[".tag"] = .str("paper_content_remove_from_folder")
                return .dictionary(d)
            case .paperContentRemoveMember:
                var d = [String: JSON]()
                d[".tag"] = .str("paper_content_remove_member")
                return .dictionary(d)
            case .paperContentRename:
                var d = [String: JSON]()
                d[".tag"] = .str("paper_content_rename")
                return .dictionary(d)
            case .paperContentRestore:
                var d = [String: JSON]()
                d[".tag"] = .str("paper_content_restore")
                return .dictionary(d)
            case .paperDocAddComment:
                var d = [String: JSON]()
                d[".tag"] = .str("paper_doc_add_comment")
                return .dictionary(d)
            case .paperDocChangeMemberRole:
                var d = [String: JSON]()
                d[".tag"] = .str("paper_doc_change_member_role")
                return .dictionary(d)
            case .paperDocChangeSharingPolicy:
                var d = [String: JSON]()
                d[".tag"] = .str("paper_doc_change_sharing_policy")
                return .dictionary(d)
            case .paperDocChangeSubscription:
                var d = [String: JSON]()
                d[".tag"] = .str("paper_doc_change_subscription")
                return .dictionary(d)
            case .paperDocDeleted:
                var d = [String: JSON]()
                d[".tag"] = .str("paper_doc_deleted")
                return .dictionary(d)
            case .paperDocDeleteComment:
                var d = [String: JSON]()
                d[".tag"] = .str("paper_doc_delete_comment")
                return .dictionary(d)
            case .paperDocDownload:
                var d = [String: JSON]()
                d[".tag"] = .str("paper_doc_download")
                return .dictionary(d)
            case .paperDocEdit:
                var d = [String: JSON]()
                d[".tag"] = .str("paper_doc_edit")
                return .dictionary(d)
            case .paperDocEditComment:
                var d = [String: JSON]()
                d[".tag"] = .str("paper_doc_edit_comment")
                return .dictionary(d)
            case .paperDocFollowed:
                var d = [String: JSON]()
                d[".tag"] = .str("paper_doc_followed")
                return .dictionary(d)
            case .paperDocMention:
                var d = [String: JSON]()
                d[".tag"] = .str("paper_doc_mention")
                return .dictionary(d)
            case .paperDocOwnershipChanged:
                var d = [String: JSON]()
                d[".tag"] = .str("paper_doc_ownership_changed")
                return .dictionary(d)
            case .paperDocRequestAccess:
                var d = [String: JSON]()
                d[".tag"] = .str("paper_doc_request_access")
                return .dictionary(d)
            case .paperDocResolveComment:
                var d = [String: JSON]()
                d[".tag"] = .str("paper_doc_resolve_comment")
                return .dictionary(d)
            case .paperDocRevert:
                var d = [String: JSON]()
                d[".tag"] = .str("paper_doc_revert")
                return .dictionary(d)
            case .paperDocSlackShare:
                var d = [String: JSON]()
                d[".tag"] = .str("paper_doc_slack_share")
                return .dictionary(d)
            case .paperDocTeamInvite:
                var d = [String: JSON]()
                d[".tag"] = .str("paper_doc_team_invite")
                return .dictionary(d)
            case .paperDocTrashed:
                var d = [String: JSON]()
                d[".tag"] = .str("paper_doc_trashed")
                return .dictionary(d)
            case .paperDocUnresolveComment:
                var d = [String: JSON]()
                d[".tag"] = .str("paper_doc_unresolve_comment")
                return .dictionary(d)
            case .paperDocUntrashed:
                var d = [String: JSON]()
                d[".tag"] = .str("paper_doc_untrashed")
                return .dictionary(d)
            case .paperDocView:
                var d = [String: JSON]()
                d[".tag"] = .str("paper_doc_view")
                return .dictionary(d)
            case .paperExternalViewAllow:
                var d = [String: JSON]()
                d[".tag"] = .str("paper_external_view_allow")
                return .dictionary(d)
            case .paperExternalViewDefaultTeam:
                var d = [String: JSON]()
                d[".tag"] = .str("paper_external_view_default_team")
                return .dictionary(d)
            case .paperExternalViewForbid:
                var d = [String: JSON]()
                d[".tag"] = .str("paper_external_view_forbid")
                return .dictionary(d)
            case .paperFolderChangeSubscription:
                var d = [String: JSON]()
                d[".tag"] = .str("paper_folder_change_subscription")
                return .dictionary(d)
            case .paperFolderDeleted:
                var d = [String: JSON]()
                d[".tag"] = .str("paper_folder_deleted")
                return .dictionary(d)
            case .paperFolderFollowed:
                var d = [String: JSON]()
                d[".tag"] = .str("paper_folder_followed")
                return .dictionary(d)
            case .paperFolderTeamInvite:
                var d = [String: JSON]()
                d[".tag"] = .str("paper_folder_team_invite")
                return .dictionary(d)
            case .paperPublishedLinkChangePermission:
                var d = [String: JSON]()
                d[".tag"] = .str("paper_published_link_change_permission")
                return .dictionary(d)
            case .paperPublishedLinkCreate:
                var d = [String: JSON]()
                d[".tag"] = .str("paper_published_link_create")
                return .dictionary(d)
            case .paperPublishedLinkDisabled:
                var d = [String: JSON]()
                d[".tag"] = .str("paper_published_link_disabled")
                return .dictionary(d)
            case .paperPublishedLinkView:
                var d = [String: JSON]()
                d[".tag"] = .str("paper_published_link_view")
                return .dictionary(d)
            case .passwordChange:
                var d = [String: JSON]()
                d[".tag"] = .str("password_change")
                return .dictionary(d)
            case .passwordReset:
                var d = [String: JSON]()
                d[".tag"] = .str("password_reset")
                return .dictionary(d)
            case .passwordResetAll:
                var d = [String: JSON]()
                d[".tag"] = .str("password_reset_all")
                return .dictionary(d)
            case .classificationCreateReport:
                var d = [String: JSON]()
                d[".tag"] = .str("classification_create_report")
                return .dictionary(d)
            case .classificationCreateReportFail:
                var d = [String: JSON]()
                d[".tag"] = .str("classification_create_report_fail")
                return .dictionary(d)
            case .emmCreateExceptionsReport:
                var d = [String: JSON]()
                d[".tag"] = .str("emm_create_exceptions_report")
                return .dictionary(d)
            case .emmCreateUsageReport:
                var d = [String: JSON]()
                d[".tag"] = .str("emm_create_usage_report")
                return .dictionary(d)
            case .exportMembersReport:
                var d = [String: JSON]()
                d[".tag"] = .str("export_members_report")
                return .dictionary(d)
            case .exportMembersReportFail:
                var d = [String: JSON]()
                d[".tag"] = .str("export_members_report_fail")
                return .dictionary(d)
            case .externalSharingCreateReport:
                var d = [String: JSON]()
                d[".tag"] = .str("external_sharing_create_report")
                return .dictionary(d)
            case .externalSharingReportFailed:
                var d = [String: JSON]()
                d[".tag"] = .str("external_sharing_report_failed")
                return .dictionary(d)
            case .noExpirationLinkGenCreateReport:
                var d = [String: JSON]()
                d[".tag"] = .str("no_expiration_link_gen_create_report")
                return .dictionary(d)
            case .noExpirationLinkGenReportFailed:
                var d = [String: JSON]()
                d[".tag"] = .str("no_expiration_link_gen_report_failed")
                return .dictionary(d)
            case .noPasswordLinkGenCreateReport:
                var d = [String: JSON]()
                d[".tag"] = .str("no_password_link_gen_create_report")
                return .dictionary(d)
            case .noPasswordLinkGenReportFailed:
                var d = [String: JSON]()
                d[".tag"] = .str("no_password_link_gen_report_failed")
                return .dictionary(d)
            case .noPasswordLinkViewCreateReport:
                var d = [String: JSON]()
                d[".tag"] = .str("no_password_link_view_create_report")
                return .dictionary(d)
            case .noPasswordLinkViewReportFailed:
                var d = [String: JSON]()
                d[".tag"] = .str("no_password_link_view_report_failed")
                return .dictionary(d)
            case .outdatedLinkViewCreateReport:
                var d = [String: JSON]()
                d[".tag"] = .str("outdated_link_view_create_report")
                return .dictionary(d)
            case .outdatedLinkViewReportFailed:
                var d = [String: JSON]()
                d[".tag"] = .str("outdated_link_view_report_failed")
                return .dictionary(d)
            case .paperAdminExportStart:
                var d = [String: JSON]()
                d[".tag"] = .str("paper_admin_export_start")
                return .dictionary(d)
            case .ransomwareAlertCreateReport:
                var d = [String: JSON]()
                d[".tag"] = .str("ransomware_alert_create_report")
                return .dictionary(d)
            case .ransomwareAlertCreateReportFailed:
                var d = [String: JSON]()
                d[".tag"] = .str("ransomware_alert_create_report_failed")
                return .dictionary(d)
            case .smartSyncCreateAdminPrivilegeReport:
                var d = [String: JSON]()
                d[".tag"] = .str("smart_sync_create_admin_privilege_report")
                return .dictionary(d)
            case .teamActivityCreateReport:
                var d = [String: JSON]()
                d[".tag"] = .str("team_activity_create_report")
                return .dictionary(d)
            case .teamActivityCreateReportFail:
                var d = [String: JSON]()
                d[".tag"] = .str("team_activity_create_report_fail")
                return .dictionary(d)
            case .collectionShare:
                var d = [String: JSON]()
                d[".tag"] = .str("collection_share")
                return .dictionary(d)
            case .fileTransfersFileAdd:
                var d = [String: JSON]()
                d[".tag"] = .str("file_transfers_file_add")
                return .dictionary(d)
            case .fileTransfersTransferDelete:
                var d = [String: JSON]()
                d[".tag"] = .str("file_transfers_transfer_delete")
                return .dictionary(d)
            case .fileTransfersTransferDownload:
                var d = [String: JSON]()
                d[".tag"] = .str("file_transfers_transfer_download")
                return .dictionary(d)
            case .fileTransfersTransferSend:
                var d = [String: JSON]()
                d[".tag"] = .str("file_transfers_transfer_send")
                return .dictionary(d)
            case .fileTransfersTransferView:
                var d = [String: JSON]()
                d[".tag"] = .str("file_transfers_transfer_view")
                return .dictionary(d)
            case .noteAclInviteOnly:
                var d = [String: JSON]()
                d[".tag"] = .str("note_acl_invite_only")
                return .dictionary(d)
            case .noteAclLink:
                var d = [String: JSON]()
                d[".tag"] = .str("note_acl_link")
                return .dictionary(d)
            case .noteAclTeamLink:
                var d = [String: JSON]()
                d[".tag"] = .str("note_acl_team_link")
                return .dictionary(d)
            case .noteShared:
                var d = [String: JSON]()
                d[".tag"] = .str("note_shared")
                return .dictionary(d)
            case .noteShareReceive:
                var d = [String: JSON]()
                d[".tag"] = .str("note_share_receive")
                return .dictionary(d)
            case .openNoteShared:
                var d = [String: JSON]()
                d[".tag"] = .str("open_note_shared")
                return .dictionary(d)
            case .replayFileSharedLinkCreated:
                var d = [String: JSON]()
                d[".tag"] = .str("replay_file_shared_link_created")
                return .dictionary(d)
            case .replayFileSharedLinkModified:
                var d = [String: JSON]()
                d[".tag"] = .str("replay_file_shared_link_modified")
                return .dictionary(d)
            case .replayProjectTeamAdd:
                var d = [String: JSON]()
                d[".tag"] = .str("replay_project_team_add")
                return .dictionary(d)
            case .replayProjectTeamDelete:
                var d = [String: JSON]()
                d[".tag"] = .str("replay_project_team_delete")
                return .dictionary(d)
            case .sfAddGroup:
                var d = [String: JSON]()
                d[".tag"] = .str("sf_add_group")
                return .dictionary(d)
            case .sfAllowNonMembersToViewSharedLinks:
                var d = [String: JSON]()
                d[".tag"] = .str("sf_allow_non_members_to_view_shared_links")
                return .dictionary(d)
            case .sfExternalInviteWarn:
                var d = [String: JSON]()
                d[".tag"] = .str("sf_external_invite_warn")
                return .dictionary(d)
            case .sfFbInvite:
                var d = [String: JSON]()
                d[".tag"] = .str("sf_fb_invite")
                return .dictionary(d)
            case .sfFbInviteChangeRole:
                var d = [String: JSON]()
                d[".tag"] = .str("sf_fb_invite_change_role")
                return .dictionary(d)
            case .sfFbUninvite:
                var d = [String: JSON]()
                d[".tag"] = .str("sf_fb_uninvite")
                return .dictionary(d)
            case .sfInviteGroup:
                var d = [String: JSON]()
                d[".tag"] = .str("sf_invite_group")
                return .dictionary(d)
            case .sfTeamGrantAccess:
                var d = [String: JSON]()
                d[".tag"] = .str("sf_team_grant_access")
                return .dictionary(d)
            case .sfTeamInvite:
                var d = [String: JSON]()
                d[".tag"] = .str("sf_team_invite")
                return .dictionary(d)
            case .sfTeamInviteChangeRole:
                var d = [String: JSON]()
                d[".tag"] = .str("sf_team_invite_change_role")
                return .dictionary(d)
            case .sfTeamJoin:
                var d = [String: JSON]()
                d[".tag"] = .str("sf_team_join")
                return .dictionary(d)
            case .sfTeamJoinFromOobLink:
                var d = [String: JSON]()
                d[".tag"] = .str("sf_team_join_from_oob_link")
                return .dictionary(d)
            case .sfTeamUninvite:
                var d = [String: JSON]()
                d[".tag"] = .str("sf_team_uninvite")
                return .dictionary(d)
            case .sharedContentAddInvitees:
                var d = [String: JSON]()
                d[".tag"] = .str("shared_content_add_invitees")
                return .dictionary(d)
            case .sharedContentAddLinkExpiry:
                var d = [String: JSON]()
                d[".tag"] = .str("shared_content_add_link_expiry")
                return .dictionary(d)
            case .sharedContentAddLinkPassword:
                var d = [String: JSON]()
                d[".tag"] = .str("shared_content_add_link_password")
                return .dictionary(d)
            case .sharedContentAddMember:
                var d = [String: JSON]()
                d[".tag"] = .str("shared_content_add_member")
                return .dictionary(d)
            case .sharedContentChangeDownloadsPolicy:
                var d = [String: JSON]()
                d[".tag"] = .str("shared_content_change_downloads_policy")
                return .dictionary(d)
            case .sharedContentChangeInviteeRole:
                var d = [String: JSON]()
                d[".tag"] = .str("shared_content_change_invitee_role")
                return .dictionary(d)
            case .sharedContentChangeLinkAudience:
                var d = [String: JSON]()
                d[".tag"] = .str("shared_content_change_link_audience")
                return .dictionary(d)
            case .sharedContentChangeLinkExpiry:
                var d = [String: JSON]()
                d[".tag"] = .str("shared_content_change_link_expiry")
                return .dictionary(d)
            case .sharedContentChangeLinkPassword:
                var d = [String: JSON]()
                d[".tag"] = .str("shared_content_change_link_password")
                return .dictionary(d)
            case .sharedContentChangeMemberRole:
                var d = [String: JSON]()
                d[".tag"] = .str("shared_content_change_member_role")
                return .dictionary(d)
            case .sharedContentChangeViewerInfoPolicy:
                var d = [String: JSON]()
                d[".tag"] = .str("shared_content_change_viewer_info_policy")
                return .dictionary(d)
            case .sharedContentClaimInvitation:
                var d = [String: JSON]()
                d[".tag"] = .str("shared_content_claim_invitation")
                return .dictionary(d)
            case .sharedContentCopy:
                var d = [String: JSON]()
                d[".tag"] = .str("shared_content_copy")
                return .dictionary(d)
            case .sharedContentDownload:
                var d = [String: JSON]()
                d[".tag"] = .str("shared_content_download")
                return .dictionary(d)
            case .sharedContentRelinquishMembership:
                var d = [String: JSON]()
                d[".tag"] = .str("shared_content_relinquish_membership")
                return .dictionary(d)
            case .sharedContentRemoveInvitees:
                var d = [String: JSON]()
                d[".tag"] = .str("shared_content_remove_invitees")
                return .dictionary(d)
            case .sharedContentRemoveLinkExpiry:
                var d = [String: JSON]()
                d[".tag"] = .str("shared_content_remove_link_expiry")
                return .dictionary(d)
            case .sharedContentRemoveLinkPassword:
                var d = [String: JSON]()
                d[".tag"] = .str("shared_content_remove_link_password")
                return .dictionary(d)
            case .sharedContentRemoveMember:
                var d = [String: JSON]()
                d[".tag"] = .str("shared_content_remove_member")
                return .dictionary(d)
            case .sharedContentRequestAccess:
                var d = [String: JSON]()
                d[".tag"] = .str("shared_content_request_access")
                return .dictionary(d)
            case .sharedContentRestoreInvitees:
                var d = [String: JSON]()
                d[".tag"] = .str("shared_content_restore_invitees")
                return .dictionary(d)
            case .sharedContentRestoreMember:
                var d = [String: JSON]()
                d[".tag"] = .str("shared_content_restore_member")
                return .dictionary(d)
            case .sharedContentUnshare:
                var d = [String: JSON]()
                d[".tag"] = .str("shared_content_unshare")
                return .dictionary(d)
            case .sharedContentView:
                var d = [String: JSON]()
                d[".tag"] = .str("shared_content_view")
                return .dictionary(d)
            case .sharedFolderChangeLinkPolicy:
                var d = [String: JSON]()
                d[".tag"] = .str("shared_folder_change_link_policy")
                return .dictionary(d)
            case .sharedFolderChangeMembersInheritancePolicy:
                var d = [String: JSON]()
                d[".tag"] = .str("shared_folder_change_members_inheritance_policy")
                return .dictionary(d)
            case .sharedFolderChangeMembersManagementPolicy:
                var d = [String: JSON]()
                d[".tag"] = .str("shared_folder_change_members_management_policy")
                return .dictionary(d)
            case .sharedFolderChangeMembersPolicy:
                var d = [String: JSON]()
                d[".tag"] = .str("shared_folder_change_members_policy")
                return .dictionary(d)
            case .sharedFolderCreate:
                var d = [String: JSON]()
                d[".tag"] = .str("shared_folder_create")
                return .dictionary(d)
            case .sharedFolderDeclineInvitation:
                var d = [String: JSON]()
                d[".tag"] = .str("shared_folder_decline_invitation")
                return .dictionary(d)
            case .sharedFolderMount:
                var d = [String: JSON]()
                d[".tag"] = .str("shared_folder_mount")
                return .dictionary(d)
            case .sharedFolderNest:
                var d = [String: JSON]()
                d[".tag"] = .str("shared_folder_nest")
                return .dictionary(d)
            case .sharedFolderTransferOwnership:
                var d = [String: JSON]()
                d[".tag"] = .str("shared_folder_transfer_ownership")
                return .dictionary(d)
            case .sharedFolderUnmount:
                var d = [String: JSON]()
                d[".tag"] = .str("shared_folder_unmount")
                return .dictionary(d)
            case .sharedLinkAddExpiry:
                var d = [String: JSON]()
                d[".tag"] = .str("shared_link_add_expiry")
                return .dictionary(d)
            case .sharedLinkChangeExpiry:
                var d = [String: JSON]()
                d[".tag"] = .str("shared_link_change_expiry")
                return .dictionary(d)
            case .sharedLinkChangeVisibility:
                var d = [String: JSON]()
                d[".tag"] = .str("shared_link_change_visibility")
                return .dictionary(d)
            case .sharedLinkCopy:
                var d = [String: JSON]()
                d[".tag"] = .str("shared_link_copy")
                return .dictionary(d)
            case .sharedLinkCreate:
                var d = [String: JSON]()
                d[".tag"] = .str("shared_link_create")
                return .dictionary(d)
            case .sharedLinkDisable:
                var d = [String: JSON]()
                d[".tag"] = .str("shared_link_disable")
                return .dictionary(d)
            case .sharedLinkDownload:
                var d = [String: JSON]()
                d[".tag"] = .str("shared_link_download")
                return .dictionary(d)
            case .sharedLinkRemoveExpiry:
                var d = [String: JSON]()
                d[".tag"] = .str("shared_link_remove_expiry")
                return .dictionary(d)
            case .sharedLinkSettingsAddExpiration:
                var d = [String: JSON]()
                d[".tag"] = .str("shared_link_settings_add_expiration")
                return .dictionary(d)
            case .sharedLinkSettingsAddPassword:
                var d = [String: JSON]()
                d[".tag"] = .str("shared_link_settings_add_password")
                return .dictionary(d)
            case .sharedLinkSettingsAllowDownloadDisabled:
                var d = [String: JSON]()
                d[".tag"] = .str("shared_link_settings_allow_download_disabled")
                return .dictionary(d)
            case .sharedLinkSettingsAllowDownloadEnabled:
                var d = [String: JSON]()
                d[".tag"] = .str("shared_link_settings_allow_download_enabled")
                return .dictionary(d)
            case .sharedLinkSettingsChangeAudience:
                var d = [String: JSON]()
                d[".tag"] = .str("shared_link_settings_change_audience")
                return .dictionary(d)
            case .sharedLinkSettingsChangeExpiration:
                var d = [String: JSON]()
                d[".tag"] = .str("shared_link_settings_change_expiration")
                return .dictionary(d)
            case .sharedLinkSettingsChangePassword:
                var d = [String: JSON]()
                d[".tag"] = .str("shared_link_settings_change_password")
                return .dictionary(d)
            case .sharedLinkSettingsRemoveExpiration:
                var d = [String: JSON]()
                d[".tag"] = .str("shared_link_settings_remove_expiration")
                return .dictionary(d)
            case .sharedLinkSettingsRemovePassword:
                var d = [String: JSON]()
                d[".tag"] = .str("shared_link_settings_remove_password")
                return .dictionary(d)
            case .sharedLinkShare:
                var d = [String: JSON]()
                d[".tag"] = .str("shared_link_share")
                return .dictionary(d)
            case .sharedLinkView:
                var d = [String: JSON]()
                d[".tag"] = .str("shared_link_view")
                return .dictionary(d)
            case .sharedNoteOpened:
                var d = [String: JSON]()
                d[".tag"] = .str("shared_note_opened")
                return .dictionary(d)
            case .shmodelDisableDownloads:
                var d = [String: JSON]()
                d[".tag"] = .str("shmodel_disable_downloads")
                return .dictionary(d)
            case .shmodelEnableDownloads:
                var d = [String: JSON]()
                d[".tag"] = .str("shmodel_enable_downloads")
                return .dictionary(d)
            case .shmodelGroupShare:
                var d = [String: JSON]()
                d[".tag"] = .str("shmodel_group_share")
                return .dictionary(d)
            case .showcaseAccessGranted:
                var d = [String: JSON]()
                d[".tag"] = .str("showcase_access_granted")
                return .dictionary(d)
            case .showcaseAddMember:
                var d = [String: JSON]()
                d[".tag"] = .str("showcase_add_member")
                return .dictionary(d)
            case .showcaseArchived:
                var d = [String: JSON]()
                d[".tag"] = .str("showcase_archived")
                return .dictionary(d)
            case .showcaseCreated:
                var d = [String: JSON]()
                d[".tag"] = .str("showcase_created")
                return .dictionary(d)
            case .showcaseDeleteComment:
                var d = [String: JSON]()
                d[".tag"] = .str("showcase_delete_comment")
                return .dictionary(d)
            case .showcaseEdited:
                var d = [String: JSON]()
                d[".tag"] = .str("showcase_edited")
                return .dictionary(d)
            case .showcaseEditComment:
                var d = [String: JSON]()
                d[".tag"] = .str("showcase_edit_comment")
                return .dictionary(d)
            case .showcaseFileAdded:
                var d = [String: JSON]()
                d[".tag"] = .str("showcase_file_added")
                return .dictionary(d)
            case .showcaseFileDownload:
                var d = [String: JSON]()
                d[".tag"] = .str("showcase_file_download")
                return .dictionary(d)
            case .showcaseFileRemoved:
                var d = [String: JSON]()
                d[".tag"] = .str("showcase_file_removed")
                return .dictionary(d)
            case .showcaseFileView:
                var d = [String: JSON]()
                d[".tag"] = .str("showcase_file_view")
                return .dictionary(d)
            case .showcasePermanentlyDeleted:
                var d = [String: JSON]()
                d[".tag"] = .str("showcase_permanently_deleted")
                return .dictionary(d)
            case .showcasePostComment:
                var d = [String: JSON]()
                d[".tag"] = .str("showcase_post_comment")
                return .dictionary(d)
            case .showcaseRemoveMember:
                var d = [String: JSON]()
                d[".tag"] = .str("showcase_remove_member")
                return .dictionary(d)
            case .showcaseRenamed:
                var d = [String: JSON]()
                d[".tag"] = .str("showcase_renamed")
                return .dictionary(d)
            case .showcaseRequestAccess:
                var d = [String: JSON]()
                d[".tag"] = .str("showcase_request_access")
                return .dictionary(d)
            case .showcaseResolveComment:
                var d = [String: JSON]()
                d[".tag"] = .str("showcase_resolve_comment")
                return .dictionary(d)
            case .showcaseRestored:
                var d = [String: JSON]()
                d[".tag"] = .str("showcase_restored")
                return .dictionary(d)
            case .showcaseTrashed:
                var d = [String: JSON]()
                d[".tag"] = .str("showcase_trashed")
                return .dictionary(d)
            case .showcaseTrashedDeprecated:
                var d = [String: JSON]()
                d[".tag"] = .str("showcase_trashed_deprecated")
                return .dictionary(d)
            case .showcaseUnresolveComment:
                var d = [String: JSON]()
                d[".tag"] = .str("showcase_unresolve_comment")
                return .dictionary(d)
            case .showcaseUntrashed:
                var d = [String: JSON]()
                d[".tag"] = .str("showcase_untrashed")
                return .dictionary(d)
            case .showcaseUntrashedDeprecated:
                var d = [String: JSON]()
                d[".tag"] = .str("showcase_untrashed_deprecated")
                return .dictionary(d)
            case .showcaseView:
                var d = [String: JSON]()
                d[".tag"] = .str("showcase_view")
                return .dictionary(d)
            case .ssoAddCert:
                var d = [String: JSON]()
                d[".tag"] = .str("sso_add_cert")
                return .dictionary(d)
            case .ssoAddLoginUrl:
                var d = [String: JSON]()
                d[".tag"] = .str("sso_add_login_url")
                return .dictionary(d)
            case .ssoAddLogoutUrl:
                var d = [String: JSON]()
                d[".tag"] = .str("sso_add_logout_url")
                return .dictionary(d)
            case .ssoChangeCert:
                var d = [String: JSON]()
                d[".tag"] = .str("sso_change_cert")
                return .dictionary(d)
            case .ssoChangeLoginUrl:
                var d = [String: JSON]()
                d[".tag"] = .str("sso_change_login_url")
                return .dictionary(d)
            case .ssoChangeLogoutUrl:
                var d = [String: JSON]()
                d[".tag"] = .str("sso_change_logout_url")
                return .dictionary(d)
            case .ssoChangeSamlIdentityMode:
                var d = [String: JSON]()
                d[".tag"] = .str("sso_change_saml_identity_mode")
                return .dictionary(d)
            case .ssoRemoveCert:
                var d = [String: JSON]()
                d[".tag"] = .str("sso_remove_cert")
                return .dictionary(d)
            case .ssoRemoveLoginUrl:
                var d = [String: JSON]()
                d[".tag"] = .str("sso_remove_login_url")
                return .dictionary(d)
            case .ssoRemoveLogoutUrl:
                var d = [String: JSON]()
                d[".tag"] = .str("sso_remove_logout_url")
                return .dictionary(d)
            case .teamFolderChangeStatus:
                var d = [String: JSON]()
                d[".tag"] = .str("team_folder_change_status")
                return .dictionary(d)
            case .teamFolderCreate:
                var d = [String: JSON]()
                d[".tag"] = .str("team_folder_create")
                return .dictionary(d)
            case .teamFolderDowngrade:
                var d = [String: JSON]()
                d[".tag"] = .str("team_folder_downgrade")
                return .dictionary(d)
            case .teamFolderPermanentlyDelete:
                var d = [String: JSON]()
                d[".tag"] = .str("team_folder_permanently_delete")
                return .dictionary(d)
            case .teamFolderRename:
                var d = [String: JSON]()
                d[".tag"] = .str("team_folder_rename")
                return .dictionary(d)
            case .teamSelectiveSyncSettingsChanged:
                var d = [String: JSON]()
                d[".tag"] = .str("team_selective_sync_settings_changed")
                return .dictionary(d)
            case .accountCaptureChangePolicy:
                var d = [String: JSON]()
                d[".tag"] = .str("account_capture_change_policy")
                return .dictionary(d)
            case .adminEmailRemindersChanged:
                var d = [String: JSON]()
                d[".tag"] = .str("admin_email_reminders_changed")
                return .dictionary(d)
            case .allowDownloadDisabled:
                var d = [String: JSON]()
                d[".tag"] = .str("allow_download_disabled")
                return .dictionary(d)
            case .allowDownloadEnabled:
                var d = [String: JSON]()
                d[".tag"] = .str("allow_download_enabled")
                return .dictionary(d)
            case .appPermissionsChanged:
                var d = [String: JSON]()
                d[".tag"] = .str("app_permissions_changed")
                return .dictionary(d)
            case .cameraUploadsPolicyChanged:
                var d = [String: JSON]()
                d[".tag"] = .str("camera_uploads_policy_changed")
                return .dictionary(d)
            case .captureTranscriptPolicyChanged:
                var d = [String: JSON]()
                d[".tag"] = .str("capture_transcript_policy_changed")
                return .dictionary(d)
            case .classificationChangePolicy:
                var d = [String: JSON]()
                d[".tag"] = .str("classification_change_policy")
                return .dictionary(d)
            case .computerBackupPolicyChanged:
                var d = [String: JSON]()
                d[".tag"] = .str("computer_backup_policy_changed")
                return .dictionary(d)
            case .contentAdministrationPolicyChanged:
                var d = [String: JSON]()
                d[".tag"] = .str("content_administration_policy_changed")
                return .dictionary(d)
            case .dataPlacementRestrictionChangePolicy:
                var d = [String: JSON]()
                d[".tag"] = .str("data_placement_restriction_change_policy")
                return .dictionary(d)
            case .dataPlacementRestrictionSatisfyPolicy:
                var d = [String: JSON]()
                d[".tag"] = .str("data_placement_restriction_satisfy_policy")
                return .dictionary(d)
            case .deviceApprovalsAddException:
                var d = [String: JSON]()
                d[".tag"] = .str("device_approvals_add_exception")
                return .dictionary(d)
            case .deviceApprovalsChangeDesktopPolicy:
                var d = [String: JSON]()
                d[".tag"] = .str("device_approvals_change_desktop_policy")
                return .dictionary(d)
            case .deviceApprovalsChangeMobilePolicy:
                var d = [String: JSON]()
                d[".tag"] = .str("device_approvals_change_mobile_policy")
                return .dictionary(d)
            case .deviceApprovalsChangeOverageAction:
                var d = [String: JSON]()
                d[".tag"] = .str("device_approvals_change_overage_action")
                return .dictionary(d)
            case .deviceApprovalsChangeUnlinkAction:
                var d = [String: JSON]()
                d[".tag"] = .str("device_approvals_change_unlink_action")
                return .dictionary(d)
            case .deviceApprovalsRemoveException:
                var d = [String: JSON]()
                d[".tag"] = .str("device_approvals_remove_exception")
                return .dictionary(d)
            case .directoryRestrictionsAddMembers:
                var d = [String: JSON]()
                d[".tag"] = .str("directory_restrictions_add_members")
                return .dictionary(d)
            case .directoryRestrictionsRemoveMembers:
                var d = [String: JSON]()
                d[".tag"] = .str("directory_restrictions_remove_members")
                return .dictionary(d)
            case .dropboxPasswordsPolicyChanged:
                var d = [String: JSON]()
                d[".tag"] = .str("dropbox_passwords_policy_changed")
                return .dictionary(d)
            case .emailIngestPolicyChanged:
                var d = [String: JSON]()
                d[".tag"] = .str("email_ingest_policy_changed")
                return .dictionary(d)
            case .emmAddException:
                var d = [String: JSON]()
                d[".tag"] = .str("emm_add_exception")
                return .dictionary(d)
            case .emmChangePolicy:
                var d = [String: JSON]()
                d[".tag"] = .str("emm_change_policy")
                return .dictionary(d)
            case .emmRemoveException:
                var d = [String: JSON]()
                d[".tag"] = .str("emm_remove_exception")
                return .dictionary(d)
            case .extendedVersionHistoryChangePolicy:
                var d = [String: JSON]()
                d[".tag"] = .str("extended_version_history_change_policy")
                return .dictionary(d)
            case .externalDriveBackupPolicyChanged:
                var d = [String: JSON]()
                d[".tag"] = .str("external_drive_backup_policy_changed")
                return .dictionary(d)
            case .fileCommentsChangePolicy:
                var d = [String: JSON]()
                d[".tag"] = .str("file_comments_change_policy")
                return .dictionary(d)
            case .fileLockingPolicyChanged:
                var d = [String: JSON]()
                d[".tag"] = .str("file_locking_policy_changed")
                return .dictionary(d)
            case .fileProviderMigrationPolicyChanged:
                var d = [String: JSON]()
                d[".tag"] = .str("file_provider_migration_policy_changed")
                return .dictionary(d)
            case .fileRequestsChangePolicy:
                var d = [String: JSON]()
                d[".tag"] = .str("file_requests_change_policy")
                return .dictionary(d)
            case .fileRequestsEmailsEnabled:
                var d = [String: JSON]()
                d[".tag"] = .str("file_requests_emails_enabled")
                return .dictionary(d)
            case .fileRequestsEmailsRestrictedToTeamOnly:
                var d = [String: JSON]()
                d[".tag"] = .str("file_requests_emails_restricted_to_team_only")
                return .dictionary(d)
            case .fileTransfersPolicyChanged:
                var d = [String: JSON]()
                d[".tag"] = .str("file_transfers_policy_changed")
                return .dictionary(d)
            case .folderLinkRestrictionPolicyChanged:
                var d = [String: JSON]()
                d[".tag"] = .str("folder_link_restriction_policy_changed")
                return .dictionary(d)
            case .googleSsoChangePolicy:
                var d = [String: JSON]()
                d[".tag"] = .str("google_sso_change_policy")
                return .dictionary(d)
            case .groupUserManagementChangePolicy:
                var d = [String: JSON]()
                d[".tag"] = .str("group_user_management_change_policy")
                return .dictionary(d)
            case .integrationPolicyChanged:
                var d = [String: JSON]()
                d[".tag"] = .str("integration_policy_changed")
                return .dictionary(d)
            case .inviteAcceptanceEmailPolicyChanged:
                var d = [String: JSON]()
                d[".tag"] = .str("invite_acceptance_email_policy_changed")
                return .dictionary(d)
            case .memberRequestsChangePolicy:
                var d = [String: JSON]()
                d[".tag"] = .str("member_requests_change_policy")
                return .dictionary(d)
            case .memberSendInvitePolicyChanged:
                var d = [String: JSON]()
                d[".tag"] = .str("member_send_invite_policy_changed")
                return .dictionary(d)
            case .memberSpaceLimitsAddException:
                var d = [String: JSON]()
                d[".tag"] = .str("member_space_limits_add_exception")
                return .dictionary(d)
            case .memberSpaceLimitsChangeCapsTypePolicy:
                var d = [String: JSON]()
                d[".tag"] = .str("member_space_limits_change_caps_type_policy")
                return .dictionary(d)
            case .memberSpaceLimitsChangePolicy:
                var d = [String: JSON]()
                d[".tag"] = .str("member_space_limits_change_policy")
                return .dictionary(d)
            case .memberSpaceLimitsRemoveException:
                var d = [String: JSON]()
                d[".tag"] = .str("member_space_limits_remove_exception")
                return .dictionary(d)
            case .memberSuggestionsChangePolicy:
                var d = [String: JSON]()
                d[".tag"] = .str("member_suggestions_change_policy")
                return .dictionary(d)
            case .microsoftOfficeAddinChangePolicy:
                var d = [String: JSON]()
                d[".tag"] = .str("microsoft_office_addin_change_policy")
                return .dictionary(d)
            case .networkControlChangePolicy:
                var d = [String: JSON]()
                d[".tag"] = .str("network_control_change_policy")
                return .dictionary(d)
            case .paperChangeDeploymentPolicy:
                var d = [String: JSON]()
                d[".tag"] = .str("paper_change_deployment_policy")
                return .dictionary(d)
            case .paperChangeMemberLinkPolicy:
                var d = [String: JSON]()
                d[".tag"] = .str("paper_change_member_link_policy")
                return .dictionary(d)
            case .paperChangeMemberPolicy:
                var d = [String: JSON]()
                d[".tag"] = .str("paper_change_member_policy")
                return .dictionary(d)
            case .paperChangePolicy:
                var d = [String: JSON]()
                d[".tag"] = .str("paper_change_policy")
                return .dictionary(d)
            case .paperDefaultFolderPolicyChanged:
                var d = [String: JSON]()
                d[".tag"] = .str("paper_default_folder_policy_changed")
                return .dictionary(d)
            case .paperDesktopPolicyChanged:
                var d = [String: JSON]()
                d[".tag"] = .str("paper_desktop_policy_changed")
                return .dictionary(d)
            case .paperEnabledUsersGroupAddition:
                var d = [String: JSON]()
                d[".tag"] = .str("paper_enabled_users_group_addition")
                return .dictionary(d)
            case .paperEnabledUsersGroupRemoval:
                var d = [String: JSON]()
                d[".tag"] = .str("paper_enabled_users_group_removal")
                return .dictionary(d)
            case .passwordStrengthRequirementsChangePolicy:
                var d = [String: JSON]()
                d[".tag"] = .str("password_strength_requirements_change_policy")
                return .dictionary(d)
            case .permanentDeleteChangePolicy:
                var d = [String: JSON]()
                d[".tag"] = .str("permanent_delete_change_policy")
                return .dictionary(d)
            case .resellerSupportChangePolicy:
                var d = [String: JSON]()
                d[".tag"] = .str("reseller_support_change_policy")
                return .dictionary(d)
            case .rewindPolicyChanged:
                var d = [String: JSON]()
                d[".tag"] = .str("rewind_policy_changed")
                return .dictionary(d)
            case .sendForSignaturePolicyChanged:
                var d = [String: JSON]()
                d[".tag"] = .str("send_for_signature_policy_changed")
                return .dictionary(d)
            case .sharingChangeFolderJoinPolicy:
                var d = [String: JSON]()
                d[".tag"] = .str("sharing_change_folder_join_policy")
                return .dictionary(d)
            case .sharingChangeLinkAllowChangeExpirationPolicy:
                var d = [String: JSON]()
                d[".tag"] = .str("sharing_change_link_allow_change_expiration_policy")
                return .dictionary(d)
            case .sharingChangeLinkDefaultExpirationPolicy:
                var d = [String: JSON]()
                d[".tag"] = .str("sharing_change_link_default_expiration_policy")
                return .dictionary(d)
            case .sharingChangeLinkEnforcePasswordPolicy:
                var d = [String: JSON]()
                d[".tag"] = .str("sharing_change_link_enforce_password_policy")
                return .dictionary(d)
            case .sharingChangeLinkPolicy:
                var d = [String: JSON]()
                d[".tag"] = .str("sharing_change_link_policy")
                return .dictionary(d)
            case .sharingChangeMemberPolicy:
                var d = [String: JSON]()
                d[".tag"] = .str("sharing_change_member_policy")
                return .dictionary(d)
            case .showcaseChangeDownloadPolicy:
                var d = [String: JSON]()
                d[".tag"] = .str("showcase_change_download_policy")
                return .dictionary(d)
            case .showcaseChangeEnabledPolicy:
                var d = [String: JSON]()
                d[".tag"] = .str("showcase_change_enabled_policy")
                return .dictionary(d)
            case .showcaseChangeExternalSharingPolicy:
                var d = [String: JSON]()
                d[".tag"] = .str("showcase_change_external_sharing_policy")
                return .dictionary(d)
            case .smarterSmartSyncPolicyChanged:
                var d = [String: JSON]()
                d[".tag"] = .str("smarter_smart_sync_policy_changed")
                return .dictionary(d)
            case .smartSyncChangePolicy:
                var d = [String: JSON]()
                d[".tag"] = .str("smart_sync_change_policy")
                return .dictionary(d)
            case .smartSyncNotOptOut:
                var d = [String: JSON]()
                d[".tag"] = .str("smart_sync_not_opt_out")
                return .dictionary(d)
            case .smartSyncOptOut:
                var d = [String: JSON]()
                d[".tag"] = .str("smart_sync_opt_out")
                return .dictionary(d)
            case .ssoChangePolicy:
                var d = [String: JSON]()
                d[".tag"] = .str("sso_change_policy")
                return .dictionary(d)
            case .teamBrandingPolicyChanged:
                var d = [String: JSON]()
                d[".tag"] = .str("team_branding_policy_changed")
                return .dictionary(d)
            case .teamExtensionsPolicyChanged:
                var d = [String: JSON]()
                d[".tag"] = .str("team_extensions_policy_changed")
                return .dictionary(d)
            case .teamSelectiveSyncPolicyChanged:
                var d = [String: JSON]()
                d[".tag"] = .str("team_selective_sync_policy_changed")
                return .dictionary(d)
            case .teamSharingWhitelistSubjectsChanged:
                var d = [String: JSON]()
                d[".tag"] = .str("team_sharing_whitelist_subjects_changed")
                return .dictionary(d)
            case .tfaAddException:
                var d = [String: JSON]()
                d[".tag"] = .str("tfa_add_exception")
                return .dictionary(d)
            case .tfaChangePolicy:
                var d = [String: JSON]()
                d[".tag"] = .str("tfa_change_policy")
                return .dictionary(d)
            case .tfaRemoveException:
                var d = [String: JSON]()
                d[".tag"] = .str("tfa_remove_exception")
                return .dictionary(d)
            case .twoAccountChangePolicy:
                var d = [String: JSON]()
                d[".tag"] = .str("two_account_change_policy")
                return .dictionary(d)
            case .viewerInfoPolicyChanged:
                var d = [String: JSON]()
                d[".tag"] = .str("viewer_info_policy_changed")
                return .dictionary(d)
            case .watermarkingPolicyChanged:
                var d = [String: JSON]()
                d[".tag"] = .str("watermarking_policy_changed")
                return .dictionary(d)
            case .webSessionsChangeActiveSessionLimit:
                var d = [String: JSON]()
                d[".tag"] = .str("web_sessions_change_active_session_limit")
                return .dictionary(d)
            case .webSessionsChangeFixedLengthPolicy:
                var d = [String: JSON]()
                d[".tag"] = .str("web_sessions_change_fixed_length_policy")
                return .dictionary(d)
            case .webSessionsChangeIdleLengthPolicy:
                var d = [String: JSON]()
                d[".tag"] = .str("web_sessions_change_idle_length_policy")
                return .dictionary(d)
            case .dataResidencyMigrationRequestSuccessful:
                var d = [String: JSON]()
                d[".tag"] = .str("data_residency_migration_request_successful")
                return .dictionary(d)
            case .dataResidencyMigrationRequestUnsuccessful:
                var d = [String: JSON]()
                d[".tag"] = .str("data_residency_migration_request_unsuccessful")
                return .dictionary(d)
            case .teamMergeFrom:
                var d = [String: JSON]()
                d[".tag"] = .str("team_merge_from")
                return .dictionary(d)
            case .teamMergeTo:
                var d = [String: JSON]()
                d[".tag"] = .str("team_merge_to")
                return .dictionary(d)
            case .teamProfileAddBackground:
                var d = [String: JSON]()
                d[".tag"] = .str("team_profile_add_background")
                return .dictionary(d)
            case .teamProfileAddLogo:
                var d = [String: JSON]()
                d[".tag"] = .str("team_profile_add_logo")
                return .dictionary(d)
            case .teamProfileChangeBackground:
                var d = [String: JSON]()
                d[".tag"] = .str("team_profile_change_background")
                return .dictionary(d)
            case .teamProfileChangeDefaultLanguage:
                var d = [String: JSON]()
                d[".tag"] = .str("team_profile_change_default_language")
                return .dictionary(d)
            case .teamProfileChangeLogo:
                var d = [String: JSON]()
                d[".tag"] = .str("team_profile_change_logo")
                return .dictionary(d)
            case .teamProfileChangeName:
                var d = [String: JSON]()
                d[".tag"] = .str("team_profile_change_name")
                return .dictionary(d)
            case .teamProfileRemoveBackground:
                var d = [String: JSON]()
                d[".tag"] = .str("team_profile_remove_background")
                return .dictionary(d)
            case .teamProfileRemoveLogo:
                var d = [String: JSON]()
                d[".tag"] = .str("team_profile_remove_logo")
                return .dictionary(d)
            case .tfaAddBackupPhone:
                var d = [String: JSON]()
                d[".tag"] = .str("tfa_add_backup_phone")
                return .dictionary(d)
            case .tfaAddSecurityKey:
                var d = [String: JSON]()
                d[".tag"] = .str("tfa_add_security_key")
                return .dictionary(d)
            case .tfaChangeBackupPhone:
                var d = [String: JSON]()
                d[".tag"] = .str("tfa_change_backup_phone")
                return .dictionary(d)
            case .tfaChangeStatus:
                var d = [String: JSON]()
                d[".tag"] = .str("tfa_change_status")
                return .dictionary(d)
            case .tfaRemoveBackupPhone:
                var d = [String: JSON]()
                d[".tag"] = .str("tfa_remove_backup_phone")
                return .dictionary(d)
            case .tfaRemoveSecurityKey:
                var d = [String: JSON]()
                d[".tag"] = .str("tfa_remove_security_key")
                return .dictionary(d)
            case .tfaReset:
                var d = [String: JSON]()
                d[".tag"] = .str("tfa_reset")
                return .dictionary(d)
            case .changedEnterpriseAdminRole:
                var d = [String: JSON]()
                d[".tag"] = .str("changed_enterprise_admin_role")
                return .dictionary(d)
            case .changedEnterpriseConnectedTeamStatus:
                var d = [String: JSON]()
                d[".tag"] = .str("changed_enterprise_connected_team_status")
                return .dictionary(d)
            case .endedEnterpriseAdminSession:
                var d = [String: JSON]()
                d[".tag"] = .str("ended_enterprise_admin_session")
                return .dictionary(d)
            case .endedEnterpriseAdminSessionDeprecated:
                var d = [String: JSON]()
                d[".tag"] = .str("ended_enterprise_admin_session_deprecated")
                return .dictionary(d)
            case .enterpriseSettingsLocking:
                var d = [String: JSON]()
                d[".tag"] = .str("enterprise_settings_locking")
                return .dictionary(d)
            case .guestAdminChangeStatus:
                var d = [String: JSON]()
                d[".tag"] = .str("guest_admin_change_status")
                return .dictionary(d)
            case .startedEnterpriseAdminSession:
                var d = [String: JSON]()
                d[".tag"] = .str("started_enterprise_admin_session")
                return .dictionary(d)
            case .teamMergeRequestAccepted:
                var d = [String: JSON]()
                d[".tag"] = .str("team_merge_request_accepted")
                return .dictionary(d)
            case .teamMergeRequestAcceptedShownToPrimaryTeam:
                var d = [String: JSON]()
                d[".tag"] = .str("team_merge_request_accepted_shown_to_primary_team")
                return .dictionary(d)
            case .teamMergeRequestAcceptedShownToSecondaryTeam:
                var d = [String: JSON]()
                d[".tag"] = .str("team_merge_request_accepted_shown_to_secondary_team")
                return .dictionary(d)
            case .teamMergeRequestAutoCanceled:
                var d = [String: JSON]()
                d[".tag"] = .str("team_merge_request_auto_canceled")
                return .dictionary(d)
            case .teamMergeRequestCanceled:
                var d = [String: JSON]()
                d[".tag"] = .str("team_merge_request_canceled")
                return .dictionary(d)
            case .teamMergeRequestCanceledShownToPrimaryTeam:
                var d = [String: JSON]()
                d[".tag"] = .str("team_merge_request_canceled_shown_to_primary_team")
                return .dictionary(d)
            case .teamMergeRequestCanceledShownToSecondaryTeam:
                var d = [String: JSON]()
                d[".tag"] = .str("team_merge_request_canceled_shown_to_secondary_team")
                return .dictionary(d)
            case .teamMergeRequestExpired:
                var d = [String: JSON]()
                d[".tag"] = .str("team_merge_request_expired")
                return .dictionary(d)
            case .teamMergeRequestExpiredShownToPrimaryTeam:
                var d = [String: JSON]()
                d[".tag"] = .str("team_merge_request_expired_shown_to_primary_team")
                return .dictionary(d)
            case .teamMergeRequestExpiredShownToSecondaryTeam:
                var d = [String: JSON]()
                d[".tag"] = .str("team_merge_request_expired_shown_to_secondary_team")
                return .dictionary(d)
            case .teamMergeRequestRejectedShownToPrimaryTeam:
                var d = [String: JSON]()
                d[".tag"] = .str("team_merge_request_rejected_shown_to_primary_team")
                return .dictionary(d)
            case .teamMergeRequestRejectedShownToSecondaryTeam:
                var d = [String: JSON]()
                d[".tag"] = .str("team_merge_request_rejected_shown_to_secondary_team")
                return .dictionary(d)
            case .teamMergeRequestReminder:
                var d = [String: JSON]()
                d[".tag"] = .str("team_merge_request_reminder")
                return .dictionary(d)
            case .teamMergeRequestReminderShownToPrimaryTeam:
                var d = [String: JSON]()
                d[".tag"] = .str("team_merge_request_reminder_shown_to_primary_team")
                return .dictionary(d)
            case .teamMergeRequestReminderShownToSecondaryTeam:
                var d = [String: JSON]()
                d[".tag"] = .str("team_merge_request_reminder_shown_to_secondary_team")
                return .dictionary(d)
            case .teamMergeRequestRevoked:
                var d = [String: JSON]()
                d[".tag"] = .str("team_merge_request_revoked")
                return .dictionary(d)
            case .teamMergeRequestSentShownToPrimaryTeam:
                var d = [String: JSON]()
                d[".tag"] = .str("team_merge_request_sent_shown_to_primary_team")
                return .dictionary(d)
            case .teamMergeRequestSentShownToSecondaryTeam:
                var d = [String: JSON]()
                d[".tag"] = .str("team_merge_request_sent_shown_to_secondary_team")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> EventTypeArg {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "admin_alerting_alert_state_changed":
                    return EventTypeArg.adminAlertingAlertStateChanged
                case "admin_alerting_changed_alert_config":
                    return EventTypeArg.adminAlertingChangedAlertConfig
                case "admin_alerting_triggered_alert":
                    return EventTypeArg.adminAlertingTriggeredAlert
                case "ransomware_restore_process_completed":
                    return EventTypeArg.ransomwareRestoreProcessCompleted
                case "ransomware_restore_process_started":
                    return EventTypeArg.ransomwareRestoreProcessStarted
                case "app_blocked_by_permissions":
                    return EventTypeArg.appBlockedByPermissions
                case "app_link_team":
                    return EventTypeArg.appLinkTeam
                case "app_link_user":
                    return EventTypeArg.appLinkUser
                case "app_unlink_team":
                    return EventTypeArg.appUnlinkTeam
                case "app_unlink_user":
                    return EventTypeArg.appUnlinkUser
                case "integration_connected":
                    return EventTypeArg.integrationConnected
                case "integration_disconnected":
                    return EventTypeArg.integrationDisconnected
                case "file_add_comment":
                    return EventTypeArg.fileAddComment
                case "file_change_comment_subscription":
                    return EventTypeArg.fileChangeCommentSubscription
                case "file_delete_comment":
                    return EventTypeArg.fileDeleteComment
                case "file_edit_comment":
                    return EventTypeArg.fileEditComment
                case "file_like_comment":
                    return EventTypeArg.fileLikeComment
                case "file_resolve_comment":
                    return EventTypeArg.fileResolveComment
                case "file_unlike_comment":
                    return EventTypeArg.fileUnlikeComment
                case "file_unresolve_comment":
                    return EventTypeArg.fileUnresolveComment
                case "governance_policy_add_folders":
                    return EventTypeArg.governancePolicyAddFolders
                case "governance_policy_add_folder_failed":
                    return EventTypeArg.governancePolicyAddFolderFailed
                case "governance_policy_content_disposed":
                    return EventTypeArg.governancePolicyContentDisposed
                case "governance_policy_create":
                    return EventTypeArg.governancePolicyCreate
                case "governance_policy_delete":
                    return EventTypeArg.governancePolicyDelete
                case "governance_policy_edit_details":
                    return EventTypeArg.governancePolicyEditDetails
                case "governance_policy_edit_duration":
                    return EventTypeArg.governancePolicyEditDuration
                case "governance_policy_export_created":
                    return EventTypeArg.governancePolicyExportCreated
                case "governance_policy_export_removed":
                    return EventTypeArg.governancePolicyExportRemoved
                case "governance_policy_remove_folders":
                    return EventTypeArg.governancePolicyRemoveFolders
                case "governance_policy_report_created":
                    return EventTypeArg.governancePolicyReportCreated
                case "governance_policy_zip_part_downloaded":
                    return EventTypeArg.governancePolicyZipPartDownloaded
                case "legal_holds_activate_a_hold":
                    return EventTypeArg.legalHoldsActivateAHold
                case "legal_holds_add_members":
                    return EventTypeArg.legalHoldsAddMembers
                case "legal_holds_change_hold_details":
                    return EventTypeArg.legalHoldsChangeHoldDetails
                case "legal_holds_change_hold_name":
                    return EventTypeArg.legalHoldsChangeHoldName
                case "legal_holds_export_a_hold":
                    return EventTypeArg.legalHoldsExportAHold
                case "legal_holds_export_cancelled":
                    return EventTypeArg.legalHoldsExportCancelled
                case "legal_holds_export_downloaded":
                    return EventTypeArg.legalHoldsExportDownloaded
                case "legal_holds_export_removed":
                    return EventTypeArg.legalHoldsExportRemoved
                case "legal_holds_release_a_hold":
                    return EventTypeArg.legalHoldsReleaseAHold
                case "legal_holds_remove_members":
                    return EventTypeArg.legalHoldsRemoveMembers
                case "legal_holds_report_a_hold":
                    return EventTypeArg.legalHoldsReportAHold
                case "device_change_ip_desktop":
                    return EventTypeArg.deviceChangeIpDesktop
                case "device_change_ip_mobile":
                    return EventTypeArg.deviceChangeIpMobile
                case "device_change_ip_web":
                    return EventTypeArg.deviceChangeIpWeb
                case "device_delete_on_unlink_fail":
                    return EventTypeArg.deviceDeleteOnUnlinkFail
                case "device_delete_on_unlink_success":
                    return EventTypeArg.deviceDeleteOnUnlinkSuccess
                case "device_link_fail":
                    return EventTypeArg.deviceLinkFail
                case "device_link_success":
                    return EventTypeArg.deviceLinkSuccess
                case "device_management_disabled":
                    return EventTypeArg.deviceManagementDisabled
                case "device_management_enabled":
                    return EventTypeArg.deviceManagementEnabled
                case "device_sync_backup_status_changed":
                    return EventTypeArg.deviceSyncBackupStatusChanged
                case "device_unlink":
                    return EventTypeArg.deviceUnlink
                case "dropbox_passwords_exported":
                    return EventTypeArg.dropboxPasswordsExported
                case "dropbox_passwords_new_device_enrolled":
                    return EventTypeArg.dropboxPasswordsNewDeviceEnrolled
                case "emm_refresh_auth_token":
                    return EventTypeArg.emmRefreshAuthToken
                case "external_drive_backup_eligibility_status_checked":
                    return EventTypeArg.externalDriveBackupEligibilityStatusChecked
                case "external_drive_backup_status_changed":
                    return EventTypeArg.externalDriveBackupStatusChanged
                case "account_capture_change_availability":
                    return EventTypeArg.accountCaptureChangeAvailability
                case "account_capture_migrate_account":
                    return EventTypeArg.accountCaptureMigrateAccount
                case "account_capture_notification_emails_sent":
                    return EventTypeArg.accountCaptureNotificationEmailsSent
                case "account_capture_relinquish_account":
                    return EventTypeArg.accountCaptureRelinquishAccount
                case "disabled_domain_invites":
                    return EventTypeArg.disabledDomainInvites
                case "domain_invites_approve_request_to_join_team":
                    return EventTypeArg.domainInvitesApproveRequestToJoinTeam
                case "domain_invites_decline_request_to_join_team":
                    return EventTypeArg.domainInvitesDeclineRequestToJoinTeam
                case "domain_invites_email_existing_users":
                    return EventTypeArg.domainInvitesEmailExistingUsers
                case "domain_invites_request_to_join_team":
                    return EventTypeArg.domainInvitesRequestToJoinTeam
                case "domain_invites_set_invite_new_user_pref_to_no":
                    return EventTypeArg.domainInvitesSetInviteNewUserPrefToNo
                case "domain_invites_set_invite_new_user_pref_to_yes":
                    return EventTypeArg.domainInvitesSetInviteNewUserPrefToYes
                case "domain_verification_add_domain_fail":
                    return EventTypeArg.domainVerificationAddDomainFail
                case "domain_verification_add_domain_success":
                    return EventTypeArg.domainVerificationAddDomainSuccess
                case "domain_verification_remove_domain":
                    return EventTypeArg.domainVerificationRemoveDomain
                case "enabled_domain_invites":
                    return EventTypeArg.enabledDomainInvites
                case "team_encryption_key_cancel_key_deletion":
                    return EventTypeArg.teamEncryptionKeyCancelKeyDeletion
                case "team_encryption_key_create_key":
                    return EventTypeArg.teamEncryptionKeyCreateKey
                case "team_encryption_key_delete_key":
                    return EventTypeArg.teamEncryptionKeyDeleteKey
                case "team_encryption_key_disable_key":
                    return EventTypeArg.teamEncryptionKeyDisableKey
                case "team_encryption_key_enable_key":
                    return EventTypeArg.teamEncryptionKeyEnableKey
                case "team_encryption_key_rotate_key":
                    return EventTypeArg.teamEncryptionKeyRotateKey
                case "team_encryption_key_schedule_key_deletion":
                    return EventTypeArg.teamEncryptionKeyScheduleKeyDeletion
                case "apply_naming_convention":
                    return EventTypeArg.applyNamingConvention
                case "create_folder":
                    return EventTypeArg.createFolder
                case "file_add":
                    return EventTypeArg.fileAdd
                case "file_add_from_automation":
                    return EventTypeArg.fileAddFromAutomation
                case "file_copy":
                    return EventTypeArg.fileCopy
                case "file_delete":
                    return EventTypeArg.fileDelete
                case "file_download":
                    return EventTypeArg.fileDownload
                case "file_edit":
                    return EventTypeArg.fileEdit
                case "file_get_copy_reference":
                    return EventTypeArg.fileGetCopyReference
                case "file_locking_lock_status_changed":
                    return EventTypeArg.fileLockingLockStatusChanged
                case "file_move":
                    return EventTypeArg.fileMove
                case "file_permanently_delete":
                    return EventTypeArg.filePermanentlyDelete
                case "file_preview":
                    return EventTypeArg.filePreview
                case "file_rename":
                    return EventTypeArg.fileRename
                case "file_restore":
                    return EventTypeArg.fileRestore
                case "file_revert":
                    return EventTypeArg.fileRevert
                case "file_rollback_changes":
                    return EventTypeArg.fileRollbackChanges
                case "file_save_copy_reference":
                    return EventTypeArg.fileSaveCopyReference
                case "folder_overview_description_changed":
                    return EventTypeArg.folderOverviewDescriptionChanged
                case "folder_overview_item_pinned":
                    return EventTypeArg.folderOverviewItemPinned
                case "folder_overview_item_unpinned":
                    return EventTypeArg.folderOverviewItemUnpinned
                case "object_label_added":
                    return EventTypeArg.objectLabelAdded
                case "object_label_removed":
                    return EventTypeArg.objectLabelRemoved
                case "object_label_updated_value":
                    return EventTypeArg.objectLabelUpdatedValue
                case "organize_folder_with_tidy":
                    return EventTypeArg.organizeFolderWithTidy
                case "replay_file_delete":
                    return EventTypeArg.replayFileDelete
                case "rewind_folder":
                    return EventTypeArg.rewindFolder
                case "undo_naming_convention":
                    return EventTypeArg.undoNamingConvention
                case "undo_organize_folder_with_tidy":
                    return EventTypeArg.undoOrganizeFolderWithTidy
                case "user_tags_added":
                    return EventTypeArg.userTagsAdded
                case "user_tags_removed":
                    return EventTypeArg.userTagsRemoved
                case "email_ingest_receive_file":
                    return EventTypeArg.emailIngestReceiveFile
                case "file_request_change":
                    return EventTypeArg.fileRequestChange
                case "file_request_close":
                    return EventTypeArg.fileRequestClose
                case "file_request_create":
                    return EventTypeArg.fileRequestCreate
                case "file_request_delete":
                    return EventTypeArg.fileRequestDelete
                case "file_request_receive_file":
                    return EventTypeArg.fileRequestReceiveFile
                case "group_add_external_id":
                    return EventTypeArg.groupAddExternalId
                case "group_add_member":
                    return EventTypeArg.groupAddMember
                case "group_change_external_id":
                    return EventTypeArg.groupChangeExternalId
                case "group_change_management_type":
                    return EventTypeArg.groupChangeManagementType
                case "group_change_member_role":
                    return EventTypeArg.groupChangeMemberRole
                case "group_create":
                    return EventTypeArg.groupCreate
                case "group_delete":
                    return EventTypeArg.groupDelete
                case "group_description_updated":
                    return EventTypeArg.groupDescriptionUpdated
                case "group_join_policy_updated":
                    return EventTypeArg.groupJoinPolicyUpdated
                case "group_moved":
                    return EventTypeArg.groupMoved
                case "group_remove_external_id":
                    return EventTypeArg.groupRemoveExternalId
                case "group_remove_member":
                    return EventTypeArg.groupRemoveMember
                case "group_rename":
                    return EventTypeArg.groupRename
                case "account_lock_or_unlocked":
                    return EventTypeArg.accountLockOrUnlocked
                case "emm_error":
                    return EventTypeArg.emmError
                case "guest_admin_signed_in_via_trusted_teams":
                    return EventTypeArg.guestAdminSignedInViaTrustedTeams
                case "guest_admin_signed_out_via_trusted_teams":
                    return EventTypeArg.guestAdminSignedOutViaTrustedTeams
                case "login_fail":
                    return EventTypeArg.loginFail
                case "login_success":
                    return EventTypeArg.loginSuccess
                case "logout":
                    return EventTypeArg.logout
                case "reseller_support_session_end":
                    return EventTypeArg.resellerSupportSessionEnd
                case "reseller_support_session_start":
                    return EventTypeArg.resellerSupportSessionStart
                case "sign_in_as_session_end":
                    return EventTypeArg.signInAsSessionEnd
                case "sign_in_as_session_start":
                    return EventTypeArg.signInAsSessionStart
                case "sso_error":
                    return EventTypeArg.ssoError
                case "backup_admin_invitation_sent":
                    return EventTypeArg.backupAdminInvitationSent
                case "backup_invitation_opened":
                    return EventTypeArg.backupInvitationOpened
                case "create_team_invite_link":
                    return EventTypeArg.createTeamInviteLink
                case "delete_team_invite_link":
                    return EventTypeArg.deleteTeamInviteLink
                case "member_add_external_id":
                    return EventTypeArg.memberAddExternalId
                case "member_add_name":
                    return EventTypeArg.memberAddName
                case "member_change_admin_role":
                    return EventTypeArg.memberChangeAdminRole
                case "member_change_email":
                    return EventTypeArg.memberChangeEmail
                case "member_change_external_id":
                    return EventTypeArg.memberChangeExternalId
                case "member_change_membership_type":
                    return EventTypeArg.memberChangeMembershipType
                case "member_change_name":
                    return EventTypeArg.memberChangeName
                case "member_change_reseller_role":
                    return EventTypeArg.memberChangeResellerRole
                case "member_change_status":
                    return EventTypeArg.memberChangeStatus
                case "member_delete_manual_contacts":
                    return EventTypeArg.memberDeleteManualContacts
                case "member_delete_profile_photo":
                    return EventTypeArg.memberDeleteProfilePhoto
                case "member_permanently_delete_account_contents":
                    return EventTypeArg.memberPermanentlyDeleteAccountContents
                case "member_remove_external_id":
                    return EventTypeArg.memberRemoveExternalId
                case "member_set_profile_photo":
                    return EventTypeArg.memberSetProfilePhoto
                case "member_space_limits_add_custom_quota":
                    return EventTypeArg.memberSpaceLimitsAddCustomQuota
                case "member_space_limits_change_custom_quota":
                    return EventTypeArg.memberSpaceLimitsChangeCustomQuota
                case "member_space_limits_change_status":
                    return EventTypeArg.memberSpaceLimitsChangeStatus
                case "member_space_limits_remove_custom_quota":
                    return EventTypeArg.memberSpaceLimitsRemoveCustomQuota
                case "member_suggest":
                    return EventTypeArg.memberSuggest
                case "member_transfer_account_contents":
                    return EventTypeArg.memberTransferAccountContents
                case "pending_secondary_email_added":
                    return EventTypeArg.pendingSecondaryEmailAdded
                case "secondary_email_deleted":
                    return EventTypeArg.secondaryEmailDeleted
                case "secondary_email_verified":
                    return EventTypeArg.secondaryEmailVerified
                case "secondary_mails_policy_changed":
                    return EventTypeArg.secondaryMailsPolicyChanged
                case "binder_add_page":
                    return EventTypeArg.binderAddPage
                case "binder_add_section":
                    return EventTypeArg.binderAddSection
                case "binder_remove_page":
                    return EventTypeArg.binderRemovePage
                case "binder_remove_section":
                    return EventTypeArg.binderRemoveSection
                case "binder_rename_page":
                    return EventTypeArg.binderRenamePage
                case "binder_rename_section":
                    return EventTypeArg.binderRenameSection
                case "binder_reorder_page":
                    return EventTypeArg.binderReorderPage
                case "binder_reorder_section":
                    return EventTypeArg.binderReorderSection
                case "paper_content_add_member":
                    return EventTypeArg.paperContentAddMember
                case "paper_content_add_to_folder":
                    return EventTypeArg.paperContentAddToFolder
                case "paper_content_archive":
                    return EventTypeArg.paperContentArchive
                case "paper_content_create":
                    return EventTypeArg.paperContentCreate
                case "paper_content_permanently_delete":
                    return EventTypeArg.paperContentPermanentlyDelete
                case "paper_content_remove_from_folder":
                    return EventTypeArg.paperContentRemoveFromFolder
                case "paper_content_remove_member":
                    return EventTypeArg.paperContentRemoveMember
                case "paper_content_rename":
                    return EventTypeArg.paperContentRename
                case "paper_content_restore":
                    return EventTypeArg.paperContentRestore
                case "paper_doc_add_comment":
                    return EventTypeArg.paperDocAddComment
                case "paper_doc_change_member_role":
                    return EventTypeArg.paperDocChangeMemberRole
                case "paper_doc_change_sharing_policy":
                    return EventTypeArg.paperDocChangeSharingPolicy
                case "paper_doc_change_subscription":
                    return EventTypeArg.paperDocChangeSubscription
                case "paper_doc_deleted":
                    return EventTypeArg.paperDocDeleted
                case "paper_doc_delete_comment":
                    return EventTypeArg.paperDocDeleteComment
                case "paper_doc_download":
                    return EventTypeArg.paperDocDownload
                case "paper_doc_edit":
                    return EventTypeArg.paperDocEdit
                case "paper_doc_edit_comment":
                    return EventTypeArg.paperDocEditComment
                case "paper_doc_followed":
                    return EventTypeArg.paperDocFollowed
                case "paper_doc_mention":
                    return EventTypeArg.paperDocMention
                case "paper_doc_ownership_changed":
                    return EventTypeArg.paperDocOwnershipChanged
                case "paper_doc_request_access":
                    return EventTypeArg.paperDocRequestAccess
                case "paper_doc_resolve_comment":
                    return EventTypeArg.paperDocResolveComment
                case "paper_doc_revert":
                    return EventTypeArg.paperDocRevert
                case "paper_doc_slack_share":
                    return EventTypeArg.paperDocSlackShare
                case "paper_doc_team_invite":
                    return EventTypeArg.paperDocTeamInvite
                case "paper_doc_trashed":
                    return EventTypeArg.paperDocTrashed
                case "paper_doc_unresolve_comment":
                    return EventTypeArg.paperDocUnresolveComment
                case "paper_doc_untrashed":
                    return EventTypeArg.paperDocUntrashed
                case "paper_doc_view":
                    return EventTypeArg.paperDocView
                case "paper_external_view_allow":
                    return EventTypeArg.paperExternalViewAllow
                case "paper_external_view_default_team":
                    return EventTypeArg.paperExternalViewDefaultTeam
                case "paper_external_view_forbid":
                    return EventTypeArg.paperExternalViewForbid
                case "paper_folder_change_subscription":
                    return EventTypeArg.paperFolderChangeSubscription
                case "paper_folder_deleted":
                    return EventTypeArg.paperFolderDeleted
                case "paper_folder_followed":
                    return EventTypeArg.paperFolderFollowed
                case "paper_folder_team_invite":
                    return EventTypeArg.paperFolderTeamInvite
                case "paper_published_link_change_permission":
                    return EventTypeArg.paperPublishedLinkChangePermission
                case "paper_published_link_create":
                    return EventTypeArg.paperPublishedLinkCreate
                case "paper_published_link_disabled":
                    return EventTypeArg.paperPublishedLinkDisabled
                case "paper_published_link_view":
                    return EventTypeArg.paperPublishedLinkView
                case "password_change":
                    return EventTypeArg.passwordChange
                case "password_reset":
                    return EventTypeArg.passwordReset
                case "password_reset_all":
                    return EventTypeArg.passwordResetAll
                case "classification_create_report":
                    return EventTypeArg.classificationCreateReport
                case "classification_create_report_fail":
                    return EventTypeArg.classificationCreateReportFail
                case "emm_create_exceptions_report":
                    return EventTypeArg.emmCreateExceptionsReport
                case "emm_create_usage_report":
                    return EventTypeArg.emmCreateUsageReport
                case "export_members_report":
                    return EventTypeArg.exportMembersReport
                case "export_members_report_fail":
                    return EventTypeArg.exportMembersReportFail
                case "external_sharing_create_report":
                    return EventTypeArg.externalSharingCreateReport
                case "external_sharing_report_failed":
                    return EventTypeArg.externalSharingReportFailed
                case "no_expiration_link_gen_create_report":
                    return EventTypeArg.noExpirationLinkGenCreateReport
                case "no_expiration_link_gen_report_failed":
                    return EventTypeArg.noExpirationLinkGenReportFailed
                case "no_password_link_gen_create_report":
                    return EventTypeArg.noPasswordLinkGenCreateReport
                case "no_password_link_gen_report_failed":
                    return EventTypeArg.noPasswordLinkGenReportFailed
                case "no_password_link_view_create_report":
                    return EventTypeArg.noPasswordLinkViewCreateReport
                case "no_password_link_view_report_failed":
                    return EventTypeArg.noPasswordLinkViewReportFailed
                case "outdated_link_view_create_report":
                    return EventTypeArg.outdatedLinkViewCreateReport
                case "outdated_link_view_report_failed":
                    return EventTypeArg.outdatedLinkViewReportFailed
                case "paper_admin_export_start":
                    return EventTypeArg.paperAdminExportStart
                case "ransomware_alert_create_report":
                    return EventTypeArg.ransomwareAlertCreateReport
                case "ransomware_alert_create_report_failed":
                    return EventTypeArg.ransomwareAlertCreateReportFailed
                case "smart_sync_create_admin_privilege_report":
                    return EventTypeArg.smartSyncCreateAdminPrivilegeReport
                case "team_activity_create_report":
                    return EventTypeArg.teamActivityCreateReport
                case "team_activity_create_report_fail":
                    return EventTypeArg.teamActivityCreateReportFail
                case "collection_share":
                    return EventTypeArg.collectionShare
                case "file_transfers_file_add":
                    return EventTypeArg.fileTransfersFileAdd
                case "file_transfers_transfer_delete":
                    return EventTypeArg.fileTransfersTransferDelete
                case "file_transfers_transfer_download":
                    return EventTypeArg.fileTransfersTransferDownload
                case "file_transfers_transfer_send":
                    return EventTypeArg.fileTransfersTransferSend
                case "file_transfers_transfer_view":
                    return EventTypeArg.fileTransfersTransferView
                case "note_acl_invite_only":
                    return EventTypeArg.noteAclInviteOnly
                case "note_acl_link":
                    return EventTypeArg.noteAclLink
                case "note_acl_team_link":
                    return EventTypeArg.noteAclTeamLink
                case "note_shared":
                    return EventTypeArg.noteShared
                case "note_share_receive":
                    return EventTypeArg.noteShareReceive
                case "open_note_shared":
                    return EventTypeArg.openNoteShared
                case "replay_file_shared_link_created":
                    return EventTypeArg.replayFileSharedLinkCreated
                case "replay_file_shared_link_modified":
                    return EventTypeArg.replayFileSharedLinkModified
                case "replay_project_team_add":
                    return EventTypeArg.replayProjectTeamAdd
                case "replay_project_team_delete":
                    return EventTypeArg.replayProjectTeamDelete
                case "sf_add_group":
                    return EventTypeArg.sfAddGroup
                case "sf_allow_non_members_to_view_shared_links":
                    return EventTypeArg.sfAllowNonMembersToViewSharedLinks
                case "sf_external_invite_warn":
                    return EventTypeArg.sfExternalInviteWarn
                case "sf_fb_invite":
                    return EventTypeArg.sfFbInvite
                case "sf_fb_invite_change_role":
                    return EventTypeArg.sfFbInviteChangeRole
                case "sf_fb_uninvite":
                    return EventTypeArg.sfFbUninvite
                case "sf_invite_group":
                    return EventTypeArg.sfInviteGroup
                case "sf_team_grant_access":
                    return EventTypeArg.sfTeamGrantAccess
                case "sf_team_invite":
                    return EventTypeArg.sfTeamInvite
                case "sf_team_invite_change_role":
                    return EventTypeArg.sfTeamInviteChangeRole
                case "sf_team_join":
                    return EventTypeArg.sfTeamJoin
                case "sf_team_join_from_oob_link":
                    return EventTypeArg.sfTeamJoinFromOobLink
                case "sf_team_uninvite":
                    return EventTypeArg.sfTeamUninvite
                case "shared_content_add_invitees":
                    return EventTypeArg.sharedContentAddInvitees
                case "shared_content_add_link_expiry":
                    return EventTypeArg.sharedContentAddLinkExpiry
                case "shared_content_add_link_password":
                    return EventTypeArg.sharedContentAddLinkPassword
                case "shared_content_add_member":
                    return EventTypeArg.sharedContentAddMember
                case "shared_content_change_downloads_policy":
                    return EventTypeArg.sharedContentChangeDownloadsPolicy
                case "shared_content_change_invitee_role":
                    return EventTypeArg.sharedContentChangeInviteeRole
                case "shared_content_change_link_audience":
                    return EventTypeArg.sharedContentChangeLinkAudience
                case "shared_content_change_link_expiry":
                    return EventTypeArg.sharedContentChangeLinkExpiry
                case "shared_content_change_link_password":
                    return EventTypeArg.sharedContentChangeLinkPassword
                case "shared_content_change_member_role":
                    return EventTypeArg.sharedContentChangeMemberRole
                case "shared_content_change_viewer_info_policy":
                    return EventTypeArg.sharedContentChangeViewerInfoPolicy
                case "shared_content_claim_invitation":
                    return EventTypeArg.sharedContentClaimInvitation
                case "shared_content_copy":
                    return EventTypeArg.sharedContentCopy
                case "shared_content_download":
                    return EventTypeArg.sharedContentDownload
                case "shared_content_relinquish_membership":
                    return EventTypeArg.sharedContentRelinquishMembership
                case "shared_content_remove_invitees":
                    return EventTypeArg.sharedContentRemoveInvitees
                case "shared_content_remove_link_expiry":
                    return EventTypeArg.sharedContentRemoveLinkExpiry
                case "shared_content_remove_link_password":
                    return EventTypeArg.sharedContentRemoveLinkPassword
                case "shared_content_remove_member":
                    return EventTypeArg.sharedContentRemoveMember
                case "shared_content_request_access":
                    return EventTypeArg.sharedContentRequestAccess
                case "shared_content_restore_invitees":
                    return EventTypeArg.sharedContentRestoreInvitees
                case "shared_content_restore_member":
                    return EventTypeArg.sharedContentRestoreMember
                case "shared_content_unshare":
                    return EventTypeArg.sharedContentUnshare
                case "shared_content_view":
                    return EventTypeArg.sharedContentView
                case "shared_folder_change_link_policy":
                    return EventTypeArg.sharedFolderChangeLinkPolicy
                case "shared_folder_change_members_inheritance_policy":
                    return EventTypeArg.sharedFolderChangeMembersInheritancePolicy
                case "shared_folder_change_members_management_policy":
                    return EventTypeArg.sharedFolderChangeMembersManagementPolicy
                case "shared_folder_change_members_policy":
                    return EventTypeArg.sharedFolderChangeMembersPolicy
                case "shared_folder_create":
                    return EventTypeArg.sharedFolderCreate
                case "shared_folder_decline_invitation":
                    return EventTypeArg.sharedFolderDeclineInvitation
                case "shared_folder_mount":
                    return EventTypeArg.sharedFolderMount
                case "shared_folder_nest":
                    return EventTypeArg.sharedFolderNest
                case "shared_folder_transfer_ownership":
                    return EventTypeArg.sharedFolderTransferOwnership
                case "shared_folder_unmount":
                    return EventTypeArg.sharedFolderUnmount
                case "shared_link_add_expiry":
                    return EventTypeArg.sharedLinkAddExpiry
                case "shared_link_change_expiry":
                    return EventTypeArg.sharedLinkChangeExpiry
                case "shared_link_change_visibility":
                    return EventTypeArg.sharedLinkChangeVisibility
                case "shared_link_copy":
                    return EventTypeArg.sharedLinkCopy
                case "shared_link_create":
                    return EventTypeArg.sharedLinkCreate
                case "shared_link_disable":
                    return EventTypeArg.sharedLinkDisable
                case "shared_link_download":
                    return EventTypeArg.sharedLinkDownload
                case "shared_link_remove_expiry":
                    return EventTypeArg.sharedLinkRemoveExpiry
                case "shared_link_settings_add_expiration":
                    return EventTypeArg.sharedLinkSettingsAddExpiration
                case "shared_link_settings_add_password":
                    return EventTypeArg.sharedLinkSettingsAddPassword
                case "shared_link_settings_allow_download_disabled":
                    return EventTypeArg.sharedLinkSettingsAllowDownloadDisabled
                case "shared_link_settings_allow_download_enabled":
                    return EventTypeArg.sharedLinkSettingsAllowDownloadEnabled
                case "shared_link_settings_change_audience":
                    return EventTypeArg.sharedLinkSettingsChangeAudience
                case "shared_link_settings_change_expiration":
                    return EventTypeArg.sharedLinkSettingsChangeExpiration
                case "shared_link_settings_change_password":
                    return EventTypeArg.sharedLinkSettingsChangePassword
                case "shared_link_settings_remove_expiration":
                    return EventTypeArg.sharedLinkSettingsRemoveExpiration
                case "shared_link_settings_remove_password":
                    return EventTypeArg.sharedLinkSettingsRemovePassword
                case "shared_link_share":
                    return EventTypeArg.sharedLinkShare
                case "shared_link_view":
                    return EventTypeArg.sharedLinkView
                case "shared_note_opened":
                    return EventTypeArg.sharedNoteOpened
                case "shmodel_disable_downloads":
                    return EventTypeArg.shmodelDisableDownloads
                case "shmodel_enable_downloads":
                    return EventTypeArg.shmodelEnableDownloads
                case "shmodel_group_share":
                    return EventTypeArg.shmodelGroupShare
                case "showcase_access_granted":
                    return EventTypeArg.showcaseAccessGranted
                case "showcase_add_member":
                    return EventTypeArg.showcaseAddMember
                case "showcase_archived":
                    return EventTypeArg.showcaseArchived
                case "showcase_created":
                    return EventTypeArg.showcaseCreated
                case "showcase_delete_comment":
                    return EventTypeArg.showcaseDeleteComment
                case "showcase_edited":
                    return EventTypeArg.showcaseEdited
                case "showcase_edit_comment":
                    return EventTypeArg.showcaseEditComment
                case "showcase_file_added":
                    return EventTypeArg.showcaseFileAdded
                case "showcase_file_download":
                    return EventTypeArg.showcaseFileDownload
                case "showcase_file_removed":
                    return EventTypeArg.showcaseFileRemoved
                case "showcase_file_view":
                    return EventTypeArg.showcaseFileView
                case "showcase_permanently_deleted":
                    return EventTypeArg.showcasePermanentlyDeleted
                case "showcase_post_comment":
                    return EventTypeArg.showcasePostComment
                case "showcase_remove_member":
                    return EventTypeArg.showcaseRemoveMember
                case "showcase_renamed":
                    return EventTypeArg.showcaseRenamed
                case "showcase_request_access":
                    return EventTypeArg.showcaseRequestAccess
                case "showcase_resolve_comment":
                    return EventTypeArg.showcaseResolveComment
                case "showcase_restored":
                    return EventTypeArg.showcaseRestored
                case "showcase_trashed":
                    return EventTypeArg.showcaseTrashed
                case "showcase_trashed_deprecated":
                    return EventTypeArg.showcaseTrashedDeprecated
                case "showcase_unresolve_comment":
                    return EventTypeArg.showcaseUnresolveComment
                case "showcase_untrashed":
                    return EventTypeArg.showcaseUntrashed
                case "showcase_untrashed_deprecated":
                    return EventTypeArg.showcaseUntrashedDeprecated
                case "showcase_view":
                    return EventTypeArg.showcaseView
                case "sso_add_cert":
                    return EventTypeArg.ssoAddCert
                case "sso_add_login_url":
                    return EventTypeArg.ssoAddLoginUrl
                case "sso_add_logout_url":
                    return EventTypeArg.ssoAddLogoutUrl
                case "sso_change_cert":
                    return EventTypeArg.ssoChangeCert
                case "sso_change_login_url":
                    return EventTypeArg.ssoChangeLoginUrl
                case "sso_change_logout_url":
                    return EventTypeArg.ssoChangeLogoutUrl
                case "sso_change_saml_identity_mode":
                    return EventTypeArg.ssoChangeSamlIdentityMode
                case "sso_remove_cert":
                    return EventTypeArg.ssoRemoveCert
                case "sso_remove_login_url":
                    return EventTypeArg.ssoRemoveLoginUrl
                case "sso_remove_logout_url":
                    return EventTypeArg.ssoRemoveLogoutUrl
                case "team_folder_change_status":
                    return EventTypeArg.teamFolderChangeStatus
                case "team_folder_create":
                    return EventTypeArg.teamFolderCreate
                case "team_folder_downgrade":
                    return EventTypeArg.teamFolderDowngrade
                case "team_folder_permanently_delete":
                    return EventTypeArg.teamFolderPermanentlyDelete
                case "team_folder_rename":
                    return EventTypeArg.teamFolderRename
                case "team_selective_sync_settings_changed":
                    return EventTypeArg.teamSelectiveSyncSettingsChanged
                case "account_capture_change_policy":
                    return EventTypeArg.accountCaptureChangePolicy
                case "admin_email_reminders_changed":
                    return EventTypeArg.adminEmailRemindersChanged
                case "allow_download_disabled":
                    return EventTypeArg.allowDownloadDisabled
                case "allow_download_enabled":
                    return EventTypeArg.allowDownloadEnabled
                case "app_permissions_changed":
                    return EventTypeArg.appPermissionsChanged
                case "camera_uploads_policy_changed":
                    return EventTypeArg.cameraUploadsPolicyChanged
                case "capture_transcript_policy_changed":
                    return EventTypeArg.captureTranscriptPolicyChanged
                case "classification_change_policy":
                    return EventTypeArg.classificationChangePolicy
                case "computer_backup_policy_changed":
                    return EventTypeArg.computerBackupPolicyChanged
                case "content_administration_policy_changed":
                    return EventTypeArg.contentAdministrationPolicyChanged
                case "data_placement_restriction_change_policy":
                    return EventTypeArg.dataPlacementRestrictionChangePolicy
                case "data_placement_restriction_satisfy_policy":
                    return EventTypeArg.dataPlacementRestrictionSatisfyPolicy
                case "device_approvals_add_exception":
                    return EventTypeArg.deviceApprovalsAddException
                case "device_approvals_change_desktop_policy":
                    return EventTypeArg.deviceApprovalsChangeDesktopPolicy
                case "device_approvals_change_mobile_policy":
                    return EventTypeArg.deviceApprovalsChangeMobilePolicy
                case "device_approvals_change_overage_action":
                    return EventTypeArg.deviceApprovalsChangeOverageAction
                case "device_approvals_change_unlink_action":
                    return EventTypeArg.deviceApprovalsChangeUnlinkAction
                case "device_approvals_remove_exception":
                    return EventTypeArg.deviceApprovalsRemoveException
                case "directory_restrictions_add_members":
                    return EventTypeArg.directoryRestrictionsAddMembers
                case "directory_restrictions_remove_members":
                    return EventTypeArg.directoryRestrictionsRemoveMembers
                case "dropbox_passwords_policy_changed":
                    return EventTypeArg.dropboxPasswordsPolicyChanged
                case "email_ingest_policy_changed":
                    return EventTypeArg.emailIngestPolicyChanged
                case "emm_add_exception":
                    return EventTypeArg.emmAddException
                case "emm_change_policy":
                    return EventTypeArg.emmChangePolicy
                case "emm_remove_exception":
                    return EventTypeArg.emmRemoveException
                case "extended_version_history_change_policy":
                    return EventTypeArg.extendedVersionHistoryChangePolicy
                case "external_drive_backup_policy_changed":
                    return EventTypeArg.externalDriveBackupPolicyChanged
                case "file_comments_change_policy":
                    return EventTypeArg.fileCommentsChangePolicy
                case "file_locking_policy_changed":
                    return EventTypeArg.fileLockingPolicyChanged
                case "file_provider_migration_policy_changed":
                    return EventTypeArg.fileProviderMigrationPolicyChanged
                case "file_requests_change_policy":
                    return EventTypeArg.fileRequestsChangePolicy
                case "file_requests_emails_enabled":
                    return EventTypeArg.fileRequestsEmailsEnabled
                case "file_requests_emails_restricted_to_team_only":
                    return EventTypeArg.fileRequestsEmailsRestrictedToTeamOnly
                case "file_transfers_policy_changed":
                    return EventTypeArg.fileTransfersPolicyChanged
                case "folder_link_restriction_policy_changed":
                    return EventTypeArg.folderLinkRestrictionPolicyChanged
                case "google_sso_change_policy":
                    return EventTypeArg.googleSsoChangePolicy
                case "group_user_management_change_policy":
                    return EventTypeArg.groupUserManagementChangePolicy
                case "integration_policy_changed":
                    return EventTypeArg.integrationPolicyChanged
                case "invite_acceptance_email_policy_changed":
                    return EventTypeArg.inviteAcceptanceEmailPolicyChanged
                case "member_requests_change_policy":
                    return EventTypeArg.memberRequestsChangePolicy
                case "member_send_invite_policy_changed":
                    return EventTypeArg.memberSendInvitePolicyChanged
                case "member_space_limits_add_exception":
                    return EventTypeArg.memberSpaceLimitsAddException
                case "member_space_limits_change_caps_type_policy":
                    return EventTypeArg.memberSpaceLimitsChangeCapsTypePolicy
                case "member_space_limits_change_policy":
                    return EventTypeArg.memberSpaceLimitsChangePolicy
                case "member_space_limits_remove_exception":
                    return EventTypeArg.memberSpaceLimitsRemoveException
                case "member_suggestions_change_policy":
                    return EventTypeArg.memberSuggestionsChangePolicy
                case "microsoft_office_addin_change_policy":
                    return EventTypeArg.microsoftOfficeAddinChangePolicy
                case "network_control_change_policy":
                    return EventTypeArg.networkControlChangePolicy
                case "paper_change_deployment_policy":
                    return EventTypeArg.paperChangeDeploymentPolicy
                case "paper_change_member_link_policy":
                    return EventTypeArg.paperChangeMemberLinkPolicy
                case "paper_change_member_policy":
                    return EventTypeArg.paperChangeMemberPolicy
                case "paper_change_policy":
                    return EventTypeArg.paperChangePolicy
                case "paper_default_folder_policy_changed":
                    return EventTypeArg.paperDefaultFolderPolicyChanged
                case "paper_desktop_policy_changed":
                    return EventTypeArg.paperDesktopPolicyChanged
                case "paper_enabled_users_group_addition":
                    return EventTypeArg.paperEnabledUsersGroupAddition
                case "paper_enabled_users_group_removal":
                    return EventTypeArg.paperEnabledUsersGroupRemoval
                case "password_strength_requirements_change_policy":
                    return EventTypeArg.passwordStrengthRequirementsChangePolicy
                case "permanent_delete_change_policy":
                    return EventTypeArg.permanentDeleteChangePolicy
                case "reseller_support_change_policy":
                    return EventTypeArg.resellerSupportChangePolicy
                case "rewind_policy_changed":
                    return EventTypeArg.rewindPolicyChanged
                case "send_for_signature_policy_changed":
                    return EventTypeArg.sendForSignaturePolicyChanged
                case "sharing_change_folder_join_policy":
                    return EventTypeArg.sharingChangeFolderJoinPolicy
                case "sharing_change_link_allow_change_expiration_policy":
                    return EventTypeArg.sharingChangeLinkAllowChangeExpirationPolicy
                case "sharing_change_link_default_expiration_policy":
                    return EventTypeArg.sharingChangeLinkDefaultExpirationPolicy
                case "sharing_change_link_enforce_password_policy":
                    return EventTypeArg.sharingChangeLinkEnforcePasswordPolicy
                case "sharing_change_link_policy":
                    return EventTypeArg.sharingChangeLinkPolicy
                case "sharing_change_member_policy":
                    return EventTypeArg.sharingChangeMemberPolicy
                case "showcase_change_download_policy":
                    return EventTypeArg.showcaseChangeDownloadPolicy
                case "showcase_change_enabled_policy":
                    return EventTypeArg.showcaseChangeEnabledPolicy
                case "showcase_change_external_sharing_policy":
                    return EventTypeArg.showcaseChangeExternalSharingPolicy
                case "smarter_smart_sync_policy_changed":
                    return EventTypeArg.smarterSmartSyncPolicyChanged
                case "smart_sync_change_policy":
                    return EventTypeArg.smartSyncChangePolicy
                case "smart_sync_not_opt_out":
                    return EventTypeArg.smartSyncNotOptOut
                case "smart_sync_opt_out":
                    return EventTypeArg.smartSyncOptOut
                case "sso_change_policy":
                    return EventTypeArg.ssoChangePolicy
                case "team_branding_policy_changed":
                    return EventTypeArg.teamBrandingPolicyChanged
                case "team_extensions_policy_changed":
                    return EventTypeArg.teamExtensionsPolicyChanged
                case "team_selective_sync_policy_changed":
                    return EventTypeArg.teamSelectiveSyncPolicyChanged
                case "team_sharing_whitelist_subjects_changed":
                    return EventTypeArg.teamSharingWhitelistSubjectsChanged
                case "tfa_add_exception":
                    return EventTypeArg.tfaAddException
                case "tfa_change_policy":
                    return EventTypeArg.tfaChangePolicy
                case "tfa_remove_exception":
                    return EventTypeArg.tfaRemoveException
                case "two_account_change_policy":
                    return EventTypeArg.twoAccountChangePolicy
                case "viewer_info_policy_changed":
                    return EventTypeArg.viewerInfoPolicyChanged
                case "watermarking_policy_changed":
                    return EventTypeArg.watermarkingPolicyChanged
                case "web_sessions_change_active_session_limit":
                    return EventTypeArg.webSessionsChangeActiveSessionLimit
                case "web_sessions_change_fixed_length_policy":
                    return EventTypeArg.webSessionsChangeFixedLengthPolicy
                case "web_sessions_change_idle_length_policy":
                    return EventTypeArg.webSessionsChangeIdleLengthPolicy
                case "data_residency_migration_request_successful":
                    return EventTypeArg.dataResidencyMigrationRequestSuccessful
                case "data_residency_migration_request_unsuccessful":
                    return EventTypeArg.dataResidencyMigrationRequestUnsuccessful
                case "team_merge_from":
                    return EventTypeArg.teamMergeFrom
                case "team_merge_to":
                    return EventTypeArg.teamMergeTo
                case "team_profile_add_background":
                    return EventTypeArg.teamProfileAddBackground
                case "team_profile_add_logo":
                    return EventTypeArg.teamProfileAddLogo
                case "team_profile_change_background":
                    return EventTypeArg.teamProfileChangeBackground
                case "team_profile_change_default_language":
                    return EventTypeArg.teamProfileChangeDefaultLanguage
                case "team_profile_change_logo":
                    return EventTypeArg.teamProfileChangeLogo
                case "team_profile_change_name":
                    return EventTypeArg.teamProfileChangeName
                case "team_profile_remove_background":
                    return EventTypeArg.teamProfileRemoveBackground
                case "team_profile_remove_logo":
                    return EventTypeArg.teamProfileRemoveLogo
                case "tfa_add_backup_phone":
                    return EventTypeArg.tfaAddBackupPhone
                case "tfa_add_security_key":
                    return EventTypeArg.tfaAddSecurityKey
                case "tfa_change_backup_phone":
                    return EventTypeArg.tfaChangeBackupPhone
                case "tfa_change_status":
                    return EventTypeArg.tfaChangeStatus
                case "tfa_remove_backup_phone":
                    return EventTypeArg.tfaRemoveBackupPhone
                case "tfa_remove_security_key":
                    return EventTypeArg.tfaRemoveSecurityKey
                case "tfa_reset":
                    return EventTypeArg.tfaReset
                case "changed_enterprise_admin_role":
                    return EventTypeArg.changedEnterpriseAdminRole
                case "changed_enterprise_connected_team_status":
                    return EventTypeArg.changedEnterpriseConnectedTeamStatus
                case "ended_enterprise_admin_session":
                    return EventTypeArg.endedEnterpriseAdminSession
                case "ended_enterprise_admin_session_deprecated":
                    return EventTypeArg.endedEnterpriseAdminSessionDeprecated
                case "enterprise_settings_locking":
                    return EventTypeArg.enterpriseSettingsLocking
                case "guest_admin_change_status":
                    return EventTypeArg.guestAdminChangeStatus
                case "started_enterprise_admin_session":
                    return EventTypeArg.startedEnterpriseAdminSession
                case "team_merge_request_accepted":
                    return EventTypeArg.teamMergeRequestAccepted
                case "team_merge_request_accepted_shown_to_primary_team":
                    return EventTypeArg.teamMergeRequestAcceptedShownToPrimaryTeam
                case "team_merge_request_accepted_shown_to_secondary_team":
                    return EventTypeArg.teamMergeRequestAcceptedShownToSecondaryTeam
                case "team_merge_request_auto_canceled":
                    return EventTypeArg.teamMergeRequestAutoCanceled
                case "team_merge_request_canceled":
                    return EventTypeArg.teamMergeRequestCanceled
                case "team_merge_request_canceled_shown_to_primary_team":
                    return EventTypeArg.teamMergeRequestCanceledShownToPrimaryTeam
                case "team_merge_request_canceled_shown_to_secondary_team":
                    return EventTypeArg.teamMergeRequestCanceledShownToSecondaryTeam
                case "team_merge_request_expired":
                    return EventTypeArg.teamMergeRequestExpired
                case "team_merge_request_expired_shown_to_primary_team":
                    return EventTypeArg.teamMergeRequestExpiredShownToPrimaryTeam
                case "team_merge_request_expired_shown_to_secondary_team":
                    return EventTypeArg.teamMergeRequestExpiredShownToSecondaryTeam
                case "team_merge_request_rejected_shown_to_primary_team":
                    return EventTypeArg.teamMergeRequestRejectedShownToPrimaryTeam
                case "team_merge_request_rejected_shown_to_secondary_team":
                    return EventTypeArg.teamMergeRequestRejectedShownToSecondaryTeam
                case "team_merge_request_reminder":
                    return EventTypeArg.teamMergeRequestReminder
                case "team_merge_request_reminder_shown_to_primary_team":
                    return EventTypeArg.teamMergeRequestReminderShownToPrimaryTeam
                case "team_merge_request_reminder_shown_to_secondary_team":
                    return EventTypeArg.teamMergeRequestReminderShownToSecondaryTeam
                case "team_merge_request_revoked":
                    return EventTypeArg.teamMergeRequestRevoked
                case "team_merge_request_sent_shown_to_primary_team":
                    return EventTypeArg.teamMergeRequestSentShownToPrimaryTeam
                case "team_merge_request_sent_shown_to_secondary_team":
                    return EventTypeArg.teamMergeRequestSentShownToSecondaryTeam
                case "other":
                    return EventTypeArg.other
                default:
                    return EventTypeArg.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: EventTypeArg.self, json: json)
            }
        }
    }

    /// Created member data report.
    public class ExportMembersReportDetails: CustomStringConvertible, JSONRepresentable {
        func json() throws -> JSON {
            try ExportMembersReportDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ExportMembersReportDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ExportMembersReportDetails: \(error)"
            }
        }
    }

    public class ExportMembersReportDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ExportMembersReportDetails) throws -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ExportMembersReportDetails {
            switch json {
            case .dictionary:
                return ExportMembersReportDetails()
            default:
                throw JSONSerializerError.deserializeError(type: ExportMembersReportDetails.self, json: json)
            }
        }
    }

    /// Failed to create members data report.
    public class ExportMembersReportFailDetails: CustomStringConvertible, JSONRepresentable {
        /// Failure reason.
        public let failureReason: Team.TeamReportFailureReason
        public init(failureReason: Team.TeamReportFailureReason) {
            self.failureReason = failureReason
        }

        func json() throws -> JSON {
            try ExportMembersReportFailDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ExportMembersReportFailDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ExportMembersReportFailDetails: \(error)"
            }
        }
    }

    public class ExportMembersReportFailDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ExportMembersReportFailDetails) throws -> JSON {
            let output = [
                "failure_reason": try Team.TeamReportFailureReasonSerializer().serialize(value.failureReason),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ExportMembersReportFailDetails {
            switch json {
            case .dictionary(let dict):
                let failureReason = try Team.TeamReportFailureReasonSerializer().deserialize(dict["failure_reason"] ?? .null)
                return ExportMembersReportFailDetails(failureReason: failureReason)
            default:
                throw JSONSerializerError.deserializeError(type: ExportMembersReportFailDetails.self, json: json)
            }
        }
    }

    /// The ExportMembersReportFailType struct
    public class ExportMembersReportFailType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try ExportMembersReportFailTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ExportMembersReportFailTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ExportMembersReportFailType: \(error)"
            }
        }
    }

    public class ExportMembersReportFailTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ExportMembersReportFailType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ExportMembersReportFailType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return ExportMembersReportFailType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: ExportMembersReportFailType.self, json: json)
            }
        }
    }

    /// The ExportMembersReportType struct
    public class ExportMembersReportType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try ExportMembersReportTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ExportMembersReportTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ExportMembersReportType: \(error)"
            }
        }
    }

    public class ExportMembersReportTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ExportMembersReportType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ExportMembersReportType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return ExportMembersReportType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: ExportMembersReportType.self, json: json)
            }
        }
    }

    /// Accepted/opted out of extended version history.
    public class ExtendedVersionHistoryChangePolicyDetails: CustomStringConvertible, JSONRepresentable {
        /// New extended version history policy.
        public let newValue: TeamLog.ExtendedVersionHistoryPolicy
        /// Previous extended version history policy. Might be missing due to historical data gap.
        public let previousValue: TeamLog.ExtendedVersionHistoryPolicy?
        public init(newValue: TeamLog.ExtendedVersionHistoryPolicy, previousValue: TeamLog.ExtendedVersionHistoryPolicy? = nil) {
            self.newValue = newValue
            self.previousValue = previousValue
        }

        func json() throws -> JSON {
            try ExtendedVersionHistoryChangePolicyDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ExtendedVersionHistoryChangePolicyDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ExtendedVersionHistoryChangePolicyDetails: \(error)"
            }
        }
    }

    public class ExtendedVersionHistoryChangePolicyDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ExtendedVersionHistoryChangePolicyDetails) throws -> JSON {
            let output = [
                "new_value": try TeamLog.ExtendedVersionHistoryPolicySerializer().serialize(value.newValue),
                "previous_value": try NullableSerializer(TeamLog.ExtendedVersionHistoryPolicySerializer()).serialize(value.previousValue),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ExtendedVersionHistoryChangePolicyDetails {
            switch json {
            case .dictionary(let dict):
                let newValue = try TeamLog.ExtendedVersionHistoryPolicySerializer().deserialize(dict["new_value"] ?? .null)
                let previousValue = try NullableSerializer(TeamLog.ExtendedVersionHistoryPolicySerializer()).deserialize(dict["previous_value"] ?? .null)
                return ExtendedVersionHistoryChangePolicyDetails(newValue: newValue, previousValue: previousValue)
            default:
                throw JSONSerializerError.deserializeError(type: ExtendedVersionHistoryChangePolicyDetails.self, json: json)
            }
        }
    }

    /// The ExtendedVersionHistoryChangePolicyType struct
    public class ExtendedVersionHistoryChangePolicyType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try ExtendedVersionHistoryChangePolicyTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ExtendedVersionHistoryChangePolicyTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ExtendedVersionHistoryChangePolicyType: \(error)"
            }
        }
    }

    public class ExtendedVersionHistoryChangePolicyTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ExtendedVersionHistoryChangePolicyType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ExtendedVersionHistoryChangePolicyType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return ExtendedVersionHistoryChangePolicyType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: ExtendedVersionHistoryChangePolicyType.self, json: json)
            }
        }
    }

    /// The ExtendedVersionHistoryPolicy union
    public enum ExtendedVersionHistoryPolicy: CustomStringConvertible, JSONRepresentable {
        /// An unspecified error.
        case explicitlyLimited
        /// An unspecified error.
        case explicitlyUnlimited
        /// An unspecified error.
        case implicitlyLimited
        /// An unspecified error.
        case implicitlyUnlimited
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try ExtendedVersionHistoryPolicySerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ExtendedVersionHistoryPolicySerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ExtendedVersionHistoryPolicy: \(error)"
            }
        }
    }

    public class ExtendedVersionHistoryPolicySerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ExtendedVersionHistoryPolicy) throws -> JSON {
            switch value {
            case .explicitlyLimited:
                var d = [String: JSON]()
                d[".tag"] = .str("explicitly_limited")
                return .dictionary(d)
            case .explicitlyUnlimited:
                var d = [String: JSON]()
                d[".tag"] = .str("explicitly_unlimited")
                return .dictionary(d)
            case .implicitlyLimited:
                var d = [String: JSON]()
                d[".tag"] = .str("implicitly_limited")
                return .dictionary(d)
            case .implicitlyUnlimited:
                var d = [String: JSON]()
                d[".tag"] = .str("implicitly_unlimited")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> ExtendedVersionHistoryPolicy {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "explicitly_limited":
                    return ExtendedVersionHistoryPolicy.explicitlyLimited
                case "explicitly_unlimited":
                    return ExtendedVersionHistoryPolicy.explicitlyUnlimited
                case "implicitly_limited":
                    return ExtendedVersionHistoryPolicy.implicitlyLimited
                case "implicitly_unlimited":
                    return ExtendedVersionHistoryPolicy.implicitlyUnlimited
                case "other":
                    return ExtendedVersionHistoryPolicy.other
                default:
                    return ExtendedVersionHistoryPolicy.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: ExtendedVersionHistoryPolicy.self, json: json)
            }
        }
    }

    /// External Drive Backup eligibility status
    public enum ExternalDriveBackupEligibilityStatus: CustomStringConvertible, JSONRepresentable {
        /// An unspecified error.
        case exceedLicenseCap
        /// An unspecified error.
        case success
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try ExternalDriveBackupEligibilityStatusSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ExternalDriveBackupEligibilityStatusSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ExternalDriveBackupEligibilityStatus: \(error)"
            }
        }
    }

    public class ExternalDriveBackupEligibilityStatusSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ExternalDriveBackupEligibilityStatus) throws -> JSON {
            switch value {
            case .exceedLicenseCap:
                var d = [String: JSON]()
                d[".tag"] = .str("exceed_license_cap")
                return .dictionary(d)
            case .success:
                var d = [String: JSON]()
                d[".tag"] = .str("success")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> ExternalDriveBackupEligibilityStatus {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "exceed_license_cap":
                    return ExternalDriveBackupEligibilityStatus.exceedLicenseCap
                case "success":
                    return ExternalDriveBackupEligibilityStatus.success
                case "other":
                    return ExternalDriveBackupEligibilityStatus.other
                default:
                    return ExternalDriveBackupEligibilityStatus.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: ExternalDriveBackupEligibilityStatus.self, json: json)
            }
        }
    }

    /// Checked external drive backup eligibility status.
    public class ExternalDriveBackupEligibilityStatusCheckedDetails: CustomStringConvertible, JSONRepresentable {
        /// Device's session logged information.
        public let desktopDeviceSessionInfo: TeamLog.DesktopDeviceSessionLogInfo
        /// Current eligibility status of external drive backup.
        public let status: TeamLog.ExternalDriveBackupEligibilityStatus
        /// Total number of valid external drive backup for all the team members.
        public let numberOfExternalDriveBackup: UInt64
        public init(
            desktopDeviceSessionInfo: TeamLog.DesktopDeviceSessionLogInfo,
            status: TeamLog.ExternalDriveBackupEligibilityStatus,
            numberOfExternalDriveBackup: UInt64
        ) {
            self.desktopDeviceSessionInfo = desktopDeviceSessionInfo
            self.status = status
            comparableValidator()(numberOfExternalDriveBackup)
            self.numberOfExternalDriveBackup = numberOfExternalDriveBackup
        }

        func json() throws -> JSON {
            try ExternalDriveBackupEligibilityStatusCheckedDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ExternalDriveBackupEligibilityStatusCheckedDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ExternalDriveBackupEligibilityStatusCheckedDetails: \(error)"
            }
        }
    }

    public class ExternalDriveBackupEligibilityStatusCheckedDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ExternalDriveBackupEligibilityStatusCheckedDetails) throws -> JSON {
            let output = [
                "desktop_device_session_info": try TeamLog.DesktopDeviceSessionLogInfoSerializer().serialize(value.desktopDeviceSessionInfo),
                "status": try TeamLog.ExternalDriveBackupEligibilityStatusSerializer().serialize(value.status),
                "number_of_external_drive_backup": try Serialization._UInt64Serializer.serialize(value.numberOfExternalDriveBackup),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ExternalDriveBackupEligibilityStatusCheckedDetails {
            switch json {
            case .dictionary(let dict):
                let desktopDeviceSessionInfo = try TeamLog.DesktopDeviceSessionLogInfoSerializer().deserialize(dict["desktop_device_session_info"] ?? .null)
                let status = try TeamLog.ExternalDriveBackupEligibilityStatusSerializer().deserialize(dict["status"] ?? .null)
                let numberOfExternalDriveBackup = try Serialization._UInt64Serializer.deserialize(dict["number_of_external_drive_backup"] ?? .null)
                return ExternalDriveBackupEligibilityStatusCheckedDetails(
                    desktopDeviceSessionInfo: desktopDeviceSessionInfo,
                    status: status,
                    numberOfExternalDriveBackup: numberOfExternalDriveBackup
                )
            default:
                throw JSONSerializerError.deserializeError(type: ExternalDriveBackupEligibilityStatusCheckedDetails.self, json: json)
            }
        }
    }

    /// The ExternalDriveBackupEligibilityStatusCheckedType struct
    public class ExternalDriveBackupEligibilityStatusCheckedType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try ExternalDriveBackupEligibilityStatusCheckedTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ExternalDriveBackupEligibilityStatusCheckedTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ExternalDriveBackupEligibilityStatusCheckedType: \(error)"
            }
        }
    }

    public class ExternalDriveBackupEligibilityStatusCheckedTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ExternalDriveBackupEligibilityStatusCheckedType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ExternalDriveBackupEligibilityStatusCheckedType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return ExternalDriveBackupEligibilityStatusCheckedType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: ExternalDriveBackupEligibilityStatusCheckedType.self, json: json)
            }
        }
    }

    /// Policy for controlling team access to external drive backup feature
    public enum ExternalDriveBackupPolicy: CustomStringConvertible, JSONRepresentable {
        /// An unspecified error.
        case default_
        /// An unspecified error.
        case disabled
        /// An unspecified error.
        case enabled
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try ExternalDriveBackupPolicySerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ExternalDriveBackupPolicySerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ExternalDriveBackupPolicy: \(error)"
            }
        }
    }

    public class ExternalDriveBackupPolicySerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ExternalDriveBackupPolicy) throws -> JSON {
            switch value {
            case .default_:
                var d = [String: JSON]()
                d[".tag"] = .str("default")
                return .dictionary(d)
            case .disabled:
                var d = [String: JSON]()
                d[".tag"] = .str("disabled")
                return .dictionary(d)
            case .enabled:
                var d = [String: JSON]()
                d[".tag"] = .str("enabled")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> ExternalDriveBackupPolicy {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "default":
                    return ExternalDriveBackupPolicy.default_
                case "disabled":
                    return ExternalDriveBackupPolicy.disabled
                case "enabled":
                    return ExternalDriveBackupPolicy.enabled
                case "other":
                    return ExternalDriveBackupPolicy.other
                default:
                    return ExternalDriveBackupPolicy.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: ExternalDriveBackupPolicy.self, json: json)
            }
        }
    }

    /// Changed external drive backup policy for team.
    public class ExternalDriveBackupPolicyChangedDetails: CustomStringConvertible, JSONRepresentable {
        /// New external drive backup policy.
        public let newValue: TeamLog.ExternalDriveBackupPolicy
        /// Previous external drive backup policy.
        public let previousValue: TeamLog.ExternalDriveBackupPolicy
        public init(newValue: TeamLog.ExternalDriveBackupPolicy, previousValue: TeamLog.ExternalDriveBackupPolicy) {
            self.newValue = newValue
            self.previousValue = previousValue
        }

        func json() throws -> JSON {
            try ExternalDriveBackupPolicyChangedDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ExternalDriveBackupPolicyChangedDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ExternalDriveBackupPolicyChangedDetails: \(error)"
            }
        }
    }

    public class ExternalDriveBackupPolicyChangedDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ExternalDriveBackupPolicyChangedDetails) throws -> JSON {
            let output = [
                "new_value": try TeamLog.ExternalDriveBackupPolicySerializer().serialize(value.newValue),
                "previous_value": try TeamLog.ExternalDriveBackupPolicySerializer().serialize(value.previousValue),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ExternalDriveBackupPolicyChangedDetails {
            switch json {
            case .dictionary(let dict):
                let newValue = try TeamLog.ExternalDriveBackupPolicySerializer().deserialize(dict["new_value"] ?? .null)
                let previousValue = try TeamLog.ExternalDriveBackupPolicySerializer().deserialize(dict["previous_value"] ?? .null)
                return ExternalDriveBackupPolicyChangedDetails(newValue: newValue, previousValue: previousValue)
            default:
                throw JSONSerializerError.deserializeError(type: ExternalDriveBackupPolicyChangedDetails.self, json: json)
            }
        }
    }

    /// The ExternalDriveBackupPolicyChangedType struct
    public class ExternalDriveBackupPolicyChangedType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try ExternalDriveBackupPolicyChangedTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ExternalDriveBackupPolicyChangedTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ExternalDriveBackupPolicyChangedType: \(error)"
            }
        }
    }

    public class ExternalDriveBackupPolicyChangedTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ExternalDriveBackupPolicyChangedType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ExternalDriveBackupPolicyChangedType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return ExternalDriveBackupPolicyChangedType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: ExternalDriveBackupPolicyChangedType.self, json: json)
            }
        }
    }

    /// External Drive Backup status
    public enum ExternalDriveBackupStatus: CustomStringConvertible, JSONRepresentable {
        /// An unspecified error.
        case broken
        /// An unspecified error.
        case created
        /// An unspecified error.
        case createdOrBroken
        /// An unspecified error.
        case deleted
        /// An unspecified error.
        case empty
        /// An unspecified error.
        case unknown
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try ExternalDriveBackupStatusSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ExternalDriveBackupStatusSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ExternalDriveBackupStatus: \(error)"
            }
        }
    }

    public class ExternalDriveBackupStatusSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ExternalDriveBackupStatus) throws -> JSON {
            switch value {
            case .broken:
                var d = [String: JSON]()
                d[".tag"] = .str("broken")
                return .dictionary(d)
            case .created:
                var d = [String: JSON]()
                d[".tag"] = .str("created")
                return .dictionary(d)
            case .createdOrBroken:
                var d = [String: JSON]()
                d[".tag"] = .str("created_or_broken")
                return .dictionary(d)
            case .deleted:
                var d = [String: JSON]()
                d[".tag"] = .str("deleted")
                return .dictionary(d)
            case .empty:
                var d = [String: JSON]()
                d[".tag"] = .str("empty")
                return .dictionary(d)
            case .unknown:
                var d = [String: JSON]()
                d[".tag"] = .str("unknown")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> ExternalDriveBackupStatus {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "broken":
                    return ExternalDriveBackupStatus.broken
                case "created":
                    return ExternalDriveBackupStatus.created
                case "created_or_broken":
                    return ExternalDriveBackupStatus.createdOrBroken
                case "deleted":
                    return ExternalDriveBackupStatus.deleted
                case "empty":
                    return ExternalDriveBackupStatus.empty
                case "unknown":
                    return ExternalDriveBackupStatus.unknown
                case "other":
                    return ExternalDriveBackupStatus.other
                default:
                    return ExternalDriveBackupStatus.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: ExternalDriveBackupStatus.self, json: json)
            }
        }
    }

    /// Modified external drive backup.
    public class ExternalDriveBackupStatusChangedDetails: CustomStringConvertible, JSONRepresentable {
        /// Device's session logged information.
        public let desktopDeviceSessionInfo: TeamLog.DesktopDeviceSessionLogInfo
        /// Previous status of this external drive backup.
        public let previousValue: TeamLog.ExternalDriveBackupStatus
        /// Next status of this external drive backup.
        public let newValue: TeamLog.ExternalDriveBackupStatus
        public init(
            desktopDeviceSessionInfo: TeamLog.DesktopDeviceSessionLogInfo,
            previousValue: TeamLog.ExternalDriveBackupStatus,
            newValue: TeamLog.ExternalDriveBackupStatus
        ) {
            self.desktopDeviceSessionInfo = desktopDeviceSessionInfo
            self.previousValue = previousValue
            self.newValue = newValue
        }

        func json() throws -> JSON {
            try ExternalDriveBackupStatusChangedDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ExternalDriveBackupStatusChangedDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ExternalDriveBackupStatusChangedDetails: \(error)"
            }
        }
    }

    public class ExternalDriveBackupStatusChangedDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ExternalDriveBackupStatusChangedDetails) throws -> JSON {
            let output = [
                "desktop_device_session_info": try TeamLog.DesktopDeviceSessionLogInfoSerializer().serialize(value.desktopDeviceSessionInfo),
                "previous_value": try TeamLog.ExternalDriveBackupStatusSerializer().serialize(value.previousValue),
                "new_value": try TeamLog.ExternalDriveBackupStatusSerializer().serialize(value.newValue),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ExternalDriveBackupStatusChangedDetails {
            switch json {
            case .dictionary(let dict):
                let desktopDeviceSessionInfo = try TeamLog.DesktopDeviceSessionLogInfoSerializer().deserialize(dict["desktop_device_session_info"] ?? .null)
                let previousValue = try TeamLog.ExternalDriveBackupStatusSerializer().deserialize(dict["previous_value"] ?? .null)
                let newValue = try TeamLog.ExternalDriveBackupStatusSerializer().deserialize(dict["new_value"] ?? .null)
                return ExternalDriveBackupStatusChangedDetails(
                    desktopDeviceSessionInfo: desktopDeviceSessionInfo,
                    previousValue: previousValue,
                    newValue: newValue
                )
            default:
                throw JSONSerializerError.deserializeError(type: ExternalDriveBackupStatusChangedDetails.self, json: json)
            }
        }
    }

    /// The ExternalDriveBackupStatusChangedType struct
    public class ExternalDriveBackupStatusChangedType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try ExternalDriveBackupStatusChangedTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ExternalDriveBackupStatusChangedTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ExternalDriveBackupStatusChangedType: \(error)"
            }
        }
    }

    public class ExternalDriveBackupStatusChangedTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ExternalDriveBackupStatusChangedType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ExternalDriveBackupStatusChangedType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return ExternalDriveBackupStatusChangedType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: ExternalDriveBackupStatusChangedType.self, json: json)
            }
        }
    }

    /// Created External sharing report.
    public class ExternalSharingCreateReportDetails: CustomStringConvertible, JSONRepresentable {
        func json() throws -> JSON {
            try ExternalSharingCreateReportDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ExternalSharingCreateReportDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ExternalSharingCreateReportDetails: \(error)"
            }
        }
    }

    public class ExternalSharingCreateReportDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ExternalSharingCreateReportDetails) throws -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ExternalSharingCreateReportDetails {
            switch json {
            case .dictionary:
                return ExternalSharingCreateReportDetails()
            default:
                throw JSONSerializerError.deserializeError(type: ExternalSharingCreateReportDetails.self, json: json)
            }
        }
    }

    /// The ExternalSharingCreateReportType struct
    public class ExternalSharingCreateReportType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try ExternalSharingCreateReportTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ExternalSharingCreateReportTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ExternalSharingCreateReportType: \(error)"
            }
        }
    }

    public class ExternalSharingCreateReportTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ExternalSharingCreateReportType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ExternalSharingCreateReportType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return ExternalSharingCreateReportType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: ExternalSharingCreateReportType.self, json: json)
            }
        }
    }

    /// Couldn't create External sharing report.
    public class ExternalSharingReportFailedDetails: CustomStringConvertible, JSONRepresentable {
        /// Failure reason.
        public let failureReason: Team.TeamReportFailureReason
        public init(failureReason: Team.TeamReportFailureReason) {
            self.failureReason = failureReason
        }

        func json() throws -> JSON {
            try ExternalSharingReportFailedDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ExternalSharingReportFailedDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ExternalSharingReportFailedDetails: \(error)"
            }
        }
    }

    public class ExternalSharingReportFailedDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ExternalSharingReportFailedDetails) throws -> JSON {
            let output = [
                "failure_reason": try Team.TeamReportFailureReasonSerializer().serialize(value.failureReason),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ExternalSharingReportFailedDetails {
            switch json {
            case .dictionary(let dict):
                let failureReason = try Team.TeamReportFailureReasonSerializer().deserialize(dict["failure_reason"] ?? .null)
                return ExternalSharingReportFailedDetails(failureReason: failureReason)
            default:
                throw JSONSerializerError.deserializeError(type: ExternalSharingReportFailedDetails.self, json: json)
            }
        }
    }

    /// The ExternalSharingReportFailedType struct
    public class ExternalSharingReportFailedType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try ExternalSharingReportFailedTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ExternalSharingReportFailedTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ExternalSharingReportFailedType: \(error)"
            }
        }
    }

    public class ExternalSharingReportFailedTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ExternalSharingReportFailedType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ExternalSharingReportFailedType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return ExternalSharingReportFailedType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: ExternalSharingReportFailedType.self, json: json)
            }
        }
    }

    /// A user without a Dropbox account.
    public class ExternalUserLogInfo: CustomStringConvertible, JSONRepresentable {
        /// An external user identifier.
        public let userIdentifier: String
        /// Identifier type.
        public let identifierType: TeamLog.IdentifierType
        public init(userIdentifier: String, identifierType: TeamLog.IdentifierType) {
            stringValidator()(userIdentifier)
            self.userIdentifier = userIdentifier
            self.identifierType = identifierType
        }

        func json() throws -> JSON {
            try ExternalUserLogInfoSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ExternalUserLogInfoSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ExternalUserLogInfo: \(error)"
            }
        }
    }

    public class ExternalUserLogInfoSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ExternalUserLogInfo) throws -> JSON {
            let output = [
                "user_identifier": try Serialization._StringSerializer.serialize(value.userIdentifier),
                "identifier_type": try TeamLog.IdentifierTypeSerializer().serialize(value.identifierType),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ExternalUserLogInfo {
            switch json {
            case .dictionary(let dict):
                let userIdentifier = try Serialization._StringSerializer.deserialize(dict["user_identifier"] ?? .null)
                let identifierType = try TeamLog.IdentifierTypeSerializer().deserialize(dict["identifier_type"] ?? .null)
                return ExternalUserLogInfo(userIdentifier: userIdentifier, identifierType: identifierType)
            default:
                throw JSONSerializerError.deserializeError(type: ExternalUserLogInfo.self, json: json)
            }
        }
    }

    /// Provides details about a failure
    public class FailureDetailsLogInfo: CustomStringConvertible, JSONRepresentable {
        /// A user friendly explanation of the error.
        public let userFriendlyMessage: String?
        /// A technical explanation of the error. This is relevant for some errors.
        public let technicalErrorMessage: String?
        public init(userFriendlyMessage: String? = nil, technicalErrorMessage: String? = nil) {
            nullableValidator(stringValidator())(userFriendlyMessage)
            self.userFriendlyMessage = userFriendlyMessage
            nullableValidator(stringValidator())(technicalErrorMessage)
            self.technicalErrorMessage = technicalErrorMessage
        }

        func json() throws -> JSON {
            try FailureDetailsLogInfoSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try FailureDetailsLogInfoSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for FailureDetailsLogInfo: \(error)"
            }
        }
    }

    public class FailureDetailsLogInfoSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: FailureDetailsLogInfo) throws -> JSON {
            let output = [
                "user_friendly_message": try NullableSerializer(Serialization._StringSerializer).serialize(value.userFriendlyMessage),
                "technical_error_message": try NullableSerializer(Serialization._StringSerializer).serialize(value.technicalErrorMessage),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> FailureDetailsLogInfo {
            switch json {
            case .dictionary(let dict):
                let userFriendlyMessage = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["user_friendly_message"] ?? .null)
                let technicalErrorMessage = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["technical_error_message"] ?? .null)
                return FailureDetailsLogInfo(userFriendlyMessage: userFriendlyMessage, technicalErrorMessage: technicalErrorMessage)
            default:
                throw JSONSerializerError.deserializeError(type: FailureDetailsLogInfo.self, json: json)
            }
        }
    }

    /// The FedAdminRole union
    public enum FedAdminRole: CustomStringConvertible, JSONRepresentable {
        /// An unspecified error.
        case enterpriseAdmin
        /// An unspecified error.
        case notEnterpriseAdmin
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try FedAdminRoleSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try FedAdminRoleSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for FedAdminRole: \(error)"
            }
        }
    }

    public class FedAdminRoleSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: FedAdminRole) throws -> JSON {
            switch value {
            case .enterpriseAdmin:
                var d = [String: JSON]()
                d[".tag"] = .str("enterprise_admin")
                return .dictionary(d)
            case .notEnterpriseAdmin:
                var d = [String: JSON]()
                d[".tag"] = .str("not_enterprise_admin")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> FedAdminRole {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "enterprise_admin":
                    return FedAdminRole.enterpriseAdmin
                case "not_enterprise_admin":
                    return FedAdminRole.notEnterpriseAdmin
                case "other":
                    return FedAdminRole.other
                default:
                    return FedAdminRole.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: FedAdminRole.self, json: json)
            }
        }
    }

    /// More details about the organization or team.
    public enum FedExtraDetails: CustomStringConvertible, JSONRepresentable {
        /// More details about the organization.
        case organization(TeamLog.OrganizationDetails)
        /// More details about the team.
        case team(TeamLog.TeamDetails)
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try FedExtraDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try FedExtraDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for FedExtraDetails: \(error)"
            }
        }
    }

    public class FedExtraDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: FedExtraDetails) throws -> JSON {
            switch value {
            case .organization(let arg):
                var d = try Serialization.getFields(TeamLog.OrganizationDetailsSerializer().serialize(arg))
                d[".tag"] = .str("organization")
                return .dictionary(d)
            case .team(let arg):
                var d = try Serialization.getFields(TeamLog.TeamDetailsSerializer().serialize(arg))
                d[".tag"] = .str("team")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> FedExtraDetails {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "organization":
                    let v = try TeamLog.OrganizationDetailsSerializer().deserialize(json)
                    return FedExtraDetails.organization(v)
                case "team":
                    let v = try TeamLog.TeamDetailsSerializer().deserialize(json)
                    return FedExtraDetails.team(v)
                case "other":
                    return FedExtraDetails.other
                default:
                    return FedExtraDetails.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: FedExtraDetails.self, json: json)
            }
        }
    }

    /// The FedHandshakeAction union
    public enum FedHandshakeAction: CustomStringConvertible, JSONRepresentable {
        /// An unspecified error.
        case acceptedInvite
        /// An unspecified error.
        case canceledInvite
        /// An unspecified error.
        case inviteExpired
        /// An unspecified error.
        case invited
        /// An unspecified error.
        case rejectedInvite
        /// An unspecified error.
        case removedTeam
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try FedHandshakeActionSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try FedHandshakeActionSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for FedHandshakeAction: \(error)"
            }
        }
    }

    public class FedHandshakeActionSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: FedHandshakeAction) throws -> JSON {
            switch value {
            case .acceptedInvite:
                var d = [String: JSON]()
                d[".tag"] = .str("accepted_invite")
                return .dictionary(d)
            case .canceledInvite:
                var d = [String: JSON]()
                d[".tag"] = .str("canceled_invite")
                return .dictionary(d)
            case .inviteExpired:
                var d = [String: JSON]()
                d[".tag"] = .str("invite_expired")
                return .dictionary(d)
            case .invited:
                var d = [String: JSON]()
                d[".tag"] = .str("invited")
                return .dictionary(d)
            case .rejectedInvite:
                var d = [String: JSON]()
                d[".tag"] = .str("rejected_invite")
                return .dictionary(d)
            case .removedTeam:
                var d = [String: JSON]()
                d[".tag"] = .str("removed_team")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> FedHandshakeAction {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "accepted_invite":
                    return FedHandshakeAction.acceptedInvite
                case "canceled_invite":
                    return FedHandshakeAction.canceledInvite
                case "invite_expired":
                    return FedHandshakeAction.inviteExpired
                case "invited":
                    return FedHandshakeAction.invited
                case "rejected_invite":
                    return FedHandshakeAction.rejectedInvite
                case "removed_team":
                    return FedHandshakeAction.removedTeam
                case "other":
                    return FedHandshakeAction.other
                default:
                    return FedHandshakeAction.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: FedHandshakeAction.self, json: json)
            }
        }
    }

    /// Additional information about the organization or connected team
    public enum FederationStatusChangeAdditionalInfo: CustomStringConvertible, JSONRepresentable {
        /// The name of the team.
        case connectedTeamName(TeamLog.ConnectedTeamName)
        /// The email to which the request was sent.
        case nonTrustedTeamDetails(TeamLog.NonTrustedTeamDetails)
        /// The name of the organization.
        case organizationName(TeamLog.OrganizationName)
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try FederationStatusChangeAdditionalInfoSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try FederationStatusChangeAdditionalInfoSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for FederationStatusChangeAdditionalInfo: \(error)"
            }
        }
    }

    public class FederationStatusChangeAdditionalInfoSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: FederationStatusChangeAdditionalInfo) throws -> JSON {
            switch value {
            case .connectedTeamName(let arg):
                var d = try Serialization.getFields(TeamLog.ConnectedTeamNameSerializer().serialize(arg))
                d[".tag"] = .str("connected_team_name")
                return .dictionary(d)
            case .nonTrustedTeamDetails(let arg):
                var d = try Serialization.getFields(TeamLog.NonTrustedTeamDetailsSerializer().serialize(arg))
                d[".tag"] = .str("non_trusted_team_details")
                return .dictionary(d)
            case .organizationName(let arg):
                var d = try Serialization.getFields(TeamLog.OrganizationNameSerializer().serialize(arg))
                d[".tag"] = .str("organization_name")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> FederationStatusChangeAdditionalInfo {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "connected_team_name":
                    let v = try TeamLog.ConnectedTeamNameSerializer().deserialize(json)
                    return FederationStatusChangeAdditionalInfo.connectedTeamName(v)
                case "non_trusted_team_details":
                    let v = try TeamLog.NonTrustedTeamDetailsSerializer().deserialize(json)
                    return FederationStatusChangeAdditionalInfo.nonTrustedTeamDetails(v)
                case "organization_name":
                    let v = try TeamLog.OrganizationNameSerializer().deserialize(json)
                    return FederationStatusChangeAdditionalInfo.organizationName(v)
                case "other":
                    return FederationStatusChangeAdditionalInfo.other
                default:
                    return FederationStatusChangeAdditionalInfo.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: FederationStatusChangeAdditionalInfo.self, json: json)
            }
        }
    }

    /// Added file comment.
    public class FileAddCommentDetails: CustomStringConvertible, JSONRepresentable {
        /// Comment text.
        public let commentText: String?
        public init(commentText: String? = nil) {
            nullableValidator(stringValidator())(commentText)
            self.commentText = commentText
        }

        func json() throws -> JSON {
            try FileAddCommentDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try FileAddCommentDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for FileAddCommentDetails: \(error)"
            }
        }
    }

    public class FileAddCommentDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: FileAddCommentDetails) throws -> JSON {
            let output = [
                "comment_text": try NullableSerializer(Serialization._StringSerializer).serialize(value.commentText),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> FileAddCommentDetails {
            switch json {
            case .dictionary(let dict):
                let commentText = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["comment_text"] ?? .null)
                return FileAddCommentDetails(commentText: commentText)
            default:
                throw JSONSerializerError.deserializeError(type: FileAddCommentDetails.self, json: json)
            }
        }
    }

    /// The FileAddCommentType struct
    public class FileAddCommentType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try FileAddCommentTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try FileAddCommentTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for FileAddCommentType: \(error)"
            }
        }
    }

    public class FileAddCommentTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: FileAddCommentType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> FileAddCommentType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return FileAddCommentType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: FileAddCommentType.self, json: json)
            }
        }
    }

    /// Added files and/or folders.
    public class FileAddDetails: CustomStringConvertible, JSONRepresentable {
        func json() throws -> JSON {
            try FileAddDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try FileAddDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for FileAddDetails: \(error)"
            }
        }
    }

    public class FileAddDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: FileAddDetails) throws -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> FileAddDetails {
            switch json {
            case .dictionary:
                return FileAddDetails()
            default:
                throw JSONSerializerError.deserializeError(type: FileAddDetails.self, json: json)
            }
        }
    }

    /// Added files and/or folders from automation.
    public class FileAddFromAutomationDetails: CustomStringConvertible, JSONRepresentable {
        func json() throws -> JSON {
            try FileAddFromAutomationDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try FileAddFromAutomationDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for FileAddFromAutomationDetails: \(error)"
            }
        }
    }

    public class FileAddFromAutomationDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: FileAddFromAutomationDetails) throws -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> FileAddFromAutomationDetails {
            switch json {
            case .dictionary:
                return FileAddFromAutomationDetails()
            default:
                throw JSONSerializerError.deserializeError(type: FileAddFromAutomationDetails.self, json: json)
            }
        }
    }

    /// The FileAddFromAutomationType struct
    public class FileAddFromAutomationType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try FileAddFromAutomationTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try FileAddFromAutomationTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for FileAddFromAutomationType: \(error)"
            }
        }
    }

    public class FileAddFromAutomationTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: FileAddFromAutomationType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> FileAddFromAutomationType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return FileAddFromAutomationType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: FileAddFromAutomationType.self, json: json)
            }
        }
    }

    /// The FileAddType struct
    public class FileAddType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try FileAddTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try FileAddTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for FileAddType: \(error)"
            }
        }
    }

    public class FileAddTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: FileAddType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> FileAddType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return FileAddType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: FileAddType.self, json: json)
            }
        }
    }

    /// Subscribed to or unsubscribed from comment notifications for file.
    public class FileChangeCommentSubscriptionDetails: CustomStringConvertible, JSONRepresentable {
        /// New file comment subscription.
        public let newValue: TeamLog.FileCommentNotificationPolicy
        /// Previous file comment subscription. Might be missing due to historical data gap.
        public let previousValue: TeamLog.FileCommentNotificationPolicy?
        public init(newValue: TeamLog.FileCommentNotificationPolicy, previousValue: TeamLog.FileCommentNotificationPolicy? = nil) {
            self.newValue = newValue
            self.previousValue = previousValue
        }

        func json() throws -> JSON {
            try FileChangeCommentSubscriptionDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try FileChangeCommentSubscriptionDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for FileChangeCommentSubscriptionDetails: \(error)"
            }
        }
    }

    public class FileChangeCommentSubscriptionDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: FileChangeCommentSubscriptionDetails) throws -> JSON {
            let output = [
                "new_value": try TeamLog.FileCommentNotificationPolicySerializer().serialize(value.newValue),
                "previous_value": try NullableSerializer(TeamLog.FileCommentNotificationPolicySerializer()).serialize(value.previousValue),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> FileChangeCommentSubscriptionDetails {
            switch json {
            case .dictionary(let dict):
                let newValue = try TeamLog.FileCommentNotificationPolicySerializer().deserialize(dict["new_value"] ?? .null)
                let previousValue = try NullableSerializer(TeamLog.FileCommentNotificationPolicySerializer()).deserialize(dict["previous_value"] ?? .null)
                return FileChangeCommentSubscriptionDetails(newValue: newValue, previousValue: previousValue)
            default:
                throw JSONSerializerError.deserializeError(type: FileChangeCommentSubscriptionDetails.self, json: json)
            }
        }
    }

    /// The FileChangeCommentSubscriptionType struct
    public class FileChangeCommentSubscriptionType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try FileChangeCommentSubscriptionTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try FileChangeCommentSubscriptionTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for FileChangeCommentSubscriptionType: \(error)"
            }
        }
    }

    public class FileChangeCommentSubscriptionTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: FileChangeCommentSubscriptionType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> FileChangeCommentSubscriptionType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return FileChangeCommentSubscriptionType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: FileChangeCommentSubscriptionType.self, json: json)
            }
        }
    }

    /// Enable or disable file comments notifications
    public enum FileCommentNotificationPolicy: CustomStringConvertible, JSONRepresentable {
        /// An unspecified error.
        case disabled
        /// An unspecified error.
        case enabled
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try FileCommentNotificationPolicySerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try FileCommentNotificationPolicySerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for FileCommentNotificationPolicy: \(error)"
            }
        }
    }

    public class FileCommentNotificationPolicySerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: FileCommentNotificationPolicy) throws -> JSON {
            switch value {
            case .disabled:
                var d = [String: JSON]()
                d[".tag"] = .str("disabled")
                return .dictionary(d)
            case .enabled:
                var d = [String: JSON]()
                d[".tag"] = .str("enabled")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> FileCommentNotificationPolicy {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "disabled":
                    return FileCommentNotificationPolicy.disabled
                case "enabled":
                    return FileCommentNotificationPolicy.enabled
                case "other":
                    return FileCommentNotificationPolicy.other
                default:
                    return FileCommentNotificationPolicy.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: FileCommentNotificationPolicy.self, json: json)
            }
        }
    }

    /// Enabled/disabled commenting on team files.
    public class FileCommentsChangePolicyDetails: CustomStringConvertible, JSONRepresentable {
        /// New commenting on team files policy.
        public let newValue: TeamLog.FileCommentsPolicy
        /// Previous commenting on team files policy. Might be missing due to historical data gap.
        public let previousValue: TeamLog.FileCommentsPolicy?
        public init(newValue: TeamLog.FileCommentsPolicy, previousValue: TeamLog.FileCommentsPolicy? = nil) {
            self.newValue = newValue
            self.previousValue = previousValue
        }

        func json() throws -> JSON {
            try FileCommentsChangePolicyDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try FileCommentsChangePolicyDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for FileCommentsChangePolicyDetails: \(error)"
            }
        }
    }

    public class FileCommentsChangePolicyDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: FileCommentsChangePolicyDetails) throws -> JSON {
            let output = [
                "new_value": try TeamLog.FileCommentsPolicySerializer().serialize(value.newValue),
                "previous_value": try NullableSerializer(TeamLog.FileCommentsPolicySerializer()).serialize(value.previousValue),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> FileCommentsChangePolicyDetails {
            switch json {
            case .dictionary(let dict):
                let newValue = try TeamLog.FileCommentsPolicySerializer().deserialize(dict["new_value"] ?? .null)
                let previousValue = try NullableSerializer(TeamLog.FileCommentsPolicySerializer()).deserialize(dict["previous_value"] ?? .null)
                return FileCommentsChangePolicyDetails(newValue: newValue, previousValue: previousValue)
            default:
                throw JSONSerializerError.deserializeError(type: FileCommentsChangePolicyDetails.self, json: json)
            }
        }
    }

    /// The FileCommentsChangePolicyType struct
    public class FileCommentsChangePolicyType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try FileCommentsChangePolicyTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try FileCommentsChangePolicyTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for FileCommentsChangePolicyType: \(error)"
            }
        }
    }

    public class FileCommentsChangePolicyTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: FileCommentsChangePolicyType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> FileCommentsChangePolicyType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return FileCommentsChangePolicyType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: FileCommentsChangePolicyType.self, json: json)
            }
        }
    }

    /// File comments policy
    public enum FileCommentsPolicy: CustomStringConvertible, JSONRepresentable {
        /// An unspecified error.
        case disabled
        /// An unspecified error.
        case enabled
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try FileCommentsPolicySerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try FileCommentsPolicySerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for FileCommentsPolicy: \(error)"
            }
        }
    }

    public class FileCommentsPolicySerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: FileCommentsPolicy) throws -> JSON {
            switch value {
            case .disabled:
                var d = [String: JSON]()
                d[".tag"] = .str("disabled")
                return .dictionary(d)
            case .enabled:
                var d = [String: JSON]()
                d[".tag"] = .str("enabled")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> FileCommentsPolicy {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "disabled":
                    return FileCommentsPolicy.disabled
                case "enabled":
                    return FileCommentsPolicy.enabled
                case "other":
                    return FileCommentsPolicy.other
                default:
                    return FileCommentsPolicy.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: FileCommentsPolicy.self, json: json)
            }
        }
    }

    /// Copied files and/or folders.
    public class FileCopyDetails: CustomStringConvertible, JSONRepresentable {
        /// Relocate action details.
        public let relocateActionDetails: [TeamLog.RelocateAssetReferencesLogInfo]
        public init(relocateActionDetails: [TeamLog.RelocateAssetReferencesLogInfo]) {
            self.relocateActionDetails = relocateActionDetails
        }

        func json() throws -> JSON {
            try FileCopyDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try FileCopyDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for FileCopyDetails: \(error)"
            }
        }
    }

    public class FileCopyDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: FileCopyDetails) throws -> JSON {
            let output = [
                "relocate_action_details": try ArraySerializer(TeamLog.RelocateAssetReferencesLogInfoSerializer()).serialize(value.relocateActionDetails),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> FileCopyDetails {
            switch json {
            case .dictionary(let dict):
                let relocateActionDetails = try ArraySerializer(TeamLog.RelocateAssetReferencesLogInfoSerializer())
                    .deserialize(dict["relocate_action_details"] ?? .null)
                return FileCopyDetails(relocateActionDetails: relocateActionDetails)
            default:
                throw JSONSerializerError.deserializeError(type: FileCopyDetails.self, json: json)
            }
        }
    }

    /// The FileCopyType struct
    public class FileCopyType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try FileCopyTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try FileCopyTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for FileCopyType: \(error)"
            }
        }
    }

    public class FileCopyTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: FileCopyType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> FileCopyType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return FileCopyType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: FileCopyType.self, json: json)
            }
        }
    }

    /// Deleted file comment.
    public class FileDeleteCommentDetails: CustomStringConvertible, JSONRepresentable {
        /// Comment text.
        public let commentText: String?
        public init(commentText: String? = nil) {
            nullableValidator(stringValidator())(commentText)
            self.commentText = commentText
        }

        func json() throws -> JSON {
            try FileDeleteCommentDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try FileDeleteCommentDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for FileDeleteCommentDetails: \(error)"
            }
        }
    }

    public class FileDeleteCommentDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: FileDeleteCommentDetails) throws -> JSON {
            let output = [
                "comment_text": try NullableSerializer(Serialization._StringSerializer).serialize(value.commentText),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> FileDeleteCommentDetails {
            switch json {
            case .dictionary(let dict):
                let commentText = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["comment_text"] ?? .null)
                return FileDeleteCommentDetails(commentText: commentText)
            default:
                throw JSONSerializerError.deserializeError(type: FileDeleteCommentDetails.self, json: json)
            }
        }
    }

    /// The FileDeleteCommentType struct
    public class FileDeleteCommentType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try FileDeleteCommentTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try FileDeleteCommentTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for FileDeleteCommentType: \(error)"
            }
        }
    }

    public class FileDeleteCommentTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: FileDeleteCommentType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> FileDeleteCommentType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return FileDeleteCommentType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: FileDeleteCommentType.self, json: json)
            }
        }
    }

    /// Deleted files and/or folders.
    public class FileDeleteDetails: CustomStringConvertible, JSONRepresentable {
        func json() throws -> JSON {
            try FileDeleteDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try FileDeleteDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for FileDeleteDetails: \(error)"
            }
        }
    }

    public class FileDeleteDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: FileDeleteDetails) throws -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> FileDeleteDetails {
            switch json {
            case .dictionary:
                return FileDeleteDetails()
            default:
                throw JSONSerializerError.deserializeError(type: FileDeleteDetails.self, json: json)
            }
        }
    }

    /// The FileDeleteType struct
    public class FileDeleteType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try FileDeleteTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try FileDeleteTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for FileDeleteType: \(error)"
            }
        }
    }

    public class FileDeleteTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: FileDeleteType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> FileDeleteType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return FileDeleteType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: FileDeleteType.self, json: json)
            }
        }
    }

    /// Downloaded files and/or folders.
    public class FileDownloadDetails: CustomStringConvertible, JSONRepresentable {
        func json() throws -> JSON {
            try FileDownloadDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try FileDownloadDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for FileDownloadDetails: \(error)"
            }
        }
    }

    public class FileDownloadDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: FileDownloadDetails) throws -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> FileDownloadDetails {
            switch json {
            case .dictionary:
                return FileDownloadDetails()
            default:
                throw JSONSerializerError.deserializeError(type: FileDownloadDetails.self, json: json)
            }
        }
    }

    /// The FileDownloadType struct
    public class FileDownloadType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try FileDownloadTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try FileDownloadTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for FileDownloadType: \(error)"
            }
        }
    }

    public class FileDownloadTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: FileDownloadType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> FileDownloadType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return FileDownloadType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: FileDownloadType.self, json: json)
            }
        }
    }

    /// Edited file comment.
    public class FileEditCommentDetails: CustomStringConvertible, JSONRepresentable {
        /// Comment text.
        public let commentText: String?
        /// Previous comment text.
        public let previousCommentText: String
        public init(previousCommentText: String, commentText: String? = nil) {
            nullableValidator(stringValidator())(commentText)
            self.commentText = commentText
            stringValidator()(previousCommentText)
            self.previousCommentText = previousCommentText
        }

        func json() throws -> JSON {
            try FileEditCommentDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try FileEditCommentDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for FileEditCommentDetails: \(error)"
            }
        }
    }

    public class FileEditCommentDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: FileEditCommentDetails) throws -> JSON {
            let output = [
                "previous_comment_text": try Serialization._StringSerializer.serialize(value.previousCommentText),
                "comment_text": try NullableSerializer(Serialization._StringSerializer).serialize(value.commentText),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> FileEditCommentDetails {
            switch json {
            case .dictionary(let dict):
                let previousCommentText = try Serialization._StringSerializer.deserialize(dict["previous_comment_text"] ?? .null)
                let commentText = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["comment_text"] ?? .null)
                return FileEditCommentDetails(previousCommentText: previousCommentText, commentText: commentText)
            default:
                throw JSONSerializerError.deserializeError(type: FileEditCommentDetails.self, json: json)
            }
        }
    }

    /// The FileEditCommentType struct
    public class FileEditCommentType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try FileEditCommentTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try FileEditCommentTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for FileEditCommentType: \(error)"
            }
        }
    }

    public class FileEditCommentTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: FileEditCommentType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> FileEditCommentType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return FileEditCommentType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: FileEditCommentType.self, json: json)
            }
        }
    }

    /// Edited files.
    public class FileEditDetails: CustomStringConvertible, JSONRepresentable {
        func json() throws -> JSON {
            try FileEditDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try FileEditDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for FileEditDetails: \(error)"
            }
        }
    }

    public class FileEditDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: FileEditDetails) throws -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> FileEditDetails {
            switch json {
            case .dictionary:
                return FileEditDetails()
            default:
                throw JSONSerializerError.deserializeError(type: FileEditDetails.self, json: json)
            }
        }
    }

    /// The FileEditType struct
    public class FileEditType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try FileEditTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try FileEditTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for FileEditType: \(error)"
            }
        }
    }

    public class FileEditTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: FileEditType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> FileEditType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return FileEditType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: FileEditType.self, json: json)
            }
        }
    }

    /// Created copy reference to file/folder.
    public class FileGetCopyReferenceDetails: CustomStringConvertible, JSONRepresentable {
        func json() throws -> JSON {
            try FileGetCopyReferenceDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try FileGetCopyReferenceDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for FileGetCopyReferenceDetails: \(error)"
            }
        }
    }

    public class FileGetCopyReferenceDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: FileGetCopyReferenceDetails) throws -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> FileGetCopyReferenceDetails {
            switch json {
            case .dictionary:
                return FileGetCopyReferenceDetails()
            default:
                throw JSONSerializerError.deserializeError(type: FileGetCopyReferenceDetails.self, json: json)
            }
        }
    }

    /// The FileGetCopyReferenceType struct
    public class FileGetCopyReferenceType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try FileGetCopyReferenceTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try FileGetCopyReferenceTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for FileGetCopyReferenceType: \(error)"
            }
        }
    }

    public class FileGetCopyReferenceTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: FileGetCopyReferenceType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> FileGetCopyReferenceType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return FileGetCopyReferenceType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: FileGetCopyReferenceType.self, json: json)
            }
        }
    }

    /// Liked file comment.
    public class FileLikeCommentDetails: CustomStringConvertible, JSONRepresentable {
        /// Comment text.
        public let commentText: String?
        public init(commentText: String? = nil) {
            nullableValidator(stringValidator())(commentText)
            self.commentText = commentText
        }

        func json() throws -> JSON {
            try FileLikeCommentDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try FileLikeCommentDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for FileLikeCommentDetails: \(error)"
            }
        }
    }

    public class FileLikeCommentDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: FileLikeCommentDetails) throws -> JSON {
            let output = [
                "comment_text": try NullableSerializer(Serialization._StringSerializer).serialize(value.commentText),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> FileLikeCommentDetails {
            switch json {
            case .dictionary(let dict):
                let commentText = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["comment_text"] ?? .null)
                return FileLikeCommentDetails(commentText: commentText)
            default:
                throw JSONSerializerError.deserializeError(type: FileLikeCommentDetails.self, json: json)
            }
        }
    }

    /// The FileLikeCommentType struct
    public class FileLikeCommentType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try FileLikeCommentTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try FileLikeCommentTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for FileLikeCommentType: \(error)"
            }
        }
    }

    public class FileLikeCommentTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: FileLikeCommentType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> FileLikeCommentType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return FileLikeCommentType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: FileLikeCommentType.self, json: json)
            }
        }
    }

    /// Locked/unlocked editing for a file.
    public class FileLockingLockStatusChangedDetails: CustomStringConvertible, JSONRepresentable {
        /// Previous lock status of the file.
        public let previousValue: TeamLog.LockStatus
        /// New lock status of the file.
        public let newValue: TeamLog.LockStatus
        public init(previousValue: TeamLog.LockStatus, newValue: TeamLog.LockStatus) {
            self.previousValue = previousValue
            self.newValue = newValue
        }

        func json() throws -> JSON {
            try FileLockingLockStatusChangedDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try FileLockingLockStatusChangedDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for FileLockingLockStatusChangedDetails: \(error)"
            }
        }
    }

    public class FileLockingLockStatusChangedDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: FileLockingLockStatusChangedDetails) throws -> JSON {
            let output = [
                "previous_value": try TeamLog.LockStatusSerializer().serialize(value.previousValue),
                "new_value": try TeamLog.LockStatusSerializer().serialize(value.newValue),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> FileLockingLockStatusChangedDetails {
            switch json {
            case .dictionary(let dict):
                let previousValue = try TeamLog.LockStatusSerializer().deserialize(dict["previous_value"] ?? .null)
                let newValue = try TeamLog.LockStatusSerializer().deserialize(dict["new_value"] ?? .null)
                return FileLockingLockStatusChangedDetails(previousValue: previousValue, newValue: newValue)
            default:
                throw JSONSerializerError.deserializeError(type: FileLockingLockStatusChangedDetails.self, json: json)
            }
        }
    }

    /// The FileLockingLockStatusChangedType struct
    public class FileLockingLockStatusChangedType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try FileLockingLockStatusChangedTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try FileLockingLockStatusChangedTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for FileLockingLockStatusChangedType: \(error)"
            }
        }
    }

    public class FileLockingLockStatusChangedTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: FileLockingLockStatusChangedType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> FileLockingLockStatusChangedType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return FileLockingLockStatusChangedType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: FileLockingLockStatusChangedType.self, json: json)
            }
        }
    }

    /// Changed file locking policy for team.
    public class FileLockingPolicyChangedDetails: CustomStringConvertible, JSONRepresentable {
        /// New file locking policy.
        public let newValue: TeamPolicies.FileLockingPolicyState
        /// Previous file locking policy.
        public let previousValue: TeamPolicies.FileLockingPolicyState
        public init(newValue: TeamPolicies.FileLockingPolicyState, previousValue: TeamPolicies.FileLockingPolicyState) {
            self.newValue = newValue
            self.previousValue = previousValue
        }

        func json() throws -> JSON {
            try FileLockingPolicyChangedDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try FileLockingPolicyChangedDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for FileLockingPolicyChangedDetails: \(error)"
            }
        }
    }

    public class FileLockingPolicyChangedDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: FileLockingPolicyChangedDetails) throws -> JSON {
            let output = [
                "new_value": try TeamPolicies.FileLockingPolicyStateSerializer().serialize(value.newValue),
                "previous_value": try TeamPolicies.FileLockingPolicyStateSerializer().serialize(value.previousValue),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> FileLockingPolicyChangedDetails {
            switch json {
            case .dictionary(let dict):
                let newValue = try TeamPolicies.FileLockingPolicyStateSerializer().deserialize(dict["new_value"] ?? .null)
                let previousValue = try TeamPolicies.FileLockingPolicyStateSerializer().deserialize(dict["previous_value"] ?? .null)
                return FileLockingPolicyChangedDetails(newValue: newValue, previousValue: previousValue)
            default:
                throw JSONSerializerError.deserializeError(type: FileLockingPolicyChangedDetails.self, json: json)
            }
        }
    }

    /// The FileLockingPolicyChangedType struct
    public class FileLockingPolicyChangedType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try FileLockingPolicyChangedTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try FileLockingPolicyChangedTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for FileLockingPolicyChangedType: \(error)"
            }
        }
    }

    public class FileLockingPolicyChangedTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: FileLockingPolicyChangedType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> FileLockingPolicyChangedType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return FileLockingPolicyChangedType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: FileLockingPolicyChangedType.self, json: json)
            }
        }
    }

    /// Generic information relevant both for files and folders
    public class FileOrFolderLogInfo: CustomStringConvertible, JSONRepresentable {
        /// Path relative to event context.
        public let path: TeamLog.PathLogInfo
        /// Display name.
        public let displayName: String?
        /// Unique ID.
        public let fileId: String?
        /// File or folder size in bytes.
        public let fileSize: UInt64?
        public init(path: TeamLog.PathLogInfo, displayName: String? = nil, fileId: String? = nil, fileSize: UInt64? = nil) {
            self.path = path
            nullableValidator(stringValidator())(displayName)
            self.displayName = displayName
            nullableValidator(stringValidator())(fileId)
            self.fileId = fileId
            nullableValidator(comparableValidator())(fileSize)
            self.fileSize = fileSize
        }

        func json() throws -> JSON {
            try FileOrFolderLogInfoSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try FileOrFolderLogInfoSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for FileOrFolderLogInfo: \(error)"
            }
        }
    }

    public class FileOrFolderLogInfoSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: FileOrFolderLogInfo) throws -> JSON {
            let output = [
                "path": try TeamLog.PathLogInfoSerializer().serialize(value.path),
                "display_name": try NullableSerializer(Serialization._StringSerializer).serialize(value.displayName),
                "file_id": try NullableSerializer(Serialization._StringSerializer).serialize(value.fileId),
                "file_size": try NullableSerializer(Serialization._UInt64Serializer).serialize(value.fileSize),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> FileOrFolderLogInfo {
            switch json {
            case .dictionary(let dict):
                let path = try TeamLog.PathLogInfoSerializer().deserialize(dict["path"] ?? .null)
                let displayName = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["display_name"] ?? .null)
                let fileId = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["file_id"] ?? .null)
                let fileSize = try NullableSerializer(Serialization._UInt64Serializer).deserialize(dict["file_size"] ?? .null)
                return FileOrFolderLogInfo(path: path, displayName: displayName, fileId: fileId, fileSize: fileSize)
            default:
                throw JSONSerializerError.deserializeError(type: FileOrFolderLogInfo.self, json: json)
            }
        }
    }

    /// File's logged information.
    public class FileLogInfo: TeamLog.FileOrFolderLogInfo {
        public override var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try FileLogInfoSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for FileLogInfo: \(error)"
            }
        }
    }

    public class FileLogInfoSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: FileLogInfo) throws -> JSON {
            let output = [
                "path": try TeamLog.PathLogInfoSerializer().serialize(value.path),
                "display_name": try NullableSerializer(Serialization._StringSerializer).serialize(value.displayName),
                "file_id": try NullableSerializer(Serialization._StringSerializer).serialize(value.fileId),
                "file_size": try NullableSerializer(Serialization._UInt64Serializer).serialize(value.fileSize),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> FileLogInfo {
            switch json {
            case .dictionary(let dict):
                let path = try TeamLog.PathLogInfoSerializer().deserialize(dict["path"] ?? .null)
                let displayName = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["display_name"] ?? .null)
                let fileId = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["file_id"] ?? .null)
                let fileSize = try NullableSerializer(Serialization._UInt64Serializer).deserialize(dict["file_size"] ?? .null)
                return FileLogInfo(path: path, displayName: displayName, fileId: fileId, fileSize: fileSize)
            default:
                throw JSONSerializerError.deserializeError(type: FileLogInfo.self, json: json)
            }
        }
    }

    /// Moved files and/or folders.
    public class FileMoveDetails: CustomStringConvertible, JSONRepresentable {
        /// Relocate action details.
        public let relocateActionDetails: [TeamLog.RelocateAssetReferencesLogInfo]
        public init(relocateActionDetails: [TeamLog.RelocateAssetReferencesLogInfo]) {
            self.relocateActionDetails = relocateActionDetails
        }

        func json() throws -> JSON {
            try FileMoveDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try FileMoveDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for FileMoveDetails: \(error)"
            }
        }
    }

    public class FileMoveDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: FileMoveDetails) throws -> JSON {
            let output = [
                "relocate_action_details": try ArraySerializer(TeamLog.RelocateAssetReferencesLogInfoSerializer()).serialize(value.relocateActionDetails),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> FileMoveDetails {
            switch json {
            case .dictionary(let dict):
                let relocateActionDetails = try ArraySerializer(TeamLog.RelocateAssetReferencesLogInfoSerializer())
                    .deserialize(dict["relocate_action_details"] ?? .null)
                return FileMoveDetails(relocateActionDetails: relocateActionDetails)
            default:
                throw JSONSerializerError.deserializeError(type: FileMoveDetails.self, json: json)
            }
        }
    }

    /// The FileMoveType struct
    public class FileMoveType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try FileMoveTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try FileMoveTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for FileMoveType: \(error)"
            }
        }
    }

    public class FileMoveTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: FileMoveType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> FileMoveType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return FileMoveType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: FileMoveType.self, json: json)
            }
        }
    }

    /// Permanently deleted files and/or folders.
    public class FilePermanentlyDeleteDetails: CustomStringConvertible, JSONRepresentable {
        func json() throws -> JSON {
            try FilePermanentlyDeleteDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try FilePermanentlyDeleteDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for FilePermanentlyDeleteDetails: \(error)"
            }
        }
    }

    public class FilePermanentlyDeleteDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: FilePermanentlyDeleteDetails) throws -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> FilePermanentlyDeleteDetails {
            switch json {
            case .dictionary:
                return FilePermanentlyDeleteDetails()
            default:
                throw JSONSerializerError.deserializeError(type: FilePermanentlyDeleteDetails.self, json: json)
            }
        }
    }

    /// The FilePermanentlyDeleteType struct
    public class FilePermanentlyDeleteType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try FilePermanentlyDeleteTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try FilePermanentlyDeleteTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for FilePermanentlyDeleteType: \(error)"
            }
        }
    }

    public class FilePermanentlyDeleteTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: FilePermanentlyDeleteType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> FilePermanentlyDeleteType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return FilePermanentlyDeleteType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: FilePermanentlyDeleteType.self, json: json)
            }
        }
    }

    /// Previewed files and/or folders.
    public class FilePreviewDetails: CustomStringConvertible, JSONRepresentable {
        func json() throws -> JSON {
            try FilePreviewDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try FilePreviewDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for FilePreviewDetails: \(error)"
            }
        }
    }

    public class FilePreviewDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: FilePreviewDetails) throws -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> FilePreviewDetails {
            switch json {
            case .dictionary:
                return FilePreviewDetails()
            default:
                throw JSONSerializerError.deserializeError(type: FilePreviewDetails.self, json: json)
            }
        }
    }

    /// The FilePreviewType struct
    public class FilePreviewType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try FilePreviewTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try FilePreviewTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for FilePreviewType: \(error)"
            }
        }
    }

    public class FilePreviewTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: FilePreviewType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> FilePreviewType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return FilePreviewType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: FilePreviewType.self, json: json)
            }
        }
    }

    /// Changed File Provider Migration policy for team.
    public class FileProviderMigrationPolicyChangedDetails: CustomStringConvertible, JSONRepresentable {
        /// To.
        public let newValue: TeamPolicies.FileProviderMigrationPolicyState
        /// From.
        public let previousValue: TeamPolicies.FileProviderMigrationPolicyState
        public init(newValue: TeamPolicies.FileProviderMigrationPolicyState, previousValue: TeamPolicies.FileProviderMigrationPolicyState) {
            self.newValue = newValue
            self.previousValue = previousValue
        }

        func json() throws -> JSON {
            try FileProviderMigrationPolicyChangedDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try FileProviderMigrationPolicyChangedDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for FileProviderMigrationPolicyChangedDetails: \(error)"
            }
        }
    }

    public class FileProviderMigrationPolicyChangedDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: FileProviderMigrationPolicyChangedDetails) throws -> JSON {
            let output = [
                "new_value": try TeamPolicies.FileProviderMigrationPolicyStateSerializer().serialize(value.newValue),
                "previous_value": try TeamPolicies.FileProviderMigrationPolicyStateSerializer().serialize(value.previousValue),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> FileProviderMigrationPolicyChangedDetails {
            switch json {
            case .dictionary(let dict):
                let newValue = try TeamPolicies.FileProviderMigrationPolicyStateSerializer().deserialize(dict["new_value"] ?? .null)
                let previousValue = try TeamPolicies.FileProviderMigrationPolicyStateSerializer().deserialize(dict["previous_value"] ?? .null)
                return FileProviderMigrationPolicyChangedDetails(newValue: newValue, previousValue: previousValue)
            default:
                throw JSONSerializerError.deserializeError(type: FileProviderMigrationPolicyChangedDetails.self, json: json)
            }
        }
    }

    /// The FileProviderMigrationPolicyChangedType struct
    public class FileProviderMigrationPolicyChangedType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try FileProviderMigrationPolicyChangedTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try FileProviderMigrationPolicyChangedTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for FileProviderMigrationPolicyChangedType: \(error)"
            }
        }
    }

    public class FileProviderMigrationPolicyChangedTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: FileProviderMigrationPolicyChangedType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> FileProviderMigrationPolicyChangedType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return FileProviderMigrationPolicyChangedType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: FileProviderMigrationPolicyChangedType.self, json: json)
            }
        }
    }

    /// Renamed files and/or folders.
    public class FileRenameDetails: CustomStringConvertible, JSONRepresentable {
        /// Relocate action details.
        public let relocateActionDetails: [TeamLog.RelocateAssetReferencesLogInfo]
        public init(relocateActionDetails: [TeamLog.RelocateAssetReferencesLogInfo]) {
            self.relocateActionDetails = relocateActionDetails
        }

        func json() throws -> JSON {
            try FileRenameDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try FileRenameDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for FileRenameDetails: \(error)"
            }
        }
    }

    public class FileRenameDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: FileRenameDetails) throws -> JSON {
            let output = [
                "relocate_action_details": try ArraySerializer(TeamLog.RelocateAssetReferencesLogInfoSerializer()).serialize(value.relocateActionDetails),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> FileRenameDetails {
            switch json {
            case .dictionary(let dict):
                let relocateActionDetails = try ArraySerializer(TeamLog.RelocateAssetReferencesLogInfoSerializer())
                    .deserialize(dict["relocate_action_details"] ?? .null)
                return FileRenameDetails(relocateActionDetails: relocateActionDetails)
            default:
                throw JSONSerializerError.deserializeError(type: FileRenameDetails.self, json: json)
            }
        }
    }

    /// The FileRenameType struct
    public class FileRenameType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try FileRenameTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try FileRenameTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for FileRenameType: \(error)"
            }
        }
    }

    public class FileRenameTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: FileRenameType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> FileRenameType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return FileRenameType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: FileRenameType.self, json: json)
            }
        }
    }

    /// Changed file request.
    public class FileRequestChangeDetails: CustomStringConvertible, JSONRepresentable {
        /// File request id. Might be missing due to historical data gap.
        public let fileRequestId: String?
        /// Previous file request details. Might be missing due to historical data gap.
        public let previousDetails: TeamLog.FileRequestDetails?
        /// New file request details.
        public let newDetails: TeamLog.FileRequestDetails
        public init(newDetails: TeamLog.FileRequestDetails, fileRequestId: String? = nil, previousDetails: TeamLog.FileRequestDetails? = nil) {
            nullableValidator(stringValidator(minLength: 1, pattern: "[-_0-9a-zA-Z]+"))(fileRequestId)
            self.fileRequestId = fileRequestId
            self.previousDetails = previousDetails
            self.newDetails = newDetails
        }

        func json() throws -> JSON {
            try FileRequestChangeDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try FileRequestChangeDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for FileRequestChangeDetails: \(error)"
            }
        }
    }

    public class FileRequestChangeDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: FileRequestChangeDetails) throws -> JSON {
            let output = [
                "new_details": try TeamLog.FileRequestDetailsSerializer().serialize(value.newDetails),
                "file_request_id": try NullableSerializer(Serialization._StringSerializer).serialize(value.fileRequestId),
                "previous_details": try NullableSerializer(TeamLog.FileRequestDetailsSerializer()).serialize(value.previousDetails),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> FileRequestChangeDetails {
            switch json {
            case .dictionary(let dict):
                let newDetails = try TeamLog.FileRequestDetailsSerializer().deserialize(dict["new_details"] ?? .null)
                let fileRequestId = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["file_request_id"] ?? .null)
                let previousDetails = try NullableSerializer(TeamLog.FileRequestDetailsSerializer()).deserialize(dict["previous_details"] ?? .null)
                return FileRequestChangeDetails(newDetails: newDetails, fileRequestId: fileRequestId, previousDetails: previousDetails)
            default:
                throw JSONSerializerError.deserializeError(type: FileRequestChangeDetails.self, json: json)
            }
        }
    }

    /// The FileRequestChangeType struct
    public class FileRequestChangeType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try FileRequestChangeTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try FileRequestChangeTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for FileRequestChangeType: \(error)"
            }
        }
    }

    public class FileRequestChangeTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: FileRequestChangeType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> FileRequestChangeType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return FileRequestChangeType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: FileRequestChangeType.self, json: json)
            }
        }
    }

    /// Closed file request.
    public class FileRequestCloseDetails: CustomStringConvertible, JSONRepresentable {
        /// File request id. Might be missing due to historical data gap.
        public let fileRequestId: String?
        /// Previous file request details. Might be missing due to historical data gap.
        public let previousDetails: TeamLog.FileRequestDetails?
        public init(fileRequestId: String? = nil, previousDetails: TeamLog.FileRequestDetails? = nil) {
            nullableValidator(stringValidator(minLength: 1, pattern: "[-_0-9a-zA-Z]+"))(fileRequestId)
            self.fileRequestId = fileRequestId
            self.previousDetails = previousDetails
        }

        func json() throws -> JSON {
            try FileRequestCloseDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try FileRequestCloseDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for FileRequestCloseDetails: \(error)"
            }
        }
    }

    public class FileRequestCloseDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: FileRequestCloseDetails) throws -> JSON {
            let output = [
                "file_request_id": try NullableSerializer(Serialization._StringSerializer).serialize(value.fileRequestId),
                "previous_details": try NullableSerializer(TeamLog.FileRequestDetailsSerializer()).serialize(value.previousDetails),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> FileRequestCloseDetails {
            switch json {
            case .dictionary(let dict):
                let fileRequestId = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["file_request_id"] ?? .null)
                let previousDetails = try NullableSerializer(TeamLog.FileRequestDetailsSerializer()).deserialize(dict["previous_details"] ?? .null)
                return FileRequestCloseDetails(fileRequestId: fileRequestId, previousDetails: previousDetails)
            default:
                throw JSONSerializerError.deserializeError(type: FileRequestCloseDetails.self, json: json)
            }
        }
    }

    /// The FileRequestCloseType struct
    public class FileRequestCloseType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try FileRequestCloseTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try FileRequestCloseTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for FileRequestCloseType: \(error)"
            }
        }
    }

    public class FileRequestCloseTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: FileRequestCloseType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> FileRequestCloseType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return FileRequestCloseType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: FileRequestCloseType.self, json: json)
            }
        }
    }

    /// Created file request.
    public class FileRequestCreateDetails: CustomStringConvertible, JSONRepresentable {
        /// File request id. Might be missing due to historical data gap.
        public let fileRequestId: String?
        /// File request details. Might be missing due to historical data gap.
        public let requestDetails: TeamLog.FileRequestDetails?
        public init(fileRequestId: String? = nil, requestDetails: TeamLog.FileRequestDetails? = nil) {
            nullableValidator(stringValidator(minLength: 1, pattern: "[-_0-9a-zA-Z]+"))(fileRequestId)
            self.fileRequestId = fileRequestId
            self.requestDetails = requestDetails
        }

        func json() throws -> JSON {
            try FileRequestCreateDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try FileRequestCreateDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for FileRequestCreateDetails: \(error)"
            }
        }
    }

    public class FileRequestCreateDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: FileRequestCreateDetails) throws -> JSON {
            let output = [
                "file_request_id": try NullableSerializer(Serialization._StringSerializer).serialize(value.fileRequestId),
                "request_details": try NullableSerializer(TeamLog.FileRequestDetailsSerializer()).serialize(value.requestDetails),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> FileRequestCreateDetails {
            switch json {
            case .dictionary(let dict):
                let fileRequestId = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["file_request_id"] ?? .null)
                let requestDetails = try NullableSerializer(TeamLog.FileRequestDetailsSerializer()).deserialize(dict["request_details"] ?? .null)
                return FileRequestCreateDetails(fileRequestId: fileRequestId, requestDetails: requestDetails)
            default:
                throw JSONSerializerError.deserializeError(type: FileRequestCreateDetails.self, json: json)
            }
        }
    }

    /// The FileRequestCreateType struct
    public class FileRequestCreateType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try FileRequestCreateTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try FileRequestCreateTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for FileRequestCreateType: \(error)"
            }
        }
    }

    public class FileRequestCreateTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: FileRequestCreateType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> FileRequestCreateType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return FileRequestCreateType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: FileRequestCreateType.self, json: json)
            }
        }
    }

    /// File request deadline
    public class FileRequestDeadline: CustomStringConvertible, JSONRepresentable {
        /// The deadline for this file request. Might be missing due to historical data gap.
        public let deadline: Date?
        /// If set, allow uploads after the deadline has passed.
        public let allowLateUploads: String?
        public init(deadline: Date? = nil, allowLateUploads: String? = nil) {
            self.deadline = deadline
            nullableValidator(stringValidator())(allowLateUploads)
            self.allowLateUploads = allowLateUploads
        }

        func json() throws -> JSON {
            try FileRequestDeadlineSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try FileRequestDeadlineSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for FileRequestDeadline: \(error)"
            }
        }
    }

    public class FileRequestDeadlineSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: FileRequestDeadline) throws -> JSON {
            let output = [
                "deadline": try NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.deadline),
                "allow_late_uploads": try NullableSerializer(Serialization._StringSerializer).serialize(value.allowLateUploads),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> FileRequestDeadline {
            switch json {
            case .dictionary(let dict):
                let deadline = try NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).deserialize(dict["deadline"] ?? .null)
                let allowLateUploads = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["allow_late_uploads"] ?? .null)
                return FileRequestDeadline(deadline: deadline, allowLateUploads: allowLateUploads)
            default:
                throw JSONSerializerError.deserializeError(type: FileRequestDeadline.self, json: json)
            }
        }
    }

    /// Delete file request.
    public class FileRequestDeleteDetails: CustomStringConvertible, JSONRepresentable {
        /// File request id. Might be missing due to historical data gap.
        public let fileRequestId: String?
        /// Previous file request details. Might be missing due to historical data gap.
        public let previousDetails: TeamLog.FileRequestDetails?
        public init(fileRequestId: String? = nil, previousDetails: TeamLog.FileRequestDetails? = nil) {
            nullableValidator(stringValidator(minLength: 1, pattern: "[-_0-9a-zA-Z]+"))(fileRequestId)
            self.fileRequestId = fileRequestId
            self.previousDetails = previousDetails
        }

        func json() throws -> JSON {
            try FileRequestDeleteDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try FileRequestDeleteDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for FileRequestDeleteDetails: \(error)"
            }
        }
    }

    public class FileRequestDeleteDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: FileRequestDeleteDetails) throws -> JSON {
            let output = [
                "file_request_id": try NullableSerializer(Serialization._StringSerializer).serialize(value.fileRequestId),
                "previous_details": try NullableSerializer(TeamLog.FileRequestDetailsSerializer()).serialize(value.previousDetails),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> FileRequestDeleteDetails {
            switch json {
            case .dictionary(let dict):
                let fileRequestId = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["file_request_id"] ?? .null)
                let previousDetails = try NullableSerializer(TeamLog.FileRequestDetailsSerializer()).deserialize(dict["previous_details"] ?? .null)
                return FileRequestDeleteDetails(fileRequestId: fileRequestId, previousDetails: previousDetails)
            default:
                throw JSONSerializerError.deserializeError(type: FileRequestDeleteDetails.self, json: json)
            }
        }
    }

    /// The FileRequestDeleteType struct
    public class FileRequestDeleteType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try FileRequestDeleteTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try FileRequestDeleteTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for FileRequestDeleteType: \(error)"
            }
        }
    }

    public class FileRequestDeleteTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: FileRequestDeleteType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> FileRequestDeleteType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return FileRequestDeleteType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: FileRequestDeleteType.self, json: json)
            }
        }
    }

    /// File request details
    public class FileRequestDetails: CustomStringConvertible, JSONRepresentable {
        /// Asset position in the Assets list.
        public let assetIndex: UInt64
        /// File request deadline.
        public let deadline: TeamLog.FileRequestDeadline?
        public init(assetIndex: UInt64, deadline: TeamLog.FileRequestDeadline? = nil) {
            comparableValidator()(assetIndex)
            self.assetIndex = assetIndex
            self.deadline = deadline
        }

        func json() throws -> JSON {
            try FileRequestDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try FileRequestDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for FileRequestDetails: \(error)"
            }
        }
    }

    public class FileRequestDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: FileRequestDetails) throws -> JSON {
            let output = [
                "asset_index": try Serialization._UInt64Serializer.serialize(value.assetIndex),
                "deadline": try NullableSerializer(TeamLog.FileRequestDeadlineSerializer()).serialize(value.deadline),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> FileRequestDetails {
            switch json {
            case .dictionary(let dict):
                let assetIndex = try Serialization._UInt64Serializer.deserialize(dict["asset_index"] ?? .null)
                let deadline = try NullableSerializer(TeamLog.FileRequestDeadlineSerializer()).deserialize(dict["deadline"] ?? .null)
                return FileRequestDetails(assetIndex: assetIndex, deadline: deadline)
            default:
                throw JSONSerializerError.deserializeError(type: FileRequestDetails.self, json: json)
            }
        }
    }

    /// Received files for file request.
    public class FileRequestReceiveFileDetails: CustomStringConvertible, JSONRepresentable {
        /// File request id. Might be missing due to historical data gap.
        public let fileRequestId: String?
        /// File request details. Might be missing due to historical data gap.
        public let fileRequestDetails: TeamLog.FileRequestDetails?
        /// Submitted file names.
        public let submittedFileNames: [String]
        /// The name as provided by the submitter.
        public let submitterName: String?
        /// The email as provided by the submitter.
        public let submitterEmail: String?
        public init(
            submittedFileNames: [String],
            fileRequestId: String? = nil,
            fileRequestDetails: TeamLog.FileRequestDetails? = nil,
            submitterName: String? = nil,
            submitterEmail: String? = nil
        ) {
            nullableValidator(stringValidator(minLength: 1, pattern: "[-_0-9a-zA-Z]+"))(fileRequestId)
            self.fileRequestId = fileRequestId
            self.fileRequestDetails = fileRequestDetails
            arrayValidator(itemValidator: stringValidator())(submittedFileNames)
            self.submittedFileNames = submittedFileNames
            nullableValidator(stringValidator())(submitterName)
            self.submitterName = submitterName
            nullableValidator(stringValidator(maxLength: 255))(submitterEmail)
            self.submitterEmail = submitterEmail
        }

        func json() throws -> JSON {
            try FileRequestReceiveFileDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try FileRequestReceiveFileDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for FileRequestReceiveFileDetails: \(error)"
            }
        }
    }

    public class FileRequestReceiveFileDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: FileRequestReceiveFileDetails) throws -> JSON {
            let output = [
                "submitted_file_names": try ArraySerializer(Serialization._StringSerializer).serialize(value.submittedFileNames),
                "file_request_id": try NullableSerializer(Serialization._StringSerializer).serialize(value.fileRequestId),
                "file_request_details": try NullableSerializer(TeamLog.FileRequestDetailsSerializer()).serialize(value.fileRequestDetails),
                "submitter_name": try NullableSerializer(Serialization._StringSerializer).serialize(value.submitterName),
                "submitter_email": try NullableSerializer(Serialization._StringSerializer).serialize(value.submitterEmail),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> FileRequestReceiveFileDetails {
            switch json {
            case .dictionary(let dict):
                let submittedFileNames = try ArraySerializer(Serialization._StringSerializer).deserialize(dict["submitted_file_names"] ?? .null)
                let fileRequestId = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["file_request_id"] ?? .null)
                let fileRequestDetails = try NullableSerializer(TeamLog.FileRequestDetailsSerializer()).deserialize(dict["file_request_details"] ?? .null)
                let submitterName = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["submitter_name"] ?? .null)
                let submitterEmail = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["submitter_email"] ?? .null)
                return FileRequestReceiveFileDetails(
                    submittedFileNames: submittedFileNames,
                    fileRequestId: fileRequestId,
                    fileRequestDetails: fileRequestDetails,
                    submitterName: submitterName,
                    submitterEmail: submitterEmail
                )
            default:
                throw JSONSerializerError.deserializeError(type: FileRequestReceiveFileDetails.self, json: json)
            }
        }
    }

    /// The FileRequestReceiveFileType struct
    public class FileRequestReceiveFileType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try FileRequestReceiveFileTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try FileRequestReceiveFileTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for FileRequestReceiveFileType: \(error)"
            }
        }
    }

    public class FileRequestReceiveFileTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: FileRequestReceiveFileType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> FileRequestReceiveFileType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return FileRequestReceiveFileType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: FileRequestReceiveFileType.self, json: json)
            }
        }
    }

    /// Enabled/disabled file requests.
    public class FileRequestsChangePolicyDetails: CustomStringConvertible, JSONRepresentable {
        /// New file requests policy.
        public let newValue: TeamLog.FileRequestsPolicy
        /// Previous file requests policy. Might be missing due to historical data gap.
        public let previousValue: TeamLog.FileRequestsPolicy?
        public init(newValue: TeamLog.FileRequestsPolicy, previousValue: TeamLog.FileRequestsPolicy? = nil) {
            self.newValue = newValue
            self.previousValue = previousValue
        }

        func json() throws -> JSON {
            try FileRequestsChangePolicyDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try FileRequestsChangePolicyDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for FileRequestsChangePolicyDetails: \(error)"
            }
        }
    }

    public class FileRequestsChangePolicyDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: FileRequestsChangePolicyDetails) throws -> JSON {
            let output = [
                "new_value": try TeamLog.FileRequestsPolicySerializer().serialize(value.newValue),
                "previous_value": try NullableSerializer(TeamLog.FileRequestsPolicySerializer()).serialize(value.previousValue),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> FileRequestsChangePolicyDetails {
            switch json {
            case .dictionary(let dict):
                let newValue = try TeamLog.FileRequestsPolicySerializer().deserialize(dict["new_value"] ?? .null)
                let previousValue = try NullableSerializer(TeamLog.FileRequestsPolicySerializer()).deserialize(dict["previous_value"] ?? .null)
                return FileRequestsChangePolicyDetails(newValue: newValue, previousValue: previousValue)
            default:
                throw JSONSerializerError.deserializeError(type: FileRequestsChangePolicyDetails.self, json: json)
            }
        }
    }

    /// The FileRequestsChangePolicyType struct
    public class FileRequestsChangePolicyType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try FileRequestsChangePolicyTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try FileRequestsChangePolicyTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for FileRequestsChangePolicyType: \(error)"
            }
        }
    }

    public class FileRequestsChangePolicyTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: FileRequestsChangePolicyType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> FileRequestsChangePolicyType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return FileRequestsChangePolicyType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: FileRequestsChangePolicyType.self, json: json)
            }
        }
    }

    /// Enabled file request emails for everyone.
    public class FileRequestsEmailsEnabledDetails: CustomStringConvertible, JSONRepresentable {
        func json() throws -> JSON {
            try FileRequestsEmailsEnabledDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try FileRequestsEmailsEnabledDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for FileRequestsEmailsEnabledDetails: \(error)"
            }
        }
    }

    public class FileRequestsEmailsEnabledDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: FileRequestsEmailsEnabledDetails) throws -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> FileRequestsEmailsEnabledDetails {
            switch json {
            case .dictionary:
                return FileRequestsEmailsEnabledDetails()
            default:
                throw JSONSerializerError.deserializeError(type: FileRequestsEmailsEnabledDetails.self, json: json)
            }
        }
    }

    /// The FileRequestsEmailsEnabledType struct
    public class FileRequestsEmailsEnabledType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try FileRequestsEmailsEnabledTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try FileRequestsEmailsEnabledTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for FileRequestsEmailsEnabledType: \(error)"
            }
        }
    }

    public class FileRequestsEmailsEnabledTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: FileRequestsEmailsEnabledType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> FileRequestsEmailsEnabledType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return FileRequestsEmailsEnabledType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: FileRequestsEmailsEnabledType.self, json: json)
            }
        }
    }

    /// Enabled file request emails for team.
    public class FileRequestsEmailsRestrictedToTeamOnlyDetails: CustomStringConvertible, JSONRepresentable {
        func json() throws -> JSON {
            try FileRequestsEmailsRestrictedToTeamOnlyDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try FileRequestsEmailsRestrictedToTeamOnlyDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for FileRequestsEmailsRestrictedToTeamOnlyDetails: \(error)"
            }
        }
    }

    public class FileRequestsEmailsRestrictedToTeamOnlyDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: FileRequestsEmailsRestrictedToTeamOnlyDetails) throws -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> FileRequestsEmailsRestrictedToTeamOnlyDetails {
            switch json {
            case .dictionary:
                return FileRequestsEmailsRestrictedToTeamOnlyDetails()
            default:
                throw JSONSerializerError.deserializeError(type: FileRequestsEmailsRestrictedToTeamOnlyDetails.self, json: json)
            }
        }
    }

    /// The FileRequestsEmailsRestrictedToTeamOnlyType struct
    public class FileRequestsEmailsRestrictedToTeamOnlyType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try FileRequestsEmailsRestrictedToTeamOnlyTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try FileRequestsEmailsRestrictedToTeamOnlyTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for FileRequestsEmailsRestrictedToTeamOnlyType: \(error)"
            }
        }
    }

    public class FileRequestsEmailsRestrictedToTeamOnlyTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: FileRequestsEmailsRestrictedToTeamOnlyType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> FileRequestsEmailsRestrictedToTeamOnlyType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return FileRequestsEmailsRestrictedToTeamOnlyType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: FileRequestsEmailsRestrictedToTeamOnlyType.self, json: json)
            }
        }
    }

    /// File requests policy
    public enum FileRequestsPolicy: CustomStringConvertible, JSONRepresentable {
        /// An unspecified error.
        case disabled
        /// An unspecified error.
        case enabled
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try FileRequestsPolicySerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try FileRequestsPolicySerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for FileRequestsPolicy: \(error)"
            }
        }
    }

    public class FileRequestsPolicySerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: FileRequestsPolicy) throws -> JSON {
            switch value {
            case .disabled:
                var d = [String: JSON]()
                d[".tag"] = .str("disabled")
                return .dictionary(d)
            case .enabled:
                var d = [String: JSON]()
                d[".tag"] = .str("enabled")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> FileRequestsPolicy {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "disabled":
                    return FileRequestsPolicy.disabled
                case "enabled":
                    return FileRequestsPolicy.enabled
                case "other":
                    return FileRequestsPolicy.other
                default:
                    return FileRequestsPolicy.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: FileRequestsPolicy.self, json: json)
            }
        }
    }

    /// Resolved file comment.
    public class FileResolveCommentDetails: CustomStringConvertible, JSONRepresentable {
        /// Comment text.
        public let commentText: String?
        public init(commentText: String? = nil) {
            nullableValidator(stringValidator())(commentText)
            self.commentText = commentText
        }

        func json() throws -> JSON {
            try FileResolveCommentDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try FileResolveCommentDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for FileResolveCommentDetails: \(error)"
            }
        }
    }

    public class FileResolveCommentDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: FileResolveCommentDetails) throws -> JSON {
            let output = [
                "comment_text": try NullableSerializer(Serialization._StringSerializer).serialize(value.commentText),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> FileResolveCommentDetails {
            switch json {
            case .dictionary(let dict):
                let commentText = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["comment_text"] ?? .null)
                return FileResolveCommentDetails(commentText: commentText)
            default:
                throw JSONSerializerError.deserializeError(type: FileResolveCommentDetails.self, json: json)
            }
        }
    }

    /// The FileResolveCommentType struct
    public class FileResolveCommentType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try FileResolveCommentTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try FileResolveCommentTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for FileResolveCommentType: \(error)"
            }
        }
    }

    public class FileResolveCommentTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: FileResolveCommentType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> FileResolveCommentType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return FileResolveCommentType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: FileResolveCommentType.self, json: json)
            }
        }
    }

    /// Restored deleted files and/or folders.
    public class FileRestoreDetails: CustomStringConvertible, JSONRepresentable {
        func json() throws -> JSON {
            try FileRestoreDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try FileRestoreDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for FileRestoreDetails: \(error)"
            }
        }
    }

    public class FileRestoreDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: FileRestoreDetails) throws -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> FileRestoreDetails {
            switch json {
            case .dictionary:
                return FileRestoreDetails()
            default:
                throw JSONSerializerError.deserializeError(type: FileRestoreDetails.self, json: json)
            }
        }
    }

    /// The FileRestoreType struct
    public class FileRestoreType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try FileRestoreTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try FileRestoreTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for FileRestoreType: \(error)"
            }
        }
    }

    public class FileRestoreTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: FileRestoreType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> FileRestoreType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return FileRestoreType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: FileRestoreType.self, json: json)
            }
        }
    }

    /// Reverted files to previous version.
    public class FileRevertDetails: CustomStringConvertible, JSONRepresentable {
        func json() throws -> JSON {
            try FileRevertDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try FileRevertDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for FileRevertDetails: \(error)"
            }
        }
    }

    public class FileRevertDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: FileRevertDetails) throws -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> FileRevertDetails {
            switch json {
            case .dictionary:
                return FileRevertDetails()
            default:
                throw JSONSerializerError.deserializeError(type: FileRevertDetails.self, json: json)
            }
        }
    }

    /// The FileRevertType struct
    public class FileRevertType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try FileRevertTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try FileRevertTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for FileRevertType: \(error)"
            }
        }
    }

    public class FileRevertTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: FileRevertType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> FileRevertType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return FileRevertType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: FileRevertType.self, json: json)
            }
        }
    }

    /// Rolled back file actions.
    public class FileRollbackChangesDetails: CustomStringConvertible, JSONRepresentable {
        func json() throws -> JSON {
            try FileRollbackChangesDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try FileRollbackChangesDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for FileRollbackChangesDetails: \(error)"
            }
        }
    }

    public class FileRollbackChangesDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: FileRollbackChangesDetails) throws -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> FileRollbackChangesDetails {
            switch json {
            case .dictionary:
                return FileRollbackChangesDetails()
            default:
                throw JSONSerializerError.deserializeError(type: FileRollbackChangesDetails.self, json: json)
            }
        }
    }

    /// The FileRollbackChangesType struct
    public class FileRollbackChangesType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try FileRollbackChangesTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try FileRollbackChangesTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for FileRollbackChangesType: \(error)"
            }
        }
    }

    public class FileRollbackChangesTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: FileRollbackChangesType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> FileRollbackChangesType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return FileRollbackChangesType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: FileRollbackChangesType.self, json: json)
            }
        }
    }

    /// Saved file/folder using copy reference.
    public class FileSaveCopyReferenceDetails: CustomStringConvertible, JSONRepresentable {
        /// Relocate action details.
        public let relocateActionDetails: [TeamLog.RelocateAssetReferencesLogInfo]
        public init(relocateActionDetails: [TeamLog.RelocateAssetReferencesLogInfo]) {
            self.relocateActionDetails = relocateActionDetails
        }

        func json() throws -> JSON {
            try FileSaveCopyReferenceDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try FileSaveCopyReferenceDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for FileSaveCopyReferenceDetails: \(error)"
            }
        }
    }

    public class FileSaveCopyReferenceDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: FileSaveCopyReferenceDetails) throws -> JSON {
            let output = [
                "relocate_action_details": try ArraySerializer(TeamLog.RelocateAssetReferencesLogInfoSerializer()).serialize(value.relocateActionDetails),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> FileSaveCopyReferenceDetails {
            switch json {
            case .dictionary(let dict):
                let relocateActionDetails = try ArraySerializer(TeamLog.RelocateAssetReferencesLogInfoSerializer())
                    .deserialize(dict["relocate_action_details"] ?? .null)
                return FileSaveCopyReferenceDetails(relocateActionDetails: relocateActionDetails)
            default:
                throw JSONSerializerError.deserializeError(type: FileSaveCopyReferenceDetails.self, json: json)
            }
        }
    }

    /// The FileSaveCopyReferenceType struct
    public class FileSaveCopyReferenceType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try FileSaveCopyReferenceTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try FileSaveCopyReferenceTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for FileSaveCopyReferenceType: \(error)"
            }
        }
    }

    public class FileSaveCopyReferenceTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: FileSaveCopyReferenceType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> FileSaveCopyReferenceType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return FileSaveCopyReferenceType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: FileSaveCopyReferenceType.self, json: json)
            }
        }
    }

    /// Transfer files added.
    public class FileTransfersFileAddDetails: CustomStringConvertible, JSONRepresentable {
        /// Transfer id.
        public let fileTransferId: String
        public init(fileTransferId: String) {
            stringValidator()(fileTransferId)
            self.fileTransferId = fileTransferId
        }

        func json() throws -> JSON {
            try FileTransfersFileAddDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try FileTransfersFileAddDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for FileTransfersFileAddDetails: \(error)"
            }
        }
    }

    public class FileTransfersFileAddDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: FileTransfersFileAddDetails) throws -> JSON {
            let output = [
                "file_transfer_id": try Serialization._StringSerializer.serialize(value.fileTransferId),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> FileTransfersFileAddDetails {
            switch json {
            case .dictionary(let dict):
                let fileTransferId = try Serialization._StringSerializer.deserialize(dict["file_transfer_id"] ?? .null)
                return FileTransfersFileAddDetails(fileTransferId: fileTransferId)
            default:
                throw JSONSerializerError.deserializeError(type: FileTransfersFileAddDetails.self, json: json)
            }
        }
    }

    /// The FileTransfersFileAddType struct
    public class FileTransfersFileAddType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try FileTransfersFileAddTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try FileTransfersFileAddTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for FileTransfersFileAddType: \(error)"
            }
        }
    }

    public class FileTransfersFileAddTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: FileTransfersFileAddType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> FileTransfersFileAddType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return FileTransfersFileAddType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: FileTransfersFileAddType.self, json: json)
            }
        }
    }

    /// File transfers policy
    public enum FileTransfersPolicy: CustomStringConvertible, JSONRepresentable {
        /// An unspecified error.
        case disabled
        /// An unspecified error.
        case enabled
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try FileTransfersPolicySerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try FileTransfersPolicySerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for FileTransfersPolicy: \(error)"
            }
        }
    }

    public class FileTransfersPolicySerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: FileTransfersPolicy) throws -> JSON {
            switch value {
            case .disabled:
                var d = [String: JSON]()
                d[".tag"] = .str("disabled")
                return .dictionary(d)
            case .enabled:
                var d = [String: JSON]()
                d[".tag"] = .str("enabled")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> FileTransfersPolicy {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "disabled":
                    return FileTransfersPolicy.disabled
                case "enabled":
                    return FileTransfersPolicy.enabled
                case "other":
                    return FileTransfersPolicy.other
                default:
                    return FileTransfersPolicy.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: FileTransfersPolicy.self, json: json)
            }
        }
    }

    /// Changed file transfers policy for team.
    public class FileTransfersPolicyChangedDetails: CustomStringConvertible, JSONRepresentable {
        /// New file transfers policy.
        public let newValue: TeamLog.FileTransfersPolicy
        /// Previous file transfers policy.
        public let previousValue: TeamLog.FileTransfersPolicy
        public init(newValue: TeamLog.FileTransfersPolicy, previousValue: TeamLog.FileTransfersPolicy) {
            self.newValue = newValue
            self.previousValue = previousValue
        }

        func json() throws -> JSON {
            try FileTransfersPolicyChangedDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try FileTransfersPolicyChangedDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for FileTransfersPolicyChangedDetails: \(error)"
            }
        }
    }

    public class FileTransfersPolicyChangedDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: FileTransfersPolicyChangedDetails) throws -> JSON {
            let output = [
                "new_value": try TeamLog.FileTransfersPolicySerializer().serialize(value.newValue),
                "previous_value": try TeamLog.FileTransfersPolicySerializer().serialize(value.previousValue),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> FileTransfersPolicyChangedDetails {
            switch json {
            case .dictionary(let dict):
                let newValue = try TeamLog.FileTransfersPolicySerializer().deserialize(dict["new_value"] ?? .null)
                let previousValue = try TeamLog.FileTransfersPolicySerializer().deserialize(dict["previous_value"] ?? .null)
                return FileTransfersPolicyChangedDetails(newValue: newValue, previousValue: previousValue)
            default:
                throw JSONSerializerError.deserializeError(type: FileTransfersPolicyChangedDetails.self, json: json)
            }
        }
    }

    /// The FileTransfersPolicyChangedType struct
    public class FileTransfersPolicyChangedType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try FileTransfersPolicyChangedTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try FileTransfersPolicyChangedTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for FileTransfersPolicyChangedType: \(error)"
            }
        }
    }

    public class FileTransfersPolicyChangedTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: FileTransfersPolicyChangedType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> FileTransfersPolicyChangedType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return FileTransfersPolicyChangedType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: FileTransfersPolicyChangedType.self, json: json)
            }
        }
    }

    /// Deleted transfer.
    public class FileTransfersTransferDeleteDetails: CustomStringConvertible, JSONRepresentable {
        /// Transfer id.
        public let fileTransferId: String
        public init(fileTransferId: String) {
            stringValidator()(fileTransferId)
            self.fileTransferId = fileTransferId
        }

        func json() throws -> JSON {
            try FileTransfersTransferDeleteDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try FileTransfersTransferDeleteDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for FileTransfersTransferDeleteDetails: \(error)"
            }
        }
    }

    public class FileTransfersTransferDeleteDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: FileTransfersTransferDeleteDetails) throws -> JSON {
            let output = [
                "file_transfer_id": try Serialization._StringSerializer.serialize(value.fileTransferId),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> FileTransfersTransferDeleteDetails {
            switch json {
            case .dictionary(let dict):
                let fileTransferId = try Serialization._StringSerializer.deserialize(dict["file_transfer_id"] ?? .null)
                return FileTransfersTransferDeleteDetails(fileTransferId: fileTransferId)
            default:
                throw JSONSerializerError.deserializeError(type: FileTransfersTransferDeleteDetails.self, json: json)
            }
        }
    }

    /// The FileTransfersTransferDeleteType struct
    public class FileTransfersTransferDeleteType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try FileTransfersTransferDeleteTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try FileTransfersTransferDeleteTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for FileTransfersTransferDeleteType: \(error)"
            }
        }
    }

    public class FileTransfersTransferDeleteTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: FileTransfersTransferDeleteType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> FileTransfersTransferDeleteType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return FileTransfersTransferDeleteType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: FileTransfersTransferDeleteType.self, json: json)
            }
        }
    }

    /// Transfer downloaded.
    public class FileTransfersTransferDownloadDetails: CustomStringConvertible, JSONRepresentable {
        /// Transfer id.
        public let fileTransferId: String
        public init(fileTransferId: String) {
            stringValidator()(fileTransferId)
            self.fileTransferId = fileTransferId
        }

        func json() throws -> JSON {
            try FileTransfersTransferDownloadDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try FileTransfersTransferDownloadDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for FileTransfersTransferDownloadDetails: \(error)"
            }
        }
    }

    public class FileTransfersTransferDownloadDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: FileTransfersTransferDownloadDetails) throws -> JSON {
            let output = [
                "file_transfer_id": try Serialization._StringSerializer.serialize(value.fileTransferId),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> FileTransfersTransferDownloadDetails {
            switch json {
            case .dictionary(let dict):
                let fileTransferId = try Serialization._StringSerializer.deserialize(dict["file_transfer_id"] ?? .null)
                return FileTransfersTransferDownloadDetails(fileTransferId: fileTransferId)
            default:
                throw JSONSerializerError.deserializeError(type: FileTransfersTransferDownloadDetails.self, json: json)
            }
        }
    }

    /// The FileTransfersTransferDownloadType struct
    public class FileTransfersTransferDownloadType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try FileTransfersTransferDownloadTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try FileTransfersTransferDownloadTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for FileTransfersTransferDownloadType: \(error)"
            }
        }
    }

    public class FileTransfersTransferDownloadTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: FileTransfersTransferDownloadType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> FileTransfersTransferDownloadType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return FileTransfersTransferDownloadType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: FileTransfersTransferDownloadType.self, json: json)
            }
        }
    }

    /// Sent transfer.
    public class FileTransfersTransferSendDetails: CustomStringConvertible, JSONRepresentable {
        /// Transfer id.
        public let fileTransferId: String
        public init(fileTransferId: String) {
            stringValidator()(fileTransferId)
            self.fileTransferId = fileTransferId
        }

        func json() throws -> JSON {
            try FileTransfersTransferSendDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try FileTransfersTransferSendDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for FileTransfersTransferSendDetails: \(error)"
            }
        }
    }

    public class FileTransfersTransferSendDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: FileTransfersTransferSendDetails) throws -> JSON {
            let output = [
                "file_transfer_id": try Serialization._StringSerializer.serialize(value.fileTransferId),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> FileTransfersTransferSendDetails {
            switch json {
            case .dictionary(let dict):
                let fileTransferId = try Serialization._StringSerializer.deserialize(dict["file_transfer_id"] ?? .null)
                return FileTransfersTransferSendDetails(fileTransferId: fileTransferId)
            default:
                throw JSONSerializerError.deserializeError(type: FileTransfersTransferSendDetails.self, json: json)
            }
        }
    }

    /// The FileTransfersTransferSendType struct
    public class FileTransfersTransferSendType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try FileTransfersTransferSendTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try FileTransfersTransferSendTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for FileTransfersTransferSendType: \(error)"
            }
        }
    }

    public class FileTransfersTransferSendTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: FileTransfersTransferSendType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> FileTransfersTransferSendType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return FileTransfersTransferSendType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: FileTransfersTransferSendType.self, json: json)
            }
        }
    }

    /// Viewed transfer.
    public class FileTransfersTransferViewDetails: CustomStringConvertible, JSONRepresentable {
        /// Transfer id.
        public let fileTransferId: String
        public init(fileTransferId: String) {
            stringValidator()(fileTransferId)
            self.fileTransferId = fileTransferId
        }

        func json() throws -> JSON {
            try FileTransfersTransferViewDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try FileTransfersTransferViewDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for FileTransfersTransferViewDetails: \(error)"
            }
        }
    }

    public class FileTransfersTransferViewDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: FileTransfersTransferViewDetails) throws -> JSON {
            let output = [
                "file_transfer_id": try Serialization._StringSerializer.serialize(value.fileTransferId),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> FileTransfersTransferViewDetails {
            switch json {
            case .dictionary(let dict):
                let fileTransferId = try Serialization._StringSerializer.deserialize(dict["file_transfer_id"] ?? .null)
                return FileTransfersTransferViewDetails(fileTransferId: fileTransferId)
            default:
                throw JSONSerializerError.deserializeError(type: FileTransfersTransferViewDetails.self, json: json)
            }
        }
    }

    /// The FileTransfersTransferViewType struct
    public class FileTransfersTransferViewType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try FileTransfersTransferViewTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try FileTransfersTransferViewTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for FileTransfersTransferViewType: \(error)"
            }
        }
    }

    public class FileTransfersTransferViewTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: FileTransfersTransferViewType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> FileTransfersTransferViewType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return FileTransfersTransferViewType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: FileTransfersTransferViewType.self, json: json)
            }
        }
    }

    /// Unliked file comment.
    public class FileUnlikeCommentDetails: CustomStringConvertible, JSONRepresentable {
        /// Comment text.
        public let commentText: String?
        public init(commentText: String? = nil) {
            nullableValidator(stringValidator())(commentText)
            self.commentText = commentText
        }

        func json() throws -> JSON {
            try FileUnlikeCommentDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try FileUnlikeCommentDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for FileUnlikeCommentDetails: \(error)"
            }
        }
    }

    public class FileUnlikeCommentDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: FileUnlikeCommentDetails) throws -> JSON {
            let output = [
                "comment_text": try NullableSerializer(Serialization._StringSerializer).serialize(value.commentText),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> FileUnlikeCommentDetails {
            switch json {
            case .dictionary(let dict):
                let commentText = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["comment_text"] ?? .null)
                return FileUnlikeCommentDetails(commentText: commentText)
            default:
                throw JSONSerializerError.deserializeError(type: FileUnlikeCommentDetails.self, json: json)
            }
        }
    }

    /// The FileUnlikeCommentType struct
    public class FileUnlikeCommentType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try FileUnlikeCommentTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try FileUnlikeCommentTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for FileUnlikeCommentType: \(error)"
            }
        }
    }

    public class FileUnlikeCommentTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: FileUnlikeCommentType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> FileUnlikeCommentType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return FileUnlikeCommentType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: FileUnlikeCommentType.self, json: json)
            }
        }
    }

    /// Unresolved file comment.
    public class FileUnresolveCommentDetails: CustomStringConvertible, JSONRepresentable {
        /// Comment text.
        public let commentText: String?
        public init(commentText: String? = nil) {
            nullableValidator(stringValidator())(commentText)
            self.commentText = commentText
        }

        func json() throws -> JSON {
            try FileUnresolveCommentDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try FileUnresolveCommentDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for FileUnresolveCommentDetails: \(error)"
            }
        }
    }

    public class FileUnresolveCommentDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: FileUnresolveCommentDetails) throws -> JSON {
            let output = [
                "comment_text": try NullableSerializer(Serialization._StringSerializer).serialize(value.commentText),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> FileUnresolveCommentDetails {
            switch json {
            case .dictionary(let dict):
                let commentText = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["comment_text"] ?? .null)
                return FileUnresolveCommentDetails(commentText: commentText)
            default:
                throw JSONSerializerError.deserializeError(type: FileUnresolveCommentDetails.self, json: json)
            }
        }
    }

    /// The FileUnresolveCommentType struct
    public class FileUnresolveCommentType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try FileUnresolveCommentTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try FileUnresolveCommentTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for FileUnresolveCommentType: \(error)"
            }
        }
    }

    public class FileUnresolveCommentTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: FileUnresolveCommentType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> FileUnresolveCommentType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return FileUnresolveCommentType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: FileUnresolveCommentType.self, json: json)
            }
        }
    }

    /// Policy for deciding whether applying link restrictions on all team owned folders
    public enum FolderLinkRestrictionPolicy: CustomStringConvertible, JSONRepresentable {
        /// An unspecified error.
        case disabled
        /// An unspecified error.
        case enabled
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try FolderLinkRestrictionPolicySerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try FolderLinkRestrictionPolicySerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for FolderLinkRestrictionPolicy: \(error)"
            }
        }
    }

    public class FolderLinkRestrictionPolicySerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: FolderLinkRestrictionPolicy) throws -> JSON {
            switch value {
            case .disabled:
                var d = [String: JSON]()
                d[".tag"] = .str("disabled")
                return .dictionary(d)
            case .enabled:
                var d = [String: JSON]()
                d[".tag"] = .str("enabled")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> FolderLinkRestrictionPolicy {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "disabled":
                    return FolderLinkRestrictionPolicy.disabled
                case "enabled":
                    return FolderLinkRestrictionPolicy.enabled
                case "other":
                    return FolderLinkRestrictionPolicy.other
                default:
                    return FolderLinkRestrictionPolicy.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: FolderLinkRestrictionPolicy.self, json: json)
            }
        }
    }

    /// Changed folder link restrictions policy for team.
    public class FolderLinkRestrictionPolicyChangedDetails: CustomStringConvertible, JSONRepresentable {
        /// To.
        public let newValue: TeamLog.FolderLinkRestrictionPolicy
        /// From.
        public let previousValue: TeamLog.FolderLinkRestrictionPolicy
        public init(newValue: TeamLog.FolderLinkRestrictionPolicy, previousValue: TeamLog.FolderLinkRestrictionPolicy) {
            self.newValue = newValue
            self.previousValue = previousValue
        }

        func json() throws -> JSON {
            try FolderLinkRestrictionPolicyChangedDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try FolderLinkRestrictionPolicyChangedDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for FolderLinkRestrictionPolicyChangedDetails: \(error)"
            }
        }
    }

    public class FolderLinkRestrictionPolicyChangedDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: FolderLinkRestrictionPolicyChangedDetails) throws -> JSON {
            let output = [
                "new_value": try TeamLog.FolderLinkRestrictionPolicySerializer().serialize(value.newValue),
                "previous_value": try TeamLog.FolderLinkRestrictionPolicySerializer().serialize(value.previousValue),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> FolderLinkRestrictionPolicyChangedDetails {
            switch json {
            case .dictionary(let dict):
                let newValue = try TeamLog.FolderLinkRestrictionPolicySerializer().deserialize(dict["new_value"] ?? .null)
                let previousValue = try TeamLog.FolderLinkRestrictionPolicySerializer().deserialize(dict["previous_value"] ?? .null)
                return FolderLinkRestrictionPolicyChangedDetails(newValue: newValue, previousValue: previousValue)
            default:
                throw JSONSerializerError.deserializeError(type: FolderLinkRestrictionPolicyChangedDetails.self, json: json)
            }
        }
    }

    /// The FolderLinkRestrictionPolicyChangedType struct
    public class FolderLinkRestrictionPolicyChangedType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try FolderLinkRestrictionPolicyChangedTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try FolderLinkRestrictionPolicyChangedTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for FolderLinkRestrictionPolicyChangedType: \(error)"
            }
        }
    }

    public class FolderLinkRestrictionPolicyChangedTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: FolderLinkRestrictionPolicyChangedType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> FolderLinkRestrictionPolicyChangedType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return FolderLinkRestrictionPolicyChangedType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: FolderLinkRestrictionPolicyChangedType.self, json: json)
            }
        }
    }

    /// Folder's logged information.
    public class FolderLogInfo: TeamLog.FileOrFolderLogInfo {
        /// Number of files within the folder.
        public let fileCount: UInt64?
        public init(path: TeamLog.PathLogInfo, displayName: String? = nil, fileId: String? = nil, fileSize: UInt64? = nil, fileCount: UInt64? = nil) {
            nullableValidator(comparableValidator())(fileCount)
            self.fileCount = fileCount
            super.init(path: path, displayName: displayName, fileId: fileId, fileSize: fileSize)
        }

        public override var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try FolderLogInfoSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for FolderLogInfo: \(error)"
            }
        }
    }

    public class FolderLogInfoSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: FolderLogInfo) throws -> JSON {
            let output = [
                "path": try TeamLog.PathLogInfoSerializer().serialize(value.path),
                "display_name": try NullableSerializer(Serialization._StringSerializer).serialize(value.displayName),
                "file_id": try NullableSerializer(Serialization._StringSerializer).serialize(value.fileId),
                "file_size": try NullableSerializer(Serialization._UInt64Serializer).serialize(value.fileSize),
                "file_count": try NullableSerializer(Serialization._UInt64Serializer).serialize(value.fileCount),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> FolderLogInfo {
            switch json {
            case .dictionary(let dict):
                let path = try TeamLog.PathLogInfoSerializer().deserialize(dict["path"] ?? .null)
                let displayName = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["display_name"] ?? .null)
                let fileId = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["file_id"] ?? .null)
                let fileSize = try NullableSerializer(Serialization._UInt64Serializer).deserialize(dict["file_size"] ?? .null)
                let fileCount = try NullableSerializer(Serialization._UInt64Serializer).deserialize(dict["file_count"] ?? .null)
                return FolderLogInfo(path: path, displayName: displayName, fileId: fileId, fileSize: fileSize, fileCount: fileCount)
            default:
                throw JSONSerializerError.deserializeError(type: FolderLogInfo.self, json: json)
            }
        }
    }

    /// Updated folder overview.
    public class FolderOverviewDescriptionChangedDetails: CustomStringConvertible, JSONRepresentable {
        /// Folder Overview location position in the Assets list.
        public let folderOverviewLocationAsset: UInt64
        public init(folderOverviewLocationAsset: UInt64) {
            comparableValidator()(folderOverviewLocationAsset)
            self.folderOverviewLocationAsset = folderOverviewLocationAsset
        }

        func json() throws -> JSON {
            try FolderOverviewDescriptionChangedDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try FolderOverviewDescriptionChangedDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for FolderOverviewDescriptionChangedDetails: \(error)"
            }
        }
    }

    public class FolderOverviewDescriptionChangedDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: FolderOverviewDescriptionChangedDetails) throws -> JSON {
            let output = [
                "folder_overview_location_asset": try Serialization._UInt64Serializer.serialize(value.folderOverviewLocationAsset),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> FolderOverviewDescriptionChangedDetails {
            switch json {
            case .dictionary(let dict):
                let folderOverviewLocationAsset = try Serialization._UInt64Serializer.deserialize(dict["folder_overview_location_asset"] ?? .null)
                return FolderOverviewDescriptionChangedDetails(folderOverviewLocationAsset: folderOverviewLocationAsset)
            default:
                throw JSONSerializerError.deserializeError(type: FolderOverviewDescriptionChangedDetails.self, json: json)
            }
        }
    }

    /// The FolderOverviewDescriptionChangedType struct
    public class FolderOverviewDescriptionChangedType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try FolderOverviewDescriptionChangedTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try FolderOverviewDescriptionChangedTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for FolderOverviewDescriptionChangedType: \(error)"
            }
        }
    }

    public class FolderOverviewDescriptionChangedTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: FolderOverviewDescriptionChangedType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> FolderOverviewDescriptionChangedType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return FolderOverviewDescriptionChangedType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: FolderOverviewDescriptionChangedType.self, json: json)
            }
        }
    }

    /// Pinned item to folder overview.
    public class FolderOverviewItemPinnedDetails: CustomStringConvertible, JSONRepresentable {
        /// Folder Overview location position in the Assets list.
        public let folderOverviewLocationAsset: UInt64
        /// Pinned items positions in the Assets list.
        public let pinnedItemsAssetIndices: [UInt64]
        public init(folderOverviewLocationAsset: UInt64, pinnedItemsAssetIndices: [UInt64]) {
            comparableValidator()(folderOverviewLocationAsset)
            self.folderOverviewLocationAsset = folderOverviewLocationAsset
            arrayValidator(itemValidator: comparableValidator())(pinnedItemsAssetIndices)
            self.pinnedItemsAssetIndices = pinnedItemsAssetIndices
        }

        func json() throws -> JSON {
            try FolderOverviewItemPinnedDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try FolderOverviewItemPinnedDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for FolderOverviewItemPinnedDetails: \(error)"
            }
        }
    }

    public class FolderOverviewItemPinnedDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: FolderOverviewItemPinnedDetails) throws -> JSON {
            let output = [
                "folder_overview_location_asset": try Serialization._UInt64Serializer.serialize(value.folderOverviewLocationAsset),
                "pinned_items_asset_indices": try ArraySerializer(Serialization._UInt64Serializer).serialize(value.pinnedItemsAssetIndices),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> FolderOverviewItemPinnedDetails {
            switch json {
            case .dictionary(let dict):
                let folderOverviewLocationAsset = try Serialization._UInt64Serializer.deserialize(dict["folder_overview_location_asset"] ?? .null)
                let pinnedItemsAssetIndices = try ArraySerializer(Serialization._UInt64Serializer).deserialize(dict["pinned_items_asset_indices"] ?? .null)
                return FolderOverviewItemPinnedDetails(
                    folderOverviewLocationAsset: folderOverviewLocationAsset,
                    pinnedItemsAssetIndices: pinnedItemsAssetIndices
                )
            default:
                throw JSONSerializerError.deserializeError(type: FolderOverviewItemPinnedDetails.self, json: json)
            }
        }
    }

    /// The FolderOverviewItemPinnedType struct
    public class FolderOverviewItemPinnedType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try FolderOverviewItemPinnedTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try FolderOverviewItemPinnedTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for FolderOverviewItemPinnedType: \(error)"
            }
        }
    }

    public class FolderOverviewItemPinnedTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: FolderOverviewItemPinnedType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> FolderOverviewItemPinnedType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return FolderOverviewItemPinnedType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: FolderOverviewItemPinnedType.self, json: json)
            }
        }
    }

    /// Unpinned item from folder overview.
    public class FolderOverviewItemUnpinnedDetails: CustomStringConvertible, JSONRepresentable {
        /// Folder Overview location position in the Assets list.
        public let folderOverviewLocationAsset: UInt64
        /// Pinned items positions in the Assets list.
        public let pinnedItemsAssetIndices: [UInt64]
        public init(folderOverviewLocationAsset: UInt64, pinnedItemsAssetIndices: [UInt64]) {
            comparableValidator()(folderOverviewLocationAsset)
            self.folderOverviewLocationAsset = folderOverviewLocationAsset
            arrayValidator(itemValidator: comparableValidator())(pinnedItemsAssetIndices)
            self.pinnedItemsAssetIndices = pinnedItemsAssetIndices
        }

        func json() throws -> JSON {
            try FolderOverviewItemUnpinnedDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try FolderOverviewItemUnpinnedDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for FolderOverviewItemUnpinnedDetails: \(error)"
            }
        }
    }

    public class FolderOverviewItemUnpinnedDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: FolderOverviewItemUnpinnedDetails) throws -> JSON {
            let output = [
                "folder_overview_location_asset": try Serialization._UInt64Serializer.serialize(value.folderOverviewLocationAsset),
                "pinned_items_asset_indices": try ArraySerializer(Serialization._UInt64Serializer).serialize(value.pinnedItemsAssetIndices),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> FolderOverviewItemUnpinnedDetails {
            switch json {
            case .dictionary(let dict):
                let folderOverviewLocationAsset = try Serialization._UInt64Serializer.deserialize(dict["folder_overview_location_asset"] ?? .null)
                let pinnedItemsAssetIndices = try ArraySerializer(Serialization._UInt64Serializer).deserialize(dict["pinned_items_asset_indices"] ?? .null)
                return FolderOverviewItemUnpinnedDetails(
                    folderOverviewLocationAsset: folderOverviewLocationAsset,
                    pinnedItemsAssetIndices: pinnedItemsAssetIndices
                )
            default:
                throw JSONSerializerError.deserializeError(type: FolderOverviewItemUnpinnedDetails.self, json: json)
            }
        }
    }

    /// The FolderOverviewItemUnpinnedType struct
    public class FolderOverviewItemUnpinnedType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try FolderOverviewItemUnpinnedTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try FolderOverviewItemUnpinnedTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for FolderOverviewItemUnpinnedType: \(error)"
            }
        }
    }

    public class FolderOverviewItemUnpinnedTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: FolderOverviewItemUnpinnedType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> FolderOverviewItemUnpinnedType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return FolderOverviewItemUnpinnedType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: FolderOverviewItemUnpinnedType.self, json: json)
            }
        }
    }

    /// Geographic location details.
    public class GeoLocationLogInfo: CustomStringConvertible, JSONRepresentable {
        /// City name.
        public let city: String?
        /// Region name.
        public let region: String?
        /// Country code.
        public let country: String?
        /// IP address.
        public let ipAddress: String
        public init(ipAddress: String, city: String? = nil, region: String? = nil, country: String? = nil) {
            nullableValidator(stringValidator())(city)
            self.city = city
            nullableValidator(stringValidator())(region)
            self.region = region
            nullableValidator(stringValidator())(country)
            self.country = country
            stringValidator()(ipAddress)
            self.ipAddress = ipAddress
        }

        func json() throws -> JSON {
            try GeoLocationLogInfoSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try GeoLocationLogInfoSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for GeoLocationLogInfo: \(error)"
            }
        }
    }

    public class GeoLocationLogInfoSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: GeoLocationLogInfo) throws -> JSON {
            let output = [
                "ip_address": try Serialization._StringSerializer.serialize(value.ipAddress),
                "city": try NullableSerializer(Serialization._StringSerializer).serialize(value.city),
                "region": try NullableSerializer(Serialization._StringSerializer).serialize(value.region),
                "country": try NullableSerializer(Serialization._StringSerializer).serialize(value.country),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> GeoLocationLogInfo {
            switch json {
            case .dictionary(let dict):
                let ipAddress = try Serialization._StringSerializer.deserialize(dict["ip_address"] ?? .null)
                let city = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["city"] ?? .null)
                let region = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["region"] ?? .null)
                let country = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["country"] ?? .null)
                return GeoLocationLogInfo(ipAddress: ipAddress, city: city, region: region, country: country)
            default:
                throw JSONSerializerError.deserializeError(type: GeoLocationLogInfo.self, json: json)
            }
        }
    }

    /// The GetTeamEventsArg struct
    public class GetTeamEventsArg: CustomStringConvertible, JSONRepresentable {
        /// The maximal number of results to return per call. Note that some calls may not return limit number of
        /// events, and may even return no events, even with `has_more` set to true. In this case, callers
        /// should fetch again using getEventsContinue.
        public let limit: UInt32
        /// Filter the events by account ID. Return only events with this account_id as either Actor, Context, or
        /// Participants.
        public let accountId: String?
        /// Filter by time range.
        public let time: TeamCommon.TimeRange?
        /// Filter the returned events to a single category. Note that category shouldn't be provided together with
        /// event_type.
        public let category: TeamLog.EventCategory?
        /// Filter the returned events to a single event type. Note that event_type shouldn't be provided together with
        /// category.
        public let eventType: TeamLog.EventTypeArg?
        public init(
            limit: UInt32 = 1_000,
            accountId: String? = nil,
            time: TeamCommon.TimeRange? = nil,
            category: TeamLog.EventCategory? = nil,
            eventType: TeamLog.EventTypeArg? = nil
        ) {
            comparableValidator(minValue: 1, maxValue: 1_000)(limit)
            self.limit = limit
            nullableValidator(stringValidator(minLength: 40, maxLength: 40))(accountId)
            self.accountId = accountId
            self.time = time
            self.category = category
            self.eventType = eventType
        }

        func json() throws -> JSON {
            try GetTeamEventsArgSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try GetTeamEventsArgSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for GetTeamEventsArg: \(error)"
            }
        }
    }

    public class GetTeamEventsArgSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: GetTeamEventsArg) throws -> JSON {
            let output = [
                "limit": try Serialization._UInt32Serializer.serialize(value.limit),
                "account_id": try NullableSerializer(Serialization._StringSerializer).serialize(value.accountId),
                "time": try NullableSerializer(TeamCommon.TimeRangeSerializer()).serialize(value.time),
                "category": try NullableSerializer(TeamLog.EventCategorySerializer()).serialize(value.category),
                "event_type": try NullableSerializer(TeamLog.EventTypeArgSerializer()).serialize(value.eventType),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> GetTeamEventsArg {
            switch json {
            case .dictionary(let dict):
                let limit = try Serialization._UInt32Serializer.deserialize(dict["limit"] ?? .number(1_000))
                let accountId = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["account_id"] ?? .null)
                let time = try NullableSerializer(TeamCommon.TimeRangeSerializer()).deserialize(dict["time"] ?? .null)
                let category = try NullableSerializer(TeamLog.EventCategorySerializer()).deserialize(dict["category"] ?? .null)
                let eventType = try NullableSerializer(TeamLog.EventTypeArgSerializer()).deserialize(dict["event_type"] ?? .null)
                return GetTeamEventsArg(limit: limit, accountId: accountId, time: time, category: category, eventType: eventType)
            default:
                throw JSONSerializerError.deserializeError(type: GetTeamEventsArg.self, json: json)
            }
        }
    }

    /// The GetTeamEventsContinueArg struct
    public class GetTeamEventsContinueArg: CustomStringConvertible, JSONRepresentable {
        /// Indicates from what point to get the next set of events.
        public let cursor: String
        public init(cursor: String) {
            stringValidator()(cursor)
            self.cursor = cursor
        }

        func json() throws -> JSON {
            try GetTeamEventsContinueArgSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try GetTeamEventsContinueArgSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for GetTeamEventsContinueArg: \(error)"
            }
        }
    }

    public class GetTeamEventsContinueArgSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: GetTeamEventsContinueArg) throws -> JSON {
            let output = [
                "cursor": try Serialization._StringSerializer.serialize(value.cursor),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> GetTeamEventsContinueArg {
            switch json {
            case .dictionary(let dict):
                let cursor = try Serialization._StringSerializer.deserialize(dict["cursor"] ?? .null)
                return GetTeamEventsContinueArg(cursor: cursor)
            default:
                throw JSONSerializerError.deserializeError(type: GetTeamEventsContinueArg.self, json: json)
            }
        }
    }

    /// Errors that can be raised when calling getEventsContinue.
    public enum GetTeamEventsContinueError: CustomStringConvertible, JSONRepresentable {
        /// Bad cursor.
        case badCursor
        /// Cursors are intended to be used quickly. Individual cursor values are normally valid for days, but in rare
        /// cases may be reset sooner. Cursor reset errors should be handled by fetching a new cursor from
        /// getEvents. The associated value is the approximate timestamp of the most recent event returned by
        /// the cursor. This should be used as a resumption point when calling getEvents to obtain a new cursor.
        case reset(Date)
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try GetTeamEventsContinueErrorSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try GetTeamEventsContinueErrorSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for GetTeamEventsContinueError: \(error)"
            }
        }
    }

    public class GetTeamEventsContinueErrorSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: GetTeamEventsContinueError) throws -> JSON {
            switch value {
            case .badCursor:
                var d = [String: JSON]()
                d[".tag"] = .str("bad_cursor")
                return .dictionary(d)
            case .reset(let arg):
                var d = try ["reset": NSDateSerializer("%Y-%m-%dT%H:%M:%SZ").serialize(arg)]
                d[".tag"] = .str("reset")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> GetTeamEventsContinueError {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "bad_cursor":
                    return GetTeamEventsContinueError.badCursor
                case "reset":
                    let v = try NSDateSerializer("%Y-%m-%dT%H:%M:%SZ").deserialize(d["reset"] ?? .null)
                    return GetTeamEventsContinueError.reset(v)
                case "other":
                    return GetTeamEventsContinueError.other
                default:
                    return GetTeamEventsContinueError.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: GetTeamEventsContinueError.self, json: json)
            }
        }
    }

    /// Errors that can be raised when calling getEvents.
    public enum GetTeamEventsError: CustomStringConvertible, JSONRepresentable {
        /// No user found matching the provided account_id.
        case accountIdNotFound
        /// Invalid time range.
        case invalidTimeRange
        /// Invalid filters. Do not specify both event_type and category parameters for the same call.
        case invalidFilters
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try GetTeamEventsErrorSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try GetTeamEventsErrorSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for GetTeamEventsError: \(error)"
            }
        }
    }

    public class GetTeamEventsErrorSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: GetTeamEventsError) throws -> JSON {
            switch value {
            case .accountIdNotFound:
                var d = [String: JSON]()
                d[".tag"] = .str("account_id_not_found")
                return .dictionary(d)
            case .invalidTimeRange:
                var d = [String: JSON]()
                d[".tag"] = .str("invalid_time_range")
                return .dictionary(d)
            case .invalidFilters:
                var d = [String: JSON]()
                d[".tag"] = .str("invalid_filters")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> GetTeamEventsError {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "account_id_not_found":
                    return GetTeamEventsError.accountIdNotFound
                case "invalid_time_range":
                    return GetTeamEventsError.invalidTimeRange
                case "invalid_filters":
                    return GetTeamEventsError.invalidFilters
                case "other":
                    return GetTeamEventsError.other
                default:
                    return GetTeamEventsError.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: GetTeamEventsError.self, json: json)
            }
        }
    }

    /// The GetTeamEventsResult struct
    public class GetTeamEventsResult: CustomStringConvertible, JSONRepresentable {
        /// List of events. Note that events are not guaranteed to be sorted by their timestamp value.
        public let events: [TeamLog.TeamEvent]
        /// Pass the cursor into getEventsContinue to obtain additional events. The value of cursor may change for each
        /// response from getEventsContinue, regardless of the value of hasMore; older cursor strings may
        /// expire. Thus, callers should ensure that they update their cursor based on the latest value of
        /// cursor after each call, and poll regularly if they wish to poll for new events. Callers should
        /// handle reset exceptions for expired cursors.
        public let cursor: String
        /// Is true if there may be additional events that have not been returned yet. An additional call to
        /// getEventsContinue can retrieve them. Note that hasMore may be true, even if events is empty.
        public let hasMore: Bool
        public init(events: [TeamLog.TeamEvent], cursor: String, hasMore: Bool) {
            self.events = events
            stringValidator()(cursor)
            self.cursor = cursor
            self.hasMore = hasMore
        }

        func json() throws -> JSON {
            try GetTeamEventsResultSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try GetTeamEventsResultSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for GetTeamEventsResult: \(error)"
            }
        }
    }

    public class GetTeamEventsResultSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: GetTeamEventsResult) throws -> JSON {
            let output = [
                "events": try ArraySerializer(TeamLog.TeamEventSerializer()).serialize(value.events),
                "cursor": try Serialization._StringSerializer.serialize(value.cursor),
                "has_more": try Serialization._BoolSerializer.serialize(value.hasMore),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> GetTeamEventsResult {
            switch json {
            case .dictionary(let dict):
                let events = try ArraySerializer(TeamLog.TeamEventSerializer()).deserialize(dict["events"] ?? .null)
                let cursor = try Serialization._StringSerializer.deserialize(dict["cursor"] ?? .null)
                let hasMore = try Serialization._BoolSerializer.deserialize(dict["has_more"] ?? .null)
                return GetTeamEventsResult(events: events, cursor: cursor, hasMore: hasMore)
            default:
                throw JSONSerializerError.deserializeError(type: GetTeamEventsResult.self, json: json)
            }
        }
    }

    /// Enabled/disabled Google single sign-on for team.
    public class GoogleSsoChangePolicyDetails: CustomStringConvertible, JSONRepresentable {
        /// New Google single sign-on policy.
        public let newValue: TeamLog.GoogleSsoPolicy
        /// Previous Google single sign-on policy. Might be missing due to historical data gap.
        public let previousValue: TeamLog.GoogleSsoPolicy?
        public init(newValue: TeamLog.GoogleSsoPolicy, previousValue: TeamLog.GoogleSsoPolicy? = nil) {
            self.newValue = newValue
            self.previousValue = previousValue
        }

        func json() throws -> JSON {
            try GoogleSsoChangePolicyDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try GoogleSsoChangePolicyDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for GoogleSsoChangePolicyDetails: \(error)"
            }
        }
    }

    public class GoogleSsoChangePolicyDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: GoogleSsoChangePolicyDetails) throws -> JSON {
            let output = [
                "new_value": try TeamLog.GoogleSsoPolicySerializer().serialize(value.newValue),
                "previous_value": try NullableSerializer(TeamLog.GoogleSsoPolicySerializer()).serialize(value.previousValue),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> GoogleSsoChangePolicyDetails {
            switch json {
            case .dictionary(let dict):
                let newValue = try TeamLog.GoogleSsoPolicySerializer().deserialize(dict["new_value"] ?? .null)
                let previousValue = try NullableSerializer(TeamLog.GoogleSsoPolicySerializer()).deserialize(dict["previous_value"] ?? .null)
                return GoogleSsoChangePolicyDetails(newValue: newValue, previousValue: previousValue)
            default:
                throw JSONSerializerError.deserializeError(type: GoogleSsoChangePolicyDetails.self, json: json)
            }
        }
    }

    /// The GoogleSsoChangePolicyType struct
    public class GoogleSsoChangePolicyType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try GoogleSsoChangePolicyTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try GoogleSsoChangePolicyTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for GoogleSsoChangePolicyType: \(error)"
            }
        }
    }

    public class GoogleSsoChangePolicyTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: GoogleSsoChangePolicyType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> GoogleSsoChangePolicyType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return GoogleSsoChangePolicyType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: GoogleSsoChangePolicyType.self, json: json)
            }
        }
    }

    /// Google SSO policy
    public enum GoogleSsoPolicy: CustomStringConvertible, JSONRepresentable {
        /// An unspecified error.
        case disabled
        /// An unspecified error.
        case enabled
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try GoogleSsoPolicySerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try GoogleSsoPolicySerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for GoogleSsoPolicy: \(error)"
            }
        }
    }

    public class GoogleSsoPolicySerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: GoogleSsoPolicy) throws -> JSON {
            switch value {
            case .disabled:
                var d = [String: JSON]()
                d[".tag"] = .str("disabled")
                return .dictionary(d)
            case .enabled:
                var d = [String: JSON]()
                d[".tag"] = .str("enabled")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> GoogleSsoPolicy {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "disabled":
                    return GoogleSsoPolicy.disabled
                case "enabled":
                    return GoogleSsoPolicy.enabled
                case "other":
                    return GoogleSsoPolicy.other
                default:
                    return GoogleSsoPolicy.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: GoogleSsoPolicy.self, json: json)
            }
        }
    }

    /// Couldn't add a folder to a policy.
    public class GovernancePolicyAddFolderFailedDetails: CustomStringConvertible, JSONRepresentable {
        /// Policy ID.
        public let governancePolicyId: String
        /// Policy name.
        public let name: String
        /// Policy type.
        public let policyType: TeamLog.PolicyType?
        /// Folder.
        public let folder: String
        /// Reason.
        public let reason: String?
        public init(governancePolicyId: String, name: String, folder: String, policyType: TeamLog.PolicyType? = nil, reason: String? = nil) {
            stringValidator()(governancePolicyId)
            self.governancePolicyId = governancePolicyId
            stringValidator()(name)
            self.name = name
            self.policyType = policyType
            stringValidator()(folder)
            self.folder = folder
            nullableValidator(stringValidator())(reason)
            self.reason = reason
        }

        func json() throws -> JSON {
            try GovernancePolicyAddFolderFailedDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try GovernancePolicyAddFolderFailedDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for GovernancePolicyAddFolderFailedDetails: \(error)"
            }
        }
    }

    public class GovernancePolicyAddFolderFailedDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: GovernancePolicyAddFolderFailedDetails) throws -> JSON {
            let output = [
                "governance_policy_id": try Serialization._StringSerializer.serialize(value.governancePolicyId),
                "name": try Serialization._StringSerializer.serialize(value.name),
                "folder": try Serialization._StringSerializer.serialize(value.folder),
                "policy_type": try NullableSerializer(TeamLog.PolicyTypeSerializer()).serialize(value.policyType),
                "reason": try NullableSerializer(Serialization._StringSerializer).serialize(value.reason),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> GovernancePolicyAddFolderFailedDetails {
            switch json {
            case .dictionary(let dict):
                let governancePolicyId = try Serialization._StringSerializer.deserialize(dict["governance_policy_id"] ?? .null)
                let name = try Serialization._StringSerializer.deserialize(dict["name"] ?? .null)
                let folder = try Serialization._StringSerializer.deserialize(dict["folder"] ?? .null)
                let policyType = try NullableSerializer(TeamLog.PolicyTypeSerializer()).deserialize(dict["policy_type"] ?? .null)
                let reason = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["reason"] ?? .null)
                return GovernancePolicyAddFolderFailedDetails(
                    governancePolicyId: governancePolicyId,
                    name: name,
                    folder: folder,
                    policyType: policyType,
                    reason: reason
                )
            default:
                throw JSONSerializerError.deserializeError(type: GovernancePolicyAddFolderFailedDetails.self, json: json)
            }
        }
    }

    /// The GovernancePolicyAddFolderFailedType struct
    public class GovernancePolicyAddFolderFailedType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try GovernancePolicyAddFolderFailedTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try GovernancePolicyAddFolderFailedTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for GovernancePolicyAddFolderFailedType: \(error)"
            }
        }
    }

    public class GovernancePolicyAddFolderFailedTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: GovernancePolicyAddFolderFailedType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> GovernancePolicyAddFolderFailedType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return GovernancePolicyAddFolderFailedType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: GovernancePolicyAddFolderFailedType.self, json: json)
            }
        }
    }

    /// Added folders to policy.
    public class GovernancePolicyAddFoldersDetails: CustomStringConvertible, JSONRepresentable {
        /// Policy ID.
        public let governancePolicyId: String
        /// Policy name.
        public let name: String
        /// Policy type.
        public let policyType: TeamLog.PolicyType?
        /// Folders.
        public let folders: [String]?
        public init(governancePolicyId: String, name: String, policyType: TeamLog.PolicyType? = nil, folders: [String]? = nil) {
            stringValidator()(governancePolicyId)
            self.governancePolicyId = governancePolicyId
            stringValidator()(name)
            self.name = name
            self.policyType = policyType
            nullableValidator(arrayValidator(itemValidator: stringValidator()))(folders)
            self.folders = folders
        }

        func json() throws -> JSON {
            try GovernancePolicyAddFoldersDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try GovernancePolicyAddFoldersDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for GovernancePolicyAddFoldersDetails: \(error)"
            }
        }
    }

    public class GovernancePolicyAddFoldersDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: GovernancePolicyAddFoldersDetails) throws -> JSON {
            let output = [
                "governance_policy_id": try Serialization._StringSerializer.serialize(value.governancePolicyId),
                "name": try Serialization._StringSerializer.serialize(value.name),
                "policy_type": try NullableSerializer(TeamLog.PolicyTypeSerializer()).serialize(value.policyType),
                "folders": try NullableSerializer(ArraySerializer(Serialization._StringSerializer)).serialize(value.folders),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> GovernancePolicyAddFoldersDetails {
            switch json {
            case .dictionary(let dict):
                let governancePolicyId = try Serialization._StringSerializer.deserialize(dict["governance_policy_id"] ?? .null)
                let name = try Serialization._StringSerializer.deserialize(dict["name"] ?? .null)
                let policyType = try NullableSerializer(TeamLog.PolicyTypeSerializer()).deserialize(dict["policy_type"] ?? .null)
                let folders = try NullableSerializer(ArraySerializer(Serialization._StringSerializer)).deserialize(dict["folders"] ?? .null)
                return GovernancePolicyAddFoldersDetails(governancePolicyId: governancePolicyId, name: name, policyType: policyType, folders: folders)
            default:
                throw JSONSerializerError.deserializeError(type: GovernancePolicyAddFoldersDetails.self, json: json)
            }
        }
    }

    /// The GovernancePolicyAddFoldersType struct
    public class GovernancePolicyAddFoldersType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try GovernancePolicyAddFoldersTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try GovernancePolicyAddFoldersTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for GovernancePolicyAddFoldersType: \(error)"
            }
        }
    }

    public class GovernancePolicyAddFoldersTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: GovernancePolicyAddFoldersType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> GovernancePolicyAddFoldersType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return GovernancePolicyAddFoldersType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: GovernancePolicyAddFoldersType.self, json: json)
            }
        }
    }

    /// Content disposed.
    public class GovernancePolicyContentDisposedDetails: CustomStringConvertible, JSONRepresentable {
        /// Policy ID.
        public let governancePolicyId: String
        /// Policy name.
        public let name: String
        /// Policy type.
        public let policyType: TeamLog.PolicyType?
        /// Disposition type.
        public let dispositionType: TeamLog.DispositionActionType
        public init(governancePolicyId: String, name: String, dispositionType: TeamLog.DispositionActionType, policyType: TeamLog.PolicyType? = nil) {
            stringValidator()(governancePolicyId)
            self.governancePolicyId = governancePolicyId
            stringValidator()(name)
            self.name = name
            self.policyType = policyType
            self.dispositionType = dispositionType
        }

        func json() throws -> JSON {
            try GovernancePolicyContentDisposedDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try GovernancePolicyContentDisposedDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for GovernancePolicyContentDisposedDetails: \(error)"
            }
        }
    }

    public class GovernancePolicyContentDisposedDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: GovernancePolicyContentDisposedDetails) throws -> JSON {
            let output = [
                "governance_policy_id": try Serialization._StringSerializer.serialize(value.governancePolicyId),
                "name": try Serialization._StringSerializer.serialize(value.name),
                "disposition_type": try TeamLog.DispositionActionTypeSerializer().serialize(value.dispositionType),
                "policy_type": try NullableSerializer(TeamLog.PolicyTypeSerializer()).serialize(value.policyType),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> GovernancePolicyContentDisposedDetails {
            switch json {
            case .dictionary(let dict):
                let governancePolicyId = try Serialization._StringSerializer.deserialize(dict["governance_policy_id"] ?? .null)
                let name = try Serialization._StringSerializer.deserialize(dict["name"] ?? .null)
                let dispositionType = try TeamLog.DispositionActionTypeSerializer().deserialize(dict["disposition_type"] ?? .null)
                let policyType = try NullableSerializer(TeamLog.PolicyTypeSerializer()).deserialize(dict["policy_type"] ?? .null)
                return GovernancePolicyContentDisposedDetails(
                    governancePolicyId: governancePolicyId,
                    name: name,
                    dispositionType: dispositionType,
                    policyType: policyType
                )
            default:
                throw JSONSerializerError.deserializeError(type: GovernancePolicyContentDisposedDetails.self, json: json)
            }
        }
    }

    /// The GovernancePolicyContentDisposedType struct
    public class GovernancePolicyContentDisposedType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try GovernancePolicyContentDisposedTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try GovernancePolicyContentDisposedTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for GovernancePolicyContentDisposedType: \(error)"
            }
        }
    }

    public class GovernancePolicyContentDisposedTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: GovernancePolicyContentDisposedType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> GovernancePolicyContentDisposedType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return GovernancePolicyContentDisposedType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: GovernancePolicyContentDisposedType.self, json: json)
            }
        }
    }

    /// Activated a new policy.
    public class GovernancePolicyCreateDetails: CustomStringConvertible, JSONRepresentable {
        /// Policy ID.
        public let governancePolicyId: String
        /// Policy name.
        public let name: String
        /// Policy type.
        public let policyType: TeamLog.PolicyType?
        /// Duration in days.
        public let duration: TeamLog.DurationLogInfo
        /// Folders.
        public let folders: [String]?
        public init(
            governancePolicyId: String,
            name: String,
            duration: TeamLog.DurationLogInfo,
            policyType: TeamLog.PolicyType? = nil,
            folders: [String]? = nil
        ) {
            stringValidator()(governancePolicyId)
            self.governancePolicyId = governancePolicyId
            stringValidator()(name)
            self.name = name
            self.policyType = policyType
            self.duration = duration
            nullableValidator(arrayValidator(itemValidator: stringValidator()))(folders)
            self.folders = folders
        }

        func json() throws -> JSON {
            try GovernancePolicyCreateDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try GovernancePolicyCreateDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for GovernancePolicyCreateDetails: \(error)"
            }
        }
    }

    public class GovernancePolicyCreateDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: GovernancePolicyCreateDetails) throws -> JSON {
            let output = [
                "governance_policy_id": try Serialization._StringSerializer.serialize(value.governancePolicyId),
                "name": try Serialization._StringSerializer.serialize(value.name),
                "duration": try TeamLog.DurationLogInfoSerializer().serialize(value.duration),
                "policy_type": try NullableSerializer(TeamLog.PolicyTypeSerializer()).serialize(value.policyType),
                "folders": try NullableSerializer(ArraySerializer(Serialization._StringSerializer)).serialize(value.folders),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> GovernancePolicyCreateDetails {
            switch json {
            case .dictionary(let dict):
                let governancePolicyId = try Serialization._StringSerializer.deserialize(dict["governance_policy_id"] ?? .null)
                let name = try Serialization._StringSerializer.deserialize(dict["name"] ?? .null)
                let duration = try TeamLog.DurationLogInfoSerializer().deserialize(dict["duration"] ?? .null)
                let policyType = try NullableSerializer(TeamLog.PolicyTypeSerializer()).deserialize(dict["policy_type"] ?? .null)
                let folders = try NullableSerializer(ArraySerializer(Serialization._StringSerializer)).deserialize(dict["folders"] ?? .null)
                return GovernancePolicyCreateDetails(
                    governancePolicyId: governancePolicyId,
                    name: name,
                    duration: duration,
                    policyType: policyType,
                    folders: folders
                )
            default:
                throw JSONSerializerError.deserializeError(type: GovernancePolicyCreateDetails.self, json: json)
            }
        }
    }

    /// The GovernancePolicyCreateType struct
    public class GovernancePolicyCreateType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try GovernancePolicyCreateTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try GovernancePolicyCreateTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for GovernancePolicyCreateType: \(error)"
            }
        }
    }

    public class GovernancePolicyCreateTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: GovernancePolicyCreateType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> GovernancePolicyCreateType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return GovernancePolicyCreateType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: GovernancePolicyCreateType.self, json: json)
            }
        }
    }

    /// Deleted a policy.
    public class GovernancePolicyDeleteDetails: CustomStringConvertible, JSONRepresentable {
        /// Policy ID.
        public let governancePolicyId: String
        /// Policy name.
        public let name: String
        /// Policy type.
        public let policyType: TeamLog.PolicyType?
        public init(governancePolicyId: String, name: String, policyType: TeamLog.PolicyType? = nil) {
            stringValidator()(governancePolicyId)
            self.governancePolicyId = governancePolicyId
            stringValidator()(name)
            self.name = name
            self.policyType = policyType
        }

        func json() throws -> JSON {
            try GovernancePolicyDeleteDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try GovernancePolicyDeleteDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for GovernancePolicyDeleteDetails: \(error)"
            }
        }
    }

    public class GovernancePolicyDeleteDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: GovernancePolicyDeleteDetails) throws -> JSON {
            let output = [
                "governance_policy_id": try Serialization._StringSerializer.serialize(value.governancePolicyId),
                "name": try Serialization._StringSerializer.serialize(value.name),
                "policy_type": try NullableSerializer(TeamLog.PolicyTypeSerializer()).serialize(value.policyType),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> GovernancePolicyDeleteDetails {
            switch json {
            case .dictionary(let dict):
                let governancePolicyId = try Serialization._StringSerializer.deserialize(dict["governance_policy_id"] ?? .null)
                let name = try Serialization._StringSerializer.deserialize(dict["name"] ?? .null)
                let policyType = try NullableSerializer(TeamLog.PolicyTypeSerializer()).deserialize(dict["policy_type"] ?? .null)
                return GovernancePolicyDeleteDetails(governancePolicyId: governancePolicyId, name: name, policyType: policyType)
            default:
                throw JSONSerializerError.deserializeError(type: GovernancePolicyDeleteDetails.self, json: json)
            }
        }
    }

    /// The GovernancePolicyDeleteType struct
    public class GovernancePolicyDeleteType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try GovernancePolicyDeleteTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try GovernancePolicyDeleteTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for GovernancePolicyDeleteType: \(error)"
            }
        }
    }

    public class GovernancePolicyDeleteTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: GovernancePolicyDeleteType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> GovernancePolicyDeleteType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return GovernancePolicyDeleteType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: GovernancePolicyDeleteType.self, json: json)
            }
        }
    }

    /// Edited policy.
    public class GovernancePolicyEditDetailsDetails: CustomStringConvertible, JSONRepresentable {
        /// Policy ID.
        public let governancePolicyId: String
        /// Policy name.
        public let name: String
        /// Policy type.
        public let policyType: TeamLog.PolicyType?
        /// Attribute.
        public let attribute: String
        /// From.
        public let previousValue: String
        /// To.
        public let newValue: String
        public init(
            governancePolicyId: String,
            name: String,
            attribute: String,
            previousValue: String,
            newValue: String,
            policyType: TeamLog.PolicyType? = nil
        ) {
            stringValidator()(governancePolicyId)
            self.governancePolicyId = governancePolicyId
            stringValidator()(name)
            self.name = name
            self.policyType = policyType
            stringValidator()(attribute)
            self.attribute = attribute
            stringValidator()(previousValue)
            self.previousValue = previousValue
            stringValidator()(newValue)
            self.newValue = newValue
        }

        func json() throws -> JSON {
            try GovernancePolicyEditDetailsDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try GovernancePolicyEditDetailsDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for GovernancePolicyEditDetailsDetails: \(error)"
            }
        }
    }

    public class GovernancePolicyEditDetailsDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: GovernancePolicyEditDetailsDetails) throws -> JSON {
            let output = [
                "governance_policy_id": try Serialization._StringSerializer.serialize(value.governancePolicyId),
                "name": try Serialization._StringSerializer.serialize(value.name),
                "attribute": try Serialization._StringSerializer.serialize(value.attribute),
                "previous_value": try Serialization._StringSerializer.serialize(value.previousValue),
                "new_value": try Serialization._StringSerializer.serialize(value.newValue),
                "policy_type": try NullableSerializer(TeamLog.PolicyTypeSerializer()).serialize(value.policyType),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> GovernancePolicyEditDetailsDetails {
            switch json {
            case .dictionary(let dict):
                let governancePolicyId = try Serialization._StringSerializer.deserialize(dict["governance_policy_id"] ?? .null)
                let name = try Serialization._StringSerializer.deserialize(dict["name"] ?? .null)
                let attribute = try Serialization._StringSerializer.deserialize(dict["attribute"] ?? .null)
                let previousValue = try Serialization._StringSerializer.deserialize(dict["previous_value"] ?? .null)
                let newValue = try Serialization._StringSerializer.deserialize(dict["new_value"] ?? .null)
                let policyType = try NullableSerializer(TeamLog.PolicyTypeSerializer()).deserialize(dict["policy_type"] ?? .null)
                return GovernancePolicyEditDetailsDetails(
                    governancePolicyId: governancePolicyId,
                    name: name,
                    attribute: attribute,
                    previousValue: previousValue,
                    newValue: newValue,
                    policyType: policyType
                )
            default:
                throw JSONSerializerError.deserializeError(type: GovernancePolicyEditDetailsDetails.self, json: json)
            }
        }
    }

    /// The GovernancePolicyEditDetailsType struct
    public class GovernancePolicyEditDetailsType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try GovernancePolicyEditDetailsTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try GovernancePolicyEditDetailsTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for GovernancePolicyEditDetailsType: \(error)"
            }
        }
    }

    public class GovernancePolicyEditDetailsTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: GovernancePolicyEditDetailsType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> GovernancePolicyEditDetailsType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return GovernancePolicyEditDetailsType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: GovernancePolicyEditDetailsType.self, json: json)
            }
        }
    }

    /// Changed policy duration.
    public class GovernancePolicyEditDurationDetails: CustomStringConvertible, JSONRepresentable {
        /// Policy ID.
        public let governancePolicyId: String
        /// Policy name.
        public let name: String
        /// Policy type.
        public let policyType: TeamLog.PolicyType?
        /// From.
        public let previousValue: TeamLog.DurationLogInfo
        /// To.
        public let newValue: TeamLog.DurationLogInfo
        public init(
            governancePolicyId: String,
            name: String,
            previousValue: TeamLog.DurationLogInfo,
            newValue: TeamLog.DurationLogInfo,
            policyType: TeamLog.PolicyType? = nil
        ) {
            stringValidator()(governancePolicyId)
            self.governancePolicyId = governancePolicyId
            stringValidator()(name)
            self.name = name
            self.policyType = policyType
            self.previousValue = previousValue
            self.newValue = newValue
        }

        func json() throws -> JSON {
            try GovernancePolicyEditDurationDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try GovernancePolicyEditDurationDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for GovernancePolicyEditDurationDetails: \(error)"
            }
        }
    }

    public class GovernancePolicyEditDurationDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: GovernancePolicyEditDurationDetails) throws -> JSON {
            let output = [
                "governance_policy_id": try Serialization._StringSerializer.serialize(value.governancePolicyId),
                "name": try Serialization._StringSerializer.serialize(value.name),
                "previous_value": try TeamLog.DurationLogInfoSerializer().serialize(value.previousValue),
                "new_value": try TeamLog.DurationLogInfoSerializer().serialize(value.newValue),
                "policy_type": try NullableSerializer(TeamLog.PolicyTypeSerializer()).serialize(value.policyType),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> GovernancePolicyEditDurationDetails {
            switch json {
            case .dictionary(let dict):
                let governancePolicyId = try Serialization._StringSerializer.deserialize(dict["governance_policy_id"] ?? .null)
                let name = try Serialization._StringSerializer.deserialize(dict["name"] ?? .null)
                let previousValue = try TeamLog.DurationLogInfoSerializer().deserialize(dict["previous_value"] ?? .null)
                let newValue = try TeamLog.DurationLogInfoSerializer().deserialize(dict["new_value"] ?? .null)
                let policyType = try NullableSerializer(TeamLog.PolicyTypeSerializer()).deserialize(dict["policy_type"] ?? .null)
                return GovernancePolicyEditDurationDetails(
                    governancePolicyId: governancePolicyId,
                    name: name,
                    previousValue: previousValue,
                    newValue: newValue,
                    policyType: policyType
                )
            default:
                throw JSONSerializerError.deserializeError(type: GovernancePolicyEditDurationDetails.self, json: json)
            }
        }
    }

    /// The GovernancePolicyEditDurationType struct
    public class GovernancePolicyEditDurationType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try GovernancePolicyEditDurationTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try GovernancePolicyEditDurationTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for GovernancePolicyEditDurationType: \(error)"
            }
        }
    }

    public class GovernancePolicyEditDurationTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: GovernancePolicyEditDurationType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> GovernancePolicyEditDurationType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return GovernancePolicyEditDurationType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: GovernancePolicyEditDurationType.self, json: json)
            }
        }
    }

    /// Created a policy download.
    public class GovernancePolicyExportCreatedDetails: CustomStringConvertible, JSONRepresentable {
        /// Policy ID.
        public let governancePolicyId: String
        /// Policy name.
        public let name: String
        /// Policy type.
        public let policyType: TeamLog.PolicyType?
        /// Export name.
        public let exportName: String
        public init(governancePolicyId: String, name: String, exportName: String, policyType: TeamLog.PolicyType? = nil) {
            stringValidator()(governancePolicyId)
            self.governancePolicyId = governancePolicyId
            stringValidator()(name)
            self.name = name
            self.policyType = policyType
            stringValidator()(exportName)
            self.exportName = exportName
        }

        func json() throws -> JSON {
            try GovernancePolicyExportCreatedDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try GovernancePolicyExportCreatedDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for GovernancePolicyExportCreatedDetails: \(error)"
            }
        }
    }

    public class GovernancePolicyExportCreatedDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: GovernancePolicyExportCreatedDetails) throws -> JSON {
            let output = [
                "governance_policy_id": try Serialization._StringSerializer.serialize(value.governancePolicyId),
                "name": try Serialization._StringSerializer.serialize(value.name),
                "export_name": try Serialization._StringSerializer.serialize(value.exportName),
                "policy_type": try NullableSerializer(TeamLog.PolicyTypeSerializer()).serialize(value.policyType),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> GovernancePolicyExportCreatedDetails {
            switch json {
            case .dictionary(let dict):
                let governancePolicyId = try Serialization._StringSerializer.deserialize(dict["governance_policy_id"] ?? .null)
                let name = try Serialization._StringSerializer.deserialize(dict["name"] ?? .null)
                let exportName = try Serialization._StringSerializer.deserialize(dict["export_name"] ?? .null)
                let policyType = try NullableSerializer(TeamLog.PolicyTypeSerializer()).deserialize(dict["policy_type"] ?? .null)
                return GovernancePolicyExportCreatedDetails(
                    governancePolicyId: governancePolicyId,
                    name: name,
                    exportName: exportName,
                    policyType: policyType
                )
            default:
                throw JSONSerializerError.deserializeError(type: GovernancePolicyExportCreatedDetails.self, json: json)
            }
        }
    }

    /// The GovernancePolicyExportCreatedType struct
    public class GovernancePolicyExportCreatedType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try GovernancePolicyExportCreatedTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try GovernancePolicyExportCreatedTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for GovernancePolicyExportCreatedType: \(error)"
            }
        }
    }

    public class GovernancePolicyExportCreatedTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: GovernancePolicyExportCreatedType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> GovernancePolicyExportCreatedType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return GovernancePolicyExportCreatedType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: GovernancePolicyExportCreatedType.self, json: json)
            }
        }
    }

    /// Removed a policy download.
    public class GovernancePolicyExportRemovedDetails: CustomStringConvertible, JSONRepresentable {
        /// Policy ID.
        public let governancePolicyId: String
        /// Policy name.
        public let name: String
        /// Policy type.
        public let policyType: TeamLog.PolicyType?
        /// Export name.
        public let exportName: String
        public init(governancePolicyId: String, name: String, exportName: String, policyType: TeamLog.PolicyType? = nil) {
            stringValidator()(governancePolicyId)
            self.governancePolicyId = governancePolicyId
            stringValidator()(name)
            self.name = name
            self.policyType = policyType
            stringValidator()(exportName)
            self.exportName = exportName
        }

        func json() throws -> JSON {
            try GovernancePolicyExportRemovedDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try GovernancePolicyExportRemovedDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for GovernancePolicyExportRemovedDetails: \(error)"
            }
        }
    }

    public class GovernancePolicyExportRemovedDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: GovernancePolicyExportRemovedDetails) throws -> JSON {
            let output = [
                "governance_policy_id": try Serialization._StringSerializer.serialize(value.governancePolicyId),
                "name": try Serialization._StringSerializer.serialize(value.name),
                "export_name": try Serialization._StringSerializer.serialize(value.exportName),
                "policy_type": try NullableSerializer(TeamLog.PolicyTypeSerializer()).serialize(value.policyType),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> GovernancePolicyExportRemovedDetails {
            switch json {
            case .dictionary(let dict):
                let governancePolicyId = try Serialization._StringSerializer.deserialize(dict["governance_policy_id"] ?? .null)
                let name = try Serialization._StringSerializer.deserialize(dict["name"] ?? .null)
                let exportName = try Serialization._StringSerializer.deserialize(dict["export_name"] ?? .null)
                let policyType = try NullableSerializer(TeamLog.PolicyTypeSerializer()).deserialize(dict["policy_type"] ?? .null)
                return GovernancePolicyExportRemovedDetails(
                    governancePolicyId: governancePolicyId,
                    name: name,
                    exportName: exportName,
                    policyType: policyType
                )
            default:
                throw JSONSerializerError.deserializeError(type: GovernancePolicyExportRemovedDetails.self, json: json)
            }
        }
    }

    /// The GovernancePolicyExportRemovedType struct
    public class GovernancePolicyExportRemovedType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try GovernancePolicyExportRemovedTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try GovernancePolicyExportRemovedTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for GovernancePolicyExportRemovedType: \(error)"
            }
        }
    }

    public class GovernancePolicyExportRemovedTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: GovernancePolicyExportRemovedType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> GovernancePolicyExportRemovedType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return GovernancePolicyExportRemovedType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: GovernancePolicyExportRemovedType.self, json: json)
            }
        }
    }

    /// Removed folders from policy.
    public class GovernancePolicyRemoveFoldersDetails: CustomStringConvertible, JSONRepresentable {
        /// Policy ID.
        public let governancePolicyId: String
        /// Policy name.
        public let name: String
        /// Policy type.
        public let policyType: TeamLog.PolicyType?
        /// Folders.
        public let folders: [String]?
        /// Reason.
        public let reason: String?
        public init(governancePolicyId: String, name: String, policyType: TeamLog.PolicyType? = nil, folders: [String]? = nil, reason: String? = nil) {
            stringValidator()(governancePolicyId)
            self.governancePolicyId = governancePolicyId
            stringValidator()(name)
            self.name = name
            self.policyType = policyType
            nullableValidator(arrayValidator(itemValidator: stringValidator()))(folders)
            self.folders = folders
            nullableValidator(stringValidator())(reason)
            self.reason = reason
        }

        func json() throws -> JSON {
            try GovernancePolicyRemoveFoldersDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try GovernancePolicyRemoveFoldersDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for GovernancePolicyRemoveFoldersDetails: \(error)"
            }
        }
    }

    public class GovernancePolicyRemoveFoldersDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: GovernancePolicyRemoveFoldersDetails) throws -> JSON {
            let output = [
                "governance_policy_id": try Serialization._StringSerializer.serialize(value.governancePolicyId),
                "name": try Serialization._StringSerializer.serialize(value.name),
                "policy_type": try NullableSerializer(TeamLog.PolicyTypeSerializer()).serialize(value.policyType),
                "folders": try NullableSerializer(ArraySerializer(Serialization._StringSerializer)).serialize(value.folders),
                "reason": try NullableSerializer(Serialization._StringSerializer).serialize(value.reason),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> GovernancePolicyRemoveFoldersDetails {
            switch json {
            case .dictionary(let dict):
                let governancePolicyId = try Serialization._StringSerializer.deserialize(dict["governance_policy_id"] ?? .null)
                let name = try Serialization._StringSerializer.deserialize(dict["name"] ?? .null)
                let policyType = try NullableSerializer(TeamLog.PolicyTypeSerializer()).deserialize(dict["policy_type"] ?? .null)
                let folders = try NullableSerializer(ArraySerializer(Serialization._StringSerializer)).deserialize(dict["folders"] ?? .null)
                let reason = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["reason"] ?? .null)
                return GovernancePolicyRemoveFoldersDetails(
                    governancePolicyId: governancePolicyId,
                    name: name,
                    policyType: policyType,
                    folders: folders,
                    reason: reason
                )
            default:
                throw JSONSerializerError.deserializeError(type: GovernancePolicyRemoveFoldersDetails.self, json: json)
            }
        }
    }

    /// The GovernancePolicyRemoveFoldersType struct
    public class GovernancePolicyRemoveFoldersType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try GovernancePolicyRemoveFoldersTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try GovernancePolicyRemoveFoldersTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for GovernancePolicyRemoveFoldersType: \(error)"
            }
        }
    }

    public class GovernancePolicyRemoveFoldersTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: GovernancePolicyRemoveFoldersType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> GovernancePolicyRemoveFoldersType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return GovernancePolicyRemoveFoldersType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: GovernancePolicyRemoveFoldersType.self, json: json)
            }
        }
    }

    /// Created a summary report for a policy.
    public class GovernancePolicyReportCreatedDetails: CustomStringConvertible, JSONRepresentable {
        /// Policy ID.
        public let governancePolicyId: String
        /// Policy name.
        public let name: String
        /// Policy type.
        public let policyType: TeamLog.PolicyType?
        public init(governancePolicyId: String, name: String, policyType: TeamLog.PolicyType? = nil) {
            stringValidator()(governancePolicyId)
            self.governancePolicyId = governancePolicyId
            stringValidator()(name)
            self.name = name
            self.policyType = policyType
        }

        func json() throws -> JSON {
            try GovernancePolicyReportCreatedDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try GovernancePolicyReportCreatedDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for GovernancePolicyReportCreatedDetails: \(error)"
            }
        }
    }

    public class GovernancePolicyReportCreatedDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: GovernancePolicyReportCreatedDetails) throws -> JSON {
            let output = [
                "governance_policy_id": try Serialization._StringSerializer.serialize(value.governancePolicyId),
                "name": try Serialization._StringSerializer.serialize(value.name),
                "policy_type": try NullableSerializer(TeamLog.PolicyTypeSerializer()).serialize(value.policyType),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> GovernancePolicyReportCreatedDetails {
            switch json {
            case .dictionary(let dict):
                let governancePolicyId = try Serialization._StringSerializer.deserialize(dict["governance_policy_id"] ?? .null)
                let name = try Serialization._StringSerializer.deserialize(dict["name"] ?? .null)
                let policyType = try NullableSerializer(TeamLog.PolicyTypeSerializer()).deserialize(dict["policy_type"] ?? .null)
                return GovernancePolicyReportCreatedDetails(governancePolicyId: governancePolicyId, name: name, policyType: policyType)
            default:
                throw JSONSerializerError.deserializeError(type: GovernancePolicyReportCreatedDetails.self, json: json)
            }
        }
    }

    /// The GovernancePolicyReportCreatedType struct
    public class GovernancePolicyReportCreatedType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try GovernancePolicyReportCreatedTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try GovernancePolicyReportCreatedTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for GovernancePolicyReportCreatedType: \(error)"
            }
        }
    }

    public class GovernancePolicyReportCreatedTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: GovernancePolicyReportCreatedType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> GovernancePolicyReportCreatedType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return GovernancePolicyReportCreatedType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: GovernancePolicyReportCreatedType.self, json: json)
            }
        }
    }

    /// Downloaded content from a policy.
    public class GovernancePolicyZipPartDownloadedDetails: CustomStringConvertible, JSONRepresentable {
        /// Policy ID.
        public let governancePolicyId: String
        /// Policy name.
        public let name: String
        /// Policy type.
        public let policyType: TeamLog.PolicyType?
        /// Export name.
        public let exportName: String
        /// Part.
        public let part: String?
        public init(governancePolicyId: String, name: String, exportName: String, policyType: TeamLog.PolicyType? = nil, part: String? = nil) {
            stringValidator()(governancePolicyId)
            self.governancePolicyId = governancePolicyId
            stringValidator()(name)
            self.name = name
            self.policyType = policyType
            stringValidator()(exportName)
            self.exportName = exportName
            nullableValidator(stringValidator())(part)
            self.part = part
        }

        func json() throws -> JSON {
            try GovernancePolicyZipPartDownloadedDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try GovernancePolicyZipPartDownloadedDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for GovernancePolicyZipPartDownloadedDetails: \(error)"
            }
        }
    }

    public class GovernancePolicyZipPartDownloadedDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: GovernancePolicyZipPartDownloadedDetails) throws -> JSON {
            let output = [
                "governance_policy_id": try Serialization._StringSerializer.serialize(value.governancePolicyId),
                "name": try Serialization._StringSerializer.serialize(value.name),
                "export_name": try Serialization._StringSerializer.serialize(value.exportName),
                "policy_type": try NullableSerializer(TeamLog.PolicyTypeSerializer()).serialize(value.policyType),
                "part": try NullableSerializer(Serialization._StringSerializer).serialize(value.part),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> GovernancePolicyZipPartDownloadedDetails {
            switch json {
            case .dictionary(let dict):
                let governancePolicyId = try Serialization._StringSerializer.deserialize(dict["governance_policy_id"] ?? .null)
                let name = try Serialization._StringSerializer.deserialize(dict["name"] ?? .null)
                let exportName = try Serialization._StringSerializer.deserialize(dict["export_name"] ?? .null)
                let policyType = try NullableSerializer(TeamLog.PolicyTypeSerializer()).deserialize(dict["policy_type"] ?? .null)
                let part = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["part"] ?? .null)
                return GovernancePolicyZipPartDownloadedDetails(
                    governancePolicyId: governancePolicyId,
                    name: name,
                    exportName: exportName,
                    policyType: policyType,
                    part: part
                )
            default:
                throw JSONSerializerError.deserializeError(type: GovernancePolicyZipPartDownloadedDetails.self, json: json)
            }
        }
    }

    /// The GovernancePolicyZipPartDownloadedType struct
    public class GovernancePolicyZipPartDownloadedType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try GovernancePolicyZipPartDownloadedTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try GovernancePolicyZipPartDownloadedTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for GovernancePolicyZipPartDownloadedType: \(error)"
            }
        }
    }

    public class GovernancePolicyZipPartDownloadedTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: GovernancePolicyZipPartDownloadedType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> GovernancePolicyZipPartDownloadedType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return GovernancePolicyZipPartDownloadedType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: GovernancePolicyZipPartDownloadedType.self, json: json)
            }
        }
    }

    /// Added external ID for group.
    public class GroupAddExternalIdDetails: CustomStringConvertible, JSONRepresentable {
        /// Current external id.
        public let newValue: String
        public init(newValue: String) {
            stringValidator()(newValue)
            self.newValue = newValue
        }

        func json() throws -> JSON {
            try GroupAddExternalIdDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try GroupAddExternalIdDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for GroupAddExternalIdDetails: \(error)"
            }
        }
    }

    public class GroupAddExternalIdDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: GroupAddExternalIdDetails) throws -> JSON {
            let output = [
                "new_value": try Serialization._StringSerializer.serialize(value.newValue),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> GroupAddExternalIdDetails {
            switch json {
            case .dictionary(let dict):
                let newValue = try Serialization._StringSerializer.deserialize(dict["new_value"] ?? .null)
                return GroupAddExternalIdDetails(newValue: newValue)
            default:
                throw JSONSerializerError.deserializeError(type: GroupAddExternalIdDetails.self, json: json)
            }
        }
    }

    /// The GroupAddExternalIdType struct
    public class GroupAddExternalIdType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try GroupAddExternalIdTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try GroupAddExternalIdTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for GroupAddExternalIdType: \(error)"
            }
        }
    }

    public class GroupAddExternalIdTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: GroupAddExternalIdType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> GroupAddExternalIdType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return GroupAddExternalIdType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: GroupAddExternalIdType.self, json: json)
            }
        }
    }

    /// Added team members to group.
    public class GroupAddMemberDetails: CustomStringConvertible, JSONRepresentable {
        /// Is group owner.
        public let isGroupOwner: Bool
        public init(isGroupOwner: Bool) {
            self.isGroupOwner = isGroupOwner
        }

        func json() throws -> JSON {
            try GroupAddMemberDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try GroupAddMemberDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for GroupAddMemberDetails: \(error)"
            }
        }
    }

    public class GroupAddMemberDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: GroupAddMemberDetails) throws -> JSON {
            let output = [
                "is_group_owner": try Serialization._BoolSerializer.serialize(value.isGroupOwner),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> GroupAddMemberDetails {
            switch json {
            case .dictionary(let dict):
                let isGroupOwner = try Serialization._BoolSerializer.deserialize(dict["is_group_owner"] ?? .null)
                return GroupAddMemberDetails(isGroupOwner: isGroupOwner)
            default:
                throw JSONSerializerError.deserializeError(type: GroupAddMemberDetails.self, json: json)
            }
        }
    }

    /// The GroupAddMemberType struct
    public class GroupAddMemberType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try GroupAddMemberTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try GroupAddMemberTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for GroupAddMemberType: \(error)"
            }
        }
    }

    public class GroupAddMemberTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: GroupAddMemberType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> GroupAddMemberType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return GroupAddMemberType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: GroupAddMemberType.self, json: json)
            }
        }
    }

    /// Changed external ID for group.
    public class GroupChangeExternalIdDetails: CustomStringConvertible, JSONRepresentable {
        /// Current external id.
        public let newValue: String
        /// Old external id.
        public let previousValue: String
        public init(newValue: String, previousValue: String) {
            stringValidator()(newValue)
            self.newValue = newValue
            stringValidator()(previousValue)
            self.previousValue = previousValue
        }

        func json() throws -> JSON {
            try GroupChangeExternalIdDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try GroupChangeExternalIdDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for GroupChangeExternalIdDetails: \(error)"
            }
        }
    }

    public class GroupChangeExternalIdDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: GroupChangeExternalIdDetails) throws -> JSON {
            let output = [
                "new_value": try Serialization._StringSerializer.serialize(value.newValue),
                "previous_value": try Serialization._StringSerializer.serialize(value.previousValue),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> GroupChangeExternalIdDetails {
            switch json {
            case .dictionary(let dict):
                let newValue = try Serialization._StringSerializer.deserialize(dict["new_value"] ?? .null)
                let previousValue = try Serialization._StringSerializer.deserialize(dict["previous_value"] ?? .null)
                return GroupChangeExternalIdDetails(newValue: newValue, previousValue: previousValue)
            default:
                throw JSONSerializerError.deserializeError(type: GroupChangeExternalIdDetails.self, json: json)
            }
        }
    }

    /// The GroupChangeExternalIdType struct
    public class GroupChangeExternalIdType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try GroupChangeExternalIdTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try GroupChangeExternalIdTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for GroupChangeExternalIdType: \(error)"
            }
        }
    }

    public class GroupChangeExternalIdTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: GroupChangeExternalIdType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> GroupChangeExternalIdType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return GroupChangeExternalIdType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: GroupChangeExternalIdType.self, json: json)
            }
        }
    }

    /// Changed group management type.
    public class GroupChangeManagementTypeDetails: CustomStringConvertible, JSONRepresentable {
        /// New group management type.
        public let newValue: TeamCommon.GroupManagementType
        /// Previous group management type. Might be missing due to historical data gap.
        public let previousValue: TeamCommon.GroupManagementType?
        public init(newValue: TeamCommon.GroupManagementType, previousValue: TeamCommon.GroupManagementType? = nil) {
            self.newValue = newValue
            self.previousValue = previousValue
        }

        func json() throws -> JSON {
            try GroupChangeManagementTypeDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try GroupChangeManagementTypeDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for GroupChangeManagementTypeDetails: \(error)"
            }
        }
    }

    public class GroupChangeManagementTypeDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: GroupChangeManagementTypeDetails) throws -> JSON {
            let output = [
                "new_value": try TeamCommon.GroupManagementTypeSerializer().serialize(value.newValue),
                "previous_value": try NullableSerializer(TeamCommon.GroupManagementTypeSerializer()).serialize(value.previousValue),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> GroupChangeManagementTypeDetails {
            switch json {
            case .dictionary(let dict):
                let newValue = try TeamCommon.GroupManagementTypeSerializer().deserialize(dict["new_value"] ?? .null)
                let previousValue = try NullableSerializer(TeamCommon.GroupManagementTypeSerializer()).deserialize(dict["previous_value"] ?? .null)
                return GroupChangeManagementTypeDetails(newValue: newValue, previousValue: previousValue)
            default:
                throw JSONSerializerError.deserializeError(type: GroupChangeManagementTypeDetails.self, json: json)
            }
        }
    }

    /// The GroupChangeManagementTypeType struct
    public class GroupChangeManagementTypeType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try GroupChangeManagementTypeTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try GroupChangeManagementTypeTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for GroupChangeManagementTypeType: \(error)"
            }
        }
    }

    public class GroupChangeManagementTypeTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: GroupChangeManagementTypeType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> GroupChangeManagementTypeType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return GroupChangeManagementTypeType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: GroupChangeManagementTypeType.self, json: json)
            }
        }
    }

    /// Changed manager permissions of group member.
    public class GroupChangeMemberRoleDetails: CustomStringConvertible, JSONRepresentable {
        /// Is group owner.
        public let isGroupOwner: Bool
        public init(isGroupOwner: Bool) {
            self.isGroupOwner = isGroupOwner
        }

        func json() throws -> JSON {
            try GroupChangeMemberRoleDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try GroupChangeMemberRoleDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for GroupChangeMemberRoleDetails: \(error)"
            }
        }
    }

    public class GroupChangeMemberRoleDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: GroupChangeMemberRoleDetails) throws -> JSON {
            let output = [
                "is_group_owner": try Serialization._BoolSerializer.serialize(value.isGroupOwner),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> GroupChangeMemberRoleDetails {
            switch json {
            case .dictionary(let dict):
                let isGroupOwner = try Serialization._BoolSerializer.deserialize(dict["is_group_owner"] ?? .null)
                return GroupChangeMemberRoleDetails(isGroupOwner: isGroupOwner)
            default:
                throw JSONSerializerError.deserializeError(type: GroupChangeMemberRoleDetails.self, json: json)
            }
        }
    }

    /// The GroupChangeMemberRoleType struct
    public class GroupChangeMemberRoleType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try GroupChangeMemberRoleTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try GroupChangeMemberRoleTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for GroupChangeMemberRoleType: \(error)"
            }
        }
    }

    public class GroupChangeMemberRoleTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: GroupChangeMemberRoleType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> GroupChangeMemberRoleType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return GroupChangeMemberRoleType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: GroupChangeMemberRoleType.self, json: json)
            }
        }
    }

    /// Created group.
    public class GroupCreateDetails: CustomStringConvertible, JSONRepresentable {
        /// Is company managed group.
        public let isCompanyManaged: Bool?
        /// Group join policy.
        public let joinPolicy: TeamLog.GroupJoinPolicy?
        public init(isCompanyManaged: Bool? = nil, joinPolicy: TeamLog.GroupJoinPolicy? = nil) {
            self.isCompanyManaged = isCompanyManaged
            self.joinPolicy = joinPolicy
        }

        func json() throws -> JSON {
            try GroupCreateDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try GroupCreateDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for GroupCreateDetails: \(error)"
            }
        }
    }

    public class GroupCreateDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: GroupCreateDetails) throws -> JSON {
            let output = [
                "is_company_managed": try NullableSerializer(Serialization._BoolSerializer).serialize(value.isCompanyManaged),
                "join_policy": try NullableSerializer(TeamLog.GroupJoinPolicySerializer()).serialize(value.joinPolicy),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> GroupCreateDetails {
            switch json {
            case .dictionary(let dict):
                let isCompanyManaged = try NullableSerializer(Serialization._BoolSerializer).deserialize(dict["is_company_managed"] ?? .null)
                let joinPolicy = try NullableSerializer(TeamLog.GroupJoinPolicySerializer()).deserialize(dict["join_policy"] ?? .null)
                return GroupCreateDetails(isCompanyManaged: isCompanyManaged, joinPolicy: joinPolicy)
            default:
                throw JSONSerializerError.deserializeError(type: GroupCreateDetails.self, json: json)
            }
        }
    }

    /// The GroupCreateType struct
    public class GroupCreateType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try GroupCreateTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try GroupCreateTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for GroupCreateType: \(error)"
            }
        }
    }

    public class GroupCreateTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: GroupCreateType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> GroupCreateType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return GroupCreateType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: GroupCreateType.self, json: json)
            }
        }
    }

    /// Deleted group.
    public class GroupDeleteDetails: CustomStringConvertible, JSONRepresentable {
        /// Is company managed group.
        public let isCompanyManaged: Bool?
        public init(isCompanyManaged: Bool? = nil) {
            self.isCompanyManaged = isCompanyManaged
        }

        func json() throws -> JSON {
            try GroupDeleteDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try GroupDeleteDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for GroupDeleteDetails: \(error)"
            }
        }
    }

    public class GroupDeleteDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: GroupDeleteDetails) throws -> JSON {
            let output = [
                "is_company_managed": try NullableSerializer(Serialization._BoolSerializer).serialize(value.isCompanyManaged),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> GroupDeleteDetails {
            switch json {
            case .dictionary(let dict):
                let isCompanyManaged = try NullableSerializer(Serialization._BoolSerializer).deserialize(dict["is_company_managed"] ?? .null)
                return GroupDeleteDetails(isCompanyManaged: isCompanyManaged)
            default:
                throw JSONSerializerError.deserializeError(type: GroupDeleteDetails.self, json: json)
            }
        }
    }

    /// The GroupDeleteType struct
    public class GroupDeleteType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try GroupDeleteTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try GroupDeleteTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for GroupDeleteType: \(error)"
            }
        }
    }

    public class GroupDeleteTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: GroupDeleteType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> GroupDeleteType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return GroupDeleteType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: GroupDeleteType.self, json: json)
            }
        }
    }

    /// Updated group.
    public class GroupDescriptionUpdatedDetails: CustomStringConvertible, JSONRepresentable {
        func json() throws -> JSON {
            try GroupDescriptionUpdatedDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try GroupDescriptionUpdatedDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for GroupDescriptionUpdatedDetails: \(error)"
            }
        }
    }

    public class GroupDescriptionUpdatedDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: GroupDescriptionUpdatedDetails) throws -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> GroupDescriptionUpdatedDetails {
            switch json {
            case .dictionary:
                return GroupDescriptionUpdatedDetails()
            default:
                throw JSONSerializerError.deserializeError(type: GroupDescriptionUpdatedDetails.self, json: json)
            }
        }
    }

    /// The GroupDescriptionUpdatedType struct
    public class GroupDescriptionUpdatedType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try GroupDescriptionUpdatedTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try GroupDescriptionUpdatedTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for GroupDescriptionUpdatedType: \(error)"
            }
        }
    }

    public class GroupDescriptionUpdatedTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: GroupDescriptionUpdatedType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> GroupDescriptionUpdatedType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return GroupDescriptionUpdatedType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: GroupDescriptionUpdatedType.self, json: json)
            }
        }
    }

    /// The GroupJoinPolicy union
    public enum GroupJoinPolicy: CustomStringConvertible, JSONRepresentable {
        /// An unspecified error.
        case open
        /// An unspecified error.
        case requestToJoin
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try GroupJoinPolicySerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try GroupJoinPolicySerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for GroupJoinPolicy: \(error)"
            }
        }
    }

    public class GroupJoinPolicySerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: GroupJoinPolicy) throws -> JSON {
            switch value {
            case .open:
                var d = [String: JSON]()
                d[".tag"] = .str("open")
                return .dictionary(d)
            case .requestToJoin:
                var d = [String: JSON]()
                d[".tag"] = .str("request_to_join")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> GroupJoinPolicy {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "open":
                    return GroupJoinPolicy.open
                case "request_to_join":
                    return GroupJoinPolicy.requestToJoin
                case "other":
                    return GroupJoinPolicy.other
                default:
                    return GroupJoinPolicy.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: GroupJoinPolicy.self, json: json)
            }
        }
    }

    /// Updated group join policy.
    public class GroupJoinPolicyUpdatedDetails: CustomStringConvertible, JSONRepresentable {
        /// Is company managed group.
        public let isCompanyManaged: Bool?
        /// Group join policy.
        public let joinPolicy: TeamLog.GroupJoinPolicy?
        public init(isCompanyManaged: Bool? = nil, joinPolicy: TeamLog.GroupJoinPolicy? = nil) {
            self.isCompanyManaged = isCompanyManaged
            self.joinPolicy = joinPolicy
        }

        func json() throws -> JSON {
            try GroupJoinPolicyUpdatedDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try GroupJoinPolicyUpdatedDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for GroupJoinPolicyUpdatedDetails: \(error)"
            }
        }
    }

    public class GroupJoinPolicyUpdatedDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: GroupJoinPolicyUpdatedDetails) throws -> JSON {
            let output = [
                "is_company_managed": try NullableSerializer(Serialization._BoolSerializer).serialize(value.isCompanyManaged),
                "join_policy": try NullableSerializer(TeamLog.GroupJoinPolicySerializer()).serialize(value.joinPolicy),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> GroupJoinPolicyUpdatedDetails {
            switch json {
            case .dictionary(let dict):
                let isCompanyManaged = try NullableSerializer(Serialization._BoolSerializer).deserialize(dict["is_company_managed"] ?? .null)
                let joinPolicy = try NullableSerializer(TeamLog.GroupJoinPolicySerializer()).deserialize(dict["join_policy"] ?? .null)
                return GroupJoinPolicyUpdatedDetails(isCompanyManaged: isCompanyManaged, joinPolicy: joinPolicy)
            default:
                throw JSONSerializerError.deserializeError(type: GroupJoinPolicyUpdatedDetails.self, json: json)
            }
        }
    }

    /// The GroupJoinPolicyUpdatedType struct
    public class GroupJoinPolicyUpdatedType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try GroupJoinPolicyUpdatedTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try GroupJoinPolicyUpdatedTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for GroupJoinPolicyUpdatedType: \(error)"
            }
        }
    }

    public class GroupJoinPolicyUpdatedTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: GroupJoinPolicyUpdatedType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> GroupJoinPolicyUpdatedType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return GroupJoinPolicyUpdatedType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: GroupJoinPolicyUpdatedType.self, json: json)
            }
        }
    }

    /// Group's logged information.
    public class GroupLogInfo: CustomStringConvertible, JSONRepresentable {
        /// The unique id of this group.
        public let groupId: String?
        /// The name of this group.
        public let displayName: String
        /// External group ID.
        public let externalId: String?
        public init(displayName: String, groupId: String? = nil, externalId: String? = nil) {
            nullableValidator(stringValidator())(groupId)
            self.groupId = groupId
            stringValidator()(displayName)
            self.displayName = displayName
            nullableValidator(stringValidator())(externalId)
            self.externalId = externalId
        }

        func json() throws -> JSON {
            try GroupLogInfoSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try GroupLogInfoSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for GroupLogInfo: \(error)"
            }
        }
    }

    public class GroupLogInfoSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: GroupLogInfo) throws -> JSON {
            let output = [
                "display_name": try Serialization._StringSerializer.serialize(value.displayName),
                "group_id": try NullableSerializer(Serialization._StringSerializer).serialize(value.groupId),
                "external_id": try NullableSerializer(Serialization._StringSerializer).serialize(value.externalId),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> GroupLogInfo {
            switch json {
            case .dictionary(let dict):
                let displayName = try Serialization._StringSerializer.deserialize(dict["display_name"] ?? .null)
                let groupId = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["group_id"] ?? .null)
                let externalId = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["external_id"] ?? .null)
                return GroupLogInfo(displayName: displayName, groupId: groupId, externalId: externalId)
            default:
                throw JSONSerializerError.deserializeError(type: GroupLogInfo.self, json: json)
            }
        }
    }

    /// Moved group.
    public class GroupMovedDetails: CustomStringConvertible, JSONRepresentable {
        func json() throws -> JSON {
            try GroupMovedDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try GroupMovedDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for GroupMovedDetails: \(error)"
            }
        }
    }

    public class GroupMovedDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: GroupMovedDetails) throws -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> GroupMovedDetails {
            switch json {
            case .dictionary:
                return GroupMovedDetails()
            default:
                throw JSONSerializerError.deserializeError(type: GroupMovedDetails.self, json: json)
            }
        }
    }

    /// The GroupMovedType struct
    public class GroupMovedType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try GroupMovedTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try GroupMovedTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for GroupMovedType: \(error)"
            }
        }
    }

    public class GroupMovedTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: GroupMovedType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> GroupMovedType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return GroupMovedType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: GroupMovedType.self, json: json)
            }
        }
    }

    /// Removed external ID for group.
    public class GroupRemoveExternalIdDetails: CustomStringConvertible, JSONRepresentable {
        /// Old external id.
        public let previousValue: String
        public init(previousValue: String) {
            stringValidator()(previousValue)
            self.previousValue = previousValue
        }

        func json() throws -> JSON {
            try GroupRemoveExternalIdDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try GroupRemoveExternalIdDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for GroupRemoveExternalIdDetails: \(error)"
            }
        }
    }

    public class GroupRemoveExternalIdDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: GroupRemoveExternalIdDetails) throws -> JSON {
            let output = [
                "previous_value": try Serialization._StringSerializer.serialize(value.previousValue),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> GroupRemoveExternalIdDetails {
            switch json {
            case .dictionary(let dict):
                let previousValue = try Serialization._StringSerializer.deserialize(dict["previous_value"] ?? .null)
                return GroupRemoveExternalIdDetails(previousValue: previousValue)
            default:
                throw JSONSerializerError.deserializeError(type: GroupRemoveExternalIdDetails.self, json: json)
            }
        }
    }

    /// The GroupRemoveExternalIdType struct
    public class GroupRemoveExternalIdType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try GroupRemoveExternalIdTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try GroupRemoveExternalIdTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for GroupRemoveExternalIdType: \(error)"
            }
        }
    }

    public class GroupRemoveExternalIdTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: GroupRemoveExternalIdType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> GroupRemoveExternalIdType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return GroupRemoveExternalIdType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: GroupRemoveExternalIdType.self, json: json)
            }
        }
    }

    /// Removed team members from group.
    public class GroupRemoveMemberDetails: CustomStringConvertible, JSONRepresentable {
        func json() throws -> JSON {
            try GroupRemoveMemberDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try GroupRemoveMemberDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for GroupRemoveMemberDetails: \(error)"
            }
        }
    }

    public class GroupRemoveMemberDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: GroupRemoveMemberDetails) throws -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> GroupRemoveMemberDetails {
            switch json {
            case .dictionary:
                return GroupRemoveMemberDetails()
            default:
                throw JSONSerializerError.deserializeError(type: GroupRemoveMemberDetails.self, json: json)
            }
        }
    }

    /// The GroupRemoveMemberType struct
    public class GroupRemoveMemberType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try GroupRemoveMemberTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try GroupRemoveMemberTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for GroupRemoveMemberType: \(error)"
            }
        }
    }

    public class GroupRemoveMemberTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: GroupRemoveMemberType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> GroupRemoveMemberType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return GroupRemoveMemberType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: GroupRemoveMemberType.self, json: json)
            }
        }
    }

    /// Renamed group.
    public class GroupRenameDetails: CustomStringConvertible, JSONRepresentable {
        /// Previous display name.
        public let previousValue: String
        /// New display name.
        public let newValue: String
        public init(previousValue: String, newValue: String) {
            stringValidator()(previousValue)
            self.previousValue = previousValue
            stringValidator()(newValue)
            self.newValue = newValue
        }

        func json() throws -> JSON {
            try GroupRenameDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try GroupRenameDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for GroupRenameDetails: \(error)"
            }
        }
    }

    public class GroupRenameDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: GroupRenameDetails) throws -> JSON {
            let output = [
                "previous_value": try Serialization._StringSerializer.serialize(value.previousValue),
                "new_value": try Serialization._StringSerializer.serialize(value.newValue),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> GroupRenameDetails {
            switch json {
            case .dictionary(let dict):
                let previousValue = try Serialization._StringSerializer.deserialize(dict["previous_value"] ?? .null)
                let newValue = try Serialization._StringSerializer.deserialize(dict["new_value"] ?? .null)
                return GroupRenameDetails(previousValue: previousValue, newValue: newValue)
            default:
                throw JSONSerializerError.deserializeError(type: GroupRenameDetails.self, json: json)
            }
        }
    }

    /// The GroupRenameType struct
    public class GroupRenameType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try GroupRenameTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try GroupRenameTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for GroupRenameType: \(error)"
            }
        }
    }

    public class GroupRenameTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: GroupRenameType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> GroupRenameType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return GroupRenameType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: GroupRenameType.self, json: json)
            }
        }
    }

    /// Changed who can create groups.
    public class GroupUserManagementChangePolicyDetails: CustomStringConvertible, JSONRepresentable {
        /// New group users management policy.
        public let newValue: TeamPolicies.GroupCreation
        /// Previous group users management policy. Might be missing due to historical data gap.
        public let previousValue: TeamPolicies.GroupCreation?
        public init(newValue: TeamPolicies.GroupCreation, previousValue: TeamPolicies.GroupCreation? = nil) {
            self.newValue = newValue
            self.previousValue = previousValue
        }

        func json() throws -> JSON {
            try GroupUserManagementChangePolicyDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try GroupUserManagementChangePolicyDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for GroupUserManagementChangePolicyDetails: \(error)"
            }
        }
    }

    public class GroupUserManagementChangePolicyDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: GroupUserManagementChangePolicyDetails) throws -> JSON {
            let output = [
                "new_value": try TeamPolicies.GroupCreationSerializer().serialize(value.newValue),
                "previous_value": try NullableSerializer(TeamPolicies.GroupCreationSerializer()).serialize(value.previousValue),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> GroupUserManagementChangePolicyDetails {
            switch json {
            case .dictionary(let dict):
                let newValue = try TeamPolicies.GroupCreationSerializer().deserialize(dict["new_value"] ?? .null)
                let previousValue = try NullableSerializer(TeamPolicies.GroupCreationSerializer()).deserialize(dict["previous_value"] ?? .null)
                return GroupUserManagementChangePolicyDetails(newValue: newValue, previousValue: previousValue)
            default:
                throw JSONSerializerError.deserializeError(type: GroupUserManagementChangePolicyDetails.self, json: json)
            }
        }
    }

    /// The GroupUserManagementChangePolicyType struct
    public class GroupUserManagementChangePolicyType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try GroupUserManagementChangePolicyTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try GroupUserManagementChangePolicyTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for GroupUserManagementChangePolicyType: \(error)"
            }
        }
    }

    public class GroupUserManagementChangePolicyTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: GroupUserManagementChangePolicyType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> GroupUserManagementChangePolicyType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return GroupUserManagementChangePolicyType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: GroupUserManagementChangePolicyType.self, json: json)
            }
        }
    }

    /// Changed guest team admin status.
    public class GuestAdminChangeStatusDetails: CustomStringConvertible, JSONRepresentable {
        /// True for guest, false for host.
        public let isGuest: Bool
        /// The name of the guest team.
        public let guestTeamName: String?
        /// The name of the host team.
        public let hostTeamName: String?
        /// Previous request state.
        public let previousValue: TeamLog.TrustedTeamsRequestState
        /// New request state.
        public let newValue: TeamLog.TrustedTeamsRequestState
        /// Action details.
        public let actionDetails: TeamLog.TrustedTeamsRequestAction
        public init(
            isGuest: Bool,
            previousValue: TeamLog.TrustedTeamsRequestState,
            newValue: TeamLog.TrustedTeamsRequestState,
            actionDetails: TeamLog.TrustedTeamsRequestAction,
            guestTeamName: String? = nil,
            hostTeamName: String? = nil
        ) {
            self.isGuest = isGuest
            nullableValidator(stringValidator())(guestTeamName)
            self.guestTeamName = guestTeamName
            nullableValidator(stringValidator())(hostTeamName)
            self.hostTeamName = hostTeamName
            self.previousValue = previousValue
            self.newValue = newValue
            self.actionDetails = actionDetails
        }

        func json() throws -> JSON {
            try GuestAdminChangeStatusDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try GuestAdminChangeStatusDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for GuestAdminChangeStatusDetails: \(error)"
            }
        }
    }

    public class GuestAdminChangeStatusDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: GuestAdminChangeStatusDetails) throws -> JSON {
            let output = [
                "is_guest": try Serialization._BoolSerializer.serialize(value.isGuest),
                "previous_value": try TeamLog.TrustedTeamsRequestStateSerializer().serialize(value.previousValue),
                "new_value": try TeamLog.TrustedTeamsRequestStateSerializer().serialize(value.newValue),
                "action_details": try TeamLog.TrustedTeamsRequestActionSerializer().serialize(value.actionDetails),
                "guest_team_name": try NullableSerializer(Serialization._StringSerializer).serialize(value.guestTeamName),
                "host_team_name": try NullableSerializer(Serialization._StringSerializer).serialize(value.hostTeamName),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> GuestAdminChangeStatusDetails {
            switch json {
            case .dictionary(let dict):
                let isGuest = try Serialization._BoolSerializer.deserialize(dict["is_guest"] ?? .null)
                let previousValue = try TeamLog.TrustedTeamsRequestStateSerializer().deserialize(dict["previous_value"] ?? .null)
                let newValue = try TeamLog.TrustedTeamsRequestStateSerializer().deserialize(dict["new_value"] ?? .null)
                let actionDetails = try TeamLog.TrustedTeamsRequestActionSerializer().deserialize(dict["action_details"] ?? .null)
                let guestTeamName = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["guest_team_name"] ?? .null)
                let hostTeamName = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["host_team_name"] ?? .null)
                return GuestAdminChangeStatusDetails(
                    isGuest: isGuest,
                    previousValue: previousValue,
                    newValue: newValue,
                    actionDetails: actionDetails,
                    guestTeamName: guestTeamName,
                    hostTeamName: hostTeamName
                )
            default:
                throw JSONSerializerError.deserializeError(type: GuestAdminChangeStatusDetails.self, json: json)
            }
        }
    }

    /// The GuestAdminChangeStatusType struct
    public class GuestAdminChangeStatusType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try GuestAdminChangeStatusTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try GuestAdminChangeStatusTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for GuestAdminChangeStatusType: \(error)"
            }
        }
    }

    public class GuestAdminChangeStatusTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: GuestAdminChangeStatusType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> GuestAdminChangeStatusType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return GuestAdminChangeStatusType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: GuestAdminChangeStatusType.self, json: json)
            }
        }
    }

    /// Started trusted team admin session.
    public class GuestAdminSignedInViaTrustedTeamsDetails: CustomStringConvertible, JSONRepresentable {
        /// Host team name.
        public let teamName: String?
        /// Trusted team name.
        public let trustedTeamName: String?
        public init(teamName: String? = nil, trustedTeamName: String? = nil) {
            nullableValidator(stringValidator())(teamName)
            self.teamName = teamName
            nullableValidator(stringValidator())(trustedTeamName)
            self.trustedTeamName = trustedTeamName
        }

        func json() throws -> JSON {
            try GuestAdminSignedInViaTrustedTeamsDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try GuestAdminSignedInViaTrustedTeamsDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for GuestAdminSignedInViaTrustedTeamsDetails: \(error)"
            }
        }
    }

    public class GuestAdminSignedInViaTrustedTeamsDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: GuestAdminSignedInViaTrustedTeamsDetails) throws -> JSON {
            let output = [
                "team_name": try NullableSerializer(Serialization._StringSerializer).serialize(value.teamName),
                "trusted_team_name": try NullableSerializer(Serialization._StringSerializer).serialize(value.trustedTeamName),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> GuestAdminSignedInViaTrustedTeamsDetails {
            switch json {
            case .dictionary(let dict):
                let teamName = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["team_name"] ?? .null)
                let trustedTeamName = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["trusted_team_name"] ?? .null)
                return GuestAdminSignedInViaTrustedTeamsDetails(teamName: teamName, trustedTeamName: trustedTeamName)
            default:
                throw JSONSerializerError.deserializeError(type: GuestAdminSignedInViaTrustedTeamsDetails.self, json: json)
            }
        }
    }

    /// The GuestAdminSignedInViaTrustedTeamsType struct
    public class GuestAdminSignedInViaTrustedTeamsType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try GuestAdminSignedInViaTrustedTeamsTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try GuestAdminSignedInViaTrustedTeamsTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for GuestAdminSignedInViaTrustedTeamsType: \(error)"
            }
        }
    }

    public class GuestAdminSignedInViaTrustedTeamsTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: GuestAdminSignedInViaTrustedTeamsType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> GuestAdminSignedInViaTrustedTeamsType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return GuestAdminSignedInViaTrustedTeamsType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: GuestAdminSignedInViaTrustedTeamsType.self, json: json)
            }
        }
    }

    /// Ended trusted team admin session.
    public class GuestAdminSignedOutViaTrustedTeamsDetails: CustomStringConvertible, JSONRepresentable {
        /// Host team name.
        public let teamName: String?
        /// Trusted team name.
        public let trustedTeamName: String?
        public init(teamName: String? = nil, trustedTeamName: String? = nil) {
            nullableValidator(stringValidator())(teamName)
            self.teamName = teamName
            nullableValidator(stringValidator())(trustedTeamName)
            self.trustedTeamName = trustedTeamName
        }

        func json() throws -> JSON {
            try GuestAdminSignedOutViaTrustedTeamsDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try GuestAdminSignedOutViaTrustedTeamsDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for GuestAdminSignedOutViaTrustedTeamsDetails: \(error)"
            }
        }
    }

    public class GuestAdminSignedOutViaTrustedTeamsDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: GuestAdminSignedOutViaTrustedTeamsDetails) throws -> JSON {
            let output = [
                "team_name": try NullableSerializer(Serialization._StringSerializer).serialize(value.teamName),
                "trusted_team_name": try NullableSerializer(Serialization._StringSerializer).serialize(value.trustedTeamName),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> GuestAdminSignedOutViaTrustedTeamsDetails {
            switch json {
            case .dictionary(let dict):
                let teamName = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["team_name"] ?? .null)
                let trustedTeamName = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["trusted_team_name"] ?? .null)
                return GuestAdminSignedOutViaTrustedTeamsDetails(teamName: teamName, trustedTeamName: trustedTeamName)
            default:
                throw JSONSerializerError.deserializeError(type: GuestAdminSignedOutViaTrustedTeamsDetails.self, json: json)
            }
        }
    }

    /// The GuestAdminSignedOutViaTrustedTeamsType struct
    public class GuestAdminSignedOutViaTrustedTeamsType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try GuestAdminSignedOutViaTrustedTeamsTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try GuestAdminSignedOutViaTrustedTeamsTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for GuestAdminSignedOutViaTrustedTeamsType: \(error)"
            }
        }
    }

    public class GuestAdminSignedOutViaTrustedTeamsTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: GuestAdminSignedOutViaTrustedTeamsType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> GuestAdminSignedOutViaTrustedTeamsType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return GuestAdminSignedOutViaTrustedTeamsType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: GuestAdminSignedOutViaTrustedTeamsType.self, json: json)
            }
        }
    }

    /// The IdentifierType union
    public enum IdentifierType: CustomStringConvertible, JSONRepresentable {
        /// An unspecified error.
        case email
        /// An unspecified error.
        case facebookProfileName
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try IdentifierTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try IdentifierTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for IdentifierType: \(error)"
            }
        }
    }

    public class IdentifierTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: IdentifierType) throws -> JSON {
            switch value {
            case .email:
                var d = [String: JSON]()
                d[".tag"] = .str("email")
                return .dictionary(d)
            case .facebookProfileName:
                var d = [String: JSON]()
                d[".tag"] = .str("facebook_profile_name")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> IdentifierType {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "email":
                    return IdentifierType.email
                case "facebook_profile_name":
                    return IdentifierType.facebookProfileName
                case "other":
                    return IdentifierType.other
                default:
                    return IdentifierType.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: IdentifierType.self, json: json)
            }
        }
    }

    /// Connected integration for member.
    public class IntegrationConnectedDetails: CustomStringConvertible, JSONRepresentable {
        /// Name of the third-party integration.
        public let integrationName: String
        public init(integrationName: String) {
            stringValidator()(integrationName)
            self.integrationName = integrationName
        }

        func json() throws -> JSON {
            try IntegrationConnectedDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try IntegrationConnectedDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for IntegrationConnectedDetails: \(error)"
            }
        }
    }

    public class IntegrationConnectedDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: IntegrationConnectedDetails) throws -> JSON {
            let output = [
                "integration_name": try Serialization._StringSerializer.serialize(value.integrationName),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> IntegrationConnectedDetails {
            switch json {
            case .dictionary(let dict):
                let integrationName = try Serialization._StringSerializer.deserialize(dict["integration_name"] ?? .null)
                return IntegrationConnectedDetails(integrationName: integrationName)
            default:
                throw JSONSerializerError.deserializeError(type: IntegrationConnectedDetails.self, json: json)
            }
        }
    }

    /// The IntegrationConnectedType struct
    public class IntegrationConnectedType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try IntegrationConnectedTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try IntegrationConnectedTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for IntegrationConnectedType: \(error)"
            }
        }
    }

    public class IntegrationConnectedTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: IntegrationConnectedType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> IntegrationConnectedType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return IntegrationConnectedType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: IntegrationConnectedType.self, json: json)
            }
        }
    }

    /// Disconnected integration for member.
    public class IntegrationDisconnectedDetails: CustomStringConvertible, JSONRepresentable {
        /// Name of the third-party integration.
        public let integrationName: String
        public init(integrationName: String) {
            stringValidator()(integrationName)
            self.integrationName = integrationName
        }

        func json() throws -> JSON {
            try IntegrationDisconnectedDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try IntegrationDisconnectedDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for IntegrationDisconnectedDetails: \(error)"
            }
        }
    }

    public class IntegrationDisconnectedDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: IntegrationDisconnectedDetails) throws -> JSON {
            let output = [
                "integration_name": try Serialization._StringSerializer.serialize(value.integrationName),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> IntegrationDisconnectedDetails {
            switch json {
            case .dictionary(let dict):
                let integrationName = try Serialization._StringSerializer.deserialize(dict["integration_name"] ?? .null)
                return IntegrationDisconnectedDetails(integrationName: integrationName)
            default:
                throw JSONSerializerError.deserializeError(type: IntegrationDisconnectedDetails.self, json: json)
            }
        }
    }

    /// The IntegrationDisconnectedType struct
    public class IntegrationDisconnectedType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try IntegrationDisconnectedTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try IntegrationDisconnectedTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for IntegrationDisconnectedType: \(error)"
            }
        }
    }

    public class IntegrationDisconnectedTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: IntegrationDisconnectedType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> IntegrationDisconnectedType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return IntegrationDisconnectedType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: IntegrationDisconnectedType.self, json: json)
            }
        }
    }

    /// Policy for controlling whether a service integration is enabled for the team.
    public enum IntegrationPolicy: CustomStringConvertible, JSONRepresentable {
        /// An unspecified error.
        case disabled
        /// An unspecified error.
        case enabled
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try IntegrationPolicySerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try IntegrationPolicySerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for IntegrationPolicy: \(error)"
            }
        }
    }

    public class IntegrationPolicySerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: IntegrationPolicy) throws -> JSON {
            switch value {
            case .disabled:
                var d = [String: JSON]()
                d[".tag"] = .str("disabled")
                return .dictionary(d)
            case .enabled:
                var d = [String: JSON]()
                d[".tag"] = .str("enabled")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> IntegrationPolicy {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "disabled":
                    return IntegrationPolicy.disabled
                case "enabled":
                    return IntegrationPolicy.enabled
                case "other":
                    return IntegrationPolicy.other
                default:
                    return IntegrationPolicy.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: IntegrationPolicy.self, json: json)
            }
        }
    }

    /// Changed integration policy for team.
    public class IntegrationPolicyChangedDetails: CustomStringConvertible, JSONRepresentable {
        /// Name of the third-party integration.
        public let integrationName: String
        /// New integration policy.
        public let newValue: TeamLog.IntegrationPolicy
        /// Previous integration policy.
        public let previousValue: TeamLog.IntegrationPolicy
        public init(integrationName: String, newValue: TeamLog.IntegrationPolicy, previousValue: TeamLog.IntegrationPolicy) {
            stringValidator()(integrationName)
            self.integrationName = integrationName
            self.newValue = newValue
            self.previousValue = previousValue
        }

        func json() throws -> JSON {
            try IntegrationPolicyChangedDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try IntegrationPolicyChangedDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for IntegrationPolicyChangedDetails: \(error)"
            }
        }
    }

    public class IntegrationPolicyChangedDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: IntegrationPolicyChangedDetails) throws -> JSON {
            let output = [
                "integration_name": try Serialization._StringSerializer.serialize(value.integrationName),
                "new_value": try TeamLog.IntegrationPolicySerializer().serialize(value.newValue),
                "previous_value": try TeamLog.IntegrationPolicySerializer().serialize(value.previousValue),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> IntegrationPolicyChangedDetails {
            switch json {
            case .dictionary(let dict):
                let integrationName = try Serialization._StringSerializer.deserialize(dict["integration_name"] ?? .null)
                let newValue = try TeamLog.IntegrationPolicySerializer().deserialize(dict["new_value"] ?? .null)
                let previousValue = try TeamLog.IntegrationPolicySerializer().deserialize(dict["previous_value"] ?? .null)
                return IntegrationPolicyChangedDetails(integrationName: integrationName, newValue: newValue, previousValue: previousValue)
            default:
                throw JSONSerializerError.deserializeError(type: IntegrationPolicyChangedDetails.self, json: json)
            }
        }
    }

    /// The IntegrationPolicyChangedType struct
    public class IntegrationPolicyChangedType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try IntegrationPolicyChangedTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try IntegrationPolicyChangedTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for IntegrationPolicyChangedType: \(error)"
            }
        }
    }

    public class IntegrationPolicyChangedTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: IntegrationPolicyChangedType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> IntegrationPolicyChangedType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return IntegrationPolicyChangedType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: IntegrationPolicyChangedType.self, json: json)
            }
        }
    }

    /// Policy for deciding whether team admins receive email when an invitation to join the team is accepted
    public enum InviteAcceptanceEmailPolicy: CustomStringConvertible, JSONRepresentable {
        /// An unspecified error.
        case disabled
        /// An unspecified error.
        case enabled
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try InviteAcceptanceEmailPolicySerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try InviteAcceptanceEmailPolicySerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for InviteAcceptanceEmailPolicy: \(error)"
            }
        }
    }

    public class InviteAcceptanceEmailPolicySerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: InviteAcceptanceEmailPolicy) throws -> JSON {
            switch value {
            case .disabled:
                var d = [String: JSON]()
                d[".tag"] = .str("disabled")
                return .dictionary(d)
            case .enabled:
                var d = [String: JSON]()
                d[".tag"] = .str("enabled")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> InviteAcceptanceEmailPolicy {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "disabled":
                    return InviteAcceptanceEmailPolicy.disabled
                case "enabled":
                    return InviteAcceptanceEmailPolicy.enabled
                case "other":
                    return InviteAcceptanceEmailPolicy.other
                default:
                    return InviteAcceptanceEmailPolicy.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: InviteAcceptanceEmailPolicy.self, json: json)
            }
        }
    }

    /// Changed invite accept email policy for team.
    public class InviteAcceptanceEmailPolicyChangedDetails: CustomStringConvertible, JSONRepresentable {
        /// To.
        public let newValue: TeamLog.InviteAcceptanceEmailPolicy
        /// From.
        public let previousValue: TeamLog.InviteAcceptanceEmailPolicy
        public init(newValue: TeamLog.InviteAcceptanceEmailPolicy, previousValue: TeamLog.InviteAcceptanceEmailPolicy) {
            self.newValue = newValue
            self.previousValue = previousValue
        }

        func json() throws -> JSON {
            try InviteAcceptanceEmailPolicyChangedDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try InviteAcceptanceEmailPolicyChangedDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for InviteAcceptanceEmailPolicyChangedDetails: \(error)"
            }
        }
    }

    public class InviteAcceptanceEmailPolicyChangedDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: InviteAcceptanceEmailPolicyChangedDetails) throws -> JSON {
            let output = [
                "new_value": try TeamLog.InviteAcceptanceEmailPolicySerializer().serialize(value.newValue),
                "previous_value": try TeamLog.InviteAcceptanceEmailPolicySerializer().serialize(value.previousValue),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> InviteAcceptanceEmailPolicyChangedDetails {
            switch json {
            case .dictionary(let dict):
                let newValue = try TeamLog.InviteAcceptanceEmailPolicySerializer().deserialize(dict["new_value"] ?? .null)
                let previousValue = try TeamLog.InviteAcceptanceEmailPolicySerializer().deserialize(dict["previous_value"] ?? .null)
                return InviteAcceptanceEmailPolicyChangedDetails(newValue: newValue, previousValue: previousValue)
            default:
                throw JSONSerializerError.deserializeError(type: InviteAcceptanceEmailPolicyChangedDetails.self, json: json)
            }
        }
    }

    /// The InviteAcceptanceEmailPolicyChangedType struct
    public class InviteAcceptanceEmailPolicyChangedType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try InviteAcceptanceEmailPolicyChangedTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try InviteAcceptanceEmailPolicyChangedTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for InviteAcceptanceEmailPolicyChangedType: \(error)"
            }
        }
    }

    public class InviteAcceptanceEmailPolicyChangedTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: InviteAcceptanceEmailPolicyChangedType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> InviteAcceptanceEmailPolicyChangedType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return InviteAcceptanceEmailPolicyChangedType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: InviteAcceptanceEmailPolicyChangedType.self, json: json)
            }
        }
    }

    /// The InviteMethod union
    public enum InviteMethod: CustomStringConvertible, JSONRepresentable {
        /// An unspecified error.
        case autoApprove
        /// An unspecified error.
        case inviteLink
        /// An unspecified error.
        case memberInvite
        /// An unspecified error.
        case movedFromAnotherTeam
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try InviteMethodSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try InviteMethodSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for InviteMethod: \(error)"
            }
        }
    }

    public class InviteMethodSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: InviteMethod) throws -> JSON {
            switch value {
            case .autoApprove:
                var d = [String: JSON]()
                d[".tag"] = .str("auto_approve")
                return .dictionary(d)
            case .inviteLink:
                var d = [String: JSON]()
                d[".tag"] = .str("invite_link")
                return .dictionary(d)
            case .memberInvite:
                var d = [String: JSON]()
                d[".tag"] = .str("member_invite")
                return .dictionary(d)
            case .movedFromAnotherTeam:
                var d = [String: JSON]()
                d[".tag"] = .str("moved_from_another_team")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> InviteMethod {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "auto_approve":
                    return InviteMethod.autoApprove
                case "invite_link":
                    return InviteMethod.inviteLink
                case "member_invite":
                    return InviteMethod.memberInvite
                case "moved_from_another_team":
                    return InviteMethod.movedFromAnotherTeam
                case "other":
                    return InviteMethod.other
                default:
                    return InviteMethod.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: InviteMethod.self, json: json)
            }
        }
    }

    /// Additional information relevant when a new member joins the team.
    public class JoinTeamDetails: CustomStringConvertible, JSONRepresentable {
        /// Linked applications. (Deprecated) Please use has_linked_apps boolean field instead.
        public let linkedApps: [TeamLog.UserLinkedAppLogInfo]
        /// Linked devices. (Deprecated) Please use has_linked_devices boolean field instead.
        public let linkedDevices: [TeamLog.LinkedDeviceLogInfo]
        /// Linked shared folders. (Deprecated) Please use has_linked_shared_folders boolean field instead.
        public let linkedSharedFolders: [TeamLog.FolderLogInfo]
        /// (Deprecated) True if the linked_apps list was truncated to the maximum supported length (50).
        public let wasLinkedAppsTruncated: Bool?
        /// (Deprecated) True if the linked_devices list was truncated to the maximum supported length (50).
        public let wasLinkedDevicesTruncated: Bool?
        /// (Deprecated) True if the linked_shared_folders list was truncated to the maximum supported length (50).
        public let wasLinkedSharedFoldersTruncated: Bool?
        /// True if the user had linked apps at event time.
        public let hasLinkedApps: Bool?
        /// True if the user had linked apps at event time.
        public let hasLinkedDevices: Bool?
        /// True if the user had linked shared folders at event time.
        public let hasLinkedSharedFolders: Bool?
        public init(
            linkedApps: [TeamLog.UserLinkedAppLogInfo],
            linkedDevices: [TeamLog.LinkedDeviceLogInfo],
            linkedSharedFolders: [TeamLog.FolderLogInfo],
            wasLinkedAppsTruncated: Bool? = nil,
            wasLinkedDevicesTruncated: Bool? = nil,
            wasLinkedSharedFoldersTruncated: Bool? = nil,
            hasLinkedApps: Bool? = nil,
            hasLinkedDevices: Bool? = nil,
            hasLinkedSharedFolders: Bool? = nil
        ) {
            self.linkedApps = linkedApps
            self.linkedDevices = linkedDevices
            self.linkedSharedFolders = linkedSharedFolders
            self.wasLinkedAppsTruncated = wasLinkedAppsTruncated
            self.wasLinkedDevicesTruncated = wasLinkedDevicesTruncated
            self.wasLinkedSharedFoldersTruncated = wasLinkedSharedFoldersTruncated
            self.hasLinkedApps = hasLinkedApps
            self.hasLinkedDevices = hasLinkedDevices
            self.hasLinkedSharedFolders = hasLinkedSharedFolders
        }

        func json() throws -> JSON {
            try JoinTeamDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try JoinTeamDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for JoinTeamDetails: \(error)"
            }
        }
    }

    public class JoinTeamDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: JoinTeamDetails) throws -> JSON {
            let output = [
                "linked_apps": try ArraySerializer(TeamLog.UserLinkedAppLogInfoSerializer()).serialize(value.linkedApps),
                "linked_devices": try ArraySerializer(TeamLog.LinkedDeviceLogInfoSerializer()).serialize(value.linkedDevices),
                "linked_shared_folders": try ArraySerializer(TeamLog.FolderLogInfoSerializer()).serialize(value.linkedSharedFolders),
                "was_linked_apps_truncated": try NullableSerializer(Serialization._BoolSerializer).serialize(value.wasLinkedAppsTruncated),
                "was_linked_devices_truncated": try NullableSerializer(Serialization._BoolSerializer).serialize(value.wasLinkedDevicesTruncated),
                "was_linked_shared_folders_truncated": try NullableSerializer(Serialization._BoolSerializer).serialize(value.wasLinkedSharedFoldersTruncated),
                "has_linked_apps": try NullableSerializer(Serialization._BoolSerializer).serialize(value.hasLinkedApps),
                "has_linked_devices": try NullableSerializer(Serialization._BoolSerializer).serialize(value.hasLinkedDevices),
                "has_linked_shared_folders": try NullableSerializer(Serialization._BoolSerializer).serialize(value.hasLinkedSharedFolders),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> JoinTeamDetails {
            switch json {
            case .dictionary(let dict):
                let linkedApps = try ArraySerializer(TeamLog.UserLinkedAppLogInfoSerializer()).deserialize(dict["linked_apps"] ?? .null)
                let linkedDevices = try ArraySerializer(TeamLog.LinkedDeviceLogInfoSerializer()).deserialize(dict["linked_devices"] ?? .null)
                let linkedSharedFolders = try ArraySerializer(TeamLog.FolderLogInfoSerializer()).deserialize(dict["linked_shared_folders"] ?? .null)
                let wasLinkedAppsTruncated = try NullableSerializer(Serialization._BoolSerializer).deserialize(dict["was_linked_apps_truncated"] ?? .null)
                let wasLinkedDevicesTruncated = try NullableSerializer(Serialization._BoolSerializer)
                    .deserialize(dict["was_linked_devices_truncated"] ?? .null)
                let wasLinkedSharedFoldersTruncated = try NullableSerializer(Serialization._BoolSerializer)
                    .deserialize(dict["was_linked_shared_folders_truncated"] ?? .null)
                let hasLinkedApps = try NullableSerializer(Serialization._BoolSerializer).deserialize(dict["has_linked_apps"] ?? .null)
                let hasLinkedDevices = try NullableSerializer(Serialization._BoolSerializer).deserialize(dict["has_linked_devices"] ?? .null)
                let hasLinkedSharedFolders = try NullableSerializer(Serialization._BoolSerializer).deserialize(dict["has_linked_shared_folders"] ?? .null)
                return JoinTeamDetails(
                    linkedApps: linkedApps,
                    linkedDevices: linkedDevices,
                    linkedSharedFolders: linkedSharedFolders,
                    wasLinkedAppsTruncated: wasLinkedAppsTruncated,
                    wasLinkedDevicesTruncated: wasLinkedDevicesTruncated,
                    wasLinkedSharedFoldersTruncated: wasLinkedSharedFoldersTruncated,
                    hasLinkedApps: hasLinkedApps,
                    hasLinkedDevices: hasLinkedDevices,
                    hasLinkedSharedFolders: hasLinkedSharedFolders
                )
            default:
                throw JSONSerializerError.deserializeError(type: JoinTeamDetails.self, json: json)
            }
        }
    }

    /// Label type
    public enum LabelType: CustomStringConvertible, JSONRepresentable {
        /// An unspecified error.
        case personalInformation
        /// An unspecified error.
        case testOnly
        /// An unspecified error.
        case userDefinedTag
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try LabelTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try LabelTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for LabelType: \(error)"
            }
        }
    }

    public class LabelTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: LabelType) throws -> JSON {
            switch value {
            case .personalInformation:
                var d = [String: JSON]()
                d[".tag"] = .str("personal_information")
                return .dictionary(d)
            case .testOnly:
                var d = [String: JSON]()
                d[".tag"] = .str("test_only")
                return .dictionary(d)
            case .userDefinedTag:
                var d = [String: JSON]()
                d[".tag"] = .str("user_defined_tag")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> LabelType {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "personal_information":
                    return LabelType.personalInformation
                case "test_only":
                    return LabelType.testOnly
                case "user_defined_tag":
                    return LabelType.userDefinedTag
                case "other":
                    return LabelType.other
                default:
                    return LabelType.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: LabelType.self, json: json)
            }
        }
    }

    /// Information on sessions, in legacy format
    public class LegacyDeviceSessionLogInfo: TeamLog.DeviceSessionLogInfo {
        /// Session unique id.
        public let sessionInfo: TeamLog.SessionLogInfo?
        /// The device name. Might be missing due to historical data gap.
        public let displayName: String?
        /// Is device managed by emm. Might be missing due to historical data gap.
        public let isEmmManaged: Bool?
        /// Information on the hosting platform. Might be missing due to historical data gap.
        public let platform: String?
        /// The mac address of the last activity from this session. Might be missing due to historical data gap.
        public let macAddress: String?
        /// The hosting OS version. Might be missing due to historical data gap.
        public let osVersion: String?
        /// Information on the hosting device type. Might be missing due to historical data gap.
        public let deviceType: String?
        /// The Dropbox client version. Might be missing due to historical data gap.
        public let clientVersion: String?
        /// Alternative unique device session id, instead of session id field. Might be missing due to historical data
        /// gap.
        public let legacyUniqId: String?
        public init(
            ipAddress: String? = nil,
            created: Date? = nil,
            updated: Date? = nil,
            sessionInfo: TeamLog.SessionLogInfo? = nil,
            displayName: String? = nil,
            isEmmManaged: Bool? = nil,
            platform: String? = nil,
            macAddress: String? = nil,
            osVersion: String? = nil,
            deviceType: String? = nil,
            clientVersion: String? = nil,
            legacyUniqId: String? = nil
        ) {
            self.sessionInfo = sessionInfo
            nullableValidator(stringValidator())(displayName)
            self.displayName = displayName
            self.isEmmManaged = isEmmManaged
            nullableValidator(stringValidator())(platform)
            self.platform = platform
            nullableValidator(stringValidator())(macAddress)
            self.macAddress = macAddress
            nullableValidator(stringValidator())(osVersion)
            self.osVersion = osVersion
            nullableValidator(stringValidator())(deviceType)
            self.deviceType = deviceType
            nullableValidator(stringValidator())(clientVersion)
            self.clientVersion = clientVersion
            nullableValidator(stringValidator())(legacyUniqId)
            self.legacyUniqId = legacyUniqId
            super.init(ipAddress: ipAddress, created: created, updated: updated)
        }

        public override var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try LegacyDeviceSessionLogInfoSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for LegacyDeviceSessionLogInfo: \(error)"
            }
        }
    }

    public class LegacyDeviceSessionLogInfoSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: LegacyDeviceSessionLogInfo) throws -> JSON {
            let output = [
                "ip_address": try NullableSerializer(Serialization._StringSerializer).serialize(value.ipAddress),
                "created": try NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.created),
                "updated": try NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.updated),
                "session_info": try NullableSerializer(TeamLog.SessionLogInfoSerializer()).serialize(value.sessionInfo),
                "display_name": try NullableSerializer(Serialization._StringSerializer).serialize(value.displayName),
                "is_emm_managed": try NullableSerializer(Serialization._BoolSerializer).serialize(value.isEmmManaged),
                "platform": try NullableSerializer(Serialization._StringSerializer).serialize(value.platform),
                "mac_address": try NullableSerializer(Serialization._StringSerializer).serialize(value.macAddress),
                "os_version": try NullableSerializer(Serialization._StringSerializer).serialize(value.osVersion),
                "device_type": try NullableSerializer(Serialization._StringSerializer).serialize(value.deviceType),
                "client_version": try NullableSerializer(Serialization._StringSerializer).serialize(value.clientVersion),
                "legacy_uniq_id": try NullableSerializer(Serialization._StringSerializer).serialize(value.legacyUniqId),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> LegacyDeviceSessionLogInfo {
            switch json {
            case .dictionary(let dict):
                let ipAddress = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["ip_address"] ?? .null)
                let created = try NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).deserialize(dict["created"] ?? .null)
                let updated = try NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).deserialize(dict["updated"] ?? .null)
                let sessionInfo = try NullableSerializer(TeamLog.SessionLogInfoSerializer()).deserialize(dict["session_info"] ?? .null)
                let displayName = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["display_name"] ?? .null)
                let isEmmManaged = try NullableSerializer(Serialization._BoolSerializer).deserialize(dict["is_emm_managed"] ?? .null)
                let platform = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["platform"] ?? .null)
                let macAddress = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["mac_address"] ?? .null)
                let osVersion = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["os_version"] ?? .null)
                let deviceType = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["device_type"] ?? .null)
                let clientVersion = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["client_version"] ?? .null)
                let legacyUniqId = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["legacy_uniq_id"] ?? .null)
                return LegacyDeviceSessionLogInfo(
                    ipAddress: ipAddress,
                    created: created,
                    updated: updated,
                    sessionInfo: sessionInfo,
                    displayName: displayName,
                    isEmmManaged: isEmmManaged,
                    platform: platform,
                    macAddress: macAddress,
                    osVersion: osVersion,
                    deviceType: deviceType,
                    clientVersion: clientVersion,
                    legacyUniqId: legacyUniqId
                )
            default:
                throw JSONSerializerError.deserializeError(type: LegacyDeviceSessionLogInfo.self, json: json)
            }
        }
    }

    /// Activated a hold.
    public class LegalHoldsActivateAHoldDetails: CustomStringConvertible, JSONRepresentable {
        /// Hold ID.
        public let legalHoldId: String
        /// Hold name.
        public let name: String
        /// Hold start date.
        public let startDate: Date
        /// Hold end date.
        public let endDate: Date?
        public init(legalHoldId: String, name: String, startDate: Date, endDate: Date? = nil) {
            stringValidator()(legalHoldId)
            self.legalHoldId = legalHoldId
            stringValidator()(name)
            self.name = name
            self.startDate = startDate
            self.endDate = endDate
        }

        func json() throws -> JSON {
            try LegalHoldsActivateAHoldDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try LegalHoldsActivateAHoldDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for LegalHoldsActivateAHoldDetails: \(error)"
            }
        }
    }

    public class LegalHoldsActivateAHoldDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: LegalHoldsActivateAHoldDetails) throws -> JSON {
            let output = [
                "legal_hold_id": try Serialization._StringSerializer.serialize(value.legalHoldId),
                "name": try Serialization._StringSerializer.serialize(value.name),
                "start_date": try NSDateSerializer("%Y-%m-%dT%H:%M:%SZ").serialize(value.startDate),
                "end_date": try NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.endDate),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> LegalHoldsActivateAHoldDetails {
            switch json {
            case .dictionary(let dict):
                let legalHoldId = try Serialization._StringSerializer.deserialize(dict["legal_hold_id"] ?? .null)
                let name = try Serialization._StringSerializer.deserialize(dict["name"] ?? .null)
                let startDate = try NSDateSerializer("%Y-%m-%dT%H:%M:%SZ").deserialize(dict["start_date"] ?? .null)
                let endDate = try NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).deserialize(dict["end_date"] ?? .null)
                return LegalHoldsActivateAHoldDetails(legalHoldId: legalHoldId, name: name, startDate: startDate, endDate: endDate)
            default:
                throw JSONSerializerError.deserializeError(type: LegalHoldsActivateAHoldDetails.self, json: json)
            }
        }
    }

    /// The LegalHoldsActivateAHoldType struct
    public class LegalHoldsActivateAHoldType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try LegalHoldsActivateAHoldTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try LegalHoldsActivateAHoldTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for LegalHoldsActivateAHoldType: \(error)"
            }
        }
    }

    public class LegalHoldsActivateAHoldTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: LegalHoldsActivateAHoldType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> LegalHoldsActivateAHoldType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return LegalHoldsActivateAHoldType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: LegalHoldsActivateAHoldType.self, json: json)
            }
        }
    }

    /// Added members to a hold.
    public class LegalHoldsAddMembersDetails: CustomStringConvertible, JSONRepresentable {
        /// Hold ID.
        public let legalHoldId: String
        /// Hold name.
        public let name: String
        public init(legalHoldId: String, name: String) {
            stringValidator()(legalHoldId)
            self.legalHoldId = legalHoldId
            stringValidator()(name)
            self.name = name
        }

        func json() throws -> JSON {
            try LegalHoldsAddMembersDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try LegalHoldsAddMembersDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for LegalHoldsAddMembersDetails: \(error)"
            }
        }
    }

    public class LegalHoldsAddMembersDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: LegalHoldsAddMembersDetails) throws -> JSON {
            let output = [
                "legal_hold_id": try Serialization._StringSerializer.serialize(value.legalHoldId),
                "name": try Serialization._StringSerializer.serialize(value.name),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> LegalHoldsAddMembersDetails {
            switch json {
            case .dictionary(let dict):
                let legalHoldId = try Serialization._StringSerializer.deserialize(dict["legal_hold_id"] ?? .null)
                let name = try Serialization._StringSerializer.deserialize(dict["name"] ?? .null)
                return LegalHoldsAddMembersDetails(legalHoldId: legalHoldId, name: name)
            default:
                throw JSONSerializerError.deserializeError(type: LegalHoldsAddMembersDetails.self, json: json)
            }
        }
    }

    /// The LegalHoldsAddMembersType struct
    public class LegalHoldsAddMembersType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try LegalHoldsAddMembersTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try LegalHoldsAddMembersTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for LegalHoldsAddMembersType: \(error)"
            }
        }
    }

    public class LegalHoldsAddMembersTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: LegalHoldsAddMembersType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> LegalHoldsAddMembersType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return LegalHoldsAddMembersType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: LegalHoldsAddMembersType.self, json: json)
            }
        }
    }

    /// Edited details for a hold.
    public class LegalHoldsChangeHoldDetailsDetails: CustomStringConvertible, JSONRepresentable {
        /// Hold ID.
        public let legalHoldId: String
        /// Hold name.
        public let name: String
        /// Previous details.
        public let previousValue: String
        /// New details.
        public let newValue: String
        public init(legalHoldId: String, name: String, previousValue: String, newValue: String) {
            stringValidator()(legalHoldId)
            self.legalHoldId = legalHoldId
            stringValidator()(name)
            self.name = name
            stringValidator()(previousValue)
            self.previousValue = previousValue
            stringValidator()(newValue)
            self.newValue = newValue
        }

        func json() throws -> JSON {
            try LegalHoldsChangeHoldDetailsDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try LegalHoldsChangeHoldDetailsDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for LegalHoldsChangeHoldDetailsDetails: \(error)"
            }
        }
    }

    public class LegalHoldsChangeHoldDetailsDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: LegalHoldsChangeHoldDetailsDetails) throws -> JSON {
            let output = [
                "legal_hold_id": try Serialization._StringSerializer.serialize(value.legalHoldId),
                "name": try Serialization._StringSerializer.serialize(value.name),
                "previous_value": try Serialization._StringSerializer.serialize(value.previousValue),
                "new_value": try Serialization._StringSerializer.serialize(value.newValue),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> LegalHoldsChangeHoldDetailsDetails {
            switch json {
            case .dictionary(let dict):
                let legalHoldId = try Serialization._StringSerializer.deserialize(dict["legal_hold_id"] ?? .null)
                let name = try Serialization._StringSerializer.deserialize(dict["name"] ?? .null)
                let previousValue = try Serialization._StringSerializer.deserialize(dict["previous_value"] ?? .null)
                let newValue = try Serialization._StringSerializer.deserialize(dict["new_value"] ?? .null)
                return LegalHoldsChangeHoldDetailsDetails(legalHoldId: legalHoldId, name: name, previousValue: previousValue, newValue: newValue)
            default:
                throw JSONSerializerError.deserializeError(type: LegalHoldsChangeHoldDetailsDetails.self, json: json)
            }
        }
    }

    /// The LegalHoldsChangeHoldDetailsType struct
    public class LegalHoldsChangeHoldDetailsType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try LegalHoldsChangeHoldDetailsTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try LegalHoldsChangeHoldDetailsTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for LegalHoldsChangeHoldDetailsType: \(error)"
            }
        }
    }

    public class LegalHoldsChangeHoldDetailsTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: LegalHoldsChangeHoldDetailsType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> LegalHoldsChangeHoldDetailsType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return LegalHoldsChangeHoldDetailsType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: LegalHoldsChangeHoldDetailsType.self, json: json)
            }
        }
    }

    /// Renamed a hold.
    public class LegalHoldsChangeHoldNameDetails: CustomStringConvertible, JSONRepresentable {
        /// Hold ID.
        public let legalHoldId: String
        /// Previous Name.
        public let previousValue: String
        /// New Name.
        public let newValue: String
        public init(legalHoldId: String, previousValue: String, newValue: String) {
            stringValidator()(legalHoldId)
            self.legalHoldId = legalHoldId
            stringValidator()(previousValue)
            self.previousValue = previousValue
            stringValidator()(newValue)
            self.newValue = newValue
        }

        func json() throws -> JSON {
            try LegalHoldsChangeHoldNameDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try LegalHoldsChangeHoldNameDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for LegalHoldsChangeHoldNameDetails: \(error)"
            }
        }
    }

    public class LegalHoldsChangeHoldNameDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: LegalHoldsChangeHoldNameDetails) throws -> JSON {
            let output = [
                "legal_hold_id": try Serialization._StringSerializer.serialize(value.legalHoldId),
                "previous_value": try Serialization._StringSerializer.serialize(value.previousValue),
                "new_value": try Serialization._StringSerializer.serialize(value.newValue),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> LegalHoldsChangeHoldNameDetails {
            switch json {
            case .dictionary(let dict):
                let legalHoldId = try Serialization._StringSerializer.deserialize(dict["legal_hold_id"] ?? .null)
                let previousValue = try Serialization._StringSerializer.deserialize(dict["previous_value"] ?? .null)
                let newValue = try Serialization._StringSerializer.deserialize(dict["new_value"] ?? .null)
                return LegalHoldsChangeHoldNameDetails(legalHoldId: legalHoldId, previousValue: previousValue, newValue: newValue)
            default:
                throw JSONSerializerError.deserializeError(type: LegalHoldsChangeHoldNameDetails.self, json: json)
            }
        }
    }

    /// The LegalHoldsChangeHoldNameType struct
    public class LegalHoldsChangeHoldNameType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try LegalHoldsChangeHoldNameTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try LegalHoldsChangeHoldNameTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for LegalHoldsChangeHoldNameType: \(error)"
            }
        }
    }

    public class LegalHoldsChangeHoldNameTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: LegalHoldsChangeHoldNameType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> LegalHoldsChangeHoldNameType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return LegalHoldsChangeHoldNameType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: LegalHoldsChangeHoldNameType.self, json: json)
            }
        }
    }

    /// Exported hold.
    public class LegalHoldsExportAHoldDetails: CustomStringConvertible, JSONRepresentable {
        /// Hold ID.
        public let legalHoldId: String
        /// Hold name.
        public let name: String
        /// Export name.
        public let exportName: String?
        public init(legalHoldId: String, name: String, exportName: String? = nil) {
            stringValidator()(legalHoldId)
            self.legalHoldId = legalHoldId
            stringValidator()(name)
            self.name = name
            nullableValidator(stringValidator())(exportName)
            self.exportName = exportName
        }

        func json() throws -> JSON {
            try LegalHoldsExportAHoldDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try LegalHoldsExportAHoldDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for LegalHoldsExportAHoldDetails: \(error)"
            }
        }
    }

    public class LegalHoldsExportAHoldDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: LegalHoldsExportAHoldDetails) throws -> JSON {
            let output = [
                "legal_hold_id": try Serialization._StringSerializer.serialize(value.legalHoldId),
                "name": try Serialization._StringSerializer.serialize(value.name),
                "export_name": try NullableSerializer(Serialization._StringSerializer).serialize(value.exportName),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> LegalHoldsExportAHoldDetails {
            switch json {
            case .dictionary(let dict):
                let legalHoldId = try Serialization._StringSerializer.deserialize(dict["legal_hold_id"] ?? .null)
                let name = try Serialization._StringSerializer.deserialize(dict["name"] ?? .null)
                let exportName = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["export_name"] ?? .null)
                return LegalHoldsExportAHoldDetails(legalHoldId: legalHoldId, name: name, exportName: exportName)
            default:
                throw JSONSerializerError.deserializeError(type: LegalHoldsExportAHoldDetails.self, json: json)
            }
        }
    }

    /// The LegalHoldsExportAHoldType struct
    public class LegalHoldsExportAHoldType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try LegalHoldsExportAHoldTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try LegalHoldsExportAHoldTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for LegalHoldsExportAHoldType: \(error)"
            }
        }
    }

    public class LegalHoldsExportAHoldTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: LegalHoldsExportAHoldType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> LegalHoldsExportAHoldType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return LegalHoldsExportAHoldType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: LegalHoldsExportAHoldType.self, json: json)
            }
        }
    }

    /// Canceled export for a hold.
    public class LegalHoldsExportCancelledDetails: CustomStringConvertible, JSONRepresentable {
        /// Hold ID.
        public let legalHoldId: String
        /// Hold name.
        public let name: String
        /// Export name.
        public let exportName: String
        public init(legalHoldId: String, name: String, exportName: String) {
            stringValidator()(legalHoldId)
            self.legalHoldId = legalHoldId
            stringValidator()(name)
            self.name = name
            stringValidator()(exportName)
            self.exportName = exportName
        }

        func json() throws -> JSON {
            try LegalHoldsExportCancelledDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try LegalHoldsExportCancelledDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for LegalHoldsExportCancelledDetails: \(error)"
            }
        }
    }

    public class LegalHoldsExportCancelledDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: LegalHoldsExportCancelledDetails) throws -> JSON {
            let output = [
                "legal_hold_id": try Serialization._StringSerializer.serialize(value.legalHoldId),
                "name": try Serialization._StringSerializer.serialize(value.name),
                "export_name": try Serialization._StringSerializer.serialize(value.exportName),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> LegalHoldsExportCancelledDetails {
            switch json {
            case .dictionary(let dict):
                let legalHoldId = try Serialization._StringSerializer.deserialize(dict["legal_hold_id"] ?? .null)
                let name = try Serialization._StringSerializer.deserialize(dict["name"] ?? .null)
                let exportName = try Serialization._StringSerializer.deserialize(dict["export_name"] ?? .null)
                return LegalHoldsExportCancelledDetails(legalHoldId: legalHoldId, name: name, exportName: exportName)
            default:
                throw JSONSerializerError.deserializeError(type: LegalHoldsExportCancelledDetails.self, json: json)
            }
        }
    }

    /// The LegalHoldsExportCancelledType struct
    public class LegalHoldsExportCancelledType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try LegalHoldsExportCancelledTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try LegalHoldsExportCancelledTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for LegalHoldsExportCancelledType: \(error)"
            }
        }
    }

    public class LegalHoldsExportCancelledTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: LegalHoldsExportCancelledType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> LegalHoldsExportCancelledType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return LegalHoldsExportCancelledType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: LegalHoldsExportCancelledType.self, json: json)
            }
        }
    }

    /// Downloaded export for a hold.
    public class LegalHoldsExportDownloadedDetails: CustomStringConvertible, JSONRepresentable {
        /// Hold ID.
        public let legalHoldId: String
        /// Hold name.
        public let name: String
        /// Export name.
        public let exportName: String
        /// Part.
        public let part: String?
        /// Filename.
        public let fileName: String?
        public init(legalHoldId: String, name: String, exportName: String, part: String? = nil, fileName: String? = nil) {
            stringValidator()(legalHoldId)
            self.legalHoldId = legalHoldId
            stringValidator()(name)
            self.name = name
            stringValidator()(exportName)
            self.exportName = exportName
            nullableValidator(stringValidator())(part)
            self.part = part
            nullableValidator(stringValidator())(fileName)
            self.fileName = fileName
        }

        func json() throws -> JSON {
            try LegalHoldsExportDownloadedDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try LegalHoldsExportDownloadedDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for LegalHoldsExportDownloadedDetails: \(error)"
            }
        }
    }

    public class LegalHoldsExportDownloadedDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: LegalHoldsExportDownloadedDetails) throws -> JSON {
            let output = [
                "legal_hold_id": try Serialization._StringSerializer.serialize(value.legalHoldId),
                "name": try Serialization._StringSerializer.serialize(value.name),
                "export_name": try Serialization._StringSerializer.serialize(value.exportName),
                "part": try NullableSerializer(Serialization._StringSerializer).serialize(value.part),
                "file_name": try NullableSerializer(Serialization._StringSerializer).serialize(value.fileName),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> LegalHoldsExportDownloadedDetails {
            switch json {
            case .dictionary(let dict):
                let legalHoldId = try Serialization._StringSerializer.deserialize(dict["legal_hold_id"] ?? .null)
                let name = try Serialization._StringSerializer.deserialize(dict["name"] ?? .null)
                let exportName = try Serialization._StringSerializer.deserialize(dict["export_name"] ?? .null)
                let part = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["part"] ?? .null)
                let fileName = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["file_name"] ?? .null)
                return LegalHoldsExportDownloadedDetails(legalHoldId: legalHoldId, name: name, exportName: exportName, part: part, fileName: fileName)
            default:
                throw JSONSerializerError.deserializeError(type: LegalHoldsExportDownloadedDetails.self, json: json)
            }
        }
    }

    /// The LegalHoldsExportDownloadedType struct
    public class LegalHoldsExportDownloadedType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try LegalHoldsExportDownloadedTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try LegalHoldsExportDownloadedTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for LegalHoldsExportDownloadedType: \(error)"
            }
        }
    }

    public class LegalHoldsExportDownloadedTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: LegalHoldsExportDownloadedType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> LegalHoldsExportDownloadedType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return LegalHoldsExportDownloadedType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: LegalHoldsExportDownloadedType.self, json: json)
            }
        }
    }

    /// Removed export for a hold.
    public class LegalHoldsExportRemovedDetails: CustomStringConvertible, JSONRepresentable {
        /// Hold ID.
        public let legalHoldId: String
        /// Hold name.
        public let name: String
        /// Export name.
        public let exportName: String
        public init(legalHoldId: String, name: String, exportName: String) {
            stringValidator()(legalHoldId)
            self.legalHoldId = legalHoldId
            stringValidator()(name)
            self.name = name
            stringValidator()(exportName)
            self.exportName = exportName
        }

        func json() throws -> JSON {
            try LegalHoldsExportRemovedDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try LegalHoldsExportRemovedDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for LegalHoldsExportRemovedDetails: \(error)"
            }
        }
    }

    public class LegalHoldsExportRemovedDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: LegalHoldsExportRemovedDetails) throws -> JSON {
            let output = [
                "legal_hold_id": try Serialization._StringSerializer.serialize(value.legalHoldId),
                "name": try Serialization._StringSerializer.serialize(value.name),
                "export_name": try Serialization._StringSerializer.serialize(value.exportName),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> LegalHoldsExportRemovedDetails {
            switch json {
            case .dictionary(let dict):
                let legalHoldId = try Serialization._StringSerializer.deserialize(dict["legal_hold_id"] ?? .null)
                let name = try Serialization._StringSerializer.deserialize(dict["name"] ?? .null)
                let exportName = try Serialization._StringSerializer.deserialize(dict["export_name"] ?? .null)
                return LegalHoldsExportRemovedDetails(legalHoldId: legalHoldId, name: name, exportName: exportName)
            default:
                throw JSONSerializerError.deserializeError(type: LegalHoldsExportRemovedDetails.self, json: json)
            }
        }
    }

    /// The LegalHoldsExportRemovedType struct
    public class LegalHoldsExportRemovedType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try LegalHoldsExportRemovedTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try LegalHoldsExportRemovedTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for LegalHoldsExportRemovedType: \(error)"
            }
        }
    }

    public class LegalHoldsExportRemovedTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: LegalHoldsExportRemovedType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> LegalHoldsExportRemovedType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return LegalHoldsExportRemovedType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: LegalHoldsExportRemovedType.self, json: json)
            }
        }
    }

    /// Released a hold.
    public class LegalHoldsReleaseAHoldDetails: CustomStringConvertible, JSONRepresentable {
        /// Hold ID.
        public let legalHoldId: String
        /// Hold name.
        public let name: String
        public init(legalHoldId: String, name: String) {
            stringValidator()(legalHoldId)
            self.legalHoldId = legalHoldId
            stringValidator()(name)
            self.name = name
        }

        func json() throws -> JSON {
            try LegalHoldsReleaseAHoldDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try LegalHoldsReleaseAHoldDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for LegalHoldsReleaseAHoldDetails: \(error)"
            }
        }
    }

    public class LegalHoldsReleaseAHoldDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: LegalHoldsReleaseAHoldDetails) throws -> JSON {
            let output = [
                "legal_hold_id": try Serialization._StringSerializer.serialize(value.legalHoldId),
                "name": try Serialization._StringSerializer.serialize(value.name),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> LegalHoldsReleaseAHoldDetails {
            switch json {
            case .dictionary(let dict):
                let legalHoldId = try Serialization._StringSerializer.deserialize(dict["legal_hold_id"] ?? .null)
                let name = try Serialization._StringSerializer.deserialize(dict["name"] ?? .null)
                return LegalHoldsReleaseAHoldDetails(legalHoldId: legalHoldId, name: name)
            default:
                throw JSONSerializerError.deserializeError(type: LegalHoldsReleaseAHoldDetails.self, json: json)
            }
        }
    }

    /// The LegalHoldsReleaseAHoldType struct
    public class LegalHoldsReleaseAHoldType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try LegalHoldsReleaseAHoldTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try LegalHoldsReleaseAHoldTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for LegalHoldsReleaseAHoldType: \(error)"
            }
        }
    }

    public class LegalHoldsReleaseAHoldTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: LegalHoldsReleaseAHoldType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> LegalHoldsReleaseAHoldType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return LegalHoldsReleaseAHoldType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: LegalHoldsReleaseAHoldType.self, json: json)
            }
        }
    }

    /// Removed members from a hold.
    public class LegalHoldsRemoveMembersDetails: CustomStringConvertible, JSONRepresentable {
        /// Hold ID.
        public let legalHoldId: String
        /// Hold name.
        public let name: String
        public init(legalHoldId: String, name: String) {
            stringValidator()(legalHoldId)
            self.legalHoldId = legalHoldId
            stringValidator()(name)
            self.name = name
        }

        func json() throws -> JSON {
            try LegalHoldsRemoveMembersDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try LegalHoldsRemoveMembersDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for LegalHoldsRemoveMembersDetails: \(error)"
            }
        }
    }

    public class LegalHoldsRemoveMembersDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: LegalHoldsRemoveMembersDetails) throws -> JSON {
            let output = [
                "legal_hold_id": try Serialization._StringSerializer.serialize(value.legalHoldId),
                "name": try Serialization._StringSerializer.serialize(value.name),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> LegalHoldsRemoveMembersDetails {
            switch json {
            case .dictionary(let dict):
                let legalHoldId = try Serialization._StringSerializer.deserialize(dict["legal_hold_id"] ?? .null)
                let name = try Serialization._StringSerializer.deserialize(dict["name"] ?? .null)
                return LegalHoldsRemoveMembersDetails(legalHoldId: legalHoldId, name: name)
            default:
                throw JSONSerializerError.deserializeError(type: LegalHoldsRemoveMembersDetails.self, json: json)
            }
        }
    }

    /// The LegalHoldsRemoveMembersType struct
    public class LegalHoldsRemoveMembersType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try LegalHoldsRemoveMembersTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try LegalHoldsRemoveMembersTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for LegalHoldsRemoveMembersType: \(error)"
            }
        }
    }

    public class LegalHoldsRemoveMembersTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: LegalHoldsRemoveMembersType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> LegalHoldsRemoveMembersType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return LegalHoldsRemoveMembersType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: LegalHoldsRemoveMembersType.self, json: json)
            }
        }
    }

    /// Created a summary report for a hold.
    public class LegalHoldsReportAHoldDetails: CustomStringConvertible, JSONRepresentable {
        /// Hold ID.
        public let legalHoldId: String
        /// Hold name.
        public let name: String
        public init(legalHoldId: String, name: String) {
            stringValidator()(legalHoldId)
            self.legalHoldId = legalHoldId
            stringValidator()(name)
            self.name = name
        }

        func json() throws -> JSON {
            try LegalHoldsReportAHoldDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try LegalHoldsReportAHoldDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for LegalHoldsReportAHoldDetails: \(error)"
            }
        }
    }

    public class LegalHoldsReportAHoldDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: LegalHoldsReportAHoldDetails) throws -> JSON {
            let output = [
                "legal_hold_id": try Serialization._StringSerializer.serialize(value.legalHoldId),
                "name": try Serialization._StringSerializer.serialize(value.name),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> LegalHoldsReportAHoldDetails {
            switch json {
            case .dictionary(let dict):
                let legalHoldId = try Serialization._StringSerializer.deserialize(dict["legal_hold_id"] ?? .null)
                let name = try Serialization._StringSerializer.deserialize(dict["name"] ?? .null)
                return LegalHoldsReportAHoldDetails(legalHoldId: legalHoldId, name: name)
            default:
                throw JSONSerializerError.deserializeError(type: LegalHoldsReportAHoldDetails.self, json: json)
            }
        }
    }

    /// The LegalHoldsReportAHoldType struct
    public class LegalHoldsReportAHoldType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try LegalHoldsReportAHoldTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try LegalHoldsReportAHoldTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for LegalHoldsReportAHoldType: \(error)"
            }
        }
    }

    public class LegalHoldsReportAHoldTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: LegalHoldsReportAHoldType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> LegalHoldsReportAHoldType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return LegalHoldsReportAHoldType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: LegalHoldsReportAHoldType.self, json: json)
            }
        }
    }

    /// The device sessions that user is linked to.
    public enum LinkedDeviceLogInfo: CustomStringConvertible, JSONRepresentable {
        /// desktop device session's details.
        case desktopDeviceSession(TeamLog.DesktopDeviceSessionLogInfo)
        /// legacy device session's details.
        case legacyDeviceSession(TeamLog.LegacyDeviceSessionLogInfo)
        /// mobile device session's details.
        case mobileDeviceSession(TeamLog.MobileDeviceSessionLogInfo)
        /// web device session's details.
        case webDeviceSession(TeamLog.WebDeviceSessionLogInfo)
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try LinkedDeviceLogInfoSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try LinkedDeviceLogInfoSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for LinkedDeviceLogInfo: \(error)"
            }
        }
    }

    public class LinkedDeviceLogInfoSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: LinkedDeviceLogInfo) throws -> JSON {
            switch value {
            case .desktopDeviceSession(let arg):
                var d = try Serialization.getFields(TeamLog.DesktopDeviceSessionLogInfoSerializer().serialize(arg))
                d[".tag"] = .str("desktop_device_session")
                return .dictionary(d)
            case .legacyDeviceSession(let arg):
                var d = try Serialization.getFields(TeamLog.LegacyDeviceSessionLogInfoSerializer().serialize(arg))
                d[".tag"] = .str("legacy_device_session")
                return .dictionary(d)
            case .mobileDeviceSession(let arg):
                var d = try Serialization.getFields(TeamLog.MobileDeviceSessionLogInfoSerializer().serialize(arg))
                d[".tag"] = .str("mobile_device_session")
                return .dictionary(d)
            case .webDeviceSession(let arg):
                var d = try Serialization.getFields(TeamLog.WebDeviceSessionLogInfoSerializer().serialize(arg))
                d[".tag"] = .str("web_device_session")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> LinkedDeviceLogInfo {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "desktop_device_session":
                    let v = try TeamLog.DesktopDeviceSessionLogInfoSerializer().deserialize(json)
                    return LinkedDeviceLogInfo.desktopDeviceSession(v)
                case "legacy_device_session":
                    let v = try TeamLog.LegacyDeviceSessionLogInfoSerializer().deserialize(json)
                    return LinkedDeviceLogInfo.legacyDeviceSession(v)
                case "mobile_device_session":
                    let v = try TeamLog.MobileDeviceSessionLogInfoSerializer().deserialize(json)
                    return LinkedDeviceLogInfo.mobileDeviceSession(v)
                case "web_device_session":
                    let v = try TeamLog.WebDeviceSessionLogInfoSerializer().deserialize(json)
                    return LinkedDeviceLogInfo.webDeviceSession(v)
                case "other":
                    return LinkedDeviceLogInfo.other
                default:
                    return LinkedDeviceLogInfo.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: LinkedDeviceLogInfo.self, json: json)
            }
        }
    }

    /// File lock status
    public enum LockStatus: CustomStringConvertible, JSONRepresentable {
        /// An unspecified error.
        case locked
        /// An unspecified error.
        case unlocked
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try LockStatusSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try LockStatusSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for LockStatus: \(error)"
            }
        }
    }

    public class LockStatusSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: LockStatus) throws -> JSON {
            switch value {
            case .locked:
                var d = [String: JSON]()
                d[".tag"] = .str("locked")
                return .dictionary(d)
            case .unlocked:
                var d = [String: JSON]()
                d[".tag"] = .str("unlocked")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> LockStatus {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "locked":
                    return LockStatus.locked
                case "unlocked":
                    return LockStatus.unlocked
                case "other":
                    return LockStatus.other
                default:
                    return LockStatus.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: LockStatus.self, json: json)
            }
        }
    }

    /// Failed to sign in.
    public class LoginFailDetails: CustomStringConvertible, JSONRepresentable {
        /// Tells if the login device is EMM managed. Might be missing due to historical data gap.
        public let isEmmManaged: Bool?
        /// Login method.
        public let loginMethod: TeamLog.LoginMethod
        /// Error details.
        public let errorDetails: TeamLog.FailureDetailsLogInfo
        public init(loginMethod: TeamLog.LoginMethod, errorDetails: TeamLog.FailureDetailsLogInfo, isEmmManaged: Bool? = nil) {
            self.isEmmManaged = isEmmManaged
            self.loginMethod = loginMethod
            self.errorDetails = errorDetails
        }

        func json() throws -> JSON {
            try LoginFailDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try LoginFailDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for LoginFailDetails: \(error)"
            }
        }
    }

    public class LoginFailDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: LoginFailDetails) throws -> JSON {
            let output = [
                "login_method": try TeamLog.LoginMethodSerializer().serialize(value.loginMethod),
                "error_details": try TeamLog.FailureDetailsLogInfoSerializer().serialize(value.errorDetails),
                "is_emm_managed": try NullableSerializer(Serialization._BoolSerializer).serialize(value.isEmmManaged),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> LoginFailDetails {
            switch json {
            case .dictionary(let dict):
                let loginMethod = try TeamLog.LoginMethodSerializer().deserialize(dict["login_method"] ?? .null)
                let errorDetails = try TeamLog.FailureDetailsLogInfoSerializer().deserialize(dict["error_details"] ?? .null)
                let isEmmManaged = try NullableSerializer(Serialization._BoolSerializer).deserialize(dict["is_emm_managed"] ?? .null)
                return LoginFailDetails(loginMethod: loginMethod, errorDetails: errorDetails, isEmmManaged: isEmmManaged)
            default:
                throw JSONSerializerError.deserializeError(type: LoginFailDetails.self, json: json)
            }
        }
    }

    /// The LoginFailType struct
    public class LoginFailType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try LoginFailTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try LoginFailTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for LoginFailType: \(error)"
            }
        }
    }

    public class LoginFailTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: LoginFailType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> LoginFailType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return LoginFailType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: LoginFailType.self, json: json)
            }
        }
    }

    /// The LoginMethod union
    public enum LoginMethod: CustomStringConvertible, JSONRepresentable {
        /// An unspecified error.
        case appleOauth
        /// An unspecified error.
        case firstPartyTokenExchange
        /// An unspecified error.
        case googleOauth
        /// An unspecified error.
        case lenovoOauth
        /// An unspecified error.
        case password
        /// An unspecified error.
        case qrCode
        /// An unspecified error.
        case saml
        /// An unspecified error.
        case twoFactorAuthentication
        /// An unspecified error.
        case webSession
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try LoginMethodSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try LoginMethodSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for LoginMethod: \(error)"
            }
        }
    }

    public class LoginMethodSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: LoginMethod) throws -> JSON {
            switch value {
            case .appleOauth:
                var d = [String: JSON]()
                d[".tag"] = .str("apple_oauth")
                return .dictionary(d)
            case .firstPartyTokenExchange:
                var d = [String: JSON]()
                d[".tag"] = .str("first_party_token_exchange")
                return .dictionary(d)
            case .googleOauth:
                var d = [String: JSON]()
                d[".tag"] = .str("google_oauth")
                return .dictionary(d)
            case .lenovoOauth:
                var d = [String: JSON]()
                d[".tag"] = .str("lenovo_oauth")
                return .dictionary(d)
            case .password:
                var d = [String: JSON]()
                d[".tag"] = .str("password")
                return .dictionary(d)
            case .qrCode:
                var d = [String: JSON]()
                d[".tag"] = .str("qr_code")
                return .dictionary(d)
            case .saml:
                var d = [String: JSON]()
                d[".tag"] = .str("saml")
                return .dictionary(d)
            case .twoFactorAuthentication:
                var d = [String: JSON]()
                d[".tag"] = .str("two_factor_authentication")
                return .dictionary(d)
            case .webSession:
                var d = [String: JSON]()
                d[".tag"] = .str("web_session")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> LoginMethod {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "apple_oauth":
                    return LoginMethod.appleOauth
                case "first_party_token_exchange":
                    return LoginMethod.firstPartyTokenExchange
                case "google_oauth":
                    return LoginMethod.googleOauth
                case "lenovo_oauth":
                    return LoginMethod.lenovoOauth
                case "password":
                    return LoginMethod.password
                case "qr_code":
                    return LoginMethod.qrCode
                case "saml":
                    return LoginMethod.saml
                case "two_factor_authentication":
                    return LoginMethod.twoFactorAuthentication
                case "web_session":
                    return LoginMethod.webSession
                case "other":
                    return LoginMethod.other
                default:
                    return LoginMethod.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: LoginMethod.self, json: json)
            }
        }
    }

    /// Signed in.
    public class LoginSuccessDetails: CustomStringConvertible, JSONRepresentable {
        /// Tells if the login device is EMM managed. Might be missing due to historical data gap.
        public let isEmmManaged: Bool?
        /// Login method.
        public let loginMethod: TeamLog.LoginMethod
        public init(loginMethod: TeamLog.LoginMethod, isEmmManaged: Bool? = nil) {
            self.isEmmManaged = isEmmManaged
            self.loginMethod = loginMethod
        }

        func json() throws -> JSON {
            try LoginSuccessDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try LoginSuccessDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for LoginSuccessDetails: \(error)"
            }
        }
    }

    public class LoginSuccessDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: LoginSuccessDetails) throws -> JSON {
            let output = [
                "login_method": try TeamLog.LoginMethodSerializer().serialize(value.loginMethod),
                "is_emm_managed": try NullableSerializer(Serialization._BoolSerializer).serialize(value.isEmmManaged),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> LoginSuccessDetails {
            switch json {
            case .dictionary(let dict):
                let loginMethod = try TeamLog.LoginMethodSerializer().deserialize(dict["login_method"] ?? .null)
                let isEmmManaged = try NullableSerializer(Serialization._BoolSerializer).deserialize(dict["is_emm_managed"] ?? .null)
                return LoginSuccessDetails(loginMethod: loginMethod, isEmmManaged: isEmmManaged)
            default:
                throw JSONSerializerError.deserializeError(type: LoginSuccessDetails.self, json: json)
            }
        }
    }

    /// The LoginSuccessType struct
    public class LoginSuccessType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try LoginSuccessTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try LoginSuccessTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for LoginSuccessType: \(error)"
            }
        }
    }

    public class LoginSuccessTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: LoginSuccessType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> LoginSuccessType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return LoginSuccessType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: LoginSuccessType.self, json: json)
            }
        }
    }

    /// Signed out.
    public class LogoutDetails: CustomStringConvertible, JSONRepresentable {
        /// Login session id.
        public let loginId: String?
        public init(loginId: String? = nil) {
            nullableValidator(stringValidator())(loginId)
            self.loginId = loginId
        }

        func json() throws -> JSON {
            try LogoutDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try LogoutDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for LogoutDetails: \(error)"
            }
        }
    }

    public class LogoutDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: LogoutDetails) throws -> JSON {
            let output = [
                "login_id": try NullableSerializer(Serialization._StringSerializer).serialize(value.loginId),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> LogoutDetails {
            switch json {
            case .dictionary(let dict):
                let loginId = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["login_id"] ?? .null)
                return LogoutDetails(loginId: loginId)
            default:
                throw JSONSerializerError.deserializeError(type: LogoutDetails.self, json: json)
            }
        }
    }

    /// The LogoutType struct
    public class LogoutType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try LogoutTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try LogoutTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for LogoutType: \(error)"
            }
        }
    }

    public class LogoutTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: LogoutType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> LogoutType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return LogoutType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: LogoutType.self, json: json)
            }
        }
    }

    /// Added an external ID for team member.
    public class MemberAddExternalIdDetails: CustomStringConvertible, JSONRepresentable {
        /// Current external id.
        public let newValue: String
        public init(newValue: String) {
            stringValidator(maxLength: 64)(newValue)
            self.newValue = newValue
        }

        func json() throws -> JSON {
            try MemberAddExternalIdDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try MemberAddExternalIdDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for MemberAddExternalIdDetails: \(error)"
            }
        }
    }

    public class MemberAddExternalIdDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: MemberAddExternalIdDetails) throws -> JSON {
            let output = [
                "new_value": try Serialization._StringSerializer.serialize(value.newValue),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> MemberAddExternalIdDetails {
            switch json {
            case .dictionary(let dict):
                let newValue = try Serialization._StringSerializer.deserialize(dict["new_value"] ?? .null)
                return MemberAddExternalIdDetails(newValue: newValue)
            default:
                throw JSONSerializerError.deserializeError(type: MemberAddExternalIdDetails.self, json: json)
            }
        }
    }

    /// The MemberAddExternalIdType struct
    public class MemberAddExternalIdType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try MemberAddExternalIdTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try MemberAddExternalIdTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for MemberAddExternalIdType: \(error)"
            }
        }
    }

    public class MemberAddExternalIdTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: MemberAddExternalIdType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> MemberAddExternalIdType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return MemberAddExternalIdType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: MemberAddExternalIdType.self, json: json)
            }
        }
    }

    /// Added team member name.
    public class MemberAddNameDetails: CustomStringConvertible, JSONRepresentable {
        /// New user's name.
        public let newValue: TeamLog.UserNameLogInfo
        public init(newValue: TeamLog.UserNameLogInfo) {
            self.newValue = newValue
        }

        func json() throws -> JSON {
            try MemberAddNameDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try MemberAddNameDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for MemberAddNameDetails: \(error)"
            }
        }
    }

    public class MemberAddNameDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: MemberAddNameDetails) throws -> JSON {
            let output = [
                "new_value": try TeamLog.UserNameLogInfoSerializer().serialize(value.newValue),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> MemberAddNameDetails {
            switch json {
            case .dictionary(let dict):
                let newValue = try TeamLog.UserNameLogInfoSerializer().deserialize(dict["new_value"] ?? .null)
                return MemberAddNameDetails(newValue: newValue)
            default:
                throw JSONSerializerError.deserializeError(type: MemberAddNameDetails.self, json: json)
            }
        }
    }

    /// The MemberAddNameType struct
    public class MemberAddNameType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try MemberAddNameTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try MemberAddNameTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for MemberAddNameType: \(error)"
            }
        }
    }

    public class MemberAddNameTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: MemberAddNameType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> MemberAddNameType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return MemberAddNameType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: MemberAddNameType.self, json: json)
            }
        }
    }

    /// Changed team member admin role.
    public class MemberChangeAdminRoleDetails: CustomStringConvertible, JSONRepresentable {
        /// New admin role. This field is relevant when the admin role is changed or whenthe user role changes from no
        /// admin rights to with admin rights.
        public let newValue: TeamLog.AdminRole?
        /// Previous admin role. This field is relevant when the admin role is changed or when the admin role is
        /// removed.
        public let previousValue: TeamLog.AdminRole?
        public init(newValue: TeamLog.AdminRole? = nil, previousValue: TeamLog.AdminRole? = nil) {
            self.newValue = newValue
            self.previousValue = previousValue
        }

        func json() throws -> JSON {
            try MemberChangeAdminRoleDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try MemberChangeAdminRoleDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for MemberChangeAdminRoleDetails: \(error)"
            }
        }
    }

    public class MemberChangeAdminRoleDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: MemberChangeAdminRoleDetails) throws -> JSON {
            let output = [
                "new_value": try NullableSerializer(TeamLog.AdminRoleSerializer()).serialize(value.newValue),
                "previous_value": try NullableSerializer(TeamLog.AdminRoleSerializer()).serialize(value.previousValue),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> MemberChangeAdminRoleDetails {
            switch json {
            case .dictionary(let dict):
                let newValue = try NullableSerializer(TeamLog.AdminRoleSerializer()).deserialize(dict["new_value"] ?? .null)
                let previousValue = try NullableSerializer(TeamLog.AdminRoleSerializer()).deserialize(dict["previous_value"] ?? .null)
                return MemberChangeAdminRoleDetails(newValue: newValue, previousValue: previousValue)
            default:
                throw JSONSerializerError.deserializeError(type: MemberChangeAdminRoleDetails.self, json: json)
            }
        }
    }

    /// The MemberChangeAdminRoleType struct
    public class MemberChangeAdminRoleType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try MemberChangeAdminRoleTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try MemberChangeAdminRoleTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for MemberChangeAdminRoleType: \(error)"
            }
        }
    }

    public class MemberChangeAdminRoleTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: MemberChangeAdminRoleType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> MemberChangeAdminRoleType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return MemberChangeAdminRoleType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: MemberChangeAdminRoleType.self, json: json)
            }
        }
    }

    /// Changed team member email.
    public class MemberChangeEmailDetails: CustomStringConvertible, JSONRepresentable {
        /// New email.
        public let newValue: String
        /// Previous email. Might be missing due to historical data gap.
        public let previousValue: String?
        public init(newValue: String, previousValue: String? = nil) {
            stringValidator(maxLength: 255)(newValue)
            self.newValue = newValue
            nullableValidator(stringValidator(maxLength: 255))(previousValue)
            self.previousValue = previousValue
        }

        func json() throws -> JSON {
            try MemberChangeEmailDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try MemberChangeEmailDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for MemberChangeEmailDetails: \(error)"
            }
        }
    }

    public class MemberChangeEmailDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: MemberChangeEmailDetails) throws -> JSON {
            let output = [
                "new_value": try Serialization._StringSerializer.serialize(value.newValue),
                "previous_value": try NullableSerializer(Serialization._StringSerializer).serialize(value.previousValue),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> MemberChangeEmailDetails {
            switch json {
            case .dictionary(let dict):
                let newValue = try Serialization._StringSerializer.deserialize(dict["new_value"] ?? .null)
                let previousValue = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["previous_value"] ?? .null)
                return MemberChangeEmailDetails(newValue: newValue, previousValue: previousValue)
            default:
                throw JSONSerializerError.deserializeError(type: MemberChangeEmailDetails.self, json: json)
            }
        }
    }

    /// The MemberChangeEmailType struct
    public class MemberChangeEmailType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try MemberChangeEmailTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try MemberChangeEmailTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for MemberChangeEmailType: \(error)"
            }
        }
    }

    public class MemberChangeEmailTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: MemberChangeEmailType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> MemberChangeEmailType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return MemberChangeEmailType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: MemberChangeEmailType.self, json: json)
            }
        }
    }

    /// Changed the external ID for team member.
    public class MemberChangeExternalIdDetails: CustomStringConvertible, JSONRepresentable {
        /// Current external id.
        public let newValue: String
        /// Old external id.
        public let previousValue: String
        public init(newValue: String, previousValue: String) {
            stringValidator(maxLength: 64)(newValue)
            self.newValue = newValue
            stringValidator(maxLength: 64)(previousValue)
            self.previousValue = previousValue
        }

        func json() throws -> JSON {
            try MemberChangeExternalIdDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try MemberChangeExternalIdDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for MemberChangeExternalIdDetails: \(error)"
            }
        }
    }

    public class MemberChangeExternalIdDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: MemberChangeExternalIdDetails) throws -> JSON {
            let output = [
                "new_value": try Serialization._StringSerializer.serialize(value.newValue),
                "previous_value": try Serialization._StringSerializer.serialize(value.previousValue),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> MemberChangeExternalIdDetails {
            switch json {
            case .dictionary(let dict):
                let newValue = try Serialization._StringSerializer.deserialize(dict["new_value"] ?? .null)
                let previousValue = try Serialization._StringSerializer.deserialize(dict["previous_value"] ?? .null)
                return MemberChangeExternalIdDetails(newValue: newValue, previousValue: previousValue)
            default:
                throw JSONSerializerError.deserializeError(type: MemberChangeExternalIdDetails.self, json: json)
            }
        }
    }

    /// The MemberChangeExternalIdType struct
    public class MemberChangeExternalIdType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try MemberChangeExternalIdTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try MemberChangeExternalIdTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for MemberChangeExternalIdType: \(error)"
            }
        }
    }

    public class MemberChangeExternalIdTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: MemberChangeExternalIdType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> MemberChangeExternalIdType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return MemberChangeExternalIdType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: MemberChangeExternalIdType.self, json: json)
            }
        }
    }

    /// Changed membership type (limited/full) of member.
    public class MemberChangeMembershipTypeDetails: CustomStringConvertible, JSONRepresentable {
        /// Previous membership type.
        public let prevValue: TeamLog.TeamMembershipType
        /// New membership type.
        public let newValue: TeamLog.TeamMembershipType
        public init(prevValue: TeamLog.TeamMembershipType, newValue: TeamLog.TeamMembershipType) {
            self.prevValue = prevValue
            self.newValue = newValue
        }

        func json() throws -> JSON {
            try MemberChangeMembershipTypeDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try MemberChangeMembershipTypeDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for MemberChangeMembershipTypeDetails: \(error)"
            }
        }
    }

    public class MemberChangeMembershipTypeDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: MemberChangeMembershipTypeDetails) throws -> JSON {
            let output = [
                "prev_value": try TeamLog.TeamMembershipTypeSerializer().serialize(value.prevValue),
                "new_value": try TeamLog.TeamMembershipTypeSerializer().serialize(value.newValue),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> MemberChangeMembershipTypeDetails {
            switch json {
            case .dictionary(let dict):
                let prevValue = try TeamLog.TeamMembershipTypeSerializer().deserialize(dict["prev_value"] ?? .null)
                let newValue = try TeamLog.TeamMembershipTypeSerializer().deserialize(dict["new_value"] ?? .null)
                return MemberChangeMembershipTypeDetails(prevValue: prevValue, newValue: newValue)
            default:
                throw JSONSerializerError.deserializeError(type: MemberChangeMembershipTypeDetails.self, json: json)
            }
        }
    }

    /// The MemberChangeMembershipTypeType struct
    public class MemberChangeMembershipTypeType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try MemberChangeMembershipTypeTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try MemberChangeMembershipTypeTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for MemberChangeMembershipTypeType: \(error)"
            }
        }
    }

    public class MemberChangeMembershipTypeTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: MemberChangeMembershipTypeType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> MemberChangeMembershipTypeType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return MemberChangeMembershipTypeType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: MemberChangeMembershipTypeType.self, json: json)
            }
        }
    }

    /// Changed team member name.
    public class MemberChangeNameDetails: CustomStringConvertible, JSONRepresentable {
        /// New user's name.
        public let newValue: TeamLog.UserNameLogInfo
        /// Previous user's name. Might be missing due to historical data gap.
        public let previousValue: TeamLog.UserNameLogInfo?
        public init(newValue: TeamLog.UserNameLogInfo, previousValue: TeamLog.UserNameLogInfo? = nil) {
            self.newValue = newValue
            self.previousValue = previousValue
        }

        func json() throws -> JSON {
            try MemberChangeNameDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try MemberChangeNameDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for MemberChangeNameDetails: \(error)"
            }
        }
    }

    public class MemberChangeNameDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: MemberChangeNameDetails) throws -> JSON {
            let output = [
                "new_value": try TeamLog.UserNameLogInfoSerializer().serialize(value.newValue),
                "previous_value": try NullableSerializer(TeamLog.UserNameLogInfoSerializer()).serialize(value.previousValue),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> MemberChangeNameDetails {
            switch json {
            case .dictionary(let dict):
                let newValue = try TeamLog.UserNameLogInfoSerializer().deserialize(dict["new_value"] ?? .null)
                let previousValue = try NullableSerializer(TeamLog.UserNameLogInfoSerializer()).deserialize(dict["previous_value"] ?? .null)
                return MemberChangeNameDetails(newValue: newValue, previousValue: previousValue)
            default:
                throw JSONSerializerError.deserializeError(type: MemberChangeNameDetails.self, json: json)
            }
        }
    }

    /// The MemberChangeNameType struct
    public class MemberChangeNameType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try MemberChangeNameTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try MemberChangeNameTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for MemberChangeNameType: \(error)"
            }
        }
    }

    public class MemberChangeNameTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: MemberChangeNameType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> MemberChangeNameType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return MemberChangeNameType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: MemberChangeNameType.self, json: json)
            }
        }
    }

    /// Changed team member reseller role.
    public class MemberChangeResellerRoleDetails: CustomStringConvertible, JSONRepresentable {
        /// New reseller role. This field is relevant when the reseller role is changed.
        public let newValue: TeamLog.ResellerRole
        /// Previous reseller role. This field is relevant when the reseller role is changed or when the reseller role
        /// is removed.
        public let previousValue: TeamLog.ResellerRole
        public init(newValue: TeamLog.ResellerRole, previousValue: TeamLog.ResellerRole) {
            self.newValue = newValue
            self.previousValue = previousValue
        }

        func json() throws -> JSON {
            try MemberChangeResellerRoleDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try MemberChangeResellerRoleDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for MemberChangeResellerRoleDetails: \(error)"
            }
        }
    }

    public class MemberChangeResellerRoleDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: MemberChangeResellerRoleDetails) throws -> JSON {
            let output = [
                "new_value": try TeamLog.ResellerRoleSerializer().serialize(value.newValue),
                "previous_value": try TeamLog.ResellerRoleSerializer().serialize(value.previousValue),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> MemberChangeResellerRoleDetails {
            switch json {
            case .dictionary(let dict):
                let newValue = try TeamLog.ResellerRoleSerializer().deserialize(dict["new_value"] ?? .null)
                let previousValue = try TeamLog.ResellerRoleSerializer().deserialize(dict["previous_value"] ?? .null)
                return MemberChangeResellerRoleDetails(newValue: newValue, previousValue: previousValue)
            default:
                throw JSONSerializerError.deserializeError(type: MemberChangeResellerRoleDetails.self, json: json)
            }
        }
    }

    /// The MemberChangeResellerRoleType struct
    public class MemberChangeResellerRoleType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try MemberChangeResellerRoleTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try MemberChangeResellerRoleTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for MemberChangeResellerRoleType: \(error)"
            }
        }
    }

    public class MemberChangeResellerRoleTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: MemberChangeResellerRoleType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> MemberChangeResellerRoleType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return MemberChangeResellerRoleType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: MemberChangeResellerRoleType.self, json: json)
            }
        }
    }

    /// Changed member status (invited, joined, suspended, etc.).
    public class MemberChangeStatusDetails: CustomStringConvertible, JSONRepresentable {
        /// Previous member status. Might be missing due to historical data gap.
        public let previousValue: TeamLog.MemberStatus?
        /// New member status.
        public let newValue: TeamLog.MemberStatus
        /// Additional information indicating the action taken that caused status change.
        public let action: TeamLog.ActionDetails?
        /// The user's new team name. This field is relevant when the user is transferred off the team.
        public let newTeam: String?
        /// The user's previous team name. This field is relevant when the user is transferred onto the team.
        public let previousTeam: String?
        public init(
            newValue: TeamLog.MemberStatus,
            previousValue: TeamLog.MemberStatus? = nil,
            action: TeamLog.ActionDetails? = nil,
            newTeam: String? = nil,
            previousTeam: String? = nil
        ) {
            self.previousValue = previousValue
            self.newValue = newValue
            self.action = action
            nullableValidator(stringValidator())(newTeam)
            self.newTeam = newTeam
            nullableValidator(stringValidator())(previousTeam)
            self.previousTeam = previousTeam
        }

        func json() throws -> JSON {
            try MemberChangeStatusDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try MemberChangeStatusDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for MemberChangeStatusDetails: \(error)"
            }
        }
    }

    public class MemberChangeStatusDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: MemberChangeStatusDetails) throws -> JSON {
            let output = [
                "new_value": try TeamLog.MemberStatusSerializer().serialize(value.newValue),
                "previous_value": try NullableSerializer(TeamLog.MemberStatusSerializer()).serialize(value.previousValue),
                "action": try NullableSerializer(TeamLog.ActionDetailsSerializer()).serialize(value.action),
                "new_team": try NullableSerializer(Serialization._StringSerializer).serialize(value.newTeam),
                "previous_team": try NullableSerializer(Serialization._StringSerializer).serialize(value.previousTeam),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> MemberChangeStatusDetails {
            switch json {
            case .dictionary(let dict):
                let newValue = try TeamLog.MemberStatusSerializer().deserialize(dict["new_value"] ?? .null)
                let previousValue = try NullableSerializer(TeamLog.MemberStatusSerializer()).deserialize(dict["previous_value"] ?? .null)
                let action = try NullableSerializer(TeamLog.ActionDetailsSerializer()).deserialize(dict["action"] ?? .null)
                let newTeam = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["new_team"] ?? .null)
                let previousTeam = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["previous_team"] ?? .null)
                return MemberChangeStatusDetails(
                    newValue: newValue,
                    previousValue: previousValue,
                    action: action,
                    newTeam: newTeam,
                    previousTeam: previousTeam
                )
            default:
                throw JSONSerializerError.deserializeError(type: MemberChangeStatusDetails.self, json: json)
            }
        }
    }

    /// The MemberChangeStatusType struct
    public class MemberChangeStatusType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try MemberChangeStatusTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try MemberChangeStatusTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for MemberChangeStatusType: \(error)"
            }
        }
    }

    public class MemberChangeStatusTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: MemberChangeStatusType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> MemberChangeStatusType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return MemberChangeStatusType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: MemberChangeStatusType.self, json: json)
            }
        }
    }

    /// Cleared manually added contacts.
    public class MemberDeleteManualContactsDetails: CustomStringConvertible, JSONRepresentable {
        func json() throws -> JSON {
            try MemberDeleteManualContactsDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try MemberDeleteManualContactsDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for MemberDeleteManualContactsDetails: \(error)"
            }
        }
    }

    public class MemberDeleteManualContactsDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: MemberDeleteManualContactsDetails) throws -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> MemberDeleteManualContactsDetails {
            switch json {
            case .dictionary:
                return MemberDeleteManualContactsDetails()
            default:
                throw JSONSerializerError.deserializeError(type: MemberDeleteManualContactsDetails.self, json: json)
            }
        }
    }

    /// The MemberDeleteManualContactsType struct
    public class MemberDeleteManualContactsType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try MemberDeleteManualContactsTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try MemberDeleteManualContactsTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for MemberDeleteManualContactsType: \(error)"
            }
        }
    }

    public class MemberDeleteManualContactsTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: MemberDeleteManualContactsType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> MemberDeleteManualContactsType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return MemberDeleteManualContactsType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: MemberDeleteManualContactsType.self, json: json)
            }
        }
    }

    /// Deleted team member profile photo.
    public class MemberDeleteProfilePhotoDetails: CustomStringConvertible, JSONRepresentable {
        func json() throws -> JSON {
            try MemberDeleteProfilePhotoDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try MemberDeleteProfilePhotoDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for MemberDeleteProfilePhotoDetails: \(error)"
            }
        }
    }

    public class MemberDeleteProfilePhotoDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: MemberDeleteProfilePhotoDetails) throws -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> MemberDeleteProfilePhotoDetails {
            switch json {
            case .dictionary:
                return MemberDeleteProfilePhotoDetails()
            default:
                throw JSONSerializerError.deserializeError(type: MemberDeleteProfilePhotoDetails.self, json: json)
            }
        }
    }

    /// The MemberDeleteProfilePhotoType struct
    public class MemberDeleteProfilePhotoType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try MemberDeleteProfilePhotoTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try MemberDeleteProfilePhotoTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for MemberDeleteProfilePhotoType: \(error)"
            }
        }
    }

    public class MemberDeleteProfilePhotoTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: MemberDeleteProfilePhotoType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> MemberDeleteProfilePhotoType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return MemberDeleteProfilePhotoType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: MemberDeleteProfilePhotoType.self, json: json)
            }
        }
    }

    /// Permanently deleted contents of deleted team member account.
    public class MemberPermanentlyDeleteAccountContentsDetails: CustomStringConvertible, JSONRepresentable {
        func json() throws -> JSON {
            try MemberPermanentlyDeleteAccountContentsDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try MemberPermanentlyDeleteAccountContentsDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for MemberPermanentlyDeleteAccountContentsDetails: \(error)"
            }
        }
    }

    public class MemberPermanentlyDeleteAccountContentsDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: MemberPermanentlyDeleteAccountContentsDetails) throws -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> MemberPermanentlyDeleteAccountContentsDetails {
            switch json {
            case .dictionary:
                return MemberPermanentlyDeleteAccountContentsDetails()
            default:
                throw JSONSerializerError.deserializeError(type: MemberPermanentlyDeleteAccountContentsDetails.self, json: json)
            }
        }
    }

    /// The MemberPermanentlyDeleteAccountContentsType struct
    public class MemberPermanentlyDeleteAccountContentsType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try MemberPermanentlyDeleteAccountContentsTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try MemberPermanentlyDeleteAccountContentsTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for MemberPermanentlyDeleteAccountContentsType: \(error)"
            }
        }
    }

    public class MemberPermanentlyDeleteAccountContentsTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: MemberPermanentlyDeleteAccountContentsType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> MemberPermanentlyDeleteAccountContentsType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return MemberPermanentlyDeleteAccountContentsType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: MemberPermanentlyDeleteAccountContentsType.self, json: json)
            }
        }
    }

    /// The MemberRemoveActionType union
    public enum MemberRemoveActionType: CustomStringConvertible, JSONRepresentable {
        /// An unspecified error.
        case delete
        /// An unspecified error.
        case leave
        /// An unspecified error.
        case offboard
        /// An unspecified error.
        case offboardAndRetainTeamFolders
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try MemberRemoveActionTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try MemberRemoveActionTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for MemberRemoveActionType: \(error)"
            }
        }
    }

    public class MemberRemoveActionTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: MemberRemoveActionType) throws -> JSON {
            switch value {
            case .delete:
                var d = [String: JSON]()
                d[".tag"] = .str("delete")
                return .dictionary(d)
            case .leave:
                var d = [String: JSON]()
                d[".tag"] = .str("leave")
                return .dictionary(d)
            case .offboard:
                var d = [String: JSON]()
                d[".tag"] = .str("offboard")
                return .dictionary(d)
            case .offboardAndRetainTeamFolders:
                var d = [String: JSON]()
                d[".tag"] = .str("offboard_and_retain_team_folders")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> MemberRemoveActionType {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "delete":
                    return MemberRemoveActionType.delete
                case "leave":
                    return MemberRemoveActionType.leave
                case "offboard":
                    return MemberRemoveActionType.offboard
                case "offboard_and_retain_team_folders":
                    return MemberRemoveActionType.offboardAndRetainTeamFolders
                case "other":
                    return MemberRemoveActionType.other
                default:
                    return MemberRemoveActionType.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: MemberRemoveActionType.self, json: json)
            }
        }
    }

    /// Removed the external ID for team member.
    public class MemberRemoveExternalIdDetails: CustomStringConvertible, JSONRepresentable {
        /// Old external id.
        public let previousValue: String
        public init(previousValue: String) {
            stringValidator(maxLength: 64)(previousValue)
            self.previousValue = previousValue
        }

        func json() throws -> JSON {
            try MemberRemoveExternalIdDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try MemberRemoveExternalIdDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for MemberRemoveExternalIdDetails: \(error)"
            }
        }
    }

    public class MemberRemoveExternalIdDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: MemberRemoveExternalIdDetails) throws -> JSON {
            let output = [
                "previous_value": try Serialization._StringSerializer.serialize(value.previousValue),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> MemberRemoveExternalIdDetails {
            switch json {
            case .dictionary(let dict):
                let previousValue = try Serialization._StringSerializer.deserialize(dict["previous_value"] ?? .null)
                return MemberRemoveExternalIdDetails(previousValue: previousValue)
            default:
                throw JSONSerializerError.deserializeError(type: MemberRemoveExternalIdDetails.self, json: json)
            }
        }
    }

    /// The MemberRemoveExternalIdType struct
    public class MemberRemoveExternalIdType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try MemberRemoveExternalIdTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try MemberRemoveExternalIdTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for MemberRemoveExternalIdType: \(error)"
            }
        }
    }

    public class MemberRemoveExternalIdTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: MemberRemoveExternalIdType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> MemberRemoveExternalIdType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return MemberRemoveExternalIdType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: MemberRemoveExternalIdType.self, json: json)
            }
        }
    }

    /// Changed whether users can find team when not invited.
    public class MemberRequestsChangePolicyDetails: CustomStringConvertible, JSONRepresentable {
        /// New member change requests policy.
        public let newValue: TeamLog.MemberRequestsPolicy
        /// Previous member change requests policy. Might be missing due to historical data gap.
        public let previousValue: TeamLog.MemberRequestsPolicy?
        public init(newValue: TeamLog.MemberRequestsPolicy, previousValue: TeamLog.MemberRequestsPolicy? = nil) {
            self.newValue = newValue
            self.previousValue = previousValue
        }

        func json() throws -> JSON {
            try MemberRequestsChangePolicyDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try MemberRequestsChangePolicyDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for MemberRequestsChangePolicyDetails: \(error)"
            }
        }
    }

    public class MemberRequestsChangePolicyDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: MemberRequestsChangePolicyDetails) throws -> JSON {
            let output = [
                "new_value": try TeamLog.MemberRequestsPolicySerializer().serialize(value.newValue),
                "previous_value": try NullableSerializer(TeamLog.MemberRequestsPolicySerializer()).serialize(value.previousValue),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> MemberRequestsChangePolicyDetails {
            switch json {
            case .dictionary(let dict):
                let newValue = try TeamLog.MemberRequestsPolicySerializer().deserialize(dict["new_value"] ?? .null)
                let previousValue = try NullableSerializer(TeamLog.MemberRequestsPolicySerializer()).deserialize(dict["previous_value"] ?? .null)
                return MemberRequestsChangePolicyDetails(newValue: newValue, previousValue: previousValue)
            default:
                throw JSONSerializerError.deserializeError(type: MemberRequestsChangePolicyDetails.self, json: json)
            }
        }
    }

    /// The MemberRequestsChangePolicyType struct
    public class MemberRequestsChangePolicyType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try MemberRequestsChangePolicyTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try MemberRequestsChangePolicyTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for MemberRequestsChangePolicyType: \(error)"
            }
        }
    }

    public class MemberRequestsChangePolicyTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: MemberRequestsChangePolicyType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> MemberRequestsChangePolicyType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return MemberRequestsChangePolicyType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: MemberRequestsChangePolicyType.self, json: json)
            }
        }
    }

    /// The MemberRequestsPolicy union
    public enum MemberRequestsPolicy: CustomStringConvertible, JSONRepresentable {
        /// An unspecified error.
        case autoAccept
        /// An unspecified error.
        case disabled
        /// An unspecified error.
        case requireApproval
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try MemberRequestsPolicySerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try MemberRequestsPolicySerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for MemberRequestsPolicy: \(error)"
            }
        }
    }

    public class MemberRequestsPolicySerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: MemberRequestsPolicy) throws -> JSON {
            switch value {
            case .autoAccept:
                var d = [String: JSON]()
                d[".tag"] = .str("auto_accept")
                return .dictionary(d)
            case .disabled:
                var d = [String: JSON]()
                d[".tag"] = .str("disabled")
                return .dictionary(d)
            case .requireApproval:
                var d = [String: JSON]()
                d[".tag"] = .str("require_approval")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> MemberRequestsPolicy {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "auto_accept":
                    return MemberRequestsPolicy.autoAccept
                case "disabled":
                    return MemberRequestsPolicy.disabled
                case "require_approval":
                    return MemberRequestsPolicy.requireApproval
                case "other":
                    return MemberRequestsPolicy.other
                default:
                    return MemberRequestsPolicy.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: MemberRequestsPolicy.self, json: json)
            }
        }
    }

    /// Policy for controlling whether team members can send team invites
    public enum MemberSendInvitePolicy: CustomStringConvertible, JSONRepresentable {
        /// An unspecified error.
        case disabled
        /// An unspecified error.
        case everyone
        /// An unspecified error.
        case specificMembers
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try MemberSendInvitePolicySerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try MemberSendInvitePolicySerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for MemberSendInvitePolicy: \(error)"
            }
        }
    }

    public class MemberSendInvitePolicySerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: MemberSendInvitePolicy) throws -> JSON {
            switch value {
            case .disabled:
                var d = [String: JSON]()
                d[".tag"] = .str("disabled")
                return .dictionary(d)
            case .everyone:
                var d = [String: JSON]()
                d[".tag"] = .str("everyone")
                return .dictionary(d)
            case .specificMembers:
                var d = [String: JSON]()
                d[".tag"] = .str("specific_members")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> MemberSendInvitePolicy {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "disabled":
                    return MemberSendInvitePolicy.disabled
                case "everyone":
                    return MemberSendInvitePolicy.everyone
                case "specific_members":
                    return MemberSendInvitePolicy.specificMembers
                case "other":
                    return MemberSendInvitePolicy.other
                default:
                    return MemberSendInvitePolicy.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: MemberSendInvitePolicy.self, json: json)
            }
        }
    }

    /// Changed member send invite policy for team.
    public class MemberSendInvitePolicyChangedDetails: CustomStringConvertible, JSONRepresentable {
        /// New team member send invite policy.
        public let newValue: TeamLog.MemberSendInvitePolicy
        /// Previous team member send invite policy.
        public let previousValue: TeamLog.MemberSendInvitePolicy
        public init(newValue: TeamLog.MemberSendInvitePolicy, previousValue: TeamLog.MemberSendInvitePolicy) {
            self.newValue = newValue
            self.previousValue = previousValue
        }

        func json() throws -> JSON {
            try MemberSendInvitePolicyChangedDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try MemberSendInvitePolicyChangedDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for MemberSendInvitePolicyChangedDetails: \(error)"
            }
        }
    }

    public class MemberSendInvitePolicyChangedDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: MemberSendInvitePolicyChangedDetails) throws -> JSON {
            let output = [
                "new_value": try TeamLog.MemberSendInvitePolicySerializer().serialize(value.newValue),
                "previous_value": try TeamLog.MemberSendInvitePolicySerializer().serialize(value.previousValue),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> MemberSendInvitePolicyChangedDetails {
            switch json {
            case .dictionary(let dict):
                let newValue = try TeamLog.MemberSendInvitePolicySerializer().deserialize(dict["new_value"] ?? .null)
                let previousValue = try TeamLog.MemberSendInvitePolicySerializer().deserialize(dict["previous_value"] ?? .null)
                return MemberSendInvitePolicyChangedDetails(newValue: newValue, previousValue: previousValue)
            default:
                throw JSONSerializerError.deserializeError(type: MemberSendInvitePolicyChangedDetails.self, json: json)
            }
        }
    }

    /// The MemberSendInvitePolicyChangedType struct
    public class MemberSendInvitePolicyChangedType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try MemberSendInvitePolicyChangedTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try MemberSendInvitePolicyChangedTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for MemberSendInvitePolicyChangedType: \(error)"
            }
        }
    }

    public class MemberSendInvitePolicyChangedTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: MemberSendInvitePolicyChangedType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> MemberSendInvitePolicyChangedType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return MemberSendInvitePolicyChangedType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: MemberSendInvitePolicyChangedType.self, json: json)
            }
        }
    }

    /// Set team member profile photo.
    public class MemberSetProfilePhotoDetails: CustomStringConvertible, JSONRepresentable {
        func json() throws -> JSON {
            try MemberSetProfilePhotoDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try MemberSetProfilePhotoDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for MemberSetProfilePhotoDetails: \(error)"
            }
        }
    }

    public class MemberSetProfilePhotoDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: MemberSetProfilePhotoDetails) throws -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> MemberSetProfilePhotoDetails {
            switch json {
            case .dictionary:
                return MemberSetProfilePhotoDetails()
            default:
                throw JSONSerializerError.deserializeError(type: MemberSetProfilePhotoDetails.self, json: json)
            }
        }
    }

    /// The MemberSetProfilePhotoType struct
    public class MemberSetProfilePhotoType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try MemberSetProfilePhotoTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try MemberSetProfilePhotoTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for MemberSetProfilePhotoType: \(error)"
            }
        }
    }

    public class MemberSetProfilePhotoTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: MemberSetProfilePhotoType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> MemberSetProfilePhotoType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return MemberSetProfilePhotoType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: MemberSetProfilePhotoType.self, json: json)
            }
        }
    }

    /// Set custom member space limit.
    public class MemberSpaceLimitsAddCustomQuotaDetails: CustomStringConvertible, JSONRepresentable {
        /// New custom quota value in bytes.
        public let newValue: UInt64
        public init(newValue: UInt64) {
            comparableValidator()(newValue)
            self.newValue = newValue
        }

        func json() throws -> JSON {
            try MemberSpaceLimitsAddCustomQuotaDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try MemberSpaceLimitsAddCustomQuotaDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for MemberSpaceLimitsAddCustomQuotaDetails: \(error)"
            }
        }
    }

    public class MemberSpaceLimitsAddCustomQuotaDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: MemberSpaceLimitsAddCustomQuotaDetails) throws -> JSON {
            let output = [
                "new_value": try Serialization._UInt64Serializer.serialize(value.newValue),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> MemberSpaceLimitsAddCustomQuotaDetails {
            switch json {
            case .dictionary(let dict):
                let newValue = try Serialization._UInt64Serializer.deserialize(dict["new_value"] ?? .null)
                return MemberSpaceLimitsAddCustomQuotaDetails(newValue: newValue)
            default:
                throw JSONSerializerError.deserializeError(type: MemberSpaceLimitsAddCustomQuotaDetails.self, json: json)
            }
        }
    }

    /// The MemberSpaceLimitsAddCustomQuotaType struct
    public class MemberSpaceLimitsAddCustomQuotaType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try MemberSpaceLimitsAddCustomQuotaTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try MemberSpaceLimitsAddCustomQuotaTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for MemberSpaceLimitsAddCustomQuotaType: \(error)"
            }
        }
    }

    public class MemberSpaceLimitsAddCustomQuotaTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: MemberSpaceLimitsAddCustomQuotaType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> MemberSpaceLimitsAddCustomQuotaType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return MemberSpaceLimitsAddCustomQuotaType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: MemberSpaceLimitsAddCustomQuotaType.self, json: json)
            }
        }
    }

    /// Added members to member space limit exception list.
    public class MemberSpaceLimitsAddExceptionDetails: CustomStringConvertible, JSONRepresentable {
        func json() throws -> JSON {
            try MemberSpaceLimitsAddExceptionDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try MemberSpaceLimitsAddExceptionDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for MemberSpaceLimitsAddExceptionDetails: \(error)"
            }
        }
    }

    public class MemberSpaceLimitsAddExceptionDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: MemberSpaceLimitsAddExceptionDetails) throws -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> MemberSpaceLimitsAddExceptionDetails {
            switch json {
            case .dictionary:
                return MemberSpaceLimitsAddExceptionDetails()
            default:
                throw JSONSerializerError.deserializeError(type: MemberSpaceLimitsAddExceptionDetails.self, json: json)
            }
        }
    }

    /// The MemberSpaceLimitsAddExceptionType struct
    public class MemberSpaceLimitsAddExceptionType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try MemberSpaceLimitsAddExceptionTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try MemberSpaceLimitsAddExceptionTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for MemberSpaceLimitsAddExceptionType: \(error)"
            }
        }
    }

    public class MemberSpaceLimitsAddExceptionTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: MemberSpaceLimitsAddExceptionType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> MemberSpaceLimitsAddExceptionType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return MemberSpaceLimitsAddExceptionType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: MemberSpaceLimitsAddExceptionType.self, json: json)
            }
        }
    }

    /// Changed member space limit type for team.
    public class MemberSpaceLimitsChangeCapsTypePolicyDetails: CustomStringConvertible, JSONRepresentable {
        /// Previous space limit type.
        public let previousValue: TeamLog.SpaceCapsType
        /// New space limit type.
        public let newValue: TeamLog.SpaceCapsType
        public init(previousValue: TeamLog.SpaceCapsType, newValue: TeamLog.SpaceCapsType) {
            self.previousValue = previousValue
            self.newValue = newValue
        }

        func json() throws -> JSON {
            try MemberSpaceLimitsChangeCapsTypePolicyDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try MemberSpaceLimitsChangeCapsTypePolicyDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for MemberSpaceLimitsChangeCapsTypePolicyDetails: \(error)"
            }
        }
    }

    public class MemberSpaceLimitsChangeCapsTypePolicyDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: MemberSpaceLimitsChangeCapsTypePolicyDetails) throws -> JSON {
            let output = [
                "previous_value": try TeamLog.SpaceCapsTypeSerializer().serialize(value.previousValue),
                "new_value": try TeamLog.SpaceCapsTypeSerializer().serialize(value.newValue),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> MemberSpaceLimitsChangeCapsTypePolicyDetails {
            switch json {
            case .dictionary(let dict):
                let previousValue = try TeamLog.SpaceCapsTypeSerializer().deserialize(dict["previous_value"] ?? .null)
                let newValue = try TeamLog.SpaceCapsTypeSerializer().deserialize(dict["new_value"] ?? .null)
                return MemberSpaceLimitsChangeCapsTypePolicyDetails(previousValue: previousValue, newValue: newValue)
            default:
                throw JSONSerializerError.deserializeError(type: MemberSpaceLimitsChangeCapsTypePolicyDetails.self, json: json)
            }
        }
    }

    /// The MemberSpaceLimitsChangeCapsTypePolicyType struct
    public class MemberSpaceLimitsChangeCapsTypePolicyType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try MemberSpaceLimitsChangeCapsTypePolicyTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try MemberSpaceLimitsChangeCapsTypePolicyTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for MemberSpaceLimitsChangeCapsTypePolicyType: \(error)"
            }
        }
    }

    public class MemberSpaceLimitsChangeCapsTypePolicyTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: MemberSpaceLimitsChangeCapsTypePolicyType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> MemberSpaceLimitsChangeCapsTypePolicyType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return MemberSpaceLimitsChangeCapsTypePolicyType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: MemberSpaceLimitsChangeCapsTypePolicyType.self, json: json)
            }
        }
    }

    /// Changed custom member space limit.
    public class MemberSpaceLimitsChangeCustomQuotaDetails: CustomStringConvertible, JSONRepresentable {
        /// Previous custom quota value in bytes.
        public let previousValue: UInt64
        /// New custom quota value in bytes.
        public let newValue: UInt64
        public init(previousValue: UInt64, newValue: UInt64) {
            comparableValidator()(previousValue)
            self.previousValue = previousValue
            comparableValidator()(newValue)
            self.newValue = newValue
        }

        func json() throws -> JSON {
            try MemberSpaceLimitsChangeCustomQuotaDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try MemberSpaceLimitsChangeCustomQuotaDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for MemberSpaceLimitsChangeCustomQuotaDetails: \(error)"
            }
        }
    }

    public class MemberSpaceLimitsChangeCustomQuotaDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: MemberSpaceLimitsChangeCustomQuotaDetails) throws -> JSON {
            let output = [
                "previous_value": try Serialization._UInt64Serializer.serialize(value.previousValue),
                "new_value": try Serialization._UInt64Serializer.serialize(value.newValue),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> MemberSpaceLimitsChangeCustomQuotaDetails {
            switch json {
            case .dictionary(let dict):
                let previousValue = try Serialization._UInt64Serializer.deserialize(dict["previous_value"] ?? .null)
                let newValue = try Serialization._UInt64Serializer.deserialize(dict["new_value"] ?? .null)
                return MemberSpaceLimitsChangeCustomQuotaDetails(previousValue: previousValue, newValue: newValue)
            default:
                throw JSONSerializerError.deserializeError(type: MemberSpaceLimitsChangeCustomQuotaDetails.self, json: json)
            }
        }
    }

    /// The MemberSpaceLimitsChangeCustomQuotaType struct
    public class MemberSpaceLimitsChangeCustomQuotaType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try MemberSpaceLimitsChangeCustomQuotaTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try MemberSpaceLimitsChangeCustomQuotaTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for MemberSpaceLimitsChangeCustomQuotaType: \(error)"
            }
        }
    }

    public class MemberSpaceLimitsChangeCustomQuotaTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: MemberSpaceLimitsChangeCustomQuotaType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> MemberSpaceLimitsChangeCustomQuotaType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return MemberSpaceLimitsChangeCustomQuotaType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: MemberSpaceLimitsChangeCustomQuotaType.self, json: json)
            }
        }
    }

    /// Changed team default member space limit.
    public class MemberSpaceLimitsChangePolicyDetails: CustomStringConvertible, JSONRepresentable {
        /// Previous team default limit value in bytes. Might be missing due to historical data gap.
        public let previousValue: UInt64?
        /// New team default limit value in bytes. Might be missing due to historical data gap.
        public let newValue: UInt64?
        public init(previousValue: UInt64? = nil, newValue: UInt64? = nil) {
            nullableValidator(comparableValidator())(previousValue)
            self.previousValue = previousValue
            nullableValidator(comparableValidator())(newValue)
            self.newValue = newValue
        }

        func json() throws -> JSON {
            try MemberSpaceLimitsChangePolicyDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try MemberSpaceLimitsChangePolicyDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for MemberSpaceLimitsChangePolicyDetails: \(error)"
            }
        }
    }

    public class MemberSpaceLimitsChangePolicyDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: MemberSpaceLimitsChangePolicyDetails) throws -> JSON {
            let output = [
                "previous_value": try NullableSerializer(Serialization._UInt64Serializer).serialize(value.previousValue),
                "new_value": try NullableSerializer(Serialization._UInt64Serializer).serialize(value.newValue),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> MemberSpaceLimitsChangePolicyDetails {
            switch json {
            case .dictionary(let dict):
                let previousValue = try NullableSerializer(Serialization._UInt64Serializer).deserialize(dict["previous_value"] ?? .null)
                let newValue = try NullableSerializer(Serialization._UInt64Serializer).deserialize(dict["new_value"] ?? .null)
                return MemberSpaceLimitsChangePolicyDetails(previousValue: previousValue, newValue: newValue)
            default:
                throw JSONSerializerError.deserializeError(type: MemberSpaceLimitsChangePolicyDetails.self, json: json)
            }
        }
    }

    /// The MemberSpaceLimitsChangePolicyType struct
    public class MemberSpaceLimitsChangePolicyType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try MemberSpaceLimitsChangePolicyTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try MemberSpaceLimitsChangePolicyTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for MemberSpaceLimitsChangePolicyType: \(error)"
            }
        }
    }

    public class MemberSpaceLimitsChangePolicyTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: MemberSpaceLimitsChangePolicyType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> MemberSpaceLimitsChangePolicyType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return MemberSpaceLimitsChangePolicyType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: MemberSpaceLimitsChangePolicyType.self, json: json)
            }
        }
    }

    /// Changed space limit status.
    public class MemberSpaceLimitsChangeStatusDetails: CustomStringConvertible, JSONRepresentable {
        /// Previous storage quota status.
        public let previousValue: TeamLog.SpaceLimitsStatus
        /// New storage quota status.
        public let newValue: TeamLog.SpaceLimitsStatus
        public init(previousValue: TeamLog.SpaceLimitsStatus, newValue: TeamLog.SpaceLimitsStatus) {
            self.previousValue = previousValue
            self.newValue = newValue
        }

        func json() throws -> JSON {
            try MemberSpaceLimitsChangeStatusDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try MemberSpaceLimitsChangeStatusDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for MemberSpaceLimitsChangeStatusDetails: \(error)"
            }
        }
    }

    public class MemberSpaceLimitsChangeStatusDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: MemberSpaceLimitsChangeStatusDetails) throws -> JSON {
            let output = [
                "previous_value": try TeamLog.SpaceLimitsStatusSerializer().serialize(value.previousValue),
                "new_value": try TeamLog.SpaceLimitsStatusSerializer().serialize(value.newValue),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> MemberSpaceLimitsChangeStatusDetails {
            switch json {
            case .dictionary(let dict):
                let previousValue = try TeamLog.SpaceLimitsStatusSerializer().deserialize(dict["previous_value"] ?? .null)
                let newValue = try TeamLog.SpaceLimitsStatusSerializer().deserialize(dict["new_value"] ?? .null)
                return MemberSpaceLimitsChangeStatusDetails(previousValue: previousValue, newValue: newValue)
            default:
                throw JSONSerializerError.deserializeError(type: MemberSpaceLimitsChangeStatusDetails.self, json: json)
            }
        }
    }

    /// The MemberSpaceLimitsChangeStatusType struct
    public class MemberSpaceLimitsChangeStatusType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try MemberSpaceLimitsChangeStatusTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try MemberSpaceLimitsChangeStatusTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for MemberSpaceLimitsChangeStatusType: \(error)"
            }
        }
    }

    public class MemberSpaceLimitsChangeStatusTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: MemberSpaceLimitsChangeStatusType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> MemberSpaceLimitsChangeStatusType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return MemberSpaceLimitsChangeStatusType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: MemberSpaceLimitsChangeStatusType.self, json: json)
            }
        }
    }

    /// Removed custom member space limit.
    public class MemberSpaceLimitsRemoveCustomQuotaDetails: CustomStringConvertible, JSONRepresentable {
        func json() throws -> JSON {
            try MemberSpaceLimitsRemoveCustomQuotaDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try MemberSpaceLimitsRemoveCustomQuotaDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for MemberSpaceLimitsRemoveCustomQuotaDetails: \(error)"
            }
        }
    }

    public class MemberSpaceLimitsRemoveCustomQuotaDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: MemberSpaceLimitsRemoveCustomQuotaDetails) throws -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> MemberSpaceLimitsRemoveCustomQuotaDetails {
            switch json {
            case .dictionary:
                return MemberSpaceLimitsRemoveCustomQuotaDetails()
            default:
                throw JSONSerializerError.deserializeError(type: MemberSpaceLimitsRemoveCustomQuotaDetails.self, json: json)
            }
        }
    }

    /// The MemberSpaceLimitsRemoveCustomQuotaType struct
    public class MemberSpaceLimitsRemoveCustomQuotaType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try MemberSpaceLimitsRemoveCustomQuotaTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try MemberSpaceLimitsRemoveCustomQuotaTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for MemberSpaceLimitsRemoveCustomQuotaType: \(error)"
            }
        }
    }

    public class MemberSpaceLimitsRemoveCustomQuotaTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: MemberSpaceLimitsRemoveCustomQuotaType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> MemberSpaceLimitsRemoveCustomQuotaType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return MemberSpaceLimitsRemoveCustomQuotaType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: MemberSpaceLimitsRemoveCustomQuotaType.self, json: json)
            }
        }
    }

    /// Removed members from member space limit exception list.
    public class MemberSpaceLimitsRemoveExceptionDetails: CustomStringConvertible, JSONRepresentable {
        func json() throws -> JSON {
            try MemberSpaceLimitsRemoveExceptionDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try MemberSpaceLimitsRemoveExceptionDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for MemberSpaceLimitsRemoveExceptionDetails: \(error)"
            }
        }
    }

    public class MemberSpaceLimitsRemoveExceptionDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: MemberSpaceLimitsRemoveExceptionDetails) throws -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> MemberSpaceLimitsRemoveExceptionDetails {
            switch json {
            case .dictionary:
                return MemberSpaceLimitsRemoveExceptionDetails()
            default:
                throw JSONSerializerError.deserializeError(type: MemberSpaceLimitsRemoveExceptionDetails.self, json: json)
            }
        }
    }

    /// The MemberSpaceLimitsRemoveExceptionType struct
    public class MemberSpaceLimitsRemoveExceptionType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try MemberSpaceLimitsRemoveExceptionTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try MemberSpaceLimitsRemoveExceptionTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for MemberSpaceLimitsRemoveExceptionType: \(error)"
            }
        }
    }

    public class MemberSpaceLimitsRemoveExceptionTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: MemberSpaceLimitsRemoveExceptionType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> MemberSpaceLimitsRemoveExceptionType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return MemberSpaceLimitsRemoveExceptionType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: MemberSpaceLimitsRemoveExceptionType.self, json: json)
            }
        }
    }

    /// The MemberStatus union
    public enum MemberStatus: CustomStringConvertible, JSONRepresentable {
        /// An unspecified error.
        case active
        /// An unspecified error.
        case invited
        /// An unspecified error.
        case movedToAnotherTeam
        /// An unspecified error.
        case notJoined
        /// An unspecified error.
        case removed
        /// An unspecified error.
        case suspended
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try MemberStatusSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try MemberStatusSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for MemberStatus: \(error)"
            }
        }
    }

    public class MemberStatusSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: MemberStatus) throws -> JSON {
            switch value {
            case .active:
                var d = [String: JSON]()
                d[".tag"] = .str("active")
                return .dictionary(d)
            case .invited:
                var d = [String: JSON]()
                d[".tag"] = .str("invited")
                return .dictionary(d)
            case .movedToAnotherTeam:
                var d = [String: JSON]()
                d[".tag"] = .str("moved_to_another_team")
                return .dictionary(d)
            case .notJoined:
                var d = [String: JSON]()
                d[".tag"] = .str("not_joined")
                return .dictionary(d)
            case .removed:
                var d = [String: JSON]()
                d[".tag"] = .str("removed")
                return .dictionary(d)
            case .suspended:
                var d = [String: JSON]()
                d[".tag"] = .str("suspended")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> MemberStatus {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "active":
                    return MemberStatus.active
                case "invited":
                    return MemberStatus.invited
                case "moved_to_another_team":
                    return MemberStatus.movedToAnotherTeam
                case "not_joined":
                    return MemberStatus.notJoined
                case "removed":
                    return MemberStatus.removed
                case "suspended":
                    return MemberStatus.suspended
                case "other":
                    return MemberStatus.other
                default:
                    return MemberStatus.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: MemberStatus.self, json: json)
            }
        }
    }

    /// Suggested person to add to team.
    public class MemberSuggestDetails: CustomStringConvertible, JSONRepresentable {
        /// suggested users emails.
        public let suggestedMembers: [String]
        public init(suggestedMembers: [String]) {
            arrayValidator(itemValidator: stringValidator(maxLength: 255))(suggestedMembers)
            self.suggestedMembers = suggestedMembers
        }

        func json() throws -> JSON {
            try MemberSuggestDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try MemberSuggestDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for MemberSuggestDetails: \(error)"
            }
        }
    }

    public class MemberSuggestDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: MemberSuggestDetails) throws -> JSON {
            let output = [
                "suggested_members": try ArraySerializer(Serialization._StringSerializer).serialize(value.suggestedMembers),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> MemberSuggestDetails {
            switch json {
            case .dictionary(let dict):
                let suggestedMembers = try ArraySerializer(Serialization._StringSerializer).deserialize(dict["suggested_members"] ?? .null)
                return MemberSuggestDetails(suggestedMembers: suggestedMembers)
            default:
                throw JSONSerializerError.deserializeError(type: MemberSuggestDetails.self, json: json)
            }
        }
    }

    /// The MemberSuggestType struct
    public class MemberSuggestType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try MemberSuggestTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try MemberSuggestTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for MemberSuggestType: \(error)"
            }
        }
    }

    public class MemberSuggestTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: MemberSuggestType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> MemberSuggestType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return MemberSuggestType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: MemberSuggestType.self, json: json)
            }
        }
    }

    /// Enabled/disabled option for team members to suggest people to add to team.
    public class MemberSuggestionsChangePolicyDetails: CustomStringConvertible, JSONRepresentable {
        /// New team member suggestions policy.
        public let newValue: TeamLog.MemberSuggestionsPolicy
        /// Previous team member suggestions policy. Might be missing due to historical data gap.
        public let previousValue: TeamLog.MemberSuggestionsPolicy?
        public init(newValue: TeamLog.MemberSuggestionsPolicy, previousValue: TeamLog.MemberSuggestionsPolicy? = nil) {
            self.newValue = newValue
            self.previousValue = previousValue
        }

        func json() throws -> JSON {
            try MemberSuggestionsChangePolicyDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try MemberSuggestionsChangePolicyDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for MemberSuggestionsChangePolicyDetails: \(error)"
            }
        }
    }

    public class MemberSuggestionsChangePolicyDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: MemberSuggestionsChangePolicyDetails) throws -> JSON {
            let output = [
                "new_value": try TeamLog.MemberSuggestionsPolicySerializer().serialize(value.newValue),
                "previous_value": try NullableSerializer(TeamLog.MemberSuggestionsPolicySerializer()).serialize(value.previousValue),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> MemberSuggestionsChangePolicyDetails {
            switch json {
            case .dictionary(let dict):
                let newValue = try TeamLog.MemberSuggestionsPolicySerializer().deserialize(dict["new_value"] ?? .null)
                let previousValue = try NullableSerializer(TeamLog.MemberSuggestionsPolicySerializer()).deserialize(dict["previous_value"] ?? .null)
                return MemberSuggestionsChangePolicyDetails(newValue: newValue, previousValue: previousValue)
            default:
                throw JSONSerializerError.deserializeError(type: MemberSuggestionsChangePolicyDetails.self, json: json)
            }
        }
    }

    /// The MemberSuggestionsChangePolicyType struct
    public class MemberSuggestionsChangePolicyType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try MemberSuggestionsChangePolicyTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try MemberSuggestionsChangePolicyTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for MemberSuggestionsChangePolicyType: \(error)"
            }
        }
    }

    public class MemberSuggestionsChangePolicyTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: MemberSuggestionsChangePolicyType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> MemberSuggestionsChangePolicyType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return MemberSuggestionsChangePolicyType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: MemberSuggestionsChangePolicyType.self, json: json)
            }
        }
    }

    /// Member suggestions policy
    public enum MemberSuggestionsPolicy: CustomStringConvertible, JSONRepresentable {
        /// An unspecified error.
        case disabled
        /// An unspecified error.
        case enabled
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try MemberSuggestionsPolicySerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try MemberSuggestionsPolicySerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for MemberSuggestionsPolicy: \(error)"
            }
        }
    }

    public class MemberSuggestionsPolicySerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: MemberSuggestionsPolicy) throws -> JSON {
            switch value {
            case .disabled:
                var d = [String: JSON]()
                d[".tag"] = .str("disabled")
                return .dictionary(d)
            case .enabled:
                var d = [String: JSON]()
                d[".tag"] = .str("enabled")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> MemberSuggestionsPolicy {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "disabled":
                    return MemberSuggestionsPolicy.disabled
                case "enabled":
                    return MemberSuggestionsPolicy.enabled
                case "other":
                    return MemberSuggestionsPolicy.other
                default:
                    return MemberSuggestionsPolicy.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: MemberSuggestionsPolicy.self, json: json)
            }
        }
    }

    /// Transferred contents of deleted member account to another member.
    public class MemberTransferAccountContentsDetails: CustomStringConvertible, JSONRepresentable {
        func json() throws -> JSON {
            try MemberTransferAccountContentsDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try MemberTransferAccountContentsDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for MemberTransferAccountContentsDetails: \(error)"
            }
        }
    }

    public class MemberTransferAccountContentsDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: MemberTransferAccountContentsDetails) throws -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> MemberTransferAccountContentsDetails {
            switch json {
            case .dictionary:
                return MemberTransferAccountContentsDetails()
            default:
                throw JSONSerializerError.deserializeError(type: MemberTransferAccountContentsDetails.self, json: json)
            }
        }
    }

    /// The MemberTransferAccountContentsType struct
    public class MemberTransferAccountContentsType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try MemberTransferAccountContentsTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try MemberTransferAccountContentsTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for MemberTransferAccountContentsType: \(error)"
            }
        }
    }

    public class MemberTransferAccountContentsTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: MemberTransferAccountContentsType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> MemberTransferAccountContentsType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return MemberTransferAccountContentsType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: MemberTransferAccountContentsType.self, json: json)
            }
        }
    }

    /// Internal only - fields for target team computations
    public class MemberTransferredInternalFields: CustomStringConvertible, JSONRepresentable {
        /// Internal only - team user was moved from.
        public let sourceTeamId: String
        /// Internal only - team user was moved to.
        public let targetTeamId: String
        public init(sourceTeamId: String, targetTeamId: String) {
            stringValidator()(sourceTeamId)
            self.sourceTeamId = sourceTeamId
            stringValidator()(targetTeamId)
            self.targetTeamId = targetTeamId
        }

        func json() throws -> JSON {
            try MemberTransferredInternalFieldsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try MemberTransferredInternalFieldsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for MemberTransferredInternalFields: \(error)"
            }
        }
    }

    public class MemberTransferredInternalFieldsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: MemberTransferredInternalFields) throws -> JSON {
            let output = [
                "source_team_id": try Serialization._StringSerializer.serialize(value.sourceTeamId),
                "target_team_id": try Serialization._StringSerializer.serialize(value.targetTeamId),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> MemberTransferredInternalFields {
            switch json {
            case .dictionary(let dict):
                let sourceTeamId = try Serialization._StringSerializer.deserialize(dict["source_team_id"] ?? .null)
                let targetTeamId = try Serialization._StringSerializer.deserialize(dict["target_team_id"] ?? .null)
                return MemberTransferredInternalFields(sourceTeamId: sourceTeamId, targetTeamId: targetTeamId)
            default:
                throw JSONSerializerError.deserializeError(type: MemberTransferredInternalFields.self, json: json)
            }
        }
    }

    /// Enabled/disabled Microsoft Office add-in.
    public class MicrosoftOfficeAddinChangePolicyDetails: CustomStringConvertible, JSONRepresentable {
        /// New Microsoft Office addin policy.
        public let newValue: TeamLog.MicrosoftOfficeAddinPolicy
        /// Previous Microsoft Office addin policy. Might be missing due to historical data gap.
        public let previousValue: TeamLog.MicrosoftOfficeAddinPolicy?
        public init(newValue: TeamLog.MicrosoftOfficeAddinPolicy, previousValue: TeamLog.MicrosoftOfficeAddinPolicy? = nil) {
            self.newValue = newValue
            self.previousValue = previousValue
        }

        func json() throws -> JSON {
            try MicrosoftOfficeAddinChangePolicyDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try MicrosoftOfficeAddinChangePolicyDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for MicrosoftOfficeAddinChangePolicyDetails: \(error)"
            }
        }
    }

    public class MicrosoftOfficeAddinChangePolicyDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: MicrosoftOfficeAddinChangePolicyDetails) throws -> JSON {
            let output = [
                "new_value": try TeamLog.MicrosoftOfficeAddinPolicySerializer().serialize(value.newValue),
                "previous_value": try NullableSerializer(TeamLog.MicrosoftOfficeAddinPolicySerializer()).serialize(value.previousValue),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> MicrosoftOfficeAddinChangePolicyDetails {
            switch json {
            case .dictionary(let dict):
                let newValue = try TeamLog.MicrosoftOfficeAddinPolicySerializer().deserialize(dict["new_value"] ?? .null)
                let previousValue = try NullableSerializer(TeamLog.MicrosoftOfficeAddinPolicySerializer()).deserialize(dict["previous_value"] ?? .null)
                return MicrosoftOfficeAddinChangePolicyDetails(newValue: newValue, previousValue: previousValue)
            default:
                throw JSONSerializerError.deserializeError(type: MicrosoftOfficeAddinChangePolicyDetails.self, json: json)
            }
        }
    }

    /// The MicrosoftOfficeAddinChangePolicyType struct
    public class MicrosoftOfficeAddinChangePolicyType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try MicrosoftOfficeAddinChangePolicyTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try MicrosoftOfficeAddinChangePolicyTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for MicrosoftOfficeAddinChangePolicyType: \(error)"
            }
        }
    }

    public class MicrosoftOfficeAddinChangePolicyTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: MicrosoftOfficeAddinChangePolicyType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> MicrosoftOfficeAddinChangePolicyType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return MicrosoftOfficeAddinChangePolicyType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: MicrosoftOfficeAddinChangePolicyType.self, json: json)
            }
        }
    }

    /// Microsoft Office addin policy
    public enum MicrosoftOfficeAddinPolicy: CustomStringConvertible, JSONRepresentable {
        /// An unspecified error.
        case disabled
        /// An unspecified error.
        case enabled
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try MicrosoftOfficeAddinPolicySerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try MicrosoftOfficeAddinPolicySerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for MicrosoftOfficeAddinPolicy: \(error)"
            }
        }
    }

    public class MicrosoftOfficeAddinPolicySerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: MicrosoftOfficeAddinPolicy) throws -> JSON {
            switch value {
            case .disabled:
                var d = [String: JSON]()
                d[".tag"] = .str("disabled")
                return .dictionary(d)
            case .enabled:
                var d = [String: JSON]()
                d[".tag"] = .str("enabled")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> MicrosoftOfficeAddinPolicy {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "disabled":
                    return MicrosoftOfficeAddinPolicy.disabled
                case "enabled":
                    return MicrosoftOfficeAddinPolicy.enabled
                case "other":
                    return MicrosoftOfficeAddinPolicy.other
                default:
                    return MicrosoftOfficeAddinPolicy.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: MicrosoftOfficeAddinPolicy.self, json: json)
            }
        }
    }

    /// An indication that an error occurred while retrieving the event. Some attributes of the event may be omitted as
    /// a result.
    public class MissingDetails: CustomStringConvertible, JSONRepresentable {
        /// All the data that could be retrieved and converted from the source event.
        public let sourceEventFields: String?
        public init(sourceEventFields: String? = nil) {
            nullableValidator(stringValidator())(sourceEventFields)
            self.sourceEventFields = sourceEventFields
        }

        func json() throws -> JSON {
            try MissingDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try MissingDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for MissingDetails: \(error)"
            }
        }
    }

    public class MissingDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: MissingDetails) throws -> JSON {
            let output = [
                "source_event_fields": try NullableSerializer(Serialization._StringSerializer).serialize(value.sourceEventFields),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> MissingDetails {
            switch json {
            case .dictionary(let dict):
                let sourceEventFields = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["source_event_fields"] ?? .null)
                return MissingDetails(sourceEventFields: sourceEventFields)
            default:
                throw JSONSerializerError.deserializeError(type: MissingDetails.self, json: json)
            }
        }
    }

    /// Information about linked Dropbox mobile client sessions
    public class MobileDeviceSessionLogInfo: TeamLog.DeviceSessionLogInfo {
        /// Mobile session unique id.
        public let sessionInfo: TeamLog.MobileSessionLogInfo?
        /// The device name.
        public let deviceName: String
        /// The mobile application type.
        public let clientType: Team.MobileClientPlatform
        /// The Dropbox client version.
        public let clientVersion: String?
        /// The hosting OS version.
        public let osVersion: String?
        /// last carrier used by the device.
        public let lastCarrier: String?
        public init(
            deviceName: String,
            clientType: Team.MobileClientPlatform,
            ipAddress: String? = nil,
            created: Date? = nil,
            updated: Date? = nil,
            sessionInfo: TeamLog.MobileSessionLogInfo? = nil,
            clientVersion: String? = nil,
            osVersion: String? = nil,
            lastCarrier: String? = nil
        ) {
            self.sessionInfo = sessionInfo
            stringValidator()(deviceName)
            self.deviceName = deviceName
            self.clientType = clientType
            nullableValidator(stringValidator())(clientVersion)
            self.clientVersion = clientVersion
            nullableValidator(stringValidator())(osVersion)
            self.osVersion = osVersion
            nullableValidator(stringValidator())(lastCarrier)
            self.lastCarrier = lastCarrier
            super.init(ipAddress: ipAddress, created: created, updated: updated)
        }

        public override var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try MobileDeviceSessionLogInfoSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for MobileDeviceSessionLogInfo: \(error)"
            }
        }
    }

    public class MobileDeviceSessionLogInfoSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: MobileDeviceSessionLogInfo) throws -> JSON {
            let output = [
                "device_name": try Serialization._StringSerializer.serialize(value.deviceName),
                "client_type": try Team.MobileClientPlatformSerializer().serialize(value.clientType),
                "ip_address": try NullableSerializer(Serialization._StringSerializer).serialize(value.ipAddress),
                "created": try NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.created),
                "updated": try NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.updated),
                "session_info": try NullableSerializer(TeamLog.MobileSessionLogInfoSerializer()).serialize(value.sessionInfo),
                "client_version": try NullableSerializer(Serialization._StringSerializer).serialize(value.clientVersion),
                "os_version": try NullableSerializer(Serialization._StringSerializer).serialize(value.osVersion),
                "last_carrier": try NullableSerializer(Serialization._StringSerializer).serialize(value.lastCarrier),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> MobileDeviceSessionLogInfo {
            switch json {
            case .dictionary(let dict):
                let deviceName = try Serialization._StringSerializer.deserialize(dict["device_name"] ?? .null)
                let clientType = try Team.MobileClientPlatformSerializer().deserialize(dict["client_type"] ?? .null)
                let ipAddress = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["ip_address"] ?? .null)
                let created = try NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).deserialize(dict["created"] ?? .null)
                let updated = try NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).deserialize(dict["updated"] ?? .null)
                let sessionInfo = try NullableSerializer(TeamLog.MobileSessionLogInfoSerializer()).deserialize(dict["session_info"] ?? .null)
                let clientVersion = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["client_version"] ?? .null)
                let osVersion = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["os_version"] ?? .null)
                let lastCarrier = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["last_carrier"] ?? .null)
                return MobileDeviceSessionLogInfo(
                    deviceName: deviceName,
                    clientType: clientType,
                    ipAddress: ipAddress,
                    created: created,
                    updated: updated,
                    sessionInfo: sessionInfo,
                    clientVersion: clientVersion,
                    osVersion: osVersion,
                    lastCarrier: lastCarrier
                )
            default:
                throw JSONSerializerError.deserializeError(type: MobileDeviceSessionLogInfo.self, json: json)
            }
        }
    }

    /// Mobile session.
    public class MobileSessionLogInfo: TeamLog.SessionLogInfo {
        public override var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try MobileSessionLogInfoSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for MobileSessionLogInfo: \(error)"
            }
        }
    }

    public class MobileSessionLogInfoSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: MobileSessionLogInfo) throws -> JSON {
            let output = [
                "session_id": try NullableSerializer(Serialization._StringSerializer).serialize(value.sessionId),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> MobileSessionLogInfo {
            switch json {
            case .dictionary(let dict):
                let sessionId = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["session_id"] ?? .null)
                return MobileSessionLogInfo(sessionId: sessionId)
            default:
                throw JSONSerializerError.deserializeError(type: MobileSessionLogInfo.self, json: json)
            }
        }
    }

    /// Namespace relative path details.
    public class NamespaceRelativePathLogInfo: CustomStringConvertible, JSONRepresentable {
        /// Namespace ID.
        public let nsId: String?
        /// A path relative to the specified namespace ID.
        public let relativePath: String?
        /// True if the namespace is shared.
        public let isSharedNamespace: Bool?
        public init(nsId: String? = nil, relativePath: String? = nil, isSharedNamespace: Bool? = nil) {
            nullableValidator(stringValidator())(nsId)
            self.nsId = nsId
            nullableValidator(stringValidator())(relativePath)
            self.relativePath = relativePath
            self.isSharedNamespace = isSharedNamespace
        }

        func json() throws -> JSON {
            try NamespaceRelativePathLogInfoSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try NamespaceRelativePathLogInfoSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for NamespaceRelativePathLogInfo: \(error)"
            }
        }
    }

    public class NamespaceRelativePathLogInfoSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: NamespaceRelativePathLogInfo) throws -> JSON {
            let output = [
                "ns_id": try NullableSerializer(Serialization._StringSerializer).serialize(value.nsId),
                "relative_path": try NullableSerializer(Serialization._StringSerializer).serialize(value.relativePath),
                "is_shared_namespace": try NullableSerializer(Serialization._BoolSerializer).serialize(value.isSharedNamespace),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> NamespaceRelativePathLogInfo {
            switch json {
            case .dictionary(let dict):
                let nsId = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["ns_id"] ?? .null)
                let relativePath = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["relative_path"] ?? .null)
                let isSharedNamespace = try NullableSerializer(Serialization._BoolSerializer).deserialize(dict["is_shared_namespace"] ?? .null)
                return NamespaceRelativePathLogInfo(nsId: nsId, relativePath: relativePath, isSharedNamespace: isSharedNamespace)
            default:
                throw JSONSerializerError.deserializeError(type: NamespaceRelativePathLogInfo.self, json: json)
            }
        }
    }

    /// Enabled/disabled network control.
    public class NetworkControlChangePolicyDetails: CustomStringConvertible, JSONRepresentable {
        /// New network control policy.
        public let newValue: TeamLog.NetworkControlPolicy
        /// Previous network control policy. Might be missing due to historical data gap.
        public let previousValue: TeamLog.NetworkControlPolicy?
        public init(newValue: TeamLog.NetworkControlPolicy, previousValue: TeamLog.NetworkControlPolicy? = nil) {
            self.newValue = newValue
            self.previousValue = previousValue
        }

        func json() throws -> JSON {
            try NetworkControlChangePolicyDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try NetworkControlChangePolicyDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for NetworkControlChangePolicyDetails: \(error)"
            }
        }
    }

    public class NetworkControlChangePolicyDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: NetworkControlChangePolicyDetails) throws -> JSON {
            let output = [
                "new_value": try TeamLog.NetworkControlPolicySerializer().serialize(value.newValue),
                "previous_value": try NullableSerializer(TeamLog.NetworkControlPolicySerializer()).serialize(value.previousValue),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> NetworkControlChangePolicyDetails {
            switch json {
            case .dictionary(let dict):
                let newValue = try TeamLog.NetworkControlPolicySerializer().deserialize(dict["new_value"] ?? .null)
                let previousValue = try NullableSerializer(TeamLog.NetworkControlPolicySerializer()).deserialize(dict["previous_value"] ?? .null)
                return NetworkControlChangePolicyDetails(newValue: newValue, previousValue: previousValue)
            default:
                throw JSONSerializerError.deserializeError(type: NetworkControlChangePolicyDetails.self, json: json)
            }
        }
    }

    /// The NetworkControlChangePolicyType struct
    public class NetworkControlChangePolicyType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try NetworkControlChangePolicyTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try NetworkControlChangePolicyTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for NetworkControlChangePolicyType: \(error)"
            }
        }
    }

    public class NetworkControlChangePolicyTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: NetworkControlChangePolicyType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> NetworkControlChangePolicyType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return NetworkControlChangePolicyType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: NetworkControlChangePolicyType.self, json: json)
            }
        }
    }

    /// Network control policy
    public enum NetworkControlPolicy: CustomStringConvertible, JSONRepresentable {
        /// An unspecified error.
        case disabled
        /// An unspecified error.
        case enabled
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try NetworkControlPolicySerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try NetworkControlPolicySerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for NetworkControlPolicy: \(error)"
            }
        }
    }

    public class NetworkControlPolicySerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: NetworkControlPolicy) throws -> JSON {
            switch value {
            case .disabled:
                var d = [String: JSON]()
                d[".tag"] = .str("disabled")
                return .dictionary(d)
            case .enabled:
                var d = [String: JSON]()
                d[".tag"] = .str("enabled")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> NetworkControlPolicy {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "disabled":
                    return NetworkControlPolicy.disabled
                case "enabled":
                    return NetworkControlPolicy.enabled
                case "other":
                    return NetworkControlPolicy.other
                default:
                    return NetworkControlPolicy.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: NetworkControlPolicy.self, json: json)
            }
        }
    }

    /// Report created: Links created with no expiration.
    public class NoExpirationLinkGenCreateReportDetails: CustomStringConvertible, JSONRepresentable {
        /// Report start date.
        public let startDate: Date
        /// Report end date.
        public let endDate: Date
        public init(startDate: Date, endDate: Date) {
            self.startDate = startDate
            self.endDate = endDate
        }

        func json() throws -> JSON {
            try NoExpirationLinkGenCreateReportDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try NoExpirationLinkGenCreateReportDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for NoExpirationLinkGenCreateReportDetails: \(error)"
            }
        }
    }

    public class NoExpirationLinkGenCreateReportDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: NoExpirationLinkGenCreateReportDetails) throws -> JSON {
            let output = [
                "start_date": try NSDateSerializer("%Y-%m-%dT%H:%M:%SZ").serialize(value.startDate),
                "end_date": try NSDateSerializer("%Y-%m-%dT%H:%M:%SZ").serialize(value.endDate),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> NoExpirationLinkGenCreateReportDetails {
            switch json {
            case .dictionary(let dict):
                let startDate = try NSDateSerializer("%Y-%m-%dT%H:%M:%SZ").deserialize(dict["start_date"] ?? .null)
                let endDate = try NSDateSerializer("%Y-%m-%dT%H:%M:%SZ").deserialize(dict["end_date"] ?? .null)
                return NoExpirationLinkGenCreateReportDetails(startDate: startDate, endDate: endDate)
            default:
                throw JSONSerializerError.deserializeError(type: NoExpirationLinkGenCreateReportDetails.self, json: json)
            }
        }
    }

    /// The NoExpirationLinkGenCreateReportType struct
    public class NoExpirationLinkGenCreateReportType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try NoExpirationLinkGenCreateReportTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try NoExpirationLinkGenCreateReportTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for NoExpirationLinkGenCreateReportType: \(error)"
            }
        }
    }

    public class NoExpirationLinkGenCreateReportTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: NoExpirationLinkGenCreateReportType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> NoExpirationLinkGenCreateReportType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return NoExpirationLinkGenCreateReportType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: NoExpirationLinkGenCreateReportType.self, json: json)
            }
        }
    }

    /// Couldn't create report: Links created with no expiration.
    public class NoExpirationLinkGenReportFailedDetails: CustomStringConvertible, JSONRepresentable {
        /// Failure reason.
        public let failureReason: Team.TeamReportFailureReason
        public init(failureReason: Team.TeamReportFailureReason) {
            self.failureReason = failureReason
        }

        func json() throws -> JSON {
            try NoExpirationLinkGenReportFailedDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try NoExpirationLinkGenReportFailedDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for NoExpirationLinkGenReportFailedDetails: \(error)"
            }
        }
    }

    public class NoExpirationLinkGenReportFailedDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: NoExpirationLinkGenReportFailedDetails) throws -> JSON {
            let output = [
                "failure_reason": try Team.TeamReportFailureReasonSerializer().serialize(value.failureReason),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> NoExpirationLinkGenReportFailedDetails {
            switch json {
            case .dictionary(let dict):
                let failureReason = try Team.TeamReportFailureReasonSerializer().deserialize(dict["failure_reason"] ?? .null)
                return NoExpirationLinkGenReportFailedDetails(failureReason: failureReason)
            default:
                throw JSONSerializerError.deserializeError(type: NoExpirationLinkGenReportFailedDetails.self, json: json)
            }
        }
    }

    /// The NoExpirationLinkGenReportFailedType struct
    public class NoExpirationLinkGenReportFailedType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try NoExpirationLinkGenReportFailedTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try NoExpirationLinkGenReportFailedTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for NoExpirationLinkGenReportFailedType: \(error)"
            }
        }
    }

    public class NoExpirationLinkGenReportFailedTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: NoExpirationLinkGenReportFailedType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> NoExpirationLinkGenReportFailedType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return NoExpirationLinkGenReportFailedType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: NoExpirationLinkGenReportFailedType.self, json: json)
            }
        }
    }

    /// Report created: Links created without passwords.
    public class NoPasswordLinkGenCreateReportDetails: CustomStringConvertible, JSONRepresentable {
        /// Report start date.
        public let startDate: Date
        /// Report end date.
        public let endDate: Date
        public init(startDate: Date, endDate: Date) {
            self.startDate = startDate
            self.endDate = endDate
        }

        func json() throws -> JSON {
            try NoPasswordLinkGenCreateReportDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try NoPasswordLinkGenCreateReportDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for NoPasswordLinkGenCreateReportDetails: \(error)"
            }
        }
    }

    public class NoPasswordLinkGenCreateReportDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: NoPasswordLinkGenCreateReportDetails) throws -> JSON {
            let output = [
                "start_date": try NSDateSerializer("%Y-%m-%dT%H:%M:%SZ").serialize(value.startDate),
                "end_date": try NSDateSerializer("%Y-%m-%dT%H:%M:%SZ").serialize(value.endDate),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> NoPasswordLinkGenCreateReportDetails {
            switch json {
            case .dictionary(let dict):
                let startDate = try NSDateSerializer("%Y-%m-%dT%H:%M:%SZ").deserialize(dict["start_date"] ?? .null)
                let endDate = try NSDateSerializer("%Y-%m-%dT%H:%M:%SZ").deserialize(dict["end_date"] ?? .null)
                return NoPasswordLinkGenCreateReportDetails(startDate: startDate, endDate: endDate)
            default:
                throw JSONSerializerError.deserializeError(type: NoPasswordLinkGenCreateReportDetails.self, json: json)
            }
        }
    }

    /// The NoPasswordLinkGenCreateReportType struct
    public class NoPasswordLinkGenCreateReportType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try NoPasswordLinkGenCreateReportTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try NoPasswordLinkGenCreateReportTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for NoPasswordLinkGenCreateReportType: \(error)"
            }
        }
    }

    public class NoPasswordLinkGenCreateReportTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: NoPasswordLinkGenCreateReportType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> NoPasswordLinkGenCreateReportType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return NoPasswordLinkGenCreateReportType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: NoPasswordLinkGenCreateReportType.self, json: json)
            }
        }
    }

    /// Couldn't create report: Links created without passwords.
    public class NoPasswordLinkGenReportFailedDetails: CustomStringConvertible, JSONRepresentable {
        /// Failure reason.
        public let failureReason: Team.TeamReportFailureReason
        public init(failureReason: Team.TeamReportFailureReason) {
            self.failureReason = failureReason
        }

        func json() throws -> JSON {
            try NoPasswordLinkGenReportFailedDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try NoPasswordLinkGenReportFailedDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for NoPasswordLinkGenReportFailedDetails: \(error)"
            }
        }
    }

    public class NoPasswordLinkGenReportFailedDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: NoPasswordLinkGenReportFailedDetails) throws -> JSON {
            let output = [
                "failure_reason": try Team.TeamReportFailureReasonSerializer().serialize(value.failureReason),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> NoPasswordLinkGenReportFailedDetails {
            switch json {
            case .dictionary(let dict):
                let failureReason = try Team.TeamReportFailureReasonSerializer().deserialize(dict["failure_reason"] ?? .null)
                return NoPasswordLinkGenReportFailedDetails(failureReason: failureReason)
            default:
                throw JSONSerializerError.deserializeError(type: NoPasswordLinkGenReportFailedDetails.self, json: json)
            }
        }
    }

    /// The NoPasswordLinkGenReportFailedType struct
    public class NoPasswordLinkGenReportFailedType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try NoPasswordLinkGenReportFailedTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try NoPasswordLinkGenReportFailedTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for NoPasswordLinkGenReportFailedType: \(error)"
            }
        }
    }

    public class NoPasswordLinkGenReportFailedTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: NoPasswordLinkGenReportFailedType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> NoPasswordLinkGenReportFailedType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return NoPasswordLinkGenReportFailedType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: NoPasswordLinkGenReportFailedType.self, json: json)
            }
        }
    }

    /// Report created: Views of links without passwords.
    public class NoPasswordLinkViewCreateReportDetails: CustomStringConvertible, JSONRepresentable {
        /// Report start date.
        public let startDate: Date
        /// Report end date.
        public let endDate: Date
        public init(startDate: Date, endDate: Date) {
            self.startDate = startDate
            self.endDate = endDate
        }

        func json() throws -> JSON {
            try NoPasswordLinkViewCreateReportDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try NoPasswordLinkViewCreateReportDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for NoPasswordLinkViewCreateReportDetails: \(error)"
            }
        }
    }

    public class NoPasswordLinkViewCreateReportDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: NoPasswordLinkViewCreateReportDetails) throws -> JSON {
            let output = [
                "start_date": try NSDateSerializer("%Y-%m-%dT%H:%M:%SZ").serialize(value.startDate),
                "end_date": try NSDateSerializer("%Y-%m-%dT%H:%M:%SZ").serialize(value.endDate),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> NoPasswordLinkViewCreateReportDetails {
            switch json {
            case .dictionary(let dict):
                let startDate = try NSDateSerializer("%Y-%m-%dT%H:%M:%SZ").deserialize(dict["start_date"] ?? .null)
                let endDate = try NSDateSerializer("%Y-%m-%dT%H:%M:%SZ").deserialize(dict["end_date"] ?? .null)
                return NoPasswordLinkViewCreateReportDetails(startDate: startDate, endDate: endDate)
            default:
                throw JSONSerializerError.deserializeError(type: NoPasswordLinkViewCreateReportDetails.self, json: json)
            }
        }
    }

    /// The NoPasswordLinkViewCreateReportType struct
    public class NoPasswordLinkViewCreateReportType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try NoPasswordLinkViewCreateReportTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try NoPasswordLinkViewCreateReportTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for NoPasswordLinkViewCreateReportType: \(error)"
            }
        }
    }

    public class NoPasswordLinkViewCreateReportTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: NoPasswordLinkViewCreateReportType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> NoPasswordLinkViewCreateReportType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return NoPasswordLinkViewCreateReportType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: NoPasswordLinkViewCreateReportType.self, json: json)
            }
        }
    }

    /// Couldn't create report: Views of links without passwords.
    public class NoPasswordLinkViewReportFailedDetails: CustomStringConvertible, JSONRepresentable {
        /// Failure reason.
        public let failureReason: Team.TeamReportFailureReason
        public init(failureReason: Team.TeamReportFailureReason) {
            self.failureReason = failureReason
        }

        func json() throws -> JSON {
            try NoPasswordLinkViewReportFailedDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try NoPasswordLinkViewReportFailedDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for NoPasswordLinkViewReportFailedDetails: \(error)"
            }
        }
    }

    public class NoPasswordLinkViewReportFailedDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: NoPasswordLinkViewReportFailedDetails) throws -> JSON {
            let output = [
                "failure_reason": try Team.TeamReportFailureReasonSerializer().serialize(value.failureReason),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> NoPasswordLinkViewReportFailedDetails {
            switch json {
            case .dictionary(let dict):
                let failureReason = try Team.TeamReportFailureReasonSerializer().deserialize(dict["failure_reason"] ?? .null)
                return NoPasswordLinkViewReportFailedDetails(failureReason: failureReason)
            default:
                throw JSONSerializerError.deserializeError(type: NoPasswordLinkViewReportFailedDetails.self, json: json)
            }
        }
    }

    /// The NoPasswordLinkViewReportFailedType struct
    public class NoPasswordLinkViewReportFailedType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try NoPasswordLinkViewReportFailedTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try NoPasswordLinkViewReportFailedTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for NoPasswordLinkViewReportFailedType: \(error)"
            }
        }
    }

    public class NoPasswordLinkViewReportFailedTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: NoPasswordLinkViewReportFailedType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> NoPasswordLinkViewReportFailedType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return NoPasswordLinkViewReportFailedType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: NoPasswordLinkViewReportFailedType.self, json: json)
            }
        }
    }

    /// User's logged information.
    public class UserLogInfo: CustomStringConvertible, JSONRepresentable {
        /// User unique ID.
        public let accountId: String?
        /// User display name.
        public let displayName: String?
        /// User email address.
        public let email: String?
        public init(accountId: String? = nil, displayName: String? = nil, email: String? = nil) {
            nullableValidator(stringValidator(minLength: 40, maxLength: 40))(accountId)
            self.accountId = accountId
            nullableValidator(stringValidator())(displayName)
            self.displayName = displayName
            nullableValidator(stringValidator(maxLength: 255))(email)
            self.email = email
        }

        func json() throws -> JSON {
            try UserLogInfoSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try UserLogInfoSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for UserLogInfo: \(error)"
            }
        }
    }

    public class UserLogInfoSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: UserLogInfo) throws -> JSON {
            var output = [
                "account_id": try NullableSerializer(Serialization._StringSerializer).serialize(value.accountId),
                "display_name": try NullableSerializer(Serialization._StringSerializer).serialize(value.displayName),
                "email": try NullableSerializer(Serialization._StringSerializer).serialize(value.email),
            ]
            switch value {
            case let teamMember as TeamLog.TeamMemberLogInfo:
                for (k, v) in try Serialization.getFields(TeamLog.TeamMemberLogInfoSerializer().serialize(teamMember)) {
                    output[k] = v
                }
                output[".tag"] = .str("team_member")
            case let trustedNonTeamMember as TeamLog.TrustedNonTeamMemberLogInfo:
                for (k, v) in try Serialization.getFields(TeamLog.TrustedNonTeamMemberLogInfoSerializer().serialize(trustedNonTeamMember)) {
                    output[k] = v
                }
                output[".tag"] = .str("trusted_non_team_member")
            case let nonTeamMember as TeamLog.NonTeamMemberLogInfo:
                for (k, v) in try Serialization.getFields(TeamLog.NonTeamMemberLogInfoSerializer().serialize(nonTeamMember)) {
                    output[k] = v
                }
                output[".tag"] = .str("non_team_member")
            default:
                throw JSONSerializerError.unexpectedSubtype(type: UserLogInfo.self, subtype: value)
            }
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> UserLogInfo {
            switch json {
            case .dictionary(let dict):
                let tag = try Serialization.getTag(dict)
                switch tag {
                case "team_member":
                    return try TeamLog.TeamMemberLogInfoSerializer().deserialize(json)
                case "trusted_non_team_member":
                    return try TeamLog.TrustedNonTeamMemberLogInfoSerializer().deserialize(json)
                case "non_team_member":
                    return try TeamLog.NonTeamMemberLogInfoSerializer().deserialize(json)
                default:
                    let accountId = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["account_id"] ?? .null)
                    let displayName = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["display_name"] ?? .null)
                    let email = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["email"] ?? .null)
                    return UserLogInfo(accountId: accountId, displayName: displayName, email: email)
                }
            default:
                throw JSONSerializerError.deserializeError(type: UserLogInfo.self, json: json)
            }
        }
    }

    /// Non team member's logged information.
    public class NonTeamMemberLogInfo: TeamLog.UserLogInfo {
        public override var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try NonTeamMemberLogInfoSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for NonTeamMemberLogInfo: \(error)"
            }
        }
    }

    public class NonTeamMemberLogInfoSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: NonTeamMemberLogInfo) throws -> JSON {
            let output = [
                "account_id": try NullableSerializer(Serialization._StringSerializer).serialize(value.accountId),
                "display_name": try NullableSerializer(Serialization._StringSerializer).serialize(value.displayName),
                "email": try NullableSerializer(Serialization._StringSerializer).serialize(value.email),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> NonTeamMemberLogInfo {
            switch json {
            case .dictionary(let dict):
                let accountId = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["account_id"] ?? .null)
                let displayName = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["display_name"] ?? .null)
                let email = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["email"] ?? .null)
                return NonTeamMemberLogInfo(accountId: accountId, displayName: displayName, email: email)
            default:
                throw JSONSerializerError.deserializeError(type: NonTeamMemberLogInfo.self, json: json)
            }
        }
    }

    /// The email to which the request was sent
    public class NonTrustedTeamDetails: CustomStringConvertible, JSONRepresentable {
        /// The email to which the request was sent.
        public let team: String
        public init(team: String) {
            stringValidator()(team)
            self.team = team
        }

        func json() throws -> JSON {
            try NonTrustedTeamDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try NonTrustedTeamDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for NonTrustedTeamDetails: \(error)"
            }
        }
    }

    public class NonTrustedTeamDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: NonTrustedTeamDetails) throws -> JSON {
            let output = [
                "team": try Serialization._StringSerializer.serialize(value.team),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> NonTrustedTeamDetails {
            switch json {
            case .dictionary(let dict):
                let team = try Serialization._StringSerializer.deserialize(dict["team"] ?? .null)
                return NonTrustedTeamDetails(team: team)
            default:
                throw JSONSerializerError.deserializeError(type: NonTrustedTeamDetails.self, json: json)
            }
        }
    }

    /// Changed Paper doc to invite-only.
    public class NoteAclInviteOnlyDetails: CustomStringConvertible, JSONRepresentable {
        func json() throws -> JSON {
            try NoteAclInviteOnlyDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try NoteAclInviteOnlyDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for NoteAclInviteOnlyDetails: \(error)"
            }
        }
    }

    public class NoteAclInviteOnlyDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: NoteAclInviteOnlyDetails) throws -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> NoteAclInviteOnlyDetails {
            switch json {
            case .dictionary:
                return NoteAclInviteOnlyDetails()
            default:
                throw JSONSerializerError.deserializeError(type: NoteAclInviteOnlyDetails.self, json: json)
            }
        }
    }

    /// The NoteAclInviteOnlyType struct
    public class NoteAclInviteOnlyType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try NoteAclInviteOnlyTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try NoteAclInviteOnlyTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for NoteAclInviteOnlyType: \(error)"
            }
        }
    }

    public class NoteAclInviteOnlyTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: NoteAclInviteOnlyType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> NoteAclInviteOnlyType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return NoteAclInviteOnlyType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: NoteAclInviteOnlyType.self, json: json)
            }
        }
    }

    /// Changed Paper doc to link-accessible.
    public class NoteAclLinkDetails: CustomStringConvertible, JSONRepresentable {
        func json() throws -> JSON {
            try NoteAclLinkDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try NoteAclLinkDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for NoteAclLinkDetails: \(error)"
            }
        }
    }

    public class NoteAclLinkDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: NoteAclLinkDetails) throws -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> NoteAclLinkDetails {
            switch json {
            case .dictionary:
                return NoteAclLinkDetails()
            default:
                throw JSONSerializerError.deserializeError(type: NoteAclLinkDetails.self, json: json)
            }
        }
    }

    /// The NoteAclLinkType struct
    public class NoteAclLinkType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try NoteAclLinkTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try NoteAclLinkTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for NoteAclLinkType: \(error)"
            }
        }
    }

    public class NoteAclLinkTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: NoteAclLinkType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> NoteAclLinkType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return NoteAclLinkType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: NoteAclLinkType.self, json: json)
            }
        }
    }

    /// Changed Paper doc to link-accessible for team.
    public class NoteAclTeamLinkDetails: CustomStringConvertible, JSONRepresentable {
        func json() throws -> JSON {
            try NoteAclTeamLinkDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try NoteAclTeamLinkDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for NoteAclTeamLinkDetails: \(error)"
            }
        }
    }

    public class NoteAclTeamLinkDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: NoteAclTeamLinkDetails) throws -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> NoteAclTeamLinkDetails {
            switch json {
            case .dictionary:
                return NoteAclTeamLinkDetails()
            default:
                throw JSONSerializerError.deserializeError(type: NoteAclTeamLinkDetails.self, json: json)
            }
        }
    }

    /// The NoteAclTeamLinkType struct
    public class NoteAclTeamLinkType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try NoteAclTeamLinkTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try NoteAclTeamLinkTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for NoteAclTeamLinkType: \(error)"
            }
        }
    }

    public class NoteAclTeamLinkTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: NoteAclTeamLinkType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> NoteAclTeamLinkType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return NoteAclTeamLinkType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: NoteAclTeamLinkType.self, json: json)
            }
        }
    }

    /// Shared received Paper doc.
    public class NoteShareReceiveDetails: CustomStringConvertible, JSONRepresentable {
        func json() throws -> JSON {
            try NoteShareReceiveDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try NoteShareReceiveDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for NoteShareReceiveDetails: \(error)"
            }
        }
    }

    public class NoteShareReceiveDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: NoteShareReceiveDetails) throws -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> NoteShareReceiveDetails {
            switch json {
            case .dictionary:
                return NoteShareReceiveDetails()
            default:
                throw JSONSerializerError.deserializeError(type: NoteShareReceiveDetails.self, json: json)
            }
        }
    }

    /// The NoteShareReceiveType struct
    public class NoteShareReceiveType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try NoteShareReceiveTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try NoteShareReceiveTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for NoteShareReceiveType: \(error)"
            }
        }
    }

    public class NoteShareReceiveTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: NoteShareReceiveType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> NoteShareReceiveType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return NoteShareReceiveType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: NoteShareReceiveType.self, json: json)
            }
        }
    }

    /// Shared Paper doc.
    public class NoteSharedDetails: CustomStringConvertible, JSONRepresentable {
        func json() throws -> JSON {
            try NoteSharedDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try NoteSharedDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for NoteSharedDetails: \(error)"
            }
        }
    }

    public class NoteSharedDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: NoteSharedDetails) throws -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> NoteSharedDetails {
            switch json {
            case .dictionary:
                return NoteSharedDetails()
            default:
                throw JSONSerializerError.deserializeError(type: NoteSharedDetails.self, json: json)
            }
        }
    }

    /// The NoteSharedType struct
    public class NoteSharedType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try NoteSharedTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try NoteSharedTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for NoteSharedType: \(error)"
            }
        }
    }

    public class NoteSharedTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: NoteSharedType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> NoteSharedType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return NoteSharedType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: NoteSharedType.self, json: json)
            }
        }
    }

    /// Added a label.
    public class ObjectLabelAddedDetails: CustomStringConvertible, JSONRepresentable {
        /// Labels mark a file or folder.
        public let labelType: TeamLog.LabelType
        public init(labelType: TeamLog.LabelType) {
            self.labelType = labelType
        }

        func json() throws -> JSON {
            try ObjectLabelAddedDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ObjectLabelAddedDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ObjectLabelAddedDetails: \(error)"
            }
        }
    }

    public class ObjectLabelAddedDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ObjectLabelAddedDetails) throws -> JSON {
            let output = [
                "label_type": try TeamLog.LabelTypeSerializer().serialize(value.labelType),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ObjectLabelAddedDetails {
            switch json {
            case .dictionary(let dict):
                let labelType = try TeamLog.LabelTypeSerializer().deserialize(dict["label_type"] ?? .null)
                return ObjectLabelAddedDetails(labelType: labelType)
            default:
                throw JSONSerializerError.deserializeError(type: ObjectLabelAddedDetails.self, json: json)
            }
        }
    }

    /// The ObjectLabelAddedType struct
    public class ObjectLabelAddedType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try ObjectLabelAddedTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ObjectLabelAddedTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ObjectLabelAddedType: \(error)"
            }
        }
    }

    public class ObjectLabelAddedTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ObjectLabelAddedType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ObjectLabelAddedType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return ObjectLabelAddedType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: ObjectLabelAddedType.self, json: json)
            }
        }
    }

    /// Removed a label.
    public class ObjectLabelRemovedDetails: CustomStringConvertible, JSONRepresentable {
        /// Labels mark a file or folder.
        public let labelType: TeamLog.LabelType
        public init(labelType: TeamLog.LabelType) {
            self.labelType = labelType
        }

        func json() throws -> JSON {
            try ObjectLabelRemovedDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ObjectLabelRemovedDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ObjectLabelRemovedDetails: \(error)"
            }
        }
    }

    public class ObjectLabelRemovedDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ObjectLabelRemovedDetails) throws -> JSON {
            let output = [
                "label_type": try TeamLog.LabelTypeSerializer().serialize(value.labelType),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ObjectLabelRemovedDetails {
            switch json {
            case .dictionary(let dict):
                let labelType = try TeamLog.LabelTypeSerializer().deserialize(dict["label_type"] ?? .null)
                return ObjectLabelRemovedDetails(labelType: labelType)
            default:
                throw JSONSerializerError.deserializeError(type: ObjectLabelRemovedDetails.self, json: json)
            }
        }
    }

    /// The ObjectLabelRemovedType struct
    public class ObjectLabelRemovedType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try ObjectLabelRemovedTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ObjectLabelRemovedTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ObjectLabelRemovedType: \(error)"
            }
        }
    }

    public class ObjectLabelRemovedTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ObjectLabelRemovedType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ObjectLabelRemovedType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return ObjectLabelRemovedType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: ObjectLabelRemovedType.self, json: json)
            }
        }
    }

    /// Updated a label's value.
    public class ObjectLabelUpdatedValueDetails: CustomStringConvertible, JSONRepresentable {
        /// Labels mark a file or folder.
        public let labelType: TeamLog.LabelType
        public init(labelType: TeamLog.LabelType) {
            self.labelType = labelType
        }

        func json() throws -> JSON {
            try ObjectLabelUpdatedValueDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ObjectLabelUpdatedValueDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ObjectLabelUpdatedValueDetails: \(error)"
            }
        }
    }

    public class ObjectLabelUpdatedValueDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ObjectLabelUpdatedValueDetails) throws -> JSON {
            let output = [
                "label_type": try TeamLog.LabelTypeSerializer().serialize(value.labelType),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ObjectLabelUpdatedValueDetails {
            switch json {
            case .dictionary(let dict):
                let labelType = try TeamLog.LabelTypeSerializer().deserialize(dict["label_type"] ?? .null)
                return ObjectLabelUpdatedValueDetails(labelType: labelType)
            default:
                throw JSONSerializerError.deserializeError(type: ObjectLabelUpdatedValueDetails.self, json: json)
            }
        }
    }

    /// The ObjectLabelUpdatedValueType struct
    public class ObjectLabelUpdatedValueType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try ObjectLabelUpdatedValueTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ObjectLabelUpdatedValueTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ObjectLabelUpdatedValueType: \(error)"
            }
        }
    }

    public class ObjectLabelUpdatedValueTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ObjectLabelUpdatedValueType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ObjectLabelUpdatedValueType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return ObjectLabelUpdatedValueType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: ObjectLabelUpdatedValueType.self, json: json)
            }
        }
    }

    /// Opened shared Paper doc.
    public class OpenNoteSharedDetails: CustomStringConvertible, JSONRepresentable {
        func json() throws -> JSON {
            try OpenNoteSharedDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try OpenNoteSharedDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for OpenNoteSharedDetails: \(error)"
            }
        }
    }

    public class OpenNoteSharedDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: OpenNoteSharedDetails) throws -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> OpenNoteSharedDetails {
            switch json {
            case .dictionary:
                return OpenNoteSharedDetails()
            default:
                throw JSONSerializerError.deserializeError(type: OpenNoteSharedDetails.self, json: json)
            }
        }
    }

    /// The OpenNoteSharedType struct
    public class OpenNoteSharedType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try OpenNoteSharedTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try OpenNoteSharedTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for OpenNoteSharedType: \(error)"
            }
        }
    }

    public class OpenNoteSharedTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: OpenNoteSharedType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> OpenNoteSharedType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return OpenNoteSharedType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: OpenNoteSharedType.self, json: json)
            }
        }
    }

    /// More details about the organization.
    public class OrganizationDetails: CustomStringConvertible, JSONRepresentable {
        /// The name of the organization.
        public let organization: String
        public init(organization: String) {
            stringValidator()(organization)
            self.organization = organization
        }

        func json() throws -> JSON {
            try OrganizationDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try OrganizationDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for OrganizationDetails: \(error)"
            }
        }
    }

    public class OrganizationDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: OrganizationDetails) throws -> JSON {
            let output = [
                "organization": try Serialization._StringSerializer.serialize(value.organization),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> OrganizationDetails {
            switch json {
            case .dictionary(let dict):
                let organization = try Serialization._StringSerializer.deserialize(dict["organization"] ?? .null)
                return OrganizationDetails(organization: organization)
            default:
                throw JSONSerializerError.deserializeError(type: OrganizationDetails.self, json: json)
            }
        }
    }

    /// The name of the organization
    public class OrganizationName: CustomStringConvertible, JSONRepresentable {
        /// The name of the organization.
        public let organization: String
        public init(organization: String) {
            stringValidator()(organization)
            self.organization = organization
        }

        func json() throws -> JSON {
            try OrganizationNameSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try OrganizationNameSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for OrganizationName: \(error)"
            }
        }
    }

    public class OrganizationNameSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: OrganizationName) throws -> JSON {
            let output = [
                "organization": try Serialization._StringSerializer.serialize(value.organization),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> OrganizationName {
            switch json {
            case .dictionary(let dict):
                let organization = try Serialization._StringSerializer.deserialize(dict["organization"] ?? .null)
                return OrganizationName(organization: organization)
            default:
                throw JSONSerializerError.deserializeError(type: OrganizationName.self, json: json)
            }
        }
    }

    /// Organized a folder with multi-file organize.
    public class OrganizeFolderWithTidyDetails: CustomStringConvertible, JSONRepresentable {
        func json() throws -> JSON {
            try OrganizeFolderWithTidyDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try OrganizeFolderWithTidyDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for OrganizeFolderWithTidyDetails: \(error)"
            }
        }
    }

    public class OrganizeFolderWithTidyDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: OrganizeFolderWithTidyDetails) throws -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> OrganizeFolderWithTidyDetails {
            switch json {
            case .dictionary:
                return OrganizeFolderWithTidyDetails()
            default:
                throw JSONSerializerError.deserializeError(type: OrganizeFolderWithTidyDetails.self, json: json)
            }
        }
    }

    /// The OrganizeFolderWithTidyType struct
    public class OrganizeFolderWithTidyType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try OrganizeFolderWithTidyTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try OrganizeFolderWithTidyTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for OrganizeFolderWithTidyType: \(error)"
            }
        }
    }

    public class OrganizeFolderWithTidyTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: OrganizeFolderWithTidyType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> OrganizeFolderWithTidyType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return OrganizeFolderWithTidyType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: OrganizeFolderWithTidyType.self, json: json)
            }
        }
    }

    /// The origin from which the actor performed the action.
    public class OriginLogInfo: CustomStringConvertible, JSONRepresentable {
        /// Geographic location details.
        public let geoLocation: TeamLog.GeoLocationLogInfo?
        /// The method that was used to perform the action.
        public let accessMethod: TeamLog.AccessMethodLogInfo
        public init(accessMethod: TeamLog.AccessMethodLogInfo, geoLocation: TeamLog.GeoLocationLogInfo? = nil) {
            self.geoLocation = geoLocation
            self.accessMethod = accessMethod
        }

        func json() throws -> JSON {
            try OriginLogInfoSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try OriginLogInfoSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for OriginLogInfo: \(error)"
            }
        }
    }

    public class OriginLogInfoSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: OriginLogInfo) throws -> JSON {
            let output = [
                "access_method": try TeamLog.AccessMethodLogInfoSerializer().serialize(value.accessMethod),
                "geo_location": try NullableSerializer(TeamLog.GeoLocationLogInfoSerializer()).serialize(value.geoLocation),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> OriginLogInfo {
            switch json {
            case .dictionary(let dict):
                let accessMethod = try TeamLog.AccessMethodLogInfoSerializer().deserialize(dict["access_method"] ?? .null)
                let geoLocation = try NullableSerializer(TeamLog.GeoLocationLogInfoSerializer()).deserialize(dict["geo_location"] ?? .null)
                return OriginLogInfo(accessMethod: accessMethod, geoLocation: geoLocation)
            default:
                throw JSONSerializerError.deserializeError(type: OriginLogInfo.self, json: json)
            }
        }
    }

    /// Report created: Views of old links.
    public class OutdatedLinkViewCreateReportDetails: CustomStringConvertible, JSONRepresentable {
        /// Report start date.
        public let startDate: Date
        /// Report end date.
        public let endDate: Date
        public init(startDate: Date, endDate: Date) {
            self.startDate = startDate
            self.endDate = endDate
        }

        func json() throws -> JSON {
            try OutdatedLinkViewCreateReportDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try OutdatedLinkViewCreateReportDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for OutdatedLinkViewCreateReportDetails: \(error)"
            }
        }
    }

    public class OutdatedLinkViewCreateReportDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: OutdatedLinkViewCreateReportDetails) throws -> JSON {
            let output = [
                "start_date": try NSDateSerializer("%Y-%m-%dT%H:%M:%SZ").serialize(value.startDate),
                "end_date": try NSDateSerializer("%Y-%m-%dT%H:%M:%SZ").serialize(value.endDate),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> OutdatedLinkViewCreateReportDetails {
            switch json {
            case .dictionary(let dict):
                let startDate = try NSDateSerializer("%Y-%m-%dT%H:%M:%SZ").deserialize(dict["start_date"] ?? .null)
                let endDate = try NSDateSerializer("%Y-%m-%dT%H:%M:%SZ").deserialize(dict["end_date"] ?? .null)
                return OutdatedLinkViewCreateReportDetails(startDate: startDate, endDate: endDate)
            default:
                throw JSONSerializerError.deserializeError(type: OutdatedLinkViewCreateReportDetails.self, json: json)
            }
        }
    }

    /// The OutdatedLinkViewCreateReportType struct
    public class OutdatedLinkViewCreateReportType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try OutdatedLinkViewCreateReportTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try OutdatedLinkViewCreateReportTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for OutdatedLinkViewCreateReportType: \(error)"
            }
        }
    }

    public class OutdatedLinkViewCreateReportTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: OutdatedLinkViewCreateReportType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> OutdatedLinkViewCreateReportType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return OutdatedLinkViewCreateReportType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: OutdatedLinkViewCreateReportType.self, json: json)
            }
        }
    }

    /// Couldn't create report: Views of old links.
    public class OutdatedLinkViewReportFailedDetails: CustomStringConvertible, JSONRepresentable {
        /// Failure reason.
        public let failureReason: Team.TeamReportFailureReason
        public init(failureReason: Team.TeamReportFailureReason) {
            self.failureReason = failureReason
        }

        func json() throws -> JSON {
            try OutdatedLinkViewReportFailedDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try OutdatedLinkViewReportFailedDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for OutdatedLinkViewReportFailedDetails: \(error)"
            }
        }
    }

    public class OutdatedLinkViewReportFailedDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: OutdatedLinkViewReportFailedDetails) throws -> JSON {
            let output = [
                "failure_reason": try Team.TeamReportFailureReasonSerializer().serialize(value.failureReason),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> OutdatedLinkViewReportFailedDetails {
            switch json {
            case .dictionary(let dict):
                let failureReason = try Team.TeamReportFailureReasonSerializer().deserialize(dict["failure_reason"] ?? .null)
                return OutdatedLinkViewReportFailedDetails(failureReason: failureReason)
            default:
                throw JSONSerializerError.deserializeError(type: OutdatedLinkViewReportFailedDetails.self, json: json)
            }
        }
    }

    /// The OutdatedLinkViewReportFailedType struct
    public class OutdatedLinkViewReportFailedType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try OutdatedLinkViewReportFailedTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try OutdatedLinkViewReportFailedTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for OutdatedLinkViewReportFailedType: \(error)"
            }
        }
    }

    public class OutdatedLinkViewReportFailedTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: OutdatedLinkViewReportFailedType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> OutdatedLinkViewReportFailedType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return OutdatedLinkViewReportFailedType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: OutdatedLinkViewReportFailedType.self, json: json)
            }
        }
    }

    /// The PaperAccessType union
    public enum PaperAccessType: CustomStringConvertible, JSONRepresentable {
        /// An unspecified error.
        case commenter
        /// An unspecified error.
        case editor
        /// An unspecified error.
        case viewer
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try PaperAccessTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PaperAccessTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PaperAccessType: \(error)"
            }
        }
    }

    public class PaperAccessTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PaperAccessType) throws -> JSON {
            switch value {
            case .commenter:
                var d = [String: JSON]()
                d[".tag"] = .str("commenter")
                return .dictionary(d)
            case .editor:
                var d = [String: JSON]()
                d[".tag"] = .str("editor")
                return .dictionary(d)
            case .viewer:
                var d = [String: JSON]()
                d[".tag"] = .str("viewer")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> PaperAccessType {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "commenter":
                    return PaperAccessType.commenter
                case "editor":
                    return PaperAccessType.editor
                case "viewer":
                    return PaperAccessType.viewer
                case "other":
                    return PaperAccessType.other
                default:
                    return PaperAccessType.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: PaperAccessType.self, json: json)
            }
        }
    }

    /// Exported all team Paper docs.
    public class PaperAdminExportStartDetails: CustomStringConvertible, JSONRepresentable {
        func json() throws -> JSON {
            try PaperAdminExportStartDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PaperAdminExportStartDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PaperAdminExportStartDetails: \(error)"
            }
        }
    }

    public class PaperAdminExportStartDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PaperAdminExportStartDetails) throws -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PaperAdminExportStartDetails {
            switch json {
            case .dictionary:
                return PaperAdminExportStartDetails()
            default:
                throw JSONSerializerError.deserializeError(type: PaperAdminExportStartDetails.self, json: json)
            }
        }
    }

    /// The PaperAdminExportStartType struct
    public class PaperAdminExportStartType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try PaperAdminExportStartTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PaperAdminExportStartTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PaperAdminExportStartType: \(error)"
            }
        }
    }

    public class PaperAdminExportStartTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PaperAdminExportStartType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PaperAdminExportStartType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return PaperAdminExportStartType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: PaperAdminExportStartType.self, json: json)
            }
        }
    }

    /// Changed whether Dropbox Paper, when enabled, is deployed to all members or to specific members.
    public class PaperChangeDeploymentPolicyDetails: CustomStringConvertible, JSONRepresentable {
        /// New Dropbox Paper deployment policy.
        public let newValue: TeamPolicies.PaperDeploymentPolicy
        /// Previous Dropbox Paper deployment policy. Might be missing due to historical data gap.
        public let previousValue: TeamPolicies.PaperDeploymentPolicy?
        public init(newValue: TeamPolicies.PaperDeploymentPolicy, previousValue: TeamPolicies.PaperDeploymentPolicy? = nil) {
            self.newValue = newValue
            self.previousValue = previousValue
        }

        func json() throws -> JSON {
            try PaperChangeDeploymentPolicyDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PaperChangeDeploymentPolicyDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PaperChangeDeploymentPolicyDetails: \(error)"
            }
        }
    }

    public class PaperChangeDeploymentPolicyDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PaperChangeDeploymentPolicyDetails) throws -> JSON {
            let output = [
                "new_value": try TeamPolicies.PaperDeploymentPolicySerializer().serialize(value.newValue),
                "previous_value": try NullableSerializer(TeamPolicies.PaperDeploymentPolicySerializer()).serialize(value.previousValue),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PaperChangeDeploymentPolicyDetails {
            switch json {
            case .dictionary(let dict):
                let newValue = try TeamPolicies.PaperDeploymentPolicySerializer().deserialize(dict["new_value"] ?? .null)
                let previousValue = try NullableSerializer(TeamPolicies.PaperDeploymentPolicySerializer()).deserialize(dict["previous_value"] ?? .null)
                return PaperChangeDeploymentPolicyDetails(newValue: newValue, previousValue: previousValue)
            default:
                throw JSONSerializerError.deserializeError(type: PaperChangeDeploymentPolicyDetails.self, json: json)
            }
        }
    }

    /// The PaperChangeDeploymentPolicyType struct
    public class PaperChangeDeploymentPolicyType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try PaperChangeDeploymentPolicyTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PaperChangeDeploymentPolicyTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PaperChangeDeploymentPolicyType: \(error)"
            }
        }
    }

    public class PaperChangeDeploymentPolicyTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PaperChangeDeploymentPolicyType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PaperChangeDeploymentPolicyType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return PaperChangeDeploymentPolicyType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: PaperChangeDeploymentPolicyType.self, json: json)
            }
        }
    }

    /// Changed whether non-members can view Paper docs with link.
    public class PaperChangeMemberLinkPolicyDetails: CustomStringConvertible, JSONRepresentable {
        /// New paper external link accessibility policy.
        public let newValue: TeamLog.PaperMemberPolicy
        public init(newValue: TeamLog.PaperMemberPolicy) {
            self.newValue = newValue
        }

        func json() throws -> JSON {
            try PaperChangeMemberLinkPolicyDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PaperChangeMemberLinkPolicyDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PaperChangeMemberLinkPolicyDetails: \(error)"
            }
        }
    }

    public class PaperChangeMemberLinkPolicyDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PaperChangeMemberLinkPolicyDetails) throws -> JSON {
            let output = [
                "new_value": try TeamLog.PaperMemberPolicySerializer().serialize(value.newValue),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PaperChangeMemberLinkPolicyDetails {
            switch json {
            case .dictionary(let dict):
                let newValue = try TeamLog.PaperMemberPolicySerializer().deserialize(dict["new_value"] ?? .null)
                return PaperChangeMemberLinkPolicyDetails(newValue: newValue)
            default:
                throw JSONSerializerError.deserializeError(type: PaperChangeMemberLinkPolicyDetails.self, json: json)
            }
        }
    }

    /// The PaperChangeMemberLinkPolicyType struct
    public class PaperChangeMemberLinkPolicyType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try PaperChangeMemberLinkPolicyTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PaperChangeMemberLinkPolicyTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PaperChangeMemberLinkPolicyType: \(error)"
            }
        }
    }

    public class PaperChangeMemberLinkPolicyTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PaperChangeMemberLinkPolicyType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PaperChangeMemberLinkPolicyType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return PaperChangeMemberLinkPolicyType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: PaperChangeMemberLinkPolicyType.self, json: json)
            }
        }
    }

    /// Changed whether members can share Paper docs outside team, and if docs are accessible only by team members or
    /// anyone by default.
    public class PaperChangeMemberPolicyDetails: CustomStringConvertible, JSONRepresentable {
        /// New paper external accessibility policy.
        public let newValue: TeamLog.PaperMemberPolicy
        /// Previous paper external accessibility policy. Might be missing due to historical data gap.
        public let previousValue: TeamLog.PaperMemberPolicy?
        public init(newValue: TeamLog.PaperMemberPolicy, previousValue: TeamLog.PaperMemberPolicy? = nil) {
            self.newValue = newValue
            self.previousValue = previousValue
        }

        func json() throws -> JSON {
            try PaperChangeMemberPolicyDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PaperChangeMemberPolicyDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PaperChangeMemberPolicyDetails: \(error)"
            }
        }
    }

    public class PaperChangeMemberPolicyDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PaperChangeMemberPolicyDetails) throws -> JSON {
            let output = [
                "new_value": try TeamLog.PaperMemberPolicySerializer().serialize(value.newValue),
                "previous_value": try NullableSerializer(TeamLog.PaperMemberPolicySerializer()).serialize(value.previousValue),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PaperChangeMemberPolicyDetails {
            switch json {
            case .dictionary(let dict):
                let newValue = try TeamLog.PaperMemberPolicySerializer().deserialize(dict["new_value"] ?? .null)
                let previousValue = try NullableSerializer(TeamLog.PaperMemberPolicySerializer()).deserialize(dict["previous_value"] ?? .null)
                return PaperChangeMemberPolicyDetails(newValue: newValue, previousValue: previousValue)
            default:
                throw JSONSerializerError.deserializeError(type: PaperChangeMemberPolicyDetails.self, json: json)
            }
        }
    }

    /// The PaperChangeMemberPolicyType struct
    public class PaperChangeMemberPolicyType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try PaperChangeMemberPolicyTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PaperChangeMemberPolicyTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PaperChangeMemberPolicyType: \(error)"
            }
        }
    }

    public class PaperChangeMemberPolicyTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PaperChangeMemberPolicyType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PaperChangeMemberPolicyType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return PaperChangeMemberPolicyType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: PaperChangeMemberPolicyType.self, json: json)
            }
        }
    }

    /// Enabled/disabled Dropbox Paper for team.
    public class PaperChangePolicyDetails: CustomStringConvertible, JSONRepresentable {
        /// New Dropbox Paper policy.
        public let newValue: TeamPolicies.PaperEnabledPolicy
        /// Previous Dropbox Paper policy. Might be missing due to historical data gap.
        public let previousValue: TeamPolicies.PaperEnabledPolicy?
        public init(newValue: TeamPolicies.PaperEnabledPolicy, previousValue: TeamPolicies.PaperEnabledPolicy? = nil) {
            self.newValue = newValue
            self.previousValue = previousValue
        }

        func json() throws -> JSON {
            try PaperChangePolicyDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PaperChangePolicyDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PaperChangePolicyDetails: \(error)"
            }
        }
    }

    public class PaperChangePolicyDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PaperChangePolicyDetails) throws -> JSON {
            let output = [
                "new_value": try TeamPolicies.PaperEnabledPolicySerializer().serialize(value.newValue),
                "previous_value": try NullableSerializer(TeamPolicies.PaperEnabledPolicySerializer()).serialize(value.previousValue),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PaperChangePolicyDetails {
            switch json {
            case .dictionary(let dict):
                let newValue = try TeamPolicies.PaperEnabledPolicySerializer().deserialize(dict["new_value"] ?? .null)
                let previousValue = try NullableSerializer(TeamPolicies.PaperEnabledPolicySerializer()).deserialize(dict["previous_value"] ?? .null)
                return PaperChangePolicyDetails(newValue: newValue, previousValue: previousValue)
            default:
                throw JSONSerializerError.deserializeError(type: PaperChangePolicyDetails.self, json: json)
            }
        }
    }

    /// The PaperChangePolicyType struct
    public class PaperChangePolicyType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try PaperChangePolicyTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PaperChangePolicyTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PaperChangePolicyType: \(error)"
            }
        }
    }

    public class PaperChangePolicyTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PaperChangePolicyType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PaperChangePolicyType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return PaperChangePolicyType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: PaperChangePolicyType.self, json: json)
            }
        }
    }

    /// Added users and/or groups to Paper doc/folder.
    public class PaperContentAddMemberDetails: CustomStringConvertible, JSONRepresentable {
        /// Event unique identifier.
        public let eventUuid: String
        public init(eventUuid: String) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
        }

        func json() throws -> JSON {
            try PaperContentAddMemberDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PaperContentAddMemberDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PaperContentAddMemberDetails: \(error)"
            }
        }
    }

    public class PaperContentAddMemberDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PaperContentAddMemberDetails) throws -> JSON {
            let output = [
                "event_uuid": try Serialization._StringSerializer.serialize(value.eventUuid),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PaperContentAddMemberDetails {
            switch json {
            case .dictionary(let dict):
                let eventUuid = try Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                return PaperContentAddMemberDetails(eventUuid: eventUuid)
            default:
                throw JSONSerializerError.deserializeError(type: PaperContentAddMemberDetails.self, json: json)
            }
        }
    }

    /// The PaperContentAddMemberType struct
    public class PaperContentAddMemberType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try PaperContentAddMemberTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PaperContentAddMemberTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PaperContentAddMemberType: \(error)"
            }
        }
    }

    public class PaperContentAddMemberTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PaperContentAddMemberType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PaperContentAddMemberType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return PaperContentAddMemberType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: PaperContentAddMemberType.self, json: json)
            }
        }
    }

    /// Added Paper doc/folder to folder.
    public class PaperContentAddToFolderDetails: CustomStringConvertible, JSONRepresentable {
        /// Event unique identifier.
        public let eventUuid: String
        /// Target asset position in the Assets list.
        public let targetAssetIndex: UInt64
        /// Parent asset position in the Assets list.
        public let parentAssetIndex: UInt64
        public init(eventUuid: String, targetAssetIndex: UInt64, parentAssetIndex: UInt64) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
            comparableValidator()(targetAssetIndex)
            self.targetAssetIndex = targetAssetIndex
            comparableValidator()(parentAssetIndex)
            self.parentAssetIndex = parentAssetIndex
        }

        func json() throws -> JSON {
            try PaperContentAddToFolderDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PaperContentAddToFolderDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PaperContentAddToFolderDetails: \(error)"
            }
        }
    }

    public class PaperContentAddToFolderDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PaperContentAddToFolderDetails) throws -> JSON {
            let output = [
                "event_uuid": try Serialization._StringSerializer.serialize(value.eventUuid),
                "target_asset_index": try Serialization._UInt64Serializer.serialize(value.targetAssetIndex),
                "parent_asset_index": try Serialization._UInt64Serializer.serialize(value.parentAssetIndex),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PaperContentAddToFolderDetails {
            switch json {
            case .dictionary(let dict):
                let eventUuid = try Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                let targetAssetIndex = try Serialization._UInt64Serializer.deserialize(dict["target_asset_index"] ?? .null)
                let parentAssetIndex = try Serialization._UInt64Serializer.deserialize(dict["parent_asset_index"] ?? .null)
                return PaperContentAddToFolderDetails(eventUuid: eventUuid, targetAssetIndex: targetAssetIndex, parentAssetIndex: parentAssetIndex)
            default:
                throw JSONSerializerError.deserializeError(type: PaperContentAddToFolderDetails.self, json: json)
            }
        }
    }

    /// The PaperContentAddToFolderType struct
    public class PaperContentAddToFolderType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try PaperContentAddToFolderTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PaperContentAddToFolderTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PaperContentAddToFolderType: \(error)"
            }
        }
    }

    public class PaperContentAddToFolderTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PaperContentAddToFolderType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PaperContentAddToFolderType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return PaperContentAddToFolderType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: PaperContentAddToFolderType.self, json: json)
            }
        }
    }

    /// Archived Paper doc/folder.
    public class PaperContentArchiveDetails: CustomStringConvertible, JSONRepresentable {
        /// Event unique identifier.
        public let eventUuid: String
        public init(eventUuid: String) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
        }

        func json() throws -> JSON {
            try PaperContentArchiveDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PaperContentArchiveDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PaperContentArchiveDetails: \(error)"
            }
        }
    }

    public class PaperContentArchiveDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PaperContentArchiveDetails) throws -> JSON {
            let output = [
                "event_uuid": try Serialization._StringSerializer.serialize(value.eventUuid),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PaperContentArchiveDetails {
            switch json {
            case .dictionary(let dict):
                let eventUuid = try Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                return PaperContentArchiveDetails(eventUuid: eventUuid)
            default:
                throw JSONSerializerError.deserializeError(type: PaperContentArchiveDetails.self, json: json)
            }
        }
    }

    /// The PaperContentArchiveType struct
    public class PaperContentArchiveType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try PaperContentArchiveTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PaperContentArchiveTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PaperContentArchiveType: \(error)"
            }
        }
    }

    public class PaperContentArchiveTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PaperContentArchiveType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PaperContentArchiveType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return PaperContentArchiveType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: PaperContentArchiveType.self, json: json)
            }
        }
    }

    /// Created Paper doc/folder.
    public class PaperContentCreateDetails: CustomStringConvertible, JSONRepresentable {
        /// Event unique identifier.
        public let eventUuid: String
        public init(eventUuid: String) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
        }

        func json() throws -> JSON {
            try PaperContentCreateDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PaperContentCreateDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PaperContentCreateDetails: \(error)"
            }
        }
    }

    public class PaperContentCreateDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PaperContentCreateDetails) throws -> JSON {
            let output = [
                "event_uuid": try Serialization._StringSerializer.serialize(value.eventUuid),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PaperContentCreateDetails {
            switch json {
            case .dictionary(let dict):
                let eventUuid = try Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                return PaperContentCreateDetails(eventUuid: eventUuid)
            default:
                throw JSONSerializerError.deserializeError(type: PaperContentCreateDetails.self, json: json)
            }
        }
    }

    /// The PaperContentCreateType struct
    public class PaperContentCreateType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try PaperContentCreateTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PaperContentCreateTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PaperContentCreateType: \(error)"
            }
        }
    }

    public class PaperContentCreateTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PaperContentCreateType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PaperContentCreateType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return PaperContentCreateType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: PaperContentCreateType.self, json: json)
            }
        }
    }

    /// Permanently deleted Paper doc/folder.
    public class PaperContentPermanentlyDeleteDetails: CustomStringConvertible, JSONRepresentable {
        /// Event unique identifier.
        public let eventUuid: String
        public init(eventUuid: String) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
        }

        func json() throws -> JSON {
            try PaperContentPermanentlyDeleteDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PaperContentPermanentlyDeleteDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PaperContentPermanentlyDeleteDetails: \(error)"
            }
        }
    }

    public class PaperContentPermanentlyDeleteDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PaperContentPermanentlyDeleteDetails) throws -> JSON {
            let output = [
                "event_uuid": try Serialization._StringSerializer.serialize(value.eventUuid),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PaperContentPermanentlyDeleteDetails {
            switch json {
            case .dictionary(let dict):
                let eventUuid = try Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                return PaperContentPermanentlyDeleteDetails(eventUuid: eventUuid)
            default:
                throw JSONSerializerError.deserializeError(type: PaperContentPermanentlyDeleteDetails.self, json: json)
            }
        }
    }

    /// The PaperContentPermanentlyDeleteType struct
    public class PaperContentPermanentlyDeleteType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try PaperContentPermanentlyDeleteTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PaperContentPermanentlyDeleteTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PaperContentPermanentlyDeleteType: \(error)"
            }
        }
    }

    public class PaperContentPermanentlyDeleteTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PaperContentPermanentlyDeleteType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PaperContentPermanentlyDeleteType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return PaperContentPermanentlyDeleteType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: PaperContentPermanentlyDeleteType.self, json: json)
            }
        }
    }

    /// Removed Paper doc/folder from folder.
    public class PaperContentRemoveFromFolderDetails: CustomStringConvertible, JSONRepresentable {
        /// Event unique identifier.
        public let eventUuid: String
        /// Target asset position in the Assets list.
        public let targetAssetIndex: UInt64?
        /// Parent asset position in the Assets list.
        public let parentAssetIndex: UInt64?
        public init(eventUuid: String, targetAssetIndex: UInt64? = nil, parentAssetIndex: UInt64? = nil) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
            nullableValidator(comparableValidator())(targetAssetIndex)
            self.targetAssetIndex = targetAssetIndex
            nullableValidator(comparableValidator())(parentAssetIndex)
            self.parentAssetIndex = parentAssetIndex
        }

        func json() throws -> JSON {
            try PaperContentRemoveFromFolderDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PaperContentRemoveFromFolderDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PaperContentRemoveFromFolderDetails: \(error)"
            }
        }
    }

    public class PaperContentRemoveFromFolderDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PaperContentRemoveFromFolderDetails) throws -> JSON {
            let output = [
                "event_uuid": try Serialization._StringSerializer.serialize(value.eventUuid),
                "target_asset_index": try NullableSerializer(Serialization._UInt64Serializer).serialize(value.targetAssetIndex),
                "parent_asset_index": try NullableSerializer(Serialization._UInt64Serializer).serialize(value.parentAssetIndex),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PaperContentRemoveFromFolderDetails {
            switch json {
            case .dictionary(let dict):
                let eventUuid = try Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                let targetAssetIndex = try NullableSerializer(Serialization._UInt64Serializer).deserialize(dict["target_asset_index"] ?? .null)
                let parentAssetIndex = try NullableSerializer(Serialization._UInt64Serializer).deserialize(dict["parent_asset_index"] ?? .null)
                return PaperContentRemoveFromFolderDetails(eventUuid: eventUuid, targetAssetIndex: targetAssetIndex, parentAssetIndex: parentAssetIndex)
            default:
                throw JSONSerializerError.deserializeError(type: PaperContentRemoveFromFolderDetails.self, json: json)
            }
        }
    }

    /// The PaperContentRemoveFromFolderType struct
    public class PaperContentRemoveFromFolderType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try PaperContentRemoveFromFolderTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PaperContentRemoveFromFolderTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PaperContentRemoveFromFolderType: \(error)"
            }
        }
    }

    public class PaperContentRemoveFromFolderTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PaperContentRemoveFromFolderType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PaperContentRemoveFromFolderType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return PaperContentRemoveFromFolderType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: PaperContentRemoveFromFolderType.self, json: json)
            }
        }
    }

    /// Removed users and/or groups from Paper doc/folder.
    public class PaperContentRemoveMemberDetails: CustomStringConvertible, JSONRepresentable {
        /// Event unique identifier.
        public let eventUuid: String
        public init(eventUuid: String) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
        }

        func json() throws -> JSON {
            try PaperContentRemoveMemberDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PaperContentRemoveMemberDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PaperContentRemoveMemberDetails: \(error)"
            }
        }
    }

    public class PaperContentRemoveMemberDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PaperContentRemoveMemberDetails) throws -> JSON {
            let output = [
                "event_uuid": try Serialization._StringSerializer.serialize(value.eventUuid),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PaperContentRemoveMemberDetails {
            switch json {
            case .dictionary(let dict):
                let eventUuid = try Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                return PaperContentRemoveMemberDetails(eventUuid: eventUuid)
            default:
                throw JSONSerializerError.deserializeError(type: PaperContentRemoveMemberDetails.self, json: json)
            }
        }
    }

    /// The PaperContentRemoveMemberType struct
    public class PaperContentRemoveMemberType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try PaperContentRemoveMemberTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PaperContentRemoveMemberTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PaperContentRemoveMemberType: \(error)"
            }
        }
    }

    public class PaperContentRemoveMemberTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PaperContentRemoveMemberType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PaperContentRemoveMemberType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return PaperContentRemoveMemberType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: PaperContentRemoveMemberType.self, json: json)
            }
        }
    }

    /// Renamed Paper doc/folder.
    public class PaperContentRenameDetails: CustomStringConvertible, JSONRepresentable {
        /// Event unique identifier.
        public let eventUuid: String
        public init(eventUuid: String) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
        }

        func json() throws -> JSON {
            try PaperContentRenameDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PaperContentRenameDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PaperContentRenameDetails: \(error)"
            }
        }
    }

    public class PaperContentRenameDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PaperContentRenameDetails) throws -> JSON {
            let output = [
                "event_uuid": try Serialization._StringSerializer.serialize(value.eventUuid),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PaperContentRenameDetails {
            switch json {
            case .dictionary(let dict):
                let eventUuid = try Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                return PaperContentRenameDetails(eventUuid: eventUuid)
            default:
                throw JSONSerializerError.deserializeError(type: PaperContentRenameDetails.self, json: json)
            }
        }
    }

    /// The PaperContentRenameType struct
    public class PaperContentRenameType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try PaperContentRenameTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PaperContentRenameTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PaperContentRenameType: \(error)"
            }
        }
    }

    public class PaperContentRenameTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PaperContentRenameType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PaperContentRenameType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return PaperContentRenameType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: PaperContentRenameType.self, json: json)
            }
        }
    }

    /// Restored archived Paper doc/folder.
    public class PaperContentRestoreDetails: CustomStringConvertible, JSONRepresentable {
        /// Event unique identifier.
        public let eventUuid: String
        public init(eventUuid: String) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
        }

        func json() throws -> JSON {
            try PaperContentRestoreDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PaperContentRestoreDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PaperContentRestoreDetails: \(error)"
            }
        }
    }

    public class PaperContentRestoreDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PaperContentRestoreDetails) throws -> JSON {
            let output = [
                "event_uuid": try Serialization._StringSerializer.serialize(value.eventUuid),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PaperContentRestoreDetails {
            switch json {
            case .dictionary(let dict):
                let eventUuid = try Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                return PaperContentRestoreDetails(eventUuid: eventUuid)
            default:
                throw JSONSerializerError.deserializeError(type: PaperContentRestoreDetails.self, json: json)
            }
        }
    }

    /// The PaperContentRestoreType struct
    public class PaperContentRestoreType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try PaperContentRestoreTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PaperContentRestoreTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PaperContentRestoreType: \(error)"
            }
        }
    }

    public class PaperContentRestoreTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PaperContentRestoreType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PaperContentRestoreType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return PaperContentRestoreType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: PaperContentRestoreType.self, json: json)
            }
        }
    }

    /// Policy to set default access for newly created Paper folders.
    public enum PaperDefaultFolderPolicy: CustomStringConvertible, JSONRepresentable {
        /// An unspecified error.
        case everyoneInTeam
        /// An unspecified error.
        case inviteOnly
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try PaperDefaultFolderPolicySerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PaperDefaultFolderPolicySerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PaperDefaultFolderPolicy: \(error)"
            }
        }
    }

    public class PaperDefaultFolderPolicySerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PaperDefaultFolderPolicy) throws -> JSON {
            switch value {
            case .everyoneInTeam:
                var d = [String: JSON]()
                d[".tag"] = .str("everyone_in_team")
                return .dictionary(d)
            case .inviteOnly:
                var d = [String: JSON]()
                d[".tag"] = .str("invite_only")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> PaperDefaultFolderPolicy {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "everyone_in_team":
                    return PaperDefaultFolderPolicy.everyoneInTeam
                case "invite_only":
                    return PaperDefaultFolderPolicy.inviteOnly
                case "other":
                    return PaperDefaultFolderPolicy.other
                default:
                    return PaperDefaultFolderPolicy.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: PaperDefaultFolderPolicy.self, json: json)
            }
        }
    }

    /// Changed Paper Default Folder Policy setting for team.
    public class PaperDefaultFolderPolicyChangedDetails: CustomStringConvertible, JSONRepresentable {
        /// New Paper Default Folder Policy.
        public let newValue: TeamLog.PaperDefaultFolderPolicy
        /// Previous Paper Default Folder Policy.
        public let previousValue: TeamLog.PaperDefaultFolderPolicy
        public init(newValue: TeamLog.PaperDefaultFolderPolicy, previousValue: TeamLog.PaperDefaultFolderPolicy) {
            self.newValue = newValue
            self.previousValue = previousValue
        }

        func json() throws -> JSON {
            try PaperDefaultFolderPolicyChangedDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PaperDefaultFolderPolicyChangedDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PaperDefaultFolderPolicyChangedDetails: \(error)"
            }
        }
    }

    public class PaperDefaultFolderPolicyChangedDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PaperDefaultFolderPolicyChangedDetails) throws -> JSON {
            let output = [
                "new_value": try TeamLog.PaperDefaultFolderPolicySerializer().serialize(value.newValue),
                "previous_value": try TeamLog.PaperDefaultFolderPolicySerializer().serialize(value.previousValue),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PaperDefaultFolderPolicyChangedDetails {
            switch json {
            case .dictionary(let dict):
                let newValue = try TeamLog.PaperDefaultFolderPolicySerializer().deserialize(dict["new_value"] ?? .null)
                let previousValue = try TeamLog.PaperDefaultFolderPolicySerializer().deserialize(dict["previous_value"] ?? .null)
                return PaperDefaultFolderPolicyChangedDetails(newValue: newValue, previousValue: previousValue)
            default:
                throw JSONSerializerError.deserializeError(type: PaperDefaultFolderPolicyChangedDetails.self, json: json)
            }
        }
    }

    /// The PaperDefaultFolderPolicyChangedType struct
    public class PaperDefaultFolderPolicyChangedType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try PaperDefaultFolderPolicyChangedTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PaperDefaultFolderPolicyChangedTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PaperDefaultFolderPolicyChangedType: \(error)"
            }
        }
    }

    public class PaperDefaultFolderPolicyChangedTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PaperDefaultFolderPolicyChangedType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PaperDefaultFolderPolicyChangedType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return PaperDefaultFolderPolicyChangedType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: PaperDefaultFolderPolicyChangedType.self, json: json)
            }
        }
    }

    /// Policy for controlling if team members can use Paper Desktop
    public enum PaperDesktopPolicy: CustomStringConvertible, JSONRepresentable {
        /// An unspecified error.
        case disabled
        /// An unspecified error.
        case enabled
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try PaperDesktopPolicySerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PaperDesktopPolicySerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PaperDesktopPolicy: \(error)"
            }
        }
    }

    public class PaperDesktopPolicySerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PaperDesktopPolicy) throws -> JSON {
            switch value {
            case .disabled:
                var d = [String: JSON]()
                d[".tag"] = .str("disabled")
                return .dictionary(d)
            case .enabled:
                var d = [String: JSON]()
                d[".tag"] = .str("enabled")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> PaperDesktopPolicy {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "disabled":
                    return PaperDesktopPolicy.disabled
                case "enabled":
                    return PaperDesktopPolicy.enabled
                case "other":
                    return PaperDesktopPolicy.other
                default:
                    return PaperDesktopPolicy.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: PaperDesktopPolicy.self, json: json)
            }
        }
    }

    /// Enabled/disabled Paper Desktop for team.
    public class PaperDesktopPolicyChangedDetails: CustomStringConvertible, JSONRepresentable {
        /// New Paper Desktop policy.
        public let newValue: TeamLog.PaperDesktopPolicy
        /// Previous Paper Desktop policy.
        public let previousValue: TeamLog.PaperDesktopPolicy
        public init(newValue: TeamLog.PaperDesktopPolicy, previousValue: TeamLog.PaperDesktopPolicy) {
            self.newValue = newValue
            self.previousValue = previousValue
        }

        func json() throws -> JSON {
            try PaperDesktopPolicyChangedDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PaperDesktopPolicyChangedDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PaperDesktopPolicyChangedDetails: \(error)"
            }
        }
    }

    public class PaperDesktopPolicyChangedDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PaperDesktopPolicyChangedDetails) throws -> JSON {
            let output = [
                "new_value": try TeamLog.PaperDesktopPolicySerializer().serialize(value.newValue),
                "previous_value": try TeamLog.PaperDesktopPolicySerializer().serialize(value.previousValue),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PaperDesktopPolicyChangedDetails {
            switch json {
            case .dictionary(let dict):
                let newValue = try TeamLog.PaperDesktopPolicySerializer().deserialize(dict["new_value"] ?? .null)
                let previousValue = try TeamLog.PaperDesktopPolicySerializer().deserialize(dict["previous_value"] ?? .null)
                return PaperDesktopPolicyChangedDetails(newValue: newValue, previousValue: previousValue)
            default:
                throw JSONSerializerError.deserializeError(type: PaperDesktopPolicyChangedDetails.self, json: json)
            }
        }
    }

    /// The PaperDesktopPolicyChangedType struct
    public class PaperDesktopPolicyChangedType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try PaperDesktopPolicyChangedTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PaperDesktopPolicyChangedTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PaperDesktopPolicyChangedType: \(error)"
            }
        }
    }

    public class PaperDesktopPolicyChangedTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PaperDesktopPolicyChangedType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PaperDesktopPolicyChangedType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return PaperDesktopPolicyChangedType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: PaperDesktopPolicyChangedType.self, json: json)
            }
        }
    }

    /// Added Paper doc comment.
    public class PaperDocAddCommentDetails: CustomStringConvertible, JSONRepresentable {
        /// Event unique identifier.
        public let eventUuid: String
        /// Comment text.
        public let commentText: String?
        public init(eventUuid: String, commentText: String? = nil) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
            nullableValidator(stringValidator())(commentText)
            self.commentText = commentText
        }

        func json() throws -> JSON {
            try PaperDocAddCommentDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PaperDocAddCommentDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PaperDocAddCommentDetails: \(error)"
            }
        }
    }

    public class PaperDocAddCommentDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PaperDocAddCommentDetails) throws -> JSON {
            let output = [
                "event_uuid": try Serialization._StringSerializer.serialize(value.eventUuid),
                "comment_text": try NullableSerializer(Serialization._StringSerializer).serialize(value.commentText),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PaperDocAddCommentDetails {
            switch json {
            case .dictionary(let dict):
                let eventUuid = try Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                let commentText = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["comment_text"] ?? .null)
                return PaperDocAddCommentDetails(eventUuid: eventUuid, commentText: commentText)
            default:
                throw JSONSerializerError.deserializeError(type: PaperDocAddCommentDetails.self, json: json)
            }
        }
    }

    /// The PaperDocAddCommentType struct
    public class PaperDocAddCommentType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try PaperDocAddCommentTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PaperDocAddCommentTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PaperDocAddCommentType: \(error)"
            }
        }
    }

    public class PaperDocAddCommentTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PaperDocAddCommentType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PaperDocAddCommentType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return PaperDocAddCommentType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: PaperDocAddCommentType.self, json: json)
            }
        }
    }

    /// Changed member permissions for Paper doc.
    public class PaperDocChangeMemberRoleDetails: CustomStringConvertible, JSONRepresentable {
        /// Event unique identifier.
        public let eventUuid: String
        /// Paper doc access type.
        public let accessType: TeamLog.PaperAccessType
        public init(eventUuid: String, accessType: TeamLog.PaperAccessType) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
            self.accessType = accessType
        }

        func json() throws -> JSON {
            try PaperDocChangeMemberRoleDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PaperDocChangeMemberRoleDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PaperDocChangeMemberRoleDetails: \(error)"
            }
        }
    }

    public class PaperDocChangeMemberRoleDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PaperDocChangeMemberRoleDetails) throws -> JSON {
            let output = [
                "event_uuid": try Serialization._StringSerializer.serialize(value.eventUuid),
                "access_type": try TeamLog.PaperAccessTypeSerializer().serialize(value.accessType),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PaperDocChangeMemberRoleDetails {
            switch json {
            case .dictionary(let dict):
                let eventUuid = try Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                let accessType = try TeamLog.PaperAccessTypeSerializer().deserialize(dict["access_type"] ?? .null)
                return PaperDocChangeMemberRoleDetails(eventUuid: eventUuid, accessType: accessType)
            default:
                throw JSONSerializerError.deserializeError(type: PaperDocChangeMemberRoleDetails.self, json: json)
            }
        }
    }

    /// The PaperDocChangeMemberRoleType struct
    public class PaperDocChangeMemberRoleType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try PaperDocChangeMemberRoleTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PaperDocChangeMemberRoleTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PaperDocChangeMemberRoleType: \(error)"
            }
        }
    }

    public class PaperDocChangeMemberRoleTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PaperDocChangeMemberRoleType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PaperDocChangeMemberRoleType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return PaperDocChangeMemberRoleType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: PaperDocChangeMemberRoleType.self, json: json)
            }
        }
    }

    /// Changed sharing setting for Paper doc.
    public class PaperDocChangeSharingPolicyDetails: CustomStringConvertible, JSONRepresentable {
        /// Event unique identifier.
        public let eventUuid: String
        /// Sharing policy with external users.
        public let publicSharingPolicy: String?
        /// Sharing policy with team.
        public let teamSharingPolicy: String?
        public init(eventUuid: String, publicSharingPolicy: String? = nil, teamSharingPolicy: String? = nil) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
            nullableValidator(stringValidator())(publicSharingPolicy)
            self.publicSharingPolicy = publicSharingPolicy
            nullableValidator(stringValidator())(teamSharingPolicy)
            self.teamSharingPolicy = teamSharingPolicy
        }

        func json() throws -> JSON {
            try PaperDocChangeSharingPolicyDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PaperDocChangeSharingPolicyDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PaperDocChangeSharingPolicyDetails: \(error)"
            }
        }
    }

    public class PaperDocChangeSharingPolicyDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PaperDocChangeSharingPolicyDetails) throws -> JSON {
            let output = [
                "event_uuid": try Serialization._StringSerializer.serialize(value.eventUuid),
                "public_sharing_policy": try NullableSerializer(Serialization._StringSerializer).serialize(value.publicSharingPolicy),
                "team_sharing_policy": try NullableSerializer(Serialization._StringSerializer).serialize(value.teamSharingPolicy),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PaperDocChangeSharingPolicyDetails {
            switch json {
            case .dictionary(let dict):
                let eventUuid = try Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                let publicSharingPolicy = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["public_sharing_policy"] ?? .null)
                let teamSharingPolicy = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["team_sharing_policy"] ?? .null)
                return PaperDocChangeSharingPolicyDetails(
                    eventUuid: eventUuid,
                    publicSharingPolicy: publicSharingPolicy,
                    teamSharingPolicy: teamSharingPolicy
                )
            default:
                throw JSONSerializerError.deserializeError(type: PaperDocChangeSharingPolicyDetails.self, json: json)
            }
        }
    }

    /// The PaperDocChangeSharingPolicyType struct
    public class PaperDocChangeSharingPolicyType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try PaperDocChangeSharingPolicyTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PaperDocChangeSharingPolicyTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PaperDocChangeSharingPolicyType: \(error)"
            }
        }
    }

    public class PaperDocChangeSharingPolicyTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PaperDocChangeSharingPolicyType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PaperDocChangeSharingPolicyType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return PaperDocChangeSharingPolicyType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: PaperDocChangeSharingPolicyType.self, json: json)
            }
        }
    }

    /// Followed/unfollowed Paper doc.
    public class PaperDocChangeSubscriptionDetails: CustomStringConvertible, JSONRepresentable {
        /// Event unique identifier.
        public let eventUuid: String
        /// New doc subscription level.
        public let newSubscriptionLevel: String
        /// Previous doc subscription level. Might be missing due to historical data gap.
        public let previousSubscriptionLevel: String?
        public init(eventUuid: String, newSubscriptionLevel: String, previousSubscriptionLevel: String? = nil) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
            stringValidator()(newSubscriptionLevel)
            self.newSubscriptionLevel = newSubscriptionLevel
            nullableValidator(stringValidator())(previousSubscriptionLevel)
            self.previousSubscriptionLevel = previousSubscriptionLevel
        }

        func json() throws -> JSON {
            try PaperDocChangeSubscriptionDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PaperDocChangeSubscriptionDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PaperDocChangeSubscriptionDetails: \(error)"
            }
        }
    }

    public class PaperDocChangeSubscriptionDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PaperDocChangeSubscriptionDetails) throws -> JSON {
            let output = [
                "event_uuid": try Serialization._StringSerializer.serialize(value.eventUuid),
                "new_subscription_level": try Serialization._StringSerializer.serialize(value.newSubscriptionLevel),
                "previous_subscription_level": try NullableSerializer(Serialization._StringSerializer).serialize(value.previousSubscriptionLevel),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PaperDocChangeSubscriptionDetails {
            switch json {
            case .dictionary(let dict):
                let eventUuid = try Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                let newSubscriptionLevel = try Serialization._StringSerializer.deserialize(dict["new_subscription_level"] ?? .null)
                let previousSubscriptionLevel = try NullableSerializer(Serialization._StringSerializer)
                    .deserialize(dict["previous_subscription_level"] ?? .null)
                return PaperDocChangeSubscriptionDetails(
                    eventUuid: eventUuid,
                    newSubscriptionLevel: newSubscriptionLevel,
                    previousSubscriptionLevel: previousSubscriptionLevel
                )
            default:
                throw JSONSerializerError.deserializeError(type: PaperDocChangeSubscriptionDetails.self, json: json)
            }
        }
    }

    /// The PaperDocChangeSubscriptionType struct
    public class PaperDocChangeSubscriptionType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try PaperDocChangeSubscriptionTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PaperDocChangeSubscriptionTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PaperDocChangeSubscriptionType: \(error)"
            }
        }
    }

    public class PaperDocChangeSubscriptionTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PaperDocChangeSubscriptionType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PaperDocChangeSubscriptionType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return PaperDocChangeSubscriptionType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: PaperDocChangeSubscriptionType.self, json: json)
            }
        }
    }

    /// Deleted Paper doc comment.
    public class PaperDocDeleteCommentDetails: CustomStringConvertible, JSONRepresentable {
        /// Event unique identifier.
        public let eventUuid: String
        /// Comment text.
        public let commentText: String?
        public init(eventUuid: String, commentText: String? = nil) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
            nullableValidator(stringValidator())(commentText)
            self.commentText = commentText
        }

        func json() throws -> JSON {
            try PaperDocDeleteCommentDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PaperDocDeleteCommentDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PaperDocDeleteCommentDetails: \(error)"
            }
        }
    }

    public class PaperDocDeleteCommentDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PaperDocDeleteCommentDetails) throws -> JSON {
            let output = [
                "event_uuid": try Serialization._StringSerializer.serialize(value.eventUuid),
                "comment_text": try NullableSerializer(Serialization._StringSerializer).serialize(value.commentText),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PaperDocDeleteCommentDetails {
            switch json {
            case .dictionary(let dict):
                let eventUuid = try Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                let commentText = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["comment_text"] ?? .null)
                return PaperDocDeleteCommentDetails(eventUuid: eventUuid, commentText: commentText)
            default:
                throw JSONSerializerError.deserializeError(type: PaperDocDeleteCommentDetails.self, json: json)
            }
        }
    }

    /// The PaperDocDeleteCommentType struct
    public class PaperDocDeleteCommentType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try PaperDocDeleteCommentTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PaperDocDeleteCommentTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PaperDocDeleteCommentType: \(error)"
            }
        }
    }

    public class PaperDocDeleteCommentTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PaperDocDeleteCommentType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PaperDocDeleteCommentType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return PaperDocDeleteCommentType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: PaperDocDeleteCommentType.self, json: json)
            }
        }
    }

    /// Archived Paper doc.
    public class PaperDocDeletedDetails: CustomStringConvertible, JSONRepresentable {
        /// Event unique identifier.
        public let eventUuid: String
        public init(eventUuid: String) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
        }

        func json() throws -> JSON {
            try PaperDocDeletedDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PaperDocDeletedDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PaperDocDeletedDetails: \(error)"
            }
        }
    }

    public class PaperDocDeletedDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PaperDocDeletedDetails) throws -> JSON {
            let output = [
                "event_uuid": try Serialization._StringSerializer.serialize(value.eventUuid),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PaperDocDeletedDetails {
            switch json {
            case .dictionary(let dict):
                let eventUuid = try Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                return PaperDocDeletedDetails(eventUuid: eventUuid)
            default:
                throw JSONSerializerError.deserializeError(type: PaperDocDeletedDetails.self, json: json)
            }
        }
    }

    /// The PaperDocDeletedType struct
    public class PaperDocDeletedType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try PaperDocDeletedTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PaperDocDeletedTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PaperDocDeletedType: \(error)"
            }
        }
    }

    public class PaperDocDeletedTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PaperDocDeletedType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PaperDocDeletedType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return PaperDocDeletedType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: PaperDocDeletedType.self, json: json)
            }
        }
    }

    /// Downloaded Paper doc in specific format.
    public class PaperDocDownloadDetails: CustomStringConvertible, JSONRepresentable {
        /// Event unique identifier.
        public let eventUuid: String
        /// Export file format.
        public let exportFileFormat: TeamLog.PaperDownloadFormat
        public init(eventUuid: String, exportFileFormat: TeamLog.PaperDownloadFormat) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
            self.exportFileFormat = exportFileFormat
        }

        func json() throws -> JSON {
            try PaperDocDownloadDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PaperDocDownloadDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PaperDocDownloadDetails: \(error)"
            }
        }
    }

    public class PaperDocDownloadDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PaperDocDownloadDetails) throws -> JSON {
            let output = [
                "event_uuid": try Serialization._StringSerializer.serialize(value.eventUuid),
                "export_file_format": try TeamLog.PaperDownloadFormatSerializer().serialize(value.exportFileFormat),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PaperDocDownloadDetails {
            switch json {
            case .dictionary(let dict):
                let eventUuid = try Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                let exportFileFormat = try TeamLog.PaperDownloadFormatSerializer().deserialize(dict["export_file_format"] ?? .null)
                return PaperDocDownloadDetails(eventUuid: eventUuid, exportFileFormat: exportFileFormat)
            default:
                throw JSONSerializerError.deserializeError(type: PaperDocDownloadDetails.self, json: json)
            }
        }
    }

    /// The PaperDocDownloadType struct
    public class PaperDocDownloadType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try PaperDocDownloadTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PaperDocDownloadTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PaperDocDownloadType: \(error)"
            }
        }
    }

    public class PaperDocDownloadTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PaperDocDownloadType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PaperDocDownloadType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return PaperDocDownloadType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: PaperDocDownloadType.self, json: json)
            }
        }
    }

    /// Edited Paper doc comment.
    public class PaperDocEditCommentDetails: CustomStringConvertible, JSONRepresentable {
        /// Event unique identifier.
        public let eventUuid: String
        /// Comment text.
        public let commentText: String?
        public init(eventUuid: String, commentText: String? = nil) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
            nullableValidator(stringValidator())(commentText)
            self.commentText = commentText
        }

        func json() throws -> JSON {
            try PaperDocEditCommentDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PaperDocEditCommentDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PaperDocEditCommentDetails: \(error)"
            }
        }
    }

    public class PaperDocEditCommentDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PaperDocEditCommentDetails) throws -> JSON {
            let output = [
                "event_uuid": try Serialization._StringSerializer.serialize(value.eventUuid),
                "comment_text": try NullableSerializer(Serialization._StringSerializer).serialize(value.commentText),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PaperDocEditCommentDetails {
            switch json {
            case .dictionary(let dict):
                let eventUuid = try Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                let commentText = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["comment_text"] ?? .null)
                return PaperDocEditCommentDetails(eventUuid: eventUuid, commentText: commentText)
            default:
                throw JSONSerializerError.deserializeError(type: PaperDocEditCommentDetails.self, json: json)
            }
        }
    }

    /// The PaperDocEditCommentType struct
    public class PaperDocEditCommentType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try PaperDocEditCommentTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PaperDocEditCommentTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PaperDocEditCommentType: \(error)"
            }
        }
    }

    public class PaperDocEditCommentTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PaperDocEditCommentType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PaperDocEditCommentType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return PaperDocEditCommentType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: PaperDocEditCommentType.self, json: json)
            }
        }
    }

    /// Edited Paper doc.
    public class PaperDocEditDetails: CustomStringConvertible, JSONRepresentable {
        /// Event unique identifier.
        public let eventUuid: String
        public init(eventUuid: String) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
        }

        func json() throws -> JSON {
            try PaperDocEditDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PaperDocEditDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PaperDocEditDetails: \(error)"
            }
        }
    }

    public class PaperDocEditDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PaperDocEditDetails) throws -> JSON {
            let output = [
                "event_uuid": try Serialization._StringSerializer.serialize(value.eventUuid),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PaperDocEditDetails {
            switch json {
            case .dictionary(let dict):
                let eventUuid = try Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                return PaperDocEditDetails(eventUuid: eventUuid)
            default:
                throw JSONSerializerError.deserializeError(type: PaperDocEditDetails.self, json: json)
            }
        }
    }

    /// The PaperDocEditType struct
    public class PaperDocEditType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try PaperDocEditTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PaperDocEditTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PaperDocEditType: \(error)"
            }
        }
    }

    public class PaperDocEditTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PaperDocEditType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PaperDocEditType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return PaperDocEditType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: PaperDocEditType.self, json: json)
            }
        }
    }

    /// Followed Paper doc.
    public class PaperDocFollowedDetails: CustomStringConvertible, JSONRepresentable {
        /// Event unique identifier.
        public let eventUuid: String
        public init(eventUuid: String) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
        }

        func json() throws -> JSON {
            try PaperDocFollowedDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PaperDocFollowedDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PaperDocFollowedDetails: \(error)"
            }
        }
    }

    public class PaperDocFollowedDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PaperDocFollowedDetails) throws -> JSON {
            let output = [
                "event_uuid": try Serialization._StringSerializer.serialize(value.eventUuid),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PaperDocFollowedDetails {
            switch json {
            case .dictionary(let dict):
                let eventUuid = try Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                return PaperDocFollowedDetails(eventUuid: eventUuid)
            default:
                throw JSONSerializerError.deserializeError(type: PaperDocFollowedDetails.self, json: json)
            }
        }
    }

    /// The PaperDocFollowedType struct
    public class PaperDocFollowedType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try PaperDocFollowedTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PaperDocFollowedTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PaperDocFollowedType: \(error)"
            }
        }
    }

    public class PaperDocFollowedTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PaperDocFollowedType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PaperDocFollowedType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return PaperDocFollowedType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: PaperDocFollowedType.self, json: json)
            }
        }
    }

    /// Mentioned user in Paper doc.
    public class PaperDocMentionDetails: CustomStringConvertible, JSONRepresentable {
        /// Event unique identifier.
        public let eventUuid: String
        public init(eventUuid: String) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
        }

        func json() throws -> JSON {
            try PaperDocMentionDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PaperDocMentionDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PaperDocMentionDetails: \(error)"
            }
        }
    }

    public class PaperDocMentionDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PaperDocMentionDetails) throws -> JSON {
            let output = [
                "event_uuid": try Serialization._StringSerializer.serialize(value.eventUuid),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PaperDocMentionDetails {
            switch json {
            case .dictionary(let dict):
                let eventUuid = try Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                return PaperDocMentionDetails(eventUuid: eventUuid)
            default:
                throw JSONSerializerError.deserializeError(type: PaperDocMentionDetails.self, json: json)
            }
        }
    }

    /// The PaperDocMentionType struct
    public class PaperDocMentionType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try PaperDocMentionTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PaperDocMentionTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PaperDocMentionType: \(error)"
            }
        }
    }

    public class PaperDocMentionTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PaperDocMentionType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PaperDocMentionType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return PaperDocMentionType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: PaperDocMentionType.self, json: json)
            }
        }
    }

    /// Transferred ownership of Paper doc.
    public class PaperDocOwnershipChangedDetails: CustomStringConvertible, JSONRepresentable {
        /// Event unique identifier.
        public let eventUuid: String
        /// Previous owner.
        public let oldOwnerUserId: String?
        /// New owner.
        public let newOwnerUserId: String
        public init(eventUuid: String, newOwnerUserId: String, oldOwnerUserId: String? = nil) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
            nullableValidator(stringValidator(minLength: 40, maxLength: 40))(oldOwnerUserId)
            self.oldOwnerUserId = oldOwnerUserId
            stringValidator(minLength: 40, maxLength: 40)(newOwnerUserId)
            self.newOwnerUserId = newOwnerUserId
        }

        func json() throws -> JSON {
            try PaperDocOwnershipChangedDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PaperDocOwnershipChangedDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PaperDocOwnershipChangedDetails: \(error)"
            }
        }
    }

    public class PaperDocOwnershipChangedDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PaperDocOwnershipChangedDetails) throws -> JSON {
            let output = [
                "event_uuid": try Serialization._StringSerializer.serialize(value.eventUuid),
                "new_owner_user_id": try Serialization._StringSerializer.serialize(value.newOwnerUserId),
                "old_owner_user_id": try NullableSerializer(Serialization._StringSerializer).serialize(value.oldOwnerUserId),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PaperDocOwnershipChangedDetails {
            switch json {
            case .dictionary(let dict):
                let eventUuid = try Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                let newOwnerUserId = try Serialization._StringSerializer.deserialize(dict["new_owner_user_id"] ?? .null)
                let oldOwnerUserId = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["old_owner_user_id"] ?? .null)
                return PaperDocOwnershipChangedDetails(eventUuid: eventUuid, newOwnerUserId: newOwnerUserId, oldOwnerUserId: oldOwnerUserId)
            default:
                throw JSONSerializerError.deserializeError(type: PaperDocOwnershipChangedDetails.self, json: json)
            }
        }
    }

    /// The PaperDocOwnershipChangedType struct
    public class PaperDocOwnershipChangedType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try PaperDocOwnershipChangedTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PaperDocOwnershipChangedTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PaperDocOwnershipChangedType: \(error)"
            }
        }
    }

    public class PaperDocOwnershipChangedTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PaperDocOwnershipChangedType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PaperDocOwnershipChangedType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return PaperDocOwnershipChangedType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: PaperDocOwnershipChangedType.self, json: json)
            }
        }
    }

    /// Requested access to Paper doc.
    public class PaperDocRequestAccessDetails: CustomStringConvertible, JSONRepresentable {
        /// Event unique identifier.
        public let eventUuid: String
        public init(eventUuid: String) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
        }

        func json() throws -> JSON {
            try PaperDocRequestAccessDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PaperDocRequestAccessDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PaperDocRequestAccessDetails: \(error)"
            }
        }
    }

    public class PaperDocRequestAccessDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PaperDocRequestAccessDetails) throws -> JSON {
            let output = [
                "event_uuid": try Serialization._StringSerializer.serialize(value.eventUuid),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PaperDocRequestAccessDetails {
            switch json {
            case .dictionary(let dict):
                let eventUuid = try Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                return PaperDocRequestAccessDetails(eventUuid: eventUuid)
            default:
                throw JSONSerializerError.deserializeError(type: PaperDocRequestAccessDetails.self, json: json)
            }
        }
    }

    /// The PaperDocRequestAccessType struct
    public class PaperDocRequestAccessType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try PaperDocRequestAccessTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PaperDocRequestAccessTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PaperDocRequestAccessType: \(error)"
            }
        }
    }

    public class PaperDocRequestAccessTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PaperDocRequestAccessType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PaperDocRequestAccessType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return PaperDocRequestAccessType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: PaperDocRequestAccessType.self, json: json)
            }
        }
    }

    /// Resolved Paper doc comment.
    public class PaperDocResolveCommentDetails: CustomStringConvertible, JSONRepresentable {
        /// Event unique identifier.
        public let eventUuid: String
        /// Comment text.
        public let commentText: String?
        public init(eventUuid: String, commentText: String? = nil) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
            nullableValidator(stringValidator())(commentText)
            self.commentText = commentText
        }

        func json() throws -> JSON {
            try PaperDocResolveCommentDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PaperDocResolveCommentDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PaperDocResolveCommentDetails: \(error)"
            }
        }
    }

    public class PaperDocResolveCommentDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PaperDocResolveCommentDetails) throws -> JSON {
            let output = [
                "event_uuid": try Serialization._StringSerializer.serialize(value.eventUuid),
                "comment_text": try NullableSerializer(Serialization._StringSerializer).serialize(value.commentText),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PaperDocResolveCommentDetails {
            switch json {
            case .dictionary(let dict):
                let eventUuid = try Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                let commentText = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["comment_text"] ?? .null)
                return PaperDocResolveCommentDetails(eventUuid: eventUuid, commentText: commentText)
            default:
                throw JSONSerializerError.deserializeError(type: PaperDocResolveCommentDetails.self, json: json)
            }
        }
    }

    /// The PaperDocResolveCommentType struct
    public class PaperDocResolveCommentType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try PaperDocResolveCommentTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PaperDocResolveCommentTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PaperDocResolveCommentType: \(error)"
            }
        }
    }

    public class PaperDocResolveCommentTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PaperDocResolveCommentType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PaperDocResolveCommentType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return PaperDocResolveCommentType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: PaperDocResolveCommentType.self, json: json)
            }
        }
    }

    /// Restored Paper doc to previous version.
    public class PaperDocRevertDetails: CustomStringConvertible, JSONRepresentable {
        /// Event unique identifier.
        public let eventUuid: String
        public init(eventUuid: String) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
        }

        func json() throws -> JSON {
            try PaperDocRevertDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PaperDocRevertDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PaperDocRevertDetails: \(error)"
            }
        }
    }

    public class PaperDocRevertDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PaperDocRevertDetails) throws -> JSON {
            let output = [
                "event_uuid": try Serialization._StringSerializer.serialize(value.eventUuid),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PaperDocRevertDetails {
            switch json {
            case .dictionary(let dict):
                let eventUuid = try Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                return PaperDocRevertDetails(eventUuid: eventUuid)
            default:
                throw JSONSerializerError.deserializeError(type: PaperDocRevertDetails.self, json: json)
            }
        }
    }

    /// The PaperDocRevertType struct
    public class PaperDocRevertType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try PaperDocRevertTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PaperDocRevertTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PaperDocRevertType: \(error)"
            }
        }
    }

    public class PaperDocRevertTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PaperDocRevertType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PaperDocRevertType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return PaperDocRevertType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: PaperDocRevertType.self, json: json)
            }
        }
    }

    /// Shared Paper doc via Slack.
    public class PaperDocSlackShareDetails: CustomStringConvertible, JSONRepresentable {
        /// Event unique identifier.
        public let eventUuid: String
        public init(eventUuid: String) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
        }

        func json() throws -> JSON {
            try PaperDocSlackShareDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PaperDocSlackShareDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PaperDocSlackShareDetails: \(error)"
            }
        }
    }

    public class PaperDocSlackShareDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PaperDocSlackShareDetails) throws -> JSON {
            let output = [
                "event_uuid": try Serialization._StringSerializer.serialize(value.eventUuid),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PaperDocSlackShareDetails {
            switch json {
            case .dictionary(let dict):
                let eventUuid = try Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                return PaperDocSlackShareDetails(eventUuid: eventUuid)
            default:
                throw JSONSerializerError.deserializeError(type: PaperDocSlackShareDetails.self, json: json)
            }
        }
    }

    /// The PaperDocSlackShareType struct
    public class PaperDocSlackShareType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try PaperDocSlackShareTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PaperDocSlackShareTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PaperDocSlackShareType: \(error)"
            }
        }
    }

    public class PaperDocSlackShareTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PaperDocSlackShareType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PaperDocSlackShareType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return PaperDocSlackShareType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: PaperDocSlackShareType.self, json: json)
            }
        }
    }

    /// Shared Paper doc with users and/or groups.
    public class PaperDocTeamInviteDetails: CustomStringConvertible, JSONRepresentable {
        /// Event unique identifier.
        public let eventUuid: String
        public init(eventUuid: String) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
        }

        func json() throws -> JSON {
            try PaperDocTeamInviteDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PaperDocTeamInviteDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PaperDocTeamInviteDetails: \(error)"
            }
        }
    }

    public class PaperDocTeamInviteDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PaperDocTeamInviteDetails) throws -> JSON {
            let output = [
                "event_uuid": try Serialization._StringSerializer.serialize(value.eventUuid),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PaperDocTeamInviteDetails {
            switch json {
            case .dictionary(let dict):
                let eventUuid = try Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                return PaperDocTeamInviteDetails(eventUuid: eventUuid)
            default:
                throw JSONSerializerError.deserializeError(type: PaperDocTeamInviteDetails.self, json: json)
            }
        }
    }

    /// The PaperDocTeamInviteType struct
    public class PaperDocTeamInviteType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try PaperDocTeamInviteTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PaperDocTeamInviteTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PaperDocTeamInviteType: \(error)"
            }
        }
    }

    public class PaperDocTeamInviteTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PaperDocTeamInviteType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PaperDocTeamInviteType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return PaperDocTeamInviteType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: PaperDocTeamInviteType.self, json: json)
            }
        }
    }

    /// Deleted Paper doc.
    public class PaperDocTrashedDetails: CustomStringConvertible, JSONRepresentable {
        /// Event unique identifier.
        public let eventUuid: String
        public init(eventUuid: String) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
        }

        func json() throws -> JSON {
            try PaperDocTrashedDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PaperDocTrashedDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PaperDocTrashedDetails: \(error)"
            }
        }
    }

    public class PaperDocTrashedDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PaperDocTrashedDetails) throws -> JSON {
            let output = [
                "event_uuid": try Serialization._StringSerializer.serialize(value.eventUuid),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PaperDocTrashedDetails {
            switch json {
            case .dictionary(let dict):
                let eventUuid = try Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                return PaperDocTrashedDetails(eventUuid: eventUuid)
            default:
                throw JSONSerializerError.deserializeError(type: PaperDocTrashedDetails.self, json: json)
            }
        }
    }

    /// The PaperDocTrashedType struct
    public class PaperDocTrashedType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try PaperDocTrashedTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PaperDocTrashedTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PaperDocTrashedType: \(error)"
            }
        }
    }

    public class PaperDocTrashedTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PaperDocTrashedType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PaperDocTrashedType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return PaperDocTrashedType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: PaperDocTrashedType.self, json: json)
            }
        }
    }

    /// Unresolved Paper doc comment.
    public class PaperDocUnresolveCommentDetails: CustomStringConvertible, JSONRepresentable {
        /// Event unique identifier.
        public let eventUuid: String
        /// Comment text.
        public let commentText: String?
        public init(eventUuid: String, commentText: String? = nil) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
            nullableValidator(stringValidator())(commentText)
            self.commentText = commentText
        }

        func json() throws -> JSON {
            try PaperDocUnresolveCommentDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PaperDocUnresolveCommentDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PaperDocUnresolveCommentDetails: \(error)"
            }
        }
    }

    public class PaperDocUnresolveCommentDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PaperDocUnresolveCommentDetails) throws -> JSON {
            let output = [
                "event_uuid": try Serialization._StringSerializer.serialize(value.eventUuid),
                "comment_text": try NullableSerializer(Serialization._StringSerializer).serialize(value.commentText),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PaperDocUnresolveCommentDetails {
            switch json {
            case .dictionary(let dict):
                let eventUuid = try Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                let commentText = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["comment_text"] ?? .null)
                return PaperDocUnresolveCommentDetails(eventUuid: eventUuid, commentText: commentText)
            default:
                throw JSONSerializerError.deserializeError(type: PaperDocUnresolveCommentDetails.self, json: json)
            }
        }
    }

    /// The PaperDocUnresolveCommentType struct
    public class PaperDocUnresolveCommentType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try PaperDocUnresolveCommentTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PaperDocUnresolveCommentTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PaperDocUnresolveCommentType: \(error)"
            }
        }
    }

    public class PaperDocUnresolveCommentTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PaperDocUnresolveCommentType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PaperDocUnresolveCommentType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return PaperDocUnresolveCommentType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: PaperDocUnresolveCommentType.self, json: json)
            }
        }
    }

    /// Restored Paper doc.
    public class PaperDocUntrashedDetails: CustomStringConvertible, JSONRepresentable {
        /// Event unique identifier.
        public let eventUuid: String
        public init(eventUuid: String) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
        }

        func json() throws -> JSON {
            try PaperDocUntrashedDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PaperDocUntrashedDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PaperDocUntrashedDetails: \(error)"
            }
        }
    }

    public class PaperDocUntrashedDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PaperDocUntrashedDetails) throws -> JSON {
            let output = [
                "event_uuid": try Serialization._StringSerializer.serialize(value.eventUuid),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PaperDocUntrashedDetails {
            switch json {
            case .dictionary(let dict):
                let eventUuid = try Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                return PaperDocUntrashedDetails(eventUuid: eventUuid)
            default:
                throw JSONSerializerError.deserializeError(type: PaperDocUntrashedDetails.self, json: json)
            }
        }
    }

    /// The PaperDocUntrashedType struct
    public class PaperDocUntrashedType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try PaperDocUntrashedTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PaperDocUntrashedTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PaperDocUntrashedType: \(error)"
            }
        }
    }

    public class PaperDocUntrashedTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PaperDocUntrashedType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PaperDocUntrashedType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return PaperDocUntrashedType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: PaperDocUntrashedType.self, json: json)
            }
        }
    }

    /// Viewed Paper doc.
    public class PaperDocViewDetails: CustomStringConvertible, JSONRepresentable {
        /// Event unique identifier.
        public let eventUuid: String
        public init(eventUuid: String) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
        }

        func json() throws -> JSON {
            try PaperDocViewDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PaperDocViewDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PaperDocViewDetails: \(error)"
            }
        }
    }

    public class PaperDocViewDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PaperDocViewDetails) throws -> JSON {
            let output = [
                "event_uuid": try Serialization._StringSerializer.serialize(value.eventUuid),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PaperDocViewDetails {
            switch json {
            case .dictionary(let dict):
                let eventUuid = try Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                return PaperDocViewDetails(eventUuid: eventUuid)
            default:
                throw JSONSerializerError.deserializeError(type: PaperDocViewDetails.self, json: json)
            }
        }
    }

    /// The PaperDocViewType struct
    public class PaperDocViewType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try PaperDocViewTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PaperDocViewTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PaperDocViewType: \(error)"
            }
        }
    }

    public class PaperDocViewTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PaperDocViewType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PaperDocViewType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return PaperDocViewType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: PaperDocViewType.self, json: json)
            }
        }
    }

    /// Paper document's logged information.
    public class PaperDocumentLogInfo: CustomStringConvertible, JSONRepresentable {
        /// Papers document Id.
        public let docId: String
        /// Paper document title.
        public let docTitle: String
        public init(docId: String, docTitle: String) {
            stringValidator()(docId)
            self.docId = docId
            stringValidator()(docTitle)
            self.docTitle = docTitle
        }

        func json() throws -> JSON {
            try PaperDocumentLogInfoSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PaperDocumentLogInfoSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PaperDocumentLogInfo: \(error)"
            }
        }
    }

    public class PaperDocumentLogInfoSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PaperDocumentLogInfo) throws -> JSON {
            let output = [
                "doc_id": try Serialization._StringSerializer.serialize(value.docId),
                "doc_title": try Serialization._StringSerializer.serialize(value.docTitle),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PaperDocumentLogInfo {
            switch json {
            case .dictionary(let dict):
                let docId = try Serialization._StringSerializer.deserialize(dict["doc_id"] ?? .null)
                let docTitle = try Serialization._StringSerializer.deserialize(dict["doc_title"] ?? .null)
                return PaperDocumentLogInfo(docId: docId, docTitle: docTitle)
            default:
                throw JSONSerializerError.deserializeError(type: PaperDocumentLogInfo.self, json: json)
            }
        }
    }

    /// The PaperDownloadFormat union
    public enum PaperDownloadFormat: CustomStringConvertible, JSONRepresentable {
        /// An unspecified error.
        case docx
        /// An unspecified error.
        case html
        /// An unspecified error.
        case markdown
        /// An unspecified error.
        case pdf
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try PaperDownloadFormatSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PaperDownloadFormatSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PaperDownloadFormat: \(error)"
            }
        }
    }

    public class PaperDownloadFormatSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PaperDownloadFormat) throws -> JSON {
            switch value {
            case .docx:
                var d = [String: JSON]()
                d[".tag"] = .str("docx")
                return .dictionary(d)
            case .html:
                var d = [String: JSON]()
                d[".tag"] = .str("html")
                return .dictionary(d)
            case .markdown:
                var d = [String: JSON]()
                d[".tag"] = .str("markdown")
                return .dictionary(d)
            case .pdf:
                var d = [String: JSON]()
                d[".tag"] = .str("pdf")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> PaperDownloadFormat {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "docx":
                    return PaperDownloadFormat.docx
                case "html":
                    return PaperDownloadFormat.html
                case "markdown":
                    return PaperDownloadFormat.markdown
                case "pdf":
                    return PaperDownloadFormat.pdf
                case "other":
                    return PaperDownloadFormat.other
                default:
                    return PaperDownloadFormat.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: PaperDownloadFormat.self, json: json)
            }
        }
    }

    /// Added users to Paper-enabled users list.
    public class PaperEnabledUsersGroupAdditionDetails: CustomStringConvertible, JSONRepresentable {
        func json() throws -> JSON {
            try PaperEnabledUsersGroupAdditionDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PaperEnabledUsersGroupAdditionDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PaperEnabledUsersGroupAdditionDetails: \(error)"
            }
        }
    }

    public class PaperEnabledUsersGroupAdditionDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PaperEnabledUsersGroupAdditionDetails) throws -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PaperEnabledUsersGroupAdditionDetails {
            switch json {
            case .dictionary:
                return PaperEnabledUsersGroupAdditionDetails()
            default:
                throw JSONSerializerError.deserializeError(type: PaperEnabledUsersGroupAdditionDetails.self, json: json)
            }
        }
    }

    /// The PaperEnabledUsersGroupAdditionType struct
    public class PaperEnabledUsersGroupAdditionType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try PaperEnabledUsersGroupAdditionTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PaperEnabledUsersGroupAdditionTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PaperEnabledUsersGroupAdditionType: \(error)"
            }
        }
    }

    public class PaperEnabledUsersGroupAdditionTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PaperEnabledUsersGroupAdditionType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PaperEnabledUsersGroupAdditionType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return PaperEnabledUsersGroupAdditionType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: PaperEnabledUsersGroupAdditionType.self, json: json)
            }
        }
    }

    /// Removed users from Paper-enabled users list.
    public class PaperEnabledUsersGroupRemovalDetails: CustomStringConvertible, JSONRepresentable {
        func json() throws -> JSON {
            try PaperEnabledUsersGroupRemovalDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PaperEnabledUsersGroupRemovalDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PaperEnabledUsersGroupRemovalDetails: \(error)"
            }
        }
    }

    public class PaperEnabledUsersGroupRemovalDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PaperEnabledUsersGroupRemovalDetails) throws -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PaperEnabledUsersGroupRemovalDetails {
            switch json {
            case .dictionary:
                return PaperEnabledUsersGroupRemovalDetails()
            default:
                throw JSONSerializerError.deserializeError(type: PaperEnabledUsersGroupRemovalDetails.self, json: json)
            }
        }
    }

    /// The PaperEnabledUsersGroupRemovalType struct
    public class PaperEnabledUsersGroupRemovalType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try PaperEnabledUsersGroupRemovalTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PaperEnabledUsersGroupRemovalTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PaperEnabledUsersGroupRemovalType: \(error)"
            }
        }
    }

    public class PaperEnabledUsersGroupRemovalTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PaperEnabledUsersGroupRemovalType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PaperEnabledUsersGroupRemovalType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return PaperEnabledUsersGroupRemovalType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: PaperEnabledUsersGroupRemovalType.self, json: json)
            }
        }
    }

    /// Changed Paper external sharing setting to anyone.
    public class PaperExternalViewAllowDetails: CustomStringConvertible, JSONRepresentable {
        /// Event unique identifier.
        public let eventUuid: String
        public init(eventUuid: String) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
        }

        func json() throws -> JSON {
            try PaperExternalViewAllowDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PaperExternalViewAllowDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PaperExternalViewAllowDetails: \(error)"
            }
        }
    }

    public class PaperExternalViewAllowDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PaperExternalViewAllowDetails) throws -> JSON {
            let output = [
                "event_uuid": try Serialization._StringSerializer.serialize(value.eventUuid),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PaperExternalViewAllowDetails {
            switch json {
            case .dictionary(let dict):
                let eventUuid = try Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                return PaperExternalViewAllowDetails(eventUuid: eventUuid)
            default:
                throw JSONSerializerError.deserializeError(type: PaperExternalViewAllowDetails.self, json: json)
            }
        }
    }

    /// The PaperExternalViewAllowType struct
    public class PaperExternalViewAllowType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try PaperExternalViewAllowTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PaperExternalViewAllowTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PaperExternalViewAllowType: \(error)"
            }
        }
    }

    public class PaperExternalViewAllowTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PaperExternalViewAllowType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PaperExternalViewAllowType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return PaperExternalViewAllowType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: PaperExternalViewAllowType.self, json: json)
            }
        }
    }

    /// Changed Paper external sharing setting to default team.
    public class PaperExternalViewDefaultTeamDetails: CustomStringConvertible, JSONRepresentable {
        /// Event unique identifier.
        public let eventUuid: String
        public init(eventUuid: String) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
        }

        func json() throws -> JSON {
            try PaperExternalViewDefaultTeamDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PaperExternalViewDefaultTeamDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PaperExternalViewDefaultTeamDetails: \(error)"
            }
        }
    }

    public class PaperExternalViewDefaultTeamDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PaperExternalViewDefaultTeamDetails) throws -> JSON {
            let output = [
                "event_uuid": try Serialization._StringSerializer.serialize(value.eventUuid),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PaperExternalViewDefaultTeamDetails {
            switch json {
            case .dictionary(let dict):
                let eventUuid = try Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                return PaperExternalViewDefaultTeamDetails(eventUuid: eventUuid)
            default:
                throw JSONSerializerError.deserializeError(type: PaperExternalViewDefaultTeamDetails.self, json: json)
            }
        }
    }

    /// The PaperExternalViewDefaultTeamType struct
    public class PaperExternalViewDefaultTeamType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try PaperExternalViewDefaultTeamTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PaperExternalViewDefaultTeamTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PaperExternalViewDefaultTeamType: \(error)"
            }
        }
    }

    public class PaperExternalViewDefaultTeamTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PaperExternalViewDefaultTeamType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PaperExternalViewDefaultTeamType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return PaperExternalViewDefaultTeamType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: PaperExternalViewDefaultTeamType.self, json: json)
            }
        }
    }

    /// Changed Paper external sharing setting to team-only.
    public class PaperExternalViewForbidDetails: CustomStringConvertible, JSONRepresentable {
        /// Event unique identifier.
        public let eventUuid: String
        public init(eventUuid: String) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
        }

        func json() throws -> JSON {
            try PaperExternalViewForbidDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PaperExternalViewForbidDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PaperExternalViewForbidDetails: \(error)"
            }
        }
    }

    public class PaperExternalViewForbidDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PaperExternalViewForbidDetails) throws -> JSON {
            let output = [
                "event_uuid": try Serialization._StringSerializer.serialize(value.eventUuid),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PaperExternalViewForbidDetails {
            switch json {
            case .dictionary(let dict):
                let eventUuid = try Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                return PaperExternalViewForbidDetails(eventUuid: eventUuid)
            default:
                throw JSONSerializerError.deserializeError(type: PaperExternalViewForbidDetails.self, json: json)
            }
        }
    }

    /// The PaperExternalViewForbidType struct
    public class PaperExternalViewForbidType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try PaperExternalViewForbidTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PaperExternalViewForbidTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PaperExternalViewForbidType: \(error)"
            }
        }
    }

    public class PaperExternalViewForbidTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PaperExternalViewForbidType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PaperExternalViewForbidType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return PaperExternalViewForbidType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: PaperExternalViewForbidType.self, json: json)
            }
        }
    }

    /// Followed/unfollowed Paper folder.
    public class PaperFolderChangeSubscriptionDetails: CustomStringConvertible, JSONRepresentable {
        /// Event unique identifier.
        public let eventUuid: String
        /// New folder subscription level.
        public let newSubscriptionLevel: String
        /// Previous folder subscription level. Might be missing due to historical data gap.
        public let previousSubscriptionLevel: String?
        public init(eventUuid: String, newSubscriptionLevel: String, previousSubscriptionLevel: String? = nil) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
            stringValidator()(newSubscriptionLevel)
            self.newSubscriptionLevel = newSubscriptionLevel
            nullableValidator(stringValidator())(previousSubscriptionLevel)
            self.previousSubscriptionLevel = previousSubscriptionLevel
        }

        func json() throws -> JSON {
            try PaperFolderChangeSubscriptionDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PaperFolderChangeSubscriptionDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PaperFolderChangeSubscriptionDetails: \(error)"
            }
        }
    }

    public class PaperFolderChangeSubscriptionDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PaperFolderChangeSubscriptionDetails) throws -> JSON {
            let output = [
                "event_uuid": try Serialization._StringSerializer.serialize(value.eventUuid),
                "new_subscription_level": try Serialization._StringSerializer.serialize(value.newSubscriptionLevel),
                "previous_subscription_level": try NullableSerializer(Serialization._StringSerializer).serialize(value.previousSubscriptionLevel),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PaperFolderChangeSubscriptionDetails {
            switch json {
            case .dictionary(let dict):
                let eventUuid = try Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                let newSubscriptionLevel = try Serialization._StringSerializer.deserialize(dict["new_subscription_level"] ?? .null)
                let previousSubscriptionLevel = try NullableSerializer(Serialization._StringSerializer)
                    .deserialize(dict["previous_subscription_level"] ?? .null)
                return PaperFolderChangeSubscriptionDetails(
                    eventUuid: eventUuid,
                    newSubscriptionLevel: newSubscriptionLevel,
                    previousSubscriptionLevel: previousSubscriptionLevel
                )
            default:
                throw JSONSerializerError.deserializeError(type: PaperFolderChangeSubscriptionDetails.self, json: json)
            }
        }
    }

    /// The PaperFolderChangeSubscriptionType struct
    public class PaperFolderChangeSubscriptionType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try PaperFolderChangeSubscriptionTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PaperFolderChangeSubscriptionTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PaperFolderChangeSubscriptionType: \(error)"
            }
        }
    }

    public class PaperFolderChangeSubscriptionTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PaperFolderChangeSubscriptionType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PaperFolderChangeSubscriptionType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return PaperFolderChangeSubscriptionType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: PaperFolderChangeSubscriptionType.self, json: json)
            }
        }
    }

    /// Archived Paper folder.
    public class PaperFolderDeletedDetails: CustomStringConvertible, JSONRepresentable {
        /// Event unique identifier.
        public let eventUuid: String
        public init(eventUuid: String) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
        }

        func json() throws -> JSON {
            try PaperFolderDeletedDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PaperFolderDeletedDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PaperFolderDeletedDetails: \(error)"
            }
        }
    }

    public class PaperFolderDeletedDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PaperFolderDeletedDetails) throws -> JSON {
            let output = [
                "event_uuid": try Serialization._StringSerializer.serialize(value.eventUuid),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PaperFolderDeletedDetails {
            switch json {
            case .dictionary(let dict):
                let eventUuid = try Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                return PaperFolderDeletedDetails(eventUuid: eventUuid)
            default:
                throw JSONSerializerError.deserializeError(type: PaperFolderDeletedDetails.self, json: json)
            }
        }
    }

    /// The PaperFolderDeletedType struct
    public class PaperFolderDeletedType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try PaperFolderDeletedTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PaperFolderDeletedTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PaperFolderDeletedType: \(error)"
            }
        }
    }

    public class PaperFolderDeletedTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PaperFolderDeletedType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PaperFolderDeletedType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return PaperFolderDeletedType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: PaperFolderDeletedType.self, json: json)
            }
        }
    }

    /// Followed Paper folder.
    public class PaperFolderFollowedDetails: CustomStringConvertible, JSONRepresentable {
        /// Event unique identifier.
        public let eventUuid: String
        public init(eventUuid: String) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
        }

        func json() throws -> JSON {
            try PaperFolderFollowedDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PaperFolderFollowedDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PaperFolderFollowedDetails: \(error)"
            }
        }
    }

    public class PaperFolderFollowedDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PaperFolderFollowedDetails) throws -> JSON {
            let output = [
                "event_uuid": try Serialization._StringSerializer.serialize(value.eventUuid),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PaperFolderFollowedDetails {
            switch json {
            case .dictionary(let dict):
                let eventUuid = try Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                return PaperFolderFollowedDetails(eventUuid: eventUuid)
            default:
                throw JSONSerializerError.deserializeError(type: PaperFolderFollowedDetails.self, json: json)
            }
        }
    }

    /// The PaperFolderFollowedType struct
    public class PaperFolderFollowedType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try PaperFolderFollowedTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PaperFolderFollowedTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PaperFolderFollowedType: \(error)"
            }
        }
    }

    public class PaperFolderFollowedTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PaperFolderFollowedType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PaperFolderFollowedType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return PaperFolderFollowedType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: PaperFolderFollowedType.self, json: json)
            }
        }
    }

    /// Paper folder's logged information.
    public class PaperFolderLogInfo: CustomStringConvertible, JSONRepresentable {
        /// Papers folder Id.
        public let folderId: String
        /// Paper folder name.
        public let folderName: String
        public init(folderId: String, folderName: String) {
            stringValidator()(folderId)
            self.folderId = folderId
            stringValidator()(folderName)
            self.folderName = folderName
        }

        func json() throws -> JSON {
            try PaperFolderLogInfoSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PaperFolderLogInfoSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PaperFolderLogInfo: \(error)"
            }
        }
    }

    public class PaperFolderLogInfoSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PaperFolderLogInfo) throws -> JSON {
            let output = [
                "folder_id": try Serialization._StringSerializer.serialize(value.folderId),
                "folder_name": try Serialization._StringSerializer.serialize(value.folderName),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PaperFolderLogInfo {
            switch json {
            case .dictionary(let dict):
                let folderId = try Serialization._StringSerializer.deserialize(dict["folder_id"] ?? .null)
                let folderName = try Serialization._StringSerializer.deserialize(dict["folder_name"] ?? .null)
                return PaperFolderLogInfo(folderId: folderId, folderName: folderName)
            default:
                throw JSONSerializerError.deserializeError(type: PaperFolderLogInfo.self, json: json)
            }
        }
    }

    /// Shared Paper folder with users and/or groups.
    public class PaperFolderTeamInviteDetails: CustomStringConvertible, JSONRepresentable {
        /// Event unique identifier.
        public let eventUuid: String
        public init(eventUuid: String) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
        }

        func json() throws -> JSON {
            try PaperFolderTeamInviteDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PaperFolderTeamInviteDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PaperFolderTeamInviteDetails: \(error)"
            }
        }
    }

    public class PaperFolderTeamInviteDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PaperFolderTeamInviteDetails) throws -> JSON {
            let output = [
                "event_uuid": try Serialization._StringSerializer.serialize(value.eventUuid),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PaperFolderTeamInviteDetails {
            switch json {
            case .dictionary(let dict):
                let eventUuid = try Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                return PaperFolderTeamInviteDetails(eventUuid: eventUuid)
            default:
                throw JSONSerializerError.deserializeError(type: PaperFolderTeamInviteDetails.self, json: json)
            }
        }
    }

    /// The PaperFolderTeamInviteType struct
    public class PaperFolderTeamInviteType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try PaperFolderTeamInviteTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PaperFolderTeamInviteTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PaperFolderTeamInviteType: \(error)"
            }
        }
    }

    public class PaperFolderTeamInviteTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PaperFolderTeamInviteType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PaperFolderTeamInviteType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return PaperFolderTeamInviteType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: PaperFolderTeamInviteType.self, json: json)
            }
        }
    }

    /// Policy for controlling if team members can share Paper documents externally.
    public enum PaperMemberPolicy: CustomStringConvertible, JSONRepresentable {
        /// An unspecified error.
        case anyoneWithLink
        /// An unspecified error.
        case onlyTeam
        /// An unspecified error.
        case teamAndExplicitlyShared
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try PaperMemberPolicySerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PaperMemberPolicySerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PaperMemberPolicy: \(error)"
            }
        }
    }

    public class PaperMemberPolicySerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PaperMemberPolicy) throws -> JSON {
            switch value {
            case .anyoneWithLink:
                var d = [String: JSON]()
                d[".tag"] = .str("anyone_with_link")
                return .dictionary(d)
            case .onlyTeam:
                var d = [String: JSON]()
                d[".tag"] = .str("only_team")
                return .dictionary(d)
            case .teamAndExplicitlyShared:
                var d = [String: JSON]()
                d[".tag"] = .str("team_and_explicitly_shared")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> PaperMemberPolicy {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "anyone_with_link":
                    return PaperMemberPolicy.anyoneWithLink
                case "only_team":
                    return PaperMemberPolicy.onlyTeam
                case "team_and_explicitly_shared":
                    return PaperMemberPolicy.teamAndExplicitlyShared
                case "other":
                    return PaperMemberPolicy.other
                default:
                    return PaperMemberPolicy.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: PaperMemberPolicy.self, json: json)
            }
        }
    }

    /// Changed permissions for published doc.
    public class PaperPublishedLinkChangePermissionDetails: CustomStringConvertible, JSONRepresentable {
        /// Event unique identifier.
        public let eventUuid: String
        /// New permission level.
        public let newPermissionLevel: String
        /// Previous permission level.
        public let previousPermissionLevel: String
        public init(eventUuid: String, newPermissionLevel: String, previousPermissionLevel: String) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
            stringValidator()(newPermissionLevel)
            self.newPermissionLevel = newPermissionLevel
            stringValidator()(previousPermissionLevel)
            self.previousPermissionLevel = previousPermissionLevel
        }

        func json() throws -> JSON {
            try PaperPublishedLinkChangePermissionDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PaperPublishedLinkChangePermissionDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PaperPublishedLinkChangePermissionDetails: \(error)"
            }
        }
    }

    public class PaperPublishedLinkChangePermissionDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PaperPublishedLinkChangePermissionDetails) throws -> JSON {
            let output = [
                "event_uuid": try Serialization._StringSerializer.serialize(value.eventUuid),
                "new_permission_level": try Serialization._StringSerializer.serialize(value.newPermissionLevel),
                "previous_permission_level": try Serialization._StringSerializer.serialize(value.previousPermissionLevel),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PaperPublishedLinkChangePermissionDetails {
            switch json {
            case .dictionary(let dict):
                let eventUuid = try Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                let newPermissionLevel = try Serialization._StringSerializer.deserialize(dict["new_permission_level"] ?? .null)
                let previousPermissionLevel = try Serialization._StringSerializer.deserialize(dict["previous_permission_level"] ?? .null)
                return PaperPublishedLinkChangePermissionDetails(
                    eventUuid: eventUuid,
                    newPermissionLevel: newPermissionLevel,
                    previousPermissionLevel: previousPermissionLevel
                )
            default:
                throw JSONSerializerError.deserializeError(type: PaperPublishedLinkChangePermissionDetails.self, json: json)
            }
        }
    }

    /// The PaperPublishedLinkChangePermissionType struct
    public class PaperPublishedLinkChangePermissionType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try PaperPublishedLinkChangePermissionTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PaperPublishedLinkChangePermissionTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PaperPublishedLinkChangePermissionType: \(error)"
            }
        }
    }

    public class PaperPublishedLinkChangePermissionTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PaperPublishedLinkChangePermissionType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PaperPublishedLinkChangePermissionType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return PaperPublishedLinkChangePermissionType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: PaperPublishedLinkChangePermissionType.self, json: json)
            }
        }
    }

    /// Published doc.
    public class PaperPublishedLinkCreateDetails: CustomStringConvertible, JSONRepresentable {
        /// Event unique identifier.
        public let eventUuid: String
        public init(eventUuid: String) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
        }

        func json() throws -> JSON {
            try PaperPublishedLinkCreateDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PaperPublishedLinkCreateDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PaperPublishedLinkCreateDetails: \(error)"
            }
        }
    }

    public class PaperPublishedLinkCreateDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PaperPublishedLinkCreateDetails) throws -> JSON {
            let output = [
                "event_uuid": try Serialization._StringSerializer.serialize(value.eventUuid),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PaperPublishedLinkCreateDetails {
            switch json {
            case .dictionary(let dict):
                let eventUuid = try Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                return PaperPublishedLinkCreateDetails(eventUuid: eventUuid)
            default:
                throw JSONSerializerError.deserializeError(type: PaperPublishedLinkCreateDetails.self, json: json)
            }
        }
    }

    /// The PaperPublishedLinkCreateType struct
    public class PaperPublishedLinkCreateType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try PaperPublishedLinkCreateTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PaperPublishedLinkCreateTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PaperPublishedLinkCreateType: \(error)"
            }
        }
    }

    public class PaperPublishedLinkCreateTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PaperPublishedLinkCreateType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PaperPublishedLinkCreateType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return PaperPublishedLinkCreateType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: PaperPublishedLinkCreateType.self, json: json)
            }
        }
    }

    /// Unpublished doc.
    public class PaperPublishedLinkDisabledDetails: CustomStringConvertible, JSONRepresentable {
        /// Event unique identifier.
        public let eventUuid: String
        public init(eventUuid: String) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
        }

        func json() throws -> JSON {
            try PaperPublishedLinkDisabledDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PaperPublishedLinkDisabledDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PaperPublishedLinkDisabledDetails: \(error)"
            }
        }
    }

    public class PaperPublishedLinkDisabledDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PaperPublishedLinkDisabledDetails) throws -> JSON {
            let output = [
                "event_uuid": try Serialization._StringSerializer.serialize(value.eventUuid),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PaperPublishedLinkDisabledDetails {
            switch json {
            case .dictionary(let dict):
                let eventUuid = try Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                return PaperPublishedLinkDisabledDetails(eventUuid: eventUuid)
            default:
                throw JSONSerializerError.deserializeError(type: PaperPublishedLinkDisabledDetails.self, json: json)
            }
        }
    }

    /// The PaperPublishedLinkDisabledType struct
    public class PaperPublishedLinkDisabledType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try PaperPublishedLinkDisabledTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PaperPublishedLinkDisabledTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PaperPublishedLinkDisabledType: \(error)"
            }
        }
    }

    public class PaperPublishedLinkDisabledTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PaperPublishedLinkDisabledType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PaperPublishedLinkDisabledType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return PaperPublishedLinkDisabledType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: PaperPublishedLinkDisabledType.self, json: json)
            }
        }
    }

    /// Viewed published doc.
    public class PaperPublishedLinkViewDetails: CustomStringConvertible, JSONRepresentable {
        /// Event unique identifier.
        public let eventUuid: String
        public init(eventUuid: String) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
        }

        func json() throws -> JSON {
            try PaperPublishedLinkViewDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PaperPublishedLinkViewDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PaperPublishedLinkViewDetails: \(error)"
            }
        }
    }

    public class PaperPublishedLinkViewDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PaperPublishedLinkViewDetails) throws -> JSON {
            let output = [
                "event_uuid": try Serialization._StringSerializer.serialize(value.eventUuid),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PaperPublishedLinkViewDetails {
            switch json {
            case .dictionary(let dict):
                let eventUuid = try Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                return PaperPublishedLinkViewDetails(eventUuid: eventUuid)
            default:
                throw JSONSerializerError.deserializeError(type: PaperPublishedLinkViewDetails.self, json: json)
            }
        }
    }

    /// The PaperPublishedLinkViewType struct
    public class PaperPublishedLinkViewType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try PaperPublishedLinkViewTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PaperPublishedLinkViewTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PaperPublishedLinkViewType: \(error)"
            }
        }
    }

    public class PaperPublishedLinkViewTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PaperPublishedLinkViewType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PaperPublishedLinkViewType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return PaperPublishedLinkViewType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: PaperPublishedLinkViewType.self, json: json)
            }
        }
    }

    /// A user or group
    public enum ParticipantLogInfo: CustomStringConvertible, JSONRepresentable {
        /// Group details.
        case group(TeamLog.GroupLogInfo)
        /// A user with a Dropbox account.
        case user(TeamLog.UserLogInfo)
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try ParticipantLogInfoSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ParticipantLogInfoSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ParticipantLogInfo: \(error)"
            }
        }
    }

    public class ParticipantLogInfoSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ParticipantLogInfo) throws -> JSON {
            switch value {
            case .group(let arg):
                var d = try Serialization.getFields(TeamLog.GroupLogInfoSerializer().serialize(arg))
                d[".tag"] = .str("group")
                return .dictionary(d)
            case .user(let arg):
                var d = try ["user": TeamLog.UserLogInfoSerializer().serialize(arg)]
                d[".tag"] = .str("user")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> ParticipantLogInfo {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "group":
                    let v = try TeamLog.GroupLogInfoSerializer().deserialize(json)
                    return ParticipantLogInfo.group(v)
                case "user":
                    let v = try TeamLog.UserLogInfoSerializer().deserialize(d["user"] ?? .null)
                    return ParticipantLogInfo.user(v)
                case "other":
                    return ParticipantLogInfo.other
                default:
                    return ParticipantLogInfo.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: ParticipantLogInfo.self, json: json)
            }
        }
    }

    /// The PassPolicy union
    public enum PassPolicy: CustomStringConvertible, JSONRepresentable {
        /// An unspecified error.
        case allow
        /// An unspecified error.
        case disabled
        /// An unspecified error.
        case enabled
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try PassPolicySerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PassPolicySerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PassPolicy: \(error)"
            }
        }
    }

    public class PassPolicySerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PassPolicy) throws -> JSON {
            switch value {
            case .allow:
                var d = [String: JSON]()
                d[".tag"] = .str("allow")
                return .dictionary(d)
            case .disabled:
                var d = [String: JSON]()
                d[".tag"] = .str("disabled")
                return .dictionary(d)
            case .enabled:
                var d = [String: JSON]()
                d[".tag"] = .str("enabled")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> PassPolicy {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "allow":
                    return PassPolicy.allow
                case "disabled":
                    return PassPolicy.disabled
                case "enabled":
                    return PassPolicy.enabled
                case "other":
                    return PassPolicy.other
                default:
                    return PassPolicy.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: PassPolicy.self, json: json)
            }
        }
    }

    /// Changed password.
    public class PasswordChangeDetails: CustomStringConvertible, JSONRepresentable {
        func json() throws -> JSON {
            try PasswordChangeDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PasswordChangeDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PasswordChangeDetails: \(error)"
            }
        }
    }

    public class PasswordChangeDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PasswordChangeDetails) throws -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PasswordChangeDetails {
            switch json {
            case .dictionary:
                return PasswordChangeDetails()
            default:
                throw JSONSerializerError.deserializeError(type: PasswordChangeDetails.self, json: json)
            }
        }
    }

    /// The PasswordChangeType struct
    public class PasswordChangeType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try PasswordChangeTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PasswordChangeTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PasswordChangeType: \(error)"
            }
        }
    }

    public class PasswordChangeTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PasswordChangeType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PasswordChangeType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return PasswordChangeType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: PasswordChangeType.self, json: json)
            }
        }
    }

    /// Reset all team member passwords.
    public class PasswordResetAllDetails: CustomStringConvertible, JSONRepresentable {
        func json() throws -> JSON {
            try PasswordResetAllDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PasswordResetAllDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PasswordResetAllDetails: \(error)"
            }
        }
    }

    public class PasswordResetAllDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PasswordResetAllDetails) throws -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PasswordResetAllDetails {
            switch json {
            case .dictionary:
                return PasswordResetAllDetails()
            default:
                throw JSONSerializerError.deserializeError(type: PasswordResetAllDetails.self, json: json)
            }
        }
    }

    /// The PasswordResetAllType struct
    public class PasswordResetAllType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try PasswordResetAllTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PasswordResetAllTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PasswordResetAllType: \(error)"
            }
        }
    }

    public class PasswordResetAllTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PasswordResetAllType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PasswordResetAllType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return PasswordResetAllType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: PasswordResetAllType.self, json: json)
            }
        }
    }

    /// Reset password.
    public class PasswordResetDetails: CustomStringConvertible, JSONRepresentable {
        func json() throws -> JSON {
            try PasswordResetDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PasswordResetDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PasswordResetDetails: \(error)"
            }
        }
    }

    public class PasswordResetDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PasswordResetDetails) throws -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PasswordResetDetails {
            switch json {
            case .dictionary:
                return PasswordResetDetails()
            default:
                throw JSONSerializerError.deserializeError(type: PasswordResetDetails.self, json: json)
            }
        }
    }

    /// The PasswordResetType struct
    public class PasswordResetType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try PasswordResetTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PasswordResetTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PasswordResetType: \(error)"
            }
        }
    }

    public class PasswordResetTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PasswordResetType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PasswordResetType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return PasswordResetType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: PasswordResetType.self, json: json)
            }
        }
    }

    /// Changed team password strength requirements.
    public class PasswordStrengthRequirementsChangePolicyDetails: CustomStringConvertible, JSONRepresentable {
        /// Old password strength policy.
        public let previousValue: TeamPolicies.PasswordStrengthPolicy
        /// New password strength policy.
        public let newValue: TeamPolicies.PasswordStrengthPolicy
        public init(previousValue: TeamPolicies.PasswordStrengthPolicy, newValue: TeamPolicies.PasswordStrengthPolicy) {
            self.previousValue = previousValue
            self.newValue = newValue
        }

        func json() throws -> JSON {
            try PasswordStrengthRequirementsChangePolicyDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PasswordStrengthRequirementsChangePolicyDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PasswordStrengthRequirementsChangePolicyDetails: \(error)"
            }
        }
    }

    public class PasswordStrengthRequirementsChangePolicyDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PasswordStrengthRequirementsChangePolicyDetails) throws -> JSON {
            let output = [
                "previous_value": try TeamPolicies.PasswordStrengthPolicySerializer().serialize(value.previousValue),
                "new_value": try TeamPolicies.PasswordStrengthPolicySerializer().serialize(value.newValue),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PasswordStrengthRequirementsChangePolicyDetails {
            switch json {
            case .dictionary(let dict):
                let previousValue = try TeamPolicies.PasswordStrengthPolicySerializer().deserialize(dict["previous_value"] ?? .null)
                let newValue = try TeamPolicies.PasswordStrengthPolicySerializer().deserialize(dict["new_value"] ?? .null)
                return PasswordStrengthRequirementsChangePolicyDetails(previousValue: previousValue, newValue: newValue)
            default:
                throw JSONSerializerError.deserializeError(type: PasswordStrengthRequirementsChangePolicyDetails.self, json: json)
            }
        }
    }

    /// The PasswordStrengthRequirementsChangePolicyType struct
    public class PasswordStrengthRequirementsChangePolicyType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try PasswordStrengthRequirementsChangePolicyTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PasswordStrengthRequirementsChangePolicyTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PasswordStrengthRequirementsChangePolicyType: \(error)"
            }
        }
    }

    public class PasswordStrengthRequirementsChangePolicyTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PasswordStrengthRequirementsChangePolicyType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PasswordStrengthRequirementsChangePolicyType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return PasswordStrengthRequirementsChangePolicyType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: PasswordStrengthRequirementsChangePolicyType.self, json: json)
            }
        }
    }

    /// Path's details.
    public class PathLogInfo: CustomStringConvertible, JSONRepresentable {
        /// Fully qualified path relative to event's context.
        public let contextual: String?
        /// Path relative to the namespace containing the content.
        public let namespaceRelative: TeamLog.NamespaceRelativePathLogInfo
        public init(namespaceRelative: TeamLog.NamespaceRelativePathLogInfo, contextual: String? = nil) {
            nullableValidator(stringValidator())(contextual)
            self.contextual = contextual
            self.namespaceRelative = namespaceRelative
        }

        func json() throws -> JSON {
            try PathLogInfoSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PathLogInfoSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PathLogInfo: \(error)"
            }
        }
    }

    public class PathLogInfoSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PathLogInfo) throws -> JSON {
            let output = [
                "namespace_relative": try TeamLog.NamespaceRelativePathLogInfoSerializer().serialize(value.namespaceRelative),
                "contextual": try NullableSerializer(Serialization._StringSerializer).serialize(value.contextual),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PathLogInfo {
            switch json {
            case .dictionary(let dict):
                let namespaceRelative = try TeamLog.NamespaceRelativePathLogInfoSerializer().deserialize(dict["namespace_relative"] ?? .null)
                let contextual = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["contextual"] ?? .null)
                return PathLogInfo(namespaceRelative: namespaceRelative, contextual: contextual)
            default:
                throw JSONSerializerError.deserializeError(type: PathLogInfo.self, json: json)
            }
        }
    }

    /// Added pending secondary email.
    public class PendingSecondaryEmailAddedDetails: CustomStringConvertible, JSONRepresentable {
        /// New pending secondary email.
        public let secondaryEmail: String
        public init(secondaryEmail: String) {
            stringValidator(maxLength: 255)(secondaryEmail)
            self.secondaryEmail = secondaryEmail
        }

        func json() throws -> JSON {
            try PendingSecondaryEmailAddedDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PendingSecondaryEmailAddedDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PendingSecondaryEmailAddedDetails: \(error)"
            }
        }
    }

    public class PendingSecondaryEmailAddedDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PendingSecondaryEmailAddedDetails) throws -> JSON {
            let output = [
                "secondary_email": try Serialization._StringSerializer.serialize(value.secondaryEmail),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PendingSecondaryEmailAddedDetails {
            switch json {
            case .dictionary(let dict):
                let secondaryEmail = try Serialization._StringSerializer.deserialize(dict["secondary_email"] ?? .null)
                return PendingSecondaryEmailAddedDetails(secondaryEmail: secondaryEmail)
            default:
                throw JSONSerializerError.deserializeError(type: PendingSecondaryEmailAddedDetails.self, json: json)
            }
        }
    }

    /// The PendingSecondaryEmailAddedType struct
    public class PendingSecondaryEmailAddedType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try PendingSecondaryEmailAddedTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PendingSecondaryEmailAddedTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PendingSecondaryEmailAddedType: \(error)"
            }
        }
    }

    public class PendingSecondaryEmailAddedTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PendingSecondaryEmailAddedType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PendingSecondaryEmailAddedType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return PendingSecondaryEmailAddedType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: PendingSecondaryEmailAddedType.self, json: json)
            }
        }
    }

    /// Enabled/disabled ability of team members to permanently delete content.
    public class PermanentDeleteChangePolicyDetails: CustomStringConvertible, JSONRepresentable {
        /// New permanent delete content policy.
        public let newValue: TeamLog.ContentPermanentDeletePolicy
        /// Previous permanent delete content policy. Might be missing due to historical data gap.
        public let previousValue: TeamLog.ContentPermanentDeletePolicy?
        public init(newValue: TeamLog.ContentPermanentDeletePolicy, previousValue: TeamLog.ContentPermanentDeletePolicy? = nil) {
            self.newValue = newValue
            self.previousValue = previousValue
        }

        func json() throws -> JSON {
            try PermanentDeleteChangePolicyDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PermanentDeleteChangePolicyDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PermanentDeleteChangePolicyDetails: \(error)"
            }
        }
    }

    public class PermanentDeleteChangePolicyDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PermanentDeleteChangePolicyDetails) throws -> JSON {
            let output = [
                "new_value": try TeamLog.ContentPermanentDeletePolicySerializer().serialize(value.newValue),
                "previous_value": try NullableSerializer(TeamLog.ContentPermanentDeletePolicySerializer()).serialize(value.previousValue),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PermanentDeleteChangePolicyDetails {
            switch json {
            case .dictionary(let dict):
                let newValue = try TeamLog.ContentPermanentDeletePolicySerializer().deserialize(dict["new_value"] ?? .null)
                let previousValue = try NullableSerializer(TeamLog.ContentPermanentDeletePolicySerializer()).deserialize(dict["previous_value"] ?? .null)
                return PermanentDeleteChangePolicyDetails(newValue: newValue, previousValue: previousValue)
            default:
                throw JSONSerializerError.deserializeError(type: PermanentDeleteChangePolicyDetails.self, json: json)
            }
        }
    }

    /// The PermanentDeleteChangePolicyType struct
    public class PermanentDeleteChangePolicyType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try PermanentDeleteChangePolicyTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PermanentDeleteChangePolicyTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PermanentDeleteChangePolicyType: \(error)"
            }
        }
    }

    public class PermanentDeleteChangePolicyTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PermanentDeleteChangePolicyType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PermanentDeleteChangePolicyType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return PermanentDeleteChangePolicyType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: PermanentDeleteChangePolicyType.self, json: json)
            }
        }
    }

    /// The PlacementRestriction union
    public enum PlacementRestriction: CustomStringConvertible, JSONRepresentable {
        /// An unspecified error.
        case australiaOnly
        /// An unspecified error.
        case europeOnly
        /// An unspecified error.
        case japanOnly
        /// An unspecified error.
        case none
        /// An unspecified error.
        case ukOnly
        /// An unspecified error.
        case usS3Only
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try PlacementRestrictionSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PlacementRestrictionSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PlacementRestriction: \(error)"
            }
        }
    }

    public class PlacementRestrictionSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PlacementRestriction) throws -> JSON {
            switch value {
            case .australiaOnly:
                var d = [String: JSON]()
                d[".tag"] = .str("australia_only")
                return .dictionary(d)
            case .europeOnly:
                var d = [String: JSON]()
                d[".tag"] = .str("europe_only")
                return .dictionary(d)
            case .japanOnly:
                var d = [String: JSON]()
                d[".tag"] = .str("japan_only")
                return .dictionary(d)
            case .none:
                var d = [String: JSON]()
                d[".tag"] = .str("none")
                return .dictionary(d)
            case .ukOnly:
                var d = [String: JSON]()
                d[".tag"] = .str("uk_only")
                return .dictionary(d)
            case .usS3Only:
                var d = [String: JSON]()
                d[".tag"] = .str("us_s3_only")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> PlacementRestriction {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "australia_only":
                    return PlacementRestriction.australiaOnly
                case "europe_only":
                    return PlacementRestriction.europeOnly
                case "japan_only":
                    return PlacementRestriction.japanOnly
                case "none":
                    return PlacementRestriction.none
                case "uk_only":
                    return PlacementRestriction.ukOnly
                case "us_s3_only":
                    return PlacementRestriction.usS3Only
                case "other":
                    return PlacementRestriction.other
                default:
                    return PlacementRestriction.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: PlacementRestriction.self, json: json)
            }
        }
    }

    /// The PolicyType union
    public enum PolicyType: CustomStringConvertible, JSONRepresentable {
        /// An unspecified error.
        case disposition
        /// An unspecified error.
        case retention
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try PolicyTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PolicyTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PolicyType: \(error)"
            }
        }
    }

    public class PolicyTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PolicyType) throws -> JSON {
            switch value {
            case .disposition:
                var d = [String: JSON]()
                d[".tag"] = .str("disposition")
                return .dictionary(d)
            case .retention:
                var d = [String: JSON]()
                d[".tag"] = .str("retention")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> PolicyType {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "disposition":
                    return PolicyType.disposition
                case "retention":
                    return PolicyType.retention
                case "other":
                    return PolicyType.other
                default:
                    return PolicyType.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: PolicyType.self, json: json)
            }
        }
    }

    /// Team merge request acceptance details shown to the primary team
    public class PrimaryTeamRequestAcceptedDetails: CustomStringConvertible, JSONRepresentable {
        /// The secondary team name.
        public let secondaryTeam: String
        /// The name of the secondary team admin who sent the request originally.
        public let sentBy: String
        public init(secondaryTeam: String, sentBy: String) {
            stringValidator()(secondaryTeam)
            self.secondaryTeam = secondaryTeam
            stringValidator()(sentBy)
            self.sentBy = sentBy
        }

        func json() throws -> JSON {
            try PrimaryTeamRequestAcceptedDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PrimaryTeamRequestAcceptedDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PrimaryTeamRequestAcceptedDetails: \(error)"
            }
        }
    }

    public class PrimaryTeamRequestAcceptedDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PrimaryTeamRequestAcceptedDetails) throws -> JSON {
            let output = [
                "secondary_team": try Serialization._StringSerializer.serialize(value.secondaryTeam),
                "sent_by": try Serialization._StringSerializer.serialize(value.sentBy),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PrimaryTeamRequestAcceptedDetails {
            switch json {
            case .dictionary(let dict):
                let secondaryTeam = try Serialization._StringSerializer.deserialize(dict["secondary_team"] ?? .null)
                let sentBy = try Serialization._StringSerializer.deserialize(dict["sent_by"] ?? .null)
                return PrimaryTeamRequestAcceptedDetails(secondaryTeam: secondaryTeam, sentBy: sentBy)
            default:
                throw JSONSerializerError.deserializeError(type: PrimaryTeamRequestAcceptedDetails.self, json: json)
            }
        }
    }

    /// Team merge request cancellation details shown to the primary team
    public class PrimaryTeamRequestCanceledDetails: CustomStringConvertible, JSONRepresentable {
        /// The secondary team name.
        public let secondaryTeam: String
        /// The name of the secondary team admin who sent the request originally.
        public let sentBy: String
        public init(secondaryTeam: String, sentBy: String) {
            stringValidator()(secondaryTeam)
            self.secondaryTeam = secondaryTeam
            stringValidator()(sentBy)
            self.sentBy = sentBy
        }

        func json() throws -> JSON {
            try PrimaryTeamRequestCanceledDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PrimaryTeamRequestCanceledDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PrimaryTeamRequestCanceledDetails: \(error)"
            }
        }
    }

    public class PrimaryTeamRequestCanceledDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PrimaryTeamRequestCanceledDetails) throws -> JSON {
            let output = [
                "secondary_team": try Serialization._StringSerializer.serialize(value.secondaryTeam),
                "sent_by": try Serialization._StringSerializer.serialize(value.sentBy),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PrimaryTeamRequestCanceledDetails {
            switch json {
            case .dictionary(let dict):
                let secondaryTeam = try Serialization._StringSerializer.deserialize(dict["secondary_team"] ?? .null)
                let sentBy = try Serialization._StringSerializer.deserialize(dict["sent_by"] ?? .null)
                return PrimaryTeamRequestCanceledDetails(secondaryTeam: secondaryTeam, sentBy: sentBy)
            default:
                throw JSONSerializerError.deserializeError(type: PrimaryTeamRequestCanceledDetails.self, json: json)
            }
        }
    }

    /// Team merge request expiration details shown to the primary team
    public class PrimaryTeamRequestExpiredDetails: CustomStringConvertible, JSONRepresentable {
        /// The secondary team name.
        public let secondaryTeam: String
        /// The name of the secondary team admin who sent the request originally.
        public let sentBy: String
        public init(secondaryTeam: String, sentBy: String) {
            stringValidator()(secondaryTeam)
            self.secondaryTeam = secondaryTeam
            stringValidator()(sentBy)
            self.sentBy = sentBy
        }

        func json() throws -> JSON {
            try PrimaryTeamRequestExpiredDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PrimaryTeamRequestExpiredDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PrimaryTeamRequestExpiredDetails: \(error)"
            }
        }
    }

    public class PrimaryTeamRequestExpiredDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PrimaryTeamRequestExpiredDetails) throws -> JSON {
            let output = [
                "secondary_team": try Serialization._StringSerializer.serialize(value.secondaryTeam),
                "sent_by": try Serialization._StringSerializer.serialize(value.sentBy),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PrimaryTeamRequestExpiredDetails {
            switch json {
            case .dictionary(let dict):
                let secondaryTeam = try Serialization._StringSerializer.deserialize(dict["secondary_team"] ?? .null)
                let sentBy = try Serialization._StringSerializer.deserialize(dict["sent_by"] ?? .null)
                return PrimaryTeamRequestExpiredDetails(secondaryTeam: secondaryTeam, sentBy: sentBy)
            default:
                throw JSONSerializerError.deserializeError(type: PrimaryTeamRequestExpiredDetails.self, json: json)
            }
        }
    }

    /// Team merge request reminder details shown to the primary team
    public class PrimaryTeamRequestReminderDetails: CustomStringConvertible, JSONRepresentable {
        /// The secondary team name.
        public let secondaryTeam: String
        /// The name of the primary team admin the request was sent to.
        public let sentTo: String
        public init(secondaryTeam: String, sentTo: String) {
            stringValidator()(secondaryTeam)
            self.secondaryTeam = secondaryTeam
            stringValidator()(sentTo)
            self.sentTo = sentTo
        }

        func json() throws -> JSON {
            try PrimaryTeamRequestReminderDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PrimaryTeamRequestReminderDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PrimaryTeamRequestReminderDetails: \(error)"
            }
        }
    }

    public class PrimaryTeamRequestReminderDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PrimaryTeamRequestReminderDetails) throws -> JSON {
            let output = [
                "secondary_team": try Serialization._StringSerializer.serialize(value.secondaryTeam),
                "sent_to": try Serialization._StringSerializer.serialize(value.sentTo),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PrimaryTeamRequestReminderDetails {
            switch json {
            case .dictionary(let dict):
                let secondaryTeam = try Serialization._StringSerializer.deserialize(dict["secondary_team"] ?? .null)
                let sentTo = try Serialization._StringSerializer.deserialize(dict["sent_to"] ?? .null)
                return PrimaryTeamRequestReminderDetails(secondaryTeam: secondaryTeam, sentTo: sentTo)
            default:
                throw JSONSerializerError.deserializeError(type: PrimaryTeamRequestReminderDetails.self, json: json)
            }
        }
    }

    /// Quick action type.
    public enum QuickActionType: CustomStringConvertible, JSONRepresentable {
        /// An unspecified error.
        case deleteSharedLink
        /// An unspecified error.
        case resetPassword
        /// An unspecified error.
        case restoreFileOrFolder
        /// An unspecified error.
        case unlinkApp
        /// An unspecified error.
        case unlinkDevice
        /// An unspecified error.
        case unlinkSession
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try QuickActionTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try QuickActionTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for QuickActionType: \(error)"
            }
        }
    }

    public class QuickActionTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: QuickActionType) throws -> JSON {
            switch value {
            case .deleteSharedLink:
                var d = [String: JSON]()
                d[".tag"] = .str("delete_shared_link")
                return .dictionary(d)
            case .resetPassword:
                var d = [String: JSON]()
                d[".tag"] = .str("reset_password")
                return .dictionary(d)
            case .restoreFileOrFolder:
                var d = [String: JSON]()
                d[".tag"] = .str("restore_file_or_folder")
                return .dictionary(d)
            case .unlinkApp:
                var d = [String: JSON]()
                d[".tag"] = .str("unlink_app")
                return .dictionary(d)
            case .unlinkDevice:
                var d = [String: JSON]()
                d[".tag"] = .str("unlink_device")
                return .dictionary(d)
            case .unlinkSession:
                var d = [String: JSON]()
                d[".tag"] = .str("unlink_session")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> QuickActionType {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "delete_shared_link":
                    return QuickActionType.deleteSharedLink
                case "reset_password":
                    return QuickActionType.resetPassword
                case "restore_file_or_folder":
                    return QuickActionType.restoreFileOrFolder
                case "unlink_app":
                    return QuickActionType.unlinkApp
                case "unlink_device":
                    return QuickActionType.unlinkDevice
                case "unlink_session":
                    return QuickActionType.unlinkSession
                case "other":
                    return QuickActionType.other
                default:
                    return QuickActionType.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: QuickActionType.self, json: json)
            }
        }
    }

    /// Created ransomware report.
    public class RansomwareAlertCreateReportDetails: CustomStringConvertible, JSONRepresentable {
        func json() throws -> JSON {
            try RansomwareAlertCreateReportDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try RansomwareAlertCreateReportDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for RansomwareAlertCreateReportDetails: \(error)"
            }
        }
    }

    public class RansomwareAlertCreateReportDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: RansomwareAlertCreateReportDetails) throws -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> RansomwareAlertCreateReportDetails {
            switch json {
            case .dictionary:
                return RansomwareAlertCreateReportDetails()
            default:
                throw JSONSerializerError.deserializeError(type: RansomwareAlertCreateReportDetails.self, json: json)
            }
        }
    }

    /// Couldn't generate ransomware report.
    public class RansomwareAlertCreateReportFailedDetails: CustomStringConvertible, JSONRepresentable {
        /// Failure reason.
        public let failureReason: Team.TeamReportFailureReason
        public init(failureReason: Team.TeamReportFailureReason) {
            self.failureReason = failureReason
        }

        func json() throws -> JSON {
            try RansomwareAlertCreateReportFailedDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try RansomwareAlertCreateReportFailedDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for RansomwareAlertCreateReportFailedDetails: \(error)"
            }
        }
    }

    public class RansomwareAlertCreateReportFailedDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: RansomwareAlertCreateReportFailedDetails) throws -> JSON {
            let output = [
                "failure_reason": try Team.TeamReportFailureReasonSerializer().serialize(value.failureReason),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> RansomwareAlertCreateReportFailedDetails {
            switch json {
            case .dictionary(let dict):
                let failureReason = try Team.TeamReportFailureReasonSerializer().deserialize(dict["failure_reason"] ?? .null)
                return RansomwareAlertCreateReportFailedDetails(failureReason: failureReason)
            default:
                throw JSONSerializerError.deserializeError(type: RansomwareAlertCreateReportFailedDetails.self, json: json)
            }
        }
    }

    /// The RansomwareAlertCreateReportFailedType struct
    public class RansomwareAlertCreateReportFailedType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try RansomwareAlertCreateReportFailedTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try RansomwareAlertCreateReportFailedTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for RansomwareAlertCreateReportFailedType: \(error)"
            }
        }
    }

    public class RansomwareAlertCreateReportFailedTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: RansomwareAlertCreateReportFailedType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> RansomwareAlertCreateReportFailedType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return RansomwareAlertCreateReportFailedType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: RansomwareAlertCreateReportFailedType.self, json: json)
            }
        }
    }

    /// The RansomwareAlertCreateReportType struct
    public class RansomwareAlertCreateReportType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try RansomwareAlertCreateReportTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try RansomwareAlertCreateReportTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for RansomwareAlertCreateReportType: \(error)"
            }
        }
    }

    public class RansomwareAlertCreateReportTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: RansomwareAlertCreateReportType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> RansomwareAlertCreateReportType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return RansomwareAlertCreateReportType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: RansomwareAlertCreateReportType.self, json: json)
            }
        }
    }

    /// Completed ransomware restore process.
    public class RansomwareRestoreProcessCompletedDetails: CustomStringConvertible, JSONRepresentable {
        /// The status of the restore process.
        public let status: String
        /// Restored files count.
        public let restoredFilesCount: Int64
        /// Restored files failed count.
        public let restoredFilesFailedCount: Int64
        public init(status: String, restoredFilesCount: Int64, restoredFilesFailedCount: Int64) {
            stringValidator()(status)
            self.status = status
            comparableValidator()(restoredFilesCount)
            self.restoredFilesCount = restoredFilesCount
            comparableValidator()(restoredFilesFailedCount)
            self.restoredFilesFailedCount = restoredFilesFailedCount
        }

        func json() throws -> JSON {
            try RansomwareRestoreProcessCompletedDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try RansomwareRestoreProcessCompletedDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for RansomwareRestoreProcessCompletedDetails: \(error)"
            }
        }
    }

    public class RansomwareRestoreProcessCompletedDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: RansomwareRestoreProcessCompletedDetails) throws -> JSON {
            let output = [
                "status": try Serialization._StringSerializer.serialize(value.status),
                "restored_files_count": try Serialization._Int64Serializer.serialize(value.restoredFilesCount),
                "restored_files_failed_count": try Serialization._Int64Serializer.serialize(value.restoredFilesFailedCount),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> RansomwareRestoreProcessCompletedDetails {
            switch json {
            case .dictionary(let dict):
                let status = try Serialization._StringSerializer.deserialize(dict["status"] ?? .null)
                let restoredFilesCount = try Serialization._Int64Serializer.deserialize(dict["restored_files_count"] ?? .null)
                let restoredFilesFailedCount = try Serialization._Int64Serializer.deserialize(dict["restored_files_failed_count"] ?? .null)
                return RansomwareRestoreProcessCompletedDetails(
                    status: status,
                    restoredFilesCount: restoredFilesCount,
                    restoredFilesFailedCount: restoredFilesFailedCount
                )
            default:
                throw JSONSerializerError.deserializeError(type: RansomwareRestoreProcessCompletedDetails.self, json: json)
            }
        }
    }

    /// The RansomwareRestoreProcessCompletedType struct
    public class RansomwareRestoreProcessCompletedType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try RansomwareRestoreProcessCompletedTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try RansomwareRestoreProcessCompletedTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for RansomwareRestoreProcessCompletedType: \(error)"
            }
        }
    }

    public class RansomwareRestoreProcessCompletedTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: RansomwareRestoreProcessCompletedType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> RansomwareRestoreProcessCompletedType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return RansomwareRestoreProcessCompletedType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: RansomwareRestoreProcessCompletedType.self, json: json)
            }
        }
    }

    /// Started ransomware restore process.
    public class RansomwareRestoreProcessStartedDetails: CustomStringConvertible, JSONRepresentable {
        /// Ransomware filename extension.
        public let extension_: String
        public init(extension_: String) {
            stringValidator()(extension_)
            self.extension_ = extension_
        }

        func json() throws -> JSON {
            try RansomwareRestoreProcessStartedDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try RansomwareRestoreProcessStartedDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for RansomwareRestoreProcessStartedDetails: \(error)"
            }
        }
    }

    public class RansomwareRestoreProcessStartedDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: RansomwareRestoreProcessStartedDetails) throws -> JSON {
            let output = [
                "extension": try Serialization._StringSerializer.serialize(value.extension_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> RansomwareRestoreProcessStartedDetails {
            switch json {
            case .dictionary(let dict):
                let extension_ = try Serialization._StringSerializer.deserialize(dict["extension"] ?? .null)
                return RansomwareRestoreProcessStartedDetails(extension_: extension_)
            default:
                throw JSONSerializerError.deserializeError(type: RansomwareRestoreProcessStartedDetails.self, json: json)
            }
        }
    }

    /// The RansomwareRestoreProcessStartedType struct
    public class RansomwareRestoreProcessStartedType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try RansomwareRestoreProcessStartedTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try RansomwareRestoreProcessStartedTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for RansomwareRestoreProcessStartedType: \(error)"
            }
        }
    }

    public class RansomwareRestoreProcessStartedTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: RansomwareRestoreProcessStartedType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> RansomwareRestoreProcessStartedType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return RansomwareRestoreProcessStartedType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: RansomwareRestoreProcessStartedType.self, json: json)
            }
        }
    }

    /// Recipients Configuration
    public class RecipientsConfiguration: CustomStringConvertible, JSONRepresentable {
        /// Recipients setting type.
        public let recipientSettingType: TeamLog.AlertRecipientsSettingType?
        /// A list of user emails to notify.
        public let emails: [String]?
        /// A list of groups to notify.
        public let groups: [String]?
        public init(recipientSettingType: TeamLog.AlertRecipientsSettingType? = nil, emails: [String]? = nil, groups: [String]? = nil) {
            self.recipientSettingType = recipientSettingType
            nullableValidator(arrayValidator(itemValidator: stringValidator(maxLength: 255)))(emails)
            self.emails = emails
            nullableValidator(arrayValidator(itemValidator: stringValidator()))(groups)
            self.groups = groups
        }

        func json() throws -> JSON {
            try RecipientsConfigurationSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try RecipientsConfigurationSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for RecipientsConfiguration: \(error)"
            }
        }
    }

    public class RecipientsConfigurationSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: RecipientsConfiguration) throws -> JSON {
            let output = [
                "recipient_setting_type": try NullableSerializer(TeamLog.AlertRecipientsSettingTypeSerializer()).serialize(value.recipientSettingType),
                "emails": try NullableSerializer(ArraySerializer(Serialization._StringSerializer)).serialize(value.emails),
                "groups": try NullableSerializer(ArraySerializer(Serialization._StringSerializer)).serialize(value.groups),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> RecipientsConfiguration {
            switch json {
            case .dictionary(let dict):
                let recipientSettingType = try NullableSerializer(TeamLog.AlertRecipientsSettingTypeSerializer())
                    .deserialize(dict["recipient_setting_type"] ?? .null)
                let emails = try NullableSerializer(ArraySerializer(Serialization._StringSerializer)).deserialize(dict["emails"] ?? .null)
                let groups = try NullableSerializer(ArraySerializer(Serialization._StringSerializer)).deserialize(dict["groups"] ?? .null)
                return RecipientsConfiguration(recipientSettingType: recipientSettingType, emails: emails, groups: groups)
            default:
                throw JSONSerializerError.deserializeError(type: RecipientsConfiguration.self, json: json)
            }
        }
    }

    /// Provides the indices of the source asset and the destination asset for a relocate action.
    public class RelocateAssetReferencesLogInfo: CustomStringConvertible, JSONRepresentable {
        /// Source asset position in the Assets list.
        public let srcAssetIndex: UInt64
        /// Destination asset position in the Assets list.
        public let destAssetIndex: UInt64
        public init(srcAssetIndex: UInt64, destAssetIndex: UInt64) {
            comparableValidator()(srcAssetIndex)
            self.srcAssetIndex = srcAssetIndex
            comparableValidator()(destAssetIndex)
            self.destAssetIndex = destAssetIndex
        }

        func json() throws -> JSON {
            try RelocateAssetReferencesLogInfoSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try RelocateAssetReferencesLogInfoSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for RelocateAssetReferencesLogInfo: \(error)"
            }
        }
    }

    public class RelocateAssetReferencesLogInfoSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: RelocateAssetReferencesLogInfo) throws -> JSON {
            let output = [
                "src_asset_index": try Serialization._UInt64Serializer.serialize(value.srcAssetIndex),
                "dest_asset_index": try Serialization._UInt64Serializer.serialize(value.destAssetIndex),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> RelocateAssetReferencesLogInfo {
            switch json {
            case .dictionary(let dict):
                let srcAssetIndex = try Serialization._UInt64Serializer.deserialize(dict["src_asset_index"] ?? .null)
                let destAssetIndex = try Serialization._UInt64Serializer.deserialize(dict["dest_asset_index"] ?? .null)
                return RelocateAssetReferencesLogInfo(srcAssetIndex: srcAssetIndex, destAssetIndex: destAssetIndex)
            default:
                throw JSONSerializerError.deserializeError(type: RelocateAssetReferencesLogInfo.self, json: json)
            }
        }
    }

    /// Deleted files in Replay.
    public class ReplayFileDeleteDetails: CustomStringConvertible, JSONRepresentable {
        func json() throws -> JSON {
            try ReplayFileDeleteDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ReplayFileDeleteDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ReplayFileDeleteDetails: \(error)"
            }
        }
    }

    public class ReplayFileDeleteDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ReplayFileDeleteDetails) throws -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ReplayFileDeleteDetails {
            switch json {
            case .dictionary:
                return ReplayFileDeleteDetails()
            default:
                throw JSONSerializerError.deserializeError(type: ReplayFileDeleteDetails.self, json: json)
            }
        }
    }

    /// The ReplayFileDeleteType struct
    public class ReplayFileDeleteType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try ReplayFileDeleteTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ReplayFileDeleteTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ReplayFileDeleteType: \(error)"
            }
        }
    }

    public class ReplayFileDeleteTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ReplayFileDeleteType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ReplayFileDeleteType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return ReplayFileDeleteType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: ReplayFileDeleteType.self, json: json)
            }
        }
    }

    /// Created shared link in Replay.
    public class ReplayFileSharedLinkCreatedDetails: CustomStringConvertible, JSONRepresentable {
        func json() throws -> JSON {
            try ReplayFileSharedLinkCreatedDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ReplayFileSharedLinkCreatedDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ReplayFileSharedLinkCreatedDetails: \(error)"
            }
        }
    }

    public class ReplayFileSharedLinkCreatedDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ReplayFileSharedLinkCreatedDetails) throws -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ReplayFileSharedLinkCreatedDetails {
            switch json {
            case .dictionary:
                return ReplayFileSharedLinkCreatedDetails()
            default:
                throw JSONSerializerError.deserializeError(type: ReplayFileSharedLinkCreatedDetails.self, json: json)
            }
        }
    }

    /// The ReplayFileSharedLinkCreatedType struct
    public class ReplayFileSharedLinkCreatedType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try ReplayFileSharedLinkCreatedTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ReplayFileSharedLinkCreatedTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ReplayFileSharedLinkCreatedType: \(error)"
            }
        }
    }

    public class ReplayFileSharedLinkCreatedTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ReplayFileSharedLinkCreatedType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ReplayFileSharedLinkCreatedType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return ReplayFileSharedLinkCreatedType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: ReplayFileSharedLinkCreatedType.self, json: json)
            }
        }
    }

    /// Modified shared link in Replay.
    public class ReplayFileSharedLinkModifiedDetails: CustomStringConvertible, JSONRepresentable {
        func json() throws -> JSON {
            try ReplayFileSharedLinkModifiedDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ReplayFileSharedLinkModifiedDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ReplayFileSharedLinkModifiedDetails: \(error)"
            }
        }
    }

    public class ReplayFileSharedLinkModifiedDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ReplayFileSharedLinkModifiedDetails) throws -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ReplayFileSharedLinkModifiedDetails {
            switch json {
            case .dictionary:
                return ReplayFileSharedLinkModifiedDetails()
            default:
                throw JSONSerializerError.deserializeError(type: ReplayFileSharedLinkModifiedDetails.self, json: json)
            }
        }
    }

    /// The ReplayFileSharedLinkModifiedType struct
    public class ReplayFileSharedLinkModifiedType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try ReplayFileSharedLinkModifiedTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ReplayFileSharedLinkModifiedTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ReplayFileSharedLinkModifiedType: \(error)"
            }
        }
    }

    public class ReplayFileSharedLinkModifiedTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ReplayFileSharedLinkModifiedType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ReplayFileSharedLinkModifiedType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return ReplayFileSharedLinkModifiedType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: ReplayFileSharedLinkModifiedType.self, json: json)
            }
        }
    }

    /// Added member to Replay Project.
    public class ReplayProjectTeamAddDetails: CustomStringConvertible, JSONRepresentable {
        func json() throws -> JSON {
            try ReplayProjectTeamAddDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ReplayProjectTeamAddDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ReplayProjectTeamAddDetails: \(error)"
            }
        }
    }

    public class ReplayProjectTeamAddDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ReplayProjectTeamAddDetails) throws -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ReplayProjectTeamAddDetails {
            switch json {
            case .dictionary:
                return ReplayProjectTeamAddDetails()
            default:
                throw JSONSerializerError.deserializeError(type: ReplayProjectTeamAddDetails.self, json: json)
            }
        }
    }

    /// The ReplayProjectTeamAddType struct
    public class ReplayProjectTeamAddType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try ReplayProjectTeamAddTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ReplayProjectTeamAddTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ReplayProjectTeamAddType: \(error)"
            }
        }
    }

    public class ReplayProjectTeamAddTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ReplayProjectTeamAddType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ReplayProjectTeamAddType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return ReplayProjectTeamAddType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: ReplayProjectTeamAddType.self, json: json)
            }
        }
    }

    /// Removed member from Replay Project.
    public class ReplayProjectTeamDeleteDetails: CustomStringConvertible, JSONRepresentable {
        func json() throws -> JSON {
            try ReplayProjectTeamDeleteDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ReplayProjectTeamDeleteDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ReplayProjectTeamDeleteDetails: \(error)"
            }
        }
    }

    public class ReplayProjectTeamDeleteDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ReplayProjectTeamDeleteDetails) throws -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ReplayProjectTeamDeleteDetails {
            switch json {
            case .dictionary:
                return ReplayProjectTeamDeleteDetails()
            default:
                throw JSONSerializerError.deserializeError(type: ReplayProjectTeamDeleteDetails.self, json: json)
            }
        }
    }

    /// The ReplayProjectTeamDeleteType struct
    public class ReplayProjectTeamDeleteType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try ReplayProjectTeamDeleteTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ReplayProjectTeamDeleteTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ReplayProjectTeamDeleteType: \(error)"
            }
        }
    }

    public class ReplayProjectTeamDeleteTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ReplayProjectTeamDeleteType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ReplayProjectTeamDeleteType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return ReplayProjectTeamDeleteType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: ReplayProjectTeamDeleteType.self, json: json)
            }
        }
    }

    /// Reseller information.
    public class ResellerLogInfo: CustomStringConvertible, JSONRepresentable {
        /// Reseller name.
        public let resellerName: String
        /// Reseller email.
        public let resellerEmail: String
        public init(resellerName: String, resellerEmail: String) {
            stringValidator()(resellerName)
            self.resellerName = resellerName
            stringValidator(maxLength: 255)(resellerEmail)
            self.resellerEmail = resellerEmail
        }

        func json() throws -> JSON {
            try ResellerLogInfoSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ResellerLogInfoSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ResellerLogInfo: \(error)"
            }
        }
    }

    public class ResellerLogInfoSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ResellerLogInfo) throws -> JSON {
            let output = [
                "reseller_name": try Serialization._StringSerializer.serialize(value.resellerName),
                "reseller_email": try Serialization._StringSerializer.serialize(value.resellerEmail),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ResellerLogInfo {
            switch json {
            case .dictionary(let dict):
                let resellerName = try Serialization._StringSerializer.deserialize(dict["reseller_name"] ?? .null)
                let resellerEmail = try Serialization._StringSerializer.deserialize(dict["reseller_email"] ?? .null)
                return ResellerLogInfo(resellerName: resellerName, resellerEmail: resellerEmail)
            default:
                throw JSONSerializerError.deserializeError(type: ResellerLogInfo.self, json: json)
            }
        }
    }

    /// The ResellerRole union
    public enum ResellerRole: CustomStringConvertible, JSONRepresentable {
        /// An unspecified error.
        case notReseller
        /// An unspecified error.
        case resellerAdmin
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try ResellerRoleSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ResellerRoleSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ResellerRole: \(error)"
            }
        }
    }

    public class ResellerRoleSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ResellerRole) throws -> JSON {
            switch value {
            case .notReseller:
                var d = [String: JSON]()
                d[".tag"] = .str("not_reseller")
                return .dictionary(d)
            case .resellerAdmin:
                var d = [String: JSON]()
                d[".tag"] = .str("reseller_admin")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> ResellerRole {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "not_reseller":
                    return ResellerRole.notReseller
                case "reseller_admin":
                    return ResellerRole.resellerAdmin
                case "other":
                    return ResellerRole.other
                default:
                    return ResellerRole.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: ResellerRole.self, json: json)
            }
        }
    }

    /// Enabled/disabled reseller support.
    public class ResellerSupportChangePolicyDetails: CustomStringConvertible, JSONRepresentable {
        /// New Reseller support policy.
        public let newValue: TeamLog.ResellerSupportPolicy
        /// Previous Reseller support policy.
        public let previousValue: TeamLog.ResellerSupportPolicy
        public init(newValue: TeamLog.ResellerSupportPolicy, previousValue: TeamLog.ResellerSupportPolicy) {
            self.newValue = newValue
            self.previousValue = previousValue
        }

        func json() throws -> JSON {
            try ResellerSupportChangePolicyDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ResellerSupportChangePolicyDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ResellerSupportChangePolicyDetails: \(error)"
            }
        }
    }

    public class ResellerSupportChangePolicyDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ResellerSupportChangePolicyDetails) throws -> JSON {
            let output = [
                "new_value": try TeamLog.ResellerSupportPolicySerializer().serialize(value.newValue),
                "previous_value": try TeamLog.ResellerSupportPolicySerializer().serialize(value.previousValue),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ResellerSupportChangePolicyDetails {
            switch json {
            case .dictionary(let dict):
                let newValue = try TeamLog.ResellerSupportPolicySerializer().deserialize(dict["new_value"] ?? .null)
                let previousValue = try TeamLog.ResellerSupportPolicySerializer().deserialize(dict["previous_value"] ?? .null)
                return ResellerSupportChangePolicyDetails(newValue: newValue, previousValue: previousValue)
            default:
                throw JSONSerializerError.deserializeError(type: ResellerSupportChangePolicyDetails.self, json: json)
            }
        }
    }

    /// The ResellerSupportChangePolicyType struct
    public class ResellerSupportChangePolicyType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try ResellerSupportChangePolicyTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ResellerSupportChangePolicyTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ResellerSupportChangePolicyType: \(error)"
            }
        }
    }

    public class ResellerSupportChangePolicyTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ResellerSupportChangePolicyType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ResellerSupportChangePolicyType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return ResellerSupportChangePolicyType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: ResellerSupportChangePolicyType.self, json: json)
            }
        }
    }

    /// Policy for controlling if reseller can access the admin console as administrator
    public enum ResellerSupportPolicy: CustomStringConvertible, JSONRepresentable {
        /// An unspecified error.
        case disabled
        /// An unspecified error.
        case enabled
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try ResellerSupportPolicySerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ResellerSupportPolicySerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ResellerSupportPolicy: \(error)"
            }
        }
    }

    public class ResellerSupportPolicySerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ResellerSupportPolicy) throws -> JSON {
            switch value {
            case .disabled:
                var d = [String: JSON]()
                d[".tag"] = .str("disabled")
                return .dictionary(d)
            case .enabled:
                var d = [String: JSON]()
                d[".tag"] = .str("enabled")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> ResellerSupportPolicy {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "disabled":
                    return ResellerSupportPolicy.disabled
                case "enabled":
                    return ResellerSupportPolicy.enabled
                case "other":
                    return ResellerSupportPolicy.other
                default:
                    return ResellerSupportPolicy.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: ResellerSupportPolicy.self, json: json)
            }
        }
    }

    /// Ended reseller support session.
    public class ResellerSupportSessionEndDetails: CustomStringConvertible, JSONRepresentable {
        func json() throws -> JSON {
            try ResellerSupportSessionEndDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ResellerSupportSessionEndDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ResellerSupportSessionEndDetails: \(error)"
            }
        }
    }

    public class ResellerSupportSessionEndDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ResellerSupportSessionEndDetails) throws -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ResellerSupportSessionEndDetails {
            switch json {
            case .dictionary:
                return ResellerSupportSessionEndDetails()
            default:
                throw JSONSerializerError.deserializeError(type: ResellerSupportSessionEndDetails.self, json: json)
            }
        }
    }

    /// The ResellerSupportSessionEndType struct
    public class ResellerSupportSessionEndType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try ResellerSupportSessionEndTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ResellerSupportSessionEndTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ResellerSupportSessionEndType: \(error)"
            }
        }
    }

    public class ResellerSupportSessionEndTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ResellerSupportSessionEndType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ResellerSupportSessionEndType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return ResellerSupportSessionEndType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: ResellerSupportSessionEndType.self, json: json)
            }
        }
    }

    /// Started reseller support session.
    public class ResellerSupportSessionStartDetails: CustomStringConvertible, JSONRepresentable {
        func json() throws -> JSON {
            try ResellerSupportSessionStartDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ResellerSupportSessionStartDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ResellerSupportSessionStartDetails: \(error)"
            }
        }
    }

    public class ResellerSupportSessionStartDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ResellerSupportSessionStartDetails) throws -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ResellerSupportSessionStartDetails {
            switch json {
            case .dictionary:
                return ResellerSupportSessionStartDetails()
            default:
                throw JSONSerializerError.deserializeError(type: ResellerSupportSessionStartDetails.self, json: json)
            }
        }
    }

    /// The ResellerSupportSessionStartType struct
    public class ResellerSupportSessionStartType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try ResellerSupportSessionStartTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ResellerSupportSessionStartTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ResellerSupportSessionStartType: \(error)"
            }
        }
    }

    public class ResellerSupportSessionStartTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ResellerSupportSessionStartType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ResellerSupportSessionStartType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return ResellerSupportSessionStartType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: ResellerSupportSessionStartType.self, json: json)
            }
        }
    }

    /// Rewound a folder.
    public class RewindFolderDetails: CustomStringConvertible, JSONRepresentable {
        /// Folder was Rewound to this date.
        public let rewindFolderTargetTsMs: Date
        public init(rewindFolderTargetTsMs: Date) {
            self.rewindFolderTargetTsMs = rewindFolderTargetTsMs
        }

        func json() throws -> JSON {
            try RewindFolderDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try RewindFolderDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for RewindFolderDetails: \(error)"
            }
        }
    }

    public class RewindFolderDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: RewindFolderDetails) throws -> JSON {
            let output = [
                "rewind_folder_target_ts_ms": try NSDateSerializer("%Y-%m-%dT%H:%M:%SZ").serialize(value.rewindFolderTargetTsMs),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> RewindFolderDetails {
            switch json {
            case .dictionary(let dict):
                let rewindFolderTargetTsMs = try NSDateSerializer("%Y-%m-%dT%H:%M:%SZ").deserialize(dict["rewind_folder_target_ts_ms"] ?? .null)
                return RewindFolderDetails(rewindFolderTargetTsMs: rewindFolderTargetTsMs)
            default:
                throw JSONSerializerError.deserializeError(type: RewindFolderDetails.self, json: json)
            }
        }
    }

    /// The RewindFolderType struct
    public class RewindFolderType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try RewindFolderTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try RewindFolderTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for RewindFolderType: \(error)"
            }
        }
    }

    public class RewindFolderTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: RewindFolderType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> RewindFolderType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return RewindFolderType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: RewindFolderType.self, json: json)
            }
        }
    }

    /// Policy for controlling whether team members can rewind
    public enum RewindPolicy: CustomStringConvertible, JSONRepresentable {
        /// An unspecified error.
        case adminsOnly
        /// An unspecified error.
        case everyone
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try RewindPolicySerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try RewindPolicySerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for RewindPolicy: \(error)"
            }
        }
    }

    public class RewindPolicySerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: RewindPolicy) throws -> JSON {
            switch value {
            case .adminsOnly:
                var d = [String: JSON]()
                d[".tag"] = .str("admins_only")
                return .dictionary(d)
            case .everyone:
                var d = [String: JSON]()
                d[".tag"] = .str("everyone")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> RewindPolicy {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "admins_only":
                    return RewindPolicy.adminsOnly
                case "everyone":
                    return RewindPolicy.everyone
                case "other":
                    return RewindPolicy.other
                default:
                    return RewindPolicy.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: RewindPolicy.self, json: json)
            }
        }
    }

    /// Changed Rewind policy for team.
    public class RewindPolicyChangedDetails: CustomStringConvertible, JSONRepresentable {
        /// New Dropbox Rewind policy.
        public let newValue: TeamLog.RewindPolicy
        /// Previous Dropbox Rewind policy.
        public let previousValue: TeamLog.RewindPolicy
        public init(newValue: TeamLog.RewindPolicy, previousValue: TeamLog.RewindPolicy) {
            self.newValue = newValue
            self.previousValue = previousValue
        }

        func json() throws -> JSON {
            try RewindPolicyChangedDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try RewindPolicyChangedDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for RewindPolicyChangedDetails: \(error)"
            }
        }
    }

    public class RewindPolicyChangedDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: RewindPolicyChangedDetails) throws -> JSON {
            let output = [
                "new_value": try TeamLog.RewindPolicySerializer().serialize(value.newValue),
                "previous_value": try TeamLog.RewindPolicySerializer().serialize(value.previousValue),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> RewindPolicyChangedDetails {
            switch json {
            case .dictionary(let dict):
                let newValue = try TeamLog.RewindPolicySerializer().deserialize(dict["new_value"] ?? .null)
                let previousValue = try TeamLog.RewindPolicySerializer().deserialize(dict["previous_value"] ?? .null)
                return RewindPolicyChangedDetails(newValue: newValue, previousValue: previousValue)
            default:
                throw JSONSerializerError.deserializeError(type: RewindPolicyChangedDetails.self, json: json)
            }
        }
    }

    /// The RewindPolicyChangedType struct
    public class RewindPolicyChangedType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try RewindPolicyChangedTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try RewindPolicyChangedTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for RewindPolicyChangedType: \(error)"
            }
        }
    }

    public class RewindPolicyChangedTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: RewindPolicyChangedType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> RewindPolicyChangedType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return RewindPolicyChangedType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: RewindPolicyChangedType.self, json: json)
            }
        }
    }

    /// Deleted secondary email.
    public class SecondaryEmailDeletedDetails: CustomStringConvertible, JSONRepresentable {
        /// Deleted secondary email.
        public let secondaryEmail: String
        public init(secondaryEmail: String) {
            stringValidator(maxLength: 255)(secondaryEmail)
            self.secondaryEmail = secondaryEmail
        }

        func json() throws -> JSON {
            try SecondaryEmailDeletedDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SecondaryEmailDeletedDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SecondaryEmailDeletedDetails: \(error)"
            }
        }
    }

    public class SecondaryEmailDeletedDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SecondaryEmailDeletedDetails) throws -> JSON {
            let output = [
                "secondary_email": try Serialization._StringSerializer.serialize(value.secondaryEmail),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SecondaryEmailDeletedDetails {
            switch json {
            case .dictionary(let dict):
                let secondaryEmail = try Serialization._StringSerializer.deserialize(dict["secondary_email"] ?? .null)
                return SecondaryEmailDeletedDetails(secondaryEmail: secondaryEmail)
            default:
                throw JSONSerializerError.deserializeError(type: SecondaryEmailDeletedDetails.self, json: json)
            }
        }
    }

    /// The SecondaryEmailDeletedType struct
    public class SecondaryEmailDeletedType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try SecondaryEmailDeletedTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SecondaryEmailDeletedTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SecondaryEmailDeletedType: \(error)"
            }
        }
    }

    public class SecondaryEmailDeletedTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SecondaryEmailDeletedType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SecondaryEmailDeletedType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return SecondaryEmailDeletedType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: SecondaryEmailDeletedType.self, json: json)
            }
        }
    }

    /// Verified secondary email.
    public class SecondaryEmailVerifiedDetails: CustomStringConvertible, JSONRepresentable {
        /// Verified secondary email.
        public let secondaryEmail: String
        public init(secondaryEmail: String) {
            stringValidator(maxLength: 255)(secondaryEmail)
            self.secondaryEmail = secondaryEmail
        }

        func json() throws -> JSON {
            try SecondaryEmailVerifiedDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SecondaryEmailVerifiedDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SecondaryEmailVerifiedDetails: \(error)"
            }
        }
    }

    public class SecondaryEmailVerifiedDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SecondaryEmailVerifiedDetails) throws -> JSON {
            let output = [
                "secondary_email": try Serialization._StringSerializer.serialize(value.secondaryEmail),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SecondaryEmailVerifiedDetails {
            switch json {
            case .dictionary(let dict):
                let secondaryEmail = try Serialization._StringSerializer.deserialize(dict["secondary_email"] ?? .null)
                return SecondaryEmailVerifiedDetails(secondaryEmail: secondaryEmail)
            default:
                throw JSONSerializerError.deserializeError(type: SecondaryEmailVerifiedDetails.self, json: json)
            }
        }
    }

    /// The SecondaryEmailVerifiedType struct
    public class SecondaryEmailVerifiedType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try SecondaryEmailVerifiedTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SecondaryEmailVerifiedTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SecondaryEmailVerifiedType: \(error)"
            }
        }
    }

    public class SecondaryEmailVerifiedTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SecondaryEmailVerifiedType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SecondaryEmailVerifiedType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return SecondaryEmailVerifiedType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: SecondaryEmailVerifiedType.self, json: json)
            }
        }
    }

    /// The SecondaryMailsPolicy union
    public enum SecondaryMailsPolicy: CustomStringConvertible, JSONRepresentable {
        /// An unspecified error.
        case disabled
        /// An unspecified error.
        case enabled
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try SecondaryMailsPolicySerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SecondaryMailsPolicySerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SecondaryMailsPolicy: \(error)"
            }
        }
    }

    public class SecondaryMailsPolicySerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SecondaryMailsPolicy) throws -> JSON {
            switch value {
            case .disabled:
                var d = [String: JSON]()
                d[".tag"] = .str("disabled")
                return .dictionary(d)
            case .enabled:
                var d = [String: JSON]()
                d[".tag"] = .str("enabled")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> SecondaryMailsPolicy {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "disabled":
                    return SecondaryMailsPolicy.disabled
                case "enabled":
                    return SecondaryMailsPolicy.enabled
                case "other":
                    return SecondaryMailsPolicy.other
                default:
                    return SecondaryMailsPolicy.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: SecondaryMailsPolicy.self, json: json)
            }
        }
    }

    /// Secondary mails policy changed.
    public class SecondaryMailsPolicyChangedDetails: CustomStringConvertible, JSONRepresentable {
        /// Previous secondary mails policy.
        public let previousValue: TeamLog.SecondaryMailsPolicy
        /// New secondary mails policy.
        public let newValue: TeamLog.SecondaryMailsPolicy
        public init(previousValue: TeamLog.SecondaryMailsPolicy, newValue: TeamLog.SecondaryMailsPolicy) {
            self.previousValue = previousValue
            self.newValue = newValue
        }

        func json() throws -> JSON {
            try SecondaryMailsPolicyChangedDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SecondaryMailsPolicyChangedDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SecondaryMailsPolicyChangedDetails: \(error)"
            }
        }
    }

    public class SecondaryMailsPolicyChangedDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SecondaryMailsPolicyChangedDetails) throws -> JSON {
            let output = [
                "previous_value": try TeamLog.SecondaryMailsPolicySerializer().serialize(value.previousValue),
                "new_value": try TeamLog.SecondaryMailsPolicySerializer().serialize(value.newValue),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SecondaryMailsPolicyChangedDetails {
            switch json {
            case .dictionary(let dict):
                let previousValue = try TeamLog.SecondaryMailsPolicySerializer().deserialize(dict["previous_value"] ?? .null)
                let newValue = try TeamLog.SecondaryMailsPolicySerializer().deserialize(dict["new_value"] ?? .null)
                return SecondaryMailsPolicyChangedDetails(previousValue: previousValue, newValue: newValue)
            default:
                throw JSONSerializerError.deserializeError(type: SecondaryMailsPolicyChangedDetails.self, json: json)
            }
        }
    }

    /// The SecondaryMailsPolicyChangedType struct
    public class SecondaryMailsPolicyChangedType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try SecondaryMailsPolicyChangedTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SecondaryMailsPolicyChangedTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SecondaryMailsPolicyChangedType: \(error)"
            }
        }
    }

    public class SecondaryMailsPolicyChangedTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SecondaryMailsPolicyChangedType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SecondaryMailsPolicyChangedType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return SecondaryMailsPolicyChangedType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: SecondaryMailsPolicyChangedType.self, json: json)
            }
        }
    }

    /// Team merge request acceptance details shown to the secondary team
    public class SecondaryTeamRequestAcceptedDetails: CustomStringConvertible, JSONRepresentable {
        /// The primary team name.
        public let primaryTeam: String
        /// The name of the secondary team admin who sent the request originally.
        public let sentBy: String
        public init(primaryTeam: String, sentBy: String) {
            stringValidator()(primaryTeam)
            self.primaryTeam = primaryTeam
            stringValidator()(sentBy)
            self.sentBy = sentBy
        }

        func json() throws -> JSON {
            try SecondaryTeamRequestAcceptedDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SecondaryTeamRequestAcceptedDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SecondaryTeamRequestAcceptedDetails: \(error)"
            }
        }
    }

    public class SecondaryTeamRequestAcceptedDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SecondaryTeamRequestAcceptedDetails) throws -> JSON {
            let output = [
                "primary_team": try Serialization._StringSerializer.serialize(value.primaryTeam),
                "sent_by": try Serialization._StringSerializer.serialize(value.sentBy),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SecondaryTeamRequestAcceptedDetails {
            switch json {
            case .dictionary(let dict):
                let primaryTeam = try Serialization._StringSerializer.deserialize(dict["primary_team"] ?? .null)
                let sentBy = try Serialization._StringSerializer.deserialize(dict["sent_by"] ?? .null)
                return SecondaryTeamRequestAcceptedDetails(primaryTeam: primaryTeam, sentBy: sentBy)
            default:
                throw JSONSerializerError.deserializeError(type: SecondaryTeamRequestAcceptedDetails.self, json: json)
            }
        }
    }

    /// Team merge request cancellation details shown to the secondary team
    public class SecondaryTeamRequestCanceledDetails: CustomStringConvertible, JSONRepresentable {
        /// The email of the primary team admin that the request was sent to.
        public let sentTo: String
        /// The name of the secondary team admin who sent the request originally.
        public let sentBy: String
        public init(sentTo: String, sentBy: String) {
            stringValidator()(sentTo)
            self.sentTo = sentTo
            stringValidator()(sentBy)
            self.sentBy = sentBy
        }

        func json() throws -> JSON {
            try SecondaryTeamRequestCanceledDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SecondaryTeamRequestCanceledDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SecondaryTeamRequestCanceledDetails: \(error)"
            }
        }
    }

    public class SecondaryTeamRequestCanceledDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SecondaryTeamRequestCanceledDetails) throws -> JSON {
            let output = [
                "sent_to": try Serialization._StringSerializer.serialize(value.sentTo),
                "sent_by": try Serialization._StringSerializer.serialize(value.sentBy),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SecondaryTeamRequestCanceledDetails {
            switch json {
            case .dictionary(let dict):
                let sentTo = try Serialization._StringSerializer.deserialize(dict["sent_to"] ?? .null)
                let sentBy = try Serialization._StringSerializer.deserialize(dict["sent_by"] ?? .null)
                return SecondaryTeamRequestCanceledDetails(sentTo: sentTo, sentBy: sentBy)
            default:
                throw JSONSerializerError.deserializeError(type: SecondaryTeamRequestCanceledDetails.self, json: json)
            }
        }
    }

    /// Team merge request expiration details shown to the secondary team
    public class SecondaryTeamRequestExpiredDetails: CustomStringConvertible, JSONRepresentable {
        /// The email of the primary team admin the request was sent to.
        public let sentTo: String
        public init(sentTo: String) {
            stringValidator()(sentTo)
            self.sentTo = sentTo
        }

        func json() throws -> JSON {
            try SecondaryTeamRequestExpiredDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SecondaryTeamRequestExpiredDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SecondaryTeamRequestExpiredDetails: \(error)"
            }
        }
    }

    public class SecondaryTeamRequestExpiredDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SecondaryTeamRequestExpiredDetails) throws -> JSON {
            let output = [
                "sent_to": try Serialization._StringSerializer.serialize(value.sentTo),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SecondaryTeamRequestExpiredDetails {
            switch json {
            case .dictionary(let dict):
                let sentTo = try Serialization._StringSerializer.deserialize(dict["sent_to"] ?? .null)
                return SecondaryTeamRequestExpiredDetails(sentTo: sentTo)
            default:
                throw JSONSerializerError.deserializeError(type: SecondaryTeamRequestExpiredDetails.self, json: json)
            }
        }
    }

    /// Team merge request reminder details shown to the secondary team
    public class SecondaryTeamRequestReminderDetails: CustomStringConvertible, JSONRepresentable {
        /// The email of the primary team admin the request was sent to.
        public let sentTo: String
        public init(sentTo: String) {
            stringValidator()(sentTo)
            self.sentTo = sentTo
        }

        func json() throws -> JSON {
            try SecondaryTeamRequestReminderDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SecondaryTeamRequestReminderDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SecondaryTeamRequestReminderDetails: \(error)"
            }
        }
    }

    public class SecondaryTeamRequestReminderDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SecondaryTeamRequestReminderDetails) throws -> JSON {
            let output = [
                "sent_to": try Serialization._StringSerializer.serialize(value.sentTo),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SecondaryTeamRequestReminderDetails {
            switch json {
            case .dictionary(let dict):
                let sentTo = try Serialization._StringSerializer.deserialize(dict["sent_to"] ?? .null)
                return SecondaryTeamRequestReminderDetails(sentTo: sentTo)
            default:
                throw JSONSerializerError.deserializeError(type: SecondaryTeamRequestReminderDetails.self, json: json)
            }
        }
    }

    /// Policy for controlling team access to send for signature feature
    public enum SendForSignaturePolicy: CustomStringConvertible, JSONRepresentable {
        /// An unspecified error.
        case disabled
        /// An unspecified error.
        case enabled
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try SendForSignaturePolicySerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SendForSignaturePolicySerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SendForSignaturePolicy: \(error)"
            }
        }
    }

    public class SendForSignaturePolicySerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SendForSignaturePolicy) throws -> JSON {
            switch value {
            case .disabled:
                var d = [String: JSON]()
                d[".tag"] = .str("disabled")
                return .dictionary(d)
            case .enabled:
                var d = [String: JSON]()
                d[".tag"] = .str("enabled")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> SendForSignaturePolicy {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "disabled":
                    return SendForSignaturePolicy.disabled
                case "enabled":
                    return SendForSignaturePolicy.enabled
                case "other":
                    return SendForSignaturePolicy.other
                default:
                    return SendForSignaturePolicy.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: SendForSignaturePolicy.self, json: json)
            }
        }
    }

    /// Changed send for signature policy for team.
    public class SendForSignaturePolicyChangedDetails: CustomStringConvertible, JSONRepresentable {
        /// New send for signature policy.
        public let newValue: TeamLog.SendForSignaturePolicy
        /// Previous send for signature policy.
        public let previousValue: TeamLog.SendForSignaturePolicy
        public init(newValue: TeamLog.SendForSignaturePolicy, previousValue: TeamLog.SendForSignaturePolicy) {
            self.newValue = newValue
            self.previousValue = previousValue
        }

        func json() throws -> JSON {
            try SendForSignaturePolicyChangedDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SendForSignaturePolicyChangedDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SendForSignaturePolicyChangedDetails: \(error)"
            }
        }
    }

    public class SendForSignaturePolicyChangedDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SendForSignaturePolicyChangedDetails) throws -> JSON {
            let output = [
                "new_value": try TeamLog.SendForSignaturePolicySerializer().serialize(value.newValue),
                "previous_value": try TeamLog.SendForSignaturePolicySerializer().serialize(value.previousValue),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SendForSignaturePolicyChangedDetails {
            switch json {
            case .dictionary(let dict):
                let newValue = try TeamLog.SendForSignaturePolicySerializer().deserialize(dict["new_value"] ?? .null)
                let previousValue = try TeamLog.SendForSignaturePolicySerializer().deserialize(dict["previous_value"] ?? .null)
                return SendForSignaturePolicyChangedDetails(newValue: newValue, previousValue: previousValue)
            default:
                throw JSONSerializerError.deserializeError(type: SendForSignaturePolicyChangedDetails.self, json: json)
            }
        }
    }

    /// The SendForSignaturePolicyChangedType struct
    public class SendForSignaturePolicyChangedType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try SendForSignaturePolicyChangedTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SendForSignaturePolicyChangedTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SendForSignaturePolicyChangedType: \(error)"
            }
        }
    }

    public class SendForSignaturePolicyChangedTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SendForSignaturePolicyChangedType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SendForSignaturePolicyChangedType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return SendForSignaturePolicyChangedType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: SendForSignaturePolicyChangedType.self, json: json)
            }
        }
    }

    /// Added team to shared folder.
    public class SfAddGroupDetails: CustomStringConvertible, JSONRepresentable {
        /// Target asset position in the Assets list.
        public let targetAssetIndex: UInt64
        /// Original shared folder name.
        public let originalFolderName: String
        /// Sharing permission.
        public let sharingPermission: String?
        /// Team name.
        public let teamName: String
        public init(targetAssetIndex: UInt64, originalFolderName: String, teamName: String, sharingPermission: String? = nil) {
            comparableValidator()(targetAssetIndex)
            self.targetAssetIndex = targetAssetIndex
            stringValidator()(originalFolderName)
            self.originalFolderName = originalFolderName
            nullableValidator(stringValidator())(sharingPermission)
            self.sharingPermission = sharingPermission
            stringValidator()(teamName)
            self.teamName = teamName
        }

        func json() throws -> JSON {
            try SfAddGroupDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SfAddGroupDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SfAddGroupDetails: \(error)"
            }
        }
    }

    public class SfAddGroupDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SfAddGroupDetails) throws -> JSON {
            let output = [
                "target_asset_index": try Serialization._UInt64Serializer.serialize(value.targetAssetIndex),
                "original_folder_name": try Serialization._StringSerializer.serialize(value.originalFolderName),
                "team_name": try Serialization._StringSerializer.serialize(value.teamName),
                "sharing_permission": try NullableSerializer(Serialization._StringSerializer).serialize(value.sharingPermission),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SfAddGroupDetails {
            switch json {
            case .dictionary(let dict):
                let targetAssetIndex = try Serialization._UInt64Serializer.deserialize(dict["target_asset_index"] ?? .null)
                let originalFolderName = try Serialization._StringSerializer.deserialize(dict["original_folder_name"] ?? .null)
                let teamName = try Serialization._StringSerializer.deserialize(dict["team_name"] ?? .null)
                let sharingPermission = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["sharing_permission"] ?? .null)
                return SfAddGroupDetails(
                    targetAssetIndex: targetAssetIndex,
                    originalFolderName: originalFolderName,
                    teamName: teamName,
                    sharingPermission: sharingPermission
                )
            default:
                throw JSONSerializerError.deserializeError(type: SfAddGroupDetails.self, json: json)
            }
        }
    }

    /// The SfAddGroupType struct
    public class SfAddGroupType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try SfAddGroupTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SfAddGroupTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SfAddGroupType: \(error)"
            }
        }
    }

    public class SfAddGroupTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SfAddGroupType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SfAddGroupType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return SfAddGroupType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: SfAddGroupType.self, json: json)
            }
        }
    }

    /// Allowed non-collaborators to view links to files in shared folder.
    public class SfAllowNonMembersToViewSharedLinksDetails: CustomStringConvertible, JSONRepresentable {
        /// Target asset position in the Assets list.
        public let targetAssetIndex: UInt64
        /// Original shared folder name.
        public let originalFolderName: String
        /// Shared folder type.
        public let sharedFolderType: String?
        public init(targetAssetIndex: UInt64, originalFolderName: String, sharedFolderType: String? = nil) {
            comparableValidator()(targetAssetIndex)
            self.targetAssetIndex = targetAssetIndex
            stringValidator()(originalFolderName)
            self.originalFolderName = originalFolderName
            nullableValidator(stringValidator())(sharedFolderType)
            self.sharedFolderType = sharedFolderType
        }

        func json() throws -> JSON {
            try SfAllowNonMembersToViewSharedLinksDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SfAllowNonMembersToViewSharedLinksDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SfAllowNonMembersToViewSharedLinksDetails: \(error)"
            }
        }
    }

    public class SfAllowNonMembersToViewSharedLinksDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SfAllowNonMembersToViewSharedLinksDetails) throws -> JSON {
            let output = [
                "target_asset_index": try Serialization._UInt64Serializer.serialize(value.targetAssetIndex),
                "original_folder_name": try Serialization._StringSerializer.serialize(value.originalFolderName),
                "shared_folder_type": try NullableSerializer(Serialization._StringSerializer).serialize(value.sharedFolderType),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SfAllowNonMembersToViewSharedLinksDetails {
            switch json {
            case .dictionary(let dict):
                let targetAssetIndex = try Serialization._UInt64Serializer.deserialize(dict["target_asset_index"] ?? .null)
                let originalFolderName = try Serialization._StringSerializer.deserialize(dict["original_folder_name"] ?? .null)
                let sharedFolderType = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["shared_folder_type"] ?? .null)
                return SfAllowNonMembersToViewSharedLinksDetails(
                    targetAssetIndex: targetAssetIndex,
                    originalFolderName: originalFolderName,
                    sharedFolderType: sharedFolderType
                )
            default:
                throw JSONSerializerError.deserializeError(type: SfAllowNonMembersToViewSharedLinksDetails.self, json: json)
            }
        }
    }

    /// The SfAllowNonMembersToViewSharedLinksType struct
    public class SfAllowNonMembersToViewSharedLinksType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try SfAllowNonMembersToViewSharedLinksTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SfAllowNonMembersToViewSharedLinksTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SfAllowNonMembersToViewSharedLinksType: \(error)"
            }
        }
    }

    public class SfAllowNonMembersToViewSharedLinksTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SfAllowNonMembersToViewSharedLinksType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SfAllowNonMembersToViewSharedLinksType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return SfAllowNonMembersToViewSharedLinksType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: SfAllowNonMembersToViewSharedLinksType.self, json: json)
            }
        }
    }

    /// Set team members to see warning before sharing folders outside team.
    public class SfExternalInviteWarnDetails: CustomStringConvertible, JSONRepresentable {
        /// Target asset position in the Assets list.
        public let targetAssetIndex: UInt64
        /// Original shared folder name.
        public let originalFolderName: String
        /// New sharing permission.
        public let newSharingPermission: String?
        /// Previous sharing permission.
        public let previousSharingPermission: String?
        public init(targetAssetIndex: UInt64, originalFolderName: String, newSharingPermission: String? = nil, previousSharingPermission: String? = nil) {
            comparableValidator()(targetAssetIndex)
            self.targetAssetIndex = targetAssetIndex
            stringValidator()(originalFolderName)
            self.originalFolderName = originalFolderName
            nullableValidator(stringValidator())(newSharingPermission)
            self.newSharingPermission = newSharingPermission
            nullableValidator(stringValidator())(previousSharingPermission)
            self.previousSharingPermission = previousSharingPermission
        }

        func json() throws -> JSON {
            try SfExternalInviteWarnDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SfExternalInviteWarnDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SfExternalInviteWarnDetails: \(error)"
            }
        }
    }

    public class SfExternalInviteWarnDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SfExternalInviteWarnDetails) throws -> JSON {
            let output = [
                "target_asset_index": try Serialization._UInt64Serializer.serialize(value.targetAssetIndex),
                "original_folder_name": try Serialization._StringSerializer.serialize(value.originalFolderName),
                "new_sharing_permission": try NullableSerializer(Serialization._StringSerializer).serialize(value.newSharingPermission),
                "previous_sharing_permission": try NullableSerializer(Serialization._StringSerializer).serialize(value.previousSharingPermission),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SfExternalInviteWarnDetails {
            switch json {
            case .dictionary(let dict):
                let targetAssetIndex = try Serialization._UInt64Serializer.deserialize(dict["target_asset_index"] ?? .null)
                let originalFolderName = try Serialization._StringSerializer.deserialize(dict["original_folder_name"] ?? .null)
                let newSharingPermission = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["new_sharing_permission"] ?? .null)
                let previousSharingPermission = try NullableSerializer(Serialization._StringSerializer)
                    .deserialize(dict["previous_sharing_permission"] ?? .null)
                return SfExternalInviteWarnDetails(
                    targetAssetIndex: targetAssetIndex,
                    originalFolderName: originalFolderName,
                    newSharingPermission: newSharingPermission,
                    previousSharingPermission: previousSharingPermission
                )
            default:
                throw JSONSerializerError.deserializeError(type: SfExternalInviteWarnDetails.self, json: json)
            }
        }
    }

    /// The SfExternalInviteWarnType struct
    public class SfExternalInviteWarnType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try SfExternalInviteWarnTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SfExternalInviteWarnTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SfExternalInviteWarnType: \(error)"
            }
        }
    }

    public class SfExternalInviteWarnTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SfExternalInviteWarnType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SfExternalInviteWarnType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return SfExternalInviteWarnType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: SfExternalInviteWarnType.self, json: json)
            }
        }
    }

    /// Changed Facebook user's role in shared folder.
    public class SfFbInviteChangeRoleDetails: CustomStringConvertible, JSONRepresentable {
        /// Target asset position in the Assets list.
        public let targetAssetIndex: UInt64
        /// Original shared folder name.
        public let originalFolderName: String
        /// Previous sharing permission.
        public let previousSharingPermission: String?
        /// New sharing permission.
        public let newSharingPermission: String?
        public init(targetAssetIndex: UInt64, originalFolderName: String, previousSharingPermission: String? = nil, newSharingPermission: String? = nil) {
            comparableValidator()(targetAssetIndex)
            self.targetAssetIndex = targetAssetIndex
            stringValidator()(originalFolderName)
            self.originalFolderName = originalFolderName
            nullableValidator(stringValidator())(previousSharingPermission)
            self.previousSharingPermission = previousSharingPermission
            nullableValidator(stringValidator())(newSharingPermission)
            self.newSharingPermission = newSharingPermission
        }

        func json() throws -> JSON {
            try SfFbInviteChangeRoleDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SfFbInviteChangeRoleDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SfFbInviteChangeRoleDetails: \(error)"
            }
        }
    }

    public class SfFbInviteChangeRoleDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SfFbInviteChangeRoleDetails) throws -> JSON {
            let output = [
                "target_asset_index": try Serialization._UInt64Serializer.serialize(value.targetAssetIndex),
                "original_folder_name": try Serialization._StringSerializer.serialize(value.originalFolderName),
                "previous_sharing_permission": try NullableSerializer(Serialization._StringSerializer).serialize(value.previousSharingPermission),
                "new_sharing_permission": try NullableSerializer(Serialization._StringSerializer).serialize(value.newSharingPermission),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SfFbInviteChangeRoleDetails {
            switch json {
            case .dictionary(let dict):
                let targetAssetIndex = try Serialization._UInt64Serializer.deserialize(dict["target_asset_index"] ?? .null)
                let originalFolderName = try Serialization._StringSerializer.deserialize(dict["original_folder_name"] ?? .null)
                let previousSharingPermission = try NullableSerializer(Serialization._StringSerializer)
                    .deserialize(dict["previous_sharing_permission"] ?? .null)
                let newSharingPermission = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["new_sharing_permission"] ?? .null)
                return SfFbInviteChangeRoleDetails(
                    targetAssetIndex: targetAssetIndex,
                    originalFolderName: originalFolderName,
                    previousSharingPermission: previousSharingPermission,
                    newSharingPermission: newSharingPermission
                )
            default:
                throw JSONSerializerError.deserializeError(type: SfFbInviteChangeRoleDetails.self, json: json)
            }
        }
    }

    /// The SfFbInviteChangeRoleType struct
    public class SfFbInviteChangeRoleType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try SfFbInviteChangeRoleTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SfFbInviteChangeRoleTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SfFbInviteChangeRoleType: \(error)"
            }
        }
    }

    public class SfFbInviteChangeRoleTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SfFbInviteChangeRoleType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SfFbInviteChangeRoleType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return SfFbInviteChangeRoleType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: SfFbInviteChangeRoleType.self, json: json)
            }
        }
    }

    /// Invited Facebook users to shared folder.
    public class SfFbInviteDetails: CustomStringConvertible, JSONRepresentable {
        /// Target asset position in the Assets list.
        public let targetAssetIndex: UInt64
        /// Original shared folder name.
        public let originalFolderName: String
        /// Sharing permission.
        public let sharingPermission: String?
        public init(targetAssetIndex: UInt64, originalFolderName: String, sharingPermission: String? = nil) {
            comparableValidator()(targetAssetIndex)
            self.targetAssetIndex = targetAssetIndex
            stringValidator()(originalFolderName)
            self.originalFolderName = originalFolderName
            nullableValidator(stringValidator())(sharingPermission)
            self.sharingPermission = sharingPermission
        }

        func json() throws -> JSON {
            try SfFbInviteDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SfFbInviteDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SfFbInviteDetails: \(error)"
            }
        }
    }

    public class SfFbInviteDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SfFbInviteDetails) throws -> JSON {
            let output = [
                "target_asset_index": try Serialization._UInt64Serializer.serialize(value.targetAssetIndex),
                "original_folder_name": try Serialization._StringSerializer.serialize(value.originalFolderName),
                "sharing_permission": try NullableSerializer(Serialization._StringSerializer).serialize(value.sharingPermission),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SfFbInviteDetails {
            switch json {
            case .dictionary(let dict):
                let targetAssetIndex = try Serialization._UInt64Serializer.deserialize(dict["target_asset_index"] ?? .null)
                let originalFolderName = try Serialization._StringSerializer.deserialize(dict["original_folder_name"] ?? .null)
                let sharingPermission = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["sharing_permission"] ?? .null)
                return SfFbInviteDetails(targetAssetIndex: targetAssetIndex, originalFolderName: originalFolderName, sharingPermission: sharingPermission)
            default:
                throw JSONSerializerError.deserializeError(type: SfFbInviteDetails.self, json: json)
            }
        }
    }

    /// The SfFbInviteType struct
    public class SfFbInviteType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try SfFbInviteTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SfFbInviteTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SfFbInviteType: \(error)"
            }
        }
    }

    public class SfFbInviteTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SfFbInviteType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SfFbInviteType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return SfFbInviteType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: SfFbInviteType.self, json: json)
            }
        }
    }

    /// Uninvited Facebook user from shared folder.
    public class SfFbUninviteDetails: CustomStringConvertible, JSONRepresentable {
        /// Target asset position in the Assets list.
        public let targetAssetIndex: UInt64
        /// Original shared folder name.
        public let originalFolderName: String
        public init(targetAssetIndex: UInt64, originalFolderName: String) {
            comparableValidator()(targetAssetIndex)
            self.targetAssetIndex = targetAssetIndex
            stringValidator()(originalFolderName)
            self.originalFolderName = originalFolderName
        }

        func json() throws -> JSON {
            try SfFbUninviteDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SfFbUninviteDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SfFbUninviteDetails: \(error)"
            }
        }
    }

    public class SfFbUninviteDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SfFbUninviteDetails) throws -> JSON {
            let output = [
                "target_asset_index": try Serialization._UInt64Serializer.serialize(value.targetAssetIndex),
                "original_folder_name": try Serialization._StringSerializer.serialize(value.originalFolderName),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SfFbUninviteDetails {
            switch json {
            case .dictionary(let dict):
                let targetAssetIndex = try Serialization._UInt64Serializer.deserialize(dict["target_asset_index"] ?? .null)
                let originalFolderName = try Serialization._StringSerializer.deserialize(dict["original_folder_name"] ?? .null)
                return SfFbUninviteDetails(targetAssetIndex: targetAssetIndex, originalFolderName: originalFolderName)
            default:
                throw JSONSerializerError.deserializeError(type: SfFbUninviteDetails.self, json: json)
            }
        }
    }

    /// The SfFbUninviteType struct
    public class SfFbUninviteType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try SfFbUninviteTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SfFbUninviteTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SfFbUninviteType: \(error)"
            }
        }
    }

    public class SfFbUninviteTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SfFbUninviteType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SfFbUninviteType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return SfFbUninviteType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: SfFbUninviteType.self, json: json)
            }
        }
    }

    /// Invited group to shared folder.
    public class SfInviteGroupDetails: CustomStringConvertible, JSONRepresentable {
        /// Target asset position in the Assets list.
        public let targetAssetIndex: UInt64
        public init(targetAssetIndex: UInt64) {
            comparableValidator()(targetAssetIndex)
            self.targetAssetIndex = targetAssetIndex
        }

        func json() throws -> JSON {
            try SfInviteGroupDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SfInviteGroupDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SfInviteGroupDetails: \(error)"
            }
        }
    }

    public class SfInviteGroupDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SfInviteGroupDetails) throws -> JSON {
            let output = [
                "target_asset_index": try Serialization._UInt64Serializer.serialize(value.targetAssetIndex),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SfInviteGroupDetails {
            switch json {
            case .dictionary(let dict):
                let targetAssetIndex = try Serialization._UInt64Serializer.deserialize(dict["target_asset_index"] ?? .null)
                return SfInviteGroupDetails(targetAssetIndex: targetAssetIndex)
            default:
                throw JSONSerializerError.deserializeError(type: SfInviteGroupDetails.self, json: json)
            }
        }
    }

    /// The SfInviteGroupType struct
    public class SfInviteGroupType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try SfInviteGroupTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SfInviteGroupTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SfInviteGroupType: \(error)"
            }
        }
    }

    public class SfInviteGroupTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SfInviteGroupType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SfInviteGroupType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return SfInviteGroupType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: SfInviteGroupType.self, json: json)
            }
        }
    }

    /// Granted access to shared folder.
    public class SfTeamGrantAccessDetails: CustomStringConvertible, JSONRepresentable {
        /// Target asset position in the Assets list.
        public let targetAssetIndex: UInt64
        /// Original shared folder name.
        public let originalFolderName: String
        public init(targetAssetIndex: UInt64, originalFolderName: String) {
            comparableValidator()(targetAssetIndex)
            self.targetAssetIndex = targetAssetIndex
            stringValidator()(originalFolderName)
            self.originalFolderName = originalFolderName
        }

        func json() throws -> JSON {
            try SfTeamGrantAccessDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SfTeamGrantAccessDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SfTeamGrantAccessDetails: \(error)"
            }
        }
    }

    public class SfTeamGrantAccessDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SfTeamGrantAccessDetails) throws -> JSON {
            let output = [
                "target_asset_index": try Serialization._UInt64Serializer.serialize(value.targetAssetIndex),
                "original_folder_name": try Serialization._StringSerializer.serialize(value.originalFolderName),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SfTeamGrantAccessDetails {
            switch json {
            case .dictionary(let dict):
                let targetAssetIndex = try Serialization._UInt64Serializer.deserialize(dict["target_asset_index"] ?? .null)
                let originalFolderName = try Serialization._StringSerializer.deserialize(dict["original_folder_name"] ?? .null)
                return SfTeamGrantAccessDetails(targetAssetIndex: targetAssetIndex, originalFolderName: originalFolderName)
            default:
                throw JSONSerializerError.deserializeError(type: SfTeamGrantAccessDetails.self, json: json)
            }
        }
    }

    /// The SfTeamGrantAccessType struct
    public class SfTeamGrantAccessType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try SfTeamGrantAccessTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SfTeamGrantAccessTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SfTeamGrantAccessType: \(error)"
            }
        }
    }

    public class SfTeamGrantAccessTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SfTeamGrantAccessType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SfTeamGrantAccessType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return SfTeamGrantAccessType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: SfTeamGrantAccessType.self, json: json)
            }
        }
    }

    /// Changed team member's role in shared folder.
    public class SfTeamInviteChangeRoleDetails: CustomStringConvertible, JSONRepresentable {
        /// Target asset position in the Assets list.
        public let targetAssetIndex: UInt64
        /// Original shared folder name.
        public let originalFolderName: String
        /// New sharing permission.
        public let newSharingPermission: String?
        /// Previous sharing permission.
        public let previousSharingPermission: String?
        public init(targetAssetIndex: UInt64, originalFolderName: String, newSharingPermission: String? = nil, previousSharingPermission: String? = nil) {
            comparableValidator()(targetAssetIndex)
            self.targetAssetIndex = targetAssetIndex
            stringValidator()(originalFolderName)
            self.originalFolderName = originalFolderName
            nullableValidator(stringValidator())(newSharingPermission)
            self.newSharingPermission = newSharingPermission
            nullableValidator(stringValidator())(previousSharingPermission)
            self.previousSharingPermission = previousSharingPermission
        }

        func json() throws -> JSON {
            try SfTeamInviteChangeRoleDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SfTeamInviteChangeRoleDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SfTeamInviteChangeRoleDetails: \(error)"
            }
        }
    }

    public class SfTeamInviteChangeRoleDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SfTeamInviteChangeRoleDetails) throws -> JSON {
            let output = [
                "target_asset_index": try Serialization._UInt64Serializer.serialize(value.targetAssetIndex),
                "original_folder_name": try Serialization._StringSerializer.serialize(value.originalFolderName),
                "new_sharing_permission": try NullableSerializer(Serialization._StringSerializer).serialize(value.newSharingPermission),
                "previous_sharing_permission": try NullableSerializer(Serialization._StringSerializer).serialize(value.previousSharingPermission),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SfTeamInviteChangeRoleDetails {
            switch json {
            case .dictionary(let dict):
                let targetAssetIndex = try Serialization._UInt64Serializer.deserialize(dict["target_asset_index"] ?? .null)
                let originalFolderName = try Serialization._StringSerializer.deserialize(dict["original_folder_name"] ?? .null)
                let newSharingPermission = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["new_sharing_permission"] ?? .null)
                let previousSharingPermission = try NullableSerializer(Serialization._StringSerializer)
                    .deserialize(dict["previous_sharing_permission"] ?? .null)
                return SfTeamInviteChangeRoleDetails(
                    targetAssetIndex: targetAssetIndex,
                    originalFolderName: originalFolderName,
                    newSharingPermission: newSharingPermission,
                    previousSharingPermission: previousSharingPermission
                )
            default:
                throw JSONSerializerError.deserializeError(type: SfTeamInviteChangeRoleDetails.self, json: json)
            }
        }
    }

    /// The SfTeamInviteChangeRoleType struct
    public class SfTeamInviteChangeRoleType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try SfTeamInviteChangeRoleTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SfTeamInviteChangeRoleTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SfTeamInviteChangeRoleType: \(error)"
            }
        }
    }

    public class SfTeamInviteChangeRoleTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SfTeamInviteChangeRoleType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SfTeamInviteChangeRoleType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return SfTeamInviteChangeRoleType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: SfTeamInviteChangeRoleType.self, json: json)
            }
        }
    }

    /// Invited team members to shared folder.
    public class SfTeamInviteDetails: CustomStringConvertible, JSONRepresentable {
        /// Target asset position in the Assets list.
        public let targetAssetIndex: UInt64
        /// Original shared folder name.
        public let originalFolderName: String
        /// Sharing permission.
        public let sharingPermission: String?
        public init(targetAssetIndex: UInt64, originalFolderName: String, sharingPermission: String? = nil) {
            comparableValidator()(targetAssetIndex)
            self.targetAssetIndex = targetAssetIndex
            stringValidator()(originalFolderName)
            self.originalFolderName = originalFolderName
            nullableValidator(stringValidator())(sharingPermission)
            self.sharingPermission = sharingPermission
        }

        func json() throws -> JSON {
            try SfTeamInviteDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SfTeamInviteDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SfTeamInviteDetails: \(error)"
            }
        }
    }

    public class SfTeamInviteDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SfTeamInviteDetails) throws -> JSON {
            let output = [
                "target_asset_index": try Serialization._UInt64Serializer.serialize(value.targetAssetIndex),
                "original_folder_name": try Serialization._StringSerializer.serialize(value.originalFolderName),
                "sharing_permission": try NullableSerializer(Serialization._StringSerializer).serialize(value.sharingPermission),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SfTeamInviteDetails {
            switch json {
            case .dictionary(let dict):
                let targetAssetIndex = try Serialization._UInt64Serializer.deserialize(dict["target_asset_index"] ?? .null)
                let originalFolderName = try Serialization._StringSerializer.deserialize(dict["original_folder_name"] ?? .null)
                let sharingPermission = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["sharing_permission"] ?? .null)
                return SfTeamInviteDetails(targetAssetIndex: targetAssetIndex, originalFolderName: originalFolderName, sharingPermission: sharingPermission)
            default:
                throw JSONSerializerError.deserializeError(type: SfTeamInviteDetails.self, json: json)
            }
        }
    }

    /// The SfTeamInviteType struct
    public class SfTeamInviteType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try SfTeamInviteTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SfTeamInviteTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SfTeamInviteType: \(error)"
            }
        }
    }

    public class SfTeamInviteTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SfTeamInviteType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SfTeamInviteType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return SfTeamInviteType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: SfTeamInviteType.self, json: json)
            }
        }
    }

    /// Joined team member's shared folder.
    public class SfTeamJoinDetails: CustomStringConvertible, JSONRepresentable {
        /// Target asset position in the Assets list.
        public let targetAssetIndex: UInt64
        /// Original shared folder name.
        public let originalFolderName: String
        public init(targetAssetIndex: UInt64, originalFolderName: String) {
            comparableValidator()(targetAssetIndex)
            self.targetAssetIndex = targetAssetIndex
            stringValidator()(originalFolderName)
            self.originalFolderName = originalFolderName
        }

        func json() throws -> JSON {
            try SfTeamJoinDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SfTeamJoinDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SfTeamJoinDetails: \(error)"
            }
        }
    }

    public class SfTeamJoinDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SfTeamJoinDetails) throws -> JSON {
            let output = [
                "target_asset_index": try Serialization._UInt64Serializer.serialize(value.targetAssetIndex),
                "original_folder_name": try Serialization._StringSerializer.serialize(value.originalFolderName),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SfTeamJoinDetails {
            switch json {
            case .dictionary(let dict):
                let targetAssetIndex = try Serialization._UInt64Serializer.deserialize(dict["target_asset_index"] ?? .null)
                let originalFolderName = try Serialization._StringSerializer.deserialize(dict["original_folder_name"] ?? .null)
                return SfTeamJoinDetails(targetAssetIndex: targetAssetIndex, originalFolderName: originalFolderName)
            default:
                throw JSONSerializerError.deserializeError(type: SfTeamJoinDetails.self, json: json)
            }
        }
    }

    /// Joined team member's shared folder from link.
    public class SfTeamJoinFromOobLinkDetails: CustomStringConvertible, JSONRepresentable {
        /// Target asset position in the Assets list.
        public let targetAssetIndex: UInt64
        /// Original shared folder name.
        public let originalFolderName: String
        /// Shared link token key.
        public let tokenKey: String?
        /// Sharing permission.
        public let sharingPermission: String?
        public init(targetAssetIndex: UInt64, originalFolderName: String, tokenKey: String? = nil, sharingPermission: String? = nil) {
            comparableValidator()(targetAssetIndex)
            self.targetAssetIndex = targetAssetIndex
            stringValidator()(originalFolderName)
            self.originalFolderName = originalFolderName
            nullableValidator(stringValidator())(tokenKey)
            self.tokenKey = tokenKey
            nullableValidator(stringValidator())(sharingPermission)
            self.sharingPermission = sharingPermission
        }

        func json() throws -> JSON {
            try SfTeamJoinFromOobLinkDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SfTeamJoinFromOobLinkDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SfTeamJoinFromOobLinkDetails: \(error)"
            }
        }
    }

    public class SfTeamJoinFromOobLinkDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SfTeamJoinFromOobLinkDetails) throws -> JSON {
            let output = [
                "target_asset_index": try Serialization._UInt64Serializer.serialize(value.targetAssetIndex),
                "original_folder_name": try Serialization._StringSerializer.serialize(value.originalFolderName),
                "token_key": try NullableSerializer(Serialization._StringSerializer).serialize(value.tokenKey),
                "sharing_permission": try NullableSerializer(Serialization._StringSerializer).serialize(value.sharingPermission),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SfTeamJoinFromOobLinkDetails {
            switch json {
            case .dictionary(let dict):
                let targetAssetIndex = try Serialization._UInt64Serializer.deserialize(dict["target_asset_index"] ?? .null)
                let originalFolderName = try Serialization._StringSerializer.deserialize(dict["original_folder_name"] ?? .null)
                let tokenKey = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["token_key"] ?? .null)
                let sharingPermission = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["sharing_permission"] ?? .null)
                return SfTeamJoinFromOobLinkDetails(
                    targetAssetIndex: targetAssetIndex,
                    originalFolderName: originalFolderName,
                    tokenKey: tokenKey,
                    sharingPermission: sharingPermission
                )
            default:
                throw JSONSerializerError.deserializeError(type: SfTeamJoinFromOobLinkDetails.self, json: json)
            }
        }
    }

    /// The SfTeamJoinFromOobLinkType struct
    public class SfTeamJoinFromOobLinkType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try SfTeamJoinFromOobLinkTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SfTeamJoinFromOobLinkTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SfTeamJoinFromOobLinkType: \(error)"
            }
        }
    }

    public class SfTeamJoinFromOobLinkTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SfTeamJoinFromOobLinkType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SfTeamJoinFromOobLinkType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return SfTeamJoinFromOobLinkType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: SfTeamJoinFromOobLinkType.self, json: json)
            }
        }
    }

    /// The SfTeamJoinType struct
    public class SfTeamJoinType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try SfTeamJoinTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SfTeamJoinTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SfTeamJoinType: \(error)"
            }
        }
    }

    public class SfTeamJoinTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SfTeamJoinType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SfTeamJoinType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return SfTeamJoinType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: SfTeamJoinType.self, json: json)
            }
        }
    }

    /// Unshared folder with team member.
    public class SfTeamUninviteDetails: CustomStringConvertible, JSONRepresentable {
        /// Target asset position in the Assets list.
        public let targetAssetIndex: UInt64
        /// Original shared folder name.
        public let originalFolderName: String
        public init(targetAssetIndex: UInt64, originalFolderName: String) {
            comparableValidator()(targetAssetIndex)
            self.targetAssetIndex = targetAssetIndex
            stringValidator()(originalFolderName)
            self.originalFolderName = originalFolderName
        }

        func json() throws -> JSON {
            try SfTeamUninviteDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SfTeamUninviteDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SfTeamUninviteDetails: \(error)"
            }
        }
    }

    public class SfTeamUninviteDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SfTeamUninviteDetails) throws -> JSON {
            let output = [
                "target_asset_index": try Serialization._UInt64Serializer.serialize(value.targetAssetIndex),
                "original_folder_name": try Serialization._StringSerializer.serialize(value.originalFolderName),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SfTeamUninviteDetails {
            switch json {
            case .dictionary(let dict):
                let targetAssetIndex = try Serialization._UInt64Serializer.deserialize(dict["target_asset_index"] ?? .null)
                let originalFolderName = try Serialization._StringSerializer.deserialize(dict["original_folder_name"] ?? .null)
                return SfTeamUninviteDetails(targetAssetIndex: targetAssetIndex, originalFolderName: originalFolderName)
            default:
                throw JSONSerializerError.deserializeError(type: SfTeamUninviteDetails.self, json: json)
            }
        }
    }

    /// The SfTeamUninviteType struct
    public class SfTeamUninviteType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try SfTeamUninviteTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SfTeamUninviteTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SfTeamUninviteType: \(error)"
            }
        }
    }

    public class SfTeamUninviteTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SfTeamUninviteType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SfTeamUninviteType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return SfTeamUninviteType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: SfTeamUninviteType.self, json: json)
            }
        }
    }

    /// Invited user to Dropbox and added them to shared file/folder.
    public class SharedContentAddInviteesDetails: CustomStringConvertible, JSONRepresentable {
        /// Shared content access level.
        public let sharedContentAccessLevel: Sharing.AccessLevel
        /// A list of invitees.
        public let invitees: [String]
        public init(sharedContentAccessLevel: Sharing.AccessLevel, invitees: [String]) {
            self.sharedContentAccessLevel = sharedContentAccessLevel
            arrayValidator(itemValidator: stringValidator(maxLength: 255))(invitees)
            self.invitees = invitees
        }

        func json() throws -> JSON {
            try SharedContentAddInviteesDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharedContentAddInviteesDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharedContentAddInviteesDetails: \(error)"
            }
        }
    }

    public class SharedContentAddInviteesDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharedContentAddInviteesDetails) throws -> JSON {
            let output = [
                "shared_content_access_level": try Sharing.AccessLevelSerializer().serialize(value.sharedContentAccessLevel),
                "invitees": try ArraySerializer(Serialization._StringSerializer).serialize(value.invitees),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharedContentAddInviteesDetails {
            switch json {
            case .dictionary(let dict):
                let sharedContentAccessLevel = try Sharing.AccessLevelSerializer().deserialize(dict["shared_content_access_level"] ?? .null)
                let invitees = try ArraySerializer(Serialization._StringSerializer).deserialize(dict["invitees"] ?? .null)
                return SharedContentAddInviteesDetails(sharedContentAccessLevel: sharedContentAccessLevel, invitees: invitees)
            default:
                throw JSONSerializerError.deserializeError(type: SharedContentAddInviteesDetails.self, json: json)
            }
        }
    }

    /// The SharedContentAddInviteesType struct
    public class SharedContentAddInviteesType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try SharedContentAddInviteesTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharedContentAddInviteesTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharedContentAddInviteesType: \(error)"
            }
        }
    }

    public class SharedContentAddInviteesTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharedContentAddInviteesType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharedContentAddInviteesType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return SharedContentAddInviteesType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: SharedContentAddInviteesType.self, json: json)
            }
        }
    }

    /// Added expiration date to link for shared file/folder.
    public class SharedContentAddLinkExpiryDetails: CustomStringConvertible, JSONRepresentable {
        /// New shared content link expiration date. Might be missing due to historical data gap.
        public let newValue: Date?
        public init(newValue: Date? = nil) {
            self.newValue = newValue
        }

        func json() throws -> JSON {
            try SharedContentAddLinkExpiryDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharedContentAddLinkExpiryDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharedContentAddLinkExpiryDetails: \(error)"
            }
        }
    }

    public class SharedContentAddLinkExpiryDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharedContentAddLinkExpiryDetails) throws -> JSON {
            let output = [
                "new_value": try NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.newValue),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharedContentAddLinkExpiryDetails {
            switch json {
            case .dictionary(let dict):
                let newValue = try NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).deserialize(dict["new_value"] ?? .null)
                return SharedContentAddLinkExpiryDetails(newValue: newValue)
            default:
                throw JSONSerializerError.deserializeError(type: SharedContentAddLinkExpiryDetails.self, json: json)
            }
        }
    }

    /// The SharedContentAddLinkExpiryType struct
    public class SharedContentAddLinkExpiryType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try SharedContentAddLinkExpiryTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharedContentAddLinkExpiryTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharedContentAddLinkExpiryType: \(error)"
            }
        }
    }

    public class SharedContentAddLinkExpiryTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharedContentAddLinkExpiryType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharedContentAddLinkExpiryType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return SharedContentAddLinkExpiryType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: SharedContentAddLinkExpiryType.self, json: json)
            }
        }
    }

    /// Added password to link for shared file/folder.
    public class SharedContentAddLinkPasswordDetails: CustomStringConvertible, JSONRepresentable {
        func json() throws -> JSON {
            try SharedContentAddLinkPasswordDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharedContentAddLinkPasswordDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharedContentAddLinkPasswordDetails: \(error)"
            }
        }
    }

    public class SharedContentAddLinkPasswordDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharedContentAddLinkPasswordDetails) throws -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharedContentAddLinkPasswordDetails {
            switch json {
            case .dictionary:
                return SharedContentAddLinkPasswordDetails()
            default:
                throw JSONSerializerError.deserializeError(type: SharedContentAddLinkPasswordDetails.self, json: json)
            }
        }
    }

    /// The SharedContentAddLinkPasswordType struct
    public class SharedContentAddLinkPasswordType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try SharedContentAddLinkPasswordTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharedContentAddLinkPasswordTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharedContentAddLinkPasswordType: \(error)"
            }
        }
    }

    public class SharedContentAddLinkPasswordTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharedContentAddLinkPasswordType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharedContentAddLinkPasswordType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return SharedContentAddLinkPasswordType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: SharedContentAddLinkPasswordType.self, json: json)
            }
        }
    }

    /// Added users and/or groups to shared file/folder.
    public class SharedContentAddMemberDetails: CustomStringConvertible, JSONRepresentable {
        /// Shared content access level.
        public let sharedContentAccessLevel: Sharing.AccessLevel
        public init(sharedContentAccessLevel: Sharing.AccessLevel) {
            self.sharedContentAccessLevel = sharedContentAccessLevel
        }

        func json() throws -> JSON {
            try SharedContentAddMemberDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharedContentAddMemberDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharedContentAddMemberDetails: \(error)"
            }
        }
    }

    public class SharedContentAddMemberDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharedContentAddMemberDetails) throws -> JSON {
            let output = [
                "shared_content_access_level": try Sharing.AccessLevelSerializer().serialize(value.sharedContentAccessLevel),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharedContentAddMemberDetails {
            switch json {
            case .dictionary(let dict):
                let sharedContentAccessLevel = try Sharing.AccessLevelSerializer().deserialize(dict["shared_content_access_level"] ?? .null)
                return SharedContentAddMemberDetails(sharedContentAccessLevel: sharedContentAccessLevel)
            default:
                throw JSONSerializerError.deserializeError(type: SharedContentAddMemberDetails.self, json: json)
            }
        }
    }

    /// The SharedContentAddMemberType struct
    public class SharedContentAddMemberType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try SharedContentAddMemberTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharedContentAddMemberTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharedContentAddMemberType: \(error)"
            }
        }
    }

    public class SharedContentAddMemberTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharedContentAddMemberType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharedContentAddMemberType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return SharedContentAddMemberType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: SharedContentAddMemberType.self, json: json)
            }
        }
    }

    /// Changed whether members can download shared file/folder.
    public class SharedContentChangeDownloadsPolicyDetails: CustomStringConvertible, JSONRepresentable {
        /// New downloads policy.
        public let newValue: TeamLog.DownloadPolicyType
        /// Previous downloads policy. Might be missing due to historical data gap.
        public let previousValue: TeamLog.DownloadPolicyType?
        public init(newValue: TeamLog.DownloadPolicyType, previousValue: TeamLog.DownloadPolicyType? = nil) {
            self.newValue = newValue
            self.previousValue = previousValue
        }

        func json() throws -> JSON {
            try SharedContentChangeDownloadsPolicyDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharedContentChangeDownloadsPolicyDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharedContentChangeDownloadsPolicyDetails: \(error)"
            }
        }
    }

    public class SharedContentChangeDownloadsPolicyDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharedContentChangeDownloadsPolicyDetails) throws -> JSON {
            let output = [
                "new_value": try TeamLog.DownloadPolicyTypeSerializer().serialize(value.newValue),
                "previous_value": try NullableSerializer(TeamLog.DownloadPolicyTypeSerializer()).serialize(value.previousValue),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharedContentChangeDownloadsPolicyDetails {
            switch json {
            case .dictionary(let dict):
                let newValue = try TeamLog.DownloadPolicyTypeSerializer().deserialize(dict["new_value"] ?? .null)
                let previousValue = try NullableSerializer(TeamLog.DownloadPolicyTypeSerializer()).deserialize(dict["previous_value"] ?? .null)
                return SharedContentChangeDownloadsPolicyDetails(newValue: newValue, previousValue: previousValue)
            default:
                throw JSONSerializerError.deserializeError(type: SharedContentChangeDownloadsPolicyDetails.self, json: json)
            }
        }
    }

    /// The SharedContentChangeDownloadsPolicyType struct
    public class SharedContentChangeDownloadsPolicyType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try SharedContentChangeDownloadsPolicyTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharedContentChangeDownloadsPolicyTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharedContentChangeDownloadsPolicyType: \(error)"
            }
        }
    }

    public class SharedContentChangeDownloadsPolicyTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharedContentChangeDownloadsPolicyType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharedContentChangeDownloadsPolicyType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return SharedContentChangeDownloadsPolicyType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: SharedContentChangeDownloadsPolicyType.self, json: json)
            }
        }
    }

    /// Changed access type of invitee to shared file/folder before invite was accepted.
    public class SharedContentChangeInviteeRoleDetails: CustomStringConvertible, JSONRepresentable {
        /// Previous access level. Might be missing due to historical data gap.
        public let previousAccessLevel: Sharing.AccessLevel?
        /// New access level.
        public let newAccessLevel: Sharing.AccessLevel
        /// The invitee whose role was changed.
        public let invitee: String
        public init(newAccessLevel: Sharing.AccessLevel, invitee: String, previousAccessLevel: Sharing.AccessLevel? = nil) {
            self.previousAccessLevel = previousAccessLevel
            self.newAccessLevel = newAccessLevel
            stringValidator(maxLength: 255)(invitee)
            self.invitee = invitee
        }

        func json() throws -> JSON {
            try SharedContentChangeInviteeRoleDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharedContentChangeInviteeRoleDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharedContentChangeInviteeRoleDetails: \(error)"
            }
        }
    }

    public class SharedContentChangeInviteeRoleDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharedContentChangeInviteeRoleDetails) throws -> JSON {
            let output = [
                "new_access_level": try Sharing.AccessLevelSerializer().serialize(value.newAccessLevel),
                "invitee": try Serialization._StringSerializer.serialize(value.invitee),
                "previous_access_level": try NullableSerializer(Sharing.AccessLevelSerializer()).serialize(value.previousAccessLevel),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharedContentChangeInviteeRoleDetails {
            switch json {
            case .dictionary(let dict):
                let newAccessLevel = try Sharing.AccessLevelSerializer().deserialize(dict["new_access_level"] ?? .null)
                let invitee = try Serialization._StringSerializer.deserialize(dict["invitee"] ?? .null)
                let previousAccessLevel = try NullableSerializer(Sharing.AccessLevelSerializer()).deserialize(dict["previous_access_level"] ?? .null)
                return SharedContentChangeInviteeRoleDetails(newAccessLevel: newAccessLevel, invitee: invitee, previousAccessLevel: previousAccessLevel)
            default:
                throw JSONSerializerError.deserializeError(type: SharedContentChangeInviteeRoleDetails.self, json: json)
            }
        }
    }

    /// The SharedContentChangeInviteeRoleType struct
    public class SharedContentChangeInviteeRoleType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try SharedContentChangeInviteeRoleTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharedContentChangeInviteeRoleTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharedContentChangeInviteeRoleType: \(error)"
            }
        }
    }

    public class SharedContentChangeInviteeRoleTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharedContentChangeInviteeRoleType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharedContentChangeInviteeRoleType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return SharedContentChangeInviteeRoleType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: SharedContentChangeInviteeRoleType.self, json: json)
            }
        }
    }

    /// Changed link audience of shared file/folder.
    public class SharedContentChangeLinkAudienceDetails: CustomStringConvertible, JSONRepresentable {
        /// New link audience value.
        public let newValue: Sharing.LinkAudience
        /// Previous link audience value.
        public let previousValue: Sharing.LinkAudience?
        public init(newValue: Sharing.LinkAudience, previousValue: Sharing.LinkAudience? = nil) {
            self.newValue = newValue
            self.previousValue = previousValue
        }

        func json() throws -> JSON {
            try SharedContentChangeLinkAudienceDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharedContentChangeLinkAudienceDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharedContentChangeLinkAudienceDetails: \(error)"
            }
        }
    }

    public class SharedContentChangeLinkAudienceDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharedContentChangeLinkAudienceDetails) throws -> JSON {
            let output = [
                "new_value": try Sharing.LinkAudienceSerializer().serialize(value.newValue),
                "previous_value": try NullableSerializer(Sharing.LinkAudienceSerializer()).serialize(value.previousValue),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharedContentChangeLinkAudienceDetails {
            switch json {
            case .dictionary(let dict):
                let newValue = try Sharing.LinkAudienceSerializer().deserialize(dict["new_value"] ?? .null)
                let previousValue = try NullableSerializer(Sharing.LinkAudienceSerializer()).deserialize(dict["previous_value"] ?? .null)
                return SharedContentChangeLinkAudienceDetails(newValue: newValue, previousValue: previousValue)
            default:
                throw JSONSerializerError.deserializeError(type: SharedContentChangeLinkAudienceDetails.self, json: json)
            }
        }
    }

    /// The SharedContentChangeLinkAudienceType struct
    public class SharedContentChangeLinkAudienceType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try SharedContentChangeLinkAudienceTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharedContentChangeLinkAudienceTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharedContentChangeLinkAudienceType: \(error)"
            }
        }
    }

    public class SharedContentChangeLinkAudienceTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharedContentChangeLinkAudienceType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharedContentChangeLinkAudienceType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return SharedContentChangeLinkAudienceType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: SharedContentChangeLinkAudienceType.self, json: json)
            }
        }
    }

    /// Changed link expiration of shared file/folder.
    public class SharedContentChangeLinkExpiryDetails: CustomStringConvertible, JSONRepresentable {
        /// New shared content link expiration date. Might be missing due to historical data gap.
        public let newValue: Date?
        /// Previous shared content link expiration date. Might be missing due to historical data gap.
        public let previousValue: Date?
        public init(newValue: Date? = nil, previousValue: Date? = nil) {
            self.newValue = newValue
            self.previousValue = previousValue
        }

        func json() throws -> JSON {
            try SharedContentChangeLinkExpiryDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharedContentChangeLinkExpiryDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharedContentChangeLinkExpiryDetails: \(error)"
            }
        }
    }

    public class SharedContentChangeLinkExpiryDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharedContentChangeLinkExpiryDetails) throws -> JSON {
            let output = [
                "new_value": try NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.newValue),
                "previous_value": try NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.previousValue),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharedContentChangeLinkExpiryDetails {
            switch json {
            case .dictionary(let dict):
                let newValue = try NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).deserialize(dict["new_value"] ?? .null)
                let previousValue = try NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).deserialize(dict["previous_value"] ?? .null)
                return SharedContentChangeLinkExpiryDetails(newValue: newValue, previousValue: previousValue)
            default:
                throw JSONSerializerError.deserializeError(type: SharedContentChangeLinkExpiryDetails.self, json: json)
            }
        }
    }

    /// The SharedContentChangeLinkExpiryType struct
    public class SharedContentChangeLinkExpiryType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try SharedContentChangeLinkExpiryTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharedContentChangeLinkExpiryTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharedContentChangeLinkExpiryType: \(error)"
            }
        }
    }

    public class SharedContentChangeLinkExpiryTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharedContentChangeLinkExpiryType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharedContentChangeLinkExpiryType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return SharedContentChangeLinkExpiryType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: SharedContentChangeLinkExpiryType.self, json: json)
            }
        }
    }

    /// Changed link password of shared file/folder.
    public class SharedContentChangeLinkPasswordDetails: CustomStringConvertible, JSONRepresentable {
        func json() throws -> JSON {
            try SharedContentChangeLinkPasswordDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharedContentChangeLinkPasswordDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharedContentChangeLinkPasswordDetails: \(error)"
            }
        }
    }

    public class SharedContentChangeLinkPasswordDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharedContentChangeLinkPasswordDetails) throws -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharedContentChangeLinkPasswordDetails {
            switch json {
            case .dictionary:
                return SharedContentChangeLinkPasswordDetails()
            default:
                throw JSONSerializerError.deserializeError(type: SharedContentChangeLinkPasswordDetails.self, json: json)
            }
        }
    }

    /// The SharedContentChangeLinkPasswordType struct
    public class SharedContentChangeLinkPasswordType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try SharedContentChangeLinkPasswordTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharedContentChangeLinkPasswordTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharedContentChangeLinkPasswordType: \(error)"
            }
        }
    }

    public class SharedContentChangeLinkPasswordTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharedContentChangeLinkPasswordType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharedContentChangeLinkPasswordType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return SharedContentChangeLinkPasswordType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: SharedContentChangeLinkPasswordType.self, json: json)
            }
        }
    }

    /// Changed access type of shared file/folder member.
    public class SharedContentChangeMemberRoleDetails: CustomStringConvertible, JSONRepresentable {
        /// Previous access level. Might be missing due to historical data gap.
        public let previousAccessLevel: Sharing.AccessLevel?
        /// New access level.
        public let newAccessLevel: Sharing.AccessLevel
        public init(newAccessLevel: Sharing.AccessLevel, previousAccessLevel: Sharing.AccessLevel? = nil) {
            self.previousAccessLevel = previousAccessLevel
            self.newAccessLevel = newAccessLevel
        }

        func json() throws -> JSON {
            try SharedContentChangeMemberRoleDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharedContentChangeMemberRoleDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharedContentChangeMemberRoleDetails: \(error)"
            }
        }
    }

    public class SharedContentChangeMemberRoleDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharedContentChangeMemberRoleDetails) throws -> JSON {
            let output = [
                "new_access_level": try Sharing.AccessLevelSerializer().serialize(value.newAccessLevel),
                "previous_access_level": try NullableSerializer(Sharing.AccessLevelSerializer()).serialize(value.previousAccessLevel),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharedContentChangeMemberRoleDetails {
            switch json {
            case .dictionary(let dict):
                let newAccessLevel = try Sharing.AccessLevelSerializer().deserialize(dict["new_access_level"] ?? .null)
                let previousAccessLevel = try NullableSerializer(Sharing.AccessLevelSerializer()).deserialize(dict["previous_access_level"] ?? .null)
                return SharedContentChangeMemberRoleDetails(newAccessLevel: newAccessLevel, previousAccessLevel: previousAccessLevel)
            default:
                throw JSONSerializerError.deserializeError(type: SharedContentChangeMemberRoleDetails.self, json: json)
            }
        }
    }

    /// The SharedContentChangeMemberRoleType struct
    public class SharedContentChangeMemberRoleType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try SharedContentChangeMemberRoleTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharedContentChangeMemberRoleTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharedContentChangeMemberRoleType: \(error)"
            }
        }
    }

    public class SharedContentChangeMemberRoleTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharedContentChangeMemberRoleType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharedContentChangeMemberRoleType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return SharedContentChangeMemberRoleType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: SharedContentChangeMemberRoleType.self, json: json)
            }
        }
    }

    /// Changed whether members can see who viewed shared file/folder.
    public class SharedContentChangeViewerInfoPolicyDetails: CustomStringConvertible, JSONRepresentable {
        /// New viewer info policy.
        public let newValue: Sharing.ViewerInfoPolicy
        /// Previous view info policy.
        public let previousValue: Sharing.ViewerInfoPolicy?
        public init(newValue: Sharing.ViewerInfoPolicy, previousValue: Sharing.ViewerInfoPolicy? = nil) {
            self.newValue = newValue
            self.previousValue = previousValue
        }

        func json() throws -> JSON {
            try SharedContentChangeViewerInfoPolicyDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharedContentChangeViewerInfoPolicyDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharedContentChangeViewerInfoPolicyDetails: \(error)"
            }
        }
    }

    public class SharedContentChangeViewerInfoPolicyDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharedContentChangeViewerInfoPolicyDetails) throws -> JSON {
            let output = [
                "new_value": try Sharing.ViewerInfoPolicySerializer().serialize(value.newValue),
                "previous_value": try NullableSerializer(Sharing.ViewerInfoPolicySerializer()).serialize(value.previousValue),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharedContentChangeViewerInfoPolicyDetails {
            switch json {
            case .dictionary(let dict):
                let newValue = try Sharing.ViewerInfoPolicySerializer().deserialize(dict["new_value"] ?? .null)
                let previousValue = try NullableSerializer(Sharing.ViewerInfoPolicySerializer()).deserialize(dict["previous_value"] ?? .null)
                return SharedContentChangeViewerInfoPolicyDetails(newValue: newValue, previousValue: previousValue)
            default:
                throw JSONSerializerError.deserializeError(type: SharedContentChangeViewerInfoPolicyDetails.self, json: json)
            }
        }
    }

    /// The SharedContentChangeViewerInfoPolicyType struct
    public class SharedContentChangeViewerInfoPolicyType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try SharedContentChangeViewerInfoPolicyTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharedContentChangeViewerInfoPolicyTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharedContentChangeViewerInfoPolicyType: \(error)"
            }
        }
    }

    public class SharedContentChangeViewerInfoPolicyTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharedContentChangeViewerInfoPolicyType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharedContentChangeViewerInfoPolicyType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return SharedContentChangeViewerInfoPolicyType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: SharedContentChangeViewerInfoPolicyType.self, json: json)
            }
        }
    }

    /// Acquired membership of shared file/folder by accepting invite.
    public class SharedContentClaimInvitationDetails: CustomStringConvertible, JSONRepresentable {
        /// Shared content link.
        public let sharedContentLink: String?
        public init(sharedContentLink: String? = nil) {
            nullableValidator(stringValidator())(sharedContentLink)
            self.sharedContentLink = sharedContentLink
        }

        func json() throws -> JSON {
            try SharedContentClaimInvitationDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharedContentClaimInvitationDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharedContentClaimInvitationDetails: \(error)"
            }
        }
    }

    public class SharedContentClaimInvitationDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharedContentClaimInvitationDetails) throws -> JSON {
            let output = [
                "shared_content_link": try NullableSerializer(Serialization._StringSerializer).serialize(value.sharedContentLink),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharedContentClaimInvitationDetails {
            switch json {
            case .dictionary(let dict):
                let sharedContentLink = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["shared_content_link"] ?? .null)
                return SharedContentClaimInvitationDetails(sharedContentLink: sharedContentLink)
            default:
                throw JSONSerializerError.deserializeError(type: SharedContentClaimInvitationDetails.self, json: json)
            }
        }
    }

    /// The SharedContentClaimInvitationType struct
    public class SharedContentClaimInvitationType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try SharedContentClaimInvitationTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharedContentClaimInvitationTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharedContentClaimInvitationType: \(error)"
            }
        }
    }

    public class SharedContentClaimInvitationTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharedContentClaimInvitationType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharedContentClaimInvitationType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return SharedContentClaimInvitationType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: SharedContentClaimInvitationType.self, json: json)
            }
        }
    }

    /// Copied shared file/folder to own Dropbox.
    public class SharedContentCopyDetails: CustomStringConvertible, JSONRepresentable {
        /// Shared content link.
        public let sharedContentLink: String
        /// The shared content owner.
        public let sharedContentOwner: TeamLog.UserLogInfo?
        /// Shared content access level.
        public let sharedContentAccessLevel: Sharing.AccessLevel
        /// The path where the member saved the content.
        public let destinationPath: String
        public init(
            sharedContentLink: String,
            sharedContentAccessLevel: Sharing.AccessLevel,
            destinationPath: String,
            sharedContentOwner: TeamLog.UserLogInfo? = nil
        ) {
            stringValidator()(sharedContentLink)
            self.sharedContentLink = sharedContentLink
            self.sharedContentOwner = sharedContentOwner
            self.sharedContentAccessLevel = sharedContentAccessLevel
            stringValidator()(destinationPath)
            self.destinationPath = destinationPath
        }

        func json() throws -> JSON {
            try SharedContentCopyDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharedContentCopyDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharedContentCopyDetails: \(error)"
            }
        }
    }

    public class SharedContentCopyDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharedContentCopyDetails) throws -> JSON {
            let output = [
                "shared_content_link": try Serialization._StringSerializer.serialize(value.sharedContentLink),
                "shared_content_access_level": try Sharing.AccessLevelSerializer().serialize(value.sharedContentAccessLevel),
                "destination_path": try Serialization._StringSerializer.serialize(value.destinationPath),
                "shared_content_owner": try NullableSerializer(TeamLog.UserLogInfoSerializer()).serialize(value.sharedContentOwner),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharedContentCopyDetails {
            switch json {
            case .dictionary(let dict):
                let sharedContentLink = try Serialization._StringSerializer.deserialize(dict["shared_content_link"] ?? .null)
                let sharedContentAccessLevel = try Sharing.AccessLevelSerializer().deserialize(dict["shared_content_access_level"] ?? .null)
                let destinationPath = try Serialization._StringSerializer.deserialize(dict["destination_path"] ?? .null)
                let sharedContentOwner = try NullableSerializer(TeamLog.UserLogInfoSerializer()).deserialize(dict["shared_content_owner"] ?? .null)
                return SharedContentCopyDetails(
                    sharedContentLink: sharedContentLink,
                    sharedContentAccessLevel: sharedContentAccessLevel,
                    destinationPath: destinationPath,
                    sharedContentOwner: sharedContentOwner
                )
            default:
                throw JSONSerializerError.deserializeError(type: SharedContentCopyDetails.self, json: json)
            }
        }
    }

    /// The SharedContentCopyType struct
    public class SharedContentCopyType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try SharedContentCopyTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharedContentCopyTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharedContentCopyType: \(error)"
            }
        }
    }

    public class SharedContentCopyTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharedContentCopyType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharedContentCopyType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return SharedContentCopyType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: SharedContentCopyType.self, json: json)
            }
        }
    }

    /// Downloaded shared file/folder.
    public class SharedContentDownloadDetails: CustomStringConvertible, JSONRepresentable {
        /// Shared content link.
        public let sharedContentLink: String
        /// The shared content owner.
        public let sharedContentOwner: TeamLog.UserLogInfo?
        /// Shared content access level.
        public let sharedContentAccessLevel: Sharing.AccessLevel
        public init(sharedContentLink: String, sharedContentAccessLevel: Sharing.AccessLevel, sharedContentOwner: TeamLog.UserLogInfo? = nil) {
            stringValidator()(sharedContentLink)
            self.sharedContentLink = sharedContentLink
            self.sharedContentOwner = sharedContentOwner
            self.sharedContentAccessLevel = sharedContentAccessLevel
        }

        func json() throws -> JSON {
            try SharedContentDownloadDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharedContentDownloadDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharedContentDownloadDetails: \(error)"
            }
        }
    }

    public class SharedContentDownloadDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharedContentDownloadDetails) throws -> JSON {
            let output = [
                "shared_content_link": try Serialization._StringSerializer.serialize(value.sharedContentLink),
                "shared_content_access_level": try Sharing.AccessLevelSerializer().serialize(value.sharedContentAccessLevel),
                "shared_content_owner": try NullableSerializer(TeamLog.UserLogInfoSerializer()).serialize(value.sharedContentOwner),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharedContentDownloadDetails {
            switch json {
            case .dictionary(let dict):
                let sharedContentLink = try Serialization._StringSerializer.deserialize(dict["shared_content_link"] ?? .null)
                let sharedContentAccessLevel = try Sharing.AccessLevelSerializer().deserialize(dict["shared_content_access_level"] ?? .null)
                let sharedContentOwner = try NullableSerializer(TeamLog.UserLogInfoSerializer()).deserialize(dict["shared_content_owner"] ?? .null)
                return SharedContentDownloadDetails(
                    sharedContentLink: sharedContentLink,
                    sharedContentAccessLevel: sharedContentAccessLevel,
                    sharedContentOwner: sharedContentOwner
                )
            default:
                throw JSONSerializerError.deserializeError(type: SharedContentDownloadDetails.self, json: json)
            }
        }
    }

    /// The SharedContentDownloadType struct
    public class SharedContentDownloadType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try SharedContentDownloadTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharedContentDownloadTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharedContentDownloadType: \(error)"
            }
        }
    }

    public class SharedContentDownloadTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharedContentDownloadType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharedContentDownloadType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return SharedContentDownloadType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: SharedContentDownloadType.self, json: json)
            }
        }
    }

    /// Left shared file/folder.
    public class SharedContentRelinquishMembershipDetails: CustomStringConvertible, JSONRepresentable {
        func json() throws -> JSON {
            try SharedContentRelinquishMembershipDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharedContentRelinquishMembershipDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharedContentRelinquishMembershipDetails: \(error)"
            }
        }
    }

    public class SharedContentRelinquishMembershipDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharedContentRelinquishMembershipDetails) throws -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharedContentRelinquishMembershipDetails {
            switch json {
            case .dictionary:
                return SharedContentRelinquishMembershipDetails()
            default:
                throw JSONSerializerError.deserializeError(type: SharedContentRelinquishMembershipDetails.self, json: json)
            }
        }
    }

    /// The SharedContentRelinquishMembershipType struct
    public class SharedContentRelinquishMembershipType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try SharedContentRelinquishMembershipTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharedContentRelinquishMembershipTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharedContentRelinquishMembershipType: \(error)"
            }
        }
    }

    public class SharedContentRelinquishMembershipTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharedContentRelinquishMembershipType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharedContentRelinquishMembershipType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return SharedContentRelinquishMembershipType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: SharedContentRelinquishMembershipType.self, json: json)
            }
        }
    }

    /// Removed invitee from shared file/folder before invite was accepted.
    public class SharedContentRemoveInviteesDetails: CustomStringConvertible, JSONRepresentable {
        /// A list of invitees.
        public let invitees: [String]
        public init(invitees: [String]) {
            arrayValidator(itemValidator: stringValidator(maxLength: 255))(invitees)
            self.invitees = invitees
        }

        func json() throws -> JSON {
            try SharedContentRemoveInviteesDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharedContentRemoveInviteesDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharedContentRemoveInviteesDetails: \(error)"
            }
        }
    }

    public class SharedContentRemoveInviteesDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharedContentRemoveInviteesDetails) throws -> JSON {
            let output = [
                "invitees": try ArraySerializer(Serialization._StringSerializer).serialize(value.invitees),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharedContentRemoveInviteesDetails {
            switch json {
            case .dictionary(let dict):
                let invitees = try ArraySerializer(Serialization._StringSerializer).deserialize(dict["invitees"] ?? .null)
                return SharedContentRemoveInviteesDetails(invitees: invitees)
            default:
                throw JSONSerializerError.deserializeError(type: SharedContentRemoveInviteesDetails.self, json: json)
            }
        }
    }

    /// The SharedContentRemoveInviteesType struct
    public class SharedContentRemoveInviteesType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try SharedContentRemoveInviteesTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharedContentRemoveInviteesTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharedContentRemoveInviteesType: \(error)"
            }
        }
    }

    public class SharedContentRemoveInviteesTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharedContentRemoveInviteesType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharedContentRemoveInviteesType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return SharedContentRemoveInviteesType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: SharedContentRemoveInviteesType.self, json: json)
            }
        }
    }

    /// Removed link expiration date of shared file/folder.
    public class SharedContentRemoveLinkExpiryDetails: CustomStringConvertible, JSONRepresentable {
        /// Previous shared content link expiration date. Might be missing due to historical data gap.
        public let previousValue: Date?
        public init(previousValue: Date? = nil) {
            self.previousValue = previousValue
        }

        func json() throws -> JSON {
            try SharedContentRemoveLinkExpiryDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharedContentRemoveLinkExpiryDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharedContentRemoveLinkExpiryDetails: \(error)"
            }
        }
    }

    public class SharedContentRemoveLinkExpiryDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharedContentRemoveLinkExpiryDetails) throws -> JSON {
            let output = [
                "previous_value": try NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.previousValue),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharedContentRemoveLinkExpiryDetails {
            switch json {
            case .dictionary(let dict):
                let previousValue = try NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).deserialize(dict["previous_value"] ?? .null)
                return SharedContentRemoveLinkExpiryDetails(previousValue: previousValue)
            default:
                throw JSONSerializerError.deserializeError(type: SharedContentRemoveLinkExpiryDetails.self, json: json)
            }
        }
    }

    /// The SharedContentRemoveLinkExpiryType struct
    public class SharedContentRemoveLinkExpiryType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try SharedContentRemoveLinkExpiryTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharedContentRemoveLinkExpiryTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharedContentRemoveLinkExpiryType: \(error)"
            }
        }
    }

    public class SharedContentRemoveLinkExpiryTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharedContentRemoveLinkExpiryType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharedContentRemoveLinkExpiryType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return SharedContentRemoveLinkExpiryType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: SharedContentRemoveLinkExpiryType.self, json: json)
            }
        }
    }

    /// Removed link password of shared file/folder.
    public class SharedContentRemoveLinkPasswordDetails: CustomStringConvertible, JSONRepresentable {
        func json() throws -> JSON {
            try SharedContentRemoveLinkPasswordDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharedContentRemoveLinkPasswordDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharedContentRemoveLinkPasswordDetails: \(error)"
            }
        }
    }

    public class SharedContentRemoveLinkPasswordDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharedContentRemoveLinkPasswordDetails) throws -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharedContentRemoveLinkPasswordDetails {
            switch json {
            case .dictionary:
                return SharedContentRemoveLinkPasswordDetails()
            default:
                throw JSONSerializerError.deserializeError(type: SharedContentRemoveLinkPasswordDetails.self, json: json)
            }
        }
    }

    /// The SharedContentRemoveLinkPasswordType struct
    public class SharedContentRemoveLinkPasswordType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try SharedContentRemoveLinkPasswordTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharedContentRemoveLinkPasswordTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharedContentRemoveLinkPasswordType: \(error)"
            }
        }
    }

    public class SharedContentRemoveLinkPasswordTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharedContentRemoveLinkPasswordType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharedContentRemoveLinkPasswordType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return SharedContentRemoveLinkPasswordType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: SharedContentRemoveLinkPasswordType.self, json: json)
            }
        }
    }

    /// Removed user/group from shared file/folder.
    public class SharedContentRemoveMemberDetails: CustomStringConvertible, JSONRepresentable {
        /// Shared content access level.
        public let sharedContentAccessLevel: Sharing.AccessLevel?
        public init(sharedContentAccessLevel: Sharing.AccessLevel? = nil) {
            self.sharedContentAccessLevel = sharedContentAccessLevel
        }

        func json() throws -> JSON {
            try SharedContentRemoveMemberDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharedContentRemoveMemberDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharedContentRemoveMemberDetails: \(error)"
            }
        }
    }

    public class SharedContentRemoveMemberDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharedContentRemoveMemberDetails) throws -> JSON {
            let output = [
                "shared_content_access_level": try NullableSerializer(Sharing.AccessLevelSerializer()).serialize(value.sharedContentAccessLevel),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharedContentRemoveMemberDetails {
            switch json {
            case .dictionary(let dict):
                let sharedContentAccessLevel = try NullableSerializer(Sharing.AccessLevelSerializer())
                    .deserialize(dict["shared_content_access_level"] ?? .null)
                return SharedContentRemoveMemberDetails(sharedContentAccessLevel: sharedContentAccessLevel)
            default:
                throw JSONSerializerError.deserializeError(type: SharedContentRemoveMemberDetails.self, json: json)
            }
        }
    }

    /// The SharedContentRemoveMemberType struct
    public class SharedContentRemoveMemberType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try SharedContentRemoveMemberTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharedContentRemoveMemberTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharedContentRemoveMemberType: \(error)"
            }
        }
    }

    public class SharedContentRemoveMemberTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharedContentRemoveMemberType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharedContentRemoveMemberType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return SharedContentRemoveMemberType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: SharedContentRemoveMemberType.self, json: json)
            }
        }
    }

    /// Requested access to shared file/folder.
    public class SharedContentRequestAccessDetails: CustomStringConvertible, JSONRepresentable {
        /// Shared content link.
        public let sharedContentLink: String?
        public init(sharedContentLink: String? = nil) {
            nullableValidator(stringValidator())(sharedContentLink)
            self.sharedContentLink = sharedContentLink
        }

        func json() throws -> JSON {
            try SharedContentRequestAccessDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharedContentRequestAccessDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharedContentRequestAccessDetails: \(error)"
            }
        }
    }

    public class SharedContentRequestAccessDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharedContentRequestAccessDetails) throws -> JSON {
            let output = [
                "shared_content_link": try NullableSerializer(Serialization._StringSerializer).serialize(value.sharedContentLink),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharedContentRequestAccessDetails {
            switch json {
            case .dictionary(let dict):
                let sharedContentLink = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["shared_content_link"] ?? .null)
                return SharedContentRequestAccessDetails(sharedContentLink: sharedContentLink)
            default:
                throw JSONSerializerError.deserializeError(type: SharedContentRequestAccessDetails.self, json: json)
            }
        }
    }

    /// The SharedContentRequestAccessType struct
    public class SharedContentRequestAccessType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try SharedContentRequestAccessTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharedContentRequestAccessTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharedContentRequestAccessType: \(error)"
            }
        }
    }

    public class SharedContentRequestAccessTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharedContentRequestAccessType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharedContentRequestAccessType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return SharedContentRequestAccessType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: SharedContentRequestAccessType.self, json: json)
            }
        }
    }

    /// Restored shared file/folder invitees.
    public class SharedContentRestoreInviteesDetails: CustomStringConvertible, JSONRepresentable {
        /// Shared content access level.
        public let sharedContentAccessLevel: Sharing.AccessLevel
        /// A list of invitees.
        public let invitees: [String]
        public init(sharedContentAccessLevel: Sharing.AccessLevel, invitees: [String]) {
            self.sharedContentAccessLevel = sharedContentAccessLevel
            arrayValidator(itemValidator: stringValidator(maxLength: 255))(invitees)
            self.invitees = invitees
        }

        func json() throws -> JSON {
            try SharedContentRestoreInviteesDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharedContentRestoreInviteesDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharedContentRestoreInviteesDetails: \(error)"
            }
        }
    }

    public class SharedContentRestoreInviteesDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharedContentRestoreInviteesDetails) throws -> JSON {
            let output = [
                "shared_content_access_level": try Sharing.AccessLevelSerializer().serialize(value.sharedContentAccessLevel),
                "invitees": try ArraySerializer(Serialization._StringSerializer).serialize(value.invitees),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharedContentRestoreInviteesDetails {
            switch json {
            case .dictionary(let dict):
                let sharedContentAccessLevel = try Sharing.AccessLevelSerializer().deserialize(dict["shared_content_access_level"] ?? .null)
                let invitees = try ArraySerializer(Serialization._StringSerializer).deserialize(dict["invitees"] ?? .null)
                return SharedContentRestoreInviteesDetails(sharedContentAccessLevel: sharedContentAccessLevel, invitees: invitees)
            default:
                throw JSONSerializerError.deserializeError(type: SharedContentRestoreInviteesDetails.self, json: json)
            }
        }
    }

    /// The SharedContentRestoreInviteesType struct
    public class SharedContentRestoreInviteesType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try SharedContentRestoreInviteesTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharedContentRestoreInviteesTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharedContentRestoreInviteesType: \(error)"
            }
        }
    }

    public class SharedContentRestoreInviteesTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharedContentRestoreInviteesType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharedContentRestoreInviteesType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return SharedContentRestoreInviteesType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: SharedContentRestoreInviteesType.self, json: json)
            }
        }
    }

    /// Restored users and/or groups to membership of shared file/folder.
    public class SharedContentRestoreMemberDetails: CustomStringConvertible, JSONRepresentable {
        /// Shared content access level.
        public let sharedContentAccessLevel: Sharing.AccessLevel
        public init(sharedContentAccessLevel: Sharing.AccessLevel) {
            self.sharedContentAccessLevel = sharedContentAccessLevel
        }

        func json() throws -> JSON {
            try SharedContentRestoreMemberDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharedContentRestoreMemberDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharedContentRestoreMemberDetails: \(error)"
            }
        }
    }

    public class SharedContentRestoreMemberDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharedContentRestoreMemberDetails) throws -> JSON {
            let output = [
                "shared_content_access_level": try Sharing.AccessLevelSerializer().serialize(value.sharedContentAccessLevel),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharedContentRestoreMemberDetails {
            switch json {
            case .dictionary(let dict):
                let sharedContentAccessLevel = try Sharing.AccessLevelSerializer().deserialize(dict["shared_content_access_level"] ?? .null)
                return SharedContentRestoreMemberDetails(sharedContentAccessLevel: sharedContentAccessLevel)
            default:
                throw JSONSerializerError.deserializeError(type: SharedContentRestoreMemberDetails.self, json: json)
            }
        }
    }

    /// The SharedContentRestoreMemberType struct
    public class SharedContentRestoreMemberType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try SharedContentRestoreMemberTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharedContentRestoreMemberTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharedContentRestoreMemberType: \(error)"
            }
        }
    }

    public class SharedContentRestoreMemberTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharedContentRestoreMemberType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharedContentRestoreMemberType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return SharedContentRestoreMemberType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: SharedContentRestoreMemberType.self, json: json)
            }
        }
    }

    /// Unshared file/folder by clearing membership.
    public class SharedContentUnshareDetails: CustomStringConvertible, JSONRepresentable {
        func json() throws -> JSON {
            try SharedContentUnshareDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharedContentUnshareDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharedContentUnshareDetails: \(error)"
            }
        }
    }

    public class SharedContentUnshareDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharedContentUnshareDetails) throws -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharedContentUnshareDetails {
            switch json {
            case .dictionary:
                return SharedContentUnshareDetails()
            default:
                throw JSONSerializerError.deserializeError(type: SharedContentUnshareDetails.self, json: json)
            }
        }
    }

    /// The SharedContentUnshareType struct
    public class SharedContentUnshareType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try SharedContentUnshareTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharedContentUnshareTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharedContentUnshareType: \(error)"
            }
        }
    }

    public class SharedContentUnshareTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharedContentUnshareType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharedContentUnshareType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return SharedContentUnshareType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: SharedContentUnshareType.self, json: json)
            }
        }
    }

    /// Previewed shared file/folder.
    public class SharedContentViewDetails: CustomStringConvertible, JSONRepresentable {
        /// Shared content link.
        public let sharedContentLink: String
        /// The shared content owner.
        public let sharedContentOwner: TeamLog.UserLogInfo?
        /// Shared content access level.
        public let sharedContentAccessLevel: Sharing.AccessLevel
        public init(sharedContentLink: String, sharedContentAccessLevel: Sharing.AccessLevel, sharedContentOwner: TeamLog.UserLogInfo? = nil) {
            stringValidator()(sharedContentLink)
            self.sharedContentLink = sharedContentLink
            self.sharedContentOwner = sharedContentOwner
            self.sharedContentAccessLevel = sharedContentAccessLevel
        }

        func json() throws -> JSON {
            try SharedContentViewDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharedContentViewDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharedContentViewDetails: \(error)"
            }
        }
    }

    public class SharedContentViewDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharedContentViewDetails) throws -> JSON {
            let output = [
                "shared_content_link": try Serialization._StringSerializer.serialize(value.sharedContentLink),
                "shared_content_access_level": try Sharing.AccessLevelSerializer().serialize(value.sharedContentAccessLevel),
                "shared_content_owner": try NullableSerializer(TeamLog.UserLogInfoSerializer()).serialize(value.sharedContentOwner),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharedContentViewDetails {
            switch json {
            case .dictionary(let dict):
                let sharedContentLink = try Serialization._StringSerializer.deserialize(dict["shared_content_link"] ?? .null)
                let sharedContentAccessLevel = try Sharing.AccessLevelSerializer().deserialize(dict["shared_content_access_level"] ?? .null)
                let sharedContentOwner = try NullableSerializer(TeamLog.UserLogInfoSerializer()).deserialize(dict["shared_content_owner"] ?? .null)
                return SharedContentViewDetails(
                    sharedContentLink: sharedContentLink,
                    sharedContentAccessLevel: sharedContentAccessLevel,
                    sharedContentOwner: sharedContentOwner
                )
            default:
                throw JSONSerializerError.deserializeError(type: SharedContentViewDetails.self, json: json)
            }
        }
    }

    /// The SharedContentViewType struct
    public class SharedContentViewType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try SharedContentViewTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharedContentViewTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharedContentViewType: \(error)"
            }
        }
    }

    public class SharedContentViewTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharedContentViewType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharedContentViewType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return SharedContentViewType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: SharedContentViewType.self, json: json)
            }
        }
    }

    /// Changed who can access shared folder via link.
    public class SharedFolderChangeLinkPolicyDetails: CustomStringConvertible, JSONRepresentable {
        /// New shared folder link policy.
        public let newValue: Sharing.SharedLinkPolicy
        /// Previous shared folder link policy. Might be missing due to historical data gap.
        public let previousValue: Sharing.SharedLinkPolicy?
        public init(newValue: Sharing.SharedLinkPolicy, previousValue: Sharing.SharedLinkPolicy? = nil) {
            self.newValue = newValue
            self.previousValue = previousValue
        }

        func json() throws -> JSON {
            try SharedFolderChangeLinkPolicyDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharedFolderChangeLinkPolicyDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharedFolderChangeLinkPolicyDetails: \(error)"
            }
        }
    }

    public class SharedFolderChangeLinkPolicyDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharedFolderChangeLinkPolicyDetails) throws -> JSON {
            let output = [
                "new_value": try Sharing.SharedLinkPolicySerializer().serialize(value.newValue),
                "previous_value": try NullableSerializer(Sharing.SharedLinkPolicySerializer()).serialize(value.previousValue),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharedFolderChangeLinkPolicyDetails {
            switch json {
            case .dictionary(let dict):
                let newValue = try Sharing.SharedLinkPolicySerializer().deserialize(dict["new_value"] ?? .null)
                let previousValue = try NullableSerializer(Sharing.SharedLinkPolicySerializer()).deserialize(dict["previous_value"] ?? .null)
                return SharedFolderChangeLinkPolicyDetails(newValue: newValue, previousValue: previousValue)
            default:
                throw JSONSerializerError.deserializeError(type: SharedFolderChangeLinkPolicyDetails.self, json: json)
            }
        }
    }

    /// The SharedFolderChangeLinkPolicyType struct
    public class SharedFolderChangeLinkPolicyType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try SharedFolderChangeLinkPolicyTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharedFolderChangeLinkPolicyTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharedFolderChangeLinkPolicyType: \(error)"
            }
        }
    }

    public class SharedFolderChangeLinkPolicyTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharedFolderChangeLinkPolicyType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharedFolderChangeLinkPolicyType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return SharedFolderChangeLinkPolicyType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: SharedFolderChangeLinkPolicyType.self, json: json)
            }
        }
    }

    /// Changed whether shared folder inherits members from parent folder.
    public class SharedFolderChangeMembersInheritancePolicyDetails: CustomStringConvertible, JSONRepresentable {
        /// New member inheritance policy.
        public let newValue: TeamLog.SharedFolderMembersInheritancePolicy
        /// Previous member inheritance policy. Might be missing due to historical data gap.
        public let previousValue: TeamLog.SharedFolderMembersInheritancePolicy?
        public init(newValue: TeamLog.SharedFolderMembersInheritancePolicy, previousValue: TeamLog.SharedFolderMembersInheritancePolicy? = nil) {
            self.newValue = newValue
            self.previousValue = previousValue
        }

        func json() throws -> JSON {
            try SharedFolderChangeMembersInheritancePolicyDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharedFolderChangeMembersInheritancePolicyDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharedFolderChangeMembersInheritancePolicyDetails: \(error)"
            }
        }
    }

    public class SharedFolderChangeMembersInheritancePolicyDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharedFolderChangeMembersInheritancePolicyDetails) throws -> JSON {
            let output = [
                "new_value": try TeamLog.SharedFolderMembersInheritancePolicySerializer().serialize(value.newValue),
                "previous_value": try NullableSerializer(TeamLog.SharedFolderMembersInheritancePolicySerializer()).serialize(value.previousValue),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharedFolderChangeMembersInheritancePolicyDetails {
            switch json {
            case .dictionary(let dict):
                let newValue = try TeamLog.SharedFolderMembersInheritancePolicySerializer().deserialize(dict["new_value"] ?? .null)
                let previousValue = try NullableSerializer(TeamLog.SharedFolderMembersInheritancePolicySerializer())
                    .deserialize(dict["previous_value"] ?? .null)
                return SharedFolderChangeMembersInheritancePolicyDetails(newValue: newValue, previousValue: previousValue)
            default:
                throw JSONSerializerError.deserializeError(type: SharedFolderChangeMembersInheritancePolicyDetails.self, json: json)
            }
        }
    }

    /// The SharedFolderChangeMembersInheritancePolicyType struct
    public class SharedFolderChangeMembersInheritancePolicyType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try SharedFolderChangeMembersInheritancePolicyTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharedFolderChangeMembersInheritancePolicyTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharedFolderChangeMembersInheritancePolicyType: \(error)"
            }
        }
    }

    public class SharedFolderChangeMembersInheritancePolicyTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharedFolderChangeMembersInheritancePolicyType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharedFolderChangeMembersInheritancePolicyType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return SharedFolderChangeMembersInheritancePolicyType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: SharedFolderChangeMembersInheritancePolicyType.self, json: json)
            }
        }
    }

    /// Changed who can add/remove members of shared folder.
    public class SharedFolderChangeMembersManagementPolicyDetails: CustomStringConvertible, JSONRepresentable {
        /// New members management policy.
        public let newValue: Sharing.AclUpdatePolicy
        /// Previous members management policy. Might be missing due to historical data gap.
        public let previousValue: Sharing.AclUpdatePolicy?
        public init(newValue: Sharing.AclUpdatePolicy, previousValue: Sharing.AclUpdatePolicy? = nil) {
            self.newValue = newValue
            self.previousValue = previousValue
        }

        func json() throws -> JSON {
            try SharedFolderChangeMembersManagementPolicyDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharedFolderChangeMembersManagementPolicyDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharedFolderChangeMembersManagementPolicyDetails: \(error)"
            }
        }
    }

    public class SharedFolderChangeMembersManagementPolicyDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharedFolderChangeMembersManagementPolicyDetails) throws -> JSON {
            let output = [
                "new_value": try Sharing.AclUpdatePolicySerializer().serialize(value.newValue),
                "previous_value": try NullableSerializer(Sharing.AclUpdatePolicySerializer()).serialize(value.previousValue),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharedFolderChangeMembersManagementPolicyDetails {
            switch json {
            case .dictionary(let dict):
                let newValue = try Sharing.AclUpdatePolicySerializer().deserialize(dict["new_value"] ?? .null)
                let previousValue = try NullableSerializer(Sharing.AclUpdatePolicySerializer()).deserialize(dict["previous_value"] ?? .null)
                return SharedFolderChangeMembersManagementPolicyDetails(newValue: newValue, previousValue: previousValue)
            default:
                throw JSONSerializerError.deserializeError(type: SharedFolderChangeMembersManagementPolicyDetails.self, json: json)
            }
        }
    }

    /// The SharedFolderChangeMembersManagementPolicyType struct
    public class SharedFolderChangeMembersManagementPolicyType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try SharedFolderChangeMembersManagementPolicyTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharedFolderChangeMembersManagementPolicyTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharedFolderChangeMembersManagementPolicyType: \(error)"
            }
        }
    }

    public class SharedFolderChangeMembersManagementPolicyTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharedFolderChangeMembersManagementPolicyType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharedFolderChangeMembersManagementPolicyType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return SharedFolderChangeMembersManagementPolicyType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: SharedFolderChangeMembersManagementPolicyType.self, json: json)
            }
        }
    }

    /// Changed who can become member of shared folder.
    public class SharedFolderChangeMembersPolicyDetails: CustomStringConvertible, JSONRepresentable {
        /// New external invite policy.
        public let newValue: Sharing.MemberPolicy
        /// Previous external invite policy. Might be missing due to historical data gap.
        public let previousValue: Sharing.MemberPolicy?
        public init(newValue: Sharing.MemberPolicy, previousValue: Sharing.MemberPolicy? = nil) {
            self.newValue = newValue
            self.previousValue = previousValue
        }

        func json() throws -> JSON {
            try SharedFolderChangeMembersPolicyDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharedFolderChangeMembersPolicyDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharedFolderChangeMembersPolicyDetails: \(error)"
            }
        }
    }

    public class SharedFolderChangeMembersPolicyDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharedFolderChangeMembersPolicyDetails) throws -> JSON {
            let output = [
                "new_value": try Sharing.MemberPolicySerializer().serialize(value.newValue),
                "previous_value": try NullableSerializer(Sharing.MemberPolicySerializer()).serialize(value.previousValue),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharedFolderChangeMembersPolicyDetails {
            switch json {
            case .dictionary(let dict):
                let newValue = try Sharing.MemberPolicySerializer().deserialize(dict["new_value"] ?? .null)
                let previousValue = try NullableSerializer(Sharing.MemberPolicySerializer()).deserialize(dict["previous_value"] ?? .null)
                return SharedFolderChangeMembersPolicyDetails(newValue: newValue, previousValue: previousValue)
            default:
                throw JSONSerializerError.deserializeError(type: SharedFolderChangeMembersPolicyDetails.self, json: json)
            }
        }
    }

    /// The SharedFolderChangeMembersPolicyType struct
    public class SharedFolderChangeMembersPolicyType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try SharedFolderChangeMembersPolicyTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharedFolderChangeMembersPolicyTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharedFolderChangeMembersPolicyType: \(error)"
            }
        }
    }

    public class SharedFolderChangeMembersPolicyTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharedFolderChangeMembersPolicyType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharedFolderChangeMembersPolicyType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return SharedFolderChangeMembersPolicyType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: SharedFolderChangeMembersPolicyType.self, json: json)
            }
        }
    }

    /// Created shared folder.
    public class SharedFolderCreateDetails: CustomStringConvertible, JSONRepresentable {
        /// Target namespace ID.
        public let targetNsId: String?
        public init(targetNsId: String? = nil) {
            nullableValidator(stringValidator())(targetNsId)
            self.targetNsId = targetNsId
        }

        func json() throws -> JSON {
            try SharedFolderCreateDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharedFolderCreateDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharedFolderCreateDetails: \(error)"
            }
        }
    }

    public class SharedFolderCreateDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharedFolderCreateDetails) throws -> JSON {
            let output = [
                "target_ns_id": try NullableSerializer(Serialization._StringSerializer).serialize(value.targetNsId),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharedFolderCreateDetails {
            switch json {
            case .dictionary(let dict):
                let targetNsId = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["target_ns_id"] ?? .null)
                return SharedFolderCreateDetails(targetNsId: targetNsId)
            default:
                throw JSONSerializerError.deserializeError(type: SharedFolderCreateDetails.self, json: json)
            }
        }
    }

    /// The SharedFolderCreateType struct
    public class SharedFolderCreateType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try SharedFolderCreateTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharedFolderCreateTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharedFolderCreateType: \(error)"
            }
        }
    }

    public class SharedFolderCreateTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharedFolderCreateType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharedFolderCreateType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return SharedFolderCreateType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: SharedFolderCreateType.self, json: json)
            }
        }
    }

    /// Declined team member's invite to shared folder.
    public class SharedFolderDeclineInvitationDetails: CustomStringConvertible, JSONRepresentable {
        func json() throws -> JSON {
            try SharedFolderDeclineInvitationDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharedFolderDeclineInvitationDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharedFolderDeclineInvitationDetails: \(error)"
            }
        }
    }

    public class SharedFolderDeclineInvitationDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharedFolderDeclineInvitationDetails) throws -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharedFolderDeclineInvitationDetails {
            switch json {
            case .dictionary:
                return SharedFolderDeclineInvitationDetails()
            default:
                throw JSONSerializerError.deserializeError(type: SharedFolderDeclineInvitationDetails.self, json: json)
            }
        }
    }

    /// The SharedFolderDeclineInvitationType struct
    public class SharedFolderDeclineInvitationType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try SharedFolderDeclineInvitationTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharedFolderDeclineInvitationTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharedFolderDeclineInvitationType: \(error)"
            }
        }
    }

    public class SharedFolderDeclineInvitationTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharedFolderDeclineInvitationType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharedFolderDeclineInvitationType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return SharedFolderDeclineInvitationType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: SharedFolderDeclineInvitationType.self, json: json)
            }
        }
    }

    /// Specifies if a shared folder inherits its members from the parent folder.
    public enum SharedFolderMembersInheritancePolicy: CustomStringConvertible, JSONRepresentable {
        /// An unspecified error.
        case dontInheritMembers
        /// An unspecified error.
        case inheritMembers
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try SharedFolderMembersInheritancePolicySerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharedFolderMembersInheritancePolicySerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharedFolderMembersInheritancePolicy: \(error)"
            }
        }
    }

    public class SharedFolderMembersInheritancePolicySerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharedFolderMembersInheritancePolicy) throws -> JSON {
            switch value {
            case .dontInheritMembers:
                var d = [String: JSON]()
                d[".tag"] = .str("dont_inherit_members")
                return .dictionary(d)
            case .inheritMembers:
                var d = [String: JSON]()
                d[".tag"] = .str("inherit_members")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> SharedFolderMembersInheritancePolicy {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "dont_inherit_members":
                    return SharedFolderMembersInheritancePolicy.dontInheritMembers
                case "inherit_members":
                    return SharedFolderMembersInheritancePolicy.inheritMembers
                case "other":
                    return SharedFolderMembersInheritancePolicy.other
                default:
                    return SharedFolderMembersInheritancePolicy.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: SharedFolderMembersInheritancePolicy.self, json: json)
            }
        }
    }

    /// Added shared folder to own Dropbox.
    public class SharedFolderMountDetails: CustomStringConvertible, JSONRepresentable {
        func json() throws -> JSON {
            try SharedFolderMountDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharedFolderMountDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharedFolderMountDetails: \(error)"
            }
        }
    }

    public class SharedFolderMountDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharedFolderMountDetails) throws -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharedFolderMountDetails {
            switch json {
            case .dictionary:
                return SharedFolderMountDetails()
            default:
                throw JSONSerializerError.deserializeError(type: SharedFolderMountDetails.self, json: json)
            }
        }
    }

    /// The SharedFolderMountType struct
    public class SharedFolderMountType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try SharedFolderMountTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharedFolderMountTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharedFolderMountType: \(error)"
            }
        }
    }

    public class SharedFolderMountTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharedFolderMountType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharedFolderMountType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return SharedFolderMountType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: SharedFolderMountType.self, json: json)
            }
        }
    }

    /// Changed parent of shared folder.
    public class SharedFolderNestDetails: CustomStringConvertible, JSONRepresentable {
        /// Previous parent namespace ID.
        public let previousParentNsId: String?
        /// New parent namespace ID.
        public let newParentNsId: String?
        /// Previous namespace path.
        public let previousNsPath: String?
        /// New namespace path.
        public let newNsPath: String?
        public init(previousParentNsId: String? = nil, newParentNsId: String? = nil, previousNsPath: String? = nil, newNsPath: String? = nil) {
            nullableValidator(stringValidator())(previousParentNsId)
            self.previousParentNsId = previousParentNsId
            nullableValidator(stringValidator())(newParentNsId)
            self.newParentNsId = newParentNsId
            nullableValidator(stringValidator())(previousNsPath)
            self.previousNsPath = previousNsPath
            nullableValidator(stringValidator())(newNsPath)
            self.newNsPath = newNsPath
        }

        func json() throws -> JSON {
            try SharedFolderNestDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharedFolderNestDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharedFolderNestDetails: \(error)"
            }
        }
    }

    public class SharedFolderNestDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharedFolderNestDetails) throws -> JSON {
            let output = [
                "previous_parent_ns_id": try NullableSerializer(Serialization._StringSerializer).serialize(value.previousParentNsId),
                "new_parent_ns_id": try NullableSerializer(Serialization._StringSerializer).serialize(value.newParentNsId),
                "previous_ns_path": try NullableSerializer(Serialization._StringSerializer).serialize(value.previousNsPath),
                "new_ns_path": try NullableSerializer(Serialization._StringSerializer).serialize(value.newNsPath),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharedFolderNestDetails {
            switch json {
            case .dictionary(let dict):
                let previousParentNsId = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["previous_parent_ns_id"] ?? .null)
                let newParentNsId = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["new_parent_ns_id"] ?? .null)
                let previousNsPath = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["previous_ns_path"] ?? .null)
                let newNsPath = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["new_ns_path"] ?? .null)
                return SharedFolderNestDetails(
                    previousParentNsId: previousParentNsId,
                    newParentNsId: newParentNsId,
                    previousNsPath: previousNsPath,
                    newNsPath: newNsPath
                )
            default:
                throw JSONSerializerError.deserializeError(type: SharedFolderNestDetails.self, json: json)
            }
        }
    }

    /// The SharedFolderNestType struct
    public class SharedFolderNestType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try SharedFolderNestTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharedFolderNestTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharedFolderNestType: \(error)"
            }
        }
    }

    public class SharedFolderNestTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharedFolderNestType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharedFolderNestType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return SharedFolderNestType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: SharedFolderNestType.self, json: json)
            }
        }
    }

    /// Transferred ownership of shared folder to another member.
    public class SharedFolderTransferOwnershipDetails: CustomStringConvertible, JSONRepresentable {
        /// The email address of the previous shared folder owner.
        public let previousOwnerEmail: String?
        /// The email address of the new shared folder owner.
        public let newOwnerEmail: String
        public init(newOwnerEmail: String, previousOwnerEmail: String? = nil) {
            nullableValidator(stringValidator(maxLength: 255))(previousOwnerEmail)
            self.previousOwnerEmail = previousOwnerEmail
            stringValidator(maxLength: 255)(newOwnerEmail)
            self.newOwnerEmail = newOwnerEmail
        }

        func json() throws -> JSON {
            try SharedFolderTransferOwnershipDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharedFolderTransferOwnershipDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharedFolderTransferOwnershipDetails: \(error)"
            }
        }
    }

    public class SharedFolderTransferOwnershipDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharedFolderTransferOwnershipDetails) throws -> JSON {
            let output = [
                "new_owner_email": try Serialization._StringSerializer.serialize(value.newOwnerEmail),
                "previous_owner_email": try NullableSerializer(Serialization._StringSerializer).serialize(value.previousOwnerEmail),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharedFolderTransferOwnershipDetails {
            switch json {
            case .dictionary(let dict):
                let newOwnerEmail = try Serialization._StringSerializer.deserialize(dict["new_owner_email"] ?? .null)
                let previousOwnerEmail = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["previous_owner_email"] ?? .null)
                return SharedFolderTransferOwnershipDetails(newOwnerEmail: newOwnerEmail, previousOwnerEmail: previousOwnerEmail)
            default:
                throw JSONSerializerError.deserializeError(type: SharedFolderTransferOwnershipDetails.self, json: json)
            }
        }
    }

    /// The SharedFolderTransferOwnershipType struct
    public class SharedFolderTransferOwnershipType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try SharedFolderTransferOwnershipTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharedFolderTransferOwnershipTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharedFolderTransferOwnershipType: \(error)"
            }
        }
    }

    public class SharedFolderTransferOwnershipTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharedFolderTransferOwnershipType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharedFolderTransferOwnershipType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return SharedFolderTransferOwnershipType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: SharedFolderTransferOwnershipType.self, json: json)
            }
        }
    }

    /// Deleted shared folder from Dropbox.
    public class SharedFolderUnmountDetails: CustomStringConvertible, JSONRepresentable {
        func json() throws -> JSON {
            try SharedFolderUnmountDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharedFolderUnmountDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharedFolderUnmountDetails: \(error)"
            }
        }
    }

    public class SharedFolderUnmountDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharedFolderUnmountDetails) throws -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharedFolderUnmountDetails {
            switch json {
            case .dictionary:
                return SharedFolderUnmountDetails()
            default:
                throw JSONSerializerError.deserializeError(type: SharedFolderUnmountDetails.self, json: json)
            }
        }
    }

    /// The SharedFolderUnmountType struct
    public class SharedFolderUnmountType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try SharedFolderUnmountTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharedFolderUnmountTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharedFolderUnmountType: \(error)"
            }
        }
    }

    public class SharedFolderUnmountTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharedFolderUnmountType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharedFolderUnmountType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return SharedFolderUnmountType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: SharedFolderUnmountType.self, json: json)
            }
        }
    }

    /// Shared link access level.
    public enum SharedLinkAccessLevel: CustomStringConvertible, JSONRepresentable {
        /// An unspecified error.
        case none
        /// An unspecified error.
        case reader
        /// An unspecified error.
        case writer
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try SharedLinkAccessLevelSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharedLinkAccessLevelSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharedLinkAccessLevel: \(error)"
            }
        }
    }

    public class SharedLinkAccessLevelSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharedLinkAccessLevel) throws -> JSON {
            switch value {
            case .none:
                var d = [String: JSON]()
                d[".tag"] = .str("none")
                return .dictionary(d)
            case .reader:
                var d = [String: JSON]()
                d[".tag"] = .str("reader")
                return .dictionary(d)
            case .writer:
                var d = [String: JSON]()
                d[".tag"] = .str("writer")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> SharedLinkAccessLevel {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "none":
                    return SharedLinkAccessLevel.none
                case "reader":
                    return SharedLinkAccessLevel.reader
                case "writer":
                    return SharedLinkAccessLevel.writer
                case "other":
                    return SharedLinkAccessLevel.other
                default:
                    return SharedLinkAccessLevel.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: SharedLinkAccessLevel.self, json: json)
            }
        }
    }

    /// Added shared link expiration date.
    public class SharedLinkAddExpiryDetails: CustomStringConvertible, JSONRepresentable {
        /// New shared link expiration date.
        public let newValue: Date
        public init(newValue: Date) {
            self.newValue = newValue
        }

        func json() throws -> JSON {
            try SharedLinkAddExpiryDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharedLinkAddExpiryDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharedLinkAddExpiryDetails: \(error)"
            }
        }
    }

    public class SharedLinkAddExpiryDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharedLinkAddExpiryDetails) throws -> JSON {
            let output = [
                "new_value": try NSDateSerializer("%Y-%m-%dT%H:%M:%SZ").serialize(value.newValue),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharedLinkAddExpiryDetails {
            switch json {
            case .dictionary(let dict):
                let newValue = try NSDateSerializer("%Y-%m-%dT%H:%M:%SZ").deserialize(dict["new_value"] ?? .null)
                return SharedLinkAddExpiryDetails(newValue: newValue)
            default:
                throw JSONSerializerError.deserializeError(type: SharedLinkAddExpiryDetails.self, json: json)
            }
        }
    }

    /// The SharedLinkAddExpiryType struct
    public class SharedLinkAddExpiryType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try SharedLinkAddExpiryTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharedLinkAddExpiryTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharedLinkAddExpiryType: \(error)"
            }
        }
    }

    public class SharedLinkAddExpiryTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharedLinkAddExpiryType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharedLinkAddExpiryType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return SharedLinkAddExpiryType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: SharedLinkAddExpiryType.self, json: json)
            }
        }
    }

    /// Changed shared link expiration date.
    public class SharedLinkChangeExpiryDetails: CustomStringConvertible, JSONRepresentable {
        /// New shared link expiration date. Might be missing due to historical data gap.
        public let newValue: Date?
        /// Previous shared link expiration date. Might be missing due to historical data gap.
        public let previousValue: Date?
        public init(newValue: Date? = nil, previousValue: Date? = nil) {
            self.newValue = newValue
            self.previousValue = previousValue
        }

        func json() throws -> JSON {
            try SharedLinkChangeExpiryDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharedLinkChangeExpiryDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharedLinkChangeExpiryDetails: \(error)"
            }
        }
    }

    public class SharedLinkChangeExpiryDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharedLinkChangeExpiryDetails) throws -> JSON {
            let output = [
                "new_value": try NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.newValue),
                "previous_value": try NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.previousValue),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharedLinkChangeExpiryDetails {
            switch json {
            case .dictionary(let dict):
                let newValue = try NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).deserialize(dict["new_value"] ?? .null)
                let previousValue = try NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).deserialize(dict["previous_value"] ?? .null)
                return SharedLinkChangeExpiryDetails(newValue: newValue, previousValue: previousValue)
            default:
                throw JSONSerializerError.deserializeError(type: SharedLinkChangeExpiryDetails.self, json: json)
            }
        }
    }

    /// The SharedLinkChangeExpiryType struct
    public class SharedLinkChangeExpiryType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try SharedLinkChangeExpiryTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharedLinkChangeExpiryTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharedLinkChangeExpiryType: \(error)"
            }
        }
    }

    public class SharedLinkChangeExpiryTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharedLinkChangeExpiryType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharedLinkChangeExpiryType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return SharedLinkChangeExpiryType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: SharedLinkChangeExpiryType.self, json: json)
            }
        }
    }

    /// Changed visibility of shared link.
    public class SharedLinkChangeVisibilityDetails: CustomStringConvertible, JSONRepresentable {
        /// New shared link visibility.
        public let newValue: TeamLog.SharedLinkVisibility
        /// Previous shared link visibility. Might be missing due to historical data gap.
        public let previousValue: TeamLog.SharedLinkVisibility?
        public init(newValue: TeamLog.SharedLinkVisibility, previousValue: TeamLog.SharedLinkVisibility? = nil) {
            self.newValue = newValue
            self.previousValue = previousValue
        }

        func json() throws -> JSON {
            try SharedLinkChangeVisibilityDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharedLinkChangeVisibilityDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharedLinkChangeVisibilityDetails: \(error)"
            }
        }
    }

    public class SharedLinkChangeVisibilityDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharedLinkChangeVisibilityDetails) throws -> JSON {
            let output = [
                "new_value": try TeamLog.SharedLinkVisibilitySerializer().serialize(value.newValue),
                "previous_value": try NullableSerializer(TeamLog.SharedLinkVisibilitySerializer()).serialize(value.previousValue),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharedLinkChangeVisibilityDetails {
            switch json {
            case .dictionary(let dict):
                let newValue = try TeamLog.SharedLinkVisibilitySerializer().deserialize(dict["new_value"] ?? .null)
                let previousValue = try NullableSerializer(TeamLog.SharedLinkVisibilitySerializer()).deserialize(dict["previous_value"] ?? .null)
                return SharedLinkChangeVisibilityDetails(newValue: newValue, previousValue: previousValue)
            default:
                throw JSONSerializerError.deserializeError(type: SharedLinkChangeVisibilityDetails.self, json: json)
            }
        }
    }

    /// The SharedLinkChangeVisibilityType struct
    public class SharedLinkChangeVisibilityType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try SharedLinkChangeVisibilityTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharedLinkChangeVisibilityTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharedLinkChangeVisibilityType: \(error)"
            }
        }
    }

    public class SharedLinkChangeVisibilityTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharedLinkChangeVisibilityType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharedLinkChangeVisibilityType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return SharedLinkChangeVisibilityType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: SharedLinkChangeVisibilityType.self, json: json)
            }
        }
    }

    /// Added file/folder to Dropbox from shared link.
    public class SharedLinkCopyDetails: CustomStringConvertible, JSONRepresentable {
        /// Shared link owner details. Might be missing due to historical data gap.
        public let sharedLinkOwner: TeamLog.UserLogInfo?
        public init(sharedLinkOwner: TeamLog.UserLogInfo? = nil) {
            self.sharedLinkOwner = sharedLinkOwner
        }

        func json() throws -> JSON {
            try SharedLinkCopyDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharedLinkCopyDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharedLinkCopyDetails: \(error)"
            }
        }
    }

    public class SharedLinkCopyDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharedLinkCopyDetails) throws -> JSON {
            let output = [
                "shared_link_owner": try NullableSerializer(TeamLog.UserLogInfoSerializer()).serialize(value.sharedLinkOwner),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharedLinkCopyDetails {
            switch json {
            case .dictionary(let dict):
                let sharedLinkOwner = try NullableSerializer(TeamLog.UserLogInfoSerializer()).deserialize(dict["shared_link_owner"] ?? .null)
                return SharedLinkCopyDetails(sharedLinkOwner: sharedLinkOwner)
            default:
                throw JSONSerializerError.deserializeError(type: SharedLinkCopyDetails.self, json: json)
            }
        }
    }

    /// The SharedLinkCopyType struct
    public class SharedLinkCopyType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try SharedLinkCopyTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharedLinkCopyTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharedLinkCopyType: \(error)"
            }
        }
    }

    public class SharedLinkCopyTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharedLinkCopyType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharedLinkCopyType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return SharedLinkCopyType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: SharedLinkCopyType.self, json: json)
            }
        }
    }

    /// Created shared link.
    public class SharedLinkCreateDetails: CustomStringConvertible, JSONRepresentable {
        /// Defines who can access the shared link. Might be missing due to historical data gap.
        public let sharedLinkAccessLevel: TeamLog.SharedLinkAccessLevel?
        public init(sharedLinkAccessLevel: TeamLog.SharedLinkAccessLevel? = nil) {
            self.sharedLinkAccessLevel = sharedLinkAccessLevel
        }

        func json() throws -> JSON {
            try SharedLinkCreateDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharedLinkCreateDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharedLinkCreateDetails: \(error)"
            }
        }
    }

    public class SharedLinkCreateDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharedLinkCreateDetails) throws -> JSON {
            let output = [
                "shared_link_access_level": try NullableSerializer(TeamLog.SharedLinkAccessLevelSerializer()).serialize(value.sharedLinkAccessLevel),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharedLinkCreateDetails {
            switch json {
            case .dictionary(let dict):
                let sharedLinkAccessLevel = try NullableSerializer(TeamLog.SharedLinkAccessLevelSerializer())
                    .deserialize(dict["shared_link_access_level"] ?? .null)
                return SharedLinkCreateDetails(sharedLinkAccessLevel: sharedLinkAccessLevel)
            default:
                throw JSONSerializerError.deserializeError(type: SharedLinkCreateDetails.self, json: json)
            }
        }
    }

    /// The SharedLinkCreateType struct
    public class SharedLinkCreateType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try SharedLinkCreateTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharedLinkCreateTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharedLinkCreateType: \(error)"
            }
        }
    }

    public class SharedLinkCreateTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharedLinkCreateType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharedLinkCreateType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return SharedLinkCreateType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: SharedLinkCreateType.self, json: json)
            }
        }
    }

    /// Removed shared link.
    public class SharedLinkDisableDetails: CustomStringConvertible, JSONRepresentable {
        /// Shared link owner details. Might be missing due to historical data gap.
        public let sharedLinkOwner: TeamLog.UserLogInfo?
        public init(sharedLinkOwner: TeamLog.UserLogInfo? = nil) {
            self.sharedLinkOwner = sharedLinkOwner
        }

        func json() throws -> JSON {
            try SharedLinkDisableDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharedLinkDisableDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharedLinkDisableDetails: \(error)"
            }
        }
    }

    public class SharedLinkDisableDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharedLinkDisableDetails) throws -> JSON {
            let output = [
                "shared_link_owner": try NullableSerializer(TeamLog.UserLogInfoSerializer()).serialize(value.sharedLinkOwner),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharedLinkDisableDetails {
            switch json {
            case .dictionary(let dict):
                let sharedLinkOwner = try NullableSerializer(TeamLog.UserLogInfoSerializer()).deserialize(dict["shared_link_owner"] ?? .null)
                return SharedLinkDisableDetails(sharedLinkOwner: sharedLinkOwner)
            default:
                throw JSONSerializerError.deserializeError(type: SharedLinkDisableDetails.self, json: json)
            }
        }
    }

    /// The SharedLinkDisableType struct
    public class SharedLinkDisableType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try SharedLinkDisableTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharedLinkDisableTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharedLinkDisableType: \(error)"
            }
        }
    }

    public class SharedLinkDisableTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharedLinkDisableType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharedLinkDisableType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return SharedLinkDisableType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: SharedLinkDisableType.self, json: json)
            }
        }
    }

    /// Downloaded file/folder from shared link.
    public class SharedLinkDownloadDetails: CustomStringConvertible, JSONRepresentable {
        /// Shared link owner details. Might be missing due to historical data gap.
        public let sharedLinkOwner: TeamLog.UserLogInfo?
        public init(sharedLinkOwner: TeamLog.UserLogInfo? = nil) {
            self.sharedLinkOwner = sharedLinkOwner
        }

        func json() throws -> JSON {
            try SharedLinkDownloadDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharedLinkDownloadDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharedLinkDownloadDetails: \(error)"
            }
        }
    }

    public class SharedLinkDownloadDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharedLinkDownloadDetails) throws -> JSON {
            let output = [
                "shared_link_owner": try NullableSerializer(TeamLog.UserLogInfoSerializer()).serialize(value.sharedLinkOwner),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharedLinkDownloadDetails {
            switch json {
            case .dictionary(let dict):
                let sharedLinkOwner = try NullableSerializer(TeamLog.UserLogInfoSerializer()).deserialize(dict["shared_link_owner"] ?? .null)
                return SharedLinkDownloadDetails(sharedLinkOwner: sharedLinkOwner)
            default:
                throw JSONSerializerError.deserializeError(type: SharedLinkDownloadDetails.self, json: json)
            }
        }
    }

    /// The SharedLinkDownloadType struct
    public class SharedLinkDownloadType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try SharedLinkDownloadTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharedLinkDownloadTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharedLinkDownloadType: \(error)"
            }
        }
    }

    public class SharedLinkDownloadTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharedLinkDownloadType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharedLinkDownloadType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return SharedLinkDownloadType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: SharedLinkDownloadType.self, json: json)
            }
        }
    }

    /// Removed shared link expiration date.
    public class SharedLinkRemoveExpiryDetails: CustomStringConvertible, JSONRepresentable {
        /// Previous shared link expiration date. Might be missing due to historical data gap.
        public let previousValue: Date?
        public init(previousValue: Date? = nil) {
            self.previousValue = previousValue
        }

        func json() throws -> JSON {
            try SharedLinkRemoveExpiryDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharedLinkRemoveExpiryDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharedLinkRemoveExpiryDetails: \(error)"
            }
        }
    }

    public class SharedLinkRemoveExpiryDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharedLinkRemoveExpiryDetails) throws -> JSON {
            let output = [
                "previous_value": try NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.previousValue),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharedLinkRemoveExpiryDetails {
            switch json {
            case .dictionary(let dict):
                let previousValue = try NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).deserialize(dict["previous_value"] ?? .null)
                return SharedLinkRemoveExpiryDetails(previousValue: previousValue)
            default:
                throw JSONSerializerError.deserializeError(type: SharedLinkRemoveExpiryDetails.self, json: json)
            }
        }
    }

    /// The SharedLinkRemoveExpiryType struct
    public class SharedLinkRemoveExpiryType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try SharedLinkRemoveExpiryTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharedLinkRemoveExpiryTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharedLinkRemoveExpiryType: \(error)"
            }
        }
    }

    public class SharedLinkRemoveExpiryTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharedLinkRemoveExpiryType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharedLinkRemoveExpiryType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return SharedLinkRemoveExpiryType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: SharedLinkRemoveExpiryType.self, json: json)
            }
        }
    }

    /// Added an expiration date to the shared link.
    public class SharedLinkSettingsAddExpirationDetails: CustomStringConvertible, JSONRepresentable {
        /// Shared content access level.
        public let sharedContentAccessLevel: Sharing.AccessLevel
        /// Shared content link.
        public let sharedContentLink: String?
        /// New shared content link expiration date. Might be missing due to historical data gap.
        public let newValue: Date?
        public init(sharedContentAccessLevel: Sharing.AccessLevel, sharedContentLink: String? = nil, newValue: Date? = nil) {
            self.sharedContentAccessLevel = sharedContentAccessLevel
            nullableValidator(stringValidator())(sharedContentLink)
            self.sharedContentLink = sharedContentLink
            self.newValue = newValue
        }

        func json() throws -> JSON {
            try SharedLinkSettingsAddExpirationDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharedLinkSettingsAddExpirationDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharedLinkSettingsAddExpirationDetails: \(error)"
            }
        }
    }

    public class SharedLinkSettingsAddExpirationDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharedLinkSettingsAddExpirationDetails) throws -> JSON {
            let output = [
                "shared_content_access_level": try Sharing.AccessLevelSerializer().serialize(value.sharedContentAccessLevel),
                "shared_content_link": try NullableSerializer(Serialization._StringSerializer).serialize(value.sharedContentLink),
                "new_value": try NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.newValue),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharedLinkSettingsAddExpirationDetails {
            switch json {
            case .dictionary(let dict):
                let sharedContentAccessLevel = try Sharing.AccessLevelSerializer().deserialize(dict["shared_content_access_level"] ?? .null)
                let sharedContentLink = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["shared_content_link"] ?? .null)
                let newValue = try NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).deserialize(dict["new_value"] ?? .null)
                return SharedLinkSettingsAddExpirationDetails(
                    sharedContentAccessLevel: sharedContentAccessLevel,
                    sharedContentLink: sharedContentLink,
                    newValue: newValue
                )
            default:
                throw JSONSerializerError.deserializeError(type: SharedLinkSettingsAddExpirationDetails.self, json: json)
            }
        }
    }

    /// The SharedLinkSettingsAddExpirationType struct
    public class SharedLinkSettingsAddExpirationType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try SharedLinkSettingsAddExpirationTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharedLinkSettingsAddExpirationTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharedLinkSettingsAddExpirationType: \(error)"
            }
        }
    }

    public class SharedLinkSettingsAddExpirationTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharedLinkSettingsAddExpirationType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharedLinkSettingsAddExpirationType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return SharedLinkSettingsAddExpirationType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: SharedLinkSettingsAddExpirationType.self, json: json)
            }
        }
    }

    /// Added a password to the shared link.
    public class SharedLinkSettingsAddPasswordDetails: CustomStringConvertible, JSONRepresentable {
        /// Shared content access level.
        public let sharedContentAccessLevel: Sharing.AccessLevel
        /// Shared content link.
        public let sharedContentLink: String?
        public init(sharedContentAccessLevel: Sharing.AccessLevel, sharedContentLink: String? = nil) {
            self.sharedContentAccessLevel = sharedContentAccessLevel
            nullableValidator(stringValidator())(sharedContentLink)
            self.sharedContentLink = sharedContentLink
        }

        func json() throws -> JSON {
            try SharedLinkSettingsAddPasswordDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharedLinkSettingsAddPasswordDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharedLinkSettingsAddPasswordDetails: \(error)"
            }
        }
    }

    public class SharedLinkSettingsAddPasswordDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharedLinkSettingsAddPasswordDetails) throws -> JSON {
            let output = [
                "shared_content_access_level": try Sharing.AccessLevelSerializer().serialize(value.sharedContentAccessLevel),
                "shared_content_link": try NullableSerializer(Serialization._StringSerializer).serialize(value.sharedContentLink),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharedLinkSettingsAddPasswordDetails {
            switch json {
            case .dictionary(let dict):
                let sharedContentAccessLevel = try Sharing.AccessLevelSerializer().deserialize(dict["shared_content_access_level"] ?? .null)
                let sharedContentLink = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["shared_content_link"] ?? .null)
                return SharedLinkSettingsAddPasswordDetails(sharedContentAccessLevel: sharedContentAccessLevel, sharedContentLink: sharedContentLink)
            default:
                throw JSONSerializerError.deserializeError(type: SharedLinkSettingsAddPasswordDetails.self, json: json)
            }
        }
    }

    /// The SharedLinkSettingsAddPasswordType struct
    public class SharedLinkSettingsAddPasswordType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try SharedLinkSettingsAddPasswordTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharedLinkSettingsAddPasswordTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharedLinkSettingsAddPasswordType: \(error)"
            }
        }
    }

    public class SharedLinkSettingsAddPasswordTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharedLinkSettingsAddPasswordType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharedLinkSettingsAddPasswordType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return SharedLinkSettingsAddPasswordType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: SharedLinkSettingsAddPasswordType.self, json: json)
            }
        }
    }

    /// Disabled downloads.
    public class SharedLinkSettingsAllowDownloadDisabledDetails: CustomStringConvertible, JSONRepresentable {
        /// Shared content access level.
        public let sharedContentAccessLevel: Sharing.AccessLevel
        /// Shared content link.
        public let sharedContentLink: String?
        public init(sharedContentAccessLevel: Sharing.AccessLevel, sharedContentLink: String? = nil) {
            self.sharedContentAccessLevel = sharedContentAccessLevel
            nullableValidator(stringValidator())(sharedContentLink)
            self.sharedContentLink = sharedContentLink
        }

        func json() throws -> JSON {
            try SharedLinkSettingsAllowDownloadDisabledDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharedLinkSettingsAllowDownloadDisabledDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharedLinkSettingsAllowDownloadDisabledDetails: \(error)"
            }
        }
    }

    public class SharedLinkSettingsAllowDownloadDisabledDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharedLinkSettingsAllowDownloadDisabledDetails) throws -> JSON {
            let output = [
                "shared_content_access_level": try Sharing.AccessLevelSerializer().serialize(value.sharedContentAccessLevel),
                "shared_content_link": try NullableSerializer(Serialization._StringSerializer).serialize(value.sharedContentLink),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharedLinkSettingsAllowDownloadDisabledDetails {
            switch json {
            case .dictionary(let dict):
                let sharedContentAccessLevel = try Sharing.AccessLevelSerializer().deserialize(dict["shared_content_access_level"] ?? .null)
                let sharedContentLink = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["shared_content_link"] ?? .null)
                return SharedLinkSettingsAllowDownloadDisabledDetails(
                    sharedContentAccessLevel: sharedContentAccessLevel,
                    sharedContentLink: sharedContentLink
                )
            default:
                throw JSONSerializerError.deserializeError(type: SharedLinkSettingsAllowDownloadDisabledDetails.self, json: json)
            }
        }
    }

    /// The SharedLinkSettingsAllowDownloadDisabledType struct
    public class SharedLinkSettingsAllowDownloadDisabledType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try SharedLinkSettingsAllowDownloadDisabledTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharedLinkSettingsAllowDownloadDisabledTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharedLinkSettingsAllowDownloadDisabledType: \(error)"
            }
        }
    }

    public class SharedLinkSettingsAllowDownloadDisabledTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharedLinkSettingsAllowDownloadDisabledType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharedLinkSettingsAllowDownloadDisabledType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return SharedLinkSettingsAllowDownloadDisabledType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: SharedLinkSettingsAllowDownloadDisabledType.self, json: json)
            }
        }
    }

    /// Enabled downloads.
    public class SharedLinkSettingsAllowDownloadEnabledDetails: CustomStringConvertible, JSONRepresentable {
        /// Shared content access level.
        public let sharedContentAccessLevel: Sharing.AccessLevel
        /// Shared content link.
        public let sharedContentLink: String?
        public init(sharedContentAccessLevel: Sharing.AccessLevel, sharedContentLink: String? = nil) {
            self.sharedContentAccessLevel = sharedContentAccessLevel
            nullableValidator(stringValidator())(sharedContentLink)
            self.sharedContentLink = sharedContentLink
        }

        func json() throws -> JSON {
            try SharedLinkSettingsAllowDownloadEnabledDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharedLinkSettingsAllowDownloadEnabledDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharedLinkSettingsAllowDownloadEnabledDetails: \(error)"
            }
        }
    }

    public class SharedLinkSettingsAllowDownloadEnabledDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharedLinkSettingsAllowDownloadEnabledDetails) throws -> JSON {
            let output = [
                "shared_content_access_level": try Sharing.AccessLevelSerializer().serialize(value.sharedContentAccessLevel),
                "shared_content_link": try NullableSerializer(Serialization._StringSerializer).serialize(value.sharedContentLink),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharedLinkSettingsAllowDownloadEnabledDetails {
            switch json {
            case .dictionary(let dict):
                let sharedContentAccessLevel = try Sharing.AccessLevelSerializer().deserialize(dict["shared_content_access_level"] ?? .null)
                let sharedContentLink = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["shared_content_link"] ?? .null)
                return SharedLinkSettingsAllowDownloadEnabledDetails(
                    sharedContentAccessLevel: sharedContentAccessLevel,
                    sharedContentLink: sharedContentLink
                )
            default:
                throw JSONSerializerError.deserializeError(type: SharedLinkSettingsAllowDownloadEnabledDetails.self, json: json)
            }
        }
    }

    /// The SharedLinkSettingsAllowDownloadEnabledType struct
    public class SharedLinkSettingsAllowDownloadEnabledType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try SharedLinkSettingsAllowDownloadEnabledTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharedLinkSettingsAllowDownloadEnabledTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharedLinkSettingsAllowDownloadEnabledType: \(error)"
            }
        }
    }

    public class SharedLinkSettingsAllowDownloadEnabledTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharedLinkSettingsAllowDownloadEnabledType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharedLinkSettingsAllowDownloadEnabledType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return SharedLinkSettingsAllowDownloadEnabledType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: SharedLinkSettingsAllowDownloadEnabledType.self, json: json)
            }
        }
    }

    /// Changed the audience of the shared link.
    public class SharedLinkSettingsChangeAudienceDetails: CustomStringConvertible, JSONRepresentable {
        /// Shared content access level.
        public let sharedContentAccessLevel: Sharing.AccessLevel
        /// Shared content link.
        public let sharedContentLink: String?
        /// New link audience value.
        public let newValue: Sharing.LinkAudience
        /// Previous link audience value.
        public let previousValue: Sharing.LinkAudience?
        public init(
            sharedContentAccessLevel: Sharing.AccessLevel,
            newValue: Sharing.LinkAudience,
            sharedContentLink: String? = nil,
            previousValue: Sharing.LinkAudience? = nil
        ) {
            self.sharedContentAccessLevel = sharedContentAccessLevel
            nullableValidator(stringValidator())(sharedContentLink)
            self.sharedContentLink = sharedContentLink
            self.newValue = newValue
            self.previousValue = previousValue
        }

        func json() throws -> JSON {
            try SharedLinkSettingsChangeAudienceDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharedLinkSettingsChangeAudienceDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharedLinkSettingsChangeAudienceDetails: \(error)"
            }
        }
    }

    public class SharedLinkSettingsChangeAudienceDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharedLinkSettingsChangeAudienceDetails) throws -> JSON {
            let output = [
                "shared_content_access_level": try Sharing.AccessLevelSerializer().serialize(value.sharedContentAccessLevel),
                "new_value": try Sharing.LinkAudienceSerializer().serialize(value.newValue),
                "shared_content_link": try NullableSerializer(Serialization._StringSerializer).serialize(value.sharedContentLink),
                "previous_value": try NullableSerializer(Sharing.LinkAudienceSerializer()).serialize(value.previousValue),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharedLinkSettingsChangeAudienceDetails {
            switch json {
            case .dictionary(let dict):
                let sharedContentAccessLevel = try Sharing.AccessLevelSerializer().deserialize(dict["shared_content_access_level"] ?? .null)
                let newValue = try Sharing.LinkAudienceSerializer().deserialize(dict["new_value"] ?? .null)
                let sharedContentLink = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["shared_content_link"] ?? .null)
                let previousValue = try NullableSerializer(Sharing.LinkAudienceSerializer()).deserialize(dict["previous_value"] ?? .null)
                return SharedLinkSettingsChangeAudienceDetails(
                    sharedContentAccessLevel: sharedContentAccessLevel,
                    newValue: newValue,
                    sharedContentLink: sharedContentLink,
                    previousValue: previousValue
                )
            default:
                throw JSONSerializerError.deserializeError(type: SharedLinkSettingsChangeAudienceDetails.self, json: json)
            }
        }
    }

    /// The SharedLinkSettingsChangeAudienceType struct
    public class SharedLinkSettingsChangeAudienceType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try SharedLinkSettingsChangeAudienceTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharedLinkSettingsChangeAudienceTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharedLinkSettingsChangeAudienceType: \(error)"
            }
        }
    }

    public class SharedLinkSettingsChangeAudienceTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharedLinkSettingsChangeAudienceType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharedLinkSettingsChangeAudienceType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return SharedLinkSettingsChangeAudienceType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: SharedLinkSettingsChangeAudienceType.self, json: json)
            }
        }
    }

    /// Changed the expiration date of the shared link.
    public class SharedLinkSettingsChangeExpirationDetails: CustomStringConvertible, JSONRepresentable {
        /// Shared content access level.
        public let sharedContentAccessLevel: Sharing.AccessLevel
        /// Shared content link.
        public let sharedContentLink: String?
        /// New shared content link expiration date. Might be missing due to historical data gap.
        public let newValue: Date?
        /// Previous shared content link expiration date. Might be missing due to historical data gap.
        public let previousValue: Date?
        public init(sharedContentAccessLevel: Sharing.AccessLevel, sharedContentLink: String? = nil, newValue: Date? = nil, previousValue: Date? = nil) {
            self.sharedContentAccessLevel = sharedContentAccessLevel
            nullableValidator(stringValidator())(sharedContentLink)
            self.sharedContentLink = sharedContentLink
            self.newValue = newValue
            self.previousValue = previousValue
        }

        func json() throws -> JSON {
            try SharedLinkSettingsChangeExpirationDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharedLinkSettingsChangeExpirationDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharedLinkSettingsChangeExpirationDetails: \(error)"
            }
        }
    }

    public class SharedLinkSettingsChangeExpirationDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharedLinkSettingsChangeExpirationDetails) throws -> JSON {
            let output = [
                "shared_content_access_level": try Sharing.AccessLevelSerializer().serialize(value.sharedContentAccessLevel),
                "shared_content_link": try NullableSerializer(Serialization._StringSerializer).serialize(value.sharedContentLink),
                "new_value": try NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.newValue),
                "previous_value": try NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.previousValue),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharedLinkSettingsChangeExpirationDetails {
            switch json {
            case .dictionary(let dict):
                let sharedContentAccessLevel = try Sharing.AccessLevelSerializer().deserialize(dict["shared_content_access_level"] ?? .null)
                let sharedContentLink = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["shared_content_link"] ?? .null)
                let newValue = try NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).deserialize(dict["new_value"] ?? .null)
                let previousValue = try NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).deserialize(dict["previous_value"] ?? .null)
                return SharedLinkSettingsChangeExpirationDetails(
                    sharedContentAccessLevel: sharedContentAccessLevel,
                    sharedContentLink: sharedContentLink,
                    newValue: newValue,
                    previousValue: previousValue
                )
            default:
                throw JSONSerializerError.deserializeError(type: SharedLinkSettingsChangeExpirationDetails.self, json: json)
            }
        }
    }

    /// The SharedLinkSettingsChangeExpirationType struct
    public class SharedLinkSettingsChangeExpirationType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try SharedLinkSettingsChangeExpirationTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharedLinkSettingsChangeExpirationTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharedLinkSettingsChangeExpirationType: \(error)"
            }
        }
    }

    public class SharedLinkSettingsChangeExpirationTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharedLinkSettingsChangeExpirationType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharedLinkSettingsChangeExpirationType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return SharedLinkSettingsChangeExpirationType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: SharedLinkSettingsChangeExpirationType.self, json: json)
            }
        }
    }

    /// Changed the password of the shared link.
    public class SharedLinkSettingsChangePasswordDetails: CustomStringConvertible, JSONRepresentable {
        /// Shared content access level.
        public let sharedContentAccessLevel: Sharing.AccessLevel
        /// Shared content link.
        public let sharedContentLink: String?
        public init(sharedContentAccessLevel: Sharing.AccessLevel, sharedContentLink: String? = nil) {
            self.sharedContentAccessLevel = sharedContentAccessLevel
            nullableValidator(stringValidator())(sharedContentLink)
            self.sharedContentLink = sharedContentLink
        }

        func json() throws -> JSON {
            try SharedLinkSettingsChangePasswordDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharedLinkSettingsChangePasswordDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharedLinkSettingsChangePasswordDetails: \(error)"
            }
        }
    }

    public class SharedLinkSettingsChangePasswordDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharedLinkSettingsChangePasswordDetails) throws -> JSON {
            let output = [
                "shared_content_access_level": try Sharing.AccessLevelSerializer().serialize(value.sharedContentAccessLevel),
                "shared_content_link": try NullableSerializer(Serialization._StringSerializer).serialize(value.sharedContentLink),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharedLinkSettingsChangePasswordDetails {
            switch json {
            case .dictionary(let dict):
                let sharedContentAccessLevel = try Sharing.AccessLevelSerializer().deserialize(dict["shared_content_access_level"] ?? .null)
                let sharedContentLink = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["shared_content_link"] ?? .null)
                return SharedLinkSettingsChangePasswordDetails(sharedContentAccessLevel: sharedContentAccessLevel, sharedContentLink: sharedContentLink)
            default:
                throw JSONSerializerError.deserializeError(type: SharedLinkSettingsChangePasswordDetails.self, json: json)
            }
        }
    }

    /// The SharedLinkSettingsChangePasswordType struct
    public class SharedLinkSettingsChangePasswordType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try SharedLinkSettingsChangePasswordTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharedLinkSettingsChangePasswordTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharedLinkSettingsChangePasswordType: \(error)"
            }
        }
    }

    public class SharedLinkSettingsChangePasswordTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharedLinkSettingsChangePasswordType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharedLinkSettingsChangePasswordType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return SharedLinkSettingsChangePasswordType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: SharedLinkSettingsChangePasswordType.self, json: json)
            }
        }
    }

    /// Removed the expiration date from the shared link.
    public class SharedLinkSettingsRemoveExpirationDetails: CustomStringConvertible, JSONRepresentable {
        /// Shared content access level.
        public let sharedContentAccessLevel: Sharing.AccessLevel
        /// Shared content link.
        public let sharedContentLink: String?
        /// Previous shared link expiration date. Might be missing due to historical data gap.
        public let previousValue: Date?
        public init(sharedContentAccessLevel: Sharing.AccessLevel, sharedContentLink: String? = nil, previousValue: Date? = nil) {
            self.sharedContentAccessLevel = sharedContentAccessLevel
            nullableValidator(stringValidator())(sharedContentLink)
            self.sharedContentLink = sharedContentLink
            self.previousValue = previousValue
        }

        func json() throws -> JSON {
            try SharedLinkSettingsRemoveExpirationDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharedLinkSettingsRemoveExpirationDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharedLinkSettingsRemoveExpirationDetails: \(error)"
            }
        }
    }

    public class SharedLinkSettingsRemoveExpirationDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharedLinkSettingsRemoveExpirationDetails) throws -> JSON {
            let output = [
                "shared_content_access_level": try Sharing.AccessLevelSerializer().serialize(value.sharedContentAccessLevel),
                "shared_content_link": try NullableSerializer(Serialization._StringSerializer).serialize(value.sharedContentLink),
                "previous_value": try NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.previousValue),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharedLinkSettingsRemoveExpirationDetails {
            switch json {
            case .dictionary(let dict):
                let sharedContentAccessLevel = try Sharing.AccessLevelSerializer().deserialize(dict["shared_content_access_level"] ?? .null)
                let sharedContentLink = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["shared_content_link"] ?? .null)
                let previousValue = try NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).deserialize(dict["previous_value"] ?? .null)
                return SharedLinkSettingsRemoveExpirationDetails(
                    sharedContentAccessLevel: sharedContentAccessLevel,
                    sharedContentLink: sharedContentLink,
                    previousValue: previousValue
                )
            default:
                throw JSONSerializerError.deserializeError(type: SharedLinkSettingsRemoveExpirationDetails.self, json: json)
            }
        }
    }

    /// The SharedLinkSettingsRemoveExpirationType struct
    public class SharedLinkSettingsRemoveExpirationType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try SharedLinkSettingsRemoveExpirationTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharedLinkSettingsRemoveExpirationTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharedLinkSettingsRemoveExpirationType: \(error)"
            }
        }
    }

    public class SharedLinkSettingsRemoveExpirationTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharedLinkSettingsRemoveExpirationType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharedLinkSettingsRemoveExpirationType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return SharedLinkSettingsRemoveExpirationType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: SharedLinkSettingsRemoveExpirationType.self, json: json)
            }
        }
    }

    /// Removed the password from the shared link.
    public class SharedLinkSettingsRemovePasswordDetails: CustomStringConvertible, JSONRepresentable {
        /// Shared content access level.
        public let sharedContentAccessLevel: Sharing.AccessLevel
        /// Shared content link.
        public let sharedContentLink: String?
        public init(sharedContentAccessLevel: Sharing.AccessLevel, sharedContentLink: String? = nil) {
            self.sharedContentAccessLevel = sharedContentAccessLevel
            nullableValidator(stringValidator())(sharedContentLink)
            self.sharedContentLink = sharedContentLink
        }

        func json() throws -> JSON {
            try SharedLinkSettingsRemovePasswordDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharedLinkSettingsRemovePasswordDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharedLinkSettingsRemovePasswordDetails: \(error)"
            }
        }
    }

    public class SharedLinkSettingsRemovePasswordDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharedLinkSettingsRemovePasswordDetails) throws -> JSON {
            let output = [
                "shared_content_access_level": try Sharing.AccessLevelSerializer().serialize(value.sharedContentAccessLevel),
                "shared_content_link": try NullableSerializer(Serialization._StringSerializer).serialize(value.sharedContentLink),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharedLinkSettingsRemovePasswordDetails {
            switch json {
            case .dictionary(let dict):
                let sharedContentAccessLevel = try Sharing.AccessLevelSerializer().deserialize(dict["shared_content_access_level"] ?? .null)
                let sharedContentLink = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["shared_content_link"] ?? .null)
                return SharedLinkSettingsRemovePasswordDetails(sharedContentAccessLevel: sharedContentAccessLevel, sharedContentLink: sharedContentLink)
            default:
                throw JSONSerializerError.deserializeError(type: SharedLinkSettingsRemovePasswordDetails.self, json: json)
            }
        }
    }

    /// The SharedLinkSettingsRemovePasswordType struct
    public class SharedLinkSettingsRemovePasswordType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try SharedLinkSettingsRemovePasswordTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharedLinkSettingsRemovePasswordTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharedLinkSettingsRemovePasswordType: \(error)"
            }
        }
    }

    public class SharedLinkSettingsRemovePasswordTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharedLinkSettingsRemovePasswordType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharedLinkSettingsRemovePasswordType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return SharedLinkSettingsRemovePasswordType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: SharedLinkSettingsRemovePasswordType.self, json: json)
            }
        }
    }

    /// Added members as audience of shared link.
    public class SharedLinkShareDetails: CustomStringConvertible, JSONRepresentable {
        /// Shared link owner details. Might be missing due to historical data gap.
        public let sharedLinkOwner: TeamLog.UserLogInfo?
        /// Users without a Dropbox account that were added as shared link audience.
        public let externalUsers: [TeamLog.ExternalUserLogInfo]?
        public init(sharedLinkOwner: TeamLog.UserLogInfo? = nil, externalUsers: [TeamLog.ExternalUserLogInfo]? = nil) {
            self.sharedLinkOwner = sharedLinkOwner
            self.externalUsers = externalUsers
        }

        func json() throws -> JSON {
            try SharedLinkShareDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharedLinkShareDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharedLinkShareDetails: \(error)"
            }
        }
    }

    public class SharedLinkShareDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharedLinkShareDetails) throws -> JSON {
            let output = [
                "shared_link_owner": try NullableSerializer(TeamLog.UserLogInfoSerializer()).serialize(value.sharedLinkOwner),
                "external_users": try NullableSerializer(ArraySerializer(TeamLog.ExternalUserLogInfoSerializer())).serialize(value.externalUsers),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharedLinkShareDetails {
            switch json {
            case .dictionary(let dict):
                let sharedLinkOwner = try NullableSerializer(TeamLog.UserLogInfoSerializer()).deserialize(dict["shared_link_owner"] ?? .null)
                let externalUsers = try NullableSerializer(ArraySerializer(TeamLog.ExternalUserLogInfoSerializer()))
                    .deserialize(dict["external_users"] ?? .null)
                return SharedLinkShareDetails(sharedLinkOwner: sharedLinkOwner, externalUsers: externalUsers)
            default:
                throw JSONSerializerError.deserializeError(type: SharedLinkShareDetails.self, json: json)
            }
        }
    }

    /// The SharedLinkShareType struct
    public class SharedLinkShareType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try SharedLinkShareTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharedLinkShareTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharedLinkShareType: \(error)"
            }
        }
    }

    public class SharedLinkShareTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharedLinkShareType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharedLinkShareType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return SharedLinkShareType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: SharedLinkShareType.self, json: json)
            }
        }
    }

    /// Opened shared link.
    public class SharedLinkViewDetails: CustomStringConvertible, JSONRepresentable {
        /// Shared link owner details. Might be missing due to historical data gap.
        public let sharedLinkOwner: TeamLog.UserLogInfo?
        public init(sharedLinkOwner: TeamLog.UserLogInfo? = nil) {
            self.sharedLinkOwner = sharedLinkOwner
        }

        func json() throws -> JSON {
            try SharedLinkViewDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharedLinkViewDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharedLinkViewDetails: \(error)"
            }
        }
    }

    public class SharedLinkViewDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharedLinkViewDetails) throws -> JSON {
            let output = [
                "shared_link_owner": try NullableSerializer(TeamLog.UserLogInfoSerializer()).serialize(value.sharedLinkOwner),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharedLinkViewDetails {
            switch json {
            case .dictionary(let dict):
                let sharedLinkOwner = try NullableSerializer(TeamLog.UserLogInfoSerializer()).deserialize(dict["shared_link_owner"] ?? .null)
                return SharedLinkViewDetails(sharedLinkOwner: sharedLinkOwner)
            default:
                throw JSONSerializerError.deserializeError(type: SharedLinkViewDetails.self, json: json)
            }
        }
    }

    /// The SharedLinkViewType struct
    public class SharedLinkViewType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try SharedLinkViewTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharedLinkViewTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharedLinkViewType: \(error)"
            }
        }
    }

    public class SharedLinkViewTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharedLinkViewType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharedLinkViewType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return SharedLinkViewType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: SharedLinkViewType.self, json: json)
            }
        }
    }

    /// Defines who has access to a shared link.
    public enum SharedLinkVisibility: CustomStringConvertible, JSONRepresentable {
        /// An unspecified error.
        case noOne
        /// An unspecified error.
        case password
        /// An unspecified error.
        case public_
        /// An unspecified error.
        case teamOnly
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try SharedLinkVisibilitySerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharedLinkVisibilitySerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharedLinkVisibility: \(error)"
            }
        }
    }

    public class SharedLinkVisibilitySerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharedLinkVisibility) throws -> JSON {
            switch value {
            case .noOne:
                var d = [String: JSON]()
                d[".tag"] = .str("no_one")
                return .dictionary(d)
            case .password:
                var d = [String: JSON]()
                d[".tag"] = .str("password")
                return .dictionary(d)
            case .public_:
                var d = [String: JSON]()
                d[".tag"] = .str("public")
                return .dictionary(d)
            case .teamOnly:
                var d = [String: JSON]()
                d[".tag"] = .str("team_only")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> SharedLinkVisibility {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "no_one":
                    return SharedLinkVisibility.noOne
                case "password":
                    return SharedLinkVisibility.password
                case "public":
                    return SharedLinkVisibility.public_
                case "team_only":
                    return SharedLinkVisibility.teamOnly
                case "other":
                    return SharedLinkVisibility.other
                default:
                    return SharedLinkVisibility.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: SharedLinkVisibility.self, json: json)
            }
        }
    }

    /// Opened shared Paper doc.
    public class SharedNoteOpenedDetails: CustomStringConvertible, JSONRepresentable {
        func json() throws -> JSON {
            try SharedNoteOpenedDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharedNoteOpenedDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharedNoteOpenedDetails: \(error)"
            }
        }
    }

    public class SharedNoteOpenedDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharedNoteOpenedDetails) throws -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharedNoteOpenedDetails {
            switch json {
            case .dictionary:
                return SharedNoteOpenedDetails()
            default:
                throw JSONSerializerError.deserializeError(type: SharedNoteOpenedDetails.self, json: json)
            }
        }
    }

    /// The SharedNoteOpenedType struct
    public class SharedNoteOpenedType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try SharedNoteOpenedTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharedNoteOpenedTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharedNoteOpenedType: \(error)"
            }
        }
    }

    public class SharedNoteOpenedTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharedNoteOpenedType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharedNoteOpenedType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return SharedNoteOpenedType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: SharedNoteOpenedType.self, json: json)
            }
        }
    }

    /// Changed whether team members can join shared folders owned outside team.
    public class SharingChangeFolderJoinPolicyDetails: CustomStringConvertible, JSONRepresentable {
        /// New external join policy.
        public let newValue: TeamLog.SharingFolderJoinPolicy
        /// Previous external join policy. Might be missing due to historical data gap.
        public let previousValue: TeamLog.SharingFolderJoinPolicy?
        public init(newValue: TeamLog.SharingFolderJoinPolicy, previousValue: TeamLog.SharingFolderJoinPolicy? = nil) {
            self.newValue = newValue
            self.previousValue = previousValue
        }

        func json() throws -> JSON {
            try SharingChangeFolderJoinPolicyDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharingChangeFolderJoinPolicyDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharingChangeFolderJoinPolicyDetails: \(error)"
            }
        }
    }

    public class SharingChangeFolderJoinPolicyDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharingChangeFolderJoinPolicyDetails) throws -> JSON {
            let output = [
                "new_value": try TeamLog.SharingFolderJoinPolicySerializer().serialize(value.newValue),
                "previous_value": try NullableSerializer(TeamLog.SharingFolderJoinPolicySerializer()).serialize(value.previousValue),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharingChangeFolderJoinPolicyDetails {
            switch json {
            case .dictionary(let dict):
                let newValue = try TeamLog.SharingFolderJoinPolicySerializer().deserialize(dict["new_value"] ?? .null)
                let previousValue = try NullableSerializer(TeamLog.SharingFolderJoinPolicySerializer()).deserialize(dict["previous_value"] ?? .null)
                return SharingChangeFolderJoinPolicyDetails(newValue: newValue, previousValue: previousValue)
            default:
                throw JSONSerializerError.deserializeError(type: SharingChangeFolderJoinPolicyDetails.self, json: json)
            }
        }
    }

    /// The SharingChangeFolderJoinPolicyType struct
    public class SharingChangeFolderJoinPolicyType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try SharingChangeFolderJoinPolicyTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharingChangeFolderJoinPolicyTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharingChangeFolderJoinPolicyType: \(error)"
            }
        }
    }

    public class SharingChangeFolderJoinPolicyTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharingChangeFolderJoinPolicyType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharingChangeFolderJoinPolicyType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return SharingChangeFolderJoinPolicyType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: SharingChangeFolderJoinPolicyType.self, json: json)
            }
        }
    }

    /// Changed the allow remove or change expiration policy for the links shared outside of the team.
    public class SharingChangeLinkAllowChangeExpirationPolicyDetails: CustomStringConvertible, JSONRepresentable {
        /// To.
        public let newValue: TeamLog.EnforceLinkPasswordPolicy
        /// From.
        public let previousValue: TeamLog.EnforceLinkPasswordPolicy?
        public init(newValue: TeamLog.EnforceLinkPasswordPolicy, previousValue: TeamLog.EnforceLinkPasswordPolicy? = nil) {
            self.newValue = newValue
            self.previousValue = previousValue
        }

        func json() throws -> JSON {
            try SharingChangeLinkAllowChangeExpirationPolicyDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharingChangeLinkAllowChangeExpirationPolicyDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharingChangeLinkAllowChangeExpirationPolicyDetails: \(error)"
            }
        }
    }

    public class SharingChangeLinkAllowChangeExpirationPolicyDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharingChangeLinkAllowChangeExpirationPolicyDetails) throws -> JSON {
            let output = [
                "new_value": try TeamLog.EnforceLinkPasswordPolicySerializer().serialize(value.newValue),
                "previous_value": try NullableSerializer(TeamLog.EnforceLinkPasswordPolicySerializer()).serialize(value.previousValue),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharingChangeLinkAllowChangeExpirationPolicyDetails {
            switch json {
            case .dictionary(let dict):
                let newValue = try TeamLog.EnforceLinkPasswordPolicySerializer().deserialize(dict["new_value"] ?? .null)
                let previousValue = try NullableSerializer(TeamLog.EnforceLinkPasswordPolicySerializer()).deserialize(dict["previous_value"] ?? .null)
                return SharingChangeLinkAllowChangeExpirationPolicyDetails(newValue: newValue, previousValue: previousValue)
            default:
                throw JSONSerializerError.deserializeError(type: SharingChangeLinkAllowChangeExpirationPolicyDetails.self, json: json)
            }
        }
    }

    /// The SharingChangeLinkAllowChangeExpirationPolicyType struct
    public class SharingChangeLinkAllowChangeExpirationPolicyType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try SharingChangeLinkAllowChangeExpirationPolicyTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharingChangeLinkAllowChangeExpirationPolicyTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharingChangeLinkAllowChangeExpirationPolicyType: \(error)"
            }
        }
    }

    public class SharingChangeLinkAllowChangeExpirationPolicyTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharingChangeLinkAllowChangeExpirationPolicyType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharingChangeLinkAllowChangeExpirationPolicyType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return SharingChangeLinkAllowChangeExpirationPolicyType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: SharingChangeLinkAllowChangeExpirationPolicyType.self, json: json)
            }
        }
    }

    /// Changed the default expiration for the links shared outside of the team.
    public class SharingChangeLinkDefaultExpirationPolicyDetails: CustomStringConvertible, JSONRepresentable {
        /// To.
        public let newValue: TeamLog.DefaultLinkExpirationDaysPolicy
        /// From.
        public let previousValue: TeamLog.DefaultLinkExpirationDaysPolicy?
        public init(newValue: TeamLog.DefaultLinkExpirationDaysPolicy, previousValue: TeamLog.DefaultLinkExpirationDaysPolicy? = nil) {
            self.newValue = newValue
            self.previousValue = previousValue
        }

        func json() throws -> JSON {
            try SharingChangeLinkDefaultExpirationPolicyDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharingChangeLinkDefaultExpirationPolicyDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharingChangeLinkDefaultExpirationPolicyDetails: \(error)"
            }
        }
    }

    public class SharingChangeLinkDefaultExpirationPolicyDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharingChangeLinkDefaultExpirationPolicyDetails) throws -> JSON {
            let output = [
                "new_value": try TeamLog.DefaultLinkExpirationDaysPolicySerializer().serialize(value.newValue),
                "previous_value": try NullableSerializer(TeamLog.DefaultLinkExpirationDaysPolicySerializer()).serialize(value.previousValue),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharingChangeLinkDefaultExpirationPolicyDetails {
            switch json {
            case .dictionary(let dict):
                let newValue = try TeamLog.DefaultLinkExpirationDaysPolicySerializer().deserialize(dict["new_value"] ?? .null)
                let previousValue = try NullableSerializer(TeamLog.DefaultLinkExpirationDaysPolicySerializer()).deserialize(dict["previous_value"] ?? .null)
                return SharingChangeLinkDefaultExpirationPolicyDetails(newValue: newValue, previousValue: previousValue)
            default:
                throw JSONSerializerError.deserializeError(type: SharingChangeLinkDefaultExpirationPolicyDetails.self, json: json)
            }
        }
    }

    /// The SharingChangeLinkDefaultExpirationPolicyType struct
    public class SharingChangeLinkDefaultExpirationPolicyType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try SharingChangeLinkDefaultExpirationPolicyTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharingChangeLinkDefaultExpirationPolicyTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharingChangeLinkDefaultExpirationPolicyType: \(error)"
            }
        }
    }

    public class SharingChangeLinkDefaultExpirationPolicyTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharingChangeLinkDefaultExpirationPolicyType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharingChangeLinkDefaultExpirationPolicyType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return SharingChangeLinkDefaultExpirationPolicyType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: SharingChangeLinkDefaultExpirationPolicyType.self, json: json)
            }
        }
    }

    /// Changed the password requirement for the links shared outside of the team.
    public class SharingChangeLinkEnforcePasswordPolicyDetails: CustomStringConvertible, JSONRepresentable {
        /// To.
        public let newValue: TeamLog.ChangeLinkExpirationPolicy
        /// From.
        public let previousValue: TeamLog.ChangeLinkExpirationPolicy?
        public init(newValue: TeamLog.ChangeLinkExpirationPolicy, previousValue: TeamLog.ChangeLinkExpirationPolicy? = nil) {
            self.newValue = newValue
            self.previousValue = previousValue
        }

        func json() throws -> JSON {
            try SharingChangeLinkEnforcePasswordPolicyDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharingChangeLinkEnforcePasswordPolicyDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharingChangeLinkEnforcePasswordPolicyDetails: \(error)"
            }
        }
    }

    public class SharingChangeLinkEnforcePasswordPolicyDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharingChangeLinkEnforcePasswordPolicyDetails) throws -> JSON {
            let output = [
                "new_value": try TeamLog.ChangeLinkExpirationPolicySerializer().serialize(value.newValue),
                "previous_value": try NullableSerializer(TeamLog.ChangeLinkExpirationPolicySerializer()).serialize(value.previousValue),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharingChangeLinkEnforcePasswordPolicyDetails {
            switch json {
            case .dictionary(let dict):
                let newValue = try TeamLog.ChangeLinkExpirationPolicySerializer().deserialize(dict["new_value"] ?? .null)
                let previousValue = try NullableSerializer(TeamLog.ChangeLinkExpirationPolicySerializer()).deserialize(dict["previous_value"] ?? .null)
                return SharingChangeLinkEnforcePasswordPolicyDetails(newValue: newValue, previousValue: previousValue)
            default:
                throw JSONSerializerError.deserializeError(type: SharingChangeLinkEnforcePasswordPolicyDetails.self, json: json)
            }
        }
    }

    /// The SharingChangeLinkEnforcePasswordPolicyType struct
    public class SharingChangeLinkEnforcePasswordPolicyType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try SharingChangeLinkEnforcePasswordPolicyTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharingChangeLinkEnforcePasswordPolicyTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharingChangeLinkEnforcePasswordPolicyType: \(error)"
            }
        }
    }

    public class SharingChangeLinkEnforcePasswordPolicyTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharingChangeLinkEnforcePasswordPolicyType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharingChangeLinkEnforcePasswordPolicyType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return SharingChangeLinkEnforcePasswordPolicyType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: SharingChangeLinkEnforcePasswordPolicyType.self, json: json)
            }
        }
    }

    /// Changed whether members can share links outside team, and if links are accessible only by team members or anyone
    /// by default.
    public class SharingChangeLinkPolicyDetails: CustomStringConvertible, JSONRepresentable {
        /// New external link accessibility policy.
        public let newValue: TeamLog.SharingLinkPolicy
        /// Previous external link accessibility policy. Might be missing due to historical data gap.
        public let previousValue: TeamLog.SharingLinkPolicy?
        public init(newValue: TeamLog.SharingLinkPolicy, previousValue: TeamLog.SharingLinkPolicy? = nil) {
            self.newValue = newValue
            self.previousValue = previousValue
        }

        func json() throws -> JSON {
            try SharingChangeLinkPolicyDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharingChangeLinkPolicyDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharingChangeLinkPolicyDetails: \(error)"
            }
        }
    }

    public class SharingChangeLinkPolicyDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharingChangeLinkPolicyDetails) throws -> JSON {
            let output = [
                "new_value": try TeamLog.SharingLinkPolicySerializer().serialize(value.newValue),
                "previous_value": try NullableSerializer(TeamLog.SharingLinkPolicySerializer()).serialize(value.previousValue),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharingChangeLinkPolicyDetails {
            switch json {
            case .dictionary(let dict):
                let newValue = try TeamLog.SharingLinkPolicySerializer().deserialize(dict["new_value"] ?? .null)
                let previousValue = try NullableSerializer(TeamLog.SharingLinkPolicySerializer()).deserialize(dict["previous_value"] ?? .null)
                return SharingChangeLinkPolicyDetails(newValue: newValue, previousValue: previousValue)
            default:
                throw JSONSerializerError.deserializeError(type: SharingChangeLinkPolicyDetails.self, json: json)
            }
        }
    }

    /// The SharingChangeLinkPolicyType struct
    public class SharingChangeLinkPolicyType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try SharingChangeLinkPolicyTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharingChangeLinkPolicyTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharingChangeLinkPolicyType: \(error)"
            }
        }
    }

    public class SharingChangeLinkPolicyTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharingChangeLinkPolicyType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharingChangeLinkPolicyType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return SharingChangeLinkPolicyType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: SharingChangeLinkPolicyType.self, json: json)
            }
        }
    }

    /// Changed whether members can share files/folders outside team.
    public class SharingChangeMemberPolicyDetails: CustomStringConvertible, JSONRepresentable {
        /// New external invite policy.
        public let newValue: TeamLog.SharingMemberPolicy
        /// Previous external invite policy. Might be missing due to historical data gap.
        public let previousValue: TeamLog.SharingMemberPolicy?
        public init(newValue: TeamLog.SharingMemberPolicy, previousValue: TeamLog.SharingMemberPolicy? = nil) {
            self.newValue = newValue
            self.previousValue = previousValue
        }

        func json() throws -> JSON {
            try SharingChangeMemberPolicyDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharingChangeMemberPolicyDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharingChangeMemberPolicyDetails: \(error)"
            }
        }
    }

    public class SharingChangeMemberPolicyDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharingChangeMemberPolicyDetails) throws -> JSON {
            let output = [
                "new_value": try TeamLog.SharingMemberPolicySerializer().serialize(value.newValue),
                "previous_value": try NullableSerializer(TeamLog.SharingMemberPolicySerializer()).serialize(value.previousValue),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharingChangeMemberPolicyDetails {
            switch json {
            case .dictionary(let dict):
                let newValue = try TeamLog.SharingMemberPolicySerializer().deserialize(dict["new_value"] ?? .null)
                let previousValue = try NullableSerializer(TeamLog.SharingMemberPolicySerializer()).deserialize(dict["previous_value"] ?? .null)
                return SharingChangeMemberPolicyDetails(newValue: newValue, previousValue: previousValue)
            default:
                throw JSONSerializerError.deserializeError(type: SharingChangeMemberPolicyDetails.self, json: json)
            }
        }
    }

    /// The SharingChangeMemberPolicyType struct
    public class SharingChangeMemberPolicyType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try SharingChangeMemberPolicyTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharingChangeMemberPolicyTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharingChangeMemberPolicyType: \(error)"
            }
        }
    }

    public class SharingChangeMemberPolicyTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharingChangeMemberPolicyType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharingChangeMemberPolicyType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return SharingChangeMemberPolicyType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: SharingChangeMemberPolicyType.self, json: json)
            }
        }
    }

    /// Policy for controlling if team members can join shared folders owned by non team members.
    public enum SharingFolderJoinPolicy: CustomStringConvertible, JSONRepresentable {
        /// An unspecified error.
        case fromAnyone
        /// An unspecified error.
        case fromTeamOnly
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try SharingFolderJoinPolicySerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharingFolderJoinPolicySerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharingFolderJoinPolicy: \(error)"
            }
        }
    }

    public class SharingFolderJoinPolicySerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharingFolderJoinPolicy) throws -> JSON {
            switch value {
            case .fromAnyone:
                var d = [String: JSON]()
                d[".tag"] = .str("from_anyone")
                return .dictionary(d)
            case .fromTeamOnly:
                var d = [String: JSON]()
                d[".tag"] = .str("from_team_only")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> SharingFolderJoinPolicy {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "from_anyone":
                    return SharingFolderJoinPolicy.fromAnyone
                case "from_team_only":
                    return SharingFolderJoinPolicy.fromTeamOnly
                case "other":
                    return SharingFolderJoinPolicy.other
                default:
                    return SharingFolderJoinPolicy.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: SharingFolderJoinPolicy.self, json: json)
            }
        }
    }

    /// Policy for controlling if team members can share links externally
    public enum SharingLinkPolicy: CustomStringConvertible, JSONRepresentable {
        /// An unspecified error.
        case defaultNoOne
        /// An unspecified error.
        case defaultPrivate
        /// An unspecified error.
        case defaultPublic
        /// An unspecified error.
        case onlyPrivate
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try SharingLinkPolicySerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharingLinkPolicySerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharingLinkPolicy: \(error)"
            }
        }
    }

    public class SharingLinkPolicySerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharingLinkPolicy) throws -> JSON {
            switch value {
            case .defaultNoOne:
                var d = [String: JSON]()
                d[".tag"] = .str("default_no_one")
                return .dictionary(d)
            case .defaultPrivate:
                var d = [String: JSON]()
                d[".tag"] = .str("default_private")
                return .dictionary(d)
            case .defaultPublic:
                var d = [String: JSON]()
                d[".tag"] = .str("default_public")
                return .dictionary(d)
            case .onlyPrivate:
                var d = [String: JSON]()
                d[".tag"] = .str("only_private")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> SharingLinkPolicy {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "default_no_one":
                    return SharingLinkPolicy.defaultNoOne
                case "default_private":
                    return SharingLinkPolicy.defaultPrivate
                case "default_public":
                    return SharingLinkPolicy.defaultPublic
                case "only_private":
                    return SharingLinkPolicy.onlyPrivate
                case "other":
                    return SharingLinkPolicy.other
                default:
                    return SharingLinkPolicy.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: SharingLinkPolicy.self, json: json)
            }
        }
    }

    /// External sharing policy
    public enum SharingMemberPolicy: CustomStringConvertible, JSONRepresentable {
        /// An unspecified error.
        case allow
        /// An unspecified error.
        case forbid
        /// An unspecified error.
        case forbidWithExclusions
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try SharingMemberPolicySerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharingMemberPolicySerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharingMemberPolicy: \(error)"
            }
        }
    }

    public class SharingMemberPolicySerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharingMemberPolicy) throws -> JSON {
            switch value {
            case .allow:
                var d = [String: JSON]()
                d[".tag"] = .str("allow")
                return .dictionary(d)
            case .forbid:
                var d = [String: JSON]()
                d[".tag"] = .str("forbid")
                return .dictionary(d)
            case .forbidWithExclusions:
                var d = [String: JSON]()
                d[".tag"] = .str("forbid_with_exclusions")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> SharingMemberPolicy {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "allow":
                    return SharingMemberPolicy.allow
                case "forbid":
                    return SharingMemberPolicy.forbid
                case "forbid_with_exclusions":
                    return SharingMemberPolicy.forbidWithExclusions
                case "other":
                    return SharingMemberPolicy.other
                default:
                    return SharingMemberPolicy.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: SharingMemberPolicy.self, json: json)
            }
        }
    }

    /// Disabled downloads for link.
    public class ShmodelDisableDownloadsDetails: CustomStringConvertible, JSONRepresentable {
        /// Shared link owner details. Might be missing due to historical data gap.
        public let sharedLinkOwner: TeamLog.UserLogInfo?
        public init(sharedLinkOwner: TeamLog.UserLogInfo? = nil) {
            self.sharedLinkOwner = sharedLinkOwner
        }

        func json() throws -> JSON {
            try ShmodelDisableDownloadsDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ShmodelDisableDownloadsDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ShmodelDisableDownloadsDetails: \(error)"
            }
        }
    }

    public class ShmodelDisableDownloadsDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ShmodelDisableDownloadsDetails) throws -> JSON {
            let output = [
                "shared_link_owner": try NullableSerializer(TeamLog.UserLogInfoSerializer()).serialize(value.sharedLinkOwner),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ShmodelDisableDownloadsDetails {
            switch json {
            case .dictionary(let dict):
                let sharedLinkOwner = try NullableSerializer(TeamLog.UserLogInfoSerializer()).deserialize(dict["shared_link_owner"] ?? .null)
                return ShmodelDisableDownloadsDetails(sharedLinkOwner: sharedLinkOwner)
            default:
                throw JSONSerializerError.deserializeError(type: ShmodelDisableDownloadsDetails.self, json: json)
            }
        }
    }

    /// The ShmodelDisableDownloadsType struct
    public class ShmodelDisableDownloadsType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try ShmodelDisableDownloadsTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ShmodelDisableDownloadsTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ShmodelDisableDownloadsType: \(error)"
            }
        }
    }

    public class ShmodelDisableDownloadsTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ShmodelDisableDownloadsType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ShmodelDisableDownloadsType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return ShmodelDisableDownloadsType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: ShmodelDisableDownloadsType.self, json: json)
            }
        }
    }

    /// Enabled downloads for link.
    public class ShmodelEnableDownloadsDetails: CustomStringConvertible, JSONRepresentable {
        /// Shared link owner details. Might be missing due to historical data gap.
        public let sharedLinkOwner: TeamLog.UserLogInfo?
        public init(sharedLinkOwner: TeamLog.UserLogInfo? = nil) {
            self.sharedLinkOwner = sharedLinkOwner
        }

        func json() throws -> JSON {
            try ShmodelEnableDownloadsDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ShmodelEnableDownloadsDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ShmodelEnableDownloadsDetails: \(error)"
            }
        }
    }

    public class ShmodelEnableDownloadsDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ShmodelEnableDownloadsDetails) throws -> JSON {
            let output = [
                "shared_link_owner": try NullableSerializer(TeamLog.UserLogInfoSerializer()).serialize(value.sharedLinkOwner),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ShmodelEnableDownloadsDetails {
            switch json {
            case .dictionary(let dict):
                let sharedLinkOwner = try NullableSerializer(TeamLog.UserLogInfoSerializer()).deserialize(dict["shared_link_owner"] ?? .null)
                return ShmodelEnableDownloadsDetails(sharedLinkOwner: sharedLinkOwner)
            default:
                throw JSONSerializerError.deserializeError(type: ShmodelEnableDownloadsDetails.self, json: json)
            }
        }
    }

    /// The ShmodelEnableDownloadsType struct
    public class ShmodelEnableDownloadsType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try ShmodelEnableDownloadsTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ShmodelEnableDownloadsTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ShmodelEnableDownloadsType: \(error)"
            }
        }
    }

    public class ShmodelEnableDownloadsTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ShmodelEnableDownloadsType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ShmodelEnableDownloadsType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return ShmodelEnableDownloadsType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: ShmodelEnableDownloadsType.self, json: json)
            }
        }
    }

    /// Shared link with group.
    public class ShmodelGroupShareDetails: CustomStringConvertible, JSONRepresentable {
        func json() throws -> JSON {
            try ShmodelGroupShareDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ShmodelGroupShareDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ShmodelGroupShareDetails: \(error)"
            }
        }
    }

    public class ShmodelGroupShareDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ShmodelGroupShareDetails) throws -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ShmodelGroupShareDetails {
            switch json {
            case .dictionary:
                return ShmodelGroupShareDetails()
            default:
                throw JSONSerializerError.deserializeError(type: ShmodelGroupShareDetails.self, json: json)
            }
        }
    }

    /// The ShmodelGroupShareType struct
    public class ShmodelGroupShareType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try ShmodelGroupShareTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ShmodelGroupShareTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ShmodelGroupShareType: \(error)"
            }
        }
    }

    public class ShmodelGroupShareTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ShmodelGroupShareType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ShmodelGroupShareType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return ShmodelGroupShareType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: ShmodelGroupShareType.self, json: json)
            }
        }
    }

    /// Granted access to showcase.
    public class ShowcaseAccessGrantedDetails: CustomStringConvertible, JSONRepresentable {
        /// Event unique identifier.
        public let eventUuid: String
        public init(eventUuid: String) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
        }

        func json() throws -> JSON {
            try ShowcaseAccessGrantedDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ShowcaseAccessGrantedDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ShowcaseAccessGrantedDetails: \(error)"
            }
        }
    }

    public class ShowcaseAccessGrantedDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ShowcaseAccessGrantedDetails) throws -> JSON {
            let output = [
                "event_uuid": try Serialization._StringSerializer.serialize(value.eventUuid),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ShowcaseAccessGrantedDetails {
            switch json {
            case .dictionary(let dict):
                let eventUuid = try Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                return ShowcaseAccessGrantedDetails(eventUuid: eventUuid)
            default:
                throw JSONSerializerError.deserializeError(type: ShowcaseAccessGrantedDetails.self, json: json)
            }
        }
    }

    /// The ShowcaseAccessGrantedType struct
    public class ShowcaseAccessGrantedType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try ShowcaseAccessGrantedTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ShowcaseAccessGrantedTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ShowcaseAccessGrantedType: \(error)"
            }
        }
    }

    public class ShowcaseAccessGrantedTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ShowcaseAccessGrantedType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ShowcaseAccessGrantedType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return ShowcaseAccessGrantedType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: ShowcaseAccessGrantedType.self, json: json)
            }
        }
    }

    /// Added member to showcase.
    public class ShowcaseAddMemberDetails: CustomStringConvertible, JSONRepresentable {
        /// Event unique identifier.
        public let eventUuid: String
        public init(eventUuid: String) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
        }

        func json() throws -> JSON {
            try ShowcaseAddMemberDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ShowcaseAddMemberDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ShowcaseAddMemberDetails: \(error)"
            }
        }
    }

    public class ShowcaseAddMemberDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ShowcaseAddMemberDetails) throws -> JSON {
            let output = [
                "event_uuid": try Serialization._StringSerializer.serialize(value.eventUuid),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ShowcaseAddMemberDetails {
            switch json {
            case .dictionary(let dict):
                let eventUuid = try Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                return ShowcaseAddMemberDetails(eventUuid: eventUuid)
            default:
                throw JSONSerializerError.deserializeError(type: ShowcaseAddMemberDetails.self, json: json)
            }
        }
    }

    /// The ShowcaseAddMemberType struct
    public class ShowcaseAddMemberType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try ShowcaseAddMemberTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ShowcaseAddMemberTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ShowcaseAddMemberType: \(error)"
            }
        }
    }

    public class ShowcaseAddMemberTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ShowcaseAddMemberType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ShowcaseAddMemberType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return ShowcaseAddMemberType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: ShowcaseAddMemberType.self, json: json)
            }
        }
    }

    /// Archived showcase.
    public class ShowcaseArchivedDetails: CustomStringConvertible, JSONRepresentable {
        /// Event unique identifier.
        public let eventUuid: String
        public init(eventUuid: String) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
        }

        func json() throws -> JSON {
            try ShowcaseArchivedDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ShowcaseArchivedDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ShowcaseArchivedDetails: \(error)"
            }
        }
    }

    public class ShowcaseArchivedDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ShowcaseArchivedDetails) throws -> JSON {
            let output = [
                "event_uuid": try Serialization._StringSerializer.serialize(value.eventUuid),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ShowcaseArchivedDetails {
            switch json {
            case .dictionary(let dict):
                let eventUuid = try Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                return ShowcaseArchivedDetails(eventUuid: eventUuid)
            default:
                throw JSONSerializerError.deserializeError(type: ShowcaseArchivedDetails.self, json: json)
            }
        }
    }

    /// The ShowcaseArchivedType struct
    public class ShowcaseArchivedType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try ShowcaseArchivedTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ShowcaseArchivedTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ShowcaseArchivedType: \(error)"
            }
        }
    }

    public class ShowcaseArchivedTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ShowcaseArchivedType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ShowcaseArchivedType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return ShowcaseArchivedType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: ShowcaseArchivedType.self, json: json)
            }
        }
    }

    /// Enabled/disabled downloading files from Dropbox Showcase for team.
    public class ShowcaseChangeDownloadPolicyDetails: CustomStringConvertible, JSONRepresentable {
        /// New Dropbox Showcase download policy.
        public let newValue: TeamLog.ShowcaseDownloadPolicy
        /// Previous Dropbox Showcase download policy.
        public let previousValue: TeamLog.ShowcaseDownloadPolicy
        public init(newValue: TeamLog.ShowcaseDownloadPolicy, previousValue: TeamLog.ShowcaseDownloadPolicy) {
            self.newValue = newValue
            self.previousValue = previousValue
        }

        func json() throws -> JSON {
            try ShowcaseChangeDownloadPolicyDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ShowcaseChangeDownloadPolicyDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ShowcaseChangeDownloadPolicyDetails: \(error)"
            }
        }
    }

    public class ShowcaseChangeDownloadPolicyDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ShowcaseChangeDownloadPolicyDetails) throws -> JSON {
            let output = [
                "new_value": try TeamLog.ShowcaseDownloadPolicySerializer().serialize(value.newValue),
                "previous_value": try TeamLog.ShowcaseDownloadPolicySerializer().serialize(value.previousValue),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ShowcaseChangeDownloadPolicyDetails {
            switch json {
            case .dictionary(let dict):
                let newValue = try TeamLog.ShowcaseDownloadPolicySerializer().deserialize(dict["new_value"] ?? .null)
                let previousValue = try TeamLog.ShowcaseDownloadPolicySerializer().deserialize(dict["previous_value"] ?? .null)
                return ShowcaseChangeDownloadPolicyDetails(newValue: newValue, previousValue: previousValue)
            default:
                throw JSONSerializerError.deserializeError(type: ShowcaseChangeDownloadPolicyDetails.self, json: json)
            }
        }
    }

    /// The ShowcaseChangeDownloadPolicyType struct
    public class ShowcaseChangeDownloadPolicyType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try ShowcaseChangeDownloadPolicyTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ShowcaseChangeDownloadPolicyTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ShowcaseChangeDownloadPolicyType: \(error)"
            }
        }
    }

    public class ShowcaseChangeDownloadPolicyTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ShowcaseChangeDownloadPolicyType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ShowcaseChangeDownloadPolicyType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return ShowcaseChangeDownloadPolicyType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: ShowcaseChangeDownloadPolicyType.self, json: json)
            }
        }
    }

    /// Enabled/disabled Dropbox Showcase for team.
    public class ShowcaseChangeEnabledPolicyDetails: CustomStringConvertible, JSONRepresentable {
        /// New Dropbox Showcase policy.
        public let newValue: TeamLog.ShowcaseEnabledPolicy
        /// Previous Dropbox Showcase policy.
        public let previousValue: TeamLog.ShowcaseEnabledPolicy
        public init(newValue: TeamLog.ShowcaseEnabledPolicy, previousValue: TeamLog.ShowcaseEnabledPolicy) {
            self.newValue = newValue
            self.previousValue = previousValue
        }

        func json() throws -> JSON {
            try ShowcaseChangeEnabledPolicyDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ShowcaseChangeEnabledPolicyDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ShowcaseChangeEnabledPolicyDetails: \(error)"
            }
        }
    }

    public class ShowcaseChangeEnabledPolicyDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ShowcaseChangeEnabledPolicyDetails) throws -> JSON {
            let output = [
                "new_value": try TeamLog.ShowcaseEnabledPolicySerializer().serialize(value.newValue),
                "previous_value": try TeamLog.ShowcaseEnabledPolicySerializer().serialize(value.previousValue),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ShowcaseChangeEnabledPolicyDetails {
            switch json {
            case .dictionary(let dict):
                let newValue = try TeamLog.ShowcaseEnabledPolicySerializer().deserialize(dict["new_value"] ?? .null)
                let previousValue = try TeamLog.ShowcaseEnabledPolicySerializer().deserialize(dict["previous_value"] ?? .null)
                return ShowcaseChangeEnabledPolicyDetails(newValue: newValue, previousValue: previousValue)
            default:
                throw JSONSerializerError.deserializeError(type: ShowcaseChangeEnabledPolicyDetails.self, json: json)
            }
        }
    }

    /// The ShowcaseChangeEnabledPolicyType struct
    public class ShowcaseChangeEnabledPolicyType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try ShowcaseChangeEnabledPolicyTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ShowcaseChangeEnabledPolicyTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ShowcaseChangeEnabledPolicyType: \(error)"
            }
        }
    }

    public class ShowcaseChangeEnabledPolicyTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ShowcaseChangeEnabledPolicyType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ShowcaseChangeEnabledPolicyType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return ShowcaseChangeEnabledPolicyType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: ShowcaseChangeEnabledPolicyType.self, json: json)
            }
        }
    }

    /// Enabled/disabled sharing Dropbox Showcase externally for team.
    public class ShowcaseChangeExternalSharingPolicyDetails: CustomStringConvertible, JSONRepresentable {
        /// New Dropbox Showcase external sharing policy.
        public let newValue: TeamLog.ShowcaseExternalSharingPolicy
        /// Previous Dropbox Showcase external sharing policy.
        public let previousValue: TeamLog.ShowcaseExternalSharingPolicy
        public init(newValue: TeamLog.ShowcaseExternalSharingPolicy, previousValue: TeamLog.ShowcaseExternalSharingPolicy) {
            self.newValue = newValue
            self.previousValue = previousValue
        }

        func json() throws -> JSON {
            try ShowcaseChangeExternalSharingPolicyDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ShowcaseChangeExternalSharingPolicyDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ShowcaseChangeExternalSharingPolicyDetails: \(error)"
            }
        }
    }

    public class ShowcaseChangeExternalSharingPolicyDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ShowcaseChangeExternalSharingPolicyDetails) throws -> JSON {
            let output = [
                "new_value": try TeamLog.ShowcaseExternalSharingPolicySerializer().serialize(value.newValue),
                "previous_value": try TeamLog.ShowcaseExternalSharingPolicySerializer().serialize(value.previousValue),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ShowcaseChangeExternalSharingPolicyDetails {
            switch json {
            case .dictionary(let dict):
                let newValue = try TeamLog.ShowcaseExternalSharingPolicySerializer().deserialize(dict["new_value"] ?? .null)
                let previousValue = try TeamLog.ShowcaseExternalSharingPolicySerializer().deserialize(dict["previous_value"] ?? .null)
                return ShowcaseChangeExternalSharingPolicyDetails(newValue: newValue, previousValue: previousValue)
            default:
                throw JSONSerializerError.deserializeError(type: ShowcaseChangeExternalSharingPolicyDetails.self, json: json)
            }
        }
    }

    /// The ShowcaseChangeExternalSharingPolicyType struct
    public class ShowcaseChangeExternalSharingPolicyType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try ShowcaseChangeExternalSharingPolicyTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ShowcaseChangeExternalSharingPolicyTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ShowcaseChangeExternalSharingPolicyType: \(error)"
            }
        }
    }

    public class ShowcaseChangeExternalSharingPolicyTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ShowcaseChangeExternalSharingPolicyType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ShowcaseChangeExternalSharingPolicyType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return ShowcaseChangeExternalSharingPolicyType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: ShowcaseChangeExternalSharingPolicyType.self, json: json)
            }
        }
    }

    /// Created showcase.
    public class ShowcaseCreatedDetails: CustomStringConvertible, JSONRepresentable {
        /// Event unique identifier.
        public let eventUuid: String
        public init(eventUuid: String) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
        }

        func json() throws -> JSON {
            try ShowcaseCreatedDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ShowcaseCreatedDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ShowcaseCreatedDetails: \(error)"
            }
        }
    }

    public class ShowcaseCreatedDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ShowcaseCreatedDetails) throws -> JSON {
            let output = [
                "event_uuid": try Serialization._StringSerializer.serialize(value.eventUuid),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ShowcaseCreatedDetails {
            switch json {
            case .dictionary(let dict):
                let eventUuid = try Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                return ShowcaseCreatedDetails(eventUuid: eventUuid)
            default:
                throw JSONSerializerError.deserializeError(type: ShowcaseCreatedDetails.self, json: json)
            }
        }
    }

    /// The ShowcaseCreatedType struct
    public class ShowcaseCreatedType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try ShowcaseCreatedTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ShowcaseCreatedTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ShowcaseCreatedType: \(error)"
            }
        }
    }

    public class ShowcaseCreatedTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ShowcaseCreatedType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ShowcaseCreatedType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return ShowcaseCreatedType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: ShowcaseCreatedType.self, json: json)
            }
        }
    }

    /// Deleted showcase comment.
    public class ShowcaseDeleteCommentDetails: CustomStringConvertible, JSONRepresentable {
        /// Event unique identifier.
        public let eventUuid: String
        /// Comment text.
        public let commentText: String?
        public init(eventUuid: String, commentText: String? = nil) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
            nullableValidator(stringValidator())(commentText)
            self.commentText = commentText
        }

        func json() throws -> JSON {
            try ShowcaseDeleteCommentDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ShowcaseDeleteCommentDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ShowcaseDeleteCommentDetails: \(error)"
            }
        }
    }

    public class ShowcaseDeleteCommentDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ShowcaseDeleteCommentDetails) throws -> JSON {
            let output = [
                "event_uuid": try Serialization._StringSerializer.serialize(value.eventUuid),
                "comment_text": try NullableSerializer(Serialization._StringSerializer).serialize(value.commentText),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ShowcaseDeleteCommentDetails {
            switch json {
            case .dictionary(let dict):
                let eventUuid = try Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                let commentText = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["comment_text"] ?? .null)
                return ShowcaseDeleteCommentDetails(eventUuid: eventUuid, commentText: commentText)
            default:
                throw JSONSerializerError.deserializeError(type: ShowcaseDeleteCommentDetails.self, json: json)
            }
        }
    }

    /// The ShowcaseDeleteCommentType struct
    public class ShowcaseDeleteCommentType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try ShowcaseDeleteCommentTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ShowcaseDeleteCommentTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ShowcaseDeleteCommentType: \(error)"
            }
        }
    }

    public class ShowcaseDeleteCommentTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ShowcaseDeleteCommentType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ShowcaseDeleteCommentType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return ShowcaseDeleteCommentType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: ShowcaseDeleteCommentType.self, json: json)
            }
        }
    }

    /// Showcase document's logged information.
    public class ShowcaseDocumentLogInfo: CustomStringConvertible, JSONRepresentable {
        /// Showcase document Id.
        public let showcaseId: String
        /// Showcase document title.
        public let showcaseTitle: String
        public init(showcaseId: String, showcaseTitle: String) {
            stringValidator()(showcaseId)
            self.showcaseId = showcaseId
            stringValidator()(showcaseTitle)
            self.showcaseTitle = showcaseTitle
        }

        func json() throws -> JSON {
            try ShowcaseDocumentLogInfoSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ShowcaseDocumentLogInfoSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ShowcaseDocumentLogInfo: \(error)"
            }
        }
    }

    public class ShowcaseDocumentLogInfoSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ShowcaseDocumentLogInfo) throws -> JSON {
            let output = [
                "showcase_id": try Serialization._StringSerializer.serialize(value.showcaseId),
                "showcase_title": try Serialization._StringSerializer.serialize(value.showcaseTitle),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ShowcaseDocumentLogInfo {
            switch json {
            case .dictionary(let dict):
                let showcaseId = try Serialization._StringSerializer.deserialize(dict["showcase_id"] ?? .null)
                let showcaseTitle = try Serialization._StringSerializer.deserialize(dict["showcase_title"] ?? .null)
                return ShowcaseDocumentLogInfo(showcaseId: showcaseId, showcaseTitle: showcaseTitle)
            default:
                throw JSONSerializerError.deserializeError(type: ShowcaseDocumentLogInfo.self, json: json)
            }
        }
    }

    /// Policy for controlling if files can be downloaded from Showcases by team members
    public enum ShowcaseDownloadPolicy: CustomStringConvertible, JSONRepresentable {
        /// An unspecified error.
        case disabled
        /// An unspecified error.
        case enabled
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try ShowcaseDownloadPolicySerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ShowcaseDownloadPolicySerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ShowcaseDownloadPolicy: \(error)"
            }
        }
    }

    public class ShowcaseDownloadPolicySerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ShowcaseDownloadPolicy) throws -> JSON {
            switch value {
            case .disabled:
                var d = [String: JSON]()
                d[".tag"] = .str("disabled")
                return .dictionary(d)
            case .enabled:
                var d = [String: JSON]()
                d[".tag"] = .str("enabled")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> ShowcaseDownloadPolicy {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "disabled":
                    return ShowcaseDownloadPolicy.disabled
                case "enabled":
                    return ShowcaseDownloadPolicy.enabled
                case "other":
                    return ShowcaseDownloadPolicy.other
                default:
                    return ShowcaseDownloadPolicy.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: ShowcaseDownloadPolicy.self, json: json)
            }
        }
    }

    /// Edited showcase comment.
    public class ShowcaseEditCommentDetails: CustomStringConvertible, JSONRepresentable {
        /// Event unique identifier.
        public let eventUuid: String
        /// Comment text.
        public let commentText: String?
        public init(eventUuid: String, commentText: String? = nil) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
            nullableValidator(stringValidator())(commentText)
            self.commentText = commentText
        }

        func json() throws -> JSON {
            try ShowcaseEditCommentDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ShowcaseEditCommentDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ShowcaseEditCommentDetails: \(error)"
            }
        }
    }

    public class ShowcaseEditCommentDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ShowcaseEditCommentDetails) throws -> JSON {
            let output = [
                "event_uuid": try Serialization._StringSerializer.serialize(value.eventUuid),
                "comment_text": try NullableSerializer(Serialization._StringSerializer).serialize(value.commentText),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ShowcaseEditCommentDetails {
            switch json {
            case .dictionary(let dict):
                let eventUuid = try Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                let commentText = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["comment_text"] ?? .null)
                return ShowcaseEditCommentDetails(eventUuid: eventUuid, commentText: commentText)
            default:
                throw JSONSerializerError.deserializeError(type: ShowcaseEditCommentDetails.self, json: json)
            }
        }
    }

    /// The ShowcaseEditCommentType struct
    public class ShowcaseEditCommentType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try ShowcaseEditCommentTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ShowcaseEditCommentTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ShowcaseEditCommentType: \(error)"
            }
        }
    }

    public class ShowcaseEditCommentTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ShowcaseEditCommentType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ShowcaseEditCommentType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return ShowcaseEditCommentType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: ShowcaseEditCommentType.self, json: json)
            }
        }
    }

    /// Edited showcase.
    public class ShowcaseEditedDetails: CustomStringConvertible, JSONRepresentable {
        /// Event unique identifier.
        public let eventUuid: String
        public init(eventUuid: String) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
        }

        func json() throws -> JSON {
            try ShowcaseEditedDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ShowcaseEditedDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ShowcaseEditedDetails: \(error)"
            }
        }
    }

    public class ShowcaseEditedDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ShowcaseEditedDetails) throws -> JSON {
            let output = [
                "event_uuid": try Serialization._StringSerializer.serialize(value.eventUuid),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ShowcaseEditedDetails {
            switch json {
            case .dictionary(let dict):
                let eventUuid = try Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                return ShowcaseEditedDetails(eventUuid: eventUuid)
            default:
                throw JSONSerializerError.deserializeError(type: ShowcaseEditedDetails.self, json: json)
            }
        }
    }

    /// The ShowcaseEditedType struct
    public class ShowcaseEditedType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try ShowcaseEditedTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ShowcaseEditedTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ShowcaseEditedType: \(error)"
            }
        }
    }

    public class ShowcaseEditedTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ShowcaseEditedType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ShowcaseEditedType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return ShowcaseEditedType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: ShowcaseEditedType.self, json: json)
            }
        }
    }

    /// Policy for controlling whether Showcase is enabled.
    public enum ShowcaseEnabledPolicy: CustomStringConvertible, JSONRepresentable {
        /// An unspecified error.
        case disabled
        /// An unspecified error.
        case enabled
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try ShowcaseEnabledPolicySerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ShowcaseEnabledPolicySerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ShowcaseEnabledPolicy: \(error)"
            }
        }
    }

    public class ShowcaseEnabledPolicySerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ShowcaseEnabledPolicy) throws -> JSON {
            switch value {
            case .disabled:
                var d = [String: JSON]()
                d[".tag"] = .str("disabled")
                return .dictionary(d)
            case .enabled:
                var d = [String: JSON]()
                d[".tag"] = .str("enabled")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> ShowcaseEnabledPolicy {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "disabled":
                    return ShowcaseEnabledPolicy.disabled
                case "enabled":
                    return ShowcaseEnabledPolicy.enabled
                case "other":
                    return ShowcaseEnabledPolicy.other
                default:
                    return ShowcaseEnabledPolicy.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: ShowcaseEnabledPolicy.self, json: json)
            }
        }
    }

    /// Policy for controlling if team members can share Showcases externally.
    public enum ShowcaseExternalSharingPolicy: CustomStringConvertible, JSONRepresentable {
        /// An unspecified error.
        case disabled
        /// An unspecified error.
        case enabled
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try ShowcaseExternalSharingPolicySerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ShowcaseExternalSharingPolicySerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ShowcaseExternalSharingPolicy: \(error)"
            }
        }
    }

    public class ShowcaseExternalSharingPolicySerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ShowcaseExternalSharingPolicy) throws -> JSON {
            switch value {
            case .disabled:
                var d = [String: JSON]()
                d[".tag"] = .str("disabled")
                return .dictionary(d)
            case .enabled:
                var d = [String: JSON]()
                d[".tag"] = .str("enabled")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> ShowcaseExternalSharingPolicy {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "disabled":
                    return ShowcaseExternalSharingPolicy.disabled
                case "enabled":
                    return ShowcaseExternalSharingPolicy.enabled
                case "other":
                    return ShowcaseExternalSharingPolicy.other
                default:
                    return ShowcaseExternalSharingPolicy.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: ShowcaseExternalSharingPolicy.self, json: json)
            }
        }
    }

    /// Added file to showcase.
    public class ShowcaseFileAddedDetails: CustomStringConvertible, JSONRepresentable {
        /// Event unique identifier.
        public let eventUuid: String
        public init(eventUuid: String) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
        }

        func json() throws -> JSON {
            try ShowcaseFileAddedDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ShowcaseFileAddedDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ShowcaseFileAddedDetails: \(error)"
            }
        }
    }

    public class ShowcaseFileAddedDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ShowcaseFileAddedDetails) throws -> JSON {
            let output = [
                "event_uuid": try Serialization._StringSerializer.serialize(value.eventUuid),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ShowcaseFileAddedDetails {
            switch json {
            case .dictionary(let dict):
                let eventUuid = try Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                return ShowcaseFileAddedDetails(eventUuid: eventUuid)
            default:
                throw JSONSerializerError.deserializeError(type: ShowcaseFileAddedDetails.self, json: json)
            }
        }
    }

    /// The ShowcaseFileAddedType struct
    public class ShowcaseFileAddedType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try ShowcaseFileAddedTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ShowcaseFileAddedTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ShowcaseFileAddedType: \(error)"
            }
        }
    }

    public class ShowcaseFileAddedTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ShowcaseFileAddedType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ShowcaseFileAddedType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return ShowcaseFileAddedType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: ShowcaseFileAddedType.self, json: json)
            }
        }
    }

    /// Downloaded file from showcase.
    public class ShowcaseFileDownloadDetails: CustomStringConvertible, JSONRepresentable {
        /// Event unique identifier.
        public let eventUuid: String
        /// Showcase download type.
        public let downloadType: String
        public init(eventUuid: String, downloadType: String) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
            stringValidator()(downloadType)
            self.downloadType = downloadType
        }

        func json() throws -> JSON {
            try ShowcaseFileDownloadDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ShowcaseFileDownloadDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ShowcaseFileDownloadDetails: \(error)"
            }
        }
    }

    public class ShowcaseFileDownloadDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ShowcaseFileDownloadDetails) throws -> JSON {
            let output = [
                "event_uuid": try Serialization._StringSerializer.serialize(value.eventUuid),
                "download_type": try Serialization._StringSerializer.serialize(value.downloadType),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ShowcaseFileDownloadDetails {
            switch json {
            case .dictionary(let dict):
                let eventUuid = try Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                let downloadType = try Serialization._StringSerializer.deserialize(dict["download_type"] ?? .null)
                return ShowcaseFileDownloadDetails(eventUuid: eventUuid, downloadType: downloadType)
            default:
                throw JSONSerializerError.deserializeError(type: ShowcaseFileDownloadDetails.self, json: json)
            }
        }
    }

    /// The ShowcaseFileDownloadType struct
    public class ShowcaseFileDownloadType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try ShowcaseFileDownloadTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ShowcaseFileDownloadTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ShowcaseFileDownloadType: \(error)"
            }
        }
    }

    public class ShowcaseFileDownloadTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ShowcaseFileDownloadType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ShowcaseFileDownloadType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return ShowcaseFileDownloadType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: ShowcaseFileDownloadType.self, json: json)
            }
        }
    }

    /// Removed file from showcase.
    public class ShowcaseFileRemovedDetails: CustomStringConvertible, JSONRepresentable {
        /// Event unique identifier.
        public let eventUuid: String
        public init(eventUuid: String) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
        }

        func json() throws -> JSON {
            try ShowcaseFileRemovedDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ShowcaseFileRemovedDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ShowcaseFileRemovedDetails: \(error)"
            }
        }
    }

    public class ShowcaseFileRemovedDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ShowcaseFileRemovedDetails) throws -> JSON {
            let output = [
                "event_uuid": try Serialization._StringSerializer.serialize(value.eventUuid),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ShowcaseFileRemovedDetails {
            switch json {
            case .dictionary(let dict):
                let eventUuid = try Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                return ShowcaseFileRemovedDetails(eventUuid: eventUuid)
            default:
                throw JSONSerializerError.deserializeError(type: ShowcaseFileRemovedDetails.self, json: json)
            }
        }
    }

    /// The ShowcaseFileRemovedType struct
    public class ShowcaseFileRemovedType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try ShowcaseFileRemovedTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ShowcaseFileRemovedTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ShowcaseFileRemovedType: \(error)"
            }
        }
    }

    public class ShowcaseFileRemovedTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ShowcaseFileRemovedType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ShowcaseFileRemovedType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return ShowcaseFileRemovedType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: ShowcaseFileRemovedType.self, json: json)
            }
        }
    }

    /// Viewed file in showcase.
    public class ShowcaseFileViewDetails: CustomStringConvertible, JSONRepresentable {
        /// Event unique identifier.
        public let eventUuid: String
        public init(eventUuid: String) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
        }

        func json() throws -> JSON {
            try ShowcaseFileViewDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ShowcaseFileViewDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ShowcaseFileViewDetails: \(error)"
            }
        }
    }

    public class ShowcaseFileViewDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ShowcaseFileViewDetails) throws -> JSON {
            let output = [
                "event_uuid": try Serialization._StringSerializer.serialize(value.eventUuid),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ShowcaseFileViewDetails {
            switch json {
            case .dictionary(let dict):
                let eventUuid = try Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                return ShowcaseFileViewDetails(eventUuid: eventUuid)
            default:
                throw JSONSerializerError.deserializeError(type: ShowcaseFileViewDetails.self, json: json)
            }
        }
    }

    /// The ShowcaseFileViewType struct
    public class ShowcaseFileViewType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try ShowcaseFileViewTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ShowcaseFileViewTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ShowcaseFileViewType: \(error)"
            }
        }
    }

    public class ShowcaseFileViewTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ShowcaseFileViewType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ShowcaseFileViewType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return ShowcaseFileViewType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: ShowcaseFileViewType.self, json: json)
            }
        }
    }

    /// Permanently deleted showcase.
    public class ShowcasePermanentlyDeletedDetails: CustomStringConvertible, JSONRepresentable {
        /// Event unique identifier.
        public let eventUuid: String
        public init(eventUuid: String) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
        }

        func json() throws -> JSON {
            try ShowcasePermanentlyDeletedDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ShowcasePermanentlyDeletedDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ShowcasePermanentlyDeletedDetails: \(error)"
            }
        }
    }

    public class ShowcasePermanentlyDeletedDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ShowcasePermanentlyDeletedDetails) throws -> JSON {
            let output = [
                "event_uuid": try Serialization._StringSerializer.serialize(value.eventUuid),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ShowcasePermanentlyDeletedDetails {
            switch json {
            case .dictionary(let dict):
                let eventUuid = try Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                return ShowcasePermanentlyDeletedDetails(eventUuid: eventUuid)
            default:
                throw JSONSerializerError.deserializeError(type: ShowcasePermanentlyDeletedDetails.self, json: json)
            }
        }
    }

    /// The ShowcasePermanentlyDeletedType struct
    public class ShowcasePermanentlyDeletedType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try ShowcasePermanentlyDeletedTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ShowcasePermanentlyDeletedTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ShowcasePermanentlyDeletedType: \(error)"
            }
        }
    }

    public class ShowcasePermanentlyDeletedTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ShowcasePermanentlyDeletedType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ShowcasePermanentlyDeletedType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return ShowcasePermanentlyDeletedType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: ShowcasePermanentlyDeletedType.self, json: json)
            }
        }
    }

    /// Added showcase comment.
    public class ShowcasePostCommentDetails: CustomStringConvertible, JSONRepresentable {
        /// Event unique identifier.
        public let eventUuid: String
        /// Comment text.
        public let commentText: String?
        public init(eventUuid: String, commentText: String? = nil) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
            nullableValidator(stringValidator())(commentText)
            self.commentText = commentText
        }

        func json() throws -> JSON {
            try ShowcasePostCommentDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ShowcasePostCommentDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ShowcasePostCommentDetails: \(error)"
            }
        }
    }

    public class ShowcasePostCommentDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ShowcasePostCommentDetails) throws -> JSON {
            let output = [
                "event_uuid": try Serialization._StringSerializer.serialize(value.eventUuid),
                "comment_text": try NullableSerializer(Serialization._StringSerializer).serialize(value.commentText),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ShowcasePostCommentDetails {
            switch json {
            case .dictionary(let dict):
                let eventUuid = try Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                let commentText = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["comment_text"] ?? .null)
                return ShowcasePostCommentDetails(eventUuid: eventUuid, commentText: commentText)
            default:
                throw JSONSerializerError.deserializeError(type: ShowcasePostCommentDetails.self, json: json)
            }
        }
    }

    /// The ShowcasePostCommentType struct
    public class ShowcasePostCommentType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try ShowcasePostCommentTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ShowcasePostCommentTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ShowcasePostCommentType: \(error)"
            }
        }
    }

    public class ShowcasePostCommentTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ShowcasePostCommentType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ShowcasePostCommentType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return ShowcasePostCommentType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: ShowcasePostCommentType.self, json: json)
            }
        }
    }

    /// Removed member from showcase.
    public class ShowcaseRemoveMemberDetails: CustomStringConvertible, JSONRepresentable {
        /// Event unique identifier.
        public let eventUuid: String
        public init(eventUuid: String) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
        }

        func json() throws -> JSON {
            try ShowcaseRemoveMemberDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ShowcaseRemoveMemberDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ShowcaseRemoveMemberDetails: \(error)"
            }
        }
    }

    public class ShowcaseRemoveMemberDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ShowcaseRemoveMemberDetails) throws -> JSON {
            let output = [
                "event_uuid": try Serialization._StringSerializer.serialize(value.eventUuid),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ShowcaseRemoveMemberDetails {
            switch json {
            case .dictionary(let dict):
                let eventUuid = try Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                return ShowcaseRemoveMemberDetails(eventUuid: eventUuid)
            default:
                throw JSONSerializerError.deserializeError(type: ShowcaseRemoveMemberDetails.self, json: json)
            }
        }
    }

    /// The ShowcaseRemoveMemberType struct
    public class ShowcaseRemoveMemberType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try ShowcaseRemoveMemberTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ShowcaseRemoveMemberTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ShowcaseRemoveMemberType: \(error)"
            }
        }
    }

    public class ShowcaseRemoveMemberTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ShowcaseRemoveMemberType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ShowcaseRemoveMemberType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return ShowcaseRemoveMemberType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: ShowcaseRemoveMemberType.self, json: json)
            }
        }
    }

    /// Renamed showcase.
    public class ShowcaseRenamedDetails: CustomStringConvertible, JSONRepresentable {
        /// Event unique identifier.
        public let eventUuid: String
        public init(eventUuid: String) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
        }

        func json() throws -> JSON {
            try ShowcaseRenamedDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ShowcaseRenamedDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ShowcaseRenamedDetails: \(error)"
            }
        }
    }

    public class ShowcaseRenamedDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ShowcaseRenamedDetails) throws -> JSON {
            let output = [
                "event_uuid": try Serialization._StringSerializer.serialize(value.eventUuid),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ShowcaseRenamedDetails {
            switch json {
            case .dictionary(let dict):
                let eventUuid = try Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                return ShowcaseRenamedDetails(eventUuid: eventUuid)
            default:
                throw JSONSerializerError.deserializeError(type: ShowcaseRenamedDetails.self, json: json)
            }
        }
    }

    /// The ShowcaseRenamedType struct
    public class ShowcaseRenamedType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try ShowcaseRenamedTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ShowcaseRenamedTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ShowcaseRenamedType: \(error)"
            }
        }
    }

    public class ShowcaseRenamedTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ShowcaseRenamedType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ShowcaseRenamedType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return ShowcaseRenamedType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: ShowcaseRenamedType.self, json: json)
            }
        }
    }

    /// Requested access to showcase.
    public class ShowcaseRequestAccessDetails: CustomStringConvertible, JSONRepresentable {
        /// Event unique identifier.
        public let eventUuid: String
        public init(eventUuid: String) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
        }

        func json() throws -> JSON {
            try ShowcaseRequestAccessDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ShowcaseRequestAccessDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ShowcaseRequestAccessDetails: \(error)"
            }
        }
    }

    public class ShowcaseRequestAccessDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ShowcaseRequestAccessDetails) throws -> JSON {
            let output = [
                "event_uuid": try Serialization._StringSerializer.serialize(value.eventUuid),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ShowcaseRequestAccessDetails {
            switch json {
            case .dictionary(let dict):
                let eventUuid = try Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                return ShowcaseRequestAccessDetails(eventUuid: eventUuid)
            default:
                throw JSONSerializerError.deserializeError(type: ShowcaseRequestAccessDetails.self, json: json)
            }
        }
    }

    /// The ShowcaseRequestAccessType struct
    public class ShowcaseRequestAccessType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try ShowcaseRequestAccessTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ShowcaseRequestAccessTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ShowcaseRequestAccessType: \(error)"
            }
        }
    }

    public class ShowcaseRequestAccessTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ShowcaseRequestAccessType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ShowcaseRequestAccessType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return ShowcaseRequestAccessType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: ShowcaseRequestAccessType.self, json: json)
            }
        }
    }

    /// Resolved showcase comment.
    public class ShowcaseResolveCommentDetails: CustomStringConvertible, JSONRepresentable {
        /// Event unique identifier.
        public let eventUuid: String
        /// Comment text.
        public let commentText: String?
        public init(eventUuid: String, commentText: String? = nil) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
            nullableValidator(stringValidator())(commentText)
            self.commentText = commentText
        }

        func json() throws -> JSON {
            try ShowcaseResolveCommentDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ShowcaseResolveCommentDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ShowcaseResolveCommentDetails: \(error)"
            }
        }
    }

    public class ShowcaseResolveCommentDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ShowcaseResolveCommentDetails) throws -> JSON {
            let output = [
                "event_uuid": try Serialization._StringSerializer.serialize(value.eventUuid),
                "comment_text": try NullableSerializer(Serialization._StringSerializer).serialize(value.commentText),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ShowcaseResolveCommentDetails {
            switch json {
            case .dictionary(let dict):
                let eventUuid = try Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                let commentText = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["comment_text"] ?? .null)
                return ShowcaseResolveCommentDetails(eventUuid: eventUuid, commentText: commentText)
            default:
                throw JSONSerializerError.deserializeError(type: ShowcaseResolveCommentDetails.self, json: json)
            }
        }
    }

    /// The ShowcaseResolveCommentType struct
    public class ShowcaseResolveCommentType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try ShowcaseResolveCommentTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ShowcaseResolveCommentTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ShowcaseResolveCommentType: \(error)"
            }
        }
    }

    public class ShowcaseResolveCommentTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ShowcaseResolveCommentType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ShowcaseResolveCommentType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return ShowcaseResolveCommentType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: ShowcaseResolveCommentType.self, json: json)
            }
        }
    }

    /// Unarchived showcase.
    public class ShowcaseRestoredDetails: CustomStringConvertible, JSONRepresentable {
        /// Event unique identifier.
        public let eventUuid: String
        public init(eventUuid: String) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
        }

        func json() throws -> JSON {
            try ShowcaseRestoredDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ShowcaseRestoredDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ShowcaseRestoredDetails: \(error)"
            }
        }
    }

    public class ShowcaseRestoredDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ShowcaseRestoredDetails) throws -> JSON {
            let output = [
                "event_uuid": try Serialization._StringSerializer.serialize(value.eventUuid),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ShowcaseRestoredDetails {
            switch json {
            case .dictionary(let dict):
                let eventUuid = try Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                return ShowcaseRestoredDetails(eventUuid: eventUuid)
            default:
                throw JSONSerializerError.deserializeError(type: ShowcaseRestoredDetails.self, json: json)
            }
        }
    }

    /// The ShowcaseRestoredType struct
    public class ShowcaseRestoredType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try ShowcaseRestoredTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ShowcaseRestoredTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ShowcaseRestoredType: \(error)"
            }
        }
    }

    public class ShowcaseRestoredTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ShowcaseRestoredType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ShowcaseRestoredType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return ShowcaseRestoredType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: ShowcaseRestoredType.self, json: json)
            }
        }
    }

    /// Deleted showcase (old version).
    public class ShowcaseTrashedDeprecatedDetails: CustomStringConvertible, JSONRepresentable {
        /// Event unique identifier.
        public let eventUuid: String
        public init(eventUuid: String) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
        }

        func json() throws -> JSON {
            try ShowcaseTrashedDeprecatedDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ShowcaseTrashedDeprecatedDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ShowcaseTrashedDeprecatedDetails: \(error)"
            }
        }
    }

    public class ShowcaseTrashedDeprecatedDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ShowcaseTrashedDeprecatedDetails) throws -> JSON {
            let output = [
                "event_uuid": try Serialization._StringSerializer.serialize(value.eventUuid),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ShowcaseTrashedDeprecatedDetails {
            switch json {
            case .dictionary(let dict):
                let eventUuid = try Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                return ShowcaseTrashedDeprecatedDetails(eventUuid: eventUuid)
            default:
                throw JSONSerializerError.deserializeError(type: ShowcaseTrashedDeprecatedDetails.self, json: json)
            }
        }
    }

    /// The ShowcaseTrashedDeprecatedType struct
    public class ShowcaseTrashedDeprecatedType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try ShowcaseTrashedDeprecatedTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ShowcaseTrashedDeprecatedTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ShowcaseTrashedDeprecatedType: \(error)"
            }
        }
    }

    public class ShowcaseTrashedDeprecatedTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ShowcaseTrashedDeprecatedType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ShowcaseTrashedDeprecatedType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return ShowcaseTrashedDeprecatedType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: ShowcaseTrashedDeprecatedType.self, json: json)
            }
        }
    }

    /// Deleted showcase.
    public class ShowcaseTrashedDetails: CustomStringConvertible, JSONRepresentable {
        /// Event unique identifier.
        public let eventUuid: String
        public init(eventUuid: String) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
        }

        func json() throws -> JSON {
            try ShowcaseTrashedDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ShowcaseTrashedDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ShowcaseTrashedDetails: \(error)"
            }
        }
    }

    public class ShowcaseTrashedDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ShowcaseTrashedDetails) throws -> JSON {
            let output = [
                "event_uuid": try Serialization._StringSerializer.serialize(value.eventUuid),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ShowcaseTrashedDetails {
            switch json {
            case .dictionary(let dict):
                let eventUuid = try Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                return ShowcaseTrashedDetails(eventUuid: eventUuid)
            default:
                throw JSONSerializerError.deserializeError(type: ShowcaseTrashedDetails.self, json: json)
            }
        }
    }

    /// The ShowcaseTrashedType struct
    public class ShowcaseTrashedType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try ShowcaseTrashedTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ShowcaseTrashedTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ShowcaseTrashedType: \(error)"
            }
        }
    }

    public class ShowcaseTrashedTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ShowcaseTrashedType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ShowcaseTrashedType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return ShowcaseTrashedType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: ShowcaseTrashedType.self, json: json)
            }
        }
    }

    /// Unresolved showcase comment.
    public class ShowcaseUnresolveCommentDetails: CustomStringConvertible, JSONRepresentable {
        /// Event unique identifier.
        public let eventUuid: String
        /// Comment text.
        public let commentText: String?
        public init(eventUuid: String, commentText: String? = nil) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
            nullableValidator(stringValidator())(commentText)
            self.commentText = commentText
        }

        func json() throws -> JSON {
            try ShowcaseUnresolveCommentDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ShowcaseUnresolveCommentDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ShowcaseUnresolveCommentDetails: \(error)"
            }
        }
    }

    public class ShowcaseUnresolveCommentDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ShowcaseUnresolveCommentDetails) throws -> JSON {
            let output = [
                "event_uuid": try Serialization._StringSerializer.serialize(value.eventUuid),
                "comment_text": try NullableSerializer(Serialization._StringSerializer).serialize(value.commentText),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ShowcaseUnresolveCommentDetails {
            switch json {
            case .dictionary(let dict):
                let eventUuid = try Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                let commentText = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["comment_text"] ?? .null)
                return ShowcaseUnresolveCommentDetails(eventUuid: eventUuid, commentText: commentText)
            default:
                throw JSONSerializerError.deserializeError(type: ShowcaseUnresolveCommentDetails.self, json: json)
            }
        }
    }

    /// The ShowcaseUnresolveCommentType struct
    public class ShowcaseUnresolveCommentType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try ShowcaseUnresolveCommentTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ShowcaseUnresolveCommentTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ShowcaseUnresolveCommentType: \(error)"
            }
        }
    }

    public class ShowcaseUnresolveCommentTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ShowcaseUnresolveCommentType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ShowcaseUnresolveCommentType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return ShowcaseUnresolveCommentType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: ShowcaseUnresolveCommentType.self, json: json)
            }
        }
    }

    /// Restored showcase (old version).
    public class ShowcaseUntrashedDeprecatedDetails: CustomStringConvertible, JSONRepresentable {
        /// Event unique identifier.
        public let eventUuid: String
        public init(eventUuid: String) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
        }

        func json() throws -> JSON {
            try ShowcaseUntrashedDeprecatedDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ShowcaseUntrashedDeprecatedDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ShowcaseUntrashedDeprecatedDetails: \(error)"
            }
        }
    }

    public class ShowcaseUntrashedDeprecatedDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ShowcaseUntrashedDeprecatedDetails) throws -> JSON {
            let output = [
                "event_uuid": try Serialization._StringSerializer.serialize(value.eventUuid),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ShowcaseUntrashedDeprecatedDetails {
            switch json {
            case .dictionary(let dict):
                let eventUuid = try Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                return ShowcaseUntrashedDeprecatedDetails(eventUuid: eventUuid)
            default:
                throw JSONSerializerError.deserializeError(type: ShowcaseUntrashedDeprecatedDetails.self, json: json)
            }
        }
    }

    /// The ShowcaseUntrashedDeprecatedType struct
    public class ShowcaseUntrashedDeprecatedType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try ShowcaseUntrashedDeprecatedTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ShowcaseUntrashedDeprecatedTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ShowcaseUntrashedDeprecatedType: \(error)"
            }
        }
    }

    public class ShowcaseUntrashedDeprecatedTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ShowcaseUntrashedDeprecatedType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ShowcaseUntrashedDeprecatedType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return ShowcaseUntrashedDeprecatedType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: ShowcaseUntrashedDeprecatedType.self, json: json)
            }
        }
    }

    /// Restored showcase.
    public class ShowcaseUntrashedDetails: CustomStringConvertible, JSONRepresentable {
        /// Event unique identifier.
        public let eventUuid: String
        public init(eventUuid: String) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
        }

        func json() throws -> JSON {
            try ShowcaseUntrashedDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ShowcaseUntrashedDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ShowcaseUntrashedDetails: \(error)"
            }
        }
    }

    public class ShowcaseUntrashedDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ShowcaseUntrashedDetails) throws -> JSON {
            let output = [
                "event_uuid": try Serialization._StringSerializer.serialize(value.eventUuid),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ShowcaseUntrashedDetails {
            switch json {
            case .dictionary(let dict):
                let eventUuid = try Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                return ShowcaseUntrashedDetails(eventUuid: eventUuid)
            default:
                throw JSONSerializerError.deserializeError(type: ShowcaseUntrashedDetails.self, json: json)
            }
        }
    }

    /// The ShowcaseUntrashedType struct
    public class ShowcaseUntrashedType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try ShowcaseUntrashedTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ShowcaseUntrashedTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ShowcaseUntrashedType: \(error)"
            }
        }
    }

    public class ShowcaseUntrashedTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ShowcaseUntrashedType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ShowcaseUntrashedType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return ShowcaseUntrashedType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: ShowcaseUntrashedType.self, json: json)
            }
        }
    }

    /// Viewed showcase.
    public class ShowcaseViewDetails: CustomStringConvertible, JSONRepresentable {
        /// Event unique identifier.
        public let eventUuid: String
        public init(eventUuid: String) {
            stringValidator()(eventUuid)
            self.eventUuid = eventUuid
        }

        func json() throws -> JSON {
            try ShowcaseViewDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ShowcaseViewDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ShowcaseViewDetails: \(error)"
            }
        }
    }

    public class ShowcaseViewDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ShowcaseViewDetails) throws -> JSON {
            let output = [
                "event_uuid": try Serialization._StringSerializer.serialize(value.eventUuid),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ShowcaseViewDetails {
            switch json {
            case .dictionary(let dict):
                let eventUuid = try Serialization._StringSerializer.deserialize(dict["event_uuid"] ?? .null)
                return ShowcaseViewDetails(eventUuid: eventUuid)
            default:
                throw JSONSerializerError.deserializeError(type: ShowcaseViewDetails.self, json: json)
            }
        }
    }

    /// The ShowcaseViewType struct
    public class ShowcaseViewType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try ShowcaseViewTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ShowcaseViewTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ShowcaseViewType: \(error)"
            }
        }
    }

    public class ShowcaseViewTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ShowcaseViewType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ShowcaseViewType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return ShowcaseViewType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: ShowcaseViewType.self, json: json)
            }
        }
    }

    /// Ended admin sign-in-as session.
    public class SignInAsSessionEndDetails: CustomStringConvertible, JSONRepresentable {
        func json() throws -> JSON {
            try SignInAsSessionEndDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SignInAsSessionEndDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SignInAsSessionEndDetails: \(error)"
            }
        }
    }

    public class SignInAsSessionEndDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SignInAsSessionEndDetails) throws -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SignInAsSessionEndDetails {
            switch json {
            case .dictionary:
                return SignInAsSessionEndDetails()
            default:
                throw JSONSerializerError.deserializeError(type: SignInAsSessionEndDetails.self, json: json)
            }
        }
    }

    /// The SignInAsSessionEndType struct
    public class SignInAsSessionEndType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try SignInAsSessionEndTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SignInAsSessionEndTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SignInAsSessionEndType: \(error)"
            }
        }
    }

    public class SignInAsSessionEndTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SignInAsSessionEndType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SignInAsSessionEndType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return SignInAsSessionEndType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: SignInAsSessionEndType.self, json: json)
            }
        }
    }

    /// Started admin sign-in-as session.
    public class SignInAsSessionStartDetails: CustomStringConvertible, JSONRepresentable {
        func json() throws -> JSON {
            try SignInAsSessionStartDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SignInAsSessionStartDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SignInAsSessionStartDetails: \(error)"
            }
        }
    }

    public class SignInAsSessionStartDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SignInAsSessionStartDetails) throws -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SignInAsSessionStartDetails {
            switch json {
            case .dictionary:
                return SignInAsSessionStartDetails()
            default:
                throw JSONSerializerError.deserializeError(type: SignInAsSessionStartDetails.self, json: json)
            }
        }
    }

    /// The SignInAsSessionStartType struct
    public class SignInAsSessionStartType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try SignInAsSessionStartTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SignInAsSessionStartTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SignInAsSessionStartType: \(error)"
            }
        }
    }

    public class SignInAsSessionStartTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SignInAsSessionStartType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SignInAsSessionStartType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return SignInAsSessionStartType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: SignInAsSessionStartType.self, json: json)
            }
        }
    }

    /// Changed default Smart Sync setting for team members.
    public class SmartSyncChangePolicyDetails: CustomStringConvertible, JSONRepresentable {
        /// New smart sync policy.
        public let newValue: TeamPolicies.SmartSyncPolicy?
        /// Previous smart sync policy.
        public let previousValue: TeamPolicies.SmartSyncPolicy?
        public init(newValue: TeamPolicies.SmartSyncPolicy? = nil, previousValue: TeamPolicies.SmartSyncPolicy? = nil) {
            self.newValue = newValue
            self.previousValue = previousValue
        }

        func json() throws -> JSON {
            try SmartSyncChangePolicyDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SmartSyncChangePolicyDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SmartSyncChangePolicyDetails: \(error)"
            }
        }
    }

    public class SmartSyncChangePolicyDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SmartSyncChangePolicyDetails) throws -> JSON {
            let output = [
                "new_value": try NullableSerializer(TeamPolicies.SmartSyncPolicySerializer()).serialize(value.newValue),
                "previous_value": try NullableSerializer(TeamPolicies.SmartSyncPolicySerializer()).serialize(value.previousValue),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SmartSyncChangePolicyDetails {
            switch json {
            case .dictionary(let dict):
                let newValue = try NullableSerializer(TeamPolicies.SmartSyncPolicySerializer()).deserialize(dict["new_value"] ?? .null)
                let previousValue = try NullableSerializer(TeamPolicies.SmartSyncPolicySerializer()).deserialize(dict["previous_value"] ?? .null)
                return SmartSyncChangePolicyDetails(newValue: newValue, previousValue: previousValue)
            default:
                throw JSONSerializerError.deserializeError(type: SmartSyncChangePolicyDetails.self, json: json)
            }
        }
    }

    /// The SmartSyncChangePolicyType struct
    public class SmartSyncChangePolicyType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try SmartSyncChangePolicyTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SmartSyncChangePolicyTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SmartSyncChangePolicyType: \(error)"
            }
        }
    }

    public class SmartSyncChangePolicyTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SmartSyncChangePolicyType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SmartSyncChangePolicyType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return SmartSyncChangePolicyType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: SmartSyncChangePolicyType.self, json: json)
            }
        }
    }

    /// Created Smart Sync non-admin devices report.
    public class SmartSyncCreateAdminPrivilegeReportDetails: CustomStringConvertible, JSONRepresentable {
        func json() throws -> JSON {
            try SmartSyncCreateAdminPrivilegeReportDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SmartSyncCreateAdminPrivilegeReportDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SmartSyncCreateAdminPrivilegeReportDetails: \(error)"
            }
        }
    }

    public class SmartSyncCreateAdminPrivilegeReportDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SmartSyncCreateAdminPrivilegeReportDetails) throws -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SmartSyncCreateAdminPrivilegeReportDetails {
            switch json {
            case .dictionary:
                return SmartSyncCreateAdminPrivilegeReportDetails()
            default:
                throw JSONSerializerError.deserializeError(type: SmartSyncCreateAdminPrivilegeReportDetails.self, json: json)
            }
        }
    }

    /// The SmartSyncCreateAdminPrivilegeReportType struct
    public class SmartSyncCreateAdminPrivilegeReportType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try SmartSyncCreateAdminPrivilegeReportTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SmartSyncCreateAdminPrivilegeReportTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SmartSyncCreateAdminPrivilegeReportType: \(error)"
            }
        }
    }

    public class SmartSyncCreateAdminPrivilegeReportTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SmartSyncCreateAdminPrivilegeReportType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SmartSyncCreateAdminPrivilegeReportType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return SmartSyncCreateAdminPrivilegeReportType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: SmartSyncCreateAdminPrivilegeReportType.self, json: json)
            }
        }
    }

    /// Opted team into Smart Sync.
    public class SmartSyncNotOptOutDetails: CustomStringConvertible, JSONRepresentable {
        /// Previous Smart Sync opt out policy.
        public let previousValue: TeamLog.SmartSyncOptOutPolicy
        /// New Smart Sync opt out policy.
        public let newValue: TeamLog.SmartSyncOptOutPolicy
        public init(previousValue: TeamLog.SmartSyncOptOutPolicy, newValue: TeamLog.SmartSyncOptOutPolicy) {
            self.previousValue = previousValue
            self.newValue = newValue
        }

        func json() throws -> JSON {
            try SmartSyncNotOptOutDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SmartSyncNotOptOutDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SmartSyncNotOptOutDetails: \(error)"
            }
        }
    }

    public class SmartSyncNotOptOutDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SmartSyncNotOptOutDetails) throws -> JSON {
            let output = [
                "previous_value": try TeamLog.SmartSyncOptOutPolicySerializer().serialize(value.previousValue),
                "new_value": try TeamLog.SmartSyncOptOutPolicySerializer().serialize(value.newValue),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SmartSyncNotOptOutDetails {
            switch json {
            case .dictionary(let dict):
                let previousValue = try TeamLog.SmartSyncOptOutPolicySerializer().deserialize(dict["previous_value"] ?? .null)
                let newValue = try TeamLog.SmartSyncOptOutPolicySerializer().deserialize(dict["new_value"] ?? .null)
                return SmartSyncNotOptOutDetails(previousValue: previousValue, newValue: newValue)
            default:
                throw JSONSerializerError.deserializeError(type: SmartSyncNotOptOutDetails.self, json: json)
            }
        }
    }

    /// The SmartSyncNotOptOutType struct
    public class SmartSyncNotOptOutType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try SmartSyncNotOptOutTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SmartSyncNotOptOutTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SmartSyncNotOptOutType: \(error)"
            }
        }
    }

    public class SmartSyncNotOptOutTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SmartSyncNotOptOutType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SmartSyncNotOptOutType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return SmartSyncNotOptOutType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: SmartSyncNotOptOutType.self, json: json)
            }
        }
    }

    /// Opted team out of Smart Sync.
    public class SmartSyncOptOutDetails: CustomStringConvertible, JSONRepresentable {
        /// Previous Smart Sync opt out policy.
        public let previousValue: TeamLog.SmartSyncOptOutPolicy
        /// New Smart Sync opt out policy.
        public let newValue: TeamLog.SmartSyncOptOutPolicy
        public init(previousValue: TeamLog.SmartSyncOptOutPolicy, newValue: TeamLog.SmartSyncOptOutPolicy) {
            self.previousValue = previousValue
            self.newValue = newValue
        }

        func json() throws -> JSON {
            try SmartSyncOptOutDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SmartSyncOptOutDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SmartSyncOptOutDetails: \(error)"
            }
        }
    }

    public class SmartSyncOptOutDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SmartSyncOptOutDetails) throws -> JSON {
            let output = [
                "previous_value": try TeamLog.SmartSyncOptOutPolicySerializer().serialize(value.previousValue),
                "new_value": try TeamLog.SmartSyncOptOutPolicySerializer().serialize(value.newValue),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SmartSyncOptOutDetails {
            switch json {
            case .dictionary(let dict):
                let previousValue = try TeamLog.SmartSyncOptOutPolicySerializer().deserialize(dict["previous_value"] ?? .null)
                let newValue = try TeamLog.SmartSyncOptOutPolicySerializer().deserialize(dict["new_value"] ?? .null)
                return SmartSyncOptOutDetails(previousValue: previousValue, newValue: newValue)
            default:
                throw JSONSerializerError.deserializeError(type: SmartSyncOptOutDetails.self, json: json)
            }
        }
    }

    /// The SmartSyncOptOutPolicy union
    public enum SmartSyncOptOutPolicy: CustomStringConvertible, JSONRepresentable {
        /// An unspecified error.
        case default_
        /// An unspecified error.
        case optedOut
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try SmartSyncOptOutPolicySerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SmartSyncOptOutPolicySerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SmartSyncOptOutPolicy: \(error)"
            }
        }
    }

    public class SmartSyncOptOutPolicySerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SmartSyncOptOutPolicy) throws -> JSON {
            switch value {
            case .default_:
                var d = [String: JSON]()
                d[".tag"] = .str("default")
                return .dictionary(d)
            case .optedOut:
                var d = [String: JSON]()
                d[".tag"] = .str("opted_out")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> SmartSyncOptOutPolicy {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "default":
                    return SmartSyncOptOutPolicy.default_
                case "opted_out":
                    return SmartSyncOptOutPolicy.optedOut
                case "other":
                    return SmartSyncOptOutPolicy.other
                default:
                    return SmartSyncOptOutPolicy.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: SmartSyncOptOutPolicy.self, json: json)
            }
        }
    }

    /// The SmartSyncOptOutType struct
    public class SmartSyncOptOutType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try SmartSyncOptOutTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SmartSyncOptOutTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SmartSyncOptOutType: \(error)"
            }
        }
    }

    public class SmartSyncOptOutTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SmartSyncOptOutType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SmartSyncOptOutType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return SmartSyncOptOutType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: SmartSyncOptOutType.self, json: json)
            }
        }
    }

    /// Changed automatic Smart Sync setting for team.
    public class SmarterSmartSyncPolicyChangedDetails: CustomStringConvertible, JSONRepresentable {
        /// Previous automatic Smart Sync setting.
        public let previousValue: TeamPolicies.SmarterSmartSyncPolicyState
        /// New automatic Smart Sync setting.
        public let newValue: TeamPolicies.SmarterSmartSyncPolicyState
        public init(previousValue: TeamPolicies.SmarterSmartSyncPolicyState, newValue: TeamPolicies.SmarterSmartSyncPolicyState) {
            self.previousValue = previousValue
            self.newValue = newValue
        }

        func json() throws -> JSON {
            try SmarterSmartSyncPolicyChangedDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SmarterSmartSyncPolicyChangedDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SmarterSmartSyncPolicyChangedDetails: \(error)"
            }
        }
    }

    public class SmarterSmartSyncPolicyChangedDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SmarterSmartSyncPolicyChangedDetails) throws -> JSON {
            let output = [
                "previous_value": try TeamPolicies.SmarterSmartSyncPolicyStateSerializer().serialize(value.previousValue),
                "new_value": try TeamPolicies.SmarterSmartSyncPolicyStateSerializer().serialize(value.newValue),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SmarterSmartSyncPolicyChangedDetails {
            switch json {
            case .dictionary(let dict):
                let previousValue = try TeamPolicies.SmarterSmartSyncPolicyStateSerializer().deserialize(dict["previous_value"] ?? .null)
                let newValue = try TeamPolicies.SmarterSmartSyncPolicyStateSerializer().deserialize(dict["new_value"] ?? .null)
                return SmarterSmartSyncPolicyChangedDetails(previousValue: previousValue, newValue: newValue)
            default:
                throw JSONSerializerError.deserializeError(type: SmarterSmartSyncPolicyChangedDetails.self, json: json)
            }
        }
    }

    /// The SmarterSmartSyncPolicyChangedType struct
    public class SmarterSmartSyncPolicyChangedType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try SmarterSmartSyncPolicyChangedTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SmarterSmartSyncPolicyChangedTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SmarterSmartSyncPolicyChangedType: \(error)"
            }
        }
    }

    public class SmarterSmartSyncPolicyChangedTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SmarterSmartSyncPolicyChangedType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SmarterSmartSyncPolicyChangedType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return SmarterSmartSyncPolicyChangedType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: SmarterSmartSyncPolicyChangedType.self, json: json)
            }
        }
    }

    /// Space limit alert policy
    public enum SpaceCapsType: CustomStringConvertible, JSONRepresentable {
        /// An unspecified error.
        case hard
        /// An unspecified error.
        case off
        /// An unspecified error.
        case soft
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try SpaceCapsTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SpaceCapsTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SpaceCapsType: \(error)"
            }
        }
    }

    public class SpaceCapsTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SpaceCapsType) throws -> JSON {
            switch value {
            case .hard:
                var d = [String: JSON]()
                d[".tag"] = .str("hard")
                return .dictionary(d)
            case .off:
                var d = [String: JSON]()
                d[".tag"] = .str("off")
                return .dictionary(d)
            case .soft:
                var d = [String: JSON]()
                d[".tag"] = .str("soft")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> SpaceCapsType {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "hard":
                    return SpaceCapsType.hard
                case "off":
                    return SpaceCapsType.off
                case "soft":
                    return SpaceCapsType.soft
                case "other":
                    return SpaceCapsType.other
                default:
                    return SpaceCapsType.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: SpaceCapsType.self, json: json)
            }
        }
    }

    /// The SpaceLimitsStatus union
    public enum SpaceLimitsStatus: CustomStringConvertible, JSONRepresentable {
        /// An unspecified error.
        case nearQuota
        /// An unspecified error.
        case overQuota
        /// An unspecified error.
        case withinQuota
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try SpaceLimitsStatusSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SpaceLimitsStatusSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SpaceLimitsStatus: \(error)"
            }
        }
    }

    public class SpaceLimitsStatusSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SpaceLimitsStatus) throws -> JSON {
            switch value {
            case .nearQuota:
                var d = [String: JSON]()
                d[".tag"] = .str("near_quota")
                return .dictionary(d)
            case .overQuota:
                var d = [String: JSON]()
                d[".tag"] = .str("over_quota")
                return .dictionary(d)
            case .withinQuota:
                var d = [String: JSON]()
                d[".tag"] = .str("within_quota")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> SpaceLimitsStatus {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "near_quota":
                    return SpaceLimitsStatus.nearQuota
                case "over_quota":
                    return SpaceLimitsStatus.overQuota
                case "within_quota":
                    return SpaceLimitsStatus.withinQuota
                case "other":
                    return SpaceLimitsStatus.other
                default:
                    return SpaceLimitsStatus.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: SpaceLimitsStatus.self, json: json)
            }
        }
    }

    /// Added X.509 certificate for SSO.
    public class SsoAddCertDetails: CustomStringConvertible, JSONRepresentable {
        /// SSO certificate details.
        public let certificateDetails: TeamLog.Certificate
        public init(certificateDetails: TeamLog.Certificate) {
            self.certificateDetails = certificateDetails
        }

        func json() throws -> JSON {
            try SsoAddCertDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SsoAddCertDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SsoAddCertDetails: \(error)"
            }
        }
    }

    public class SsoAddCertDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SsoAddCertDetails) throws -> JSON {
            let output = [
                "certificate_details": try TeamLog.CertificateSerializer().serialize(value.certificateDetails),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SsoAddCertDetails {
            switch json {
            case .dictionary(let dict):
                let certificateDetails = try TeamLog.CertificateSerializer().deserialize(dict["certificate_details"] ?? .null)
                return SsoAddCertDetails(certificateDetails: certificateDetails)
            default:
                throw JSONSerializerError.deserializeError(type: SsoAddCertDetails.self, json: json)
            }
        }
    }

    /// The SsoAddCertType struct
    public class SsoAddCertType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try SsoAddCertTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SsoAddCertTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SsoAddCertType: \(error)"
            }
        }
    }

    public class SsoAddCertTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SsoAddCertType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SsoAddCertType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return SsoAddCertType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: SsoAddCertType.self, json: json)
            }
        }
    }

    /// Added sign-in URL for SSO.
    public class SsoAddLoginUrlDetails: CustomStringConvertible, JSONRepresentable {
        /// New single sign-on login URL.
        public let newValue: String
        public init(newValue: String) {
            stringValidator()(newValue)
            self.newValue = newValue
        }

        func json() throws -> JSON {
            try SsoAddLoginUrlDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SsoAddLoginUrlDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SsoAddLoginUrlDetails: \(error)"
            }
        }
    }

    public class SsoAddLoginUrlDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SsoAddLoginUrlDetails) throws -> JSON {
            let output = [
                "new_value": try Serialization._StringSerializer.serialize(value.newValue),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SsoAddLoginUrlDetails {
            switch json {
            case .dictionary(let dict):
                let newValue = try Serialization._StringSerializer.deserialize(dict["new_value"] ?? .null)
                return SsoAddLoginUrlDetails(newValue: newValue)
            default:
                throw JSONSerializerError.deserializeError(type: SsoAddLoginUrlDetails.self, json: json)
            }
        }
    }

    /// The SsoAddLoginUrlType struct
    public class SsoAddLoginUrlType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try SsoAddLoginUrlTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SsoAddLoginUrlTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SsoAddLoginUrlType: \(error)"
            }
        }
    }

    public class SsoAddLoginUrlTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SsoAddLoginUrlType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SsoAddLoginUrlType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return SsoAddLoginUrlType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: SsoAddLoginUrlType.self, json: json)
            }
        }
    }

    /// Added sign-out URL for SSO.
    public class SsoAddLogoutUrlDetails: CustomStringConvertible, JSONRepresentable {
        /// New single sign-on logout URL.
        public let newValue: String?
        public init(newValue: String? = nil) {
            nullableValidator(stringValidator())(newValue)
            self.newValue = newValue
        }

        func json() throws -> JSON {
            try SsoAddLogoutUrlDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SsoAddLogoutUrlDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SsoAddLogoutUrlDetails: \(error)"
            }
        }
    }

    public class SsoAddLogoutUrlDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SsoAddLogoutUrlDetails) throws -> JSON {
            let output = [
                "new_value": try NullableSerializer(Serialization._StringSerializer).serialize(value.newValue),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SsoAddLogoutUrlDetails {
            switch json {
            case .dictionary(let dict):
                let newValue = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["new_value"] ?? .null)
                return SsoAddLogoutUrlDetails(newValue: newValue)
            default:
                throw JSONSerializerError.deserializeError(type: SsoAddLogoutUrlDetails.self, json: json)
            }
        }
    }

    /// The SsoAddLogoutUrlType struct
    public class SsoAddLogoutUrlType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try SsoAddLogoutUrlTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SsoAddLogoutUrlTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SsoAddLogoutUrlType: \(error)"
            }
        }
    }

    public class SsoAddLogoutUrlTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SsoAddLogoutUrlType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SsoAddLogoutUrlType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return SsoAddLogoutUrlType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: SsoAddLogoutUrlType.self, json: json)
            }
        }
    }

    /// Changed X.509 certificate for SSO.
    public class SsoChangeCertDetails: CustomStringConvertible, JSONRepresentable {
        /// Previous SSO certificate details. Might be missing due to historical data gap.
        public let previousCertificateDetails: TeamLog.Certificate?
        /// New SSO certificate details.
        public let newCertificateDetails: TeamLog.Certificate
        public init(newCertificateDetails: TeamLog.Certificate, previousCertificateDetails: TeamLog.Certificate? = nil) {
            self.previousCertificateDetails = previousCertificateDetails
            self.newCertificateDetails = newCertificateDetails
        }

        func json() throws -> JSON {
            try SsoChangeCertDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SsoChangeCertDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SsoChangeCertDetails: \(error)"
            }
        }
    }

    public class SsoChangeCertDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SsoChangeCertDetails) throws -> JSON {
            let output = [
                "new_certificate_details": try TeamLog.CertificateSerializer().serialize(value.newCertificateDetails),
                "previous_certificate_details": try NullableSerializer(TeamLog.CertificateSerializer()).serialize(value.previousCertificateDetails),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SsoChangeCertDetails {
            switch json {
            case .dictionary(let dict):
                let newCertificateDetails = try TeamLog.CertificateSerializer().deserialize(dict["new_certificate_details"] ?? .null)
                let previousCertificateDetails = try NullableSerializer(TeamLog.CertificateSerializer())
                    .deserialize(dict["previous_certificate_details"] ?? .null)
                return SsoChangeCertDetails(newCertificateDetails: newCertificateDetails, previousCertificateDetails: previousCertificateDetails)
            default:
                throw JSONSerializerError.deserializeError(type: SsoChangeCertDetails.self, json: json)
            }
        }
    }

    /// The SsoChangeCertType struct
    public class SsoChangeCertType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try SsoChangeCertTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SsoChangeCertTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SsoChangeCertType: \(error)"
            }
        }
    }

    public class SsoChangeCertTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SsoChangeCertType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SsoChangeCertType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return SsoChangeCertType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: SsoChangeCertType.self, json: json)
            }
        }
    }

    /// Changed sign-in URL for SSO.
    public class SsoChangeLoginUrlDetails: CustomStringConvertible, JSONRepresentable {
        /// Previous single sign-on login URL.
        public let previousValue: String
        /// New single sign-on login URL.
        public let newValue: String
        public init(previousValue: String, newValue: String) {
            stringValidator()(previousValue)
            self.previousValue = previousValue
            stringValidator()(newValue)
            self.newValue = newValue
        }

        func json() throws -> JSON {
            try SsoChangeLoginUrlDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SsoChangeLoginUrlDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SsoChangeLoginUrlDetails: \(error)"
            }
        }
    }

    public class SsoChangeLoginUrlDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SsoChangeLoginUrlDetails) throws -> JSON {
            let output = [
                "previous_value": try Serialization._StringSerializer.serialize(value.previousValue),
                "new_value": try Serialization._StringSerializer.serialize(value.newValue),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SsoChangeLoginUrlDetails {
            switch json {
            case .dictionary(let dict):
                let previousValue = try Serialization._StringSerializer.deserialize(dict["previous_value"] ?? .null)
                let newValue = try Serialization._StringSerializer.deserialize(dict["new_value"] ?? .null)
                return SsoChangeLoginUrlDetails(previousValue: previousValue, newValue: newValue)
            default:
                throw JSONSerializerError.deserializeError(type: SsoChangeLoginUrlDetails.self, json: json)
            }
        }
    }

    /// The SsoChangeLoginUrlType struct
    public class SsoChangeLoginUrlType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try SsoChangeLoginUrlTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SsoChangeLoginUrlTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SsoChangeLoginUrlType: \(error)"
            }
        }
    }

    public class SsoChangeLoginUrlTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SsoChangeLoginUrlType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SsoChangeLoginUrlType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return SsoChangeLoginUrlType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: SsoChangeLoginUrlType.self, json: json)
            }
        }
    }

    /// Changed sign-out URL for SSO.
    public class SsoChangeLogoutUrlDetails: CustomStringConvertible, JSONRepresentable {
        /// Previous single sign-on logout URL. Might be missing due to historical data gap.
        public let previousValue: String?
        /// New single sign-on logout URL.
        public let newValue: String?
        public init(previousValue: String? = nil, newValue: String? = nil) {
            nullableValidator(stringValidator())(previousValue)
            self.previousValue = previousValue
            nullableValidator(stringValidator())(newValue)
            self.newValue = newValue
        }

        func json() throws -> JSON {
            try SsoChangeLogoutUrlDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SsoChangeLogoutUrlDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SsoChangeLogoutUrlDetails: \(error)"
            }
        }
    }

    public class SsoChangeLogoutUrlDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SsoChangeLogoutUrlDetails) throws -> JSON {
            let output = [
                "previous_value": try NullableSerializer(Serialization._StringSerializer).serialize(value.previousValue),
                "new_value": try NullableSerializer(Serialization._StringSerializer).serialize(value.newValue),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SsoChangeLogoutUrlDetails {
            switch json {
            case .dictionary(let dict):
                let previousValue = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["previous_value"] ?? .null)
                let newValue = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["new_value"] ?? .null)
                return SsoChangeLogoutUrlDetails(previousValue: previousValue, newValue: newValue)
            default:
                throw JSONSerializerError.deserializeError(type: SsoChangeLogoutUrlDetails.self, json: json)
            }
        }
    }

    /// The SsoChangeLogoutUrlType struct
    public class SsoChangeLogoutUrlType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try SsoChangeLogoutUrlTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SsoChangeLogoutUrlTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SsoChangeLogoutUrlType: \(error)"
            }
        }
    }

    public class SsoChangeLogoutUrlTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SsoChangeLogoutUrlType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SsoChangeLogoutUrlType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return SsoChangeLogoutUrlType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: SsoChangeLogoutUrlType.self, json: json)
            }
        }
    }

    /// Changed single sign-on setting for team.
    public class SsoChangePolicyDetails: CustomStringConvertible, JSONRepresentable {
        /// New single sign-on policy.
        public let newValue: TeamPolicies.SsoPolicy
        /// Previous single sign-on policy. Might be missing due to historical data gap.
        public let previousValue: TeamPolicies.SsoPolicy?
        public init(newValue: TeamPolicies.SsoPolicy, previousValue: TeamPolicies.SsoPolicy? = nil) {
            self.newValue = newValue
            self.previousValue = previousValue
        }

        func json() throws -> JSON {
            try SsoChangePolicyDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SsoChangePolicyDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SsoChangePolicyDetails: \(error)"
            }
        }
    }

    public class SsoChangePolicyDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SsoChangePolicyDetails) throws -> JSON {
            let output = [
                "new_value": try TeamPolicies.SsoPolicySerializer().serialize(value.newValue),
                "previous_value": try NullableSerializer(TeamPolicies.SsoPolicySerializer()).serialize(value.previousValue),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SsoChangePolicyDetails {
            switch json {
            case .dictionary(let dict):
                let newValue = try TeamPolicies.SsoPolicySerializer().deserialize(dict["new_value"] ?? .null)
                let previousValue = try NullableSerializer(TeamPolicies.SsoPolicySerializer()).deserialize(dict["previous_value"] ?? .null)
                return SsoChangePolicyDetails(newValue: newValue, previousValue: previousValue)
            default:
                throw JSONSerializerError.deserializeError(type: SsoChangePolicyDetails.self, json: json)
            }
        }
    }

    /// The SsoChangePolicyType struct
    public class SsoChangePolicyType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try SsoChangePolicyTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SsoChangePolicyTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SsoChangePolicyType: \(error)"
            }
        }
    }

    public class SsoChangePolicyTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SsoChangePolicyType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SsoChangePolicyType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return SsoChangePolicyType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: SsoChangePolicyType.self, json: json)
            }
        }
    }

    /// Changed SAML identity mode for SSO.
    public class SsoChangeSamlIdentityModeDetails: CustomStringConvertible, JSONRepresentable {
        /// Previous single sign-on identity mode.
        public let previousValue: Int64
        /// New single sign-on identity mode.
        public let newValue: Int64
        public init(previousValue: Int64, newValue: Int64) {
            comparableValidator()(previousValue)
            self.previousValue = previousValue
            comparableValidator()(newValue)
            self.newValue = newValue
        }

        func json() throws -> JSON {
            try SsoChangeSamlIdentityModeDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SsoChangeSamlIdentityModeDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SsoChangeSamlIdentityModeDetails: \(error)"
            }
        }
    }

    public class SsoChangeSamlIdentityModeDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SsoChangeSamlIdentityModeDetails) throws -> JSON {
            let output = [
                "previous_value": try Serialization._Int64Serializer.serialize(value.previousValue),
                "new_value": try Serialization._Int64Serializer.serialize(value.newValue),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SsoChangeSamlIdentityModeDetails {
            switch json {
            case .dictionary(let dict):
                let previousValue = try Serialization._Int64Serializer.deserialize(dict["previous_value"] ?? .null)
                let newValue = try Serialization._Int64Serializer.deserialize(dict["new_value"] ?? .null)
                return SsoChangeSamlIdentityModeDetails(previousValue: previousValue, newValue: newValue)
            default:
                throw JSONSerializerError.deserializeError(type: SsoChangeSamlIdentityModeDetails.self, json: json)
            }
        }
    }

    /// The SsoChangeSamlIdentityModeType struct
    public class SsoChangeSamlIdentityModeType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try SsoChangeSamlIdentityModeTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SsoChangeSamlIdentityModeTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SsoChangeSamlIdentityModeType: \(error)"
            }
        }
    }

    public class SsoChangeSamlIdentityModeTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SsoChangeSamlIdentityModeType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SsoChangeSamlIdentityModeType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return SsoChangeSamlIdentityModeType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: SsoChangeSamlIdentityModeType.self, json: json)
            }
        }
    }

    /// Failed to sign in via SSO.
    public class SsoErrorDetails: CustomStringConvertible, JSONRepresentable {
        /// Error details.
        public let errorDetails: TeamLog.FailureDetailsLogInfo
        public init(errorDetails: TeamLog.FailureDetailsLogInfo) {
            self.errorDetails = errorDetails
        }

        func json() throws -> JSON {
            try SsoErrorDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SsoErrorDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SsoErrorDetails: \(error)"
            }
        }
    }

    public class SsoErrorDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SsoErrorDetails) throws -> JSON {
            let output = [
                "error_details": try TeamLog.FailureDetailsLogInfoSerializer().serialize(value.errorDetails),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SsoErrorDetails {
            switch json {
            case .dictionary(let dict):
                let errorDetails = try TeamLog.FailureDetailsLogInfoSerializer().deserialize(dict["error_details"] ?? .null)
                return SsoErrorDetails(errorDetails: errorDetails)
            default:
                throw JSONSerializerError.deserializeError(type: SsoErrorDetails.self, json: json)
            }
        }
    }

    /// The SsoErrorType struct
    public class SsoErrorType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try SsoErrorTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SsoErrorTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SsoErrorType: \(error)"
            }
        }
    }

    public class SsoErrorTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SsoErrorType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SsoErrorType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return SsoErrorType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: SsoErrorType.self, json: json)
            }
        }
    }

    /// Removed X.509 certificate for SSO.
    public class SsoRemoveCertDetails: CustomStringConvertible, JSONRepresentable {
        func json() throws -> JSON {
            try SsoRemoveCertDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SsoRemoveCertDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SsoRemoveCertDetails: \(error)"
            }
        }
    }

    public class SsoRemoveCertDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SsoRemoveCertDetails) throws -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SsoRemoveCertDetails {
            switch json {
            case .dictionary:
                return SsoRemoveCertDetails()
            default:
                throw JSONSerializerError.deserializeError(type: SsoRemoveCertDetails.self, json: json)
            }
        }
    }

    /// The SsoRemoveCertType struct
    public class SsoRemoveCertType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try SsoRemoveCertTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SsoRemoveCertTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SsoRemoveCertType: \(error)"
            }
        }
    }

    public class SsoRemoveCertTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SsoRemoveCertType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SsoRemoveCertType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return SsoRemoveCertType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: SsoRemoveCertType.self, json: json)
            }
        }
    }

    /// Removed sign-in URL for SSO.
    public class SsoRemoveLoginUrlDetails: CustomStringConvertible, JSONRepresentable {
        /// Previous single sign-on login URL.
        public let previousValue: String
        public init(previousValue: String) {
            stringValidator()(previousValue)
            self.previousValue = previousValue
        }

        func json() throws -> JSON {
            try SsoRemoveLoginUrlDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SsoRemoveLoginUrlDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SsoRemoveLoginUrlDetails: \(error)"
            }
        }
    }

    public class SsoRemoveLoginUrlDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SsoRemoveLoginUrlDetails) throws -> JSON {
            let output = [
                "previous_value": try Serialization._StringSerializer.serialize(value.previousValue),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SsoRemoveLoginUrlDetails {
            switch json {
            case .dictionary(let dict):
                let previousValue = try Serialization._StringSerializer.deserialize(dict["previous_value"] ?? .null)
                return SsoRemoveLoginUrlDetails(previousValue: previousValue)
            default:
                throw JSONSerializerError.deserializeError(type: SsoRemoveLoginUrlDetails.self, json: json)
            }
        }
    }

    /// The SsoRemoveLoginUrlType struct
    public class SsoRemoveLoginUrlType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try SsoRemoveLoginUrlTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SsoRemoveLoginUrlTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SsoRemoveLoginUrlType: \(error)"
            }
        }
    }

    public class SsoRemoveLoginUrlTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SsoRemoveLoginUrlType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SsoRemoveLoginUrlType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return SsoRemoveLoginUrlType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: SsoRemoveLoginUrlType.self, json: json)
            }
        }
    }

    /// Removed sign-out URL for SSO.
    public class SsoRemoveLogoutUrlDetails: CustomStringConvertible, JSONRepresentable {
        /// Previous single sign-on logout URL.
        public let previousValue: String
        public init(previousValue: String) {
            stringValidator()(previousValue)
            self.previousValue = previousValue
        }

        func json() throws -> JSON {
            try SsoRemoveLogoutUrlDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SsoRemoveLogoutUrlDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SsoRemoveLogoutUrlDetails: \(error)"
            }
        }
    }

    public class SsoRemoveLogoutUrlDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SsoRemoveLogoutUrlDetails) throws -> JSON {
            let output = [
                "previous_value": try Serialization._StringSerializer.serialize(value.previousValue),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SsoRemoveLogoutUrlDetails {
            switch json {
            case .dictionary(let dict):
                let previousValue = try Serialization._StringSerializer.deserialize(dict["previous_value"] ?? .null)
                return SsoRemoveLogoutUrlDetails(previousValue: previousValue)
            default:
                throw JSONSerializerError.deserializeError(type: SsoRemoveLogoutUrlDetails.self, json: json)
            }
        }
    }

    /// The SsoRemoveLogoutUrlType struct
    public class SsoRemoveLogoutUrlType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try SsoRemoveLogoutUrlTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SsoRemoveLogoutUrlTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SsoRemoveLogoutUrlType: \(error)"
            }
        }
    }

    public class SsoRemoveLogoutUrlTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SsoRemoveLogoutUrlType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SsoRemoveLogoutUrlType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return SsoRemoveLogoutUrlType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: SsoRemoveLogoutUrlType.self, json: json)
            }
        }
    }

    /// Started enterprise admin session.
    public class StartedEnterpriseAdminSessionDetails: CustomStringConvertible, JSONRepresentable {
        /// More information about the organization or team.
        public let federationExtraDetails: TeamLog.FedExtraDetails
        public init(federationExtraDetails: TeamLog.FedExtraDetails) {
            self.federationExtraDetails = federationExtraDetails
        }

        func json() throws -> JSON {
            try StartedEnterpriseAdminSessionDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try StartedEnterpriseAdminSessionDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for StartedEnterpriseAdminSessionDetails: \(error)"
            }
        }
    }

    public class StartedEnterpriseAdminSessionDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: StartedEnterpriseAdminSessionDetails) throws -> JSON {
            let output = [
                "federation_extra_details": try TeamLog.FedExtraDetailsSerializer().serialize(value.federationExtraDetails),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> StartedEnterpriseAdminSessionDetails {
            switch json {
            case .dictionary(let dict):
                let federationExtraDetails = try TeamLog.FedExtraDetailsSerializer().deserialize(dict["federation_extra_details"] ?? .null)
                return StartedEnterpriseAdminSessionDetails(federationExtraDetails: federationExtraDetails)
            default:
                throw JSONSerializerError.deserializeError(type: StartedEnterpriseAdminSessionDetails.self, json: json)
            }
        }
    }

    /// The StartedEnterpriseAdminSessionType struct
    public class StartedEnterpriseAdminSessionType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try StartedEnterpriseAdminSessionTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try StartedEnterpriseAdminSessionTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for StartedEnterpriseAdminSessionType: \(error)"
            }
        }
    }

    public class StartedEnterpriseAdminSessionTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: StartedEnterpriseAdminSessionType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> StartedEnterpriseAdminSessionType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return StartedEnterpriseAdminSessionType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: StartedEnterpriseAdminSessionType.self, json: json)
            }
        }
    }

    /// Created team activity report.
    public class TeamActivityCreateReportDetails: CustomStringConvertible, JSONRepresentable {
        /// Report start date.
        public let startDate: Date
        /// Report end date.
        public let endDate: Date
        public init(startDate: Date, endDate: Date) {
            self.startDate = startDate
            self.endDate = endDate
        }

        func json() throws -> JSON {
            try TeamActivityCreateReportDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TeamActivityCreateReportDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TeamActivityCreateReportDetails: \(error)"
            }
        }
    }

    public class TeamActivityCreateReportDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TeamActivityCreateReportDetails) throws -> JSON {
            let output = [
                "start_date": try NSDateSerializer("%Y-%m-%dT%H:%M:%SZ").serialize(value.startDate),
                "end_date": try NSDateSerializer("%Y-%m-%dT%H:%M:%SZ").serialize(value.endDate),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> TeamActivityCreateReportDetails {
            switch json {
            case .dictionary(let dict):
                let startDate = try NSDateSerializer("%Y-%m-%dT%H:%M:%SZ").deserialize(dict["start_date"] ?? .null)
                let endDate = try NSDateSerializer("%Y-%m-%dT%H:%M:%SZ").deserialize(dict["end_date"] ?? .null)
                return TeamActivityCreateReportDetails(startDate: startDate, endDate: endDate)
            default:
                throw JSONSerializerError.deserializeError(type: TeamActivityCreateReportDetails.self, json: json)
            }
        }
    }

    /// Couldn't generate team activity report.
    public class TeamActivityCreateReportFailDetails: CustomStringConvertible, JSONRepresentable {
        /// Failure reason.
        public let failureReason: Team.TeamReportFailureReason
        public init(failureReason: Team.TeamReportFailureReason) {
            self.failureReason = failureReason
        }

        func json() throws -> JSON {
            try TeamActivityCreateReportFailDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TeamActivityCreateReportFailDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TeamActivityCreateReportFailDetails: \(error)"
            }
        }
    }

    public class TeamActivityCreateReportFailDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TeamActivityCreateReportFailDetails) throws -> JSON {
            let output = [
                "failure_reason": try Team.TeamReportFailureReasonSerializer().serialize(value.failureReason),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> TeamActivityCreateReportFailDetails {
            switch json {
            case .dictionary(let dict):
                let failureReason = try Team.TeamReportFailureReasonSerializer().deserialize(dict["failure_reason"] ?? .null)
                return TeamActivityCreateReportFailDetails(failureReason: failureReason)
            default:
                throw JSONSerializerError.deserializeError(type: TeamActivityCreateReportFailDetails.self, json: json)
            }
        }
    }

    /// The TeamActivityCreateReportFailType struct
    public class TeamActivityCreateReportFailType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try TeamActivityCreateReportFailTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TeamActivityCreateReportFailTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TeamActivityCreateReportFailType: \(error)"
            }
        }
    }

    public class TeamActivityCreateReportFailTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TeamActivityCreateReportFailType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> TeamActivityCreateReportFailType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return TeamActivityCreateReportFailType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: TeamActivityCreateReportFailType.self, json: json)
            }
        }
    }

    /// The TeamActivityCreateReportType struct
    public class TeamActivityCreateReportType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try TeamActivityCreateReportTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TeamActivityCreateReportTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TeamActivityCreateReportType: \(error)"
            }
        }
    }

    public class TeamActivityCreateReportTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TeamActivityCreateReportType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> TeamActivityCreateReportType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return TeamActivityCreateReportType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: TeamActivityCreateReportType.self, json: json)
            }
        }
    }

    /// Policy for controlling team access to setting up branding feature
    public enum TeamBrandingPolicy: CustomStringConvertible, JSONRepresentable {
        /// An unspecified error.
        case disabled
        /// An unspecified error.
        case enabled
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try TeamBrandingPolicySerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TeamBrandingPolicySerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TeamBrandingPolicy: \(error)"
            }
        }
    }

    public class TeamBrandingPolicySerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TeamBrandingPolicy) throws -> JSON {
            switch value {
            case .disabled:
                var d = [String: JSON]()
                d[".tag"] = .str("disabled")
                return .dictionary(d)
            case .enabled:
                var d = [String: JSON]()
                d[".tag"] = .str("enabled")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> TeamBrandingPolicy {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "disabled":
                    return TeamBrandingPolicy.disabled
                case "enabled":
                    return TeamBrandingPolicy.enabled
                case "other":
                    return TeamBrandingPolicy.other
                default:
                    return TeamBrandingPolicy.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: TeamBrandingPolicy.self, json: json)
            }
        }
    }

    /// Changed team branding policy for team.
    public class TeamBrandingPolicyChangedDetails: CustomStringConvertible, JSONRepresentable {
        /// New team branding policy.
        public let newValue: TeamLog.TeamBrandingPolicy
        /// Previous team branding policy.
        public let previousValue: TeamLog.TeamBrandingPolicy
        public init(newValue: TeamLog.TeamBrandingPolicy, previousValue: TeamLog.TeamBrandingPolicy) {
            self.newValue = newValue
            self.previousValue = previousValue
        }

        func json() throws -> JSON {
            try TeamBrandingPolicyChangedDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TeamBrandingPolicyChangedDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TeamBrandingPolicyChangedDetails: \(error)"
            }
        }
    }

    public class TeamBrandingPolicyChangedDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TeamBrandingPolicyChangedDetails) throws -> JSON {
            let output = [
                "new_value": try TeamLog.TeamBrandingPolicySerializer().serialize(value.newValue),
                "previous_value": try TeamLog.TeamBrandingPolicySerializer().serialize(value.previousValue),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> TeamBrandingPolicyChangedDetails {
            switch json {
            case .dictionary(let dict):
                let newValue = try TeamLog.TeamBrandingPolicySerializer().deserialize(dict["new_value"] ?? .null)
                let previousValue = try TeamLog.TeamBrandingPolicySerializer().deserialize(dict["previous_value"] ?? .null)
                return TeamBrandingPolicyChangedDetails(newValue: newValue, previousValue: previousValue)
            default:
                throw JSONSerializerError.deserializeError(type: TeamBrandingPolicyChangedDetails.self, json: json)
            }
        }
    }

    /// The TeamBrandingPolicyChangedType struct
    public class TeamBrandingPolicyChangedType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try TeamBrandingPolicyChangedTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TeamBrandingPolicyChangedTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TeamBrandingPolicyChangedType: \(error)"
            }
        }
    }

    public class TeamBrandingPolicyChangedTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TeamBrandingPolicyChangedType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> TeamBrandingPolicyChangedType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return TeamBrandingPolicyChangedType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: TeamBrandingPolicyChangedType.self, json: json)
            }
        }
    }

    /// More details about the team.
    public class TeamDetails: CustomStringConvertible, JSONRepresentable {
        /// The name of the team.
        public let team: String
        public init(team: String) {
            stringValidator()(team)
            self.team = team
        }

        func json() throws -> JSON {
            try TeamDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TeamDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TeamDetails: \(error)"
            }
        }
    }

    public class TeamDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TeamDetails) throws -> JSON {
            let output = [
                "team": try Serialization._StringSerializer.serialize(value.team),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> TeamDetails {
            switch json {
            case .dictionary(let dict):
                let team = try Serialization._StringSerializer.deserialize(dict["team"] ?? .null)
                return TeamDetails(team: team)
            default:
                throw JSONSerializerError.deserializeError(type: TeamDetails.self, json: json)
            }
        }
    }

    /// Canceled team encryption key deletion.
    public class TeamEncryptionKeyCancelKeyDeletionDetails: CustomStringConvertible, JSONRepresentable {
        func json() throws -> JSON {
            try TeamEncryptionKeyCancelKeyDeletionDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TeamEncryptionKeyCancelKeyDeletionDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TeamEncryptionKeyCancelKeyDeletionDetails: \(error)"
            }
        }
    }

    public class TeamEncryptionKeyCancelKeyDeletionDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TeamEncryptionKeyCancelKeyDeletionDetails) throws -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> TeamEncryptionKeyCancelKeyDeletionDetails {
            switch json {
            case .dictionary:
                return TeamEncryptionKeyCancelKeyDeletionDetails()
            default:
                throw JSONSerializerError.deserializeError(type: TeamEncryptionKeyCancelKeyDeletionDetails.self, json: json)
            }
        }
    }

    /// The TeamEncryptionKeyCancelKeyDeletionType struct
    public class TeamEncryptionKeyCancelKeyDeletionType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try TeamEncryptionKeyCancelKeyDeletionTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TeamEncryptionKeyCancelKeyDeletionTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TeamEncryptionKeyCancelKeyDeletionType: \(error)"
            }
        }
    }

    public class TeamEncryptionKeyCancelKeyDeletionTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TeamEncryptionKeyCancelKeyDeletionType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> TeamEncryptionKeyCancelKeyDeletionType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return TeamEncryptionKeyCancelKeyDeletionType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: TeamEncryptionKeyCancelKeyDeletionType.self, json: json)
            }
        }
    }

    /// Created team encryption key.
    public class TeamEncryptionKeyCreateKeyDetails: CustomStringConvertible, JSONRepresentable {
        func json() throws -> JSON {
            try TeamEncryptionKeyCreateKeyDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TeamEncryptionKeyCreateKeyDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TeamEncryptionKeyCreateKeyDetails: \(error)"
            }
        }
    }

    public class TeamEncryptionKeyCreateKeyDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TeamEncryptionKeyCreateKeyDetails) throws -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> TeamEncryptionKeyCreateKeyDetails {
            switch json {
            case .dictionary:
                return TeamEncryptionKeyCreateKeyDetails()
            default:
                throw JSONSerializerError.deserializeError(type: TeamEncryptionKeyCreateKeyDetails.self, json: json)
            }
        }
    }

    /// The TeamEncryptionKeyCreateKeyType struct
    public class TeamEncryptionKeyCreateKeyType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try TeamEncryptionKeyCreateKeyTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TeamEncryptionKeyCreateKeyTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TeamEncryptionKeyCreateKeyType: \(error)"
            }
        }
    }

    public class TeamEncryptionKeyCreateKeyTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TeamEncryptionKeyCreateKeyType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> TeamEncryptionKeyCreateKeyType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return TeamEncryptionKeyCreateKeyType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: TeamEncryptionKeyCreateKeyType.self, json: json)
            }
        }
    }

    /// Deleted team encryption key.
    public class TeamEncryptionKeyDeleteKeyDetails: CustomStringConvertible, JSONRepresentable {
        func json() throws -> JSON {
            try TeamEncryptionKeyDeleteKeyDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TeamEncryptionKeyDeleteKeyDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TeamEncryptionKeyDeleteKeyDetails: \(error)"
            }
        }
    }

    public class TeamEncryptionKeyDeleteKeyDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TeamEncryptionKeyDeleteKeyDetails) throws -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> TeamEncryptionKeyDeleteKeyDetails {
            switch json {
            case .dictionary:
                return TeamEncryptionKeyDeleteKeyDetails()
            default:
                throw JSONSerializerError.deserializeError(type: TeamEncryptionKeyDeleteKeyDetails.self, json: json)
            }
        }
    }

    /// The TeamEncryptionKeyDeleteKeyType struct
    public class TeamEncryptionKeyDeleteKeyType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try TeamEncryptionKeyDeleteKeyTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TeamEncryptionKeyDeleteKeyTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TeamEncryptionKeyDeleteKeyType: \(error)"
            }
        }
    }

    public class TeamEncryptionKeyDeleteKeyTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TeamEncryptionKeyDeleteKeyType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> TeamEncryptionKeyDeleteKeyType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return TeamEncryptionKeyDeleteKeyType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: TeamEncryptionKeyDeleteKeyType.self, json: json)
            }
        }
    }

    /// Disabled team encryption key.
    public class TeamEncryptionKeyDisableKeyDetails: CustomStringConvertible, JSONRepresentable {
        func json() throws -> JSON {
            try TeamEncryptionKeyDisableKeyDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TeamEncryptionKeyDisableKeyDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TeamEncryptionKeyDisableKeyDetails: \(error)"
            }
        }
    }

    public class TeamEncryptionKeyDisableKeyDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TeamEncryptionKeyDisableKeyDetails) throws -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> TeamEncryptionKeyDisableKeyDetails {
            switch json {
            case .dictionary:
                return TeamEncryptionKeyDisableKeyDetails()
            default:
                throw JSONSerializerError.deserializeError(type: TeamEncryptionKeyDisableKeyDetails.self, json: json)
            }
        }
    }

    /// The TeamEncryptionKeyDisableKeyType struct
    public class TeamEncryptionKeyDisableKeyType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try TeamEncryptionKeyDisableKeyTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TeamEncryptionKeyDisableKeyTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TeamEncryptionKeyDisableKeyType: \(error)"
            }
        }
    }

    public class TeamEncryptionKeyDisableKeyTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TeamEncryptionKeyDisableKeyType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> TeamEncryptionKeyDisableKeyType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return TeamEncryptionKeyDisableKeyType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: TeamEncryptionKeyDisableKeyType.self, json: json)
            }
        }
    }

    /// Enabled team encryption key.
    public class TeamEncryptionKeyEnableKeyDetails: CustomStringConvertible, JSONRepresentable {
        func json() throws -> JSON {
            try TeamEncryptionKeyEnableKeyDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TeamEncryptionKeyEnableKeyDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TeamEncryptionKeyEnableKeyDetails: \(error)"
            }
        }
    }

    public class TeamEncryptionKeyEnableKeyDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TeamEncryptionKeyEnableKeyDetails) throws -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> TeamEncryptionKeyEnableKeyDetails {
            switch json {
            case .dictionary:
                return TeamEncryptionKeyEnableKeyDetails()
            default:
                throw JSONSerializerError.deserializeError(type: TeamEncryptionKeyEnableKeyDetails.self, json: json)
            }
        }
    }

    /// The TeamEncryptionKeyEnableKeyType struct
    public class TeamEncryptionKeyEnableKeyType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try TeamEncryptionKeyEnableKeyTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TeamEncryptionKeyEnableKeyTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TeamEncryptionKeyEnableKeyType: \(error)"
            }
        }
    }

    public class TeamEncryptionKeyEnableKeyTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TeamEncryptionKeyEnableKeyType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> TeamEncryptionKeyEnableKeyType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return TeamEncryptionKeyEnableKeyType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: TeamEncryptionKeyEnableKeyType.self, json: json)
            }
        }
    }

    /// Rotated team encryption key.
    public class TeamEncryptionKeyRotateKeyDetails: CustomStringConvertible, JSONRepresentable {
        func json() throws -> JSON {
            try TeamEncryptionKeyRotateKeyDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TeamEncryptionKeyRotateKeyDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TeamEncryptionKeyRotateKeyDetails: \(error)"
            }
        }
    }

    public class TeamEncryptionKeyRotateKeyDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TeamEncryptionKeyRotateKeyDetails) throws -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> TeamEncryptionKeyRotateKeyDetails {
            switch json {
            case .dictionary:
                return TeamEncryptionKeyRotateKeyDetails()
            default:
                throw JSONSerializerError.deserializeError(type: TeamEncryptionKeyRotateKeyDetails.self, json: json)
            }
        }
    }

    /// The TeamEncryptionKeyRotateKeyType struct
    public class TeamEncryptionKeyRotateKeyType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try TeamEncryptionKeyRotateKeyTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TeamEncryptionKeyRotateKeyTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TeamEncryptionKeyRotateKeyType: \(error)"
            }
        }
    }

    public class TeamEncryptionKeyRotateKeyTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TeamEncryptionKeyRotateKeyType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> TeamEncryptionKeyRotateKeyType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return TeamEncryptionKeyRotateKeyType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: TeamEncryptionKeyRotateKeyType.self, json: json)
            }
        }
    }

    /// Scheduled encryption key deletion.
    public class TeamEncryptionKeyScheduleKeyDeletionDetails: CustomStringConvertible, JSONRepresentable {
        func json() throws -> JSON {
            try TeamEncryptionKeyScheduleKeyDeletionDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TeamEncryptionKeyScheduleKeyDeletionDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TeamEncryptionKeyScheduleKeyDeletionDetails: \(error)"
            }
        }
    }

    public class TeamEncryptionKeyScheduleKeyDeletionDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TeamEncryptionKeyScheduleKeyDeletionDetails) throws -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> TeamEncryptionKeyScheduleKeyDeletionDetails {
            switch json {
            case .dictionary:
                return TeamEncryptionKeyScheduleKeyDeletionDetails()
            default:
                throw JSONSerializerError.deserializeError(type: TeamEncryptionKeyScheduleKeyDeletionDetails.self, json: json)
            }
        }
    }

    /// The TeamEncryptionKeyScheduleKeyDeletionType struct
    public class TeamEncryptionKeyScheduleKeyDeletionType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try TeamEncryptionKeyScheduleKeyDeletionTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TeamEncryptionKeyScheduleKeyDeletionTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TeamEncryptionKeyScheduleKeyDeletionType: \(error)"
            }
        }
    }

    public class TeamEncryptionKeyScheduleKeyDeletionTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TeamEncryptionKeyScheduleKeyDeletionType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> TeamEncryptionKeyScheduleKeyDeletionType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return TeamEncryptionKeyScheduleKeyDeletionType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: TeamEncryptionKeyScheduleKeyDeletionType.self, json: json)
            }
        }
    }

    /// An audit log event.
    public class TeamEvent: CustomStringConvertible, JSONRepresentable {
        /// The Dropbox timestamp representing when the action was taken.
        public let timestamp_: Date
        /// The category that this type of action belongs to.
        public let eventCategory: TeamLog.EventCategory
        /// The entity who actually performed the action. Might be missing due to historical data gap.
        public let actor: TeamLog.ActorLogInfo?
        /// The origin from which the actor performed the action including information about host, ip address, location,
        /// session, etc. If the action was performed programmatically via the API the origin represents the API
        /// client.
        public let origin: TeamLog.OriginLogInfo?
        /// True if the action involved a non team member either as the actor or as one of the affected users. Might be
        /// missing due to historical data gap.
        public let involveNonTeamMember: Bool?
        /// The user or team on whose behalf the actor performed the action. Might be missing due to historical data
        /// gap.
        public let context: TeamLog.ContextLogInfo?
        /// Zero or more users and/or groups that are affected by the action. Note that this list doesn't include any
        /// actors or users in context.
        public let participants: [TeamLog.ParticipantLogInfo]?
        /// Zero or more content assets involved in the action. Currently these include Dropbox files and folders but in
        /// the future we might add other asset types such as Paper documents, folders, projects, etc.
        public let assets: [TeamLog.AssetLogInfo]?
        /// The particular type of action taken.
        public let eventType: TeamLog.EventType
        /// The variable event schema applicable to this type of action, instantiated with respect to this particular
        /// action.
        public let details: TeamLog.EventDetails
        public init(
            timestamp_: Date,
            eventCategory: TeamLog.EventCategory,
            eventType: TeamLog.EventType,
            details: TeamLog.EventDetails,
            actor: TeamLog.ActorLogInfo? = nil,
            origin: TeamLog.OriginLogInfo? = nil,
            involveNonTeamMember: Bool? = nil,
            context: TeamLog.ContextLogInfo? = nil,
            participants: [TeamLog.ParticipantLogInfo]? = nil,
            assets: [TeamLog.AssetLogInfo]? = nil
        ) {
            self.timestamp_ = timestamp_
            self.eventCategory = eventCategory
            self.actor = actor
            self.origin = origin
            self.involveNonTeamMember = involveNonTeamMember
            self.context = context
            self.participants = participants
            self.assets = assets
            self.eventType = eventType
            self.details = details
        }

        func json() throws -> JSON {
            try TeamEventSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TeamEventSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TeamEvent: \(error)"
            }
        }
    }

    public class TeamEventSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TeamEvent) throws -> JSON {
            let output = [
                "timestamp": try NSDateSerializer("%Y-%m-%dT%H:%M:%SZ").serialize(value.timestamp_),
                "event_category": try TeamLog.EventCategorySerializer().serialize(value.eventCategory),
                "event_type": try TeamLog.EventTypeSerializer().serialize(value.eventType),
                "details": try TeamLog.EventDetailsSerializer().serialize(value.details),
                "actor": try NullableSerializer(TeamLog.ActorLogInfoSerializer()).serialize(value.actor),
                "origin": try NullableSerializer(TeamLog.OriginLogInfoSerializer()).serialize(value.origin),
                "involve_non_team_member": try NullableSerializer(Serialization._BoolSerializer).serialize(value.involveNonTeamMember),
                "context": try NullableSerializer(TeamLog.ContextLogInfoSerializer()).serialize(value.context),
                "participants": try NullableSerializer(ArraySerializer(TeamLog.ParticipantLogInfoSerializer())).serialize(value.participants),
                "assets": try NullableSerializer(ArraySerializer(TeamLog.AssetLogInfoSerializer())).serialize(value.assets),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> TeamEvent {
            switch json {
            case .dictionary(let dict):
                let timestamp_ = try NSDateSerializer("%Y-%m-%dT%H:%M:%SZ").deserialize(dict["timestamp"] ?? .null)
                let eventCategory = try TeamLog.EventCategorySerializer().deserialize(dict["event_category"] ?? .null)
                let eventType = try TeamLog.EventTypeSerializer().deserialize(dict["event_type"] ?? .null)
                let details = try TeamLog.EventDetailsSerializer().deserialize(dict["details"] ?? .null)
                let actor = try NullableSerializer(TeamLog.ActorLogInfoSerializer()).deserialize(dict["actor"] ?? .null)
                let origin = try NullableSerializer(TeamLog.OriginLogInfoSerializer()).deserialize(dict["origin"] ?? .null)
                let involveNonTeamMember = try NullableSerializer(Serialization._BoolSerializer).deserialize(dict["involve_non_team_member"] ?? .null)
                let context = try NullableSerializer(TeamLog.ContextLogInfoSerializer()).deserialize(dict["context"] ?? .null)
                let participants = try NullableSerializer(ArraySerializer(TeamLog.ParticipantLogInfoSerializer()))
                    .deserialize(dict["participants"] ?? .null)
                let assets = try NullableSerializer(ArraySerializer(TeamLog.AssetLogInfoSerializer())).deserialize(dict["assets"] ?? .null)
                return TeamEvent(
                    timestamp_: timestamp_,
                    eventCategory: eventCategory,
                    eventType: eventType,
                    details: details,
                    actor: actor,
                    origin: origin,
                    involveNonTeamMember: involveNonTeamMember,
                    context: context,
                    participants: participants,
                    assets: assets
                )
            default:
                throw JSONSerializerError.deserializeError(type: TeamEvent.self, json: json)
            }
        }
    }

    /// Policy for controlling whether App Integrations are enabled for the team.
    public enum TeamExtensionsPolicy: CustomStringConvertible, JSONRepresentable {
        /// An unspecified error.
        case disabled
        /// An unspecified error.
        case enabled
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try TeamExtensionsPolicySerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TeamExtensionsPolicySerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TeamExtensionsPolicy: \(error)"
            }
        }
    }

    public class TeamExtensionsPolicySerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TeamExtensionsPolicy) throws -> JSON {
            switch value {
            case .disabled:
                var d = [String: JSON]()
                d[".tag"] = .str("disabled")
                return .dictionary(d)
            case .enabled:
                var d = [String: JSON]()
                d[".tag"] = .str("enabled")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> TeamExtensionsPolicy {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "disabled":
                    return TeamExtensionsPolicy.disabled
                case "enabled":
                    return TeamExtensionsPolicy.enabled
                case "other":
                    return TeamExtensionsPolicy.other
                default:
                    return TeamExtensionsPolicy.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: TeamExtensionsPolicy.self, json: json)
            }
        }
    }

    /// Changed App Integrations setting for team.
    public class TeamExtensionsPolicyChangedDetails: CustomStringConvertible, JSONRepresentable {
        /// New Extensions policy.
        public let newValue: TeamLog.TeamExtensionsPolicy
        /// Previous Extensions policy.
        public let previousValue: TeamLog.TeamExtensionsPolicy
        public init(newValue: TeamLog.TeamExtensionsPolicy, previousValue: TeamLog.TeamExtensionsPolicy) {
            self.newValue = newValue
            self.previousValue = previousValue
        }

        func json() throws -> JSON {
            try TeamExtensionsPolicyChangedDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TeamExtensionsPolicyChangedDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TeamExtensionsPolicyChangedDetails: \(error)"
            }
        }
    }

    public class TeamExtensionsPolicyChangedDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TeamExtensionsPolicyChangedDetails) throws -> JSON {
            let output = [
                "new_value": try TeamLog.TeamExtensionsPolicySerializer().serialize(value.newValue),
                "previous_value": try TeamLog.TeamExtensionsPolicySerializer().serialize(value.previousValue),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> TeamExtensionsPolicyChangedDetails {
            switch json {
            case .dictionary(let dict):
                let newValue = try TeamLog.TeamExtensionsPolicySerializer().deserialize(dict["new_value"] ?? .null)
                let previousValue = try TeamLog.TeamExtensionsPolicySerializer().deserialize(dict["previous_value"] ?? .null)
                return TeamExtensionsPolicyChangedDetails(newValue: newValue, previousValue: previousValue)
            default:
                throw JSONSerializerError.deserializeError(type: TeamExtensionsPolicyChangedDetails.self, json: json)
            }
        }
    }

    /// The TeamExtensionsPolicyChangedType struct
    public class TeamExtensionsPolicyChangedType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try TeamExtensionsPolicyChangedTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TeamExtensionsPolicyChangedTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TeamExtensionsPolicyChangedType: \(error)"
            }
        }
    }

    public class TeamExtensionsPolicyChangedTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TeamExtensionsPolicyChangedType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> TeamExtensionsPolicyChangedType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return TeamExtensionsPolicyChangedType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: TeamExtensionsPolicyChangedType.self, json: json)
            }
        }
    }

    /// Changed archival status of team folder.
    public class TeamFolderChangeStatusDetails: CustomStringConvertible, JSONRepresentable {
        /// New team folder status.
        public let newValue: Team.TeamFolderStatus
        /// Previous team folder status. Might be missing due to historical data gap.
        public let previousValue: Team.TeamFolderStatus?
        public init(newValue: Team.TeamFolderStatus, previousValue: Team.TeamFolderStatus? = nil) {
            self.newValue = newValue
            self.previousValue = previousValue
        }

        func json() throws -> JSON {
            try TeamFolderChangeStatusDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TeamFolderChangeStatusDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TeamFolderChangeStatusDetails: \(error)"
            }
        }
    }

    public class TeamFolderChangeStatusDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TeamFolderChangeStatusDetails) throws -> JSON {
            let output = [
                "new_value": try Team.TeamFolderStatusSerializer().serialize(value.newValue),
                "previous_value": try NullableSerializer(Team.TeamFolderStatusSerializer()).serialize(value.previousValue),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> TeamFolderChangeStatusDetails {
            switch json {
            case .dictionary(let dict):
                let newValue = try Team.TeamFolderStatusSerializer().deserialize(dict["new_value"] ?? .null)
                let previousValue = try NullableSerializer(Team.TeamFolderStatusSerializer()).deserialize(dict["previous_value"] ?? .null)
                return TeamFolderChangeStatusDetails(newValue: newValue, previousValue: previousValue)
            default:
                throw JSONSerializerError.deserializeError(type: TeamFolderChangeStatusDetails.self, json: json)
            }
        }
    }

    /// The TeamFolderChangeStatusType struct
    public class TeamFolderChangeStatusType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try TeamFolderChangeStatusTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TeamFolderChangeStatusTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TeamFolderChangeStatusType: \(error)"
            }
        }
    }

    public class TeamFolderChangeStatusTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TeamFolderChangeStatusType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> TeamFolderChangeStatusType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return TeamFolderChangeStatusType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: TeamFolderChangeStatusType.self, json: json)
            }
        }
    }

    /// Created team folder in active status.
    public class TeamFolderCreateDetails: CustomStringConvertible, JSONRepresentable {
        func json() throws -> JSON {
            try TeamFolderCreateDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TeamFolderCreateDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TeamFolderCreateDetails: \(error)"
            }
        }
    }

    public class TeamFolderCreateDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TeamFolderCreateDetails) throws -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> TeamFolderCreateDetails {
            switch json {
            case .dictionary:
                return TeamFolderCreateDetails()
            default:
                throw JSONSerializerError.deserializeError(type: TeamFolderCreateDetails.self, json: json)
            }
        }
    }

    /// The TeamFolderCreateType struct
    public class TeamFolderCreateType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try TeamFolderCreateTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TeamFolderCreateTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TeamFolderCreateType: \(error)"
            }
        }
    }

    public class TeamFolderCreateTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TeamFolderCreateType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> TeamFolderCreateType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return TeamFolderCreateType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: TeamFolderCreateType.self, json: json)
            }
        }
    }

    /// Downgraded team folder to regular shared folder.
    public class TeamFolderDowngradeDetails: CustomStringConvertible, JSONRepresentable {
        /// Target asset position in the Assets list.
        public let targetAssetIndex: UInt64
        public init(targetAssetIndex: UInt64) {
            comparableValidator()(targetAssetIndex)
            self.targetAssetIndex = targetAssetIndex
        }

        func json() throws -> JSON {
            try TeamFolderDowngradeDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TeamFolderDowngradeDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TeamFolderDowngradeDetails: \(error)"
            }
        }
    }

    public class TeamFolderDowngradeDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TeamFolderDowngradeDetails) throws -> JSON {
            let output = [
                "target_asset_index": try Serialization._UInt64Serializer.serialize(value.targetAssetIndex),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> TeamFolderDowngradeDetails {
            switch json {
            case .dictionary(let dict):
                let targetAssetIndex = try Serialization._UInt64Serializer.deserialize(dict["target_asset_index"] ?? .null)
                return TeamFolderDowngradeDetails(targetAssetIndex: targetAssetIndex)
            default:
                throw JSONSerializerError.deserializeError(type: TeamFolderDowngradeDetails.self, json: json)
            }
        }
    }

    /// The TeamFolderDowngradeType struct
    public class TeamFolderDowngradeType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try TeamFolderDowngradeTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TeamFolderDowngradeTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TeamFolderDowngradeType: \(error)"
            }
        }
    }

    public class TeamFolderDowngradeTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TeamFolderDowngradeType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> TeamFolderDowngradeType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return TeamFolderDowngradeType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: TeamFolderDowngradeType.self, json: json)
            }
        }
    }

    /// Permanently deleted archived team folder.
    public class TeamFolderPermanentlyDeleteDetails: CustomStringConvertible, JSONRepresentable {
        func json() throws -> JSON {
            try TeamFolderPermanentlyDeleteDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TeamFolderPermanentlyDeleteDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TeamFolderPermanentlyDeleteDetails: \(error)"
            }
        }
    }

    public class TeamFolderPermanentlyDeleteDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TeamFolderPermanentlyDeleteDetails) throws -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> TeamFolderPermanentlyDeleteDetails {
            switch json {
            case .dictionary:
                return TeamFolderPermanentlyDeleteDetails()
            default:
                throw JSONSerializerError.deserializeError(type: TeamFolderPermanentlyDeleteDetails.self, json: json)
            }
        }
    }

    /// The TeamFolderPermanentlyDeleteType struct
    public class TeamFolderPermanentlyDeleteType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try TeamFolderPermanentlyDeleteTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TeamFolderPermanentlyDeleteTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TeamFolderPermanentlyDeleteType: \(error)"
            }
        }
    }

    public class TeamFolderPermanentlyDeleteTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TeamFolderPermanentlyDeleteType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> TeamFolderPermanentlyDeleteType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return TeamFolderPermanentlyDeleteType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: TeamFolderPermanentlyDeleteType.self, json: json)
            }
        }
    }

    /// Renamed active/archived team folder.
    public class TeamFolderRenameDetails: CustomStringConvertible, JSONRepresentable {
        /// Previous folder name.
        public let previousFolderName: String
        /// New folder name.
        public let newFolderName: String
        public init(previousFolderName: String, newFolderName: String) {
            stringValidator()(previousFolderName)
            self.previousFolderName = previousFolderName
            stringValidator()(newFolderName)
            self.newFolderName = newFolderName
        }

        func json() throws -> JSON {
            try TeamFolderRenameDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TeamFolderRenameDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TeamFolderRenameDetails: \(error)"
            }
        }
    }

    public class TeamFolderRenameDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TeamFolderRenameDetails) throws -> JSON {
            let output = [
                "previous_folder_name": try Serialization._StringSerializer.serialize(value.previousFolderName),
                "new_folder_name": try Serialization._StringSerializer.serialize(value.newFolderName),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> TeamFolderRenameDetails {
            switch json {
            case .dictionary(let dict):
                let previousFolderName = try Serialization._StringSerializer.deserialize(dict["previous_folder_name"] ?? .null)
                let newFolderName = try Serialization._StringSerializer.deserialize(dict["new_folder_name"] ?? .null)
                return TeamFolderRenameDetails(previousFolderName: previousFolderName, newFolderName: newFolderName)
            default:
                throw JSONSerializerError.deserializeError(type: TeamFolderRenameDetails.self, json: json)
            }
        }
    }

    /// The TeamFolderRenameType struct
    public class TeamFolderRenameType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try TeamFolderRenameTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TeamFolderRenameTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TeamFolderRenameType: \(error)"
            }
        }
    }

    public class TeamFolderRenameTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TeamFolderRenameType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> TeamFolderRenameType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return TeamFolderRenameType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: TeamFolderRenameType.self, json: json)
            }
        }
    }

    /// Details about team invites
    public class TeamInviteDetails: CustomStringConvertible, JSONRepresentable {
        /// How the user was invited to the team.
        public let inviteMethod: TeamLog.InviteMethod
        /// True if the invitation incurred an additional license purchase.
        public let additionalLicensePurchase: Bool?
        public init(inviteMethod: TeamLog.InviteMethod, additionalLicensePurchase: Bool? = nil) {
            self.inviteMethod = inviteMethod
            self.additionalLicensePurchase = additionalLicensePurchase
        }

        func json() throws -> JSON {
            try TeamInviteDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TeamInviteDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TeamInviteDetails: \(error)"
            }
        }
    }

    public class TeamInviteDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TeamInviteDetails) throws -> JSON {
            let output = [
                "invite_method": try TeamLog.InviteMethodSerializer().serialize(value.inviteMethod),
                "additional_license_purchase": try NullableSerializer(Serialization._BoolSerializer).serialize(value.additionalLicensePurchase),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> TeamInviteDetails {
            switch json {
            case .dictionary(let dict):
                let inviteMethod = try TeamLog.InviteMethodSerializer().deserialize(dict["invite_method"] ?? .null)
                let additionalLicensePurchase = try NullableSerializer(Serialization._BoolSerializer)
                    .deserialize(dict["additional_license_purchase"] ?? .null)
                return TeamInviteDetails(inviteMethod: inviteMethod, additionalLicensePurchase: additionalLicensePurchase)
            default:
                throw JSONSerializerError.deserializeError(type: TeamInviteDetails.self, json: json)
            }
        }
    }

    /// Team linked app
    public class TeamLinkedAppLogInfo: TeamLog.AppLogInfo {
        public override var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TeamLinkedAppLogInfoSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TeamLinkedAppLogInfo: \(error)"
            }
        }
    }

    public class TeamLinkedAppLogInfoSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TeamLinkedAppLogInfo) throws -> JSON {
            let output = [
                "app_id": try NullableSerializer(Serialization._StringSerializer).serialize(value.appId),
                "display_name": try NullableSerializer(Serialization._StringSerializer).serialize(value.displayName),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> TeamLinkedAppLogInfo {
            switch json {
            case .dictionary(let dict):
                let appId = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["app_id"] ?? .null)
                let displayName = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["display_name"] ?? .null)
                return TeamLinkedAppLogInfo(appId: appId, displayName: displayName)
            default:
                throw JSONSerializerError.deserializeError(type: TeamLinkedAppLogInfo.self, json: json)
            }
        }
    }

    /// Team's logged information.
    public class TeamLogInfo: CustomStringConvertible, JSONRepresentable {
        /// Team display name.
        public let displayName: String
        public init(displayName: String) {
            stringValidator()(displayName)
            self.displayName = displayName
        }

        func json() throws -> JSON {
            try TeamLogInfoSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TeamLogInfoSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TeamLogInfo: \(error)"
            }
        }
    }

    public class TeamLogInfoSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TeamLogInfo) throws -> JSON {
            let output = [
                "display_name": try Serialization._StringSerializer.serialize(value.displayName),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> TeamLogInfo {
            switch json {
            case .dictionary(let dict):
                let displayName = try Serialization._StringSerializer.deserialize(dict["display_name"] ?? .null)
                return TeamLogInfo(displayName: displayName)
            default:
                throw JSONSerializerError.deserializeError(type: TeamLogInfo.self, json: json)
            }
        }
    }

    /// Team member's logged information.
    public class TeamMemberLogInfo: TeamLog.UserLogInfo {
        /// Team member ID.
        public let teamMemberId: String?
        /// Team member external ID.
        public let memberExternalId: String?
        /// Details about this user&#x2019s team for enterprise event.
        public let team: TeamLog.TeamLogInfo?
        public init(
            accountId: String? = nil,
            displayName: String? = nil,
            email: String? = nil,
            teamMemberId: String? = nil,
            memberExternalId: String? = nil,
            team: TeamLog.TeamLogInfo? = nil
        ) {
            nullableValidator(stringValidator())(teamMemberId)
            self.teamMemberId = teamMemberId
            nullableValidator(stringValidator(maxLength: 64))(memberExternalId)
            self.memberExternalId = memberExternalId
            self.team = team
            super.init(accountId: accountId, displayName: displayName, email: email)
        }

        public override var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TeamMemberLogInfoSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TeamMemberLogInfo: \(error)"
            }
        }
    }

    public class TeamMemberLogInfoSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TeamMemberLogInfo) throws -> JSON {
            let output = [
                "account_id": try NullableSerializer(Serialization._StringSerializer).serialize(value.accountId),
                "display_name": try NullableSerializer(Serialization._StringSerializer).serialize(value.displayName),
                "email": try NullableSerializer(Serialization._StringSerializer).serialize(value.email),
                "team_member_id": try NullableSerializer(Serialization._StringSerializer).serialize(value.teamMemberId),
                "member_external_id": try NullableSerializer(Serialization._StringSerializer).serialize(value.memberExternalId),
                "team": try NullableSerializer(TeamLog.TeamLogInfoSerializer()).serialize(value.team),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> TeamMemberLogInfo {
            switch json {
            case .dictionary(let dict):
                let accountId = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["account_id"] ?? .null)
                let displayName = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["display_name"] ?? .null)
                let email = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["email"] ?? .null)
                let teamMemberId = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["team_member_id"] ?? .null)
                let memberExternalId = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["member_external_id"] ?? .null)
                let team = try NullableSerializer(TeamLog.TeamLogInfoSerializer()).deserialize(dict["team"] ?? .null)
                return TeamMemberLogInfo(
                    accountId: accountId,
                    displayName: displayName,
                    email: email,
                    teamMemberId: teamMemberId,
                    memberExternalId: memberExternalId,
                    team: team
                )
            default:
                throw JSONSerializerError.deserializeError(type: TeamMemberLogInfo.self, json: json)
            }
        }
    }

    /// The TeamMembershipType union
    public enum TeamMembershipType: CustomStringConvertible, JSONRepresentable {
        /// An unspecified error.
        case free
        /// An unspecified error.
        case full
        /// An unspecified error.
        case guest
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try TeamMembershipTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TeamMembershipTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TeamMembershipType: \(error)"
            }
        }
    }

    public class TeamMembershipTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TeamMembershipType) throws -> JSON {
            switch value {
            case .free:
                var d = [String: JSON]()
                d[".tag"] = .str("free")
                return .dictionary(d)
            case .full:
                var d = [String: JSON]()
                d[".tag"] = .str("full")
                return .dictionary(d)
            case .guest:
                var d = [String: JSON]()
                d[".tag"] = .str("guest")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> TeamMembershipType {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "free":
                    return TeamMembershipType.free
                case "full":
                    return TeamMembershipType.full
                case "guest":
                    return TeamMembershipType.guest
                case "other":
                    return TeamMembershipType.other
                default:
                    return TeamMembershipType.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: TeamMembershipType.self, json: json)
            }
        }
    }

    /// Merged another team into this team.
    public class TeamMergeFromDetails: CustomStringConvertible, JSONRepresentable {
        /// The name of the team that was merged into this team.
        public let teamName: String
        public init(teamName: String) {
            stringValidator()(teamName)
            self.teamName = teamName
        }

        func json() throws -> JSON {
            try TeamMergeFromDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TeamMergeFromDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TeamMergeFromDetails: \(error)"
            }
        }
    }

    public class TeamMergeFromDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TeamMergeFromDetails) throws -> JSON {
            let output = [
                "team_name": try Serialization._StringSerializer.serialize(value.teamName),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> TeamMergeFromDetails {
            switch json {
            case .dictionary(let dict):
                let teamName = try Serialization._StringSerializer.deserialize(dict["team_name"] ?? .null)
                return TeamMergeFromDetails(teamName: teamName)
            default:
                throw JSONSerializerError.deserializeError(type: TeamMergeFromDetails.self, json: json)
            }
        }
    }

    /// The TeamMergeFromType struct
    public class TeamMergeFromType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try TeamMergeFromTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TeamMergeFromTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TeamMergeFromType: \(error)"
            }
        }
    }

    public class TeamMergeFromTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TeamMergeFromType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> TeamMergeFromType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return TeamMergeFromType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: TeamMergeFromType.self, json: json)
            }
        }
    }

    /// Accepted a team merge request.
    public class TeamMergeRequestAcceptedDetails: CustomStringConvertible, JSONRepresentable {
        /// Team merge request acceptance details.
        public let requestAcceptedDetails: TeamLog.TeamMergeRequestAcceptedExtraDetails
        public init(requestAcceptedDetails: TeamLog.TeamMergeRequestAcceptedExtraDetails) {
            self.requestAcceptedDetails = requestAcceptedDetails
        }

        func json() throws -> JSON {
            try TeamMergeRequestAcceptedDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TeamMergeRequestAcceptedDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TeamMergeRequestAcceptedDetails: \(error)"
            }
        }
    }

    public class TeamMergeRequestAcceptedDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TeamMergeRequestAcceptedDetails) throws -> JSON {
            let output = [
                "request_accepted_details": try TeamLog.TeamMergeRequestAcceptedExtraDetailsSerializer().serialize(value.requestAcceptedDetails),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> TeamMergeRequestAcceptedDetails {
            switch json {
            case .dictionary(let dict):
                let requestAcceptedDetails = try TeamLog.TeamMergeRequestAcceptedExtraDetailsSerializer()
                    .deserialize(dict["request_accepted_details"] ?? .null)
                return TeamMergeRequestAcceptedDetails(requestAcceptedDetails: requestAcceptedDetails)
            default:
                throw JSONSerializerError.deserializeError(type: TeamMergeRequestAcceptedDetails.self, json: json)
            }
        }
    }

    /// Team merge request acceptance details
    public enum TeamMergeRequestAcceptedExtraDetails: CustomStringConvertible, JSONRepresentable {
        /// Team merge request accepted details shown to the primary team.
        case primaryTeam(TeamLog.PrimaryTeamRequestAcceptedDetails)
        /// Team merge request accepted details shown to the secondary team.
        case secondaryTeam(TeamLog.SecondaryTeamRequestAcceptedDetails)
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try TeamMergeRequestAcceptedExtraDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TeamMergeRequestAcceptedExtraDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TeamMergeRequestAcceptedExtraDetails: \(error)"
            }
        }
    }

    public class TeamMergeRequestAcceptedExtraDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TeamMergeRequestAcceptedExtraDetails) throws -> JSON {
            switch value {
            case .primaryTeam(let arg):
                var d = try Serialization.getFields(TeamLog.PrimaryTeamRequestAcceptedDetailsSerializer().serialize(arg))
                d[".tag"] = .str("primary_team")
                return .dictionary(d)
            case .secondaryTeam(let arg):
                var d = try Serialization.getFields(TeamLog.SecondaryTeamRequestAcceptedDetailsSerializer().serialize(arg))
                d[".tag"] = .str("secondary_team")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> TeamMergeRequestAcceptedExtraDetails {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "primary_team":
                    let v = try TeamLog.PrimaryTeamRequestAcceptedDetailsSerializer().deserialize(json)
                    return TeamMergeRequestAcceptedExtraDetails.primaryTeam(v)
                case "secondary_team":
                    let v = try TeamLog.SecondaryTeamRequestAcceptedDetailsSerializer().deserialize(json)
                    return TeamMergeRequestAcceptedExtraDetails.secondaryTeam(v)
                case "other":
                    return TeamMergeRequestAcceptedExtraDetails.other
                default:
                    return TeamMergeRequestAcceptedExtraDetails.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: TeamMergeRequestAcceptedExtraDetails.self, json: json)
            }
        }
    }

    /// Accepted a team merge request.
    public class TeamMergeRequestAcceptedShownToPrimaryTeamDetails: CustomStringConvertible, JSONRepresentable {
        /// The secondary team name.
        public let secondaryTeam: String
        /// The name of the secondary team admin who sent the request originally.
        public let sentBy: String
        public init(secondaryTeam: String, sentBy: String) {
            stringValidator()(secondaryTeam)
            self.secondaryTeam = secondaryTeam
            stringValidator()(sentBy)
            self.sentBy = sentBy
        }

        func json() throws -> JSON {
            try TeamMergeRequestAcceptedShownToPrimaryTeamDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TeamMergeRequestAcceptedShownToPrimaryTeamDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TeamMergeRequestAcceptedShownToPrimaryTeamDetails: \(error)"
            }
        }
    }

    public class TeamMergeRequestAcceptedShownToPrimaryTeamDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TeamMergeRequestAcceptedShownToPrimaryTeamDetails) throws -> JSON {
            let output = [
                "secondary_team": try Serialization._StringSerializer.serialize(value.secondaryTeam),
                "sent_by": try Serialization._StringSerializer.serialize(value.sentBy),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> TeamMergeRequestAcceptedShownToPrimaryTeamDetails {
            switch json {
            case .dictionary(let dict):
                let secondaryTeam = try Serialization._StringSerializer.deserialize(dict["secondary_team"] ?? .null)
                let sentBy = try Serialization._StringSerializer.deserialize(dict["sent_by"] ?? .null)
                return TeamMergeRequestAcceptedShownToPrimaryTeamDetails(secondaryTeam: secondaryTeam, sentBy: sentBy)
            default:
                throw JSONSerializerError.deserializeError(type: TeamMergeRequestAcceptedShownToPrimaryTeamDetails.self, json: json)
            }
        }
    }

    /// The TeamMergeRequestAcceptedShownToPrimaryTeamType struct
    public class TeamMergeRequestAcceptedShownToPrimaryTeamType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try TeamMergeRequestAcceptedShownToPrimaryTeamTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TeamMergeRequestAcceptedShownToPrimaryTeamTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TeamMergeRequestAcceptedShownToPrimaryTeamType: \(error)"
            }
        }
    }

    public class TeamMergeRequestAcceptedShownToPrimaryTeamTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TeamMergeRequestAcceptedShownToPrimaryTeamType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> TeamMergeRequestAcceptedShownToPrimaryTeamType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return TeamMergeRequestAcceptedShownToPrimaryTeamType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: TeamMergeRequestAcceptedShownToPrimaryTeamType.self, json: json)
            }
        }
    }

    /// Accepted a team merge request.
    public class TeamMergeRequestAcceptedShownToSecondaryTeamDetails: CustomStringConvertible, JSONRepresentable {
        /// The primary team name.
        public let primaryTeam: String
        /// The name of the secondary team admin who sent the request originally.
        public let sentBy: String
        public init(primaryTeam: String, sentBy: String) {
            stringValidator()(primaryTeam)
            self.primaryTeam = primaryTeam
            stringValidator()(sentBy)
            self.sentBy = sentBy
        }

        func json() throws -> JSON {
            try TeamMergeRequestAcceptedShownToSecondaryTeamDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TeamMergeRequestAcceptedShownToSecondaryTeamDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TeamMergeRequestAcceptedShownToSecondaryTeamDetails: \(error)"
            }
        }
    }

    public class TeamMergeRequestAcceptedShownToSecondaryTeamDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TeamMergeRequestAcceptedShownToSecondaryTeamDetails) throws -> JSON {
            let output = [
                "primary_team": try Serialization._StringSerializer.serialize(value.primaryTeam),
                "sent_by": try Serialization._StringSerializer.serialize(value.sentBy),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> TeamMergeRequestAcceptedShownToSecondaryTeamDetails {
            switch json {
            case .dictionary(let dict):
                let primaryTeam = try Serialization._StringSerializer.deserialize(dict["primary_team"] ?? .null)
                let sentBy = try Serialization._StringSerializer.deserialize(dict["sent_by"] ?? .null)
                return TeamMergeRequestAcceptedShownToSecondaryTeamDetails(primaryTeam: primaryTeam, sentBy: sentBy)
            default:
                throw JSONSerializerError.deserializeError(type: TeamMergeRequestAcceptedShownToSecondaryTeamDetails.self, json: json)
            }
        }
    }

    /// The TeamMergeRequestAcceptedShownToSecondaryTeamType struct
    public class TeamMergeRequestAcceptedShownToSecondaryTeamType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try TeamMergeRequestAcceptedShownToSecondaryTeamTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TeamMergeRequestAcceptedShownToSecondaryTeamTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TeamMergeRequestAcceptedShownToSecondaryTeamType: \(error)"
            }
        }
    }

    public class TeamMergeRequestAcceptedShownToSecondaryTeamTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TeamMergeRequestAcceptedShownToSecondaryTeamType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> TeamMergeRequestAcceptedShownToSecondaryTeamType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return TeamMergeRequestAcceptedShownToSecondaryTeamType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: TeamMergeRequestAcceptedShownToSecondaryTeamType.self, json: json)
            }
        }
    }

    /// The TeamMergeRequestAcceptedType struct
    public class TeamMergeRequestAcceptedType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try TeamMergeRequestAcceptedTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TeamMergeRequestAcceptedTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TeamMergeRequestAcceptedType: \(error)"
            }
        }
    }

    public class TeamMergeRequestAcceptedTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TeamMergeRequestAcceptedType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> TeamMergeRequestAcceptedType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return TeamMergeRequestAcceptedType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: TeamMergeRequestAcceptedType.self, json: json)
            }
        }
    }

    /// Automatically canceled team merge request.
    public class TeamMergeRequestAutoCanceledDetails: CustomStringConvertible, JSONRepresentable {
        /// The cancellation reason.
        public let details: String?
        public init(details: String? = nil) {
            nullableValidator(stringValidator())(details)
            self.details = details
        }

        func json() throws -> JSON {
            try TeamMergeRequestAutoCanceledDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TeamMergeRequestAutoCanceledDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TeamMergeRequestAutoCanceledDetails: \(error)"
            }
        }
    }

    public class TeamMergeRequestAutoCanceledDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TeamMergeRequestAutoCanceledDetails) throws -> JSON {
            let output = [
                "details": try NullableSerializer(Serialization._StringSerializer).serialize(value.details),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> TeamMergeRequestAutoCanceledDetails {
            switch json {
            case .dictionary(let dict):
                let details = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["details"] ?? .null)
                return TeamMergeRequestAutoCanceledDetails(details: details)
            default:
                throw JSONSerializerError.deserializeError(type: TeamMergeRequestAutoCanceledDetails.self, json: json)
            }
        }
    }

    /// The TeamMergeRequestAutoCanceledType struct
    public class TeamMergeRequestAutoCanceledType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try TeamMergeRequestAutoCanceledTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TeamMergeRequestAutoCanceledTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TeamMergeRequestAutoCanceledType: \(error)"
            }
        }
    }

    public class TeamMergeRequestAutoCanceledTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TeamMergeRequestAutoCanceledType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> TeamMergeRequestAutoCanceledType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return TeamMergeRequestAutoCanceledType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: TeamMergeRequestAutoCanceledType.self, json: json)
            }
        }
    }

    /// Canceled a team merge request.
    public class TeamMergeRequestCanceledDetails: CustomStringConvertible, JSONRepresentable {
        /// Team merge request cancellation details.
        public let requestCanceledDetails: TeamLog.TeamMergeRequestCanceledExtraDetails
        public init(requestCanceledDetails: TeamLog.TeamMergeRequestCanceledExtraDetails) {
            self.requestCanceledDetails = requestCanceledDetails
        }

        func json() throws -> JSON {
            try TeamMergeRequestCanceledDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TeamMergeRequestCanceledDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TeamMergeRequestCanceledDetails: \(error)"
            }
        }
    }

    public class TeamMergeRequestCanceledDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TeamMergeRequestCanceledDetails) throws -> JSON {
            let output = [
                "request_canceled_details": try TeamLog.TeamMergeRequestCanceledExtraDetailsSerializer().serialize(value.requestCanceledDetails),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> TeamMergeRequestCanceledDetails {
            switch json {
            case .dictionary(let dict):
                let requestCanceledDetails = try TeamLog.TeamMergeRequestCanceledExtraDetailsSerializer()
                    .deserialize(dict["request_canceled_details"] ?? .null)
                return TeamMergeRequestCanceledDetails(requestCanceledDetails: requestCanceledDetails)
            default:
                throw JSONSerializerError.deserializeError(type: TeamMergeRequestCanceledDetails.self, json: json)
            }
        }
    }

    /// Team merge request cancellation details
    public enum TeamMergeRequestCanceledExtraDetails: CustomStringConvertible, JSONRepresentable {
        /// Team merge request cancellation details shown to the primary team.
        case primaryTeam(TeamLog.PrimaryTeamRequestCanceledDetails)
        /// Team merge request cancellation details shown to the secondary team.
        case secondaryTeam(TeamLog.SecondaryTeamRequestCanceledDetails)
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try TeamMergeRequestCanceledExtraDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TeamMergeRequestCanceledExtraDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TeamMergeRequestCanceledExtraDetails: \(error)"
            }
        }
    }

    public class TeamMergeRequestCanceledExtraDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TeamMergeRequestCanceledExtraDetails) throws -> JSON {
            switch value {
            case .primaryTeam(let arg):
                var d = try Serialization.getFields(TeamLog.PrimaryTeamRequestCanceledDetailsSerializer().serialize(arg))
                d[".tag"] = .str("primary_team")
                return .dictionary(d)
            case .secondaryTeam(let arg):
                var d = try Serialization.getFields(TeamLog.SecondaryTeamRequestCanceledDetailsSerializer().serialize(arg))
                d[".tag"] = .str("secondary_team")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> TeamMergeRequestCanceledExtraDetails {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "primary_team":
                    let v = try TeamLog.PrimaryTeamRequestCanceledDetailsSerializer().deserialize(json)
                    return TeamMergeRequestCanceledExtraDetails.primaryTeam(v)
                case "secondary_team":
                    let v = try TeamLog.SecondaryTeamRequestCanceledDetailsSerializer().deserialize(json)
                    return TeamMergeRequestCanceledExtraDetails.secondaryTeam(v)
                case "other":
                    return TeamMergeRequestCanceledExtraDetails.other
                default:
                    return TeamMergeRequestCanceledExtraDetails.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: TeamMergeRequestCanceledExtraDetails.self, json: json)
            }
        }
    }

    /// Canceled a team merge request.
    public class TeamMergeRequestCanceledShownToPrimaryTeamDetails: CustomStringConvertible, JSONRepresentable {
        /// The secondary team name.
        public let secondaryTeam: String
        /// The name of the secondary team admin who sent the request originally.
        public let sentBy: String
        public init(secondaryTeam: String, sentBy: String) {
            stringValidator()(secondaryTeam)
            self.secondaryTeam = secondaryTeam
            stringValidator()(sentBy)
            self.sentBy = sentBy
        }

        func json() throws -> JSON {
            try TeamMergeRequestCanceledShownToPrimaryTeamDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TeamMergeRequestCanceledShownToPrimaryTeamDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TeamMergeRequestCanceledShownToPrimaryTeamDetails: \(error)"
            }
        }
    }

    public class TeamMergeRequestCanceledShownToPrimaryTeamDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TeamMergeRequestCanceledShownToPrimaryTeamDetails) throws -> JSON {
            let output = [
                "secondary_team": try Serialization._StringSerializer.serialize(value.secondaryTeam),
                "sent_by": try Serialization._StringSerializer.serialize(value.sentBy),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> TeamMergeRequestCanceledShownToPrimaryTeamDetails {
            switch json {
            case .dictionary(let dict):
                let secondaryTeam = try Serialization._StringSerializer.deserialize(dict["secondary_team"] ?? .null)
                let sentBy = try Serialization._StringSerializer.deserialize(dict["sent_by"] ?? .null)
                return TeamMergeRequestCanceledShownToPrimaryTeamDetails(secondaryTeam: secondaryTeam, sentBy: sentBy)
            default:
                throw JSONSerializerError.deserializeError(type: TeamMergeRequestCanceledShownToPrimaryTeamDetails.self, json: json)
            }
        }
    }

    /// The TeamMergeRequestCanceledShownToPrimaryTeamType struct
    public class TeamMergeRequestCanceledShownToPrimaryTeamType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try TeamMergeRequestCanceledShownToPrimaryTeamTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TeamMergeRequestCanceledShownToPrimaryTeamTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TeamMergeRequestCanceledShownToPrimaryTeamType: \(error)"
            }
        }
    }

    public class TeamMergeRequestCanceledShownToPrimaryTeamTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TeamMergeRequestCanceledShownToPrimaryTeamType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> TeamMergeRequestCanceledShownToPrimaryTeamType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return TeamMergeRequestCanceledShownToPrimaryTeamType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: TeamMergeRequestCanceledShownToPrimaryTeamType.self, json: json)
            }
        }
    }

    /// Canceled a team merge request.
    public class TeamMergeRequestCanceledShownToSecondaryTeamDetails: CustomStringConvertible, JSONRepresentable {
        /// The email of the primary team admin that the request was sent to.
        public let sentTo: String
        /// The name of the secondary team admin who sent the request originally.
        public let sentBy: String
        public init(sentTo: String, sentBy: String) {
            stringValidator()(sentTo)
            self.sentTo = sentTo
            stringValidator()(sentBy)
            self.sentBy = sentBy
        }

        func json() throws -> JSON {
            try TeamMergeRequestCanceledShownToSecondaryTeamDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TeamMergeRequestCanceledShownToSecondaryTeamDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TeamMergeRequestCanceledShownToSecondaryTeamDetails: \(error)"
            }
        }
    }

    public class TeamMergeRequestCanceledShownToSecondaryTeamDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TeamMergeRequestCanceledShownToSecondaryTeamDetails) throws -> JSON {
            let output = [
                "sent_to": try Serialization._StringSerializer.serialize(value.sentTo),
                "sent_by": try Serialization._StringSerializer.serialize(value.sentBy),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> TeamMergeRequestCanceledShownToSecondaryTeamDetails {
            switch json {
            case .dictionary(let dict):
                let sentTo = try Serialization._StringSerializer.deserialize(dict["sent_to"] ?? .null)
                let sentBy = try Serialization._StringSerializer.deserialize(dict["sent_by"] ?? .null)
                return TeamMergeRequestCanceledShownToSecondaryTeamDetails(sentTo: sentTo, sentBy: sentBy)
            default:
                throw JSONSerializerError.deserializeError(type: TeamMergeRequestCanceledShownToSecondaryTeamDetails.self, json: json)
            }
        }
    }

    /// The TeamMergeRequestCanceledShownToSecondaryTeamType struct
    public class TeamMergeRequestCanceledShownToSecondaryTeamType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try TeamMergeRequestCanceledShownToSecondaryTeamTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TeamMergeRequestCanceledShownToSecondaryTeamTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TeamMergeRequestCanceledShownToSecondaryTeamType: \(error)"
            }
        }
    }

    public class TeamMergeRequestCanceledShownToSecondaryTeamTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TeamMergeRequestCanceledShownToSecondaryTeamType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> TeamMergeRequestCanceledShownToSecondaryTeamType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return TeamMergeRequestCanceledShownToSecondaryTeamType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: TeamMergeRequestCanceledShownToSecondaryTeamType.self, json: json)
            }
        }
    }

    /// The TeamMergeRequestCanceledType struct
    public class TeamMergeRequestCanceledType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try TeamMergeRequestCanceledTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TeamMergeRequestCanceledTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TeamMergeRequestCanceledType: \(error)"
            }
        }
    }

    public class TeamMergeRequestCanceledTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TeamMergeRequestCanceledType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> TeamMergeRequestCanceledType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return TeamMergeRequestCanceledType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: TeamMergeRequestCanceledType.self, json: json)
            }
        }
    }

    /// Team merge request expired.
    public class TeamMergeRequestExpiredDetails: CustomStringConvertible, JSONRepresentable {
        /// Team merge request expiration details.
        public let requestExpiredDetails: TeamLog.TeamMergeRequestExpiredExtraDetails
        public init(requestExpiredDetails: TeamLog.TeamMergeRequestExpiredExtraDetails) {
            self.requestExpiredDetails = requestExpiredDetails
        }

        func json() throws -> JSON {
            try TeamMergeRequestExpiredDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TeamMergeRequestExpiredDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TeamMergeRequestExpiredDetails: \(error)"
            }
        }
    }

    public class TeamMergeRequestExpiredDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TeamMergeRequestExpiredDetails) throws -> JSON {
            let output = [
                "request_expired_details": try TeamLog.TeamMergeRequestExpiredExtraDetailsSerializer().serialize(value.requestExpiredDetails),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> TeamMergeRequestExpiredDetails {
            switch json {
            case .dictionary(let dict):
                let requestExpiredDetails = try TeamLog.TeamMergeRequestExpiredExtraDetailsSerializer()
                    .deserialize(dict["request_expired_details"] ?? .null)
                return TeamMergeRequestExpiredDetails(requestExpiredDetails: requestExpiredDetails)
            default:
                throw JSONSerializerError.deserializeError(type: TeamMergeRequestExpiredDetails.self, json: json)
            }
        }
    }

    /// Team merge request expiration details
    public enum TeamMergeRequestExpiredExtraDetails: CustomStringConvertible, JSONRepresentable {
        /// Team merge request canceled details shown to the primary team.
        case primaryTeam(TeamLog.PrimaryTeamRequestExpiredDetails)
        /// Team merge request canceled details shown to the secondary team.
        case secondaryTeam(TeamLog.SecondaryTeamRequestExpiredDetails)
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try TeamMergeRequestExpiredExtraDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TeamMergeRequestExpiredExtraDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TeamMergeRequestExpiredExtraDetails: \(error)"
            }
        }
    }

    public class TeamMergeRequestExpiredExtraDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TeamMergeRequestExpiredExtraDetails) throws -> JSON {
            switch value {
            case .primaryTeam(let arg):
                var d = try Serialization.getFields(TeamLog.PrimaryTeamRequestExpiredDetailsSerializer().serialize(arg))
                d[".tag"] = .str("primary_team")
                return .dictionary(d)
            case .secondaryTeam(let arg):
                var d = try Serialization.getFields(TeamLog.SecondaryTeamRequestExpiredDetailsSerializer().serialize(arg))
                d[".tag"] = .str("secondary_team")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> TeamMergeRequestExpiredExtraDetails {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "primary_team":
                    let v = try TeamLog.PrimaryTeamRequestExpiredDetailsSerializer().deserialize(json)
                    return TeamMergeRequestExpiredExtraDetails.primaryTeam(v)
                case "secondary_team":
                    let v = try TeamLog.SecondaryTeamRequestExpiredDetailsSerializer().deserialize(json)
                    return TeamMergeRequestExpiredExtraDetails.secondaryTeam(v)
                case "other":
                    return TeamMergeRequestExpiredExtraDetails.other
                default:
                    return TeamMergeRequestExpiredExtraDetails.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: TeamMergeRequestExpiredExtraDetails.self, json: json)
            }
        }
    }

    /// Team merge request expired.
    public class TeamMergeRequestExpiredShownToPrimaryTeamDetails: CustomStringConvertible, JSONRepresentable {
        /// The secondary team name.
        public let secondaryTeam: String
        /// The name of the secondary team admin who sent the request originally.
        public let sentBy: String
        public init(secondaryTeam: String, sentBy: String) {
            stringValidator()(secondaryTeam)
            self.secondaryTeam = secondaryTeam
            stringValidator()(sentBy)
            self.sentBy = sentBy
        }

        func json() throws -> JSON {
            try TeamMergeRequestExpiredShownToPrimaryTeamDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TeamMergeRequestExpiredShownToPrimaryTeamDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TeamMergeRequestExpiredShownToPrimaryTeamDetails: \(error)"
            }
        }
    }

    public class TeamMergeRequestExpiredShownToPrimaryTeamDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TeamMergeRequestExpiredShownToPrimaryTeamDetails) throws -> JSON {
            let output = [
                "secondary_team": try Serialization._StringSerializer.serialize(value.secondaryTeam),
                "sent_by": try Serialization._StringSerializer.serialize(value.sentBy),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> TeamMergeRequestExpiredShownToPrimaryTeamDetails {
            switch json {
            case .dictionary(let dict):
                let secondaryTeam = try Serialization._StringSerializer.deserialize(dict["secondary_team"] ?? .null)
                let sentBy = try Serialization._StringSerializer.deserialize(dict["sent_by"] ?? .null)
                return TeamMergeRequestExpiredShownToPrimaryTeamDetails(secondaryTeam: secondaryTeam, sentBy: sentBy)
            default:
                throw JSONSerializerError.deserializeError(type: TeamMergeRequestExpiredShownToPrimaryTeamDetails.self, json: json)
            }
        }
    }

    /// The TeamMergeRequestExpiredShownToPrimaryTeamType struct
    public class TeamMergeRequestExpiredShownToPrimaryTeamType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try TeamMergeRequestExpiredShownToPrimaryTeamTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TeamMergeRequestExpiredShownToPrimaryTeamTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TeamMergeRequestExpiredShownToPrimaryTeamType: \(error)"
            }
        }
    }

    public class TeamMergeRequestExpiredShownToPrimaryTeamTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TeamMergeRequestExpiredShownToPrimaryTeamType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> TeamMergeRequestExpiredShownToPrimaryTeamType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return TeamMergeRequestExpiredShownToPrimaryTeamType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: TeamMergeRequestExpiredShownToPrimaryTeamType.self, json: json)
            }
        }
    }

    /// Team merge request expired.
    public class TeamMergeRequestExpiredShownToSecondaryTeamDetails: CustomStringConvertible, JSONRepresentable {
        /// The email of the primary team admin the request was sent to.
        public let sentTo: String
        public init(sentTo: String) {
            stringValidator()(sentTo)
            self.sentTo = sentTo
        }

        func json() throws -> JSON {
            try TeamMergeRequestExpiredShownToSecondaryTeamDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TeamMergeRequestExpiredShownToSecondaryTeamDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TeamMergeRequestExpiredShownToSecondaryTeamDetails: \(error)"
            }
        }
    }

    public class TeamMergeRequestExpiredShownToSecondaryTeamDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TeamMergeRequestExpiredShownToSecondaryTeamDetails) throws -> JSON {
            let output = [
                "sent_to": try Serialization._StringSerializer.serialize(value.sentTo),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> TeamMergeRequestExpiredShownToSecondaryTeamDetails {
            switch json {
            case .dictionary(let dict):
                let sentTo = try Serialization._StringSerializer.deserialize(dict["sent_to"] ?? .null)
                return TeamMergeRequestExpiredShownToSecondaryTeamDetails(sentTo: sentTo)
            default:
                throw JSONSerializerError.deserializeError(type: TeamMergeRequestExpiredShownToSecondaryTeamDetails.self, json: json)
            }
        }
    }

    /// The TeamMergeRequestExpiredShownToSecondaryTeamType struct
    public class TeamMergeRequestExpiredShownToSecondaryTeamType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try TeamMergeRequestExpiredShownToSecondaryTeamTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TeamMergeRequestExpiredShownToSecondaryTeamTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TeamMergeRequestExpiredShownToSecondaryTeamType: \(error)"
            }
        }
    }

    public class TeamMergeRequestExpiredShownToSecondaryTeamTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TeamMergeRequestExpiredShownToSecondaryTeamType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> TeamMergeRequestExpiredShownToSecondaryTeamType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return TeamMergeRequestExpiredShownToSecondaryTeamType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: TeamMergeRequestExpiredShownToSecondaryTeamType.self, json: json)
            }
        }
    }

    /// The TeamMergeRequestExpiredType struct
    public class TeamMergeRequestExpiredType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try TeamMergeRequestExpiredTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TeamMergeRequestExpiredTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TeamMergeRequestExpiredType: \(error)"
            }
        }
    }

    public class TeamMergeRequestExpiredTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TeamMergeRequestExpiredType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> TeamMergeRequestExpiredType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return TeamMergeRequestExpiredType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: TeamMergeRequestExpiredType.self, json: json)
            }
        }
    }

    /// Rejected a team merge request.
    public class TeamMergeRequestRejectedShownToPrimaryTeamDetails: CustomStringConvertible, JSONRepresentable {
        /// The secondary team name.
        public let secondaryTeam: String
        /// The name of the secondary team admin who sent the request originally.
        public let sentBy: String
        public init(secondaryTeam: String, sentBy: String) {
            stringValidator()(secondaryTeam)
            self.secondaryTeam = secondaryTeam
            stringValidator()(sentBy)
            self.sentBy = sentBy
        }

        func json() throws -> JSON {
            try TeamMergeRequestRejectedShownToPrimaryTeamDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TeamMergeRequestRejectedShownToPrimaryTeamDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TeamMergeRequestRejectedShownToPrimaryTeamDetails: \(error)"
            }
        }
    }

    public class TeamMergeRequestRejectedShownToPrimaryTeamDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TeamMergeRequestRejectedShownToPrimaryTeamDetails) throws -> JSON {
            let output = [
                "secondary_team": try Serialization._StringSerializer.serialize(value.secondaryTeam),
                "sent_by": try Serialization._StringSerializer.serialize(value.sentBy),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> TeamMergeRequestRejectedShownToPrimaryTeamDetails {
            switch json {
            case .dictionary(let dict):
                let secondaryTeam = try Serialization._StringSerializer.deserialize(dict["secondary_team"] ?? .null)
                let sentBy = try Serialization._StringSerializer.deserialize(dict["sent_by"] ?? .null)
                return TeamMergeRequestRejectedShownToPrimaryTeamDetails(secondaryTeam: secondaryTeam, sentBy: sentBy)
            default:
                throw JSONSerializerError.deserializeError(type: TeamMergeRequestRejectedShownToPrimaryTeamDetails.self, json: json)
            }
        }
    }

    /// The TeamMergeRequestRejectedShownToPrimaryTeamType struct
    public class TeamMergeRequestRejectedShownToPrimaryTeamType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try TeamMergeRequestRejectedShownToPrimaryTeamTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TeamMergeRequestRejectedShownToPrimaryTeamTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TeamMergeRequestRejectedShownToPrimaryTeamType: \(error)"
            }
        }
    }

    public class TeamMergeRequestRejectedShownToPrimaryTeamTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TeamMergeRequestRejectedShownToPrimaryTeamType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> TeamMergeRequestRejectedShownToPrimaryTeamType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return TeamMergeRequestRejectedShownToPrimaryTeamType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: TeamMergeRequestRejectedShownToPrimaryTeamType.self, json: json)
            }
        }
    }

    /// Rejected a team merge request.
    public class TeamMergeRequestRejectedShownToSecondaryTeamDetails: CustomStringConvertible, JSONRepresentable {
        /// The name of the secondary team admin who sent the request originally.
        public let sentBy: String
        public init(sentBy: String) {
            stringValidator()(sentBy)
            self.sentBy = sentBy
        }

        func json() throws -> JSON {
            try TeamMergeRequestRejectedShownToSecondaryTeamDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TeamMergeRequestRejectedShownToSecondaryTeamDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TeamMergeRequestRejectedShownToSecondaryTeamDetails: \(error)"
            }
        }
    }

    public class TeamMergeRequestRejectedShownToSecondaryTeamDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TeamMergeRequestRejectedShownToSecondaryTeamDetails) throws -> JSON {
            let output = [
                "sent_by": try Serialization._StringSerializer.serialize(value.sentBy),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> TeamMergeRequestRejectedShownToSecondaryTeamDetails {
            switch json {
            case .dictionary(let dict):
                let sentBy = try Serialization._StringSerializer.deserialize(dict["sent_by"] ?? .null)
                return TeamMergeRequestRejectedShownToSecondaryTeamDetails(sentBy: sentBy)
            default:
                throw JSONSerializerError.deserializeError(type: TeamMergeRequestRejectedShownToSecondaryTeamDetails.self, json: json)
            }
        }
    }

    /// The TeamMergeRequestRejectedShownToSecondaryTeamType struct
    public class TeamMergeRequestRejectedShownToSecondaryTeamType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try TeamMergeRequestRejectedShownToSecondaryTeamTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TeamMergeRequestRejectedShownToSecondaryTeamTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TeamMergeRequestRejectedShownToSecondaryTeamType: \(error)"
            }
        }
    }

    public class TeamMergeRequestRejectedShownToSecondaryTeamTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TeamMergeRequestRejectedShownToSecondaryTeamType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> TeamMergeRequestRejectedShownToSecondaryTeamType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return TeamMergeRequestRejectedShownToSecondaryTeamType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: TeamMergeRequestRejectedShownToSecondaryTeamType.self, json: json)
            }
        }
    }

    /// Sent a team merge request reminder.
    public class TeamMergeRequestReminderDetails: CustomStringConvertible, JSONRepresentable {
        /// Team merge request reminder details.
        public let requestReminderDetails: TeamLog.TeamMergeRequestReminderExtraDetails
        public init(requestReminderDetails: TeamLog.TeamMergeRequestReminderExtraDetails) {
            self.requestReminderDetails = requestReminderDetails
        }

        func json() throws -> JSON {
            try TeamMergeRequestReminderDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TeamMergeRequestReminderDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TeamMergeRequestReminderDetails: \(error)"
            }
        }
    }

    public class TeamMergeRequestReminderDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TeamMergeRequestReminderDetails) throws -> JSON {
            let output = [
                "request_reminder_details": try TeamLog.TeamMergeRequestReminderExtraDetailsSerializer().serialize(value.requestReminderDetails),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> TeamMergeRequestReminderDetails {
            switch json {
            case .dictionary(let dict):
                let requestReminderDetails = try TeamLog.TeamMergeRequestReminderExtraDetailsSerializer()
                    .deserialize(dict["request_reminder_details"] ?? .null)
                return TeamMergeRequestReminderDetails(requestReminderDetails: requestReminderDetails)
            default:
                throw JSONSerializerError.deserializeError(type: TeamMergeRequestReminderDetails.self, json: json)
            }
        }
    }

    /// Team merge request reminder details
    public enum TeamMergeRequestReminderExtraDetails: CustomStringConvertible, JSONRepresentable {
        /// Team merge request reminder details shown to the primary team.
        case primaryTeam(TeamLog.PrimaryTeamRequestReminderDetails)
        /// Team merge request reminder details shown to the secondary team.
        case secondaryTeam(TeamLog.SecondaryTeamRequestReminderDetails)
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try TeamMergeRequestReminderExtraDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TeamMergeRequestReminderExtraDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TeamMergeRequestReminderExtraDetails: \(error)"
            }
        }
    }

    public class TeamMergeRequestReminderExtraDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TeamMergeRequestReminderExtraDetails) throws -> JSON {
            switch value {
            case .primaryTeam(let arg):
                var d = try Serialization.getFields(TeamLog.PrimaryTeamRequestReminderDetailsSerializer().serialize(arg))
                d[".tag"] = .str("primary_team")
                return .dictionary(d)
            case .secondaryTeam(let arg):
                var d = try Serialization.getFields(TeamLog.SecondaryTeamRequestReminderDetailsSerializer().serialize(arg))
                d[".tag"] = .str("secondary_team")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> TeamMergeRequestReminderExtraDetails {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "primary_team":
                    let v = try TeamLog.PrimaryTeamRequestReminderDetailsSerializer().deserialize(json)
                    return TeamMergeRequestReminderExtraDetails.primaryTeam(v)
                case "secondary_team":
                    let v = try TeamLog.SecondaryTeamRequestReminderDetailsSerializer().deserialize(json)
                    return TeamMergeRequestReminderExtraDetails.secondaryTeam(v)
                case "other":
                    return TeamMergeRequestReminderExtraDetails.other
                default:
                    return TeamMergeRequestReminderExtraDetails.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: TeamMergeRequestReminderExtraDetails.self, json: json)
            }
        }
    }

    /// Sent a team merge request reminder.
    public class TeamMergeRequestReminderShownToPrimaryTeamDetails: CustomStringConvertible, JSONRepresentable {
        /// The secondary team name.
        public let secondaryTeam: String
        /// The name of the primary team admin the request was sent to.
        public let sentTo: String
        public init(secondaryTeam: String, sentTo: String) {
            stringValidator()(secondaryTeam)
            self.secondaryTeam = secondaryTeam
            stringValidator()(sentTo)
            self.sentTo = sentTo
        }

        func json() throws -> JSON {
            try TeamMergeRequestReminderShownToPrimaryTeamDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TeamMergeRequestReminderShownToPrimaryTeamDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TeamMergeRequestReminderShownToPrimaryTeamDetails: \(error)"
            }
        }
    }

    public class TeamMergeRequestReminderShownToPrimaryTeamDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TeamMergeRequestReminderShownToPrimaryTeamDetails) throws -> JSON {
            let output = [
                "secondary_team": try Serialization._StringSerializer.serialize(value.secondaryTeam),
                "sent_to": try Serialization._StringSerializer.serialize(value.sentTo),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> TeamMergeRequestReminderShownToPrimaryTeamDetails {
            switch json {
            case .dictionary(let dict):
                let secondaryTeam = try Serialization._StringSerializer.deserialize(dict["secondary_team"] ?? .null)
                let sentTo = try Serialization._StringSerializer.deserialize(dict["sent_to"] ?? .null)
                return TeamMergeRequestReminderShownToPrimaryTeamDetails(secondaryTeam: secondaryTeam, sentTo: sentTo)
            default:
                throw JSONSerializerError.deserializeError(type: TeamMergeRequestReminderShownToPrimaryTeamDetails.self, json: json)
            }
        }
    }

    /// The TeamMergeRequestReminderShownToPrimaryTeamType struct
    public class TeamMergeRequestReminderShownToPrimaryTeamType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try TeamMergeRequestReminderShownToPrimaryTeamTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TeamMergeRequestReminderShownToPrimaryTeamTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TeamMergeRequestReminderShownToPrimaryTeamType: \(error)"
            }
        }
    }

    public class TeamMergeRequestReminderShownToPrimaryTeamTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TeamMergeRequestReminderShownToPrimaryTeamType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> TeamMergeRequestReminderShownToPrimaryTeamType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return TeamMergeRequestReminderShownToPrimaryTeamType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: TeamMergeRequestReminderShownToPrimaryTeamType.self, json: json)
            }
        }
    }

    /// Sent a team merge request reminder.
    public class TeamMergeRequestReminderShownToSecondaryTeamDetails: CustomStringConvertible, JSONRepresentable {
        /// The email of the primary team admin the request was sent to.
        public let sentTo: String
        public init(sentTo: String) {
            stringValidator()(sentTo)
            self.sentTo = sentTo
        }

        func json() throws -> JSON {
            try TeamMergeRequestReminderShownToSecondaryTeamDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TeamMergeRequestReminderShownToSecondaryTeamDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TeamMergeRequestReminderShownToSecondaryTeamDetails: \(error)"
            }
        }
    }

    public class TeamMergeRequestReminderShownToSecondaryTeamDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TeamMergeRequestReminderShownToSecondaryTeamDetails) throws -> JSON {
            let output = [
                "sent_to": try Serialization._StringSerializer.serialize(value.sentTo),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> TeamMergeRequestReminderShownToSecondaryTeamDetails {
            switch json {
            case .dictionary(let dict):
                let sentTo = try Serialization._StringSerializer.deserialize(dict["sent_to"] ?? .null)
                return TeamMergeRequestReminderShownToSecondaryTeamDetails(sentTo: sentTo)
            default:
                throw JSONSerializerError.deserializeError(type: TeamMergeRequestReminderShownToSecondaryTeamDetails.self, json: json)
            }
        }
    }

    /// The TeamMergeRequestReminderShownToSecondaryTeamType struct
    public class TeamMergeRequestReminderShownToSecondaryTeamType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try TeamMergeRequestReminderShownToSecondaryTeamTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TeamMergeRequestReminderShownToSecondaryTeamTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TeamMergeRequestReminderShownToSecondaryTeamType: \(error)"
            }
        }
    }

    public class TeamMergeRequestReminderShownToSecondaryTeamTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TeamMergeRequestReminderShownToSecondaryTeamType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> TeamMergeRequestReminderShownToSecondaryTeamType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return TeamMergeRequestReminderShownToSecondaryTeamType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: TeamMergeRequestReminderShownToSecondaryTeamType.self, json: json)
            }
        }
    }

    /// The TeamMergeRequestReminderType struct
    public class TeamMergeRequestReminderType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try TeamMergeRequestReminderTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TeamMergeRequestReminderTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TeamMergeRequestReminderType: \(error)"
            }
        }
    }

    public class TeamMergeRequestReminderTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TeamMergeRequestReminderType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> TeamMergeRequestReminderType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return TeamMergeRequestReminderType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: TeamMergeRequestReminderType.self, json: json)
            }
        }
    }

    /// Canceled the team merge.
    public class TeamMergeRequestRevokedDetails: CustomStringConvertible, JSONRepresentable {
        /// The name of the other team.
        public let team: String
        public init(team: String) {
            stringValidator()(team)
            self.team = team
        }

        func json() throws -> JSON {
            try TeamMergeRequestRevokedDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TeamMergeRequestRevokedDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TeamMergeRequestRevokedDetails: \(error)"
            }
        }
    }

    public class TeamMergeRequestRevokedDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TeamMergeRequestRevokedDetails) throws -> JSON {
            let output = [
                "team": try Serialization._StringSerializer.serialize(value.team),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> TeamMergeRequestRevokedDetails {
            switch json {
            case .dictionary(let dict):
                let team = try Serialization._StringSerializer.deserialize(dict["team"] ?? .null)
                return TeamMergeRequestRevokedDetails(team: team)
            default:
                throw JSONSerializerError.deserializeError(type: TeamMergeRequestRevokedDetails.self, json: json)
            }
        }
    }

    /// The TeamMergeRequestRevokedType struct
    public class TeamMergeRequestRevokedType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try TeamMergeRequestRevokedTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TeamMergeRequestRevokedTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TeamMergeRequestRevokedType: \(error)"
            }
        }
    }

    public class TeamMergeRequestRevokedTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TeamMergeRequestRevokedType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> TeamMergeRequestRevokedType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return TeamMergeRequestRevokedType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: TeamMergeRequestRevokedType.self, json: json)
            }
        }
    }

    /// Requested to merge their Dropbox team into yours.
    public class TeamMergeRequestSentShownToPrimaryTeamDetails: CustomStringConvertible, JSONRepresentable {
        /// The secondary team name.
        public let secondaryTeam: String
        /// The name of the primary team admin the request was sent to.
        public let sentTo: String
        public init(secondaryTeam: String, sentTo: String) {
            stringValidator()(secondaryTeam)
            self.secondaryTeam = secondaryTeam
            stringValidator()(sentTo)
            self.sentTo = sentTo
        }

        func json() throws -> JSON {
            try TeamMergeRequestSentShownToPrimaryTeamDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TeamMergeRequestSentShownToPrimaryTeamDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TeamMergeRequestSentShownToPrimaryTeamDetails: \(error)"
            }
        }
    }

    public class TeamMergeRequestSentShownToPrimaryTeamDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TeamMergeRequestSentShownToPrimaryTeamDetails) throws -> JSON {
            let output = [
                "secondary_team": try Serialization._StringSerializer.serialize(value.secondaryTeam),
                "sent_to": try Serialization._StringSerializer.serialize(value.sentTo),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> TeamMergeRequestSentShownToPrimaryTeamDetails {
            switch json {
            case .dictionary(let dict):
                let secondaryTeam = try Serialization._StringSerializer.deserialize(dict["secondary_team"] ?? .null)
                let sentTo = try Serialization._StringSerializer.deserialize(dict["sent_to"] ?? .null)
                return TeamMergeRequestSentShownToPrimaryTeamDetails(secondaryTeam: secondaryTeam, sentTo: sentTo)
            default:
                throw JSONSerializerError.deserializeError(type: TeamMergeRequestSentShownToPrimaryTeamDetails.self, json: json)
            }
        }
    }

    /// The TeamMergeRequestSentShownToPrimaryTeamType struct
    public class TeamMergeRequestSentShownToPrimaryTeamType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try TeamMergeRequestSentShownToPrimaryTeamTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TeamMergeRequestSentShownToPrimaryTeamTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TeamMergeRequestSentShownToPrimaryTeamType: \(error)"
            }
        }
    }

    public class TeamMergeRequestSentShownToPrimaryTeamTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TeamMergeRequestSentShownToPrimaryTeamType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> TeamMergeRequestSentShownToPrimaryTeamType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return TeamMergeRequestSentShownToPrimaryTeamType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: TeamMergeRequestSentShownToPrimaryTeamType.self, json: json)
            }
        }
    }

    /// Requested to merge your team into another Dropbox team.
    public class TeamMergeRequestSentShownToSecondaryTeamDetails: CustomStringConvertible, JSONRepresentable {
        /// The email of the primary team admin the request was sent to.
        public let sentTo: String
        public init(sentTo: String) {
            stringValidator()(sentTo)
            self.sentTo = sentTo
        }

        func json() throws -> JSON {
            try TeamMergeRequestSentShownToSecondaryTeamDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TeamMergeRequestSentShownToSecondaryTeamDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TeamMergeRequestSentShownToSecondaryTeamDetails: \(error)"
            }
        }
    }

    public class TeamMergeRequestSentShownToSecondaryTeamDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TeamMergeRequestSentShownToSecondaryTeamDetails) throws -> JSON {
            let output = [
                "sent_to": try Serialization._StringSerializer.serialize(value.sentTo),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> TeamMergeRequestSentShownToSecondaryTeamDetails {
            switch json {
            case .dictionary(let dict):
                let sentTo = try Serialization._StringSerializer.deserialize(dict["sent_to"] ?? .null)
                return TeamMergeRequestSentShownToSecondaryTeamDetails(sentTo: sentTo)
            default:
                throw JSONSerializerError.deserializeError(type: TeamMergeRequestSentShownToSecondaryTeamDetails.self, json: json)
            }
        }
    }

    /// The TeamMergeRequestSentShownToSecondaryTeamType struct
    public class TeamMergeRequestSentShownToSecondaryTeamType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try TeamMergeRequestSentShownToSecondaryTeamTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TeamMergeRequestSentShownToSecondaryTeamTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TeamMergeRequestSentShownToSecondaryTeamType: \(error)"
            }
        }
    }

    public class TeamMergeRequestSentShownToSecondaryTeamTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TeamMergeRequestSentShownToSecondaryTeamType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> TeamMergeRequestSentShownToSecondaryTeamType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return TeamMergeRequestSentShownToSecondaryTeamType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: TeamMergeRequestSentShownToSecondaryTeamType.self, json: json)
            }
        }
    }

    /// Merged this team into another team.
    public class TeamMergeToDetails: CustomStringConvertible, JSONRepresentable {
        /// The name of the team that this team was merged into.
        public let teamName: String
        public init(teamName: String) {
            stringValidator()(teamName)
            self.teamName = teamName
        }

        func json() throws -> JSON {
            try TeamMergeToDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TeamMergeToDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TeamMergeToDetails: \(error)"
            }
        }
    }

    public class TeamMergeToDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TeamMergeToDetails) throws -> JSON {
            let output = [
                "team_name": try Serialization._StringSerializer.serialize(value.teamName),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> TeamMergeToDetails {
            switch json {
            case .dictionary(let dict):
                let teamName = try Serialization._StringSerializer.deserialize(dict["team_name"] ?? .null)
                return TeamMergeToDetails(teamName: teamName)
            default:
                throw JSONSerializerError.deserializeError(type: TeamMergeToDetails.self, json: json)
            }
        }
    }

    /// The TeamMergeToType struct
    public class TeamMergeToType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try TeamMergeToTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TeamMergeToTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TeamMergeToType: \(error)"
            }
        }
    }

    public class TeamMergeToTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TeamMergeToType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> TeamMergeToType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return TeamMergeToType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: TeamMergeToType.self, json: json)
            }
        }
    }

    /// Team name details
    public class TeamName: CustomStringConvertible, JSONRepresentable {
        /// Team's display name.
        public let teamDisplayName: String
        /// Team's legal name.
        public let teamLegalName: String
        public init(teamDisplayName: String, teamLegalName: String) {
            stringValidator()(teamDisplayName)
            self.teamDisplayName = teamDisplayName
            stringValidator()(teamLegalName)
            self.teamLegalName = teamLegalName
        }

        func json() throws -> JSON {
            try TeamNameSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TeamNameSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TeamName: \(error)"
            }
        }
    }

    public class TeamNameSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TeamName) throws -> JSON {
            let output = [
                "team_display_name": try Serialization._StringSerializer.serialize(value.teamDisplayName),
                "team_legal_name": try Serialization._StringSerializer.serialize(value.teamLegalName),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> TeamName {
            switch json {
            case .dictionary(let dict):
                let teamDisplayName = try Serialization._StringSerializer.deserialize(dict["team_display_name"] ?? .null)
                let teamLegalName = try Serialization._StringSerializer.deserialize(dict["team_legal_name"] ?? .null)
                return TeamName(teamDisplayName: teamDisplayName, teamLegalName: teamLegalName)
            default:
                throw JSONSerializerError.deserializeError(type: TeamName.self, json: json)
            }
        }
    }

    /// Added team background to display on shared link headers.
    public class TeamProfileAddBackgroundDetails: CustomStringConvertible, JSONRepresentable {
        func json() throws -> JSON {
            try TeamProfileAddBackgroundDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TeamProfileAddBackgroundDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TeamProfileAddBackgroundDetails: \(error)"
            }
        }
    }

    public class TeamProfileAddBackgroundDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TeamProfileAddBackgroundDetails) throws -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> TeamProfileAddBackgroundDetails {
            switch json {
            case .dictionary:
                return TeamProfileAddBackgroundDetails()
            default:
                throw JSONSerializerError.deserializeError(type: TeamProfileAddBackgroundDetails.self, json: json)
            }
        }
    }

    /// The TeamProfileAddBackgroundType struct
    public class TeamProfileAddBackgroundType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try TeamProfileAddBackgroundTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TeamProfileAddBackgroundTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TeamProfileAddBackgroundType: \(error)"
            }
        }
    }

    public class TeamProfileAddBackgroundTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TeamProfileAddBackgroundType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> TeamProfileAddBackgroundType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return TeamProfileAddBackgroundType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: TeamProfileAddBackgroundType.self, json: json)
            }
        }
    }

    /// Added team logo to display on shared link headers.
    public class TeamProfileAddLogoDetails: CustomStringConvertible, JSONRepresentable {
        func json() throws -> JSON {
            try TeamProfileAddLogoDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TeamProfileAddLogoDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TeamProfileAddLogoDetails: \(error)"
            }
        }
    }

    public class TeamProfileAddLogoDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TeamProfileAddLogoDetails) throws -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> TeamProfileAddLogoDetails {
            switch json {
            case .dictionary:
                return TeamProfileAddLogoDetails()
            default:
                throw JSONSerializerError.deserializeError(type: TeamProfileAddLogoDetails.self, json: json)
            }
        }
    }

    /// The TeamProfileAddLogoType struct
    public class TeamProfileAddLogoType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try TeamProfileAddLogoTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TeamProfileAddLogoTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TeamProfileAddLogoType: \(error)"
            }
        }
    }

    public class TeamProfileAddLogoTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TeamProfileAddLogoType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> TeamProfileAddLogoType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return TeamProfileAddLogoType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: TeamProfileAddLogoType.self, json: json)
            }
        }
    }

    /// Changed team background displayed on shared link headers.
    public class TeamProfileChangeBackgroundDetails: CustomStringConvertible, JSONRepresentable {
        func json() throws -> JSON {
            try TeamProfileChangeBackgroundDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TeamProfileChangeBackgroundDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TeamProfileChangeBackgroundDetails: \(error)"
            }
        }
    }

    public class TeamProfileChangeBackgroundDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TeamProfileChangeBackgroundDetails) throws -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> TeamProfileChangeBackgroundDetails {
            switch json {
            case .dictionary:
                return TeamProfileChangeBackgroundDetails()
            default:
                throw JSONSerializerError.deserializeError(type: TeamProfileChangeBackgroundDetails.self, json: json)
            }
        }
    }

    /// The TeamProfileChangeBackgroundType struct
    public class TeamProfileChangeBackgroundType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try TeamProfileChangeBackgroundTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TeamProfileChangeBackgroundTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TeamProfileChangeBackgroundType: \(error)"
            }
        }
    }

    public class TeamProfileChangeBackgroundTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TeamProfileChangeBackgroundType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> TeamProfileChangeBackgroundType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return TeamProfileChangeBackgroundType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: TeamProfileChangeBackgroundType.self, json: json)
            }
        }
    }

    /// Changed default language for team.
    public class TeamProfileChangeDefaultLanguageDetails: CustomStringConvertible, JSONRepresentable {
        /// New team's default language.
        public let newValue: String
        /// Previous team's default language.
        public let previousValue: String
        public init(newValue: String, previousValue: String) {
            stringValidator(minLength: 2)(newValue)
            self.newValue = newValue
            stringValidator(minLength: 2)(previousValue)
            self.previousValue = previousValue
        }

        func json() throws -> JSON {
            try TeamProfileChangeDefaultLanguageDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TeamProfileChangeDefaultLanguageDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TeamProfileChangeDefaultLanguageDetails: \(error)"
            }
        }
    }

    public class TeamProfileChangeDefaultLanguageDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TeamProfileChangeDefaultLanguageDetails) throws -> JSON {
            let output = [
                "new_value": try Serialization._StringSerializer.serialize(value.newValue),
                "previous_value": try Serialization._StringSerializer.serialize(value.previousValue),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> TeamProfileChangeDefaultLanguageDetails {
            switch json {
            case .dictionary(let dict):
                let newValue = try Serialization._StringSerializer.deserialize(dict["new_value"] ?? .null)
                let previousValue = try Serialization._StringSerializer.deserialize(dict["previous_value"] ?? .null)
                return TeamProfileChangeDefaultLanguageDetails(newValue: newValue, previousValue: previousValue)
            default:
                throw JSONSerializerError.deserializeError(type: TeamProfileChangeDefaultLanguageDetails.self, json: json)
            }
        }
    }

    /// The TeamProfileChangeDefaultLanguageType struct
    public class TeamProfileChangeDefaultLanguageType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try TeamProfileChangeDefaultLanguageTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TeamProfileChangeDefaultLanguageTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TeamProfileChangeDefaultLanguageType: \(error)"
            }
        }
    }

    public class TeamProfileChangeDefaultLanguageTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TeamProfileChangeDefaultLanguageType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> TeamProfileChangeDefaultLanguageType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return TeamProfileChangeDefaultLanguageType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: TeamProfileChangeDefaultLanguageType.self, json: json)
            }
        }
    }

    /// Changed team logo displayed on shared link headers.
    public class TeamProfileChangeLogoDetails: CustomStringConvertible, JSONRepresentable {
        func json() throws -> JSON {
            try TeamProfileChangeLogoDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TeamProfileChangeLogoDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TeamProfileChangeLogoDetails: \(error)"
            }
        }
    }

    public class TeamProfileChangeLogoDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TeamProfileChangeLogoDetails) throws -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> TeamProfileChangeLogoDetails {
            switch json {
            case .dictionary:
                return TeamProfileChangeLogoDetails()
            default:
                throw JSONSerializerError.deserializeError(type: TeamProfileChangeLogoDetails.self, json: json)
            }
        }
    }

    /// The TeamProfileChangeLogoType struct
    public class TeamProfileChangeLogoType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try TeamProfileChangeLogoTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TeamProfileChangeLogoTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TeamProfileChangeLogoType: \(error)"
            }
        }
    }

    public class TeamProfileChangeLogoTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TeamProfileChangeLogoType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> TeamProfileChangeLogoType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return TeamProfileChangeLogoType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: TeamProfileChangeLogoType.self, json: json)
            }
        }
    }

    /// Changed team name.
    public class TeamProfileChangeNameDetails: CustomStringConvertible, JSONRepresentable {
        /// Previous teams name. Might be missing due to historical data gap.
        public let previousValue: TeamLog.TeamName?
        /// New team name.
        public let newValue: TeamLog.TeamName
        public init(newValue: TeamLog.TeamName, previousValue: TeamLog.TeamName? = nil) {
            self.previousValue = previousValue
            self.newValue = newValue
        }

        func json() throws -> JSON {
            try TeamProfileChangeNameDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TeamProfileChangeNameDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TeamProfileChangeNameDetails: \(error)"
            }
        }
    }

    public class TeamProfileChangeNameDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TeamProfileChangeNameDetails) throws -> JSON {
            let output = [
                "new_value": try TeamLog.TeamNameSerializer().serialize(value.newValue),
                "previous_value": try NullableSerializer(TeamLog.TeamNameSerializer()).serialize(value.previousValue),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> TeamProfileChangeNameDetails {
            switch json {
            case .dictionary(let dict):
                let newValue = try TeamLog.TeamNameSerializer().deserialize(dict["new_value"] ?? .null)
                let previousValue = try NullableSerializer(TeamLog.TeamNameSerializer()).deserialize(dict["previous_value"] ?? .null)
                return TeamProfileChangeNameDetails(newValue: newValue, previousValue: previousValue)
            default:
                throw JSONSerializerError.deserializeError(type: TeamProfileChangeNameDetails.self, json: json)
            }
        }
    }

    /// The TeamProfileChangeNameType struct
    public class TeamProfileChangeNameType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try TeamProfileChangeNameTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TeamProfileChangeNameTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TeamProfileChangeNameType: \(error)"
            }
        }
    }

    public class TeamProfileChangeNameTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TeamProfileChangeNameType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> TeamProfileChangeNameType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return TeamProfileChangeNameType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: TeamProfileChangeNameType.self, json: json)
            }
        }
    }

    /// Removed team background displayed on shared link headers.
    public class TeamProfileRemoveBackgroundDetails: CustomStringConvertible, JSONRepresentable {
        func json() throws -> JSON {
            try TeamProfileRemoveBackgroundDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TeamProfileRemoveBackgroundDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TeamProfileRemoveBackgroundDetails: \(error)"
            }
        }
    }

    public class TeamProfileRemoveBackgroundDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TeamProfileRemoveBackgroundDetails) throws -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> TeamProfileRemoveBackgroundDetails {
            switch json {
            case .dictionary:
                return TeamProfileRemoveBackgroundDetails()
            default:
                throw JSONSerializerError.deserializeError(type: TeamProfileRemoveBackgroundDetails.self, json: json)
            }
        }
    }

    /// The TeamProfileRemoveBackgroundType struct
    public class TeamProfileRemoveBackgroundType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try TeamProfileRemoveBackgroundTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TeamProfileRemoveBackgroundTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TeamProfileRemoveBackgroundType: \(error)"
            }
        }
    }

    public class TeamProfileRemoveBackgroundTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TeamProfileRemoveBackgroundType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> TeamProfileRemoveBackgroundType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return TeamProfileRemoveBackgroundType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: TeamProfileRemoveBackgroundType.self, json: json)
            }
        }
    }

    /// Removed team logo displayed on shared link headers.
    public class TeamProfileRemoveLogoDetails: CustomStringConvertible, JSONRepresentable {
        func json() throws -> JSON {
            try TeamProfileRemoveLogoDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TeamProfileRemoveLogoDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TeamProfileRemoveLogoDetails: \(error)"
            }
        }
    }

    public class TeamProfileRemoveLogoDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TeamProfileRemoveLogoDetails) throws -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> TeamProfileRemoveLogoDetails {
            switch json {
            case .dictionary:
                return TeamProfileRemoveLogoDetails()
            default:
                throw JSONSerializerError.deserializeError(type: TeamProfileRemoveLogoDetails.self, json: json)
            }
        }
    }

    /// The TeamProfileRemoveLogoType struct
    public class TeamProfileRemoveLogoType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try TeamProfileRemoveLogoTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TeamProfileRemoveLogoTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TeamProfileRemoveLogoType: \(error)"
            }
        }
    }

    public class TeamProfileRemoveLogoTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TeamProfileRemoveLogoType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> TeamProfileRemoveLogoType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return TeamProfileRemoveLogoType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: TeamProfileRemoveLogoType.self, json: json)
            }
        }
    }

    /// Policy for controlling whether team selective sync is enabled for team.
    public enum TeamSelectiveSyncPolicy: CustomStringConvertible, JSONRepresentable {
        /// An unspecified error.
        case disabled
        /// An unspecified error.
        case enabled
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try TeamSelectiveSyncPolicySerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TeamSelectiveSyncPolicySerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TeamSelectiveSyncPolicy: \(error)"
            }
        }
    }

    public class TeamSelectiveSyncPolicySerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TeamSelectiveSyncPolicy) throws -> JSON {
            switch value {
            case .disabled:
                var d = [String: JSON]()
                d[".tag"] = .str("disabled")
                return .dictionary(d)
            case .enabled:
                var d = [String: JSON]()
                d[".tag"] = .str("enabled")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> TeamSelectiveSyncPolicy {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "disabled":
                    return TeamSelectiveSyncPolicy.disabled
                case "enabled":
                    return TeamSelectiveSyncPolicy.enabled
                case "other":
                    return TeamSelectiveSyncPolicy.other
                default:
                    return TeamSelectiveSyncPolicy.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: TeamSelectiveSyncPolicy.self, json: json)
            }
        }
    }

    /// Enabled/disabled Team Selective Sync for team.
    public class TeamSelectiveSyncPolicyChangedDetails: CustomStringConvertible, JSONRepresentable {
        /// New Team Selective Sync policy.
        public let newValue: TeamLog.TeamSelectiveSyncPolicy
        /// Previous Team Selective Sync policy.
        public let previousValue: TeamLog.TeamSelectiveSyncPolicy
        public init(newValue: TeamLog.TeamSelectiveSyncPolicy, previousValue: TeamLog.TeamSelectiveSyncPolicy) {
            self.newValue = newValue
            self.previousValue = previousValue
        }

        func json() throws -> JSON {
            try TeamSelectiveSyncPolicyChangedDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TeamSelectiveSyncPolicyChangedDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TeamSelectiveSyncPolicyChangedDetails: \(error)"
            }
        }
    }

    public class TeamSelectiveSyncPolicyChangedDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TeamSelectiveSyncPolicyChangedDetails) throws -> JSON {
            let output = [
                "new_value": try TeamLog.TeamSelectiveSyncPolicySerializer().serialize(value.newValue),
                "previous_value": try TeamLog.TeamSelectiveSyncPolicySerializer().serialize(value.previousValue),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> TeamSelectiveSyncPolicyChangedDetails {
            switch json {
            case .dictionary(let dict):
                let newValue = try TeamLog.TeamSelectiveSyncPolicySerializer().deserialize(dict["new_value"] ?? .null)
                let previousValue = try TeamLog.TeamSelectiveSyncPolicySerializer().deserialize(dict["previous_value"] ?? .null)
                return TeamSelectiveSyncPolicyChangedDetails(newValue: newValue, previousValue: previousValue)
            default:
                throw JSONSerializerError.deserializeError(type: TeamSelectiveSyncPolicyChangedDetails.self, json: json)
            }
        }
    }

    /// The TeamSelectiveSyncPolicyChangedType struct
    public class TeamSelectiveSyncPolicyChangedType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try TeamSelectiveSyncPolicyChangedTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TeamSelectiveSyncPolicyChangedTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TeamSelectiveSyncPolicyChangedType: \(error)"
            }
        }
    }

    public class TeamSelectiveSyncPolicyChangedTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TeamSelectiveSyncPolicyChangedType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> TeamSelectiveSyncPolicyChangedType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return TeamSelectiveSyncPolicyChangedType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: TeamSelectiveSyncPolicyChangedType.self, json: json)
            }
        }
    }

    /// Changed sync default.
    public class TeamSelectiveSyncSettingsChangedDetails: CustomStringConvertible, JSONRepresentable {
        /// Previous value.
        public let previousValue: Files.SyncSetting
        /// New value.
        public let newValue: Files.SyncSetting
        public init(previousValue: Files.SyncSetting, newValue: Files.SyncSetting) {
            self.previousValue = previousValue
            self.newValue = newValue
        }

        func json() throws -> JSON {
            try TeamSelectiveSyncSettingsChangedDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TeamSelectiveSyncSettingsChangedDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TeamSelectiveSyncSettingsChangedDetails: \(error)"
            }
        }
    }

    public class TeamSelectiveSyncSettingsChangedDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TeamSelectiveSyncSettingsChangedDetails) throws -> JSON {
            let output = [
                "previous_value": try Files.SyncSettingSerializer().serialize(value.previousValue),
                "new_value": try Files.SyncSettingSerializer().serialize(value.newValue),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> TeamSelectiveSyncSettingsChangedDetails {
            switch json {
            case .dictionary(let dict):
                let previousValue = try Files.SyncSettingSerializer().deserialize(dict["previous_value"] ?? .null)
                let newValue = try Files.SyncSettingSerializer().deserialize(dict["new_value"] ?? .null)
                return TeamSelectiveSyncSettingsChangedDetails(previousValue: previousValue, newValue: newValue)
            default:
                throw JSONSerializerError.deserializeError(type: TeamSelectiveSyncSettingsChangedDetails.self, json: json)
            }
        }
    }

    /// The TeamSelectiveSyncSettingsChangedType struct
    public class TeamSelectiveSyncSettingsChangedType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try TeamSelectiveSyncSettingsChangedTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TeamSelectiveSyncSettingsChangedTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TeamSelectiveSyncSettingsChangedType: \(error)"
            }
        }
    }

    public class TeamSelectiveSyncSettingsChangedTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TeamSelectiveSyncSettingsChangedType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> TeamSelectiveSyncSettingsChangedType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return TeamSelectiveSyncSettingsChangedType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: TeamSelectiveSyncSettingsChangedType.self, json: json)
            }
        }
    }

    /// Edited the approved list for sharing externally.
    public class TeamSharingWhitelistSubjectsChangedDetails: CustomStringConvertible, JSONRepresentable {
        /// Domains or emails added to the approved list for sharing externally.
        public let addedWhitelistSubjects: [String]
        /// Domains or emails removed from the approved list for sharing externally.
        public let removedWhitelistSubjects: [String]
        public init(addedWhitelistSubjects: [String], removedWhitelistSubjects: [String]) {
            arrayValidator(itemValidator: stringValidator())(addedWhitelistSubjects)
            self.addedWhitelistSubjects = addedWhitelistSubjects
            arrayValidator(itemValidator: stringValidator())(removedWhitelistSubjects)
            self.removedWhitelistSubjects = removedWhitelistSubjects
        }

        func json() throws -> JSON {
            try TeamSharingWhitelistSubjectsChangedDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TeamSharingWhitelistSubjectsChangedDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TeamSharingWhitelistSubjectsChangedDetails: \(error)"
            }
        }
    }

    public class TeamSharingWhitelistSubjectsChangedDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TeamSharingWhitelistSubjectsChangedDetails) throws -> JSON {
            let output = [
                "added_whitelist_subjects": try ArraySerializer(Serialization._StringSerializer).serialize(value.addedWhitelistSubjects),
                "removed_whitelist_subjects": try ArraySerializer(Serialization._StringSerializer).serialize(value.removedWhitelistSubjects),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> TeamSharingWhitelistSubjectsChangedDetails {
            switch json {
            case .dictionary(let dict):
                let addedWhitelistSubjects = try ArraySerializer(Serialization._StringSerializer).deserialize(dict["added_whitelist_subjects"] ?? .null)
                let removedWhitelistSubjects = try ArraySerializer(Serialization._StringSerializer).deserialize(dict["removed_whitelist_subjects"] ?? .null)
                return TeamSharingWhitelistSubjectsChangedDetails(
                    addedWhitelistSubjects: addedWhitelistSubjects,
                    removedWhitelistSubjects: removedWhitelistSubjects
                )
            default:
                throw JSONSerializerError.deserializeError(type: TeamSharingWhitelistSubjectsChangedDetails.self, json: json)
            }
        }
    }

    /// The TeamSharingWhitelistSubjectsChangedType struct
    public class TeamSharingWhitelistSubjectsChangedType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try TeamSharingWhitelistSubjectsChangedTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TeamSharingWhitelistSubjectsChangedTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TeamSharingWhitelistSubjectsChangedType: \(error)"
            }
        }
    }

    public class TeamSharingWhitelistSubjectsChangedTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TeamSharingWhitelistSubjectsChangedType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> TeamSharingWhitelistSubjectsChangedType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return TeamSharingWhitelistSubjectsChangedType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: TeamSharingWhitelistSubjectsChangedType.self, json: json)
            }
        }
    }

    /// Added backup phone for two-step verification.
    public class TfaAddBackupPhoneDetails: CustomStringConvertible, JSONRepresentable {
        func json() throws -> JSON {
            try TfaAddBackupPhoneDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TfaAddBackupPhoneDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TfaAddBackupPhoneDetails: \(error)"
            }
        }
    }

    public class TfaAddBackupPhoneDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TfaAddBackupPhoneDetails) throws -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> TfaAddBackupPhoneDetails {
            switch json {
            case .dictionary:
                return TfaAddBackupPhoneDetails()
            default:
                throw JSONSerializerError.deserializeError(type: TfaAddBackupPhoneDetails.self, json: json)
            }
        }
    }

    /// The TfaAddBackupPhoneType struct
    public class TfaAddBackupPhoneType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try TfaAddBackupPhoneTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TfaAddBackupPhoneTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TfaAddBackupPhoneType: \(error)"
            }
        }
    }

    public class TfaAddBackupPhoneTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TfaAddBackupPhoneType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> TfaAddBackupPhoneType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return TfaAddBackupPhoneType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: TfaAddBackupPhoneType.self, json: json)
            }
        }
    }

    /// Added members to two factor authentication exception list.
    public class TfaAddExceptionDetails: CustomStringConvertible, JSONRepresentable {
        func json() throws -> JSON {
            try TfaAddExceptionDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TfaAddExceptionDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TfaAddExceptionDetails: \(error)"
            }
        }
    }

    public class TfaAddExceptionDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TfaAddExceptionDetails) throws -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> TfaAddExceptionDetails {
            switch json {
            case .dictionary:
                return TfaAddExceptionDetails()
            default:
                throw JSONSerializerError.deserializeError(type: TfaAddExceptionDetails.self, json: json)
            }
        }
    }

    /// The TfaAddExceptionType struct
    public class TfaAddExceptionType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try TfaAddExceptionTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TfaAddExceptionTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TfaAddExceptionType: \(error)"
            }
        }
    }

    public class TfaAddExceptionTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TfaAddExceptionType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> TfaAddExceptionType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return TfaAddExceptionType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: TfaAddExceptionType.self, json: json)
            }
        }
    }

    /// Added security key for two-step verification.
    public class TfaAddSecurityKeyDetails: CustomStringConvertible, JSONRepresentable {
        func json() throws -> JSON {
            try TfaAddSecurityKeyDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TfaAddSecurityKeyDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TfaAddSecurityKeyDetails: \(error)"
            }
        }
    }

    public class TfaAddSecurityKeyDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TfaAddSecurityKeyDetails) throws -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> TfaAddSecurityKeyDetails {
            switch json {
            case .dictionary:
                return TfaAddSecurityKeyDetails()
            default:
                throw JSONSerializerError.deserializeError(type: TfaAddSecurityKeyDetails.self, json: json)
            }
        }
    }

    /// The TfaAddSecurityKeyType struct
    public class TfaAddSecurityKeyType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try TfaAddSecurityKeyTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TfaAddSecurityKeyTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TfaAddSecurityKeyType: \(error)"
            }
        }
    }

    public class TfaAddSecurityKeyTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TfaAddSecurityKeyType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> TfaAddSecurityKeyType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return TfaAddSecurityKeyType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: TfaAddSecurityKeyType.self, json: json)
            }
        }
    }

    /// Changed backup phone for two-step verification.
    public class TfaChangeBackupPhoneDetails: CustomStringConvertible, JSONRepresentable {
        func json() throws -> JSON {
            try TfaChangeBackupPhoneDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TfaChangeBackupPhoneDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TfaChangeBackupPhoneDetails: \(error)"
            }
        }
    }

    public class TfaChangeBackupPhoneDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TfaChangeBackupPhoneDetails) throws -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> TfaChangeBackupPhoneDetails {
            switch json {
            case .dictionary:
                return TfaChangeBackupPhoneDetails()
            default:
                throw JSONSerializerError.deserializeError(type: TfaChangeBackupPhoneDetails.self, json: json)
            }
        }
    }

    /// The TfaChangeBackupPhoneType struct
    public class TfaChangeBackupPhoneType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try TfaChangeBackupPhoneTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TfaChangeBackupPhoneTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TfaChangeBackupPhoneType: \(error)"
            }
        }
    }

    public class TfaChangeBackupPhoneTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TfaChangeBackupPhoneType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> TfaChangeBackupPhoneType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return TfaChangeBackupPhoneType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: TfaChangeBackupPhoneType.self, json: json)
            }
        }
    }

    /// Changed two-step verification setting for team.
    public class TfaChangePolicyDetails: CustomStringConvertible, JSONRepresentable {
        /// New change policy.
        public let newValue: TeamPolicies.TwoStepVerificationPolicy
        /// Previous change policy. Might be missing due to historical data gap.
        public let previousValue: TeamPolicies.TwoStepVerificationPolicy?
        public init(newValue: TeamPolicies.TwoStepVerificationPolicy, previousValue: TeamPolicies.TwoStepVerificationPolicy? = nil) {
            self.newValue = newValue
            self.previousValue = previousValue
        }

        func json() throws -> JSON {
            try TfaChangePolicyDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TfaChangePolicyDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TfaChangePolicyDetails: \(error)"
            }
        }
    }

    public class TfaChangePolicyDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TfaChangePolicyDetails) throws -> JSON {
            let output = [
                "new_value": try TeamPolicies.TwoStepVerificationPolicySerializer().serialize(value.newValue),
                "previous_value": try NullableSerializer(TeamPolicies.TwoStepVerificationPolicySerializer()).serialize(value.previousValue),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> TfaChangePolicyDetails {
            switch json {
            case .dictionary(let dict):
                let newValue = try TeamPolicies.TwoStepVerificationPolicySerializer().deserialize(dict["new_value"] ?? .null)
                let previousValue = try NullableSerializer(TeamPolicies.TwoStepVerificationPolicySerializer()).deserialize(dict["previous_value"] ?? .null)
                return TfaChangePolicyDetails(newValue: newValue, previousValue: previousValue)
            default:
                throw JSONSerializerError.deserializeError(type: TfaChangePolicyDetails.self, json: json)
            }
        }
    }

    /// The TfaChangePolicyType struct
    public class TfaChangePolicyType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try TfaChangePolicyTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TfaChangePolicyTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TfaChangePolicyType: \(error)"
            }
        }
    }

    public class TfaChangePolicyTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TfaChangePolicyType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> TfaChangePolicyType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return TfaChangePolicyType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: TfaChangePolicyType.self, json: json)
            }
        }
    }

    /// Enabled/disabled/changed two-step verification setting.
    public class TfaChangeStatusDetails: CustomStringConvertible, JSONRepresentable {
        /// The new two factor authentication configuration.
        public let newValue: TeamLog.TfaConfiguration
        /// The previous two factor authentication configuration. Might be missing due to historical data gap.
        public let previousValue: TeamLog.TfaConfiguration?
        /// Used two factor authentication rescue code. This flag is relevant when the two factor authentication
        /// configuration is disabled.
        public let usedRescueCode: Bool?
        public init(newValue: TeamLog.TfaConfiguration, previousValue: TeamLog.TfaConfiguration? = nil, usedRescueCode: Bool? = nil) {
            self.newValue = newValue
            self.previousValue = previousValue
            self.usedRescueCode = usedRescueCode
        }

        func json() throws -> JSON {
            try TfaChangeStatusDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TfaChangeStatusDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TfaChangeStatusDetails: \(error)"
            }
        }
    }

    public class TfaChangeStatusDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TfaChangeStatusDetails) throws -> JSON {
            let output = [
                "new_value": try TeamLog.TfaConfigurationSerializer().serialize(value.newValue),
                "previous_value": try NullableSerializer(TeamLog.TfaConfigurationSerializer()).serialize(value.previousValue),
                "used_rescue_code": try NullableSerializer(Serialization._BoolSerializer).serialize(value.usedRescueCode),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> TfaChangeStatusDetails {
            switch json {
            case .dictionary(let dict):
                let newValue = try TeamLog.TfaConfigurationSerializer().deserialize(dict["new_value"] ?? .null)
                let previousValue = try NullableSerializer(TeamLog.TfaConfigurationSerializer()).deserialize(dict["previous_value"] ?? .null)
                let usedRescueCode = try NullableSerializer(Serialization._BoolSerializer).deserialize(dict["used_rescue_code"] ?? .null)
                return TfaChangeStatusDetails(newValue: newValue, previousValue: previousValue, usedRescueCode: usedRescueCode)
            default:
                throw JSONSerializerError.deserializeError(type: TfaChangeStatusDetails.self, json: json)
            }
        }
    }

    /// The TfaChangeStatusType struct
    public class TfaChangeStatusType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try TfaChangeStatusTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TfaChangeStatusTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TfaChangeStatusType: \(error)"
            }
        }
    }

    public class TfaChangeStatusTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TfaChangeStatusType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> TfaChangeStatusType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return TfaChangeStatusType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: TfaChangeStatusType.self, json: json)
            }
        }
    }

    /// Two factor authentication configuration. Note: the enabled option is deprecated.
    public enum TfaConfiguration: CustomStringConvertible, JSONRepresentable {
        /// An unspecified error.
        case authenticator
        /// An unspecified error.
        case disabled
        /// An unspecified error.
        case enabled
        /// An unspecified error.
        case sms
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try TfaConfigurationSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TfaConfigurationSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TfaConfiguration: \(error)"
            }
        }
    }

    public class TfaConfigurationSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TfaConfiguration) throws -> JSON {
            switch value {
            case .authenticator:
                var d = [String: JSON]()
                d[".tag"] = .str("authenticator")
                return .dictionary(d)
            case .disabled:
                var d = [String: JSON]()
                d[".tag"] = .str("disabled")
                return .dictionary(d)
            case .enabled:
                var d = [String: JSON]()
                d[".tag"] = .str("enabled")
                return .dictionary(d)
            case .sms:
                var d = [String: JSON]()
                d[".tag"] = .str("sms")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> TfaConfiguration {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "authenticator":
                    return TfaConfiguration.authenticator
                case "disabled":
                    return TfaConfiguration.disabled
                case "enabled":
                    return TfaConfiguration.enabled
                case "sms":
                    return TfaConfiguration.sms
                case "other":
                    return TfaConfiguration.other
                default:
                    return TfaConfiguration.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: TfaConfiguration.self, json: json)
            }
        }
    }

    /// Removed backup phone for two-step verification.
    public class TfaRemoveBackupPhoneDetails: CustomStringConvertible, JSONRepresentable {
        func json() throws -> JSON {
            try TfaRemoveBackupPhoneDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TfaRemoveBackupPhoneDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TfaRemoveBackupPhoneDetails: \(error)"
            }
        }
    }

    public class TfaRemoveBackupPhoneDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TfaRemoveBackupPhoneDetails) throws -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> TfaRemoveBackupPhoneDetails {
            switch json {
            case .dictionary:
                return TfaRemoveBackupPhoneDetails()
            default:
                throw JSONSerializerError.deserializeError(type: TfaRemoveBackupPhoneDetails.self, json: json)
            }
        }
    }

    /// The TfaRemoveBackupPhoneType struct
    public class TfaRemoveBackupPhoneType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try TfaRemoveBackupPhoneTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TfaRemoveBackupPhoneTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TfaRemoveBackupPhoneType: \(error)"
            }
        }
    }

    public class TfaRemoveBackupPhoneTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TfaRemoveBackupPhoneType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> TfaRemoveBackupPhoneType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return TfaRemoveBackupPhoneType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: TfaRemoveBackupPhoneType.self, json: json)
            }
        }
    }

    /// Removed members from two factor authentication exception list.
    public class TfaRemoveExceptionDetails: CustomStringConvertible, JSONRepresentable {
        func json() throws -> JSON {
            try TfaRemoveExceptionDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TfaRemoveExceptionDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TfaRemoveExceptionDetails: \(error)"
            }
        }
    }

    public class TfaRemoveExceptionDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TfaRemoveExceptionDetails) throws -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> TfaRemoveExceptionDetails {
            switch json {
            case .dictionary:
                return TfaRemoveExceptionDetails()
            default:
                throw JSONSerializerError.deserializeError(type: TfaRemoveExceptionDetails.self, json: json)
            }
        }
    }

    /// The TfaRemoveExceptionType struct
    public class TfaRemoveExceptionType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try TfaRemoveExceptionTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TfaRemoveExceptionTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TfaRemoveExceptionType: \(error)"
            }
        }
    }

    public class TfaRemoveExceptionTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TfaRemoveExceptionType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> TfaRemoveExceptionType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return TfaRemoveExceptionType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: TfaRemoveExceptionType.self, json: json)
            }
        }
    }

    /// Removed security key for two-step verification.
    public class TfaRemoveSecurityKeyDetails: CustomStringConvertible, JSONRepresentable {
        func json() throws -> JSON {
            try TfaRemoveSecurityKeyDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TfaRemoveSecurityKeyDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TfaRemoveSecurityKeyDetails: \(error)"
            }
        }
    }

    public class TfaRemoveSecurityKeyDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TfaRemoveSecurityKeyDetails) throws -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> TfaRemoveSecurityKeyDetails {
            switch json {
            case .dictionary:
                return TfaRemoveSecurityKeyDetails()
            default:
                throw JSONSerializerError.deserializeError(type: TfaRemoveSecurityKeyDetails.self, json: json)
            }
        }
    }

    /// The TfaRemoveSecurityKeyType struct
    public class TfaRemoveSecurityKeyType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try TfaRemoveSecurityKeyTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TfaRemoveSecurityKeyTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TfaRemoveSecurityKeyType: \(error)"
            }
        }
    }

    public class TfaRemoveSecurityKeyTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TfaRemoveSecurityKeyType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> TfaRemoveSecurityKeyType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return TfaRemoveSecurityKeyType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: TfaRemoveSecurityKeyType.self, json: json)
            }
        }
    }

    /// Reset two-step verification for team member.
    public class TfaResetDetails: CustomStringConvertible, JSONRepresentable {
        func json() throws -> JSON {
            try TfaResetDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TfaResetDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TfaResetDetails: \(error)"
            }
        }
    }

    public class TfaResetDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TfaResetDetails) throws -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> TfaResetDetails {
            switch json {
            case .dictionary:
                return TfaResetDetails()
            default:
                throw JSONSerializerError.deserializeError(type: TfaResetDetails.self, json: json)
            }
        }
    }

    /// The TfaResetType struct
    public class TfaResetType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try TfaResetTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TfaResetTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TfaResetType: \(error)"
            }
        }
    }

    public class TfaResetTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TfaResetType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> TfaResetType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return TfaResetType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: TfaResetType.self, json: json)
            }
        }
    }

    /// The TimeUnit union
    public enum TimeUnit: CustomStringConvertible, JSONRepresentable {
        /// An unspecified error.
        case days
        /// An unspecified error.
        case hours
        /// An unspecified error.
        case milliseconds
        /// An unspecified error.
        case minutes
        /// An unspecified error.
        case months
        /// An unspecified error.
        case seconds
        /// An unspecified error.
        case weeks
        /// An unspecified error.
        case years
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try TimeUnitSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TimeUnitSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TimeUnit: \(error)"
            }
        }
    }

    public class TimeUnitSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TimeUnit) throws -> JSON {
            switch value {
            case .days:
                var d = [String: JSON]()
                d[".tag"] = .str("days")
                return .dictionary(d)
            case .hours:
                var d = [String: JSON]()
                d[".tag"] = .str("hours")
                return .dictionary(d)
            case .milliseconds:
                var d = [String: JSON]()
                d[".tag"] = .str("milliseconds")
                return .dictionary(d)
            case .minutes:
                var d = [String: JSON]()
                d[".tag"] = .str("minutes")
                return .dictionary(d)
            case .months:
                var d = [String: JSON]()
                d[".tag"] = .str("months")
                return .dictionary(d)
            case .seconds:
                var d = [String: JSON]()
                d[".tag"] = .str("seconds")
                return .dictionary(d)
            case .weeks:
                var d = [String: JSON]()
                d[".tag"] = .str("weeks")
                return .dictionary(d)
            case .years:
                var d = [String: JSON]()
                d[".tag"] = .str("years")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> TimeUnit {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "days":
                    return TimeUnit.days
                case "hours":
                    return TimeUnit.hours
                case "milliseconds":
                    return TimeUnit.milliseconds
                case "minutes":
                    return TimeUnit.minutes
                case "months":
                    return TimeUnit.months
                case "seconds":
                    return TimeUnit.seconds
                case "weeks":
                    return TimeUnit.weeks
                case "years":
                    return TimeUnit.years
                case "other":
                    return TimeUnit.other
                default:
                    return TimeUnit.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: TimeUnit.self, json: json)
            }
        }
    }

    /// User that is not a member of the team but considered trusted.
    public class TrustedNonTeamMemberLogInfo: TeamLog.UserLogInfo {
        /// Indicates the type of the member of a trusted team.
        public let trustedNonTeamMemberType: TeamLog.TrustedNonTeamMemberType
        /// Details about this user's trusted team.
        public let team: TeamLog.TeamLogInfo?
        public init(
            trustedNonTeamMemberType: TeamLog.TrustedNonTeamMemberType,
            accountId: String? = nil,
            displayName: String? = nil,
            email: String? = nil,
            team: TeamLog.TeamLogInfo? = nil
        ) {
            self.trustedNonTeamMemberType = trustedNonTeamMemberType
            self.team = team
            super.init(accountId: accountId, displayName: displayName, email: email)
        }

        public override var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TrustedNonTeamMemberLogInfoSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TrustedNonTeamMemberLogInfo: \(error)"
            }
        }
    }

    public class TrustedNonTeamMemberLogInfoSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TrustedNonTeamMemberLogInfo) throws -> JSON {
            let output = [
                "trusted_non_team_member_type": try TeamLog.TrustedNonTeamMemberTypeSerializer().serialize(value.trustedNonTeamMemberType),
                "account_id": try NullableSerializer(Serialization._StringSerializer).serialize(value.accountId),
                "display_name": try NullableSerializer(Serialization._StringSerializer).serialize(value.displayName),
                "email": try NullableSerializer(Serialization._StringSerializer).serialize(value.email),
                "team": try NullableSerializer(TeamLog.TeamLogInfoSerializer()).serialize(value.team),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> TrustedNonTeamMemberLogInfo {
            switch json {
            case .dictionary(let dict):
                let trustedNonTeamMemberType = try TeamLog.TrustedNonTeamMemberTypeSerializer().deserialize(dict["trusted_non_team_member_type"] ?? .null)
                let accountId = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["account_id"] ?? .null)
                let displayName = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["display_name"] ?? .null)
                let email = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["email"] ?? .null)
                let team = try NullableSerializer(TeamLog.TeamLogInfoSerializer()).deserialize(dict["team"] ?? .null)
                return TrustedNonTeamMemberLogInfo(
                    trustedNonTeamMemberType: trustedNonTeamMemberType,
                    accountId: accountId,
                    displayName: displayName,
                    email: email,
                    team: team
                )
            default:
                throw JSONSerializerError.deserializeError(type: TrustedNonTeamMemberLogInfo.self, json: json)
            }
        }
    }

    /// The TrustedNonTeamMemberType union
    public enum TrustedNonTeamMemberType: CustomStringConvertible, JSONRepresentable {
        /// An unspecified error.
        case enterpriseAdmin
        /// An unspecified error.
        case multiInstanceAdmin
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try TrustedNonTeamMemberTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TrustedNonTeamMemberTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TrustedNonTeamMemberType: \(error)"
            }
        }
    }

    public class TrustedNonTeamMemberTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TrustedNonTeamMemberType) throws -> JSON {
            switch value {
            case .enterpriseAdmin:
                var d = [String: JSON]()
                d[".tag"] = .str("enterprise_admin")
                return .dictionary(d)
            case .multiInstanceAdmin:
                var d = [String: JSON]()
                d[".tag"] = .str("multi_instance_admin")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> TrustedNonTeamMemberType {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "enterprise_admin":
                    return TrustedNonTeamMemberType.enterpriseAdmin
                case "multi_instance_admin":
                    return TrustedNonTeamMemberType.multiInstanceAdmin
                case "other":
                    return TrustedNonTeamMemberType.other
                default:
                    return TrustedNonTeamMemberType.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: TrustedNonTeamMemberType.self, json: json)
            }
        }
    }

    /// The TrustedTeamsRequestAction union
    public enum TrustedTeamsRequestAction: CustomStringConvertible, JSONRepresentable {
        /// An unspecified error.
        case accepted
        /// An unspecified error.
        case declined
        /// An unspecified error.
        case expired
        /// An unspecified error.
        case invited
        /// An unspecified error.
        case revoked
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try TrustedTeamsRequestActionSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TrustedTeamsRequestActionSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TrustedTeamsRequestAction: \(error)"
            }
        }
    }

    public class TrustedTeamsRequestActionSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TrustedTeamsRequestAction) throws -> JSON {
            switch value {
            case .accepted:
                var d = [String: JSON]()
                d[".tag"] = .str("accepted")
                return .dictionary(d)
            case .declined:
                var d = [String: JSON]()
                d[".tag"] = .str("declined")
                return .dictionary(d)
            case .expired:
                var d = [String: JSON]()
                d[".tag"] = .str("expired")
                return .dictionary(d)
            case .invited:
                var d = [String: JSON]()
                d[".tag"] = .str("invited")
                return .dictionary(d)
            case .revoked:
                var d = [String: JSON]()
                d[".tag"] = .str("revoked")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> TrustedTeamsRequestAction {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "accepted":
                    return TrustedTeamsRequestAction.accepted
                case "declined":
                    return TrustedTeamsRequestAction.declined
                case "expired":
                    return TrustedTeamsRequestAction.expired
                case "invited":
                    return TrustedTeamsRequestAction.invited
                case "revoked":
                    return TrustedTeamsRequestAction.revoked
                case "other":
                    return TrustedTeamsRequestAction.other
                default:
                    return TrustedTeamsRequestAction.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: TrustedTeamsRequestAction.self, json: json)
            }
        }
    }

    /// The TrustedTeamsRequestState union
    public enum TrustedTeamsRequestState: CustomStringConvertible, JSONRepresentable {
        /// An unspecified error.
        case invited
        /// An unspecified error.
        case linked
        /// An unspecified error.
        case unlinked
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try TrustedTeamsRequestStateSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TrustedTeamsRequestStateSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TrustedTeamsRequestState: \(error)"
            }
        }
    }

    public class TrustedTeamsRequestStateSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TrustedTeamsRequestState) throws -> JSON {
            switch value {
            case .invited:
                var d = [String: JSON]()
                d[".tag"] = .str("invited")
                return .dictionary(d)
            case .linked:
                var d = [String: JSON]()
                d[".tag"] = .str("linked")
                return .dictionary(d)
            case .unlinked:
                var d = [String: JSON]()
                d[".tag"] = .str("unlinked")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> TrustedTeamsRequestState {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "invited":
                    return TrustedTeamsRequestState.invited
                case "linked":
                    return TrustedTeamsRequestState.linked
                case "unlinked":
                    return TrustedTeamsRequestState.unlinked
                case "other":
                    return TrustedTeamsRequestState.other
                default:
                    return TrustedTeamsRequestState.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: TrustedTeamsRequestState.self, json: json)
            }
        }
    }

    /// Enabled/disabled option for members to link personal Dropbox account and team account to same computer.
    public class TwoAccountChangePolicyDetails: CustomStringConvertible, JSONRepresentable {
        /// New two account policy.
        public let newValue: TeamLog.TwoAccountPolicy
        /// Previous two account policy. Might be missing due to historical data gap.
        public let previousValue: TeamLog.TwoAccountPolicy?
        public init(newValue: TeamLog.TwoAccountPolicy, previousValue: TeamLog.TwoAccountPolicy? = nil) {
            self.newValue = newValue
            self.previousValue = previousValue
        }

        func json() throws -> JSON {
            try TwoAccountChangePolicyDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TwoAccountChangePolicyDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TwoAccountChangePolicyDetails: \(error)"
            }
        }
    }

    public class TwoAccountChangePolicyDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TwoAccountChangePolicyDetails) throws -> JSON {
            let output = [
                "new_value": try TeamLog.TwoAccountPolicySerializer().serialize(value.newValue),
                "previous_value": try NullableSerializer(TeamLog.TwoAccountPolicySerializer()).serialize(value.previousValue),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> TwoAccountChangePolicyDetails {
            switch json {
            case .dictionary(let dict):
                let newValue = try TeamLog.TwoAccountPolicySerializer().deserialize(dict["new_value"] ?? .null)
                let previousValue = try NullableSerializer(TeamLog.TwoAccountPolicySerializer()).deserialize(dict["previous_value"] ?? .null)
                return TwoAccountChangePolicyDetails(newValue: newValue, previousValue: previousValue)
            default:
                throw JSONSerializerError.deserializeError(type: TwoAccountChangePolicyDetails.self, json: json)
            }
        }
    }

    /// The TwoAccountChangePolicyType struct
    public class TwoAccountChangePolicyType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try TwoAccountChangePolicyTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TwoAccountChangePolicyTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TwoAccountChangePolicyType: \(error)"
            }
        }
    }

    public class TwoAccountChangePolicyTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TwoAccountChangePolicyType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> TwoAccountChangePolicyType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return TwoAccountChangePolicyType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: TwoAccountChangePolicyType.self, json: json)
            }
        }
    }

    /// Policy for pairing personal account to work account
    public enum TwoAccountPolicy: CustomStringConvertible, JSONRepresentable {
        /// An unspecified error.
        case disabled
        /// An unspecified error.
        case enabled
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try TwoAccountPolicySerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TwoAccountPolicySerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TwoAccountPolicy: \(error)"
            }
        }
    }

    public class TwoAccountPolicySerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TwoAccountPolicy) throws -> JSON {
            switch value {
            case .disabled:
                var d = [String: JSON]()
                d[".tag"] = .str("disabled")
                return .dictionary(d)
            case .enabled:
                var d = [String: JSON]()
                d[".tag"] = .str("enabled")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> TwoAccountPolicy {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "disabled":
                    return TwoAccountPolicy.disabled
                case "enabled":
                    return TwoAccountPolicy.enabled
                case "other":
                    return TwoAccountPolicy.other
                default:
                    return TwoAccountPolicy.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: TwoAccountPolicy.self, json: json)
            }
        }
    }

    /// Reverted naming convention.
    public class UndoNamingConventionDetails: CustomStringConvertible, JSONRepresentable {
        func json() throws -> JSON {
            try UndoNamingConventionDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try UndoNamingConventionDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for UndoNamingConventionDetails: \(error)"
            }
        }
    }

    public class UndoNamingConventionDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: UndoNamingConventionDetails) throws -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> UndoNamingConventionDetails {
            switch json {
            case .dictionary:
                return UndoNamingConventionDetails()
            default:
                throw JSONSerializerError.deserializeError(type: UndoNamingConventionDetails.self, json: json)
            }
        }
    }

    /// The UndoNamingConventionType struct
    public class UndoNamingConventionType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try UndoNamingConventionTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try UndoNamingConventionTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for UndoNamingConventionType: \(error)"
            }
        }
    }

    public class UndoNamingConventionTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: UndoNamingConventionType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> UndoNamingConventionType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return UndoNamingConventionType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: UndoNamingConventionType.self, json: json)
            }
        }
    }

    /// Removed multi-file organize.
    public class UndoOrganizeFolderWithTidyDetails: CustomStringConvertible, JSONRepresentable {
        func json() throws -> JSON {
            try UndoOrganizeFolderWithTidyDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try UndoOrganizeFolderWithTidyDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for UndoOrganizeFolderWithTidyDetails: \(error)"
            }
        }
    }

    public class UndoOrganizeFolderWithTidyDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: UndoOrganizeFolderWithTidyDetails) throws -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> UndoOrganizeFolderWithTidyDetails {
            switch json {
            case .dictionary:
                return UndoOrganizeFolderWithTidyDetails()
            default:
                throw JSONSerializerError.deserializeError(type: UndoOrganizeFolderWithTidyDetails.self, json: json)
            }
        }
    }

    /// The UndoOrganizeFolderWithTidyType struct
    public class UndoOrganizeFolderWithTidyType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try UndoOrganizeFolderWithTidyTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try UndoOrganizeFolderWithTidyTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for UndoOrganizeFolderWithTidyType: \(error)"
            }
        }
    }

    public class UndoOrganizeFolderWithTidyTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: UndoOrganizeFolderWithTidyType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> UndoOrganizeFolderWithTidyType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return UndoOrganizeFolderWithTidyType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: UndoOrganizeFolderWithTidyType.self, json: json)
            }
        }
    }

    /// User linked app
    public class UserLinkedAppLogInfo: TeamLog.AppLogInfo {
        public override var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try UserLinkedAppLogInfoSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for UserLinkedAppLogInfo: \(error)"
            }
        }
    }

    public class UserLinkedAppLogInfoSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: UserLinkedAppLogInfo) throws -> JSON {
            let output = [
                "app_id": try NullableSerializer(Serialization._StringSerializer).serialize(value.appId),
                "display_name": try NullableSerializer(Serialization._StringSerializer).serialize(value.displayName),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> UserLinkedAppLogInfo {
            switch json {
            case .dictionary(let dict):
                let appId = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["app_id"] ?? .null)
                let displayName = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["display_name"] ?? .null)
                return UserLinkedAppLogInfo(appId: appId, displayName: displayName)
            default:
                throw JSONSerializerError.deserializeError(type: UserLinkedAppLogInfo.self, json: json)
            }
        }
    }

    /// User's name logged information
    public class UserNameLogInfo: CustomStringConvertible, JSONRepresentable {
        /// Given name.
        public let givenName: String
        /// Surname.
        public let surname: String
        /// Locale. Might be missing due to historical data gap.
        public let locale: String?
        public init(givenName: String, surname: String, locale: String? = nil) {
            stringValidator()(givenName)
            self.givenName = givenName
            stringValidator()(surname)
            self.surname = surname
            nullableValidator(stringValidator())(locale)
            self.locale = locale
        }

        func json() throws -> JSON {
            try UserNameLogInfoSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try UserNameLogInfoSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for UserNameLogInfo: \(error)"
            }
        }
    }

    public class UserNameLogInfoSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: UserNameLogInfo) throws -> JSON {
            let output = [
                "given_name": try Serialization._StringSerializer.serialize(value.givenName),
                "surname": try Serialization._StringSerializer.serialize(value.surname),
                "locale": try NullableSerializer(Serialization._StringSerializer).serialize(value.locale),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> UserNameLogInfo {
            switch json {
            case .dictionary(let dict):
                let givenName = try Serialization._StringSerializer.deserialize(dict["given_name"] ?? .null)
                let surname = try Serialization._StringSerializer.deserialize(dict["surname"] ?? .null)
                let locale = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["locale"] ?? .null)
                return UserNameLogInfo(givenName: givenName, surname: surname, locale: locale)
            default:
                throw JSONSerializerError.deserializeError(type: UserNameLogInfo.self, json: json)
            }
        }
    }

    /// User or team linked app. Used when linked type is missing due to historical data gap.
    public class UserOrTeamLinkedAppLogInfo: TeamLog.AppLogInfo {
        public override var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try UserOrTeamLinkedAppLogInfoSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for UserOrTeamLinkedAppLogInfo: \(error)"
            }
        }
    }

    public class UserOrTeamLinkedAppLogInfoSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: UserOrTeamLinkedAppLogInfo) throws -> JSON {
            let output = [
                "app_id": try NullableSerializer(Serialization._StringSerializer).serialize(value.appId),
                "display_name": try NullableSerializer(Serialization._StringSerializer).serialize(value.displayName),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> UserOrTeamLinkedAppLogInfo {
            switch json {
            case .dictionary(let dict):
                let appId = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["app_id"] ?? .null)
                let displayName = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["display_name"] ?? .null)
                return UserOrTeamLinkedAppLogInfo(appId: appId, displayName: displayName)
            default:
                throw JSONSerializerError.deserializeError(type: UserOrTeamLinkedAppLogInfo.self, json: json)
            }
        }
    }

    /// Tagged a file.
    public class UserTagsAddedDetails: CustomStringConvertible, JSONRepresentable {
        /// values.
        public let values: [String]
        public init(values: [String]) {
            arrayValidator(itemValidator: stringValidator())(values)
            self.values = values
        }

        func json() throws -> JSON {
            try UserTagsAddedDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try UserTagsAddedDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for UserTagsAddedDetails: \(error)"
            }
        }
    }

    public class UserTagsAddedDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: UserTagsAddedDetails) throws -> JSON {
            let output = [
                "values": try ArraySerializer(Serialization._StringSerializer).serialize(value.values),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> UserTagsAddedDetails {
            switch json {
            case .dictionary(let dict):
                let values = try ArraySerializer(Serialization._StringSerializer).deserialize(dict["values"] ?? .null)
                return UserTagsAddedDetails(values: values)
            default:
                throw JSONSerializerError.deserializeError(type: UserTagsAddedDetails.self, json: json)
            }
        }
    }

    /// The UserTagsAddedType struct
    public class UserTagsAddedType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try UserTagsAddedTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try UserTagsAddedTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for UserTagsAddedType: \(error)"
            }
        }
    }

    public class UserTagsAddedTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: UserTagsAddedType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> UserTagsAddedType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return UserTagsAddedType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: UserTagsAddedType.self, json: json)
            }
        }
    }

    /// Removed tags.
    public class UserTagsRemovedDetails: CustomStringConvertible, JSONRepresentable {
        /// values.
        public let values: [String]
        public init(values: [String]) {
            arrayValidator(itemValidator: stringValidator())(values)
            self.values = values
        }

        func json() throws -> JSON {
            try UserTagsRemovedDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try UserTagsRemovedDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for UserTagsRemovedDetails: \(error)"
            }
        }
    }

    public class UserTagsRemovedDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: UserTagsRemovedDetails) throws -> JSON {
            let output = [
                "values": try ArraySerializer(Serialization._StringSerializer).serialize(value.values),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> UserTagsRemovedDetails {
            switch json {
            case .dictionary(let dict):
                let values = try ArraySerializer(Serialization._StringSerializer).deserialize(dict["values"] ?? .null)
                return UserTagsRemovedDetails(values: values)
            default:
                throw JSONSerializerError.deserializeError(type: UserTagsRemovedDetails.self, json: json)
            }
        }
    }

    /// The UserTagsRemovedType struct
    public class UserTagsRemovedType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try UserTagsRemovedTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try UserTagsRemovedTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for UserTagsRemovedType: \(error)"
            }
        }
    }

    public class UserTagsRemovedTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: UserTagsRemovedType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> UserTagsRemovedType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return UserTagsRemovedType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: UserTagsRemovedType.self, json: json)
            }
        }
    }

    /// Changed team policy for viewer info.
    public class ViewerInfoPolicyChangedDetails: CustomStringConvertible, JSONRepresentable {
        /// Previous Viewer Info policy.
        public let previousValue: TeamLog.PassPolicy
        /// New Viewer Info policy.
        public let newValue: TeamLog.PassPolicy
        public init(previousValue: TeamLog.PassPolicy, newValue: TeamLog.PassPolicy) {
            self.previousValue = previousValue
            self.newValue = newValue
        }

        func json() throws -> JSON {
            try ViewerInfoPolicyChangedDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ViewerInfoPolicyChangedDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ViewerInfoPolicyChangedDetails: \(error)"
            }
        }
    }

    public class ViewerInfoPolicyChangedDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ViewerInfoPolicyChangedDetails) throws -> JSON {
            let output = [
                "previous_value": try TeamLog.PassPolicySerializer().serialize(value.previousValue),
                "new_value": try TeamLog.PassPolicySerializer().serialize(value.newValue),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ViewerInfoPolicyChangedDetails {
            switch json {
            case .dictionary(let dict):
                let previousValue = try TeamLog.PassPolicySerializer().deserialize(dict["previous_value"] ?? .null)
                let newValue = try TeamLog.PassPolicySerializer().deserialize(dict["new_value"] ?? .null)
                return ViewerInfoPolicyChangedDetails(previousValue: previousValue, newValue: newValue)
            default:
                throw JSONSerializerError.deserializeError(type: ViewerInfoPolicyChangedDetails.self, json: json)
            }
        }
    }

    /// The ViewerInfoPolicyChangedType struct
    public class ViewerInfoPolicyChangedType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try ViewerInfoPolicyChangedTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ViewerInfoPolicyChangedTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ViewerInfoPolicyChangedType: \(error)"
            }
        }
    }

    public class ViewerInfoPolicyChangedTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ViewerInfoPolicyChangedType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ViewerInfoPolicyChangedType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return ViewerInfoPolicyChangedType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: ViewerInfoPolicyChangedType.self, json: json)
            }
        }
    }

    /// Policy for controlling team access to watermarking feature
    public enum WatermarkingPolicy: CustomStringConvertible, JSONRepresentable {
        /// An unspecified error.
        case disabled
        /// An unspecified error.
        case enabled
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try WatermarkingPolicySerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try WatermarkingPolicySerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for WatermarkingPolicy: \(error)"
            }
        }
    }

    public class WatermarkingPolicySerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: WatermarkingPolicy) throws -> JSON {
            switch value {
            case .disabled:
                var d = [String: JSON]()
                d[".tag"] = .str("disabled")
                return .dictionary(d)
            case .enabled:
                var d = [String: JSON]()
                d[".tag"] = .str("enabled")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> WatermarkingPolicy {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "disabled":
                    return WatermarkingPolicy.disabled
                case "enabled":
                    return WatermarkingPolicy.enabled
                case "other":
                    return WatermarkingPolicy.other
                default:
                    return WatermarkingPolicy.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: WatermarkingPolicy.self, json: json)
            }
        }
    }

    /// Changed watermarking policy for team.
    public class WatermarkingPolicyChangedDetails: CustomStringConvertible, JSONRepresentable {
        /// New watermarking policy.
        public let newValue: TeamLog.WatermarkingPolicy
        /// Previous watermarking policy.
        public let previousValue: TeamLog.WatermarkingPolicy
        public init(newValue: TeamLog.WatermarkingPolicy, previousValue: TeamLog.WatermarkingPolicy) {
            self.newValue = newValue
            self.previousValue = previousValue
        }

        func json() throws -> JSON {
            try WatermarkingPolicyChangedDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try WatermarkingPolicyChangedDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for WatermarkingPolicyChangedDetails: \(error)"
            }
        }
    }

    public class WatermarkingPolicyChangedDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: WatermarkingPolicyChangedDetails) throws -> JSON {
            let output = [
                "new_value": try TeamLog.WatermarkingPolicySerializer().serialize(value.newValue),
                "previous_value": try TeamLog.WatermarkingPolicySerializer().serialize(value.previousValue),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> WatermarkingPolicyChangedDetails {
            switch json {
            case .dictionary(let dict):
                let newValue = try TeamLog.WatermarkingPolicySerializer().deserialize(dict["new_value"] ?? .null)
                let previousValue = try TeamLog.WatermarkingPolicySerializer().deserialize(dict["previous_value"] ?? .null)
                return WatermarkingPolicyChangedDetails(newValue: newValue, previousValue: previousValue)
            default:
                throw JSONSerializerError.deserializeError(type: WatermarkingPolicyChangedDetails.self, json: json)
            }
        }
    }

    /// The WatermarkingPolicyChangedType struct
    public class WatermarkingPolicyChangedType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try WatermarkingPolicyChangedTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try WatermarkingPolicyChangedTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for WatermarkingPolicyChangedType: \(error)"
            }
        }
    }

    public class WatermarkingPolicyChangedTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: WatermarkingPolicyChangedType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> WatermarkingPolicyChangedType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return WatermarkingPolicyChangedType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: WatermarkingPolicyChangedType.self, json: json)
            }
        }
    }

    /// Information on active web sessions
    public class WebDeviceSessionLogInfo: TeamLog.DeviceSessionLogInfo {
        /// Web session unique id.
        public let sessionInfo: TeamLog.WebSessionLogInfo?
        /// Information on the hosting device.
        public let userAgent: String
        /// Information on the hosting operating system.
        public let os: String
        /// Information on the browser used for this web session.
        public let browser: String
        public init(
            userAgent: String,
            os: String,
            browser: String,
            ipAddress: String? = nil,
            created: Date? = nil,
            updated: Date? = nil,
            sessionInfo: TeamLog.WebSessionLogInfo? = nil
        ) {
            self.sessionInfo = sessionInfo
            stringValidator()(userAgent)
            self.userAgent = userAgent
            stringValidator()(os)
            self.os = os
            stringValidator()(browser)
            self.browser = browser
            super.init(ipAddress: ipAddress, created: created, updated: updated)
        }

        public override var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try WebDeviceSessionLogInfoSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for WebDeviceSessionLogInfo: \(error)"
            }
        }
    }

    public class WebDeviceSessionLogInfoSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: WebDeviceSessionLogInfo) throws -> JSON {
            let output = [
                "user_agent": try Serialization._StringSerializer.serialize(value.userAgent),
                "os": try Serialization._StringSerializer.serialize(value.os),
                "browser": try Serialization._StringSerializer.serialize(value.browser),
                "ip_address": try NullableSerializer(Serialization._StringSerializer).serialize(value.ipAddress),
                "created": try NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.created),
                "updated": try NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.updated),
                "session_info": try NullableSerializer(TeamLog.WebSessionLogInfoSerializer()).serialize(value.sessionInfo),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> WebDeviceSessionLogInfo {
            switch json {
            case .dictionary(let dict):
                let userAgent = try Serialization._StringSerializer.deserialize(dict["user_agent"] ?? .null)
                let os = try Serialization._StringSerializer.deserialize(dict["os"] ?? .null)
                let browser = try Serialization._StringSerializer.deserialize(dict["browser"] ?? .null)
                let ipAddress = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["ip_address"] ?? .null)
                let created = try NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).deserialize(dict["created"] ?? .null)
                let updated = try NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).deserialize(dict["updated"] ?? .null)
                let sessionInfo = try NullableSerializer(TeamLog.WebSessionLogInfoSerializer()).deserialize(dict["session_info"] ?? .null)
                return WebDeviceSessionLogInfo(
                    userAgent: userAgent,
                    os: os,
                    browser: browser,
                    ipAddress: ipAddress,
                    created: created,
                    updated: updated,
                    sessionInfo: sessionInfo
                )
            default:
                throw JSONSerializerError.deserializeError(type: WebDeviceSessionLogInfo.self, json: json)
            }
        }
    }

    /// Web session.
    public class WebSessionLogInfo: TeamLog.SessionLogInfo {
        public override var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try WebSessionLogInfoSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for WebSessionLogInfo: \(error)"
            }
        }
    }

    public class WebSessionLogInfoSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: WebSessionLogInfo) throws -> JSON {
            let output = [
                "session_id": try NullableSerializer(Serialization._StringSerializer).serialize(value.sessionId),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> WebSessionLogInfo {
            switch json {
            case .dictionary(let dict):
                let sessionId = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["session_id"] ?? .null)
                return WebSessionLogInfo(sessionId: sessionId)
            default:
                throw JSONSerializerError.deserializeError(type: WebSessionLogInfo.self, json: json)
            }
        }
    }

    /// Changed limit on active sessions per member.
    public class WebSessionsChangeActiveSessionLimitDetails: CustomStringConvertible, JSONRepresentable {
        /// Previous max number of concurrent active sessions policy.
        public let previousValue: String
        /// New max number of concurrent active sessions policy.
        public let newValue: String
        public init(previousValue: String, newValue: String) {
            stringValidator()(previousValue)
            self.previousValue = previousValue
            stringValidator()(newValue)
            self.newValue = newValue
        }

        func json() throws -> JSON {
            try WebSessionsChangeActiveSessionLimitDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try WebSessionsChangeActiveSessionLimitDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for WebSessionsChangeActiveSessionLimitDetails: \(error)"
            }
        }
    }

    public class WebSessionsChangeActiveSessionLimitDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: WebSessionsChangeActiveSessionLimitDetails) throws -> JSON {
            let output = [
                "previous_value": try Serialization._StringSerializer.serialize(value.previousValue),
                "new_value": try Serialization._StringSerializer.serialize(value.newValue),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> WebSessionsChangeActiveSessionLimitDetails {
            switch json {
            case .dictionary(let dict):
                let previousValue = try Serialization._StringSerializer.deserialize(dict["previous_value"] ?? .null)
                let newValue = try Serialization._StringSerializer.deserialize(dict["new_value"] ?? .null)
                return WebSessionsChangeActiveSessionLimitDetails(previousValue: previousValue, newValue: newValue)
            default:
                throw JSONSerializerError.deserializeError(type: WebSessionsChangeActiveSessionLimitDetails.self, json: json)
            }
        }
    }

    /// The WebSessionsChangeActiveSessionLimitType struct
    public class WebSessionsChangeActiveSessionLimitType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try WebSessionsChangeActiveSessionLimitTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try WebSessionsChangeActiveSessionLimitTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for WebSessionsChangeActiveSessionLimitType: \(error)"
            }
        }
    }

    public class WebSessionsChangeActiveSessionLimitTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: WebSessionsChangeActiveSessionLimitType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> WebSessionsChangeActiveSessionLimitType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return WebSessionsChangeActiveSessionLimitType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: WebSessionsChangeActiveSessionLimitType.self, json: json)
            }
        }
    }

    /// Changed how long members can stay signed in to Dropbox.com.
    public class WebSessionsChangeFixedLengthPolicyDetails: CustomStringConvertible, JSONRepresentable {
        /// New session length policy. Might be missing due to historical data gap.
        public let newValue: TeamLog.WebSessionsFixedLengthPolicy?
        /// Previous session length policy. Might be missing due to historical data gap.
        public let previousValue: TeamLog.WebSessionsFixedLengthPolicy?
        public init(newValue: TeamLog.WebSessionsFixedLengthPolicy? = nil, previousValue: TeamLog.WebSessionsFixedLengthPolicy? = nil) {
            self.newValue = newValue
            self.previousValue = previousValue
        }

        func json() throws -> JSON {
            try WebSessionsChangeFixedLengthPolicyDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try WebSessionsChangeFixedLengthPolicyDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for WebSessionsChangeFixedLengthPolicyDetails: \(error)"
            }
        }
    }

    public class WebSessionsChangeFixedLengthPolicyDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: WebSessionsChangeFixedLengthPolicyDetails) throws -> JSON {
            let output = [
                "new_value": try NullableSerializer(TeamLog.WebSessionsFixedLengthPolicySerializer()).serialize(value.newValue),
                "previous_value": try NullableSerializer(TeamLog.WebSessionsFixedLengthPolicySerializer()).serialize(value.previousValue),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> WebSessionsChangeFixedLengthPolicyDetails {
            switch json {
            case .dictionary(let dict):
                let newValue = try NullableSerializer(TeamLog.WebSessionsFixedLengthPolicySerializer()).deserialize(dict["new_value"] ?? .null)
                let previousValue = try NullableSerializer(TeamLog.WebSessionsFixedLengthPolicySerializer()).deserialize(dict["previous_value"] ?? .null)
                return WebSessionsChangeFixedLengthPolicyDetails(newValue: newValue, previousValue: previousValue)
            default:
                throw JSONSerializerError.deserializeError(type: WebSessionsChangeFixedLengthPolicyDetails.self, json: json)
            }
        }
    }

    /// The WebSessionsChangeFixedLengthPolicyType struct
    public class WebSessionsChangeFixedLengthPolicyType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try WebSessionsChangeFixedLengthPolicyTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try WebSessionsChangeFixedLengthPolicyTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for WebSessionsChangeFixedLengthPolicyType: \(error)"
            }
        }
    }

    public class WebSessionsChangeFixedLengthPolicyTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: WebSessionsChangeFixedLengthPolicyType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> WebSessionsChangeFixedLengthPolicyType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return WebSessionsChangeFixedLengthPolicyType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: WebSessionsChangeFixedLengthPolicyType.self, json: json)
            }
        }
    }

    /// Changed how long team members can be idle while signed in to Dropbox.com.
    public class WebSessionsChangeIdleLengthPolicyDetails: CustomStringConvertible, JSONRepresentable {
        /// New idle length policy. Might be missing due to historical data gap.
        public let newValue: TeamLog.WebSessionsIdleLengthPolicy?
        /// Previous idle length policy. Might be missing due to historical data gap.
        public let previousValue: TeamLog.WebSessionsIdleLengthPolicy?
        public init(newValue: TeamLog.WebSessionsIdleLengthPolicy? = nil, previousValue: TeamLog.WebSessionsIdleLengthPolicy? = nil) {
            self.newValue = newValue
            self.previousValue = previousValue
        }

        func json() throws -> JSON {
            try WebSessionsChangeIdleLengthPolicyDetailsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try WebSessionsChangeIdleLengthPolicyDetailsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for WebSessionsChangeIdleLengthPolicyDetails: \(error)"
            }
        }
    }

    public class WebSessionsChangeIdleLengthPolicyDetailsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: WebSessionsChangeIdleLengthPolicyDetails) throws -> JSON {
            let output = [
                "new_value": try NullableSerializer(TeamLog.WebSessionsIdleLengthPolicySerializer()).serialize(value.newValue),
                "previous_value": try NullableSerializer(TeamLog.WebSessionsIdleLengthPolicySerializer()).serialize(value.previousValue),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> WebSessionsChangeIdleLengthPolicyDetails {
            switch json {
            case .dictionary(let dict):
                let newValue = try NullableSerializer(TeamLog.WebSessionsIdleLengthPolicySerializer()).deserialize(dict["new_value"] ?? .null)
                let previousValue = try NullableSerializer(TeamLog.WebSessionsIdleLengthPolicySerializer()).deserialize(dict["previous_value"] ?? .null)
                return WebSessionsChangeIdleLengthPolicyDetails(newValue: newValue, previousValue: previousValue)
            default:
                throw JSONSerializerError.deserializeError(type: WebSessionsChangeIdleLengthPolicyDetails.self, json: json)
            }
        }
    }

    /// The WebSessionsChangeIdleLengthPolicyType struct
    public class WebSessionsChangeIdleLengthPolicyType: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let description_: String
        public init(description_: String) {
            stringValidator()(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try WebSessionsChangeIdleLengthPolicyTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try WebSessionsChangeIdleLengthPolicyTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for WebSessionsChangeIdleLengthPolicyType: \(error)"
            }
        }
    }

    public class WebSessionsChangeIdleLengthPolicyTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: WebSessionsChangeIdleLengthPolicyType) throws -> JSON {
            let output = [
                "description": try Serialization._StringSerializer.serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> WebSessionsChangeIdleLengthPolicyType {
            switch json {
            case .dictionary(let dict):
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                return WebSessionsChangeIdleLengthPolicyType(description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: WebSessionsChangeIdleLengthPolicyType.self, json: json)
            }
        }
    }

    /// Web sessions fixed length policy.
    public enum WebSessionsFixedLengthPolicy: CustomStringConvertible, JSONRepresentable {
        /// Defined fixed session length.
        case defined(TeamLog.DurationLogInfo)
        /// Undefined fixed session length.
        case undefined
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try WebSessionsFixedLengthPolicySerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try WebSessionsFixedLengthPolicySerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for WebSessionsFixedLengthPolicy: \(error)"
            }
        }
    }

    public class WebSessionsFixedLengthPolicySerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: WebSessionsFixedLengthPolicy) throws -> JSON {
            switch value {
            case .defined(let arg):
                var d = try Serialization.getFields(TeamLog.DurationLogInfoSerializer().serialize(arg))
                d[".tag"] = .str("defined")
                return .dictionary(d)
            case .undefined:
                var d = [String: JSON]()
                d[".tag"] = .str("undefined")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> WebSessionsFixedLengthPolicy {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "defined":
                    let v = try TeamLog.DurationLogInfoSerializer().deserialize(json)
                    return WebSessionsFixedLengthPolicy.defined(v)
                case "undefined":
                    return WebSessionsFixedLengthPolicy.undefined
                case "other":
                    return WebSessionsFixedLengthPolicy.other
                default:
                    return WebSessionsFixedLengthPolicy.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: WebSessionsFixedLengthPolicy.self, json: json)
            }
        }
    }

    /// Web sessions idle length policy.
    public enum WebSessionsIdleLengthPolicy: CustomStringConvertible, JSONRepresentable {
        /// Defined idle session length.
        case defined(TeamLog.DurationLogInfo)
        /// Undefined idle session length.
        case undefined
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try WebSessionsIdleLengthPolicySerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try WebSessionsIdleLengthPolicySerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for WebSessionsIdleLengthPolicy: \(error)"
            }
        }
    }

    public class WebSessionsIdleLengthPolicySerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: WebSessionsIdleLengthPolicy) throws -> JSON {
            switch value {
            case .defined(let arg):
                var d = try Serialization.getFields(TeamLog.DurationLogInfoSerializer().serialize(arg))
                d[".tag"] = .str("defined")
                return .dictionary(d)
            case .undefined:
                var d = [String: JSON]()
                d[".tag"] = .str("undefined")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> WebSessionsIdleLengthPolicy {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "defined":
                    let v = try TeamLog.DurationLogInfoSerializer().deserialize(json)
                    return WebSessionsIdleLengthPolicy.defined(v)
                case "undefined":
                    return WebSessionsIdleLengthPolicy.undefined
                case "other":
                    return WebSessionsIdleLengthPolicy.other
                default:
                    return WebSessionsIdleLengthPolicy.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: WebSessionsIdleLengthPolicy.self, json: json)
            }
        }
    }

    /// Stone Route Objects

    static let getEvents = Route(
        name: "get_events",
        version: 1,
        namespace: "team_log",
        deprecated: false,
        argSerializer: TeamLog.GetTeamEventsArgSerializer(),
        responseSerializer: TeamLog.GetTeamEventsResultSerializer(),
        errorSerializer: TeamLog.GetTeamEventsErrorSerializer(),
        attributes: RouteAttributes(
            auth: [.team],
            host: .api,
            style: .rpc
        )
    )
    static let getEventsContinue = Route(
        name: "get_events/continue",
        version: 1,
        namespace: "team_log",
        deprecated: false,
        argSerializer: TeamLog.GetTeamEventsContinueArgSerializer(),
        responseSerializer: TeamLog.GetTeamEventsResultSerializer(),
        errorSerializer: TeamLog.GetTeamEventsContinueErrorSerializer(),
        attributes: RouteAttributes(
            auth: [.team],
            host: .api,
            style: .rpc
        )
    )
}
