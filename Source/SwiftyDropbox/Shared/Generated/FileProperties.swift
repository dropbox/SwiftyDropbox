///
/// Copyright (c) 2016 Dropbox, Inc. All rights reserved.
///
/// Auto-generated by Stone, do not modify.
///

import Foundation

/// Datatypes and serializers for the file_properties namespace
open class FileProperties {
    /// The AddPropertiesArg struct
    open class AddPropertiesArg: CustomStringConvertible {
        /// A unique identifier for the file or folder.
        open let path: String
        /// The property groups which are to be added to a Dropbox file.
        open let propertyGroups: Array<FileProperties.PropertyGroup>
        public init(path: String, propertyGroups: Array<FileProperties.PropertyGroup>) {
            stringValidator(pattern: "/(.|[\\r\\n])*|id:.*|(ns:[0-9]+(/.*)?)")(path)
            self.path = path
            self.propertyGroups = propertyGroups
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(AddPropertiesArgSerializer().serialize(self)))"
        }
    }
    open class AddPropertiesArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: AddPropertiesArg) -> JSON {
            let output = [ 
            "path": Serialization._StringSerializer.serialize(value.path),
            "property_groups": ArraySerializer(FileProperties.PropertyGroupSerializer()).serialize(value.propertyGroups),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> AddPropertiesArg {
            switch json {
                case .dictionary(let dict):
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .null)
                    let propertyGroups = ArraySerializer(FileProperties.PropertyGroupSerializer()).deserialize(dict["property_groups"] ?? .null)
                    return AddPropertiesArg(path: path, propertyGroups: propertyGroups)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The TemplateError union
    public enum TemplateError: CustomStringConvertible {
        /// Template does not exist for the given identifier.
        case templateNotFound(String)
        /// You do not have permission to modify this template.
        case restrictedContent
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(TemplateErrorSerializer().serialize(self)))"
        }
    }
    open class TemplateErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: TemplateError) -> JSON {
            switch value {
                case .templateNotFound(let arg):
                    var d = ["template_not_found": Serialization._StringSerializer.serialize(arg)]
                    d[".tag"] = .str("template_not_found")
                    return .dictionary(d)
                case .restrictedContent:
                    var d = [String: JSON]()
                    d[".tag"] = .str("restricted_content")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> TemplateError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "template_not_found":
                            let v = Serialization._StringSerializer.deserialize(d["template_not_found"] ?? .null)
                            return TemplateError.templateNotFound(v)
                        case "restricted_content":
                            return TemplateError.restrictedContent
                        case "other":
                            return TemplateError.other
                        default:
                            return TemplateError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The PropertiesError union
    public enum PropertiesError: CustomStringConvertible {
        /// Template does not exist for the given identifier.
        case templateNotFound(String)
        /// You do not have permission to modify this template.
        case restrictedContent
        /// An unspecified error.
        case other
        /// An unspecified error.
        case path(FileProperties.LookupError)
        /// This folder cannot be tagged. Tagging folders is not supported for team-owned templates.
        case unsupportedFolder

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PropertiesErrorSerializer().serialize(self)))"
        }
    }
    open class PropertiesErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PropertiesError) -> JSON {
            switch value {
                case .templateNotFound(let arg):
                    var d = ["template_not_found": Serialization._StringSerializer.serialize(arg)]
                    d[".tag"] = .str("template_not_found")
                    return .dictionary(d)
                case .restrictedContent:
                    var d = [String: JSON]()
                    d[".tag"] = .str("restricted_content")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
                case .path(let arg):
                    var d = ["path": FileProperties.LookupErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("path")
                    return .dictionary(d)
                case .unsupportedFolder:
                    var d = [String: JSON]()
                    d[".tag"] = .str("unsupported_folder")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> PropertiesError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "template_not_found":
                            let v = Serialization._StringSerializer.deserialize(d["template_not_found"] ?? .null)
                            return PropertiesError.templateNotFound(v)
                        case "restricted_content":
                            return PropertiesError.restrictedContent
                        case "other":
                            return PropertiesError.other
                        case "path":
                            let v = FileProperties.LookupErrorSerializer().deserialize(d["path"] ?? .null)
                            return PropertiesError.path(v)
                        case "unsupported_folder":
                            return PropertiesError.unsupportedFolder
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The InvalidPropertyGroupError union
    public enum InvalidPropertyGroupError: CustomStringConvertible {
        /// Template does not exist for the given identifier.
        case templateNotFound(String)
        /// You do not have permission to modify this template.
        case restrictedContent
        /// An unspecified error.
        case other
        /// An unspecified error.
        case path(FileProperties.LookupError)
        /// This folder cannot be tagged. Tagging folders is not supported for team-owned templates.
        case unsupportedFolder
        /// One or more of the supplied property field values is too large.
        case propertyFieldTooLarge
        /// One or more of the supplied property fields does not conform to the template specifications.
        case doesNotFitTemplate

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(InvalidPropertyGroupErrorSerializer().serialize(self)))"
        }
    }
    open class InvalidPropertyGroupErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: InvalidPropertyGroupError) -> JSON {
            switch value {
                case .templateNotFound(let arg):
                    var d = ["template_not_found": Serialization._StringSerializer.serialize(arg)]
                    d[".tag"] = .str("template_not_found")
                    return .dictionary(d)
                case .restrictedContent:
                    var d = [String: JSON]()
                    d[".tag"] = .str("restricted_content")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
                case .path(let arg):
                    var d = ["path": FileProperties.LookupErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("path")
                    return .dictionary(d)
                case .unsupportedFolder:
                    var d = [String: JSON]()
                    d[".tag"] = .str("unsupported_folder")
                    return .dictionary(d)
                case .propertyFieldTooLarge:
                    var d = [String: JSON]()
                    d[".tag"] = .str("property_field_too_large")
                    return .dictionary(d)
                case .doesNotFitTemplate:
                    var d = [String: JSON]()
                    d[".tag"] = .str("does_not_fit_template")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> InvalidPropertyGroupError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "template_not_found":
                            let v = Serialization._StringSerializer.deserialize(d["template_not_found"] ?? .null)
                            return InvalidPropertyGroupError.templateNotFound(v)
                        case "restricted_content":
                            return InvalidPropertyGroupError.restrictedContent
                        case "other":
                            return InvalidPropertyGroupError.other
                        case "path":
                            let v = FileProperties.LookupErrorSerializer().deserialize(d["path"] ?? .null)
                            return InvalidPropertyGroupError.path(v)
                        case "unsupported_folder":
                            return InvalidPropertyGroupError.unsupportedFolder
                        case "property_field_too_large":
                            return InvalidPropertyGroupError.propertyFieldTooLarge
                        case "does_not_fit_template":
                            return InvalidPropertyGroupError.doesNotFitTemplate
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The AddPropertiesError union
    public enum AddPropertiesError: CustomStringConvertible {
        /// Template does not exist for the given identifier.
        case templateNotFound(String)
        /// You do not have permission to modify this template.
        case restrictedContent
        /// An unspecified error.
        case other
        /// An unspecified error.
        case path(FileProperties.LookupError)
        /// This folder cannot be tagged. Tagging folders is not supported for team-owned templates.
        case unsupportedFolder
        /// One or more of the supplied property field values is too large.
        case propertyFieldTooLarge
        /// One or more of the supplied property fields does not conform to the template specifications.
        case doesNotFitTemplate
        /// A property group associated with this template and file already exists.
        case propertyGroupAlreadyExists

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(AddPropertiesErrorSerializer().serialize(self)))"
        }
    }
    open class AddPropertiesErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: AddPropertiesError) -> JSON {
            switch value {
                case .templateNotFound(let arg):
                    var d = ["template_not_found": Serialization._StringSerializer.serialize(arg)]
                    d[".tag"] = .str("template_not_found")
                    return .dictionary(d)
                case .restrictedContent:
                    var d = [String: JSON]()
                    d[".tag"] = .str("restricted_content")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
                case .path(let arg):
                    var d = ["path": FileProperties.LookupErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("path")
                    return .dictionary(d)
                case .unsupportedFolder:
                    var d = [String: JSON]()
                    d[".tag"] = .str("unsupported_folder")
                    return .dictionary(d)
                case .propertyFieldTooLarge:
                    var d = [String: JSON]()
                    d[".tag"] = .str("property_field_too_large")
                    return .dictionary(d)
                case .doesNotFitTemplate:
                    var d = [String: JSON]()
                    d[".tag"] = .str("does_not_fit_template")
                    return .dictionary(d)
                case .propertyGroupAlreadyExists:
                    var d = [String: JSON]()
                    d[".tag"] = .str("property_group_already_exists")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> AddPropertiesError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "template_not_found":
                            let v = Serialization._StringSerializer.deserialize(d["template_not_found"] ?? .null)
                            return AddPropertiesError.templateNotFound(v)
                        case "restricted_content":
                            return AddPropertiesError.restrictedContent
                        case "other":
                            return AddPropertiesError.other
                        case "path":
                            let v = FileProperties.LookupErrorSerializer().deserialize(d["path"] ?? .null)
                            return AddPropertiesError.path(v)
                        case "unsupported_folder":
                            return AddPropertiesError.unsupportedFolder
                        case "property_field_too_large":
                            return AddPropertiesError.propertyFieldTooLarge
                        case "does_not_fit_template":
                            return AddPropertiesError.doesNotFitTemplate
                        case "property_group_already_exists":
                            return AddPropertiesError.propertyGroupAlreadyExists
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Defines how a property group may be structured.
    open class PropertyGroupTemplate: CustomStringConvertible {
        /// Display name for the template. Template names can be up to 256 bytes.
        open let name: String
        /// Description for the template. Template descriptions can be up to 1024 bytes.
        open let description_: String
        /// Definitions of the property fields associated with this template. There can be up to 32 properties in a
        /// single template.
        open let fields: Array<FileProperties.PropertyFieldTemplate>
        public init(name: String, description_: String, fields: Array<FileProperties.PropertyFieldTemplate>) {
            stringValidator()(name)
            self.name = name
            stringValidator()(description_)
            self.description_ = description_
            self.fields = fields
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PropertyGroupTemplateSerializer().serialize(self)))"
        }
    }
    open class PropertyGroupTemplateSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PropertyGroupTemplate) -> JSON {
            let output = [ 
            "name": Serialization._StringSerializer.serialize(value.name),
            "description": Serialization._StringSerializer.serialize(value.description_),
            "fields": ArraySerializer(FileProperties.PropertyFieldTemplateSerializer()).serialize(value.fields),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> PropertyGroupTemplate {
            switch json {
                case .dictionary(let dict):
                    let name = Serialization._StringSerializer.deserialize(dict["name"] ?? .null)
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    let fields = ArraySerializer(FileProperties.PropertyFieldTemplateSerializer()).deserialize(dict["fields"] ?? .null)
                    return PropertyGroupTemplate(name: name, description_: description_, fields: fields)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The AddTemplateArg struct
    open class AddTemplateArg: FileProperties.PropertyGroupTemplate {
        open override var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(AddTemplateArgSerializer().serialize(self)))"
        }
    }
    open class AddTemplateArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: AddTemplateArg) -> JSON {
            let output = [ 
            "name": Serialization._StringSerializer.serialize(value.name),
            "description": Serialization._StringSerializer.serialize(value.description_),
            "fields": ArraySerializer(FileProperties.PropertyFieldTemplateSerializer()).serialize(value.fields),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> AddTemplateArg {
            switch json {
                case .dictionary(let dict):
                    let name = Serialization._StringSerializer.deserialize(dict["name"] ?? .null)
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    let fields = ArraySerializer(FileProperties.PropertyFieldTemplateSerializer()).deserialize(dict["fields"] ?? .null)
                    return AddTemplateArg(name: name, description_: description_, fields: fields)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The AddTemplateResult struct
    open class AddTemplateResult: CustomStringConvertible {
        /// An identifier for template added by  See templatesAddForUser or templatesAddForTeam.
        open let templateId: String
        public init(templateId: String) {
            stringValidator(minLength: 1, pattern: "(/|ptid:).*")(templateId)
            self.templateId = templateId
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(AddTemplateResultSerializer().serialize(self)))"
        }
    }
    open class AddTemplateResultSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: AddTemplateResult) -> JSON {
            let output = [ 
            "template_id": Serialization._StringSerializer.serialize(value.templateId),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> AddTemplateResult {
            switch json {
                case .dictionary(let dict):
                    let templateId = Serialization._StringSerializer.deserialize(dict["template_id"] ?? .null)
                    return AddTemplateResult(templateId: templateId)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The GetTemplateArg struct
    open class GetTemplateArg: CustomStringConvertible {
        /// An identifier for template added by route  See templatesAddForUser or templatesAddForTeam.
        open let templateId: String
        public init(templateId: String) {
            stringValidator(minLength: 1, pattern: "(/|ptid:).*")(templateId)
            self.templateId = templateId
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GetTemplateArgSerializer().serialize(self)))"
        }
    }
    open class GetTemplateArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GetTemplateArg) -> JSON {
            let output = [ 
            "template_id": Serialization._StringSerializer.serialize(value.templateId),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> GetTemplateArg {
            switch json {
                case .dictionary(let dict):
                    let templateId = Serialization._StringSerializer.deserialize(dict["template_id"] ?? .null)
                    return GetTemplateArg(templateId: templateId)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The GetTemplateResult struct
    open class GetTemplateResult: FileProperties.PropertyGroupTemplate {
        open override var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GetTemplateResultSerializer().serialize(self)))"
        }
    }
    open class GetTemplateResultSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GetTemplateResult) -> JSON {
            let output = [ 
            "name": Serialization._StringSerializer.serialize(value.name),
            "description": Serialization._StringSerializer.serialize(value.description_),
            "fields": ArraySerializer(FileProperties.PropertyFieldTemplateSerializer()).serialize(value.fields),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> GetTemplateResult {
            switch json {
                case .dictionary(let dict):
                    let name = Serialization._StringSerializer.deserialize(dict["name"] ?? .null)
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    let fields = ArraySerializer(FileProperties.PropertyFieldTemplateSerializer()).deserialize(dict["fields"] ?? .null)
                    return GetTemplateResult(name: name, description_: description_, fields: fields)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The ListTemplateResult struct
    open class ListTemplateResult: CustomStringConvertible {
        /// List of identifiers for templates added by  See templatesAddForUser or templatesAddForTeam.
        open let templateIds: Array<String>
        public init(templateIds: Array<String>) {
            arrayValidator(itemValidator: stringValidator(minLength: 1, pattern: "(/|ptid:).*"))(templateIds)
            self.templateIds = templateIds
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListTemplateResultSerializer().serialize(self)))"
        }
    }
    open class ListTemplateResultSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ListTemplateResult) -> JSON {
            let output = [ 
            "template_ids": ArraySerializer(Serialization._StringSerializer).serialize(value.templateIds),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ListTemplateResult {
            switch json {
                case .dictionary(let dict):
                    let templateIds = ArraySerializer(Serialization._StringSerializer).deserialize(dict["template_ids"] ?? .null)
                    return ListTemplateResult(templateIds: templateIds)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Logical operator to join search queries together.
    public enum LogicalOperator: CustomStringConvertible {
        /// Append a query with an "or" operator.
        case orOperator
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(LogicalOperatorSerializer().serialize(self)))"
        }
    }
    open class LogicalOperatorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: LogicalOperator) -> JSON {
            switch value {
                case .orOperator:
                    var d = [String: JSON]()
                    d[".tag"] = .str("or_operator")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> LogicalOperator {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "or_operator":
                            return LogicalOperator.orOperator
                        case "other":
                            return LogicalOperator.other
                        default:
                            return LogicalOperator.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The LookUpPropertiesError union
    public enum LookUpPropertiesError: CustomStringConvertible {
        /// No property group was found.
        case propertyGroupNotFound
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(LookUpPropertiesErrorSerializer().serialize(self)))"
        }
    }
    open class LookUpPropertiesErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: LookUpPropertiesError) -> JSON {
            switch value {
                case .propertyGroupNotFound:
                    var d = [String: JSON]()
                    d[".tag"] = .str("property_group_not_found")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> LookUpPropertiesError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "property_group_not_found":
                            return LookUpPropertiesError.propertyGroupNotFound
                        case "other":
                            return LookUpPropertiesError.other
                        default:
                            return LookUpPropertiesError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The LookupError union
    public enum LookupError: CustomStringConvertible {
        /// An unspecified error.
        case malformedPath(String)
        /// There is nothing at the given path.
        case notFound
        /// We were expecting a file, but the given path refers to something that isn't a file.
        case notFile
        /// We were expecting a folder, but the given path refers to something that isn't a folder.
        case notFolder
        /// The file cannot be transferred because the content is restricted.  For example, sometimes there are legal
        /// restrictions due to copyright claims.
        case restrictedContent
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(LookupErrorSerializer().serialize(self)))"
        }
    }
    open class LookupErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: LookupError) -> JSON {
            switch value {
                case .malformedPath(let arg):
                    var d = ["malformed_path": Serialization._StringSerializer.serialize(arg)]
                    d[".tag"] = .str("malformed_path")
                    return .dictionary(d)
                case .notFound:
                    var d = [String: JSON]()
                    d[".tag"] = .str("not_found")
                    return .dictionary(d)
                case .notFile:
                    var d = [String: JSON]()
                    d[".tag"] = .str("not_file")
                    return .dictionary(d)
                case .notFolder:
                    var d = [String: JSON]()
                    d[".tag"] = .str("not_folder")
                    return .dictionary(d)
                case .restrictedContent:
                    var d = [String: JSON]()
                    d[".tag"] = .str("restricted_content")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> LookupError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "malformed_path":
                            let v = Serialization._StringSerializer.deserialize(d["malformed_path"] ?? .null)
                            return LookupError.malformedPath(v)
                        case "not_found":
                            return LookupError.notFound
                        case "not_file":
                            return LookupError.notFile
                        case "not_folder":
                            return LookupError.notFolder
                        case "restricted_content":
                            return LookupError.restrictedContent
                        case "other":
                            return LookupError.other
                        default:
                            return LookupError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The ModifyTemplateError union
    public enum ModifyTemplateError: CustomStringConvertible {
        /// Template does not exist for the given identifier.
        case templateNotFound(String)
        /// You do not have permission to modify this template.
        case restrictedContent
        /// An unspecified error.
        case other
        /// A property field key with that name already exists in the template.
        case conflictingPropertyNames
        /// There are too many properties in the changed template. The maximum number of properties per template is 32.
        case tooManyProperties
        /// There are too many templates for the team.
        case tooManyTemplates
        /// The template name, description or one or more of the property field keys is too large.
        case templateAttributeTooLarge

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ModifyTemplateErrorSerializer().serialize(self)))"
        }
    }
    open class ModifyTemplateErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ModifyTemplateError) -> JSON {
            switch value {
                case .templateNotFound(let arg):
                    var d = ["template_not_found": Serialization._StringSerializer.serialize(arg)]
                    d[".tag"] = .str("template_not_found")
                    return .dictionary(d)
                case .restrictedContent:
                    var d = [String: JSON]()
                    d[".tag"] = .str("restricted_content")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
                case .conflictingPropertyNames:
                    var d = [String: JSON]()
                    d[".tag"] = .str("conflicting_property_names")
                    return .dictionary(d)
                case .tooManyProperties:
                    var d = [String: JSON]()
                    d[".tag"] = .str("too_many_properties")
                    return .dictionary(d)
                case .tooManyTemplates:
                    var d = [String: JSON]()
                    d[".tag"] = .str("too_many_templates")
                    return .dictionary(d)
                case .templateAttributeTooLarge:
                    var d = [String: JSON]()
                    d[".tag"] = .str("template_attribute_too_large")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> ModifyTemplateError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "template_not_found":
                            let v = Serialization._StringSerializer.deserialize(d["template_not_found"] ?? .null)
                            return ModifyTemplateError.templateNotFound(v)
                        case "restricted_content":
                            return ModifyTemplateError.restrictedContent
                        case "other":
                            return ModifyTemplateError.other
                        case "conflicting_property_names":
                            return ModifyTemplateError.conflictingPropertyNames
                        case "too_many_properties":
                            return ModifyTemplateError.tooManyProperties
                        case "too_many_templates":
                            return ModifyTemplateError.tooManyTemplates
                        case "template_attribute_too_large":
                            return ModifyTemplateError.templateAttributeTooLarge
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The OverwritePropertyGroupArg struct
    open class OverwritePropertyGroupArg: CustomStringConvertible {
        /// A unique identifier for the file or folder.
        open let path: String
        /// The property groups "snapshot" updates to force apply.
        open let propertyGroups: Array<FileProperties.PropertyGroup>
        public init(path: String, propertyGroups: Array<FileProperties.PropertyGroup>) {
            stringValidator(pattern: "/(.|[\\r\\n])*|id:.*|(ns:[0-9]+(/.*)?)")(path)
            self.path = path
            self.propertyGroups = propertyGroups
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(OverwritePropertyGroupArgSerializer().serialize(self)))"
        }
    }
    open class OverwritePropertyGroupArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: OverwritePropertyGroupArg) -> JSON {
            let output = [ 
            "path": Serialization._StringSerializer.serialize(value.path),
            "property_groups": ArraySerializer(FileProperties.PropertyGroupSerializer()).serialize(value.propertyGroups),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> OverwritePropertyGroupArg {
            switch json {
                case .dictionary(let dict):
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .null)
                    let propertyGroups = ArraySerializer(FileProperties.PropertyGroupSerializer()).deserialize(dict["property_groups"] ?? .null)
                    return OverwritePropertyGroupArg(path: path, propertyGroups: propertyGroups)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The PropertiesSearchArg struct
    open class PropertiesSearchArg: CustomStringConvertible {
        /// Queries to search.
        open let queries: Array<FileProperties.PropertiesSearchQuery>
        /// Filter results to contain only properties associated with these template IDs.
        open let templateFilter: FileProperties.TemplateFilter
        public init(queries: Array<FileProperties.PropertiesSearchQuery>, templateFilter: FileProperties.TemplateFilter = .filterNone) {
            self.queries = queries
            self.templateFilter = templateFilter
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PropertiesSearchArgSerializer().serialize(self)))"
        }
    }
    open class PropertiesSearchArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PropertiesSearchArg) -> JSON {
            let output = [ 
            "queries": ArraySerializer(FileProperties.PropertiesSearchQuerySerializer()).serialize(value.queries),
            "template_filter": FileProperties.TemplateFilterSerializer().serialize(value.templateFilter),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> PropertiesSearchArg {
            switch json {
                case .dictionary(let dict):
                    let queries = ArraySerializer(FileProperties.PropertiesSearchQuerySerializer()).deserialize(dict["queries"] ?? .null)
                    let templateFilter = FileProperties.TemplateFilterSerializer().deserialize(dict["template_filter"] ?? FileProperties.TemplateFilterSerializer().serialize(.filterNone))
                    return PropertiesSearchArg(queries: queries, templateFilter: templateFilter)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The PropertiesSearchError union
    public enum PropertiesSearchError: CustomStringConvertible {
        /// An unspecified error.
        case propertyGroupLookup(FileProperties.LookUpPropertiesError)
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PropertiesSearchErrorSerializer().serialize(self)))"
        }
    }
    open class PropertiesSearchErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PropertiesSearchError) -> JSON {
            switch value {
                case .propertyGroupLookup(let arg):
                    var d = ["property_group_lookup": FileProperties.LookUpPropertiesErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("property_group_lookup")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> PropertiesSearchError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "property_group_lookup":
                            let v = FileProperties.LookUpPropertiesErrorSerializer().deserialize(d["property_group_lookup"] ?? .null)
                            return PropertiesSearchError.propertyGroupLookup(v)
                        case "other":
                            return PropertiesSearchError.other
                        default:
                            return PropertiesSearchError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The PropertiesSearchMatch struct
    open class PropertiesSearchMatch: CustomStringConvertible {
        /// The ID for the matched file or folder.
        open let id: String
        /// The path for the matched file or folder.
        open let path: String
        /// List of custom property groups associated with the file.
        open let propertyGroups: Array<FileProperties.PropertyGroup>
        public init(id: String, path: String, propertyGroups: Array<FileProperties.PropertyGroup>) {
            stringValidator(minLength: 1)(id)
            self.id = id
            stringValidator()(path)
            self.path = path
            self.propertyGroups = propertyGroups
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PropertiesSearchMatchSerializer().serialize(self)))"
        }
    }
    open class PropertiesSearchMatchSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PropertiesSearchMatch) -> JSON {
            let output = [ 
            "id": Serialization._StringSerializer.serialize(value.id),
            "path": Serialization._StringSerializer.serialize(value.path),
            "property_groups": ArraySerializer(FileProperties.PropertyGroupSerializer()).serialize(value.propertyGroups),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> PropertiesSearchMatch {
            switch json {
                case .dictionary(let dict):
                    let id = Serialization._StringSerializer.deserialize(dict["id"] ?? .null)
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .null)
                    let propertyGroups = ArraySerializer(FileProperties.PropertyGroupSerializer()).deserialize(dict["property_groups"] ?? .null)
                    return PropertiesSearchMatch(id: id, path: path, propertyGroups: propertyGroups)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The PropertiesSearchMode union
    public enum PropertiesSearchMode: CustomStringConvertible {
        /// Search for a value associated with this field name.
        case fieldName(String)
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PropertiesSearchModeSerializer().serialize(self)))"
        }
    }
    open class PropertiesSearchModeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PropertiesSearchMode) -> JSON {
            switch value {
                case .fieldName(let arg):
                    var d = ["field_name": Serialization._StringSerializer.serialize(arg)]
                    d[".tag"] = .str("field_name")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> PropertiesSearchMode {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "field_name":
                            let v = Serialization._StringSerializer.deserialize(d["field_name"] ?? .null)
                            return PropertiesSearchMode.fieldName(v)
                        case "other":
                            return PropertiesSearchMode.other
                        default:
                            return PropertiesSearchMode.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The PropertiesSearchQuery struct
    open class PropertiesSearchQuery: CustomStringConvertible {
        /// The property field value for which to search across templates.
        open let query: String
        /// The mode with which to perform the search.
        open let mode: FileProperties.PropertiesSearchMode
        /// The logical operator with which to append the query.
        open let logicalOperator: FileProperties.LogicalOperator
        public init(query: String, mode: FileProperties.PropertiesSearchMode, logicalOperator: FileProperties.LogicalOperator = .orOperator) {
            stringValidator()(query)
            self.query = query
            self.mode = mode
            self.logicalOperator = logicalOperator
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PropertiesSearchQuerySerializer().serialize(self)))"
        }
    }
    open class PropertiesSearchQuerySerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PropertiesSearchQuery) -> JSON {
            let output = [ 
            "query": Serialization._StringSerializer.serialize(value.query),
            "mode": FileProperties.PropertiesSearchModeSerializer().serialize(value.mode),
            "logical_operator": FileProperties.LogicalOperatorSerializer().serialize(value.logicalOperator),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> PropertiesSearchQuery {
            switch json {
                case .dictionary(let dict):
                    let query = Serialization._StringSerializer.deserialize(dict["query"] ?? .null)
                    let mode = FileProperties.PropertiesSearchModeSerializer().deserialize(dict["mode"] ?? .null)
                    let logicalOperator = FileProperties.LogicalOperatorSerializer().deserialize(dict["logical_operator"] ?? FileProperties.LogicalOperatorSerializer().serialize(.orOperator))
                    return PropertiesSearchQuery(query: query, mode: mode, logicalOperator: logicalOperator)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The PropertiesSearchResult struct
    open class PropertiesSearchResult: CustomStringConvertible {
        /// A list (possibly empty) of matches for the query.
        open let matches: Array<FileProperties.PropertiesSearchMatch>
        public init(matches: Array<FileProperties.PropertiesSearchMatch>) {
            self.matches = matches
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PropertiesSearchResultSerializer().serialize(self)))"
        }
    }
    open class PropertiesSearchResultSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PropertiesSearchResult) -> JSON {
            let output = [ 
            "matches": ArraySerializer(FileProperties.PropertiesSearchMatchSerializer()).serialize(value.matches),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> PropertiesSearchResult {
            switch json {
                case .dictionary(let dict):
                    let matches = ArraySerializer(FileProperties.PropertiesSearchMatchSerializer()).deserialize(dict["matches"] ?? .null)
                    return PropertiesSearchResult(matches: matches)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Raw key/value data to be associated with a Dropbox file. Property fields are added to Dropbox files as a
    /// PropertyGroup.
    open class PropertyField: CustomStringConvertible {
        /// Key of the property field associated with a file and template. Keys can be up to 256 bytes.
        open let name: String
        /// Value of the property field associated with a file and template. Values can be up to 1024 bytes.
        open let value: String
        public init(name: String, value: String) {
            stringValidator()(name)
            self.name = name
            stringValidator()(value)
            self.value = value
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PropertyFieldSerializer().serialize(self)))"
        }
    }
    open class PropertyFieldSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PropertyField) -> JSON {
            let output = [ 
            "name": Serialization._StringSerializer.serialize(value.name),
            "value": Serialization._StringSerializer.serialize(value.value),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> PropertyField {
            switch json {
                case .dictionary(let dict):
                    let name = Serialization._StringSerializer.deserialize(dict["name"] ?? .null)
                    let value = Serialization._StringSerializer.deserialize(dict["value"] ?? .null)
                    return PropertyField(name: name, value: value)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Defines how a single property field may be structured. Used exclusively by PropertyGroupTemplate.
    open class PropertyFieldTemplate: CustomStringConvertible {
        /// Key of the property field being described. Property field keys can be up to 256 bytes.
        open let name: String
        /// Description of the property field. Property field descriptions can be up to 1024 bytes.
        open let description_: String
        /// Data type of the value of this property field. This type will be enforced upon property creation and
        /// modifications.
        open let type: FileProperties.PropertyType
        public init(name: String, description_: String, type: FileProperties.PropertyType) {
            stringValidator()(name)
            self.name = name
            stringValidator()(description_)
            self.description_ = description_
            self.type = type
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PropertyFieldTemplateSerializer().serialize(self)))"
        }
    }
    open class PropertyFieldTemplateSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PropertyFieldTemplate) -> JSON {
            let output = [ 
            "name": Serialization._StringSerializer.serialize(value.name),
            "description": Serialization._StringSerializer.serialize(value.description_),
            "type": FileProperties.PropertyTypeSerializer().serialize(value.type),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> PropertyFieldTemplate {
            switch json {
                case .dictionary(let dict):
                    let name = Serialization._StringSerializer.deserialize(dict["name"] ?? .null)
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    let type = FileProperties.PropertyTypeSerializer().deserialize(dict["type"] ?? .null)
                    return PropertyFieldTemplate(name: name, description_: description_, type: type)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// A subset of the property fields described by the corresponding PropertyGroupTemplate. Properties are always
    /// added to a Dropbox file as a PropertyGroup. The possible key names and value types in this group are defined by
    /// the corresponding PropertyGroupTemplate.
    open class PropertyGroup: CustomStringConvertible {
        /// A unique identifier for the associated template.
        open let templateId: String
        /// The actual properties associated with the template. There can be up to 32 property types per template.
        open let fields: Array<FileProperties.PropertyField>
        public init(templateId: String, fields: Array<FileProperties.PropertyField>) {
            stringValidator(minLength: 1, pattern: "(/|ptid:).*")(templateId)
            self.templateId = templateId
            self.fields = fields
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PropertyGroupSerializer().serialize(self)))"
        }
    }
    open class PropertyGroupSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PropertyGroup) -> JSON {
            let output = [ 
            "template_id": Serialization._StringSerializer.serialize(value.templateId),
            "fields": ArraySerializer(FileProperties.PropertyFieldSerializer()).serialize(value.fields),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> PropertyGroup {
            switch json {
                case .dictionary(let dict):
                    let templateId = Serialization._StringSerializer.deserialize(dict["template_id"] ?? .null)
                    let fields = ArraySerializer(FileProperties.PropertyFieldSerializer()).deserialize(dict["fields"] ?? .null)
                    return PropertyGroup(templateId: templateId, fields: fields)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The PropertyGroupUpdate struct
    open class PropertyGroupUpdate: CustomStringConvertible {
        /// A unique identifier for a property template.
        open let templateId: String
        /// Property fields to update. If the property field already exists, it is updated. If the property field
        /// doesn't exist, the property group is added.
        open let addOrUpdateFields: Array<FileProperties.PropertyField>?
        /// Property fields to remove (by name), provided they exist.
        open let removeFields: Array<String>?
        public init(templateId: String, addOrUpdateFields: Array<FileProperties.PropertyField>? = nil, removeFields: Array<String>? = nil) {
            stringValidator(minLength: 1, pattern: "(/|ptid:).*")(templateId)
            self.templateId = templateId
            self.addOrUpdateFields = addOrUpdateFields
            nullableValidator(arrayValidator(itemValidator: stringValidator()))(removeFields)
            self.removeFields = removeFields
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PropertyGroupUpdateSerializer().serialize(self)))"
        }
    }
    open class PropertyGroupUpdateSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PropertyGroupUpdate) -> JSON {
            let output = [ 
            "template_id": Serialization._StringSerializer.serialize(value.templateId),
            "add_or_update_fields": NullableSerializer(ArraySerializer(FileProperties.PropertyFieldSerializer())).serialize(value.addOrUpdateFields),
            "remove_fields": NullableSerializer(ArraySerializer(Serialization._StringSerializer)).serialize(value.removeFields),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> PropertyGroupUpdate {
            switch json {
                case .dictionary(let dict):
                    let templateId = Serialization._StringSerializer.deserialize(dict["template_id"] ?? .null)
                    let addOrUpdateFields = NullableSerializer(ArraySerializer(FileProperties.PropertyFieldSerializer())).deserialize(dict["add_or_update_fields"] ?? .null)
                    let removeFields = NullableSerializer(ArraySerializer(Serialization._StringSerializer)).deserialize(dict["remove_fields"] ?? .null)
                    return PropertyGroupUpdate(templateId: templateId, addOrUpdateFields: addOrUpdateFields, removeFields: removeFields)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Data type of the given property field added.
    public enum PropertyType: CustomStringConvertible {
        /// The associated property field will be of type string. Unicode is supported.
        case string_
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PropertyTypeSerializer().serialize(self)))"
        }
    }
    open class PropertyTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PropertyType) -> JSON {
            switch value {
                case .string_:
                    var d = [String: JSON]()
                    d[".tag"] = .str("string")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> PropertyType {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "string":
                            return PropertyType.string_
                        case "other":
                            return PropertyType.other
                        default:
                            return PropertyType.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The RemovePropertiesArg struct
    open class RemovePropertiesArg: CustomStringConvertible {
        /// A unique identifier for the file or folder.
        open let path: String
        /// A list of identifiers for a template created by templatesAddForUser or templatesAddForTeam.
        open let propertyTemplateIds: Array<String>
        public init(path: String, propertyTemplateIds: Array<String>) {
            stringValidator(pattern: "/(.|[\\r\\n])*|id:.*|(ns:[0-9]+(/.*)?)")(path)
            self.path = path
            arrayValidator(itemValidator: stringValidator(minLength: 1, pattern: "(/|ptid:).*"))(propertyTemplateIds)
            self.propertyTemplateIds = propertyTemplateIds
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(RemovePropertiesArgSerializer().serialize(self)))"
        }
    }
    open class RemovePropertiesArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: RemovePropertiesArg) -> JSON {
            let output = [ 
            "path": Serialization._StringSerializer.serialize(value.path),
            "property_template_ids": ArraySerializer(Serialization._StringSerializer).serialize(value.propertyTemplateIds),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> RemovePropertiesArg {
            switch json {
                case .dictionary(let dict):
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .null)
                    let propertyTemplateIds = ArraySerializer(Serialization._StringSerializer).deserialize(dict["property_template_ids"] ?? .null)
                    return RemovePropertiesArg(path: path, propertyTemplateIds: propertyTemplateIds)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The RemovePropertiesError union
    public enum RemovePropertiesError: CustomStringConvertible {
        /// Template does not exist for the given identifier.
        case templateNotFound(String)
        /// You do not have permission to modify this template.
        case restrictedContent
        /// An unspecified error.
        case other
        /// An unspecified error.
        case path(FileProperties.LookupError)
        /// This folder cannot be tagged. Tagging folders is not supported for team-owned templates.
        case unsupportedFolder
        /// An unspecified error.
        case propertyGroupLookup(FileProperties.LookUpPropertiesError)

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(RemovePropertiesErrorSerializer().serialize(self)))"
        }
    }
    open class RemovePropertiesErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: RemovePropertiesError) -> JSON {
            switch value {
                case .templateNotFound(let arg):
                    var d = ["template_not_found": Serialization._StringSerializer.serialize(arg)]
                    d[".tag"] = .str("template_not_found")
                    return .dictionary(d)
                case .restrictedContent:
                    var d = [String: JSON]()
                    d[".tag"] = .str("restricted_content")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
                case .path(let arg):
                    var d = ["path": FileProperties.LookupErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("path")
                    return .dictionary(d)
                case .unsupportedFolder:
                    var d = [String: JSON]()
                    d[".tag"] = .str("unsupported_folder")
                    return .dictionary(d)
                case .propertyGroupLookup(let arg):
                    var d = ["property_group_lookup": FileProperties.LookUpPropertiesErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("property_group_lookup")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> RemovePropertiesError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "template_not_found":
                            let v = Serialization._StringSerializer.deserialize(d["template_not_found"] ?? .null)
                            return RemovePropertiesError.templateNotFound(v)
                        case "restricted_content":
                            return RemovePropertiesError.restrictedContent
                        case "other":
                            return RemovePropertiesError.other
                        case "path":
                            let v = FileProperties.LookupErrorSerializer().deserialize(d["path"] ?? .null)
                            return RemovePropertiesError.path(v)
                        case "unsupported_folder":
                            return RemovePropertiesError.unsupportedFolder
                        case "property_group_lookup":
                            let v = FileProperties.LookUpPropertiesErrorSerializer().deserialize(d["property_group_lookup"] ?? .null)
                            return RemovePropertiesError.propertyGroupLookup(v)
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The TemplateFilter union
    public enum TemplateFilter: CustomStringConvertible {
        /// No templates will be filtered from the result (all templates will be returned).
        case filterNone
        /// Only templates with an ID in the supplied list will be returned (a subset of templates will be returned).
        case filterSome(Array<String>)
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(TemplateFilterSerializer().serialize(self)))"
        }
    }
    open class TemplateFilterSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: TemplateFilter) -> JSON {
            switch value {
                case .filterNone:
                    var d = [String: JSON]()
                    d[".tag"] = .str("filter_none")
                    return .dictionary(d)
                case .filterSome(let arg):
                    var d = ["filter_some": ArraySerializer(Serialization._StringSerializer).serialize(arg)]
                    d[".tag"] = .str("filter_some")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> TemplateFilter {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "filter_none":
                            return TemplateFilter.filterNone
                        case "filter_some":
                            let v = ArraySerializer(Serialization._StringSerializer).deserialize(d["filter_some"] ?? .null)
                            return TemplateFilter.filterSome(v)
                        case "other":
                            return TemplateFilter.other
                        default:
                            return TemplateFilter.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The TemplateOwnerType union
    public enum TemplateOwnerType: CustomStringConvertible {
        /// Template will be associated with a user.
        case user
        /// Template will be associated with a team.
        case team
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(TemplateOwnerTypeSerializer().serialize(self)))"
        }
    }
    open class TemplateOwnerTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: TemplateOwnerType) -> JSON {
            switch value {
                case .user:
                    var d = [String: JSON]()
                    d[".tag"] = .str("user")
                    return .dictionary(d)
                case .team:
                    var d = [String: JSON]()
                    d[".tag"] = .str("team")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> TemplateOwnerType {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "user":
                            return TemplateOwnerType.user
                        case "team":
                            return TemplateOwnerType.team
                        case "other":
                            return TemplateOwnerType.other
                        default:
                            return TemplateOwnerType.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The UpdatePropertiesArg struct
    open class UpdatePropertiesArg: CustomStringConvertible {
        /// A unique identifier for the file or folder.
        open let path: String
        /// The property groups "delta" updates to apply.
        open let updatePropertyGroups: Array<FileProperties.PropertyGroupUpdate>
        public init(path: String, updatePropertyGroups: Array<FileProperties.PropertyGroupUpdate>) {
            stringValidator(pattern: "/(.|[\\r\\n])*|id:.*|(ns:[0-9]+(/.*)?)")(path)
            self.path = path
            self.updatePropertyGroups = updatePropertyGroups
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(UpdatePropertiesArgSerializer().serialize(self)))"
        }
    }
    open class UpdatePropertiesArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: UpdatePropertiesArg) -> JSON {
            let output = [ 
            "path": Serialization._StringSerializer.serialize(value.path),
            "update_property_groups": ArraySerializer(FileProperties.PropertyGroupUpdateSerializer()).serialize(value.updatePropertyGroups),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> UpdatePropertiesArg {
            switch json {
                case .dictionary(let dict):
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .null)
                    let updatePropertyGroups = ArraySerializer(FileProperties.PropertyGroupUpdateSerializer()).deserialize(dict["update_property_groups"] ?? .null)
                    return UpdatePropertiesArg(path: path, updatePropertyGroups: updatePropertyGroups)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The UpdatePropertiesError union
    public enum UpdatePropertiesError: CustomStringConvertible {
        /// Template does not exist for the given identifier.
        case templateNotFound(String)
        /// You do not have permission to modify this template.
        case restrictedContent
        /// An unspecified error.
        case other
        /// An unspecified error.
        case path(FileProperties.LookupError)
        /// This folder cannot be tagged. Tagging folders is not supported for team-owned templates.
        case unsupportedFolder
        /// One or more of the supplied property field values is too large.
        case propertyFieldTooLarge
        /// One or more of the supplied property fields does not conform to the template specifications.
        case doesNotFitTemplate
        /// An unspecified error.
        case propertyGroupLookup(FileProperties.LookUpPropertiesError)

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(UpdatePropertiesErrorSerializer().serialize(self)))"
        }
    }
    open class UpdatePropertiesErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: UpdatePropertiesError) -> JSON {
            switch value {
                case .templateNotFound(let arg):
                    var d = ["template_not_found": Serialization._StringSerializer.serialize(arg)]
                    d[".tag"] = .str("template_not_found")
                    return .dictionary(d)
                case .restrictedContent:
                    var d = [String: JSON]()
                    d[".tag"] = .str("restricted_content")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
                case .path(let arg):
                    var d = ["path": FileProperties.LookupErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("path")
                    return .dictionary(d)
                case .unsupportedFolder:
                    var d = [String: JSON]()
                    d[".tag"] = .str("unsupported_folder")
                    return .dictionary(d)
                case .propertyFieldTooLarge:
                    var d = [String: JSON]()
                    d[".tag"] = .str("property_field_too_large")
                    return .dictionary(d)
                case .doesNotFitTemplate:
                    var d = [String: JSON]()
                    d[".tag"] = .str("does_not_fit_template")
                    return .dictionary(d)
                case .propertyGroupLookup(let arg):
                    var d = ["property_group_lookup": FileProperties.LookUpPropertiesErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("property_group_lookup")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> UpdatePropertiesError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "template_not_found":
                            let v = Serialization._StringSerializer.deserialize(d["template_not_found"] ?? .null)
                            return UpdatePropertiesError.templateNotFound(v)
                        case "restricted_content":
                            return UpdatePropertiesError.restrictedContent
                        case "other":
                            return UpdatePropertiesError.other
                        case "path":
                            let v = FileProperties.LookupErrorSerializer().deserialize(d["path"] ?? .null)
                            return UpdatePropertiesError.path(v)
                        case "unsupported_folder":
                            return UpdatePropertiesError.unsupportedFolder
                        case "property_field_too_large":
                            return UpdatePropertiesError.propertyFieldTooLarge
                        case "does_not_fit_template":
                            return UpdatePropertiesError.doesNotFitTemplate
                        case "property_group_lookup":
                            let v = FileProperties.LookUpPropertiesErrorSerializer().deserialize(d["property_group_lookup"] ?? .null)
                            return UpdatePropertiesError.propertyGroupLookup(v)
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The UpdateTemplateArg struct
    open class UpdateTemplateArg: CustomStringConvertible {
        /// An identifier for template added by  See templatesAddForUser or templatesAddForTeam.
        open let templateId: String
        /// A display name for the template. template names can be up to 256 bytes.
        open let name: String?
        /// Description for the new template. Template descriptions can be up to 1024 bytes.
        open let description_: String?
        /// Property field templates to be added to the group template. There can be up to 32 properties in a single
        /// template.
        open let addFields: Array<FileProperties.PropertyFieldTemplate>?
        public init(templateId: String, name: String? = nil, description_: String? = nil, addFields: Array<FileProperties.PropertyFieldTemplate>? = nil) {
            stringValidator(minLength: 1, pattern: "(/|ptid:).*")(templateId)
            self.templateId = templateId
            nullableValidator(stringValidator())(name)
            self.name = name
            nullableValidator(stringValidator())(description_)
            self.description_ = description_
            self.addFields = addFields
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(UpdateTemplateArgSerializer().serialize(self)))"
        }
    }
    open class UpdateTemplateArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: UpdateTemplateArg) -> JSON {
            let output = [ 
            "template_id": Serialization._StringSerializer.serialize(value.templateId),
            "name": NullableSerializer(Serialization._StringSerializer).serialize(value.name),
            "description": NullableSerializer(Serialization._StringSerializer).serialize(value.description_),
            "add_fields": NullableSerializer(ArraySerializer(FileProperties.PropertyFieldTemplateSerializer())).serialize(value.addFields),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> UpdateTemplateArg {
            switch json {
                case .dictionary(let dict):
                    let templateId = Serialization._StringSerializer.deserialize(dict["template_id"] ?? .null)
                    let name = NullableSerializer(Serialization._StringSerializer).deserialize(dict["name"] ?? .null)
                    let description_ = NullableSerializer(Serialization._StringSerializer).deserialize(dict["description"] ?? .null)
                    let addFields = NullableSerializer(ArraySerializer(FileProperties.PropertyFieldTemplateSerializer())).deserialize(dict["add_fields"] ?? .null)
                    return UpdateTemplateArg(templateId: templateId, name: name, description_: description_, addFields: addFields)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The UpdateTemplateResult struct
    open class UpdateTemplateResult: CustomStringConvertible {
        /// An identifier for template added by route  See templatesAddForUser or templatesAddForTeam.
        open let templateId: String
        public init(templateId: String) {
            stringValidator(minLength: 1, pattern: "(/|ptid:).*")(templateId)
            self.templateId = templateId
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(UpdateTemplateResultSerializer().serialize(self)))"
        }
    }
    open class UpdateTemplateResultSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: UpdateTemplateResult) -> JSON {
            let output = [ 
            "template_id": Serialization._StringSerializer.serialize(value.templateId),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> UpdateTemplateResult {
            switch json {
                case .dictionary(let dict):
                    let templateId = Serialization._StringSerializer.deserialize(dict["template_id"] ?? .null)
                    return UpdateTemplateResult(templateId: templateId)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }


    /// Stone Route Objects

    static let propertiesAdd = Route(
        name: "properties/add",
        namespace: "file_properties",
        deprecated: false,
        argSerializer: FileProperties.AddPropertiesArgSerializer(),
        responseSerializer: Serialization._VoidSerializer,
        errorSerializer: FileProperties.AddPropertiesErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let propertiesOverwrite = Route(
        name: "properties/overwrite",
        namespace: "file_properties",
        deprecated: false,
        argSerializer: FileProperties.OverwritePropertyGroupArgSerializer(),
        responseSerializer: Serialization._VoidSerializer,
        errorSerializer: FileProperties.InvalidPropertyGroupErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let propertiesRemove = Route(
        name: "properties/remove",
        namespace: "file_properties",
        deprecated: false,
        argSerializer: FileProperties.RemovePropertiesArgSerializer(),
        responseSerializer: Serialization._VoidSerializer,
        errorSerializer: FileProperties.RemovePropertiesErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let propertiesSearch = Route(
        name: "properties/search",
        namespace: "file_properties",
        deprecated: false,
        argSerializer: FileProperties.PropertiesSearchArgSerializer(),
        responseSerializer: FileProperties.PropertiesSearchResultSerializer(),
        errorSerializer: FileProperties.PropertiesSearchErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let propertiesUpdate = Route(
        name: "properties/update",
        namespace: "file_properties",
        deprecated: false,
        argSerializer: FileProperties.UpdatePropertiesArgSerializer(),
        responseSerializer: Serialization._VoidSerializer,
        errorSerializer: FileProperties.UpdatePropertiesErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let templatesAddForTeam = Route(
        name: "templates/add_for_team",
        namespace: "file_properties",
        deprecated: false,
        argSerializer: FileProperties.AddTemplateArgSerializer(),
        responseSerializer: FileProperties.AddTemplateResultSerializer(),
        errorSerializer: FileProperties.ModifyTemplateErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let templatesAddForUser = Route(
        name: "templates/add_for_user",
        namespace: "file_properties",
        deprecated: false,
        argSerializer: FileProperties.AddTemplateArgSerializer(),
        responseSerializer: FileProperties.AddTemplateResultSerializer(),
        errorSerializer: FileProperties.ModifyTemplateErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let templatesGetForTeam = Route(
        name: "templates/get_for_team",
        namespace: "file_properties",
        deprecated: false,
        argSerializer: FileProperties.GetTemplateArgSerializer(),
        responseSerializer: FileProperties.GetTemplateResultSerializer(),
        errorSerializer: FileProperties.TemplateErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let templatesGetForUser = Route(
        name: "templates/get_for_user",
        namespace: "file_properties",
        deprecated: false,
        argSerializer: FileProperties.GetTemplateArgSerializer(),
        responseSerializer: FileProperties.GetTemplateResultSerializer(),
        errorSerializer: FileProperties.TemplateErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let templatesListForTeam = Route(
        name: "templates/list_for_team",
        namespace: "file_properties",
        deprecated: false,
        argSerializer: Serialization._VoidSerializer,
        responseSerializer: FileProperties.ListTemplateResultSerializer(),
        errorSerializer: FileProperties.TemplateErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let templatesListForUser = Route(
        name: "templates/list_for_user",
        namespace: "file_properties",
        deprecated: false,
        argSerializer: Serialization._VoidSerializer,
        responseSerializer: FileProperties.ListTemplateResultSerializer(),
        errorSerializer: FileProperties.TemplateErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let templatesUpdateForTeam = Route(
        name: "templates/update_for_team",
        namespace: "file_properties",
        deprecated: false,
        argSerializer: FileProperties.UpdateTemplateArgSerializer(),
        responseSerializer: FileProperties.UpdateTemplateResultSerializer(),
        errorSerializer: FileProperties.ModifyTemplateErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let templatesUpdateForUser = Route(
        name: "templates/update_for_user",
        namespace: "file_properties",
        deprecated: false,
        argSerializer: FileProperties.UpdateTemplateArgSerializer(),
        responseSerializer: FileProperties.UpdateTemplateResultSerializer(),
        errorSerializer: FileProperties.ModifyTemplateErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
}
