///
/// Copyright (c) 2016 Dropbox, Inc. All rights reserved.
///
/// Auto-generated by Stone, do not modify.
///

import Foundation

/// Datatypes and serializers for the file_properties namespace
public class FileProperties {
    /// The AddPropertiesArg struct
    public class AddPropertiesArg: CustomStringConvertible, JSONRepresentable {
        /// A unique identifier for the file or folder.
        public let path: String
        /// The property groups which are to be added to a Dropbox file. No two groups in the input should  refer to the
        /// same template.
        public let propertyGroups: [FileProperties.PropertyGroup]
        public init(path: String, propertyGroups: [FileProperties.PropertyGroup]) {
            stringValidator(pattern: "/(.|[\\r\\n])*|id:.*|(ns:[0-9]+(/.*)?)")(path)
            self.path = path
            self.propertyGroups = propertyGroups
        }

        func json() throws -> JSON {
            try AddPropertiesArgSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try AddPropertiesArgSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for AddPropertiesArg: \(error)"
            }
        }
    }

    public class AddPropertiesArgSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: AddPropertiesArg) throws -> JSON {
            let output = [
                "path": try Serialization._StringSerializer.serialize(value.path),
                "property_groups": try ArraySerializer(FileProperties.PropertyGroupSerializer()).serialize(value.propertyGroups),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> AddPropertiesArg {
            switch json {
            case .dictionary(let dict):
                let path = try Serialization._StringSerializer.deserialize(dict["path"] ?? .null)
                let propertyGroups = try ArraySerializer(FileProperties.PropertyGroupSerializer()).deserialize(dict["property_groups"] ?? .null)
                return AddPropertiesArg(path: path, propertyGroups: propertyGroups)
            default:
                throw JSONSerializerError.deserializeError(type: AddPropertiesArg.self, json: json)
            }
        }
    }

    /// The TemplateError union
    public enum TemplateError: CustomStringConvertible, JSONRepresentable {
        /// Template does not exist for the given identifier.
        case templateNotFound(String)
        /// You do not have permission to modify this template.
        case restrictedContent
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try TemplateErrorSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TemplateErrorSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TemplateError: \(error)"
            }
        }
    }

    public class TemplateErrorSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TemplateError) throws -> JSON {
            switch value {
            case .templateNotFound(let arg):
                var d = try ["template_not_found": Serialization._StringSerializer.serialize(arg)]
                d[".tag"] = .str("template_not_found")
                return .dictionary(d)
            case .restrictedContent:
                var d = [String: JSON]()
                d[".tag"] = .str("restricted_content")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> TemplateError {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "template_not_found":
                    let v = try Serialization._StringSerializer.deserialize(d["template_not_found"] ?? .null)
                    return TemplateError.templateNotFound(v)
                case "restricted_content":
                    return TemplateError.restrictedContent
                case "other":
                    return TemplateError.other
                default:
                    return TemplateError.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: TemplateError.self, json: json)
            }
        }
    }

    /// The PropertiesError union
    public enum PropertiesError: CustomStringConvertible, JSONRepresentable {
        /// Template does not exist for the given identifier.
        case templateNotFound(String)
        /// You do not have permission to modify this template.
        case restrictedContent
        /// An unspecified error.
        case other
        /// An unspecified error.
        case path(FileProperties.LookupError)
        /// This folder cannot be tagged. Tagging folders is not supported for team-owned templates.
        case unsupportedFolder

        func json() throws -> JSON {
            try PropertiesErrorSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PropertiesErrorSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PropertiesError: \(error)"
            }
        }
    }

    public class PropertiesErrorSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PropertiesError) throws -> JSON {
            switch value {
            case .templateNotFound(let arg):
                var d = try ["template_not_found": Serialization._StringSerializer.serialize(arg)]
                d[".tag"] = .str("template_not_found")
                return .dictionary(d)
            case .restrictedContent:
                var d = [String: JSON]()
                d[".tag"] = .str("restricted_content")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            case .path(let arg):
                var d = try ["path": FileProperties.LookupErrorSerializer().serialize(arg)]
                d[".tag"] = .str("path")
                return .dictionary(d)
            case .unsupportedFolder:
                var d = [String: JSON]()
                d[".tag"] = .str("unsupported_folder")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> PropertiesError {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "template_not_found":
                    let v = try Serialization._StringSerializer.deserialize(d["template_not_found"] ?? .null)
                    return PropertiesError.templateNotFound(v)
                case "restricted_content":
                    return PropertiesError.restrictedContent
                case "other":
                    return PropertiesError.other
                case "path":
                    let v = try FileProperties.LookupErrorSerializer().deserialize(d["path"] ?? .null)
                    return PropertiesError.path(v)
                case "unsupported_folder":
                    return PropertiesError.unsupportedFolder
                default:
                    throw JSONSerializerError.unknownTag(type: PropertiesError.self, json: json, tag: tag)
                }
            default:
                throw JSONSerializerError.deserializeError(type: PropertiesError.self, json: json)
            }
        }
    }

    /// The InvalidPropertyGroupError union
    public enum InvalidPropertyGroupError: CustomStringConvertible, JSONRepresentable {
        /// Template does not exist for the given identifier.
        case templateNotFound(String)
        /// You do not have permission to modify this template.
        case restrictedContent
        /// An unspecified error.
        case other
        /// An unspecified error.
        case path(FileProperties.LookupError)
        /// This folder cannot be tagged. Tagging folders is not supported for team-owned templates.
        case unsupportedFolder
        /// One or more of the supplied property field values is too large.
        case propertyFieldTooLarge
        /// One or more of the supplied property fields does not conform to the template specifications.
        case doesNotFitTemplate
        /// There are 2 or more property groups referring to the same templates in the input.
        case duplicatePropertyGroups

        func json() throws -> JSON {
            try InvalidPropertyGroupErrorSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try InvalidPropertyGroupErrorSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for InvalidPropertyGroupError: \(error)"
            }
        }
    }

    public class InvalidPropertyGroupErrorSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: InvalidPropertyGroupError) throws -> JSON {
            switch value {
            case .templateNotFound(let arg):
                var d = try ["template_not_found": Serialization._StringSerializer.serialize(arg)]
                d[".tag"] = .str("template_not_found")
                return .dictionary(d)
            case .restrictedContent:
                var d = [String: JSON]()
                d[".tag"] = .str("restricted_content")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            case .path(let arg):
                var d = try ["path": FileProperties.LookupErrorSerializer().serialize(arg)]
                d[".tag"] = .str("path")
                return .dictionary(d)
            case .unsupportedFolder:
                var d = [String: JSON]()
                d[".tag"] = .str("unsupported_folder")
                return .dictionary(d)
            case .propertyFieldTooLarge:
                var d = [String: JSON]()
                d[".tag"] = .str("property_field_too_large")
                return .dictionary(d)
            case .doesNotFitTemplate:
                var d = [String: JSON]()
                d[".tag"] = .str("does_not_fit_template")
                return .dictionary(d)
            case .duplicatePropertyGroups:
                var d = [String: JSON]()
                d[".tag"] = .str("duplicate_property_groups")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> InvalidPropertyGroupError {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "template_not_found":
                    let v = try Serialization._StringSerializer.deserialize(d["template_not_found"] ?? .null)
                    return InvalidPropertyGroupError.templateNotFound(v)
                case "restricted_content":
                    return InvalidPropertyGroupError.restrictedContent
                case "other":
                    return InvalidPropertyGroupError.other
                case "path":
                    let v = try FileProperties.LookupErrorSerializer().deserialize(d["path"] ?? .null)
                    return InvalidPropertyGroupError.path(v)
                case "unsupported_folder":
                    return InvalidPropertyGroupError.unsupportedFolder
                case "property_field_too_large":
                    return InvalidPropertyGroupError.propertyFieldTooLarge
                case "does_not_fit_template":
                    return InvalidPropertyGroupError.doesNotFitTemplate
                case "duplicate_property_groups":
                    return InvalidPropertyGroupError.duplicatePropertyGroups
                default:
                    throw JSONSerializerError.unknownTag(type: InvalidPropertyGroupError.self, json: json, tag: tag)
                }
            default:
                throw JSONSerializerError.deserializeError(type: InvalidPropertyGroupError.self, json: json)
            }
        }
    }

    /// The AddPropertiesError union
    public enum AddPropertiesError: CustomStringConvertible, JSONRepresentable {
        /// Template does not exist for the given identifier.
        case templateNotFound(String)
        /// You do not have permission to modify this template.
        case restrictedContent
        /// An unspecified error.
        case other
        /// An unspecified error.
        case path(FileProperties.LookupError)
        /// This folder cannot be tagged. Tagging folders is not supported for team-owned templates.
        case unsupportedFolder
        /// One or more of the supplied property field values is too large.
        case propertyFieldTooLarge
        /// One or more of the supplied property fields does not conform to the template specifications.
        case doesNotFitTemplate
        /// There are 2 or more property groups referring to the same templates in the input.
        case duplicatePropertyGroups
        /// A property group associated with this template and file already exists.
        case propertyGroupAlreadyExists

        func json() throws -> JSON {
            try AddPropertiesErrorSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try AddPropertiesErrorSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for AddPropertiesError: \(error)"
            }
        }
    }

    public class AddPropertiesErrorSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: AddPropertiesError) throws -> JSON {
            switch value {
            case .templateNotFound(let arg):
                var d = try ["template_not_found": Serialization._StringSerializer.serialize(arg)]
                d[".tag"] = .str("template_not_found")
                return .dictionary(d)
            case .restrictedContent:
                var d = [String: JSON]()
                d[".tag"] = .str("restricted_content")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            case .path(let arg):
                var d = try ["path": FileProperties.LookupErrorSerializer().serialize(arg)]
                d[".tag"] = .str("path")
                return .dictionary(d)
            case .unsupportedFolder:
                var d = [String: JSON]()
                d[".tag"] = .str("unsupported_folder")
                return .dictionary(d)
            case .propertyFieldTooLarge:
                var d = [String: JSON]()
                d[".tag"] = .str("property_field_too_large")
                return .dictionary(d)
            case .doesNotFitTemplate:
                var d = [String: JSON]()
                d[".tag"] = .str("does_not_fit_template")
                return .dictionary(d)
            case .duplicatePropertyGroups:
                var d = [String: JSON]()
                d[".tag"] = .str("duplicate_property_groups")
                return .dictionary(d)
            case .propertyGroupAlreadyExists:
                var d = [String: JSON]()
                d[".tag"] = .str("property_group_already_exists")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> AddPropertiesError {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "template_not_found":
                    let v = try Serialization._StringSerializer.deserialize(d["template_not_found"] ?? .null)
                    return AddPropertiesError.templateNotFound(v)
                case "restricted_content":
                    return AddPropertiesError.restrictedContent
                case "other":
                    return AddPropertiesError.other
                case "path":
                    let v = try FileProperties.LookupErrorSerializer().deserialize(d["path"] ?? .null)
                    return AddPropertiesError.path(v)
                case "unsupported_folder":
                    return AddPropertiesError.unsupportedFolder
                case "property_field_too_large":
                    return AddPropertiesError.propertyFieldTooLarge
                case "does_not_fit_template":
                    return AddPropertiesError.doesNotFitTemplate
                case "duplicate_property_groups":
                    return AddPropertiesError.duplicatePropertyGroups
                case "property_group_already_exists":
                    return AddPropertiesError.propertyGroupAlreadyExists
                default:
                    throw JSONSerializerError.unknownTag(type: AddPropertiesError.self, json: json, tag: tag)
                }
            default:
                throw JSONSerializerError.deserializeError(type: AddPropertiesError.self, json: json)
            }
        }
    }

    /// Defines how a property group may be structured.
    public class PropertyGroupTemplate: CustomStringConvertible, JSONRepresentable {
        /// Display name for the template. Template names can be up to 256 bytes.
        public let name: String
        /// Description for the template. Template descriptions can be up to 1024 bytes.
        public let description_: String
        /// Definitions of the property fields associated with this template. There can be up to 32 properties in a
        /// single template.
        public let fields: [FileProperties.PropertyFieldTemplate]
        public init(name: String, description_: String, fields: [FileProperties.PropertyFieldTemplate]) {
            stringValidator()(name)
            self.name = name
            stringValidator()(description_)
            self.description_ = description_
            self.fields = fields
        }

        func json() throws -> JSON {
            try PropertyGroupTemplateSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PropertyGroupTemplateSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PropertyGroupTemplate: \(error)"
            }
        }
    }

    public class PropertyGroupTemplateSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PropertyGroupTemplate) throws -> JSON {
            let output = [
                "name": try Serialization._StringSerializer.serialize(value.name),
                "description": try Serialization._StringSerializer.serialize(value.description_),
                "fields": try ArraySerializer(FileProperties.PropertyFieldTemplateSerializer()).serialize(value.fields),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PropertyGroupTemplate {
            switch json {
            case .dictionary(let dict):
                let name = try Serialization._StringSerializer.deserialize(dict["name"] ?? .null)
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                let fields = try ArraySerializer(FileProperties.PropertyFieldTemplateSerializer()).deserialize(dict["fields"] ?? .null)
                return PropertyGroupTemplate(name: name, description_: description_, fields: fields)
            default:
                throw JSONSerializerError.deserializeError(type: PropertyGroupTemplate.self, json: json)
            }
        }
    }

    /// The AddTemplateArg struct
    public class AddTemplateArg: FileProperties.PropertyGroupTemplate {
        public override var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try AddTemplateArgSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for AddTemplateArg: \(error)"
            }
        }
    }

    public class AddTemplateArgSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: AddTemplateArg) throws -> JSON {
            let output = [
                "name": try Serialization._StringSerializer.serialize(value.name),
                "description": try Serialization._StringSerializer.serialize(value.description_),
                "fields": try ArraySerializer(FileProperties.PropertyFieldTemplateSerializer()).serialize(value.fields),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> AddTemplateArg {
            switch json {
            case .dictionary(let dict):
                let name = try Serialization._StringSerializer.deserialize(dict["name"] ?? .null)
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                let fields = try ArraySerializer(FileProperties.PropertyFieldTemplateSerializer()).deserialize(dict["fields"] ?? .null)
                return AddTemplateArg(name: name, description_: description_, fields: fields)
            default:
                throw JSONSerializerError.deserializeError(type: AddTemplateArg.self, json: json)
            }
        }
    }

    /// The AddTemplateResult struct
    public class AddTemplateResult: CustomStringConvertible, JSONRepresentable {
        /// An identifier for template added by  See templatesAddForUser or templatesAddForTeam.
        public let templateId: String
        public init(templateId: String) {
            stringValidator(minLength: 1, pattern: "(/|ptid:).*")(templateId)
            self.templateId = templateId
        }

        func json() throws -> JSON {
            try AddTemplateResultSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try AddTemplateResultSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for AddTemplateResult: \(error)"
            }
        }
    }

    public class AddTemplateResultSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: AddTemplateResult) throws -> JSON {
            let output = [
                "template_id": try Serialization._StringSerializer.serialize(value.templateId),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> AddTemplateResult {
            switch json {
            case .dictionary(let dict):
                let templateId = try Serialization._StringSerializer.deserialize(dict["template_id"] ?? .null)
                return AddTemplateResult(templateId: templateId)
            default:
                throw JSONSerializerError.deserializeError(type: AddTemplateResult.self, json: json)
            }
        }
    }

    /// The GetTemplateArg struct
    public class GetTemplateArg: CustomStringConvertible, JSONRepresentable {
        /// An identifier for template added by route  See templatesAddForUser or templatesAddForTeam.
        public let templateId: String
        public init(templateId: String) {
            stringValidator(minLength: 1, pattern: "(/|ptid:).*")(templateId)
            self.templateId = templateId
        }

        func json() throws -> JSON {
            try GetTemplateArgSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try GetTemplateArgSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for GetTemplateArg: \(error)"
            }
        }
    }

    public class GetTemplateArgSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: GetTemplateArg) throws -> JSON {
            let output = [
                "template_id": try Serialization._StringSerializer.serialize(value.templateId),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> GetTemplateArg {
            switch json {
            case .dictionary(let dict):
                let templateId = try Serialization._StringSerializer.deserialize(dict["template_id"] ?? .null)
                return GetTemplateArg(templateId: templateId)
            default:
                throw JSONSerializerError.deserializeError(type: GetTemplateArg.self, json: json)
            }
        }
    }

    /// The GetTemplateResult struct
    public class GetTemplateResult: FileProperties.PropertyGroupTemplate {
        public override var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try GetTemplateResultSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for GetTemplateResult: \(error)"
            }
        }
    }

    public class GetTemplateResultSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: GetTemplateResult) throws -> JSON {
            let output = [
                "name": try Serialization._StringSerializer.serialize(value.name),
                "description": try Serialization._StringSerializer.serialize(value.description_),
                "fields": try ArraySerializer(FileProperties.PropertyFieldTemplateSerializer()).serialize(value.fields),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> GetTemplateResult {
            switch json {
            case .dictionary(let dict):
                let name = try Serialization._StringSerializer.deserialize(dict["name"] ?? .null)
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                let fields = try ArraySerializer(FileProperties.PropertyFieldTemplateSerializer()).deserialize(dict["fields"] ?? .null)
                return GetTemplateResult(name: name, description_: description_, fields: fields)
            default:
                throw JSONSerializerError.deserializeError(type: GetTemplateResult.self, json: json)
            }
        }
    }

    /// The ListTemplateResult struct
    public class ListTemplateResult: CustomStringConvertible, JSONRepresentable {
        /// List of identifiers for templates added by  See templatesAddForUser or templatesAddForTeam.
        public let templateIds: [String]
        public init(templateIds: [String]) {
            arrayValidator(itemValidator: stringValidator(minLength: 1, pattern: "(/|ptid:).*"))(templateIds)
            self.templateIds = templateIds
        }

        func json() throws -> JSON {
            try ListTemplateResultSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ListTemplateResultSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ListTemplateResult: \(error)"
            }
        }
    }

    public class ListTemplateResultSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ListTemplateResult) throws -> JSON {
            let output = [
                "template_ids": try ArraySerializer(Serialization._StringSerializer).serialize(value.templateIds),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ListTemplateResult {
            switch json {
            case .dictionary(let dict):
                let templateIds = try ArraySerializer(Serialization._StringSerializer).deserialize(dict["template_ids"] ?? .null)
                return ListTemplateResult(templateIds: templateIds)
            default:
                throw JSONSerializerError.deserializeError(type: ListTemplateResult.self, json: json)
            }
        }
    }

    /// Logical operator to join search queries together.
    public enum LogicalOperator: CustomStringConvertible, JSONRepresentable {
        /// Append a query with an "or" operator.
        case orOperator
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try LogicalOperatorSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try LogicalOperatorSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for LogicalOperator: \(error)"
            }
        }
    }

    public class LogicalOperatorSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: LogicalOperator) throws -> JSON {
            switch value {
            case .orOperator:
                var d = [String: JSON]()
                d[".tag"] = .str("or_operator")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> LogicalOperator {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "or_operator":
                    return LogicalOperator.orOperator
                case "other":
                    return LogicalOperator.other
                default:
                    return LogicalOperator.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: LogicalOperator.self, json: json)
            }
        }
    }

    /// The LookUpPropertiesError union
    public enum LookUpPropertiesError: CustomStringConvertible, JSONRepresentable {
        /// No property group was found.
        case propertyGroupNotFound
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try LookUpPropertiesErrorSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try LookUpPropertiesErrorSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for LookUpPropertiesError: \(error)"
            }
        }
    }

    public class LookUpPropertiesErrorSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: LookUpPropertiesError) throws -> JSON {
            switch value {
            case .propertyGroupNotFound:
                var d = [String: JSON]()
                d[".tag"] = .str("property_group_not_found")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> LookUpPropertiesError {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "property_group_not_found":
                    return LookUpPropertiesError.propertyGroupNotFound
                case "other":
                    return LookUpPropertiesError.other
                default:
                    return LookUpPropertiesError.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: LookUpPropertiesError.self, json: json)
            }
        }
    }

    /// The LookupError union
    public enum LookupError: CustomStringConvertible, JSONRepresentable {
        /// An unspecified error.
        case malformedPath(String)
        /// There is nothing at the given path.
        case notFound
        /// We were expecting a file, but the given path refers to something that isn't a file.
        case notFile
        /// We were expecting a folder, but the given path refers to something that isn't a folder.
        case notFolder
        /// The file cannot be transferred because the content is restricted. For example, we might restrict a file due
        /// to legal requirements.
        case restrictedContent
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try LookupErrorSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try LookupErrorSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for LookupError: \(error)"
            }
        }
    }

    public class LookupErrorSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: LookupError) throws -> JSON {
            switch value {
            case .malformedPath(let arg):
                var d = try ["malformed_path": Serialization._StringSerializer.serialize(arg)]
                d[".tag"] = .str("malformed_path")
                return .dictionary(d)
            case .notFound:
                var d = [String: JSON]()
                d[".tag"] = .str("not_found")
                return .dictionary(d)
            case .notFile:
                var d = [String: JSON]()
                d[".tag"] = .str("not_file")
                return .dictionary(d)
            case .notFolder:
                var d = [String: JSON]()
                d[".tag"] = .str("not_folder")
                return .dictionary(d)
            case .restrictedContent:
                var d = [String: JSON]()
                d[".tag"] = .str("restricted_content")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> LookupError {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "malformed_path":
                    let v = try Serialization._StringSerializer.deserialize(d["malformed_path"] ?? .null)
                    return LookupError.malformedPath(v)
                case "not_found":
                    return LookupError.notFound
                case "not_file":
                    return LookupError.notFile
                case "not_folder":
                    return LookupError.notFolder
                case "restricted_content":
                    return LookupError.restrictedContent
                case "other":
                    return LookupError.other
                default:
                    return LookupError.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: LookupError.self, json: json)
            }
        }
    }

    /// The ModifyTemplateError union
    public enum ModifyTemplateError: CustomStringConvertible, JSONRepresentable {
        /// Template does not exist for the given identifier.
        case templateNotFound(String)
        /// You do not have permission to modify this template.
        case restrictedContent
        /// An unspecified error.
        case other
        /// A property field key with that name already exists in the template.
        case conflictingPropertyNames
        /// There are too many properties in the changed template. The maximum number of properties per template is 32.
        case tooManyProperties
        /// There are too many templates for the team.
        case tooManyTemplates
        /// The template name, description or one or more of the property field keys is too large.
        case templateAttributeTooLarge

        func json() throws -> JSON {
            try ModifyTemplateErrorSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ModifyTemplateErrorSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ModifyTemplateError: \(error)"
            }
        }
    }

    public class ModifyTemplateErrorSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ModifyTemplateError) throws -> JSON {
            switch value {
            case .templateNotFound(let arg):
                var d = try ["template_not_found": Serialization._StringSerializer.serialize(arg)]
                d[".tag"] = .str("template_not_found")
                return .dictionary(d)
            case .restrictedContent:
                var d = [String: JSON]()
                d[".tag"] = .str("restricted_content")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            case .conflictingPropertyNames:
                var d = [String: JSON]()
                d[".tag"] = .str("conflicting_property_names")
                return .dictionary(d)
            case .tooManyProperties:
                var d = [String: JSON]()
                d[".tag"] = .str("too_many_properties")
                return .dictionary(d)
            case .tooManyTemplates:
                var d = [String: JSON]()
                d[".tag"] = .str("too_many_templates")
                return .dictionary(d)
            case .templateAttributeTooLarge:
                var d = [String: JSON]()
                d[".tag"] = .str("template_attribute_too_large")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> ModifyTemplateError {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "template_not_found":
                    let v = try Serialization._StringSerializer.deserialize(d["template_not_found"] ?? .null)
                    return ModifyTemplateError.templateNotFound(v)
                case "restricted_content":
                    return ModifyTemplateError.restrictedContent
                case "other":
                    return ModifyTemplateError.other
                case "conflicting_property_names":
                    return ModifyTemplateError.conflictingPropertyNames
                case "too_many_properties":
                    return ModifyTemplateError.tooManyProperties
                case "too_many_templates":
                    return ModifyTemplateError.tooManyTemplates
                case "template_attribute_too_large":
                    return ModifyTemplateError.templateAttributeTooLarge
                default:
                    throw JSONSerializerError.unknownTag(type: ModifyTemplateError.self, json: json, tag: tag)
                }
            default:
                throw JSONSerializerError.deserializeError(type: ModifyTemplateError.self, json: json)
            }
        }
    }

    /// The OverwritePropertyGroupArg struct
    public class OverwritePropertyGroupArg: CustomStringConvertible, JSONRepresentable {
        /// A unique identifier for the file or folder.
        public let path: String
        /// The property groups "snapshot" updates to force apply. No two groups in the input should  refer to the same
        /// template.
        public let propertyGroups: [FileProperties.PropertyGroup]
        public init(path: String, propertyGroups: [FileProperties.PropertyGroup]) {
            stringValidator(pattern: "/(.|[\\r\\n])*|id:.*|(ns:[0-9]+(/.*)?)")(path)
            self.path = path
            self.propertyGroups = propertyGroups
        }

        func json() throws -> JSON {
            try OverwritePropertyGroupArgSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try OverwritePropertyGroupArgSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for OverwritePropertyGroupArg: \(error)"
            }
        }
    }

    public class OverwritePropertyGroupArgSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: OverwritePropertyGroupArg) throws -> JSON {
            let output = [
                "path": try Serialization._StringSerializer.serialize(value.path),
                "property_groups": try ArraySerializer(FileProperties.PropertyGroupSerializer()).serialize(value.propertyGroups),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> OverwritePropertyGroupArg {
            switch json {
            case .dictionary(let dict):
                let path = try Serialization._StringSerializer.deserialize(dict["path"] ?? .null)
                let propertyGroups = try ArraySerializer(FileProperties.PropertyGroupSerializer()).deserialize(dict["property_groups"] ?? .null)
                return OverwritePropertyGroupArg(path: path, propertyGroups: propertyGroups)
            default:
                throw JSONSerializerError.deserializeError(type: OverwritePropertyGroupArg.self, json: json)
            }
        }
    }

    /// The PropertiesSearchArg struct
    public class PropertiesSearchArg: CustomStringConvertible, JSONRepresentable {
        /// Queries to search.
        public let queries: [FileProperties.PropertiesSearchQuery]
        /// Filter results to contain only properties associated with these template IDs.
        public let templateFilter: FileProperties.TemplateFilter
        public init(queries: [FileProperties.PropertiesSearchQuery], templateFilter: FileProperties.TemplateFilter = .filterNone) {
            self.queries = queries
            self.templateFilter = templateFilter
        }

        func json() throws -> JSON {
            try PropertiesSearchArgSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PropertiesSearchArgSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PropertiesSearchArg: \(error)"
            }
        }
    }

    public class PropertiesSearchArgSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PropertiesSearchArg) throws -> JSON {
            let output = [
                "queries": try ArraySerializer(FileProperties.PropertiesSearchQuerySerializer()).serialize(value.queries),
                "template_filter": try FileProperties.TemplateFilterSerializer().serialize(value.templateFilter),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PropertiesSearchArg {
            switch json {
            case .dictionary(let dict):
                let queries = try ArraySerializer(FileProperties.PropertiesSearchQuerySerializer()).deserialize(dict["queries"] ?? .null)
                let templateFilter = try FileProperties.TemplateFilterSerializer()
                    .deserialize(dict["template_filter"] ?? FileProperties.TemplateFilterSerializer().serialize(.filterNone))
                return PropertiesSearchArg(queries: queries, templateFilter: templateFilter)
            default:
                throw JSONSerializerError.deserializeError(type: PropertiesSearchArg.self, json: json)
            }
        }
    }

    /// The PropertiesSearchContinueArg struct
    public class PropertiesSearchContinueArg: CustomStringConvertible, JSONRepresentable {
        /// The cursor returned by your last call to propertiesSearch or propertiesSearchContinue.
        public let cursor: String
        public init(cursor: String) {
            stringValidator(minLength: 1)(cursor)
            self.cursor = cursor
        }

        func json() throws -> JSON {
            try PropertiesSearchContinueArgSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PropertiesSearchContinueArgSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PropertiesSearchContinueArg: \(error)"
            }
        }
    }

    public class PropertiesSearchContinueArgSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PropertiesSearchContinueArg) throws -> JSON {
            let output = [
                "cursor": try Serialization._StringSerializer.serialize(value.cursor),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PropertiesSearchContinueArg {
            switch json {
            case .dictionary(let dict):
                let cursor = try Serialization._StringSerializer.deserialize(dict["cursor"] ?? .null)
                return PropertiesSearchContinueArg(cursor: cursor)
            default:
                throw JSONSerializerError.deserializeError(type: PropertiesSearchContinueArg.self, json: json)
            }
        }
    }

    /// The PropertiesSearchContinueError union
    public enum PropertiesSearchContinueError: CustomStringConvertible, JSONRepresentable {
        /// Indicates that the cursor has been invalidated. Call propertiesSearch to obtain a new cursor.
        case reset
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try PropertiesSearchContinueErrorSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PropertiesSearchContinueErrorSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PropertiesSearchContinueError: \(error)"
            }
        }
    }

    public class PropertiesSearchContinueErrorSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PropertiesSearchContinueError) throws -> JSON {
            switch value {
            case .reset:
                var d = [String: JSON]()
                d[".tag"] = .str("reset")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> PropertiesSearchContinueError {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "reset":
                    return PropertiesSearchContinueError.reset
                case "other":
                    return PropertiesSearchContinueError.other
                default:
                    return PropertiesSearchContinueError.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: PropertiesSearchContinueError.self, json: json)
            }
        }
    }

    /// The PropertiesSearchError union
    public enum PropertiesSearchError: CustomStringConvertible, JSONRepresentable {
        /// An unspecified error.
        case propertyGroupLookup(FileProperties.LookUpPropertiesError)
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try PropertiesSearchErrorSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PropertiesSearchErrorSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PropertiesSearchError: \(error)"
            }
        }
    }

    public class PropertiesSearchErrorSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PropertiesSearchError) throws -> JSON {
            switch value {
            case .propertyGroupLookup(let arg):
                var d = try ["property_group_lookup": FileProperties.LookUpPropertiesErrorSerializer().serialize(arg)]
                d[".tag"] = .str("property_group_lookup")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> PropertiesSearchError {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "property_group_lookup":
                    let v = try FileProperties.LookUpPropertiesErrorSerializer().deserialize(d["property_group_lookup"] ?? .null)
                    return PropertiesSearchError.propertyGroupLookup(v)
                case "other":
                    return PropertiesSearchError.other
                default:
                    return PropertiesSearchError.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: PropertiesSearchError.self, json: json)
            }
        }
    }

    /// The PropertiesSearchMatch struct
    public class PropertiesSearchMatch: CustomStringConvertible, JSONRepresentable {
        /// The ID for the matched file or folder.
        public let id: String
        /// The path for the matched file or folder.
        public let path: String
        /// Whether the file or folder is deleted.
        public let isDeleted: Bool
        /// List of custom property groups associated with the file.
        public let propertyGroups: [FileProperties.PropertyGroup]
        public init(id: String, path: String, isDeleted: Bool, propertyGroups: [FileProperties.PropertyGroup]) {
            stringValidator(minLength: 1)(id)
            self.id = id
            stringValidator()(path)
            self.path = path
            self.isDeleted = isDeleted
            self.propertyGroups = propertyGroups
        }

        func json() throws -> JSON {
            try PropertiesSearchMatchSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PropertiesSearchMatchSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PropertiesSearchMatch: \(error)"
            }
        }
    }

    public class PropertiesSearchMatchSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PropertiesSearchMatch) throws -> JSON {
            let output = [
                "id": try Serialization._StringSerializer.serialize(value.id),
                "path": try Serialization._StringSerializer.serialize(value.path),
                "is_deleted": try Serialization._BoolSerializer.serialize(value.isDeleted),
                "property_groups": try ArraySerializer(FileProperties.PropertyGroupSerializer()).serialize(value.propertyGroups),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PropertiesSearchMatch {
            switch json {
            case .dictionary(let dict):
                let id = try Serialization._StringSerializer.deserialize(dict["id"] ?? .null)
                let path = try Serialization._StringSerializer.deserialize(dict["path"] ?? .null)
                let isDeleted = try Serialization._BoolSerializer.deserialize(dict["is_deleted"] ?? .null)
                let propertyGroups = try ArraySerializer(FileProperties.PropertyGroupSerializer()).deserialize(dict["property_groups"] ?? .null)
                return PropertiesSearchMatch(id: id, path: path, isDeleted: isDeleted, propertyGroups: propertyGroups)
            default:
                throw JSONSerializerError.deserializeError(type: PropertiesSearchMatch.self, json: json)
            }
        }
    }

    /// The PropertiesSearchMode union
    public enum PropertiesSearchMode: CustomStringConvertible, JSONRepresentable {
        /// Search for a value associated with this field name.
        case fieldName(String)
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try PropertiesSearchModeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PropertiesSearchModeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PropertiesSearchMode: \(error)"
            }
        }
    }

    public class PropertiesSearchModeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PropertiesSearchMode) throws -> JSON {
            switch value {
            case .fieldName(let arg):
                var d = try ["field_name": Serialization._StringSerializer.serialize(arg)]
                d[".tag"] = .str("field_name")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> PropertiesSearchMode {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "field_name":
                    let v = try Serialization._StringSerializer.deserialize(d["field_name"] ?? .null)
                    return PropertiesSearchMode.fieldName(v)
                case "other":
                    return PropertiesSearchMode.other
                default:
                    return PropertiesSearchMode.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: PropertiesSearchMode.self, json: json)
            }
        }
    }

    /// The PropertiesSearchQuery struct
    public class PropertiesSearchQuery: CustomStringConvertible, JSONRepresentable {
        /// The property field value for which to search across templates.
        public let query: String
        /// The mode with which to perform the search.
        public let mode: FileProperties.PropertiesSearchMode
        /// The logical operator with which to append the query.
        public let logicalOperator: FileProperties.LogicalOperator
        public init(query: String, mode: FileProperties.PropertiesSearchMode, logicalOperator: FileProperties.LogicalOperator = .orOperator) {
            stringValidator()(query)
            self.query = query
            self.mode = mode
            self.logicalOperator = logicalOperator
        }

        func json() throws -> JSON {
            try PropertiesSearchQuerySerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PropertiesSearchQuerySerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PropertiesSearchQuery: \(error)"
            }
        }
    }

    public class PropertiesSearchQuerySerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PropertiesSearchQuery) throws -> JSON {
            let output = [
                "query": try Serialization._StringSerializer.serialize(value.query),
                "mode": try FileProperties.PropertiesSearchModeSerializer().serialize(value.mode),
                "logical_operator": try FileProperties.LogicalOperatorSerializer().serialize(value.logicalOperator),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PropertiesSearchQuery {
            switch json {
            case .dictionary(let dict):
                let query = try Serialization._StringSerializer.deserialize(dict["query"] ?? .null)
                let mode = try FileProperties.PropertiesSearchModeSerializer().deserialize(dict["mode"] ?? .null)
                let logicalOperator = try FileProperties.LogicalOperatorSerializer()
                    .deserialize(dict["logical_operator"] ?? FileProperties.LogicalOperatorSerializer().serialize(.orOperator))
                return PropertiesSearchQuery(query: query, mode: mode, logicalOperator: logicalOperator)
            default:
                throw JSONSerializerError.deserializeError(type: PropertiesSearchQuery.self, json: json)
            }
        }
    }

    /// The PropertiesSearchResult struct
    public class PropertiesSearchResult: CustomStringConvertible, JSONRepresentable {
        /// A list (possibly empty) of matches for the query.
        public let matches: [FileProperties.PropertiesSearchMatch]
        /// Pass the cursor into propertiesSearchContinue to continue to receive search results. Cursor will be null
        /// when there are no more results.
        public let cursor: String?
        public init(matches: [FileProperties.PropertiesSearchMatch], cursor: String? = nil) {
            self.matches = matches
            nullableValidator(stringValidator(minLength: 1))(cursor)
            self.cursor = cursor
        }

        func json() throws -> JSON {
            try PropertiesSearchResultSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PropertiesSearchResultSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PropertiesSearchResult: \(error)"
            }
        }
    }

    public class PropertiesSearchResultSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PropertiesSearchResult) throws -> JSON {
            let output = [
                "matches": try ArraySerializer(FileProperties.PropertiesSearchMatchSerializer()).serialize(value.matches),
                "cursor": try NullableSerializer(Serialization._StringSerializer).serialize(value.cursor),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PropertiesSearchResult {
            switch json {
            case .dictionary(let dict):
                let matches = try ArraySerializer(FileProperties.PropertiesSearchMatchSerializer()).deserialize(dict["matches"] ?? .null)
                let cursor = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["cursor"] ?? .null)
                return PropertiesSearchResult(matches: matches, cursor: cursor)
            default:
                throw JSONSerializerError.deserializeError(type: PropertiesSearchResult.self, json: json)
            }
        }
    }

    /// Raw key/value data to be associated with a Dropbox file. Property fields are added to Dropbox files as a
    /// PropertyGroup.
    public class PropertyField: CustomStringConvertible, JSONRepresentable {
        /// Key of the property field associated with a file and template. Keys can be up to 256 bytes.
        public let name: String
        /// Value of the property field associated with a file and template. Values can be up to 1024 bytes.
        public let value: String
        public init(name: String, value: String) {
            stringValidator()(name)
            self.name = name
            stringValidator()(value)
            self.value = value
        }

        func json() throws -> JSON {
            try PropertyFieldSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PropertyFieldSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PropertyField: \(error)"
            }
        }
    }

    public class PropertyFieldSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PropertyField) throws -> JSON {
            let output = [
                "name": try Serialization._StringSerializer.serialize(value.name),
                "value": try Serialization._StringSerializer.serialize(value.value),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PropertyField {
            switch json {
            case .dictionary(let dict):
                let name = try Serialization._StringSerializer.deserialize(dict["name"] ?? .null)
                let value = try Serialization._StringSerializer.deserialize(dict["value"] ?? .null)
                return PropertyField(name: name, value: value)
            default:
                throw JSONSerializerError.deserializeError(type: PropertyField.self, json: json)
            }
        }
    }

    /// Defines how a single property field may be structured. Used exclusively by PropertyGroupTemplate.
    public class PropertyFieldTemplate: CustomStringConvertible, JSONRepresentable {
        /// Key of the property field being described. Property field keys can be up to 256 bytes.
        public let name: String
        /// Description of the property field. Property field descriptions can be up to 1024 bytes.
        public let description_: String
        /// Data type of the value of this property field. This type will be enforced upon property creation and
        /// modifications.
        public let type: FileProperties.PropertyType
        public init(name: String, description_: String, type: FileProperties.PropertyType) {
            stringValidator()(name)
            self.name = name
            stringValidator()(description_)
            self.description_ = description_
            self.type = type
        }

        func json() throws -> JSON {
            try PropertyFieldTemplateSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PropertyFieldTemplateSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PropertyFieldTemplate: \(error)"
            }
        }
    }

    public class PropertyFieldTemplateSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PropertyFieldTemplate) throws -> JSON {
            let output = [
                "name": try Serialization._StringSerializer.serialize(value.name),
                "description": try Serialization._StringSerializer.serialize(value.description_),
                "type": try FileProperties.PropertyTypeSerializer().serialize(value.type),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PropertyFieldTemplate {
            switch json {
            case .dictionary(let dict):
                let name = try Serialization._StringSerializer.deserialize(dict["name"] ?? .null)
                let description_ = try Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                let type = try FileProperties.PropertyTypeSerializer().deserialize(dict["type"] ?? .null)
                return PropertyFieldTemplate(name: name, description_: description_, type: type)
            default:
                throw JSONSerializerError.deserializeError(type: PropertyFieldTemplate.self, json: json)
            }
        }
    }

    /// A subset of the property fields described by the corresponding PropertyGroupTemplate. Properties are always
    /// added to a Dropbox file as a PropertyGroup. The possible key names and value types in this group are defined
    /// by the corresponding PropertyGroupTemplate.
    public class PropertyGroup: CustomStringConvertible, JSONRepresentable {
        /// A unique identifier for the associated template.
        public let templateId: String
        /// The actual properties associated with the template. There can be up to 32 property types per template.
        public let fields: [FileProperties.PropertyField]
        public init(templateId: String, fields: [FileProperties.PropertyField]) {
            stringValidator(minLength: 1, pattern: "(/|ptid:).*")(templateId)
            self.templateId = templateId
            self.fields = fields
        }

        func json() throws -> JSON {
            try PropertyGroupSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PropertyGroupSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PropertyGroup: \(error)"
            }
        }
    }

    public class PropertyGroupSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PropertyGroup) throws -> JSON {
            let output = [
                "template_id": try Serialization._StringSerializer.serialize(value.templateId),
                "fields": try ArraySerializer(FileProperties.PropertyFieldSerializer()).serialize(value.fields),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PropertyGroup {
            switch json {
            case .dictionary(let dict):
                let templateId = try Serialization._StringSerializer.deserialize(dict["template_id"] ?? .null)
                let fields = try ArraySerializer(FileProperties.PropertyFieldSerializer()).deserialize(dict["fields"] ?? .null)
                return PropertyGroup(templateId: templateId, fields: fields)
            default:
                throw JSONSerializerError.deserializeError(type: PropertyGroup.self, json: json)
            }
        }
    }

    /// The PropertyGroupUpdate struct
    public class PropertyGroupUpdate: CustomStringConvertible, JSONRepresentable {
        /// A unique identifier for a property template.
        public let templateId: String
        /// Property fields to update. If the property field already exists, it is updated. If the property field
        /// doesn't exist, the property group is added.
        public let addOrUpdateFields: [FileProperties.PropertyField]?
        /// Property fields to remove (by name), provided they exist.
        public let removeFields: [String]?
        public init(templateId: String, addOrUpdateFields: [FileProperties.PropertyField]? = nil, removeFields: [String]? = nil) {
            stringValidator(minLength: 1, pattern: "(/|ptid:).*")(templateId)
            self.templateId = templateId
            self.addOrUpdateFields = addOrUpdateFields
            nullableValidator(arrayValidator(itemValidator: stringValidator()))(removeFields)
            self.removeFields = removeFields
        }

        func json() throws -> JSON {
            try PropertyGroupUpdateSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PropertyGroupUpdateSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PropertyGroupUpdate: \(error)"
            }
        }
    }

    public class PropertyGroupUpdateSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PropertyGroupUpdate) throws -> JSON {
            let output = [
                "template_id": try Serialization._StringSerializer.serialize(value.templateId),
                "add_or_update_fields": try NullableSerializer(ArraySerializer(FileProperties.PropertyFieldSerializer())).serialize(value.addOrUpdateFields),
                "remove_fields": try NullableSerializer(ArraySerializer(Serialization._StringSerializer)).serialize(value.removeFields),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PropertyGroupUpdate {
            switch json {
            case .dictionary(let dict):
                let templateId = try Serialization._StringSerializer.deserialize(dict["template_id"] ?? .null)
                let addOrUpdateFields = try NullableSerializer(ArraySerializer(FileProperties.PropertyFieldSerializer()))
                    .deserialize(dict["add_or_update_fields"] ?? .null)
                let removeFields = try NullableSerializer(ArraySerializer(Serialization._StringSerializer)).deserialize(dict["remove_fields"] ?? .null)
                return PropertyGroupUpdate(templateId: templateId, addOrUpdateFields: addOrUpdateFields, removeFields: removeFields)
            default:
                throw JSONSerializerError.deserializeError(type: PropertyGroupUpdate.self, json: json)
            }
        }
    }

    /// Data type of the given property field added.
    public enum PropertyType: CustomStringConvertible, JSONRepresentable {
        /// The associated property field will be of type string. Unicode is supported.
        case string_
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try PropertyTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PropertyTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PropertyType: \(error)"
            }
        }
    }

    public class PropertyTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PropertyType) throws -> JSON {
            switch value {
            case .string_:
                var d = [String: JSON]()
                d[".tag"] = .str("string")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> PropertyType {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "string":
                    return PropertyType.string_
                case "other":
                    return PropertyType.other
                default:
                    return PropertyType.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: PropertyType.self, json: json)
            }
        }
    }

    /// The RemovePropertiesArg struct
    public class RemovePropertiesArg: CustomStringConvertible, JSONRepresentable {
        /// A unique identifier for the file or folder.
        public let path: String
        /// A list of identifiers for a template created by templatesAddForUser or templatesAddForTeam.
        public let propertyTemplateIds: [String]
        public init(path: String, propertyTemplateIds: [String]) {
            stringValidator(pattern: "/(.|[\\r\\n])*|id:.*|(ns:[0-9]+(/.*)?)")(path)
            self.path = path
            arrayValidator(itemValidator: stringValidator(minLength: 1, pattern: "(/|ptid:).*"))(propertyTemplateIds)
            self.propertyTemplateIds = propertyTemplateIds
        }

        func json() throws -> JSON {
            try RemovePropertiesArgSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try RemovePropertiesArgSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for RemovePropertiesArg: \(error)"
            }
        }
    }

    public class RemovePropertiesArgSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: RemovePropertiesArg) throws -> JSON {
            let output = [
                "path": try Serialization._StringSerializer.serialize(value.path),
                "property_template_ids": try ArraySerializer(Serialization._StringSerializer).serialize(value.propertyTemplateIds),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> RemovePropertiesArg {
            switch json {
            case .dictionary(let dict):
                let path = try Serialization._StringSerializer.deserialize(dict["path"] ?? .null)
                let propertyTemplateIds = try ArraySerializer(Serialization._StringSerializer).deserialize(dict["property_template_ids"] ?? .null)
                return RemovePropertiesArg(path: path, propertyTemplateIds: propertyTemplateIds)
            default:
                throw JSONSerializerError.deserializeError(type: RemovePropertiesArg.self, json: json)
            }
        }
    }

    /// The RemovePropertiesError union
    public enum RemovePropertiesError: CustomStringConvertible, JSONRepresentable {
        /// Template does not exist for the given identifier.
        case templateNotFound(String)
        /// You do not have permission to modify this template.
        case restrictedContent
        /// An unspecified error.
        case other
        /// An unspecified error.
        case path(FileProperties.LookupError)
        /// This folder cannot be tagged. Tagging folders is not supported for team-owned templates.
        case unsupportedFolder
        /// An unspecified error.
        case propertyGroupLookup(FileProperties.LookUpPropertiesError)

        func json() throws -> JSON {
            try RemovePropertiesErrorSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try RemovePropertiesErrorSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for RemovePropertiesError: \(error)"
            }
        }
    }

    public class RemovePropertiesErrorSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: RemovePropertiesError) throws -> JSON {
            switch value {
            case .templateNotFound(let arg):
                var d = try ["template_not_found": Serialization._StringSerializer.serialize(arg)]
                d[".tag"] = .str("template_not_found")
                return .dictionary(d)
            case .restrictedContent:
                var d = [String: JSON]()
                d[".tag"] = .str("restricted_content")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            case .path(let arg):
                var d = try ["path": FileProperties.LookupErrorSerializer().serialize(arg)]
                d[".tag"] = .str("path")
                return .dictionary(d)
            case .unsupportedFolder:
                var d = [String: JSON]()
                d[".tag"] = .str("unsupported_folder")
                return .dictionary(d)
            case .propertyGroupLookup(let arg):
                var d = try ["property_group_lookup": FileProperties.LookUpPropertiesErrorSerializer().serialize(arg)]
                d[".tag"] = .str("property_group_lookup")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> RemovePropertiesError {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "template_not_found":
                    let v = try Serialization._StringSerializer.deserialize(d["template_not_found"] ?? .null)
                    return RemovePropertiesError.templateNotFound(v)
                case "restricted_content":
                    return RemovePropertiesError.restrictedContent
                case "other":
                    return RemovePropertiesError.other
                case "path":
                    let v = try FileProperties.LookupErrorSerializer().deserialize(d["path"] ?? .null)
                    return RemovePropertiesError.path(v)
                case "unsupported_folder":
                    return RemovePropertiesError.unsupportedFolder
                case "property_group_lookup":
                    let v = try FileProperties.LookUpPropertiesErrorSerializer().deserialize(d["property_group_lookup"] ?? .null)
                    return RemovePropertiesError.propertyGroupLookup(v)
                default:
                    throw JSONSerializerError.unknownTag(type: RemovePropertiesError.self, json: json, tag: tag)
                }
            default:
                throw JSONSerializerError.deserializeError(type: RemovePropertiesError.self, json: json)
            }
        }
    }

    /// The RemoveTemplateArg struct
    public class RemoveTemplateArg: CustomStringConvertible, JSONRepresentable {
        /// An identifier for a template created by templatesAddForUser or templatesAddForTeam.
        public let templateId: String
        public init(templateId: String) {
            stringValidator(minLength: 1, pattern: "(/|ptid:).*")(templateId)
            self.templateId = templateId
        }

        func json() throws -> JSON {
            try RemoveTemplateArgSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try RemoveTemplateArgSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for RemoveTemplateArg: \(error)"
            }
        }
    }

    public class RemoveTemplateArgSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: RemoveTemplateArg) throws -> JSON {
            let output = [
                "template_id": try Serialization._StringSerializer.serialize(value.templateId),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> RemoveTemplateArg {
            switch json {
            case .dictionary(let dict):
                let templateId = try Serialization._StringSerializer.deserialize(dict["template_id"] ?? .null)
                return RemoveTemplateArg(templateId: templateId)
            default:
                throw JSONSerializerError.deserializeError(type: RemoveTemplateArg.self, json: json)
            }
        }
    }

    /// The TemplateFilterBase union
    public enum TemplateFilterBase: CustomStringConvertible, JSONRepresentable {
        /// Only templates with an ID in the supplied list will be returned (a subset of templates will be returned).
        case filterSome([String])
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try TemplateFilterBaseSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TemplateFilterBaseSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TemplateFilterBase: \(error)"
            }
        }
    }

    public class TemplateFilterBaseSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TemplateFilterBase) throws -> JSON {
            switch value {
            case .filterSome(let arg):
                var d = try ["filter_some": ArraySerializer(Serialization._StringSerializer).serialize(arg)]
                d[".tag"] = .str("filter_some")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> TemplateFilterBase {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "filter_some":
                    let v = try ArraySerializer(Serialization._StringSerializer).deserialize(d["filter_some"] ?? .null)
                    return TemplateFilterBase.filterSome(v)
                case "other":
                    return TemplateFilterBase.other
                default:
                    return TemplateFilterBase.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: TemplateFilterBase.self, json: json)
            }
        }
    }

    /// The TemplateFilter union
    public enum TemplateFilter: CustomStringConvertible, JSONRepresentable {
        /// Only templates with an ID in the supplied list will be returned (a subset of templates will be returned).
        case filterSome([String])
        /// An unspecified error.
        case other
        /// No templates will be filtered from the result (all templates will be returned).
        case filterNone

        func json() throws -> JSON {
            try TemplateFilterSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TemplateFilterSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TemplateFilter: \(error)"
            }
        }
    }

    public class TemplateFilterSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TemplateFilter) throws -> JSON {
            switch value {
            case .filterSome(let arg):
                var d = try ["filter_some": ArraySerializer(Serialization._StringSerializer).serialize(arg)]
                d[".tag"] = .str("filter_some")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            case .filterNone:
                var d = [String: JSON]()
                d[".tag"] = .str("filter_none")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> TemplateFilter {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "filter_some":
                    let v = try ArraySerializer(Serialization._StringSerializer).deserialize(d["filter_some"] ?? .null)
                    return TemplateFilter.filterSome(v)
                case "other":
                    return TemplateFilter.other
                case "filter_none":
                    return TemplateFilter.filterNone
                default:
                    throw JSONSerializerError.unknownTag(type: TemplateFilter.self, json: json, tag: tag)
                }
            default:
                throw JSONSerializerError.deserializeError(type: TemplateFilter.self, json: json)
            }
        }
    }

    /// The TemplateOwnerType union
    public enum TemplateOwnerType: CustomStringConvertible, JSONRepresentable {
        /// Template will be associated with a user.
        case user
        /// Template will be associated with a team.
        case team
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try TemplateOwnerTypeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TemplateOwnerTypeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TemplateOwnerType: \(error)"
            }
        }
    }

    public class TemplateOwnerTypeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TemplateOwnerType) throws -> JSON {
            switch value {
            case .user:
                var d = [String: JSON]()
                d[".tag"] = .str("user")
                return .dictionary(d)
            case .team:
                var d = [String: JSON]()
                d[".tag"] = .str("team")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> TemplateOwnerType {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "user":
                    return TemplateOwnerType.user
                case "team":
                    return TemplateOwnerType.team
                case "other":
                    return TemplateOwnerType.other
                default:
                    return TemplateOwnerType.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: TemplateOwnerType.self, json: json)
            }
        }
    }

    /// The UpdatePropertiesArg struct
    public class UpdatePropertiesArg: CustomStringConvertible, JSONRepresentable {
        /// A unique identifier for the file or folder.
        public let path: String
        /// The property groups "delta" updates to apply.
        public let updatePropertyGroups: [FileProperties.PropertyGroupUpdate]
        public init(path: String, updatePropertyGroups: [FileProperties.PropertyGroupUpdate]) {
            stringValidator(pattern: "/(.|[\\r\\n])*|id:.*|(ns:[0-9]+(/.*)?)")(path)
            self.path = path
            self.updatePropertyGroups = updatePropertyGroups
        }

        func json() throws -> JSON {
            try UpdatePropertiesArgSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try UpdatePropertiesArgSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for UpdatePropertiesArg: \(error)"
            }
        }
    }

    public class UpdatePropertiesArgSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: UpdatePropertiesArg) throws -> JSON {
            let output = [
                "path": try Serialization._StringSerializer.serialize(value.path),
                "update_property_groups": try ArraySerializer(FileProperties.PropertyGroupUpdateSerializer()).serialize(value.updatePropertyGroups),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> UpdatePropertiesArg {
            switch json {
            case .dictionary(let dict):
                let path = try Serialization._StringSerializer.deserialize(dict["path"] ?? .null)
                let updatePropertyGroups = try ArraySerializer(FileProperties.PropertyGroupUpdateSerializer())
                    .deserialize(dict["update_property_groups"] ?? .null)
                return UpdatePropertiesArg(path: path, updatePropertyGroups: updatePropertyGroups)
            default:
                throw JSONSerializerError.deserializeError(type: UpdatePropertiesArg.self, json: json)
            }
        }
    }

    /// The UpdatePropertiesError union
    public enum UpdatePropertiesError: CustomStringConvertible, JSONRepresentable {
        /// Template does not exist for the given identifier.
        case templateNotFound(String)
        /// You do not have permission to modify this template.
        case restrictedContent
        /// An unspecified error.
        case other
        /// An unspecified error.
        case path(FileProperties.LookupError)
        /// This folder cannot be tagged. Tagging folders is not supported for team-owned templates.
        case unsupportedFolder
        /// One or more of the supplied property field values is too large.
        case propertyFieldTooLarge
        /// One or more of the supplied property fields does not conform to the template specifications.
        case doesNotFitTemplate
        /// There are 2 or more property groups referring to the same templates in the input.
        case duplicatePropertyGroups
        /// An unspecified error.
        case propertyGroupLookup(FileProperties.LookUpPropertiesError)

        func json() throws -> JSON {
            try UpdatePropertiesErrorSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try UpdatePropertiesErrorSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for UpdatePropertiesError: \(error)"
            }
        }
    }

    public class UpdatePropertiesErrorSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: UpdatePropertiesError) throws -> JSON {
            switch value {
            case .templateNotFound(let arg):
                var d = try ["template_not_found": Serialization._StringSerializer.serialize(arg)]
                d[".tag"] = .str("template_not_found")
                return .dictionary(d)
            case .restrictedContent:
                var d = [String: JSON]()
                d[".tag"] = .str("restricted_content")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            case .path(let arg):
                var d = try ["path": FileProperties.LookupErrorSerializer().serialize(arg)]
                d[".tag"] = .str("path")
                return .dictionary(d)
            case .unsupportedFolder:
                var d = [String: JSON]()
                d[".tag"] = .str("unsupported_folder")
                return .dictionary(d)
            case .propertyFieldTooLarge:
                var d = [String: JSON]()
                d[".tag"] = .str("property_field_too_large")
                return .dictionary(d)
            case .doesNotFitTemplate:
                var d = [String: JSON]()
                d[".tag"] = .str("does_not_fit_template")
                return .dictionary(d)
            case .duplicatePropertyGroups:
                var d = [String: JSON]()
                d[".tag"] = .str("duplicate_property_groups")
                return .dictionary(d)
            case .propertyGroupLookup(let arg):
                var d = try ["property_group_lookup": FileProperties.LookUpPropertiesErrorSerializer().serialize(arg)]
                d[".tag"] = .str("property_group_lookup")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> UpdatePropertiesError {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "template_not_found":
                    let v = try Serialization._StringSerializer.deserialize(d["template_not_found"] ?? .null)
                    return UpdatePropertiesError.templateNotFound(v)
                case "restricted_content":
                    return UpdatePropertiesError.restrictedContent
                case "other":
                    return UpdatePropertiesError.other
                case "path":
                    let v = try FileProperties.LookupErrorSerializer().deserialize(d["path"] ?? .null)
                    return UpdatePropertiesError.path(v)
                case "unsupported_folder":
                    return UpdatePropertiesError.unsupportedFolder
                case "property_field_too_large":
                    return UpdatePropertiesError.propertyFieldTooLarge
                case "does_not_fit_template":
                    return UpdatePropertiesError.doesNotFitTemplate
                case "duplicate_property_groups":
                    return UpdatePropertiesError.duplicatePropertyGroups
                case "property_group_lookup":
                    let v = try FileProperties.LookUpPropertiesErrorSerializer().deserialize(d["property_group_lookup"] ?? .null)
                    return UpdatePropertiesError.propertyGroupLookup(v)
                default:
                    throw JSONSerializerError.unknownTag(type: UpdatePropertiesError.self, json: json, tag: tag)
                }
            default:
                throw JSONSerializerError.deserializeError(type: UpdatePropertiesError.self, json: json)
            }
        }
    }

    /// The UpdateTemplateArg struct
    public class UpdateTemplateArg: CustomStringConvertible, JSONRepresentable {
        /// An identifier for template added by  See templatesAddForUser or templatesAddForTeam.
        public let templateId: String
        /// A display name for the template. template names can be up to 256 bytes.
        public let name: String?
        /// Description for the new template. Template descriptions can be up to 1024 bytes.
        public let description_: String?
        /// Property field templates to be added to the group template. There can be up to 32 properties in a single
        /// template.
        public let addFields: [FileProperties.PropertyFieldTemplate]?
        public init(templateId: String, name: String? = nil, description_: String? = nil, addFields: [FileProperties.PropertyFieldTemplate]? = nil) {
            stringValidator(minLength: 1, pattern: "(/|ptid:).*")(templateId)
            self.templateId = templateId
            nullableValidator(stringValidator())(name)
            self.name = name
            nullableValidator(stringValidator())(description_)
            self.description_ = description_
            self.addFields = addFields
        }

        func json() throws -> JSON {
            try UpdateTemplateArgSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try UpdateTemplateArgSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for UpdateTemplateArg: \(error)"
            }
        }
    }

    public class UpdateTemplateArgSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: UpdateTemplateArg) throws -> JSON {
            let output = [
                "template_id": try Serialization._StringSerializer.serialize(value.templateId),
                "name": try NullableSerializer(Serialization._StringSerializer).serialize(value.name),
                "description": try NullableSerializer(Serialization._StringSerializer).serialize(value.description_),
                "add_fields": try NullableSerializer(ArraySerializer(FileProperties.PropertyFieldTemplateSerializer())).serialize(value.addFields),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> UpdateTemplateArg {
            switch json {
            case .dictionary(let dict):
                let templateId = try Serialization._StringSerializer.deserialize(dict["template_id"] ?? .null)
                let name = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["name"] ?? .null)
                let description_ = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["description"] ?? .null)
                let addFields = try NullableSerializer(ArraySerializer(FileProperties.PropertyFieldTemplateSerializer()))
                    .deserialize(dict["add_fields"] ?? .null)
                return UpdateTemplateArg(templateId: templateId, name: name, description_: description_, addFields: addFields)
            default:
                throw JSONSerializerError.deserializeError(type: UpdateTemplateArg.self, json: json)
            }
        }
    }

    /// The UpdateTemplateResult struct
    public class UpdateTemplateResult: CustomStringConvertible, JSONRepresentable {
        /// An identifier for template added by route  See templatesAddForUser or templatesAddForTeam.
        public let templateId: String
        public init(templateId: String) {
            stringValidator(minLength: 1, pattern: "(/|ptid:).*")(templateId)
            self.templateId = templateId
        }

        func json() throws -> JSON {
            try UpdateTemplateResultSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try UpdateTemplateResultSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for UpdateTemplateResult: \(error)"
            }
        }
    }

    public class UpdateTemplateResultSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: UpdateTemplateResult) throws -> JSON {
            let output = [
                "template_id": try Serialization._StringSerializer.serialize(value.templateId),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> UpdateTemplateResult {
            switch json {
            case .dictionary(let dict):
                let templateId = try Serialization._StringSerializer.deserialize(dict["template_id"] ?? .null)
                return UpdateTemplateResult(templateId: templateId)
            default:
                throw JSONSerializerError.deserializeError(type: UpdateTemplateResult.self, json: json)
            }
        }
    }

    /// Stone Route Objects

    static let propertiesAdd = Route(
        name: "properties/add",
        version: 1,
        namespace: "file_properties",
        deprecated: false,
        argSerializer: FileProperties.AddPropertiesArgSerializer(),
        responseSerializer: Serialization._VoidSerializer,
        errorSerializer: FileProperties.AddPropertiesErrorSerializer(),
        attributes: RouteAttributes(
            auth: [.user],
            host: .api,
            style: .rpc
        )
    )
    static let propertiesOverwrite = Route(
        name: "properties/overwrite",
        version: 1,
        namespace: "file_properties",
        deprecated: false,
        argSerializer: FileProperties.OverwritePropertyGroupArgSerializer(),
        responseSerializer: Serialization._VoidSerializer,
        errorSerializer: FileProperties.InvalidPropertyGroupErrorSerializer(),
        attributes: RouteAttributes(
            auth: [.user],
            host: .api,
            style: .rpc
        )
    )
    static let propertiesRemove = Route(
        name: "properties/remove",
        version: 1,
        namespace: "file_properties",
        deprecated: false,
        argSerializer: FileProperties.RemovePropertiesArgSerializer(),
        responseSerializer: Serialization._VoidSerializer,
        errorSerializer: FileProperties.RemovePropertiesErrorSerializer(),
        attributes: RouteAttributes(
            auth: [.user],
            host: .api,
            style: .rpc
        )
    )
    static let propertiesSearch = Route(
        name: "properties/search",
        version: 1,
        namespace: "file_properties",
        deprecated: false,
        argSerializer: FileProperties.PropertiesSearchArgSerializer(),
        responseSerializer: FileProperties.PropertiesSearchResultSerializer(),
        errorSerializer: FileProperties.PropertiesSearchErrorSerializer(),
        attributes: RouteAttributes(
            auth: [.user],
            host: .api,
            style: .rpc
        )
    )
    static let propertiesSearchContinue = Route(
        name: "properties/search/continue",
        version: 1,
        namespace: "file_properties",
        deprecated: false,
        argSerializer: FileProperties.PropertiesSearchContinueArgSerializer(),
        responseSerializer: FileProperties.PropertiesSearchResultSerializer(),
        errorSerializer: FileProperties.PropertiesSearchContinueErrorSerializer(),
        attributes: RouteAttributes(
            auth: [.user],
            host: .api,
            style: .rpc
        )
    )
    static let propertiesUpdate = Route(
        name: "properties/update",
        version: 1,
        namespace: "file_properties",
        deprecated: false,
        argSerializer: FileProperties.UpdatePropertiesArgSerializer(),
        responseSerializer: Serialization._VoidSerializer,
        errorSerializer: FileProperties.UpdatePropertiesErrorSerializer(),
        attributes: RouteAttributes(
            auth: [.user],
            host: .api,
            style: .rpc
        )
    )
    static let templatesAddForTeam = Route(
        name: "templates/add_for_team",
        version: 1,
        namespace: "file_properties",
        deprecated: false,
        argSerializer: FileProperties.AddTemplateArgSerializer(),
        responseSerializer: FileProperties.AddTemplateResultSerializer(),
        errorSerializer: FileProperties.ModifyTemplateErrorSerializer(),
        attributes: RouteAttributes(
            auth: [.team],
            host: .api,
            style: .rpc
        )
    )
    static let templatesAddForUser = Route(
        name: "templates/add_for_user",
        version: 1,
        namespace: "file_properties",
        deprecated: false,
        argSerializer: FileProperties.AddTemplateArgSerializer(),
        responseSerializer: FileProperties.AddTemplateResultSerializer(),
        errorSerializer: FileProperties.ModifyTemplateErrorSerializer(),
        attributes: RouteAttributes(
            auth: [.user],
            host: .api,
            style: .rpc
        )
    )
    static let templatesGetForTeam = Route(
        name: "templates/get_for_team",
        version: 1,
        namespace: "file_properties",
        deprecated: false,
        argSerializer: FileProperties.GetTemplateArgSerializer(),
        responseSerializer: FileProperties.GetTemplateResultSerializer(),
        errorSerializer: FileProperties.TemplateErrorSerializer(),
        attributes: RouteAttributes(
            auth: [.team],
            host: .api,
            style: .rpc
        )
    )
    static let templatesGetForUser = Route(
        name: "templates/get_for_user",
        version: 1,
        namespace: "file_properties",
        deprecated: false,
        argSerializer: FileProperties.GetTemplateArgSerializer(),
        responseSerializer: FileProperties.GetTemplateResultSerializer(),
        errorSerializer: FileProperties.TemplateErrorSerializer(),
        attributes: RouteAttributes(
            auth: [.user],
            host: .api,
            style: .rpc
        )
    )
    static let templatesListForTeam = Route(
        name: "templates/list_for_team",
        version: 1,
        namespace: "file_properties",
        deprecated: false,
        argSerializer: Serialization._VoidSerializer,
        responseSerializer: FileProperties.ListTemplateResultSerializer(),
        errorSerializer: FileProperties.TemplateErrorSerializer(),
        attributes: RouteAttributes(
            auth: [.team],
            host: .api,
            style: .rpc
        )
    )
    static let templatesListForUser = Route(
        name: "templates/list_for_user",
        version: 1,
        namespace: "file_properties",
        deprecated: false,
        argSerializer: Serialization._VoidSerializer,
        responseSerializer: FileProperties.ListTemplateResultSerializer(),
        errorSerializer: FileProperties.TemplateErrorSerializer(),
        attributes: RouteAttributes(
            auth: [.user],
            host: .api,
            style: .rpc
        )
    )
    static let templatesRemoveForTeam = Route(
        name: "templates/remove_for_team",
        version: 1,
        namespace: "file_properties",
        deprecated: false,
        argSerializer: FileProperties.RemoveTemplateArgSerializer(),
        responseSerializer: Serialization._VoidSerializer,
        errorSerializer: FileProperties.TemplateErrorSerializer(),
        attributes: RouteAttributes(
            auth: [.team],
            host: .api,
            style: .rpc
        )
    )
    static let templatesRemoveForUser = Route(
        name: "templates/remove_for_user",
        version: 1,
        namespace: "file_properties",
        deprecated: false,
        argSerializer: FileProperties.RemoveTemplateArgSerializer(),
        responseSerializer: Serialization._VoidSerializer,
        errorSerializer: FileProperties.TemplateErrorSerializer(),
        attributes: RouteAttributes(
            auth: [.user],
            host: .api,
            style: .rpc
        )
    )
    static let templatesUpdateForTeam = Route(
        name: "templates/update_for_team",
        version: 1,
        namespace: "file_properties",
        deprecated: false,
        argSerializer: FileProperties.UpdateTemplateArgSerializer(),
        responseSerializer: FileProperties.UpdateTemplateResultSerializer(),
        errorSerializer: FileProperties.ModifyTemplateErrorSerializer(),
        attributes: RouteAttributes(
            auth: [.team],
            host: .api,
            style: .rpc
        )
    )
    static let templatesUpdateForUser = Route(
        name: "templates/update_for_user",
        version: 1,
        namespace: "file_properties",
        deprecated: false,
        argSerializer: FileProperties.UpdateTemplateArgSerializer(),
        responseSerializer: FileProperties.UpdateTemplateResultSerializer(),
        errorSerializer: FileProperties.ModifyTemplateErrorSerializer(),
        attributes: RouteAttributes(
            auth: [.user],
            host: .api,
            style: .rpc
        )
    )
}
