///
/// Copyright (c) 2016 Dropbox, Inc. All rights reserved.
///
/// Auto-generated by Stone, do not modify.
///

import Foundation

/// Datatypes and serializers for the file_requests namespace
public class FileRequests {
    /// There is an error accessing the file requests functionality.
    public enum GeneralFileRequestsError: CustomStringConvertible, JSONRepresentable {
        /// This user's Dropbox Business team doesn't allow file requests.
        case disabledForTeam
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try GeneralFileRequestsErrorSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try GeneralFileRequestsErrorSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for GeneralFileRequestsError: \(error)"
            }
        }
    }

    public class GeneralFileRequestsErrorSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: GeneralFileRequestsError) throws -> JSON {
            switch value {
            case .disabledForTeam:
                var d = [String: JSON]()
                d[".tag"] = .str("disabled_for_team")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> GeneralFileRequestsError {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "disabled_for_team":
                    return GeneralFileRequestsError.disabledForTeam
                case "other":
                    return GeneralFileRequestsError.other
                default:
                    return GeneralFileRequestsError.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: GeneralFileRequestsError.self, json: json)
            }
        }
    }

    /// There was an error counting the file requests.
    public enum CountFileRequestsError: CustomStringConvertible, JSONRepresentable {
        /// This user's Dropbox Business team doesn't allow file requests.
        case disabledForTeam
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try CountFileRequestsErrorSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try CountFileRequestsErrorSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for CountFileRequestsError: \(error)"
            }
        }
    }

    public class CountFileRequestsErrorSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: CountFileRequestsError) throws -> JSON {
            switch value {
            case .disabledForTeam:
                var d = [String: JSON]()
                d[".tag"] = .str("disabled_for_team")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> CountFileRequestsError {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "disabled_for_team":
                    return CountFileRequestsError.disabledForTeam
                case "other":
                    return CountFileRequestsError.other
                default:
                    throw JSONSerializerError.unknownTag(type: CountFileRequestsError.self, json: json, tag: tag)
                }
            default:
                throw JSONSerializerError.deserializeError(type: CountFileRequestsError.self, json: json)
            }
        }
    }

    /// Result for count.
    public class CountFileRequestsResult: CustomStringConvertible, JSONRepresentable {
        /// The number file requests owner by this user.
        public let fileRequestCount: UInt64
        public init(fileRequestCount: UInt64) {
            comparableValidator()(fileRequestCount)
            self.fileRequestCount = fileRequestCount
        }

        func json() throws -> JSON {
            try CountFileRequestsResultSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try CountFileRequestsResultSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for CountFileRequestsResult: \(error)"
            }
        }
    }

    public class CountFileRequestsResultSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: CountFileRequestsResult) throws -> JSON {
            let output = [
                "file_request_count": try Serialization._UInt64Serializer.serialize(value.fileRequestCount),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> CountFileRequestsResult {
            switch json {
            case .dictionary(let dict):
                let fileRequestCount = try Serialization._UInt64Serializer.deserialize(dict["file_request_count"] ?? .null)
                return CountFileRequestsResult(fileRequestCount: fileRequestCount)
            default:
                throw JSONSerializerError.deserializeError(type: CountFileRequestsResult.self, json: json)
            }
        }
    }

    /// Arguments for create.
    public class CreateFileRequestArgs: CustomStringConvertible, JSONRepresentable {
        /// The title of the file request. Must not be empty.
        public let title: String
        /// The path of the folder in the Dropbox where uploaded files will be sent. For apps with the app folder
        /// permission, this will be relative to the app folder.
        public let destination: String
        /// The deadline for the file request. Deadlines can only be set by Professional and Business accounts.
        public let deadline: FileRequests.FileRequestDeadline?
        /// Whether or not the file request should be open. If the file request is closed, it will not accept any file
        /// submissions, but it can be opened later.
        public let open: Bool
        /// A description of the file request.
        public let description_: String?
        public init(title: String, destination: String, deadline: FileRequests.FileRequestDeadline? = nil, open: Bool = true, description_: String? = nil) {
            stringValidator(minLength: 1)(title)
            self.title = title
            stringValidator(pattern: "/(.|[\\r\\n])*")(destination)
            self.destination = destination
            self.deadline = deadline
            self.open = open
            nullableValidator(stringValidator())(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try CreateFileRequestArgsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try CreateFileRequestArgsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for CreateFileRequestArgs: \(error)"
            }
        }
    }

    public class CreateFileRequestArgsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: CreateFileRequestArgs) throws -> JSON {
            let output = [
                "title": try Serialization._StringSerializer.serialize(value.title),
                "destination": try Serialization._StringSerializer.serialize(value.destination),
                "deadline": try NullableSerializer(FileRequests.FileRequestDeadlineSerializer()).serialize(value.deadline),
                "open": try Serialization._BoolSerializer.serialize(value.open),
                "description": try NullableSerializer(Serialization._StringSerializer).serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> CreateFileRequestArgs {
            switch json {
            case .dictionary(let dict):
                let title = try Serialization._StringSerializer.deserialize(dict["title"] ?? .null)
                let destination = try Serialization._StringSerializer.deserialize(dict["destination"] ?? .null)
                let deadline = try NullableSerializer(FileRequests.FileRequestDeadlineSerializer()).deserialize(dict["deadline"] ?? .null)
                let open = try Serialization._BoolSerializer.deserialize(dict["open"] ?? .number(1))
                let description_ = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["description"] ?? .null)
                return CreateFileRequestArgs(title: title, destination: destination, deadline: deadline, open: open, description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: CreateFileRequestArgs.self, json: json)
            }
        }
    }

    /// There is an error with the file request.
    public enum FileRequestError: CustomStringConvertible, JSONRepresentable {
        /// This user's Dropbox Business team doesn't allow file requests.
        case disabledForTeam
        /// An unspecified error.
        case other
        /// This file request ID was not found.
        case notFound
        /// The specified path is not a folder.
        case notAFolder
        /// This file request is not accessible to this app. Apps with the app folder permission can only access file
        /// requests in their app folder.
        case appLacksAccess
        /// This user doesn't have permission to access or modify this file request.
        case noPermission
        /// This user's email address is not verified. File requests are only available on accounts with a verified
        /// email address. Users can verify their email address here https://www.dropbox.com/help/317.
        case emailUnverified
        /// There was an error validating the request. For example, the title was invalid, or there were disallowed
        /// characters in the destination path.
        case validationError

        func json() throws -> JSON {
            try FileRequestErrorSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try FileRequestErrorSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for FileRequestError: \(error)"
            }
        }
    }

    public class FileRequestErrorSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: FileRequestError) throws -> JSON {
            switch value {
            case .disabledForTeam:
                var d = [String: JSON]()
                d[".tag"] = .str("disabled_for_team")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            case .notFound:
                var d = [String: JSON]()
                d[".tag"] = .str("not_found")
                return .dictionary(d)
            case .notAFolder:
                var d = [String: JSON]()
                d[".tag"] = .str("not_a_folder")
                return .dictionary(d)
            case .appLacksAccess:
                var d = [String: JSON]()
                d[".tag"] = .str("app_lacks_access")
                return .dictionary(d)
            case .noPermission:
                var d = [String: JSON]()
                d[".tag"] = .str("no_permission")
                return .dictionary(d)
            case .emailUnverified:
                var d = [String: JSON]()
                d[".tag"] = .str("email_unverified")
                return .dictionary(d)
            case .validationError:
                var d = [String: JSON]()
                d[".tag"] = .str("validation_error")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> FileRequestError {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "disabled_for_team":
                    return FileRequestError.disabledForTeam
                case "other":
                    return FileRequestError.other
                case "not_found":
                    return FileRequestError.notFound
                case "not_a_folder":
                    return FileRequestError.notAFolder
                case "app_lacks_access":
                    return FileRequestError.appLacksAccess
                case "no_permission":
                    return FileRequestError.noPermission
                case "email_unverified":
                    return FileRequestError.emailUnverified
                case "validation_error":
                    return FileRequestError.validationError
                default:
                    throw JSONSerializerError.unknownTag(type: FileRequestError.self, json: json, tag: tag)
                }
            default:
                throw JSONSerializerError.deserializeError(type: FileRequestError.self, json: json)
            }
        }
    }

    /// There was an error creating the file request.
    public enum CreateFileRequestError: CustomStringConvertible, JSONRepresentable {
        /// This user's Dropbox Business team doesn't allow file requests.
        case disabledForTeam
        /// An unspecified error.
        case other
        /// This file request ID was not found.
        case notFound
        /// The specified path is not a folder.
        case notAFolder
        /// This file request is not accessible to this app. Apps with the app folder permission can only access file
        /// requests in their app folder.
        case appLacksAccess
        /// This user doesn't have permission to access or modify this file request.
        case noPermission
        /// This user's email address is not verified. File requests are only available on accounts with a verified
        /// email address. Users can verify their email address here https://www.dropbox.com/help/317.
        case emailUnverified
        /// There was an error validating the request. For example, the title was invalid, or there were disallowed
        /// characters in the destination path.
        case validationError
        /// File requests are not available on the specified folder.
        case invalidLocation
        /// The user has reached the rate limit for creating file requests. The limit is currently 4000 file requests
        /// total.
        case rateLimit

        func json() throws -> JSON {
            try CreateFileRequestErrorSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try CreateFileRequestErrorSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for CreateFileRequestError: \(error)"
            }
        }
    }

    public class CreateFileRequestErrorSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: CreateFileRequestError) throws -> JSON {
            switch value {
            case .disabledForTeam:
                var d = [String: JSON]()
                d[".tag"] = .str("disabled_for_team")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            case .notFound:
                var d = [String: JSON]()
                d[".tag"] = .str("not_found")
                return .dictionary(d)
            case .notAFolder:
                var d = [String: JSON]()
                d[".tag"] = .str("not_a_folder")
                return .dictionary(d)
            case .appLacksAccess:
                var d = [String: JSON]()
                d[".tag"] = .str("app_lacks_access")
                return .dictionary(d)
            case .noPermission:
                var d = [String: JSON]()
                d[".tag"] = .str("no_permission")
                return .dictionary(d)
            case .emailUnverified:
                var d = [String: JSON]()
                d[".tag"] = .str("email_unverified")
                return .dictionary(d)
            case .validationError:
                var d = [String: JSON]()
                d[".tag"] = .str("validation_error")
                return .dictionary(d)
            case .invalidLocation:
                var d = [String: JSON]()
                d[".tag"] = .str("invalid_location")
                return .dictionary(d)
            case .rateLimit:
                var d = [String: JSON]()
                d[".tag"] = .str("rate_limit")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> CreateFileRequestError {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "disabled_for_team":
                    return CreateFileRequestError.disabledForTeam
                case "other":
                    return CreateFileRequestError.other
                case "not_found":
                    return CreateFileRequestError.notFound
                case "not_a_folder":
                    return CreateFileRequestError.notAFolder
                case "app_lacks_access":
                    return CreateFileRequestError.appLacksAccess
                case "no_permission":
                    return CreateFileRequestError.noPermission
                case "email_unverified":
                    return CreateFileRequestError.emailUnverified
                case "validation_error":
                    return CreateFileRequestError.validationError
                case "invalid_location":
                    return CreateFileRequestError.invalidLocation
                case "rate_limit":
                    return CreateFileRequestError.rateLimit
                default:
                    throw JSONSerializerError.unknownTag(type: CreateFileRequestError.self, json: json, tag: tag)
                }
            default:
                throw JSONSerializerError.deserializeError(type: CreateFileRequestError.self, json: json)
            }
        }
    }

    /// There was an error deleting all closed file requests.
    public enum DeleteAllClosedFileRequestsError: CustomStringConvertible, JSONRepresentable {
        /// This user's Dropbox Business team doesn't allow file requests.
        case disabledForTeam
        /// An unspecified error.
        case other
        /// This file request ID was not found.
        case notFound
        /// The specified path is not a folder.
        case notAFolder
        /// This file request is not accessible to this app. Apps with the app folder permission can only access file
        /// requests in their app folder.
        case appLacksAccess
        /// This user doesn't have permission to access or modify this file request.
        case noPermission
        /// This user's email address is not verified. File requests are only available on accounts with a verified
        /// email address. Users can verify their email address here https://www.dropbox.com/help/317.
        case emailUnverified
        /// There was an error validating the request. For example, the title was invalid, or there were disallowed
        /// characters in the destination path.
        case validationError

        func json() throws -> JSON {
            try DeleteAllClosedFileRequestsErrorSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try DeleteAllClosedFileRequestsErrorSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for DeleteAllClosedFileRequestsError: \(error)"
            }
        }
    }

    public class DeleteAllClosedFileRequestsErrorSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: DeleteAllClosedFileRequestsError) throws -> JSON {
            switch value {
            case .disabledForTeam:
                var d = [String: JSON]()
                d[".tag"] = .str("disabled_for_team")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            case .notFound:
                var d = [String: JSON]()
                d[".tag"] = .str("not_found")
                return .dictionary(d)
            case .notAFolder:
                var d = [String: JSON]()
                d[".tag"] = .str("not_a_folder")
                return .dictionary(d)
            case .appLacksAccess:
                var d = [String: JSON]()
                d[".tag"] = .str("app_lacks_access")
                return .dictionary(d)
            case .noPermission:
                var d = [String: JSON]()
                d[".tag"] = .str("no_permission")
                return .dictionary(d)
            case .emailUnverified:
                var d = [String: JSON]()
                d[".tag"] = .str("email_unverified")
                return .dictionary(d)
            case .validationError:
                var d = [String: JSON]()
                d[".tag"] = .str("validation_error")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> DeleteAllClosedFileRequestsError {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "disabled_for_team":
                    return DeleteAllClosedFileRequestsError.disabledForTeam
                case "other":
                    return DeleteAllClosedFileRequestsError.other
                case "not_found":
                    return DeleteAllClosedFileRequestsError.notFound
                case "not_a_folder":
                    return DeleteAllClosedFileRequestsError.notAFolder
                case "app_lacks_access":
                    return DeleteAllClosedFileRequestsError.appLacksAccess
                case "no_permission":
                    return DeleteAllClosedFileRequestsError.noPermission
                case "email_unverified":
                    return DeleteAllClosedFileRequestsError.emailUnverified
                case "validation_error":
                    return DeleteAllClosedFileRequestsError.validationError
                default:
                    throw JSONSerializerError.unknownTag(type: DeleteAllClosedFileRequestsError.self, json: json, tag: tag)
                }
            default:
                throw JSONSerializerError.deserializeError(type: DeleteAllClosedFileRequestsError.self, json: json)
            }
        }
    }

    /// Result for deleteAllClosed.
    public class DeleteAllClosedFileRequestsResult: CustomStringConvertible, JSONRepresentable {
        /// The file requests deleted for this user.
        public let fileRequests: [FileRequests.FileRequest]
        public init(fileRequests: [FileRequests.FileRequest]) {
            self.fileRequests = fileRequests
        }

        func json() throws -> JSON {
            try DeleteAllClosedFileRequestsResultSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try DeleteAllClosedFileRequestsResultSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for DeleteAllClosedFileRequestsResult: \(error)"
            }
        }
    }

    public class DeleteAllClosedFileRequestsResultSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: DeleteAllClosedFileRequestsResult) throws -> JSON {
            let output = [
                "file_requests": try ArraySerializer(FileRequests.FileRequestSerializer()).serialize(value.fileRequests),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> DeleteAllClosedFileRequestsResult {
            switch json {
            case .dictionary(let dict):
                let fileRequests = try ArraySerializer(FileRequests.FileRequestSerializer()).deserialize(dict["file_requests"] ?? .null)
                return DeleteAllClosedFileRequestsResult(fileRequests: fileRequests)
            default:
                throw JSONSerializerError.deserializeError(type: DeleteAllClosedFileRequestsResult.self, json: json)
            }
        }
    }

    /// Arguments for delete.
    public class DeleteFileRequestArgs: CustomStringConvertible, JSONRepresentable {
        /// List IDs of the file requests to delete.
        public let ids: [String]
        public init(ids: [String]) {
            arrayValidator(itemValidator: stringValidator(minLength: 1, pattern: "[-_0-9a-zA-Z]+"))(ids)
            self.ids = ids
        }

        func json() throws -> JSON {
            try DeleteFileRequestArgsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try DeleteFileRequestArgsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for DeleteFileRequestArgs: \(error)"
            }
        }
    }

    public class DeleteFileRequestArgsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: DeleteFileRequestArgs) throws -> JSON {
            let output = [
                "ids": try ArraySerializer(Serialization._StringSerializer).serialize(value.ids),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> DeleteFileRequestArgs {
            switch json {
            case .dictionary(let dict):
                let ids = try ArraySerializer(Serialization._StringSerializer).deserialize(dict["ids"] ?? .null)
                return DeleteFileRequestArgs(ids: ids)
            default:
                throw JSONSerializerError.deserializeError(type: DeleteFileRequestArgs.self, json: json)
            }
        }
    }

    /// There was an error deleting these file requests.
    public enum DeleteFileRequestError: CustomStringConvertible, JSONRepresentable {
        /// This user's Dropbox Business team doesn't allow file requests.
        case disabledForTeam
        /// An unspecified error.
        case other
        /// This file request ID was not found.
        case notFound
        /// The specified path is not a folder.
        case notAFolder
        /// This file request is not accessible to this app. Apps with the app folder permission can only access file
        /// requests in their app folder.
        case appLacksAccess
        /// This user doesn't have permission to access or modify this file request.
        case noPermission
        /// This user's email address is not verified. File requests are only available on accounts with a verified
        /// email address. Users can verify their email address here https://www.dropbox.com/help/317.
        case emailUnverified
        /// There was an error validating the request. For example, the title was invalid, or there were disallowed
        /// characters in the destination path.
        case validationError
        /// One or more file requests currently open.
        case fileRequestOpen

        func json() throws -> JSON {
            try DeleteFileRequestErrorSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try DeleteFileRequestErrorSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for DeleteFileRequestError: \(error)"
            }
        }
    }

    public class DeleteFileRequestErrorSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: DeleteFileRequestError) throws -> JSON {
            switch value {
            case .disabledForTeam:
                var d = [String: JSON]()
                d[".tag"] = .str("disabled_for_team")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            case .notFound:
                var d = [String: JSON]()
                d[".tag"] = .str("not_found")
                return .dictionary(d)
            case .notAFolder:
                var d = [String: JSON]()
                d[".tag"] = .str("not_a_folder")
                return .dictionary(d)
            case .appLacksAccess:
                var d = [String: JSON]()
                d[".tag"] = .str("app_lacks_access")
                return .dictionary(d)
            case .noPermission:
                var d = [String: JSON]()
                d[".tag"] = .str("no_permission")
                return .dictionary(d)
            case .emailUnverified:
                var d = [String: JSON]()
                d[".tag"] = .str("email_unverified")
                return .dictionary(d)
            case .validationError:
                var d = [String: JSON]()
                d[".tag"] = .str("validation_error")
                return .dictionary(d)
            case .fileRequestOpen:
                var d = [String: JSON]()
                d[".tag"] = .str("file_request_open")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> DeleteFileRequestError {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "disabled_for_team":
                    return DeleteFileRequestError.disabledForTeam
                case "other":
                    return DeleteFileRequestError.other
                case "not_found":
                    return DeleteFileRequestError.notFound
                case "not_a_folder":
                    return DeleteFileRequestError.notAFolder
                case "app_lacks_access":
                    return DeleteFileRequestError.appLacksAccess
                case "no_permission":
                    return DeleteFileRequestError.noPermission
                case "email_unverified":
                    return DeleteFileRequestError.emailUnverified
                case "validation_error":
                    return DeleteFileRequestError.validationError
                case "file_request_open":
                    return DeleteFileRequestError.fileRequestOpen
                default:
                    throw JSONSerializerError.unknownTag(type: DeleteFileRequestError.self, json: json, tag: tag)
                }
            default:
                throw JSONSerializerError.deserializeError(type: DeleteFileRequestError.self, json: json)
            }
        }
    }

    /// Result for delete.
    public class DeleteFileRequestsResult: CustomStringConvertible, JSONRepresentable {
        /// The file requests deleted by the request.
        public let fileRequests: [FileRequests.FileRequest]
        public init(fileRequests: [FileRequests.FileRequest]) {
            self.fileRequests = fileRequests
        }

        func json() throws -> JSON {
            try DeleteFileRequestsResultSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try DeleteFileRequestsResultSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for DeleteFileRequestsResult: \(error)"
            }
        }
    }

    public class DeleteFileRequestsResultSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: DeleteFileRequestsResult) throws -> JSON {
            let output = [
                "file_requests": try ArraySerializer(FileRequests.FileRequestSerializer()).serialize(value.fileRequests),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> DeleteFileRequestsResult {
            switch json {
            case .dictionary(let dict):
                let fileRequests = try ArraySerializer(FileRequests.FileRequestSerializer()).deserialize(dict["file_requests"] ?? .null)
                return DeleteFileRequestsResult(fileRequests: fileRequests)
            default:
                throw JSONSerializerError.deserializeError(type: DeleteFileRequestsResult.self, json: json)
            }
        }
    }

    /// A file request https://www.dropbox.com/help/9090 for receiving files into the user's Dropbox account.
    public class FileRequest: CustomStringConvertible, JSONRepresentable {
        /// The ID of the file request.
        public let id: String
        /// The URL of the file request.
        public let url: String
        /// The title of the file request.
        public let title: String
        /// The path of the folder in the Dropbox where uploaded files will be sent. This can be null if the destination
        /// was removed. For apps with the app folder permission, this will be relative to the app folder.
        public let destination: String?
        /// When this file request was created.
        public let created: Date
        /// The deadline for this file request. Only set if the request has a deadline.
        public let deadline: FileRequests.FileRequestDeadline?
        /// Whether or not the file request is open. If the file request is closed, it will not accept any more file
        /// submissions.
        public let isOpen: Bool
        /// The number of files this file request has received.
        public let fileCount: Int64
        /// A description of the file request.
        public let description_: String?
        public init(
            id: String,
            url: String,
            title: String,
            created: Date,
            isOpen: Bool,
            fileCount: Int64,
            destination: String? = nil,
            deadline: FileRequests.FileRequestDeadline? = nil,
            description_: String? = nil
        ) {
            stringValidator(minLength: 1, pattern: "[-_0-9a-zA-Z]+")(id)
            self.id = id
            stringValidator(minLength: 1)(url)
            self.url = url
            stringValidator(minLength: 1)(title)
            self.title = title
            nullableValidator(stringValidator(pattern: "/(.|[\\r\\n])*"))(destination)
            self.destination = destination
            self.created = created
            self.deadline = deadline
            self.isOpen = isOpen
            comparableValidator()(fileCount)
            self.fileCount = fileCount
            nullableValidator(stringValidator())(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try FileRequestSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try FileRequestSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for FileRequest: \(error)"
            }
        }
    }

    public class FileRequestSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: FileRequest) throws -> JSON {
            let output = [
                "id": try Serialization._StringSerializer.serialize(value.id),
                "url": try Serialization._StringSerializer.serialize(value.url),
                "title": try Serialization._StringSerializer.serialize(value.title),
                "created": try NSDateSerializer("%Y-%m-%dT%H:%M:%SZ").serialize(value.created),
                "is_open": try Serialization._BoolSerializer.serialize(value.isOpen),
                "file_count": try Serialization._Int64Serializer.serialize(value.fileCount),
                "destination": try NullableSerializer(Serialization._StringSerializer).serialize(value.destination),
                "deadline": try NullableSerializer(FileRequests.FileRequestDeadlineSerializer()).serialize(value.deadline),
                "description": try NullableSerializer(Serialization._StringSerializer).serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> FileRequest {
            switch json {
            case .dictionary(let dict):
                let id = try Serialization._StringSerializer.deserialize(dict["id"] ?? .null)
                let url = try Serialization._StringSerializer.deserialize(dict["url"] ?? .null)
                let title = try Serialization._StringSerializer.deserialize(dict["title"] ?? .null)
                let created = try NSDateSerializer("%Y-%m-%dT%H:%M:%SZ").deserialize(dict["created"] ?? .null)
                let isOpen = try Serialization._BoolSerializer.deserialize(dict["is_open"] ?? .null)
                let fileCount = try Serialization._Int64Serializer.deserialize(dict["file_count"] ?? .null)
                let destination = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["destination"] ?? .null)
                let deadline = try NullableSerializer(FileRequests.FileRequestDeadlineSerializer()).deserialize(dict["deadline"] ?? .null)
                let description_ = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["description"] ?? .null)
                return FileRequest(
                    id: id,
                    url: url,
                    title: title,
                    created: created,
                    isOpen: isOpen,
                    fileCount: fileCount,
                    destination: destination,
                    deadline: deadline,
                    description_: description_
                )
            default:
                throw JSONSerializerError.deserializeError(type: FileRequest.self, json: json)
            }
        }
    }

    /// The FileRequestDeadline struct
    public class FileRequestDeadline: CustomStringConvertible, JSONRepresentable {
        /// The deadline for this file request.
        public let deadline: Date
        /// If set, allow uploads after the deadline has passed. These     uploads will be marked overdue.
        public let allowLateUploads: FileRequests.GracePeriod?
        public init(deadline: Date, allowLateUploads: FileRequests.GracePeriod? = nil) {
            self.deadline = deadline
            self.allowLateUploads = allowLateUploads
        }

        func json() throws -> JSON {
            try FileRequestDeadlineSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try FileRequestDeadlineSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for FileRequestDeadline: \(error)"
            }
        }
    }

    public class FileRequestDeadlineSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: FileRequestDeadline) throws -> JSON {
            let output = [
                "deadline": try NSDateSerializer("%Y-%m-%dT%H:%M:%SZ").serialize(value.deadline),
                "allow_late_uploads": try NullableSerializer(FileRequests.GracePeriodSerializer()).serialize(value.allowLateUploads),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> FileRequestDeadline {
            switch json {
            case .dictionary(let dict):
                let deadline = try NSDateSerializer("%Y-%m-%dT%H:%M:%SZ").deserialize(dict["deadline"] ?? .null)
                let allowLateUploads = try NullableSerializer(FileRequests.GracePeriodSerializer()).deserialize(dict["allow_late_uploads"] ?? .null)
                return FileRequestDeadline(deadline: deadline, allowLateUploads: allowLateUploads)
            default:
                throw JSONSerializerError.deserializeError(type: FileRequestDeadline.self, json: json)
            }
        }
    }

    /// Arguments for get.
    public class GetFileRequestArgs: CustomStringConvertible, JSONRepresentable {
        /// The ID of the file request to retrieve.
        public let id: String
        public init(id: String) {
            stringValidator(minLength: 1, pattern: "[-_0-9a-zA-Z]+")(id)
            self.id = id
        }

        func json() throws -> JSON {
            try GetFileRequestArgsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try GetFileRequestArgsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for GetFileRequestArgs: \(error)"
            }
        }
    }

    public class GetFileRequestArgsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: GetFileRequestArgs) throws -> JSON {
            let output = [
                "id": try Serialization._StringSerializer.serialize(value.id),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> GetFileRequestArgs {
            switch json {
            case .dictionary(let dict):
                let id = try Serialization._StringSerializer.deserialize(dict["id"] ?? .null)
                return GetFileRequestArgs(id: id)
            default:
                throw JSONSerializerError.deserializeError(type: GetFileRequestArgs.self, json: json)
            }
        }
    }

    /// There was an error retrieving the specified file request.
    public enum GetFileRequestError: CustomStringConvertible, JSONRepresentable {
        /// This user's Dropbox Business team doesn't allow file requests.
        case disabledForTeam
        /// An unspecified error.
        case other
        /// This file request ID was not found.
        case notFound
        /// The specified path is not a folder.
        case notAFolder
        /// This file request is not accessible to this app. Apps with the app folder permission can only access file
        /// requests in their app folder.
        case appLacksAccess
        /// This user doesn't have permission to access or modify this file request.
        case noPermission
        /// This user's email address is not verified. File requests are only available on accounts with a verified
        /// email address. Users can verify their email address here https://www.dropbox.com/help/317.
        case emailUnverified
        /// There was an error validating the request. For example, the title was invalid, or there were disallowed
        /// characters in the destination path.
        case validationError

        func json() throws -> JSON {
            try GetFileRequestErrorSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try GetFileRequestErrorSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for GetFileRequestError: \(error)"
            }
        }
    }

    public class GetFileRequestErrorSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: GetFileRequestError) throws -> JSON {
            switch value {
            case .disabledForTeam:
                var d = [String: JSON]()
                d[".tag"] = .str("disabled_for_team")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            case .notFound:
                var d = [String: JSON]()
                d[".tag"] = .str("not_found")
                return .dictionary(d)
            case .notAFolder:
                var d = [String: JSON]()
                d[".tag"] = .str("not_a_folder")
                return .dictionary(d)
            case .appLacksAccess:
                var d = [String: JSON]()
                d[".tag"] = .str("app_lacks_access")
                return .dictionary(d)
            case .noPermission:
                var d = [String: JSON]()
                d[".tag"] = .str("no_permission")
                return .dictionary(d)
            case .emailUnverified:
                var d = [String: JSON]()
                d[".tag"] = .str("email_unverified")
                return .dictionary(d)
            case .validationError:
                var d = [String: JSON]()
                d[".tag"] = .str("validation_error")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> GetFileRequestError {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "disabled_for_team":
                    return GetFileRequestError.disabledForTeam
                case "other":
                    return GetFileRequestError.other
                case "not_found":
                    return GetFileRequestError.notFound
                case "not_a_folder":
                    return GetFileRequestError.notAFolder
                case "app_lacks_access":
                    return GetFileRequestError.appLacksAccess
                case "no_permission":
                    return GetFileRequestError.noPermission
                case "email_unverified":
                    return GetFileRequestError.emailUnverified
                case "validation_error":
                    return GetFileRequestError.validationError
                default:
                    throw JSONSerializerError.unknownTag(type: GetFileRequestError.self, json: json, tag: tag)
                }
            default:
                throw JSONSerializerError.deserializeError(type: GetFileRequestError.self, json: json)
            }
        }
    }

    /// The GracePeriod union
    public enum GracePeriod: CustomStringConvertible, JSONRepresentable {
        /// An unspecified error.
        case oneDay
        /// An unspecified error.
        case twoDays
        /// An unspecified error.
        case sevenDays
        /// An unspecified error.
        case thirtyDays
        /// An unspecified error.
        case always
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try GracePeriodSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try GracePeriodSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for GracePeriod: \(error)"
            }
        }
    }

    public class GracePeriodSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: GracePeriod) throws -> JSON {
            switch value {
            case .oneDay:
                var d = [String: JSON]()
                d[".tag"] = .str("one_day")
                return .dictionary(d)
            case .twoDays:
                var d = [String: JSON]()
                d[".tag"] = .str("two_days")
                return .dictionary(d)
            case .sevenDays:
                var d = [String: JSON]()
                d[".tag"] = .str("seven_days")
                return .dictionary(d)
            case .thirtyDays:
                var d = [String: JSON]()
                d[".tag"] = .str("thirty_days")
                return .dictionary(d)
            case .always:
                var d = [String: JSON]()
                d[".tag"] = .str("always")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> GracePeriod {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "one_day":
                    return GracePeriod.oneDay
                case "two_days":
                    return GracePeriod.twoDays
                case "seven_days":
                    return GracePeriod.sevenDays
                case "thirty_days":
                    return GracePeriod.thirtyDays
                case "always":
                    return GracePeriod.always
                case "other":
                    return GracePeriod.other
                default:
                    return GracePeriod.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: GracePeriod.self, json: json)
            }
        }
    }

    /// Arguments for listV2.
    public class ListFileRequestsArg: CustomStringConvertible, JSONRepresentable {
        /// The maximum number of file requests that should be returned per request.
        public let limit: UInt64
        public init(limit: UInt64 = 1_000) {
            comparableValidator()(limit)
            self.limit = limit
        }

        func json() throws -> JSON {
            try ListFileRequestsArgSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ListFileRequestsArgSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ListFileRequestsArg: \(error)"
            }
        }
    }

    public class ListFileRequestsArgSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ListFileRequestsArg) throws -> JSON {
            let output = [
                "limit": try Serialization._UInt64Serializer.serialize(value.limit),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ListFileRequestsArg {
            switch json {
            case .dictionary(let dict):
                let limit = try Serialization._UInt64Serializer.deserialize(dict["limit"] ?? .number(1_000))
                return ListFileRequestsArg(limit: limit)
            default:
                throw JSONSerializerError.deserializeError(type: ListFileRequestsArg.self, json: json)
            }
        }
    }

    /// The ListFileRequestsContinueArg struct
    public class ListFileRequestsContinueArg: CustomStringConvertible, JSONRepresentable {
        /// The cursor returned by the previous API call specified in the endpoint description.
        public let cursor: String
        public init(cursor: String) {
            stringValidator()(cursor)
            self.cursor = cursor
        }

        func json() throws -> JSON {
            try ListFileRequestsContinueArgSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ListFileRequestsContinueArgSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ListFileRequestsContinueArg: \(error)"
            }
        }
    }

    public class ListFileRequestsContinueArgSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ListFileRequestsContinueArg) throws -> JSON {
            let output = [
                "cursor": try Serialization._StringSerializer.serialize(value.cursor),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ListFileRequestsContinueArg {
            switch json {
            case .dictionary(let dict):
                let cursor = try Serialization._StringSerializer.deserialize(dict["cursor"] ?? .null)
                return ListFileRequestsContinueArg(cursor: cursor)
            default:
                throw JSONSerializerError.deserializeError(type: ListFileRequestsContinueArg.self, json: json)
            }
        }
    }

    /// There was an error retrieving the file requests.
    public enum ListFileRequestsContinueError: CustomStringConvertible, JSONRepresentable {
        /// This user's Dropbox Business team doesn't allow file requests.
        case disabledForTeam
        /// An unspecified error.
        case other
        /// The cursor is invalid.
        case invalidCursor

        func json() throws -> JSON {
            try ListFileRequestsContinueErrorSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ListFileRequestsContinueErrorSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ListFileRequestsContinueError: \(error)"
            }
        }
    }

    public class ListFileRequestsContinueErrorSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ListFileRequestsContinueError) throws -> JSON {
            switch value {
            case .disabledForTeam:
                var d = [String: JSON]()
                d[".tag"] = .str("disabled_for_team")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            case .invalidCursor:
                var d = [String: JSON]()
                d[".tag"] = .str("invalid_cursor")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> ListFileRequestsContinueError {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "disabled_for_team":
                    return ListFileRequestsContinueError.disabledForTeam
                case "other":
                    return ListFileRequestsContinueError.other
                case "invalid_cursor":
                    return ListFileRequestsContinueError.invalidCursor
                default:
                    throw JSONSerializerError.unknownTag(type: ListFileRequestsContinueError.self, json: json, tag: tag)
                }
            default:
                throw JSONSerializerError.deserializeError(type: ListFileRequestsContinueError.self, json: json)
            }
        }
    }

    /// There was an error retrieving the file requests.
    public enum ListFileRequestsError: CustomStringConvertible, JSONRepresentable {
        /// This user's Dropbox Business team doesn't allow file requests.
        case disabledForTeam
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try ListFileRequestsErrorSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ListFileRequestsErrorSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ListFileRequestsError: \(error)"
            }
        }
    }

    public class ListFileRequestsErrorSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ListFileRequestsError) throws -> JSON {
            switch value {
            case .disabledForTeam:
                var d = [String: JSON]()
                d[".tag"] = .str("disabled_for_team")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> ListFileRequestsError {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "disabled_for_team":
                    return ListFileRequestsError.disabledForTeam
                case "other":
                    return ListFileRequestsError.other
                default:
                    throw JSONSerializerError.unknownTag(type: ListFileRequestsError.self, json: json, tag: tag)
                }
            default:
                throw JSONSerializerError.deserializeError(type: ListFileRequestsError.self, json: json)
            }
        }
    }

    /// Result for list_.
    public class ListFileRequestsResult: CustomStringConvertible, JSONRepresentable {
        /// The file requests owned by this user. Apps with the app folder permission will only see file requests in
        /// their app folder.
        public let fileRequests: [FileRequests.FileRequest]
        public init(fileRequests: [FileRequests.FileRequest]) {
            self.fileRequests = fileRequests
        }

        func json() throws -> JSON {
            try ListFileRequestsResultSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ListFileRequestsResultSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ListFileRequestsResult: \(error)"
            }
        }
    }

    public class ListFileRequestsResultSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ListFileRequestsResult) throws -> JSON {
            let output = [
                "file_requests": try ArraySerializer(FileRequests.FileRequestSerializer()).serialize(value.fileRequests),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ListFileRequestsResult {
            switch json {
            case .dictionary(let dict):
                let fileRequests = try ArraySerializer(FileRequests.FileRequestSerializer()).deserialize(dict["file_requests"] ?? .null)
                return ListFileRequestsResult(fileRequests: fileRequests)
            default:
                throw JSONSerializerError.deserializeError(type: ListFileRequestsResult.self, json: json)
            }
        }
    }

    /// Result for listV2 and listContinue.
    public class ListFileRequestsV2Result: CustomStringConvertible, JSONRepresentable {
        /// The file requests owned by this user. Apps with the app folder permission will only see file requests in
        /// their app folder.
        public let fileRequests: [FileRequests.FileRequest]
        /// Pass the cursor into listContinue to obtain additional file requests.
        public let cursor: String
        /// Is true if there are additional file requests that have not been returned yet. An additional call to
        /// :route:list/continue` can retrieve them.
        public let hasMore: Bool
        public init(fileRequests: [FileRequests.FileRequest], cursor: String, hasMore: Bool) {
            self.fileRequests = fileRequests
            stringValidator()(cursor)
            self.cursor = cursor
            self.hasMore = hasMore
        }

        func json() throws -> JSON {
            try ListFileRequestsV2ResultSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ListFileRequestsV2ResultSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ListFileRequestsV2Result: \(error)"
            }
        }
    }

    public class ListFileRequestsV2ResultSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ListFileRequestsV2Result) throws -> JSON {
            let output = [
                "file_requests": try ArraySerializer(FileRequests.FileRequestSerializer()).serialize(value.fileRequests),
                "cursor": try Serialization._StringSerializer.serialize(value.cursor),
                "has_more": try Serialization._BoolSerializer.serialize(value.hasMore),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ListFileRequestsV2Result {
            switch json {
            case .dictionary(let dict):
                let fileRequests = try ArraySerializer(FileRequests.FileRequestSerializer()).deserialize(dict["file_requests"] ?? .null)
                let cursor = try Serialization._StringSerializer.deserialize(dict["cursor"] ?? .null)
                let hasMore = try Serialization._BoolSerializer.deserialize(dict["has_more"] ?? .null)
                return ListFileRequestsV2Result(fileRequests: fileRequests, cursor: cursor, hasMore: hasMore)
            default:
                throw JSONSerializerError.deserializeError(type: ListFileRequestsV2Result.self, json: json)
            }
        }
    }

    /// Arguments for update.
    public class UpdateFileRequestArgs: CustomStringConvertible, JSONRepresentable {
        /// The ID of the file request to update.
        public let id: String
        /// The new title of the file request. Must not be empty.
        public let title: String?
        /// The new path of the folder in the Dropbox where uploaded files will be sent. For apps with the app folder
        /// permission, this will be relative to the app folder.
        public let destination: String?
        /// The new deadline for the file request. Deadlines can only be set by Professional and Business accounts.
        public let deadline: FileRequests.UpdateFileRequestDeadline
        /// Whether to set this file request as open or closed.
        public let open: Bool?
        /// The description of the file request.
        public let description_: String?
        public init(
            id: String,
            title: String? = nil,
            destination: String? = nil,
            deadline: FileRequests.UpdateFileRequestDeadline = .noUpdate,
            open: Bool? = nil,
            description_: String? = nil
        ) {
            stringValidator(minLength: 1, pattern: "[-_0-9a-zA-Z]+")(id)
            self.id = id
            nullableValidator(stringValidator(minLength: 1))(title)
            self.title = title
            nullableValidator(stringValidator(pattern: "/(.|[\\r\\n])*"))(destination)
            self.destination = destination
            self.deadline = deadline
            self.open = open
            nullableValidator(stringValidator())(description_)
            self.description_ = description_
        }

        func json() throws -> JSON {
            try UpdateFileRequestArgsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try UpdateFileRequestArgsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for UpdateFileRequestArgs: \(error)"
            }
        }
    }

    public class UpdateFileRequestArgsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: UpdateFileRequestArgs) throws -> JSON {
            let output = [
                "id": try Serialization._StringSerializer.serialize(value.id),
                "title": try NullableSerializer(Serialization._StringSerializer).serialize(value.title),
                "destination": try NullableSerializer(Serialization._StringSerializer).serialize(value.destination),
                "deadline": try FileRequests.UpdateFileRequestDeadlineSerializer().serialize(value.deadline),
                "open": try NullableSerializer(Serialization._BoolSerializer).serialize(value.open),
                "description": try NullableSerializer(Serialization._StringSerializer).serialize(value.description_),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> UpdateFileRequestArgs {
            switch json {
            case .dictionary(let dict):
                let id = try Serialization._StringSerializer.deserialize(dict["id"] ?? .null)
                let title = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["title"] ?? .null)
                let destination = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["destination"] ?? .null)
                let deadline = try FileRequests.UpdateFileRequestDeadlineSerializer()
                    .deserialize(dict["deadline"] ?? FileRequests.UpdateFileRequestDeadlineSerializer().serialize(.noUpdate))
                let open = try NullableSerializer(Serialization._BoolSerializer).deserialize(dict["open"] ?? .null)
                let description_ = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["description"] ?? .null)
                return UpdateFileRequestArgs(id: id, title: title, destination: destination, deadline: deadline, open: open, description_: description_)
            default:
                throw JSONSerializerError.deserializeError(type: UpdateFileRequestArgs.self, json: json)
            }
        }
    }

    /// The UpdateFileRequestDeadline union
    public enum UpdateFileRequestDeadline: CustomStringConvertible, JSONRepresentable {
        /// Do not change the file request's deadline.
        case noUpdate
        /// If null, the file request's deadline is cleared.
        case update(FileRequests.FileRequestDeadline?)
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try UpdateFileRequestDeadlineSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try UpdateFileRequestDeadlineSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for UpdateFileRequestDeadline: \(error)"
            }
        }
    }

    public class UpdateFileRequestDeadlineSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: UpdateFileRequestDeadline) throws -> JSON {
            switch value {
            case .noUpdate:
                var d = [String: JSON]()
                d[".tag"] = .str("no_update")
                return .dictionary(d)
            case .update(let arg):
                var d = try ["update": NullableSerializer(FileRequests.FileRequestDeadlineSerializer()).serialize(arg)]
                d[".tag"] = .str("update")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> UpdateFileRequestDeadline {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "no_update":
                    return UpdateFileRequestDeadline.noUpdate
                case "update":
                    let v = try NullableSerializer(FileRequests.FileRequestDeadlineSerializer()).deserialize(d["update"] ?? .null)
                    return UpdateFileRequestDeadline.update(v)
                case "other":
                    return UpdateFileRequestDeadline.other
                default:
                    return UpdateFileRequestDeadline.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: UpdateFileRequestDeadline.self, json: json)
            }
        }
    }

    /// There is an error updating the file request.
    public enum UpdateFileRequestError: CustomStringConvertible, JSONRepresentable {
        /// This user's Dropbox Business team doesn't allow file requests.
        case disabledForTeam
        /// An unspecified error.
        case other
        /// This file request ID was not found.
        case notFound
        /// The specified path is not a folder.
        case notAFolder
        /// This file request is not accessible to this app. Apps with the app folder permission can only access file
        /// requests in their app folder.
        case appLacksAccess
        /// This user doesn't have permission to access or modify this file request.
        case noPermission
        /// This user's email address is not verified. File requests are only available on accounts with a verified
        /// email address. Users can verify their email address here https://www.dropbox.com/help/317.
        case emailUnverified
        /// There was an error validating the request. For example, the title was invalid, or there were disallowed
        /// characters in the destination path.
        case validationError

        func json() throws -> JSON {
            try UpdateFileRequestErrorSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try UpdateFileRequestErrorSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for UpdateFileRequestError: \(error)"
            }
        }
    }

    public class UpdateFileRequestErrorSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: UpdateFileRequestError) throws -> JSON {
            switch value {
            case .disabledForTeam:
                var d = [String: JSON]()
                d[".tag"] = .str("disabled_for_team")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            case .notFound:
                var d = [String: JSON]()
                d[".tag"] = .str("not_found")
                return .dictionary(d)
            case .notAFolder:
                var d = [String: JSON]()
                d[".tag"] = .str("not_a_folder")
                return .dictionary(d)
            case .appLacksAccess:
                var d = [String: JSON]()
                d[".tag"] = .str("app_lacks_access")
                return .dictionary(d)
            case .noPermission:
                var d = [String: JSON]()
                d[".tag"] = .str("no_permission")
                return .dictionary(d)
            case .emailUnverified:
                var d = [String: JSON]()
                d[".tag"] = .str("email_unverified")
                return .dictionary(d)
            case .validationError:
                var d = [String: JSON]()
                d[".tag"] = .str("validation_error")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> UpdateFileRequestError {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "disabled_for_team":
                    return UpdateFileRequestError.disabledForTeam
                case "other":
                    return UpdateFileRequestError.other
                case "not_found":
                    return UpdateFileRequestError.notFound
                case "not_a_folder":
                    return UpdateFileRequestError.notAFolder
                case "app_lacks_access":
                    return UpdateFileRequestError.appLacksAccess
                case "no_permission":
                    return UpdateFileRequestError.noPermission
                case "email_unverified":
                    return UpdateFileRequestError.emailUnverified
                case "validation_error":
                    return UpdateFileRequestError.validationError
                default:
                    throw JSONSerializerError.unknownTag(type: UpdateFileRequestError.self, json: json, tag: tag)
                }
            default:
                throw JSONSerializerError.deserializeError(type: UpdateFileRequestError.self, json: json)
            }
        }
    }

    /// Stone Route Objects

    static let count = Route(
        name: "count",
        version: 1,
        namespace: "file_requests",
        deprecated: false,
        argSerializer: Serialization._VoidSerializer,
        responseSerializer: FileRequests.CountFileRequestsResultSerializer(),
        errorSerializer: FileRequests.CountFileRequestsErrorSerializer(),
        attributes: RouteAttributes(
            auth: [.user],
            host: .api,
            style: .rpc
        )
    )
    static let create = Route(
        name: "create",
        version: 1,
        namespace: "file_requests",
        deprecated: false,
        argSerializer: FileRequests.CreateFileRequestArgsSerializer(),
        responseSerializer: FileRequests.FileRequestSerializer(),
        errorSerializer: FileRequests.CreateFileRequestErrorSerializer(),
        attributes: RouteAttributes(
            auth: [.user],
            host: .api,
            style: .rpc
        )
    )
    static let delete = Route(
        name: "delete",
        version: 1,
        namespace: "file_requests",
        deprecated: false,
        argSerializer: FileRequests.DeleteFileRequestArgsSerializer(),
        responseSerializer: FileRequests.DeleteFileRequestsResultSerializer(),
        errorSerializer: FileRequests.DeleteFileRequestErrorSerializer(),
        attributes: RouteAttributes(
            auth: [.user],
            host: .api,
            style: .rpc
        )
    )
    static let deleteAllClosed = Route(
        name: "delete_all_closed",
        version: 1,
        namespace: "file_requests",
        deprecated: false,
        argSerializer: Serialization._VoidSerializer,
        responseSerializer: FileRequests.DeleteAllClosedFileRequestsResultSerializer(),
        errorSerializer: FileRequests.DeleteAllClosedFileRequestsErrorSerializer(),
        attributes: RouteAttributes(
            auth: [.user],
            host: .api,
            style: .rpc
        )
    )
    static let get = Route(
        name: "get",
        version: 1,
        namespace: "file_requests",
        deprecated: false,
        argSerializer: FileRequests.GetFileRequestArgsSerializer(),
        responseSerializer: FileRequests.FileRequestSerializer(),
        errorSerializer: FileRequests.GetFileRequestErrorSerializer(),
        attributes: RouteAttributes(
            auth: [.user],
            host: .api,
            style: .rpc
        )
    )
    static let listV2 = Route(
        name: "list_v2",
        version: 2,
        namespace: "file_requests",
        deprecated: false,
        argSerializer: FileRequests.ListFileRequestsArgSerializer(),
        responseSerializer: FileRequests.ListFileRequestsV2ResultSerializer(),
        errorSerializer: FileRequests.ListFileRequestsErrorSerializer(),
        attributes: RouteAttributes(
            auth: [.user],
            host: .api,
            style: .rpc
        )
    )
    static let list_ = Route(
        name: "list",
        version: 1,
        namespace: "file_requests",
        deprecated: false,
        argSerializer: Serialization._VoidSerializer,
        responseSerializer: FileRequests.ListFileRequestsResultSerializer(),
        errorSerializer: FileRequests.ListFileRequestsErrorSerializer(),
        attributes: RouteAttributes(
            auth: [.user],
            host: .api,
            style: .rpc
        )
    )
    static let listContinue = Route(
        name: "list/continue",
        version: 1,
        namespace: "file_requests",
        deprecated: false,
        argSerializer: FileRequests.ListFileRequestsContinueArgSerializer(),
        responseSerializer: FileRequests.ListFileRequestsV2ResultSerializer(),
        errorSerializer: FileRequests.ListFileRequestsContinueErrorSerializer(),
        attributes: RouteAttributes(
            auth: [.user],
            host: .api,
            style: .rpc
        )
    )
    static let update = Route(
        name: "update",
        version: 1,
        namespace: "file_requests",
        deprecated: false,
        argSerializer: FileRequests.UpdateFileRequestArgsSerializer(),
        responseSerializer: FileRequests.FileRequestSerializer(),
        errorSerializer: FileRequests.UpdateFileRequestErrorSerializer(),
        attributes: RouteAttributes(
            auth: [.user],
            host: .api,
            style: .rpc
        )
    )
}
