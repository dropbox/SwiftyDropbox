///
/// Copyright (c) 2016 Dropbox, Inc. All rights reserved.
///
/// Auto-generated by Stone, do not modify.
///

import Foundation

/// Datatypes and serializers for the file_requests namespace
open class FileRequests {
    /// Arguments for create.
    open class CreateFileRequestArgs: CustomStringConvertible {
        /// The title of the file request. Must not be empty.
        open let title: String
        /// The path of the folder in the Dropbox where uploaded files will be sent. For apps with the app folder
        /// permission, this will be relative to the app folder.
        open let destination: String
        /// The deadline for the file request. Deadlines can only be set by Pro and Business accounts.
        open let deadline: FileRequests.FileRequestDeadline?
        /// Whether or not the file request should be open. If the file request is closed, it will not accept any file
        /// submissions, but it can be opened later.
        open let open: Bool
        public init(title: String, destination: String, deadline: FileRequests.FileRequestDeadline? = nil, open: Bool = true) {
            stringValidator(minLength: 1)(title)
            self.title = title
            stringValidator(pattern: "/(.|[\\r\\n])*")(destination)
            self.destination = destination
            self.deadline = deadline
            self.open = open
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(CreateFileRequestArgsSerializer().serialize(self)))"
        }
    }
    open class CreateFileRequestArgsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: CreateFileRequestArgs) -> JSON {
            let output = [ 
            "title": Serialization._StringSerializer.serialize(value.title),
            "destination": Serialization._StringSerializer.serialize(value.destination),
            "deadline": NullableSerializer(FileRequests.FileRequestDeadlineSerializer()).serialize(value.deadline),
            "open": Serialization._BoolSerializer.serialize(value.open),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> CreateFileRequestArgs {
            switch json {
                case .dictionary(let dict):
                    let title = Serialization._StringSerializer.deserialize(dict["title"] ?? .null)
                    let destination = Serialization._StringSerializer.deserialize(dict["destination"] ?? .null)
                    let deadline = NullableSerializer(FileRequests.FileRequestDeadlineSerializer()).deserialize(dict["deadline"] ?? .null)
                    let open = Serialization._BoolSerializer.deserialize(dict["open"] ?? .number(1))
                    return CreateFileRequestArgs(title: title, destination: destination, deadline: deadline, open: open)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// There is an error accessing the file requests functionality.
    public enum GeneralFileRequestsError: CustomStringConvertible {
        /// This user's Dropbox Business team doesn't allow file requests.
        case disabledForTeam
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GeneralFileRequestsErrorSerializer().serialize(self)))"
        }
    }
    open class GeneralFileRequestsErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GeneralFileRequestsError) -> JSON {
            switch value {
                case .disabledForTeam:
                    var d = [String: JSON]()
                    d[".tag"] = .str("disabled_for_team")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> GeneralFileRequestsError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "disabled_for_team":
                            return GeneralFileRequestsError.disabledForTeam
                        case "other":
                            return GeneralFileRequestsError.other
                        default:
                            return GeneralFileRequestsError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// There is an error with the file request.
    public enum FileRequestError: CustomStringConvertible {
        /// This user's Dropbox Business team doesn't allow file requests.
        case disabledForTeam
        /// An unspecified error.
        case other
        /// This file request ID was not found.
        case notFound
        /// The specified path is not a folder.
        case notAFolder
        /// This file request is not accessible to this app. Apps with the app folder permission can only access file
        /// requests in their app folder.
        case appLacksAccess
        /// This user doesn't have permission to access or modify this file request.
        case noPermission
        /// This user's email address is not verified. File requests are only available on accounts with a verified
        /// email address. Users can verify their email address here https://www.dropbox.com/help/317.
        case emailUnverified
        /// There was an error validating the request. For example, the title was invalid, or there were disallowed
        /// characters in the destination path.
        case validationError

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(FileRequestErrorSerializer().serialize(self)))"
        }
    }
    open class FileRequestErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: FileRequestError) -> JSON {
            switch value {
                case .disabledForTeam:
                    var d = [String: JSON]()
                    d[".tag"] = .str("disabled_for_team")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
                case .notFound:
                    var d = [String: JSON]()
                    d[".tag"] = .str("not_found")
                    return .dictionary(d)
                case .notAFolder:
                    var d = [String: JSON]()
                    d[".tag"] = .str("not_a_folder")
                    return .dictionary(d)
                case .appLacksAccess:
                    var d = [String: JSON]()
                    d[".tag"] = .str("app_lacks_access")
                    return .dictionary(d)
                case .noPermission:
                    var d = [String: JSON]()
                    d[".tag"] = .str("no_permission")
                    return .dictionary(d)
                case .emailUnverified:
                    var d = [String: JSON]()
                    d[".tag"] = .str("email_unverified")
                    return .dictionary(d)
                case .validationError:
                    var d = [String: JSON]()
                    d[".tag"] = .str("validation_error")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> FileRequestError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "disabled_for_team":
                            return FileRequestError.disabledForTeam
                        case "other":
                            return FileRequestError.other
                        case "not_found":
                            return FileRequestError.notFound
                        case "not_a_folder":
                            return FileRequestError.notAFolder
                        case "app_lacks_access":
                            return FileRequestError.appLacksAccess
                        case "no_permission":
                            return FileRequestError.noPermission
                        case "email_unverified":
                            return FileRequestError.emailUnverified
                        case "validation_error":
                            return FileRequestError.validationError
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// There was an error creating the file request.
    public enum CreateFileRequestError: CustomStringConvertible {
        /// This user's Dropbox Business team doesn't allow file requests.
        case disabledForTeam
        /// An unspecified error.
        case other
        /// This file request ID was not found.
        case notFound
        /// The specified path is not a folder.
        case notAFolder
        /// This file request is not accessible to this app. Apps with the app folder permission can only access file
        /// requests in their app folder.
        case appLacksAccess
        /// This user doesn't have permission to access or modify this file request.
        case noPermission
        /// This user's email address is not verified. File requests are only available on accounts with a verified
        /// email address. Users can verify their email address here https://www.dropbox.com/help/317.
        case emailUnverified
        /// There was an error validating the request. For example, the title was invalid, or there were disallowed
        /// characters in the destination path.
        case validationError
        /// File requests are not available on the specified folder.
        case invalidLocation
        /// The user has reached the rate limit for creating file requests. The limit is currently 100 file requests per
        /// day.
        case rateLimit

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(CreateFileRequestErrorSerializer().serialize(self)))"
        }
    }
    open class CreateFileRequestErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: CreateFileRequestError) -> JSON {
            switch value {
                case .disabledForTeam:
                    var d = [String: JSON]()
                    d[".tag"] = .str("disabled_for_team")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
                case .notFound:
                    var d = [String: JSON]()
                    d[".tag"] = .str("not_found")
                    return .dictionary(d)
                case .notAFolder:
                    var d = [String: JSON]()
                    d[".tag"] = .str("not_a_folder")
                    return .dictionary(d)
                case .appLacksAccess:
                    var d = [String: JSON]()
                    d[".tag"] = .str("app_lacks_access")
                    return .dictionary(d)
                case .noPermission:
                    var d = [String: JSON]()
                    d[".tag"] = .str("no_permission")
                    return .dictionary(d)
                case .emailUnverified:
                    var d = [String: JSON]()
                    d[".tag"] = .str("email_unverified")
                    return .dictionary(d)
                case .validationError:
                    var d = [String: JSON]()
                    d[".tag"] = .str("validation_error")
                    return .dictionary(d)
                case .invalidLocation:
                    var d = [String: JSON]()
                    d[".tag"] = .str("invalid_location")
                    return .dictionary(d)
                case .rateLimit:
                    var d = [String: JSON]()
                    d[".tag"] = .str("rate_limit")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> CreateFileRequestError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "disabled_for_team":
                            return CreateFileRequestError.disabledForTeam
                        case "other":
                            return CreateFileRequestError.other
                        case "not_found":
                            return CreateFileRequestError.notFound
                        case "not_a_folder":
                            return CreateFileRequestError.notAFolder
                        case "app_lacks_access":
                            return CreateFileRequestError.appLacksAccess
                        case "no_permission":
                            return CreateFileRequestError.noPermission
                        case "email_unverified":
                            return CreateFileRequestError.emailUnverified
                        case "validation_error":
                            return CreateFileRequestError.validationError
                        case "invalid_location":
                            return CreateFileRequestError.invalidLocation
                        case "rate_limit":
                            return CreateFileRequestError.rateLimit
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// A file request https://www.dropbox.com/help/9090 for receiving files into the user's Dropbox account.
    open class FileRequest: CustomStringConvertible {
        /// The ID of the file request.
        open let id: String
        /// The URL of the file request.
        open let url: String
        /// The title of the file request.
        open let title: String
        /// The path of the folder in the Dropbox where uploaded files will be sent. This can be null if the destination
        /// was removed. For apps with the app folder permission, this will be relative to the app folder.
        open let destination: String?
        /// When this file request was created.
        open let created: Date
        /// The deadline for this file request. Only set if the request has a deadline.
        open let deadline: FileRequests.FileRequestDeadline?
        /// Whether or not the file request is open. If the file request is closed, it will not accept any more file
        /// submissions.
        open let isOpen: Bool
        /// The number of files this file request has received.
        open let fileCount: Int64
        public init(id: String, url: String, title: String, created: Date, isOpen: Bool, fileCount: Int64, destination: String? = nil, deadline: FileRequests.FileRequestDeadline? = nil) {
            stringValidator(minLength: 1, pattern: "[-_0-9a-zA-Z]+")(id)
            self.id = id
            stringValidator(minLength: 1)(url)
            self.url = url
            stringValidator(minLength: 1)(title)
            self.title = title
            nullableValidator(stringValidator(pattern: "/(.|[\\r\\n])*"))(destination)
            self.destination = destination
            self.created = created
            self.deadline = deadline
            self.isOpen = isOpen
            comparableValidator()(fileCount)
            self.fileCount = fileCount
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(FileRequestSerializer().serialize(self)))"
        }
    }
    open class FileRequestSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: FileRequest) -> JSON {
            let output = [ 
            "id": Serialization._StringSerializer.serialize(value.id),
            "url": Serialization._StringSerializer.serialize(value.url),
            "title": Serialization._StringSerializer.serialize(value.title),
            "created": NSDateSerializer("%Y-%m-%dT%H:%M:%SZ").serialize(value.created),
            "is_open": Serialization._BoolSerializer.serialize(value.isOpen),
            "file_count": Serialization._Int64Serializer.serialize(value.fileCount),
            "destination": NullableSerializer(Serialization._StringSerializer).serialize(value.destination),
            "deadline": NullableSerializer(FileRequests.FileRequestDeadlineSerializer()).serialize(value.deadline),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> FileRequest {
            switch json {
                case .dictionary(let dict):
                    let id = Serialization._StringSerializer.deserialize(dict["id"] ?? .null)
                    let url = Serialization._StringSerializer.deserialize(dict["url"] ?? .null)
                    let title = Serialization._StringSerializer.deserialize(dict["title"] ?? .null)
                    let created = NSDateSerializer("%Y-%m-%dT%H:%M:%SZ").deserialize(dict["created"] ?? .null)
                    let isOpen = Serialization._BoolSerializer.deserialize(dict["is_open"] ?? .null)
                    let fileCount = Serialization._Int64Serializer.deserialize(dict["file_count"] ?? .null)
                    let destination = NullableSerializer(Serialization._StringSerializer).deserialize(dict["destination"] ?? .null)
                    let deadline = NullableSerializer(FileRequests.FileRequestDeadlineSerializer()).deserialize(dict["deadline"] ?? .null)
                    return FileRequest(id: id, url: url, title: title, created: created, isOpen: isOpen, fileCount: fileCount, destination: destination, deadline: deadline)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The FileRequestDeadline struct
    open class FileRequestDeadline: CustomStringConvertible {
        /// The deadline for this file request.
        open let deadline: Date
        /// If set, allow uploads after the deadline has passed. These uploads will be marked overdue.
        open let allowLateUploads: FileRequests.GracePeriod?
        public init(deadline: Date, allowLateUploads: FileRequests.GracePeriod? = nil) {
            self.deadline = deadline
            self.allowLateUploads = allowLateUploads
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(FileRequestDeadlineSerializer().serialize(self)))"
        }
    }
    open class FileRequestDeadlineSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: FileRequestDeadline) -> JSON {
            let output = [ 
            "deadline": NSDateSerializer("%Y-%m-%dT%H:%M:%SZ").serialize(value.deadline),
            "allow_late_uploads": NullableSerializer(FileRequests.GracePeriodSerializer()).serialize(value.allowLateUploads),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> FileRequestDeadline {
            switch json {
                case .dictionary(let dict):
                    let deadline = NSDateSerializer("%Y-%m-%dT%H:%M:%SZ").deserialize(dict["deadline"] ?? .null)
                    let allowLateUploads = NullableSerializer(FileRequests.GracePeriodSerializer()).deserialize(dict["allow_late_uploads"] ?? .null)
                    return FileRequestDeadline(deadline: deadline, allowLateUploads: allowLateUploads)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Arguments for get.
    open class GetFileRequestArgs: CustomStringConvertible {
        /// The ID of the file request to retrieve.
        open let id: String
        public init(id: String) {
            stringValidator(minLength: 1, pattern: "[-_0-9a-zA-Z]+")(id)
            self.id = id
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GetFileRequestArgsSerializer().serialize(self)))"
        }
    }
    open class GetFileRequestArgsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GetFileRequestArgs) -> JSON {
            let output = [ 
            "id": Serialization._StringSerializer.serialize(value.id),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> GetFileRequestArgs {
            switch json {
                case .dictionary(let dict):
                    let id = Serialization._StringSerializer.deserialize(dict["id"] ?? .null)
                    return GetFileRequestArgs(id: id)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// There was an error retrieving the specified file request.
    public enum GetFileRequestError: CustomStringConvertible {
        /// This user's Dropbox Business team doesn't allow file requests.
        case disabledForTeam
        /// An unspecified error.
        case other
        /// This file request ID was not found.
        case notFound
        /// The specified path is not a folder.
        case notAFolder
        /// This file request is not accessible to this app. Apps with the app folder permission can only access file
        /// requests in their app folder.
        case appLacksAccess
        /// This user doesn't have permission to access or modify this file request.
        case noPermission
        /// This user's email address is not verified. File requests are only available on accounts with a verified
        /// email address. Users can verify their email address here https://www.dropbox.com/help/317.
        case emailUnverified
        /// There was an error validating the request. For example, the title was invalid, or there were disallowed
        /// characters in the destination path.
        case validationError

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GetFileRequestErrorSerializer().serialize(self)))"
        }
    }
    open class GetFileRequestErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GetFileRequestError) -> JSON {
            switch value {
                case .disabledForTeam:
                    var d = [String: JSON]()
                    d[".tag"] = .str("disabled_for_team")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
                case .notFound:
                    var d = [String: JSON]()
                    d[".tag"] = .str("not_found")
                    return .dictionary(d)
                case .notAFolder:
                    var d = [String: JSON]()
                    d[".tag"] = .str("not_a_folder")
                    return .dictionary(d)
                case .appLacksAccess:
                    var d = [String: JSON]()
                    d[".tag"] = .str("app_lacks_access")
                    return .dictionary(d)
                case .noPermission:
                    var d = [String: JSON]()
                    d[".tag"] = .str("no_permission")
                    return .dictionary(d)
                case .emailUnverified:
                    var d = [String: JSON]()
                    d[".tag"] = .str("email_unverified")
                    return .dictionary(d)
                case .validationError:
                    var d = [String: JSON]()
                    d[".tag"] = .str("validation_error")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> GetFileRequestError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "disabled_for_team":
                            return GetFileRequestError.disabledForTeam
                        case "other":
                            return GetFileRequestError.other
                        case "not_found":
                            return GetFileRequestError.notFound
                        case "not_a_folder":
                            return GetFileRequestError.notAFolder
                        case "app_lacks_access":
                            return GetFileRequestError.appLacksAccess
                        case "no_permission":
                            return GetFileRequestError.noPermission
                        case "email_unverified":
                            return GetFileRequestError.emailUnverified
                        case "validation_error":
                            return GetFileRequestError.validationError
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The GracePeriod union
    public enum GracePeriod: CustomStringConvertible {
        /// An unspecified error.
        case oneDay
        /// An unspecified error.
        case twoDays
        /// An unspecified error.
        case sevenDays
        /// An unspecified error.
        case thirtyDays
        /// An unspecified error.
        case always
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GracePeriodSerializer().serialize(self)))"
        }
    }
    open class GracePeriodSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GracePeriod) -> JSON {
            switch value {
                case .oneDay:
                    var d = [String: JSON]()
                    d[".tag"] = .str("one_day")
                    return .dictionary(d)
                case .twoDays:
                    var d = [String: JSON]()
                    d[".tag"] = .str("two_days")
                    return .dictionary(d)
                case .sevenDays:
                    var d = [String: JSON]()
                    d[".tag"] = .str("seven_days")
                    return .dictionary(d)
                case .thirtyDays:
                    var d = [String: JSON]()
                    d[".tag"] = .str("thirty_days")
                    return .dictionary(d)
                case .always:
                    var d = [String: JSON]()
                    d[".tag"] = .str("always")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> GracePeriod {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "one_day":
                            return GracePeriod.oneDay
                        case "two_days":
                            return GracePeriod.twoDays
                        case "seven_days":
                            return GracePeriod.sevenDays
                        case "thirty_days":
                            return GracePeriod.thirtyDays
                        case "always":
                            return GracePeriod.always
                        case "other":
                            return GracePeriod.other
                        default:
                            return GracePeriod.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// There was an error retrieving the file requests.
    public enum ListFileRequestsError: CustomStringConvertible {
        /// This user's Dropbox Business team doesn't allow file requests.
        case disabledForTeam
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListFileRequestsErrorSerializer().serialize(self)))"
        }
    }
    open class ListFileRequestsErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ListFileRequestsError) -> JSON {
            switch value {
                case .disabledForTeam:
                    var d = [String: JSON]()
                    d[".tag"] = .str("disabled_for_team")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> ListFileRequestsError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "disabled_for_team":
                            return ListFileRequestsError.disabledForTeam
                        case "other":
                            return ListFileRequestsError.other
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Result for list_.
    open class ListFileRequestsResult: CustomStringConvertible {
        /// The file requests owned by this user. Apps with the app folder permission will only see file requests in
        /// their app folder.
        open let fileRequests: Array<FileRequests.FileRequest>
        public init(fileRequests: Array<FileRequests.FileRequest>) {
            self.fileRequests = fileRequests
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListFileRequestsResultSerializer().serialize(self)))"
        }
    }
    open class ListFileRequestsResultSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ListFileRequestsResult) -> JSON {
            let output = [ 
            "file_requests": ArraySerializer(FileRequests.FileRequestSerializer()).serialize(value.fileRequests),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ListFileRequestsResult {
            switch json {
                case .dictionary(let dict):
                    let fileRequests = ArraySerializer(FileRequests.FileRequestSerializer()).deserialize(dict["file_requests"] ?? .null)
                    return ListFileRequestsResult(fileRequests: fileRequests)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Arguments for update.
    open class UpdateFileRequestArgs: CustomStringConvertible {
        /// The ID of the file request to update.
        open let id: String
        /// The new title of the file request. Must not be empty.
        open let title: String?
        /// The new path of the folder in the Dropbox where uploaded files will be sent. For apps with the app folder
        /// permission, this will be relative to the app folder.
        open let destination: String?
        /// The new deadline for the file request.
        open let deadline: FileRequests.UpdateFileRequestDeadline
        /// Whether to set this file request as open or closed.
        open let open: Bool?
        public init(id: String, title: String? = nil, destination: String? = nil, deadline: FileRequests.UpdateFileRequestDeadline = .noUpdate, open: Bool? = nil) {
            stringValidator(minLength: 1, pattern: "[-_0-9a-zA-Z]+")(id)
            self.id = id
            nullableValidator(stringValidator(minLength: 1))(title)
            self.title = title
            nullableValidator(stringValidator(pattern: "/(.|[\\r\\n])*"))(destination)
            self.destination = destination
            self.deadline = deadline
            self.open = open
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(UpdateFileRequestArgsSerializer().serialize(self)))"
        }
    }
    open class UpdateFileRequestArgsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: UpdateFileRequestArgs) -> JSON {
            let output = [ 
            "id": Serialization._StringSerializer.serialize(value.id),
            "title": NullableSerializer(Serialization._StringSerializer).serialize(value.title),
            "destination": NullableSerializer(Serialization._StringSerializer).serialize(value.destination),
            "deadline": FileRequests.UpdateFileRequestDeadlineSerializer().serialize(value.deadline),
            "open": NullableSerializer(Serialization._BoolSerializer).serialize(value.open),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> UpdateFileRequestArgs {
            switch json {
                case .dictionary(let dict):
                    let id = Serialization._StringSerializer.deserialize(dict["id"] ?? .null)
                    let title = NullableSerializer(Serialization._StringSerializer).deserialize(dict["title"] ?? .null)
                    let destination = NullableSerializer(Serialization._StringSerializer).deserialize(dict["destination"] ?? .null)
                    let deadline = FileRequests.UpdateFileRequestDeadlineSerializer().deserialize(dict["deadline"] ?? FileRequests.UpdateFileRequestDeadlineSerializer().serialize(.noUpdate))
                    let open = NullableSerializer(Serialization._BoolSerializer).deserialize(dict["open"] ?? .null)
                    return UpdateFileRequestArgs(id: id, title: title, destination: destination, deadline: deadline, open: open)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The UpdateFileRequestDeadline union
    public enum UpdateFileRequestDeadline: CustomStringConvertible {
        /// Do not change the file request's deadline.
        case noUpdate
        /// If null, the file request's deadline is cleared.
        case update(FileRequests.FileRequestDeadline?)
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(UpdateFileRequestDeadlineSerializer().serialize(self)))"
        }
    }
    open class UpdateFileRequestDeadlineSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: UpdateFileRequestDeadline) -> JSON {
            switch value {
                case .noUpdate:
                    var d = [String: JSON]()
                    d[".tag"] = .str("no_update")
                    return .dictionary(d)
                case .update(let arg):
                    var d = ["update": NullableSerializer(FileRequests.FileRequestDeadlineSerializer()).serialize(arg)]
                    d[".tag"] = .str("update")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> UpdateFileRequestDeadline {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "no_update":
                            return UpdateFileRequestDeadline.noUpdate
                        case "update":
                            let v = NullableSerializer(FileRequests.FileRequestDeadlineSerializer()).deserialize(d["update"] ?? .null)
                            return UpdateFileRequestDeadline.update(v)
                        case "other":
                            return UpdateFileRequestDeadline.other
                        default:
                            return UpdateFileRequestDeadline.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// There is an error updating the file request.
    public enum UpdateFileRequestError: CustomStringConvertible {
        /// This user's Dropbox Business team doesn't allow file requests.
        case disabledForTeam
        /// An unspecified error.
        case other
        /// This file request ID was not found.
        case notFound
        /// The specified path is not a folder.
        case notAFolder
        /// This file request is not accessible to this app. Apps with the app folder permission can only access file
        /// requests in their app folder.
        case appLacksAccess
        /// This user doesn't have permission to access or modify this file request.
        case noPermission
        /// This user's email address is not verified. File requests are only available on accounts with a verified
        /// email address. Users can verify their email address here https://www.dropbox.com/help/317.
        case emailUnverified
        /// There was an error validating the request. For example, the title was invalid, or there were disallowed
        /// characters in the destination path.
        case validationError

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(UpdateFileRequestErrorSerializer().serialize(self)))"
        }
    }
    open class UpdateFileRequestErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: UpdateFileRequestError) -> JSON {
            switch value {
                case .disabledForTeam:
                    var d = [String: JSON]()
                    d[".tag"] = .str("disabled_for_team")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
                case .notFound:
                    var d = [String: JSON]()
                    d[".tag"] = .str("not_found")
                    return .dictionary(d)
                case .notAFolder:
                    var d = [String: JSON]()
                    d[".tag"] = .str("not_a_folder")
                    return .dictionary(d)
                case .appLacksAccess:
                    var d = [String: JSON]()
                    d[".tag"] = .str("app_lacks_access")
                    return .dictionary(d)
                case .noPermission:
                    var d = [String: JSON]()
                    d[".tag"] = .str("no_permission")
                    return .dictionary(d)
                case .emailUnverified:
                    var d = [String: JSON]()
                    d[".tag"] = .str("email_unverified")
                    return .dictionary(d)
                case .validationError:
                    var d = [String: JSON]()
                    d[".tag"] = .str("validation_error")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> UpdateFileRequestError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "disabled_for_team":
                            return UpdateFileRequestError.disabledForTeam
                        case "other":
                            return UpdateFileRequestError.other
                        case "not_found":
                            return UpdateFileRequestError.notFound
                        case "not_a_folder":
                            return UpdateFileRequestError.notAFolder
                        case "app_lacks_access":
                            return UpdateFileRequestError.appLacksAccess
                        case "no_permission":
                            return UpdateFileRequestError.noPermission
                        case "email_unverified":
                            return UpdateFileRequestError.emailUnverified
                        case "validation_error":
                            return UpdateFileRequestError.validationError
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }


    /// Stone Route Objects

    static let create = Route(
        name: "create",
        namespace: "file_requests",
        deprecated: false,
        argSerializer: FileRequests.CreateFileRequestArgsSerializer(),
        responseSerializer: FileRequests.FileRequestSerializer(),
        errorSerializer: FileRequests.CreateFileRequestErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let get = Route(
        name: "get",
        namespace: "file_requests",
        deprecated: false,
        argSerializer: FileRequests.GetFileRequestArgsSerializer(),
        responseSerializer: FileRequests.FileRequestSerializer(),
        errorSerializer: FileRequests.GetFileRequestErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let list_ = Route(
        name: "list",
        namespace: "file_requests",
        deprecated: false,
        argSerializer: Serialization._VoidSerializer,
        responseSerializer: FileRequests.ListFileRequestsResultSerializer(),
        errorSerializer: FileRequests.ListFileRequestsErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let update = Route(
        name: "update",
        namespace: "file_requests",
        deprecated: false,
        argSerializer: FileRequests.UpdateFileRequestArgsSerializer(),
        responseSerializer: FileRequests.FileRequestSerializer(),
        errorSerializer: FileRequests.UpdateFileRequestErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
}
