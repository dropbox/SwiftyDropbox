///
/// Copyright (c) 2016 Dropbox, Inc. All rights reserved.
///
/// Auto-generated by Stone, do not modify.
///

import Foundation

/// Datatypes and serializers for the properties namespace
open class Properties {
    /// The GetPropertyTemplateArg struct
    open class GetPropertyTemplateArg: CustomStringConvertible {
        /// An identifier for property template added by route properties/template/add.
        open let templateId: String
        public init(templateId: String) {
            stringValidator(minLength: 1, pattern: "(/|ptid:).*")(templateId)
            self.templateId = templateId
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GetPropertyTemplateArgSerializer().serialize(self)))"
        }
    }
    open class GetPropertyTemplateArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GetPropertyTemplateArg) -> JSON {
            let output = [ 
            "template_id": Serialization._StringSerializer.serialize(value.templateId),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> GetPropertyTemplateArg {
            switch json {
                case .dictionary(let dict):
                    let templateId = Serialization._StringSerializer.deserialize(dict["template_id"] ?? .null)
                    return GetPropertyTemplateArg(templateId: templateId)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Describes property templates that can be filled and associated with a file.
    open class PropertyGroupTemplate: CustomStringConvertible {
        /// A display name for the property template. Property template names can be up to 256 bytes.
        open let name: String
        /// Description for new property template. Property template descriptions can be up to 1024 bytes.
        open let description_: String
        /// This is a list of custom properties associated with a property template. There can be up to 64 properties in
        /// a single property template.
        open let fields: Array<Properties.PropertyFieldTemplate>
        public init(name: String, description_: String, fields: Array<Properties.PropertyFieldTemplate>) {
            stringValidator()(name)
            self.name = name
            stringValidator()(description_)
            self.description_ = description_
            self.fields = fields
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PropertyGroupTemplateSerializer().serialize(self)))"
        }
    }
    open class PropertyGroupTemplateSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PropertyGroupTemplate) -> JSON {
            let output = [ 
            "name": Serialization._StringSerializer.serialize(value.name),
            "description": Serialization._StringSerializer.serialize(value.description_),
            "fields": ArraySerializer(Properties.PropertyFieldTemplateSerializer()).serialize(value.fields),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> PropertyGroupTemplate {
            switch json {
                case .dictionary(let dict):
                    let name = Serialization._StringSerializer.deserialize(dict["name"] ?? .null)
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    let fields = ArraySerializer(Properties.PropertyFieldTemplateSerializer()).deserialize(dict["fields"] ?? .null)
                    return PropertyGroupTemplate(name: name, description_: description_, fields: fields)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The Property template for the specified template.
    open class GetPropertyTemplateResult: Properties.PropertyGroupTemplate {
        open override var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GetPropertyTemplateResultSerializer().serialize(self)))"
        }
    }
    open class GetPropertyTemplateResultSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GetPropertyTemplateResult) -> JSON {
            let output = [ 
            "name": Serialization._StringSerializer.serialize(value.name),
            "description": Serialization._StringSerializer.serialize(value.description_),
            "fields": ArraySerializer(Properties.PropertyFieldTemplateSerializer()).serialize(value.fields),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> GetPropertyTemplateResult {
            switch json {
                case .dictionary(let dict):
                    let name = Serialization._StringSerializer.deserialize(dict["name"] ?? .null)
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    let fields = ArraySerializer(Properties.PropertyFieldTemplateSerializer()).deserialize(dict["fields"] ?? .null)
                    return GetPropertyTemplateResult(name: name, description_: description_, fields: fields)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The ListPropertyTemplateIds struct
    open class ListPropertyTemplateIds: CustomStringConvertible {
        /// List of identifiers for templates added by route properties/template/add.
        open let templateIds: Array<String>
        public init(templateIds: Array<String>) {
            arrayValidator(itemValidator: stringValidator(minLength: 1, pattern: "(/|ptid:).*"))(templateIds)
            self.templateIds = templateIds
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListPropertyTemplateIdsSerializer().serialize(self)))"
        }
    }
    open class ListPropertyTemplateIdsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ListPropertyTemplateIds) -> JSON {
            let output = [ 
            "template_ids": ArraySerializer(Serialization._StringSerializer).serialize(value.templateIds),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ListPropertyTemplateIds {
            switch json {
                case .dictionary(let dict):
                    let templateIds = ArraySerializer(Serialization._StringSerializer).deserialize(dict["template_ids"] ?? .null)
                    return ListPropertyTemplateIds(templateIds: templateIds)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The PropertyTemplateError union
    public enum PropertyTemplateError: CustomStringConvertible {
        /// Property template does not exist for given identifier.
        case templateNotFound(String)
        /// You do not have the permissions to modify this property template.
        case restrictedContent
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PropertyTemplateErrorSerializer().serialize(self)))"
        }
    }
    open class PropertyTemplateErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PropertyTemplateError) -> JSON {
            switch value {
                case .templateNotFound(let arg):
                    var d = ["template_not_found": Serialization._StringSerializer.serialize(arg)]
                    d[".tag"] = .str("template_not_found")
                    return .dictionary(d)
                case .restrictedContent:
                    var d = [String: JSON]()
                    d[".tag"] = .str("restricted_content")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> PropertyTemplateError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "template_not_found":
                            let v = Serialization._StringSerializer.deserialize(d["template_not_found"] ?? .null)
                            return PropertyTemplateError.templateNotFound(v)
                        case "restricted_content":
                            return PropertyTemplateError.restrictedContent
                        case "other":
                            return PropertyTemplateError.other
                        default:
                            return PropertyTemplateError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The ModifyPropertyTemplateError union
    public enum ModifyPropertyTemplateError: CustomStringConvertible {
        /// Property template does not exist for given identifier.
        case templateNotFound(String)
        /// You do not have the permissions to modify this property template.
        case restrictedContent
        /// An unspecified error.
        case other
        /// A property field name already exists in the template.
        case conflictingPropertyNames
        /// There are too many properties in the changed template. The maximum number of properties per template is 32.
        case tooManyProperties
        /// There are too many templates for the team.
        case tooManyTemplates
        /// The template name, description or field names is too large.
        case templateAttributeTooLarge

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ModifyPropertyTemplateErrorSerializer().serialize(self)))"
        }
    }
    open class ModifyPropertyTemplateErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ModifyPropertyTemplateError) -> JSON {
            switch value {
                case .templateNotFound(let arg):
                    var d = ["template_not_found": Serialization._StringSerializer.serialize(arg)]
                    d[".tag"] = .str("template_not_found")
                    return .dictionary(d)
                case .restrictedContent:
                    var d = [String: JSON]()
                    d[".tag"] = .str("restricted_content")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
                case .conflictingPropertyNames:
                    var d = [String: JSON]()
                    d[".tag"] = .str("conflicting_property_names")
                    return .dictionary(d)
                case .tooManyProperties:
                    var d = [String: JSON]()
                    d[".tag"] = .str("too_many_properties")
                    return .dictionary(d)
                case .tooManyTemplates:
                    var d = [String: JSON]()
                    d[".tag"] = .str("too_many_templates")
                    return .dictionary(d)
                case .templateAttributeTooLarge:
                    var d = [String: JSON]()
                    d[".tag"] = .str("template_attribute_too_large")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> ModifyPropertyTemplateError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "template_not_found":
                            let v = Serialization._StringSerializer.deserialize(d["template_not_found"] ?? .null)
                            return ModifyPropertyTemplateError.templateNotFound(v)
                        case "restricted_content":
                            return ModifyPropertyTemplateError.restrictedContent
                        case "other":
                            return ModifyPropertyTemplateError.other
                        case "conflicting_property_names":
                            return ModifyPropertyTemplateError.conflictingPropertyNames
                        case "too_many_properties":
                            return ModifyPropertyTemplateError.tooManyProperties
                        case "too_many_templates":
                            return ModifyPropertyTemplateError.tooManyTemplates
                        case "template_attribute_too_large":
                            return ModifyPropertyTemplateError.templateAttributeTooLarge
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The PropertyField struct
    open class PropertyField: CustomStringConvertible {
        /// This is the name or key of a custom property in a property template. File property names can be up to 256
        /// bytes.
        open let name: String
        /// Value of a custom property attached to a file. Values can be up to 1024 bytes.
        open let value: String
        public init(name: String, value: String) {
            stringValidator()(name)
            self.name = name
            stringValidator()(value)
            self.value = value
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PropertyFieldSerializer().serialize(self)))"
        }
    }
    open class PropertyFieldSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PropertyField) -> JSON {
            let output = [ 
            "name": Serialization._StringSerializer.serialize(value.name),
            "value": Serialization._StringSerializer.serialize(value.value),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> PropertyField {
            switch json {
                case .dictionary(let dict):
                    let name = Serialization._StringSerializer.deserialize(dict["name"] ?? .null)
                    let value = Serialization._StringSerializer.deserialize(dict["value"] ?? .null)
                    return PropertyField(name: name, value: value)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Describe a single property field type which that can be part of a property template.
    open class PropertyFieldTemplate: CustomStringConvertible {
        /// This is the name or key of a custom property in a property template. File property names can be up to 256
        /// bytes.
        open let name: String
        /// This is the description for a custom property in a property template. File property description can be up to
        /// 1024 bytes.
        open let description_: String
        /// This is the data type of the value of this property. This type will be enforced upon property creation and
        /// modifications.
        open let type: Properties.PropertyType
        public init(name: String, description_: String, type: Properties.PropertyType) {
            stringValidator()(name)
            self.name = name
            stringValidator()(description_)
            self.description_ = description_
            self.type = type
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PropertyFieldTemplateSerializer().serialize(self)))"
        }
    }
    open class PropertyFieldTemplateSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PropertyFieldTemplate) -> JSON {
            let output = [ 
            "name": Serialization._StringSerializer.serialize(value.name),
            "description": Serialization._StringSerializer.serialize(value.description_),
            "type": Properties.PropertyTypeSerializer().serialize(value.type),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> PropertyFieldTemplate {
            switch json {
                case .dictionary(let dict):
                    let name = Serialization._StringSerializer.deserialize(dict["name"] ?? .null)
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .null)
                    let type = Properties.PropertyTypeSerializer().deserialize(dict["type"] ?? .null)
                    return PropertyFieldTemplate(name: name, description_: description_, type: type)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Collection of custom properties in filled property templates.
    open class PropertyGroup: CustomStringConvertible {
        /// A unique identifier for a property template type.
        open let templateId: String
        /// This is a list of custom properties associated with a file. There can be up to 32 properties for a template.
        open let fields: Array<Properties.PropertyField>
        public init(templateId: String, fields: Array<Properties.PropertyField>) {
            stringValidator(minLength: 1, pattern: "(/|ptid:).*")(templateId)
            self.templateId = templateId
            self.fields = fields
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PropertyGroupSerializer().serialize(self)))"
        }
    }
    open class PropertyGroupSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PropertyGroup) -> JSON {
            let output = [ 
            "template_id": Serialization._StringSerializer.serialize(value.templateId),
            "fields": ArraySerializer(Properties.PropertyFieldSerializer()).serialize(value.fields),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> PropertyGroup {
            switch json {
                case .dictionary(let dict):
                    let templateId = Serialization._StringSerializer.deserialize(dict["template_id"] ?? .null)
                    let fields = ArraySerializer(Properties.PropertyFieldSerializer()).deserialize(dict["fields"] ?? .null)
                    return PropertyGroup(templateId: templateId, fields: fields)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Data type of the given property added. This endpoint is in beta and  only properties of type strings is
    /// supported.
    public enum PropertyType: CustomStringConvertible {
        /// The associated property will be of type string. Unicode is supported.
        case string_
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(PropertyTypeSerializer().serialize(self)))"
        }
    }
    open class PropertyTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PropertyType) -> JSON {
            switch value {
                case .string_:
                    var d = [String: JSON]()
                    d[".tag"] = .str("string")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> PropertyType {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "string":
                            return PropertyType.string_
                        case "other":
                            return PropertyType.other
                        default:
                            return PropertyType.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

}
