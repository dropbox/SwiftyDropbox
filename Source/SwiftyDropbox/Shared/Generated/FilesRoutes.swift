///
/// Copyright (c) 2016 Dropbox, Inc. All rights reserved.
///
/// Auto-generated by Stone, do not modify.
///

/// Routes for the files namespace
open class FilesRoutes {
    open let client: DropboxTransportClient
    init(client: DropboxTransportClient) {
        self.client = client
    }

    /// Returns the metadata for a file or folder. This is an alpha endpoint compatible with the properties API. Note:
    /// Metadata for the root folder is unsupported.
    ///
    /// - parameter includePropertyTemplates: If set to a valid list of template IDs, propertyGroups in FileMetadata is
    /// set for files with custom properties.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Files.Metadata` object on success or a
    /// `Files.AlphaGetMetadataError` object on failure.
    @discardableResult open func alphaGetMetadata(path: String, includeMediaInfo: Bool = false, includeDeleted: Bool = false, includeHasExplicitSharedMembers: Bool = false, includePropertyTemplates: Array<String>? = nil) -> RpcRequest<Files.MetadataSerializer, Files.AlphaGetMetadataErrorSerializer> {
        let route = Files.alphaGetMetadata
        let serverArgs = Files.AlphaGetMetadataArg(path: path, includeMediaInfo: includeMediaInfo, includeDeleted: includeDeleted, includeHasExplicitSharedMembers: includeHasExplicitSharedMembers, includePropertyTemplates: includePropertyTemplates)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Create a new file with the contents provided in the request. Note that this endpoint is part of the properties
    /// API alpha and is slightly different from upload. Do not use this to upload a file larger than 150 MB. Instead,
    /// create an upload session with uploadSessionStart.
    ///
    /// - parameter propertyGroups: List of custom properties to add to file.
    /// - parameter input: The file to upload, as an Data object.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Files.FileMetadata` object on success or a
    /// `Files.UploadErrorWithProperties` object on failure.
    @discardableResult open func alphaUpload(path: String, mode: Files.WriteMode = .add, autorename: Bool = false, clientModified: Date? = nil, mute: Bool = false, propertyGroups: Array<FileProperties.PropertyGroup>? = nil, input: Data) -> UploadRequest<Files.FileMetadataSerializer, Files.UploadErrorWithPropertiesSerializer> {
        let route = Files.alphaUpload
        let serverArgs = Files.CommitInfoWithProperties(path: path, mode: mode, autorename: autorename, clientModified: clientModified, mute: mute, propertyGroups: propertyGroups)
        return client.request(route, serverArgs: serverArgs, input: .data(input))
    }

    /// Create a new file with the contents provided in the request. Note that this endpoint is part of the properties
    /// API alpha and is slightly different from upload. Do not use this to upload a file larger than 150 MB. Instead,
    /// create an upload session with uploadSessionStart.
    ///
    /// - parameter propertyGroups: List of custom properties to add to file.
    /// - parameter input: The file to upload, as an URL object.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Files.FileMetadata` object on success or a
    /// `Files.UploadErrorWithProperties` object on failure.
    @discardableResult open func alphaUpload(path: String, mode: Files.WriteMode = .add, autorename: Bool = false, clientModified: Date? = nil, mute: Bool = false, propertyGroups: Array<FileProperties.PropertyGroup>? = nil, input: URL) -> UploadRequest<Files.FileMetadataSerializer, Files.UploadErrorWithPropertiesSerializer> {
        let route = Files.alphaUpload
        let serverArgs = Files.CommitInfoWithProperties(path: path, mode: mode, autorename: autorename, clientModified: clientModified, mute: mute, propertyGroups: propertyGroups)
        return client.request(route, serverArgs: serverArgs, input: .file(input))
    }

    /// Create a new file with the contents provided in the request. Note that this endpoint is part of the properties
    /// API alpha and is slightly different from upload. Do not use this to upload a file larger than 150 MB. Instead,
    /// create an upload session with uploadSessionStart.
    ///
    /// - parameter propertyGroups: List of custom properties to add to file.
    /// - parameter input: The file to upload, as an InputStream object.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Files.FileMetadata` object on success or a
    /// `Files.UploadErrorWithProperties` object on failure.
    @discardableResult open func alphaUpload(path: String, mode: Files.WriteMode = .add, autorename: Bool = false, clientModified: Date? = nil, mute: Bool = false, propertyGroups: Array<FileProperties.PropertyGroup>? = nil, input: InputStream) -> UploadRequest<Files.FileMetadataSerializer, Files.UploadErrorWithPropertiesSerializer> {
        let route = Files.alphaUpload
        let serverArgs = Files.CommitInfoWithProperties(path: path, mode: mode, autorename: autorename, clientModified: clientModified, mute: mute, propertyGroups: propertyGroups)
        return client.request(route, serverArgs: serverArgs, input: .stream(input))
    }

    /// Copy a file or folder to a different location in the user's Dropbox. If the source path is a folder all its
    /// contents will be copied.
    ///
    /// - parameter allowSharedFolder: If true, copy will copy contents in shared folder, otherwise cantCopySharedFolder
    /// in RelocationError will be returned if fromPath contains shared folder. This field is always true for move.
    /// - parameter autorename: If there's a conflict, have the Dropbox server try to autorename the file to avoid the
    /// conflict.
    /// - parameter allowOwnershipTransfer: Allow moves by owner even if it would result in an ownership transfer for
    /// the content being moved. This does not apply to copies.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Files.Metadata` object on success or a
    /// `Files.RelocationError` object on failure.
    @available(*, unavailable, message:"copy is deprecated. Use copy_v2.")
    @discardableResult open func copy(fromPath: String, toPath: String, allowSharedFolder: Bool = false, autorename: Bool = false, allowOwnershipTransfer: Bool = false) -> RpcRequest<Files.MetadataSerializer, Files.RelocationErrorSerializer> {
        let route = Files.copy
        let serverArgs = Files.RelocationArg(fromPath: fromPath, toPath: toPath, allowSharedFolder: allowSharedFolder, autorename: autorename, allowOwnershipTransfer: allowOwnershipTransfer)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Copy multiple files or folders to different locations at once in the user's Dropbox. If allowSharedFolder in
    /// RelocationBatchArg is false, this route is atomic. If on entry failes, the whole transaction will abort. If
    /// allowSharedFolder in RelocationBatchArg is true, not atomicity is guaranteed, but you will be able to copy the
    /// contents of shared folders to new locations. This route will return job ID immediately and do the async copy job
    /// in background. Please use copyBatchCheck to check the job status.
    ///
    /// - parameter entries: List of entries to be moved or copied. Each entry is RelocationPath.
    /// - parameter allowSharedFolder: If true, copyBatch will copy contents in shared folder, otherwise
    /// cantCopySharedFolder in RelocationError will be returned if fromPath in RelocationPath contains shared folder.
    /// This field is always true for moveBatch.
    /// - parameter autorename: If there's a conflict with any file, have the Dropbox server try to autorename that file
    /// to avoid the conflict.
    /// - parameter allowOwnershipTransfer: Allow moves by owner even if it would result in an ownership transfer for
    /// the content being moved. This does not apply to copies.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Files.RelocationBatchLaunch` object on
    /// success or a `Void` object on failure.
    @discardableResult open func copyBatch(entries: Array<Files.RelocationPath>, allowSharedFolder: Bool = false, autorename: Bool = false, allowOwnershipTransfer: Bool = false) -> RpcRequest<Files.RelocationBatchLaunchSerializer, VoidSerializer> {
        let route = Files.copyBatch
        let serverArgs = Files.RelocationBatchArg(entries: entries, allowSharedFolder: allowSharedFolder, autorename: autorename, allowOwnershipTransfer: allowOwnershipTransfer)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Returns the status of an asynchronous job for copyBatch. If success, it returns list of results for each entry.
    ///
    /// - parameter asyncJobId: Id of the asynchronous job. This is the value of a response returned from the method
    /// that launched the job.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Files.RelocationBatchJobStatus` object on
    /// success or a `Async.PollError` object on failure.
    @discardableResult open func copyBatchCheck(asyncJobId: String) -> RpcRequest<Files.RelocationBatchJobStatusSerializer, Async.PollErrorSerializer> {
        let route = Files.copyBatchCheck
        let serverArgs = Async.PollArg(asyncJobId: asyncJobId)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Get a copy reference to a file or folder. This reference string can be used to save that file or folder to
    /// another user's Dropbox by passing it to copyReferenceSave.
    ///
    /// - parameter path: The path to the file or folder you want to get a copy reference to.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Files.GetCopyReferenceResult` object on
    /// success or a `Files.GetCopyReferenceError` object on failure.
    @discardableResult open func copyReferenceGet(path: String) -> RpcRequest<Files.GetCopyReferenceResultSerializer, Files.GetCopyReferenceErrorSerializer> {
        let route = Files.copyReferenceGet
        let serverArgs = Files.GetCopyReferenceArg(path: path)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Save a copy reference returned by copyReferenceGet to the user's Dropbox.
    ///
    /// - parameter copyReference: A copy reference returned by copyReferenceGet.
    /// - parameter path: Path in the user's Dropbox that is the destination.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Files.SaveCopyReferenceResult` object on
    /// success or a `Files.SaveCopyReferenceError` object on failure.
    @discardableResult open func copyReferenceSave(copyReference: String, path: String) -> RpcRequest<Files.SaveCopyReferenceResultSerializer, Files.SaveCopyReferenceErrorSerializer> {
        let route = Files.copyReferenceSave
        let serverArgs = Files.SaveCopyReferenceArg(copyReference: copyReference, path: path)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Copy a file or folder to a different location in the user's Dropbox. If the source path is a folder all its
    /// contents will be copied.
    ///
    /// - parameter allowSharedFolder: If true, copy will copy contents in shared folder, otherwise cantCopySharedFolder
    /// in RelocationError will be returned if fromPath contains shared folder. This field is always true for move.
    /// - parameter autorename: If there's a conflict, have the Dropbox server try to autorename the file to avoid the
    /// conflict.
    /// - parameter allowOwnershipTransfer: Allow moves by owner even if it would result in an ownership transfer for
    /// the content being moved. This does not apply to copies.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Files.RelocationResult` object on success
    /// or a `Files.RelocationError` object on failure.
    @discardableResult open func copyV2(fromPath: String, toPath: String, allowSharedFolder: Bool = false, autorename: Bool = false, allowOwnershipTransfer: Bool = false) -> RpcRequest<Files.RelocationResultSerializer, Files.RelocationErrorSerializer> {
        let route = Files.copyV2
        let serverArgs = Files.RelocationArg(fromPath: fromPath, toPath: toPath, allowSharedFolder: allowSharedFolder, autorename: autorename, allowOwnershipTransfer: allowOwnershipTransfer)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Create a folder at a given path.
    ///
    /// - parameter path: Path in the user's Dropbox to create.
    /// - parameter autorename: If there's a conflict, have the Dropbox server try to autorename the folder to avoid the
    /// conflict.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Files.FolderMetadata` object on success or
    /// a `Files.CreateFolderError` object on failure.
    @available(*, unavailable, message:"create_folder is deprecated. Use create_folder_v2.")
    @discardableResult open func createFolder(path: String, autorename: Bool = false) -> RpcRequest<Files.FolderMetadataSerializer, Files.CreateFolderErrorSerializer> {
        let route = Files.createFolder
        let serverArgs = Files.CreateFolderArg(path: path, autorename: autorename)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Create a folder at a given path.
    ///
    /// - parameter path: Path in the user's Dropbox to create.
    /// - parameter autorename: If there's a conflict, have the Dropbox server try to autorename the folder to avoid the
    /// conflict.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Files.CreateFolderResult` object on
    /// success or a `Files.CreateFolderError` object on failure.
    @discardableResult open func createFolderV2(path: String, autorename: Bool = false) -> RpcRequest<Files.CreateFolderResultSerializer, Files.CreateFolderErrorSerializer> {
        let route = Files.createFolderV2
        let serverArgs = Files.CreateFolderArg(path: path, autorename: autorename)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Delete the file or folder at a given path. If the path is a folder, all its contents will be deleted too. A
    /// successful response indicates that the file or folder was deleted. The returned metadata will be the
    /// corresponding FileMetadata or FolderMetadata for the item at time of deletion, and not a DeletedMetadata object.
    ///
    /// - parameter path: Path in the user's Dropbox to delete.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Files.Metadata` object on success or a
    /// `Files.DeleteError` object on failure.
    @available(*, unavailable, message:"delete is deprecated. Use delete_v2.")
    @discardableResult open func delete(path: String) -> RpcRequest<Files.MetadataSerializer, Files.DeleteErrorSerializer> {
        let route = Files.delete
        let serverArgs = Files.DeleteArg(path: path)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Delete multiple files/folders at once. This route is asynchronous, which returns a job ID immediately and runs
    /// the delete batch asynchronously. Use deleteBatchCheck to check the job status.
    ///
    ///
    ///  - returns: Through the response callback, the caller will receive a `Files.DeleteBatchLaunch` object on success
    /// or a `Void` object on failure.
    @discardableResult open func deleteBatch(entries: Array<Files.DeleteArg>) -> RpcRequest<Files.DeleteBatchLaunchSerializer, VoidSerializer> {
        let route = Files.deleteBatch
        let serverArgs = Files.DeleteBatchArg(entries: entries)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Returns the status of an asynchronous job for deleteBatch. If success, it returns list of result for each entry.
    ///
    /// - parameter asyncJobId: Id of the asynchronous job. This is the value of a response returned from the method
    /// that launched the job.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Files.DeleteBatchJobStatus` object on
    /// success or a `Async.PollError` object on failure.
    @discardableResult open func deleteBatchCheck(asyncJobId: String) -> RpcRequest<Files.DeleteBatchJobStatusSerializer, Async.PollErrorSerializer> {
        let route = Files.deleteBatchCheck
        let serverArgs = Async.PollArg(asyncJobId: asyncJobId)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Delete the file or folder at a given path. If the path is a folder, all its contents will be deleted too. A
    /// successful response indicates that the file or folder was deleted. The returned metadata will be the
    /// corresponding FileMetadata or FolderMetadata for the item at time of deletion, and not a DeletedMetadata object.
    ///
    /// - parameter path: Path in the user's Dropbox to delete.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Files.DeleteResult` object on success or a
    /// `Files.DeleteError` object on failure.
    @discardableResult open func deleteV2(path: String) -> RpcRequest<Files.DeleteResultSerializer, Files.DeleteErrorSerializer> {
        let route = Files.deleteV2
        let serverArgs = Files.DeleteArg(path: path)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Download a file from a user's Dropbox.
    ///
    /// - parameter path: The path of the file to download.
    /// - parameter rev: Please specify revision in path instead.
    /// - parameter overwrite: A boolean to set behavior in the event of a naming conflict. `True` will overwrite
    /// conflicting file at destination. `False` will take no action (but if left unhandled in destination closure, an
    /// NSError will be thrown).
    /// - parameter destination: A closure used to compute the destination, given the temporary file location and the
    /// response.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Files.FileMetadata` object on success or a
    /// `Files.DownloadError` object on failure.
    @discardableResult open func download(path: String, rev: String? = nil, overwrite: Bool = false, destination: @escaping (URL, HTTPURLResponse) -> URL) -> DownloadRequestFile<Files.FileMetadataSerializer, Files.DownloadErrorSerializer> {
        let route = Files.download
        let serverArgs = Files.DownloadArg(path: path, rev: rev)
        return client.request(route, serverArgs: serverArgs, overwrite: overwrite, destination: destination)
    }

    /// Download a file from a user's Dropbox.
    ///
    /// - parameter path: The path of the file to download.
    /// - parameter rev: Please specify revision in path instead.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Files.FileMetadata` object on success or a
    /// `Files.DownloadError` object on failure.
    @discardableResult open func download(path: String, rev: String? = nil) -> DownloadRequestMemory<Files.FileMetadataSerializer, Files.DownloadErrorSerializer> {
        let route = Files.download
        let serverArgs = Files.DownloadArg(path: path, rev: rev)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Returns the metadata for a file or folder. Note: Metadata for the root folder is unsupported.
    ///
    /// - parameter path: The path of a file or folder on Dropbox.
    /// - parameter includeMediaInfo: If true, mediaInfo in FileMetadata is set for photo and video.
    /// - parameter includeDeleted: If true, DeletedMetadata will be returned for deleted file or folder, otherwise
    /// notFound in LookupError will be returned.
    /// - parameter includeHasExplicitSharedMembers: If true, the results will include a flag for each file indicating
    /// whether or not  that file has any explicit members.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Files.Metadata` object on success or a
    /// `Files.GetMetadataError` object on failure.
    @discardableResult open func getMetadata(path: String, includeMediaInfo: Bool = false, includeDeleted: Bool = false, includeHasExplicitSharedMembers: Bool = false) -> RpcRequest<Files.MetadataSerializer, Files.GetMetadataErrorSerializer> {
        let route = Files.getMetadata
        let serverArgs = Files.GetMetadataArg(path: path, includeMediaInfo: includeMediaInfo, includeDeleted: includeDeleted, includeHasExplicitSharedMembers: includeHasExplicitSharedMembers)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Get a preview for a file. Currently, PDF previews are generated for files with the following extensions: .ai,
    /// .doc, .docm, .docx, .eps, .odp, .odt, .pps, .ppsm, .ppsx, .ppt, .pptm, .pptx, .rtf. HTML previews are generated
    /// for files with the following extensions: .csv, .ods, .xls, .xlsm, .xlsx. Other formats will return an
    /// unsupported extension error.
    ///
    /// - parameter path: The path of the file to preview.
    /// - parameter rev: Please specify revision in path instead.
    /// - parameter overwrite: A boolean to set behavior in the event of a naming conflict. `True` will overwrite
    /// conflicting file at destination. `False` will take no action (but if left unhandled in destination closure, an
    /// NSError will be thrown).
    /// - parameter destination: A closure used to compute the destination, given the temporary file location and the
    /// response.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Files.FileMetadata` object on success or a
    /// `Files.PreviewError` object on failure.
    @discardableResult open func getPreview(path: String, rev: String? = nil, overwrite: Bool = false, destination: @escaping (URL, HTTPURLResponse) -> URL) -> DownloadRequestFile<Files.FileMetadataSerializer, Files.PreviewErrorSerializer> {
        let route = Files.getPreview
        let serverArgs = Files.PreviewArg(path: path, rev: rev)
        return client.request(route, serverArgs: serverArgs, overwrite: overwrite, destination: destination)
    }

    /// Get a preview for a file. Currently, PDF previews are generated for files with the following extensions: .ai,
    /// .doc, .docm, .docx, .eps, .odp, .odt, .pps, .ppsm, .ppsx, .ppt, .pptm, .pptx, .rtf. HTML previews are generated
    /// for files with the following extensions: .csv, .ods, .xls, .xlsm, .xlsx. Other formats will return an
    /// unsupported extension error.
    ///
    /// - parameter path: The path of the file to preview.
    /// - parameter rev: Please specify revision in path instead.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Files.FileMetadata` object on success or a
    /// `Files.PreviewError` object on failure.
    @discardableResult open func getPreview(path: String, rev: String? = nil) -> DownloadRequestMemory<Files.FileMetadataSerializer, Files.PreviewErrorSerializer> {
        let route = Files.getPreview
        let serverArgs = Files.PreviewArg(path: path, rev: rev)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Get a temporary link to stream content of a file. This link will expire in four hours and afterwards you will
    /// get 410 Gone. Content-Type of the link is determined automatically by the file's mime type.
    ///
    /// - parameter path: The path to the file you want a temporary link to.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Files.GetTemporaryLinkResult` object on
    /// success or a `Files.GetTemporaryLinkError` object on failure.
    @discardableResult open func getTemporaryLink(path: String) -> RpcRequest<Files.GetTemporaryLinkResultSerializer, Files.GetTemporaryLinkErrorSerializer> {
        let route = Files.getTemporaryLink
        let serverArgs = Files.GetTemporaryLinkArg(path: path)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Get a thumbnail for an image. This method currently supports files with the following file extensions: jpg,
    /// jpeg, png, tiff, tif, gif and bmp. Photos that are larger than 20MB in size won't be converted to a thumbnail.
    ///
    /// - parameter path: The path to the image file you want to thumbnail.
    /// - parameter format: The format for the thumbnail image, jpeg (default) or png. For  images that are photos, jpeg
    /// should be preferred, while png is  better for screenshots and digital arts.
    /// - parameter size: The size for the thumbnail image.
    /// - parameter overwrite: A boolean to set behavior in the event of a naming conflict. `True` will overwrite
    /// conflicting file at destination. `False` will take no action (but if left unhandled in destination closure, an
    /// NSError will be thrown).
    /// - parameter destination: A closure used to compute the destination, given the temporary file location and the
    /// response.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Files.FileMetadata` object on success or a
    /// `Files.ThumbnailError` object on failure.
    @discardableResult open func getThumbnail(path: String, format: Files.ThumbnailFormat = .jpeg, size: Files.ThumbnailSize = .w64h64, overwrite: Bool = false, destination: @escaping (URL, HTTPURLResponse) -> URL) -> DownloadRequestFile<Files.FileMetadataSerializer, Files.ThumbnailErrorSerializer> {
        let route = Files.getThumbnail
        let serverArgs = Files.ThumbnailArg(path: path, format: format, size: size)
        return client.request(route, serverArgs: serverArgs, overwrite: overwrite, destination: destination)
    }

    /// Get a thumbnail for an image. This method currently supports files with the following file extensions: jpg,
    /// jpeg, png, tiff, tif, gif and bmp. Photos that are larger than 20MB in size won't be converted to a thumbnail.
    ///
    /// - parameter path: The path to the image file you want to thumbnail.
    /// - parameter format: The format for the thumbnail image, jpeg (default) or png. For  images that are photos, jpeg
    /// should be preferred, while png is  better for screenshots and digital arts.
    /// - parameter size: The size for the thumbnail image.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Files.FileMetadata` object on success or a
    /// `Files.ThumbnailError` object on failure.
    @discardableResult open func getThumbnail(path: String, format: Files.ThumbnailFormat = .jpeg, size: Files.ThumbnailSize = .w64h64) -> DownloadRequestMemory<Files.FileMetadataSerializer, Files.ThumbnailErrorSerializer> {
        let route = Files.getThumbnail
        let serverArgs = Files.ThumbnailArg(path: path, format: format, size: size)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Get thumbnails for a list of images. We allow up to 25 thumbnails in a single batch. This method currently
    /// supports files with the following file extensions: jpg, jpeg, png, tiff, tif, gif and bmp. Photos that are
    /// larger than 20MB in size won't be converted to a thumbnail.
    ///
    /// - parameter entries: List of files to get thumbnails.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Files.GetThumbnailBatchResult` object on
    /// success or a `Files.GetThumbnailBatchError` object on failure.
    @discardableResult open func getThumbnailBatch(entries: Array<Files.ThumbnailArg>) -> RpcRequest<Files.GetThumbnailBatchResultSerializer, Files.GetThumbnailBatchErrorSerializer> {
        let route = Files.getThumbnailBatch
        let serverArgs = Files.GetThumbnailBatchArg(entries: entries)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Starts returning the contents of a folder. If the result's hasMore in ListFolderResult field is true, call
    /// listFolderContinue with the returned cursor in ListFolderResult to retrieve more entries. If you're using
    /// recursive in ListFolderArg set to true to keep a local cache of the contents of a Dropbox account, iterate
    /// through each entry in order and process them as follows to keep your local state in sync: For each FileMetadata,
    /// store the new entry at the given path in your local state. If the required parent folders don't exist yet,
    /// create them. If there's already something else at the given path, replace it and remove all its children. For
    /// each FolderMetadata, store the new entry at the given path in your local state. If the required parent folders
    /// don't exist yet, create them. If there's already something else at the given path, replace it but leave the
    /// children as they are. Check the new entry's readOnly in FolderSharingInfo and set all its children's read-only
    /// statuses to match. For each DeletedMetadata, if your local state has something at the given path, remove it and
    /// all its children. If there's nothing at the given path, ignore this entry. Note: auth.RateLimitError may be
    /// returned if multiple listFolder or listFolderContinue calls with same parameters are made simultaneously by same
    /// API app for same user. If your app implements retry logic, please hold off the retry until the previous request
    /// finishes.
    ///
    /// - parameter path: A unique identifier for the file.
    /// - parameter recursive: If true, the list folder operation will be applied recursively to all subfolders and the
    /// response will contain contents of all subfolders.
    /// - parameter includeMediaInfo: If true, mediaInfo in FileMetadata is set for photo and video.
    /// - parameter includeDeleted: If true, the results will include entries for files and folders that used to exist
    /// but were deleted.
    /// - parameter includeHasExplicitSharedMembers: If true, the results will include a flag for each file indicating
    /// whether or not  that file has any explicit members.
    /// - parameter includeMountedFolders: If true, the results will include entries under mounted folders which
    /// includes app folder, shared folder and team folder.
    /// - parameter limit: The maximum number of results to return per request. Note: This is an approximate number and
    /// there can be slightly more entries returned in some cases.
    /// - parameter sharedLink: A shared link to list the contents of. If the link is password-protected, the password
    /// must be provided. If this field is present, path in ListFolderArg will be relative to root of the shared link.
    /// Only non-recursive mode is supported for shared link.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Files.ListFolderResult` object on success
    /// or a `Files.ListFolderError` object on failure.
    @discardableResult open func listFolder(path: String, recursive: Bool = false, includeMediaInfo: Bool = false, includeDeleted: Bool = false, includeHasExplicitSharedMembers: Bool = false, includeMountedFolders: Bool = true, limit: UInt32? = nil, sharedLink: Files.SharedLink? = nil) -> RpcRequest<Files.ListFolderResultSerializer, Files.ListFolderErrorSerializer> {
        let route = Files.listFolder
        let serverArgs = Files.ListFolderArg(path: path, recursive: recursive, includeMediaInfo: includeMediaInfo, includeDeleted: includeDeleted, includeHasExplicitSharedMembers: includeHasExplicitSharedMembers, includeMountedFolders: includeMountedFolders, limit: limit, sharedLink: sharedLink)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Once a cursor has been retrieved from listFolder, use this to paginate through all files and retrieve updates to
    /// the folder, following the same rules as documented for listFolder.
    ///
    /// - parameter cursor: The cursor returned by your last call to listFolder or listFolderContinue.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Files.ListFolderResult` object on success
    /// or a `Files.ListFolderContinueError` object on failure.
    @discardableResult open func listFolderContinue(cursor: String) -> RpcRequest<Files.ListFolderResultSerializer, Files.ListFolderContinueErrorSerializer> {
        let route = Files.listFolderContinue
        let serverArgs = Files.ListFolderContinueArg(cursor: cursor)
        return client.request(route, serverArgs: serverArgs)
    }

    /// A way to quickly get a cursor for the folder's state. Unlike listFolder, listFolderGetLatestCursor doesn't
    /// return any entries. This endpoint is for app which only needs to know about new files and modifications and
    /// doesn't need to know about files that already exist in Dropbox.
    ///
    /// - parameter path: A unique identifier for the file.
    /// - parameter recursive: If true, the list folder operation will be applied recursively to all subfolders and the
    /// response will contain contents of all subfolders.
    /// - parameter includeMediaInfo: If true, mediaInfo in FileMetadata is set for photo and video.
    /// - parameter includeDeleted: If true, the results will include entries for files and folders that used to exist
    /// but were deleted.
    /// - parameter includeHasExplicitSharedMembers: If true, the results will include a flag for each file indicating
    /// whether or not  that file has any explicit members.
    /// - parameter includeMountedFolders: If true, the results will include entries under mounted folders which
    /// includes app folder, shared folder and team folder.
    /// - parameter limit: The maximum number of results to return per request. Note: This is an approximate number and
    /// there can be slightly more entries returned in some cases.
    /// - parameter sharedLink: A shared link to list the contents of. If the link is password-protected, the password
    /// must be provided. If this field is present, path in ListFolderArg will be relative to root of the shared link.
    /// Only non-recursive mode is supported for shared link.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Files.ListFolderGetLatestCursorResult`
    /// object on success or a `Files.ListFolderError` object on failure.
    @discardableResult open func listFolderGetLatestCursor(path: String, recursive: Bool = false, includeMediaInfo: Bool = false, includeDeleted: Bool = false, includeHasExplicitSharedMembers: Bool = false, includeMountedFolders: Bool = true, limit: UInt32? = nil, sharedLink: Files.SharedLink? = nil) -> RpcRequest<Files.ListFolderGetLatestCursorResultSerializer, Files.ListFolderErrorSerializer> {
        let route = Files.listFolderGetLatestCursor
        let serverArgs = Files.ListFolderArg(path: path, recursive: recursive, includeMediaInfo: includeMediaInfo, includeDeleted: includeDeleted, includeHasExplicitSharedMembers: includeHasExplicitSharedMembers, includeMountedFolders: includeMountedFolders, limit: limit, sharedLink: sharedLink)
        return client.request(route, serverArgs: serverArgs)
    }

    /// A longpoll endpoint to wait for changes on an account. In conjunction with listFolderContinue, this call gives
    /// you a low-latency way to monitor an account for file changes. The connection will block until there are changes
    /// available or a timeout occurs. This endpoint is useful mostly for client-side apps. If you're looking for
    /// server-side notifications, check out our webhooks documentation
    /// https://www.dropbox.com/developers/reference/webhooks.
    ///
    /// - parameter cursor: A cursor as returned by listFolder or listFolderContinue. Cursors retrieved by setting
    /// includeMediaInfo in ListFolderArg to true are not supported.
    /// - parameter timeout: A timeout in seconds. The request will block for at most this length of time, plus up to 90
    /// seconds of random jitter added to avoid the thundering herd problem. Care should be taken when using this
    /// parameter, as some network infrastructure does not support long timeouts.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Files.ListFolderLongpollResult` object on
    /// success or a `Files.ListFolderLongpollError` object on failure.
    @discardableResult open func listFolderLongpoll(cursor: String, timeout: UInt64 = 30) -> RpcRequest<Files.ListFolderLongpollResultSerializer, Files.ListFolderLongpollErrorSerializer> {
        let route = Files.listFolderLongpoll
        let serverArgs = Files.ListFolderLongpollArg(cursor: cursor, timeout: timeout)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Returns revisions for files based on a file path or a file id. The file path or file id is identified from the
    /// latest file entry at the given file path or id. This end point allows your app to query either by file path or
    /// file id by setting the mode parameter appropriately. In the path in ListRevisionsMode (default) mode, all
    /// revisions at the same file path as the latest file entry are returned. If revisions with the same file id are
    /// desired, then mode must be set to id in ListRevisionsMode. The id in ListRevisionsMode mode is useful to
    /// retrieve revisions for a given file across moves or renames.
    ///
    /// - parameter path: The path to the file you want to see the revisions of.
    /// - parameter mode: Determines the behavior of the API in listing the revisions for a given file path or id.
    /// - parameter limit: The maximum number of revision entries returned.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Files.ListRevisionsResult` object on
    /// success or a `Files.ListRevisionsError` object on failure.
    @discardableResult open func listRevisions(path: String, mode: Files.ListRevisionsMode = .path, limit: UInt64 = 10) -> RpcRequest<Files.ListRevisionsResultSerializer, Files.ListRevisionsErrorSerializer> {
        let route = Files.listRevisions
        let serverArgs = Files.ListRevisionsArg(path: path, mode: mode, limit: limit)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Move a file or folder to a different location in the user's Dropbox. If the source path is a folder all its
    /// contents will be moved.
    ///
    /// - parameter allowSharedFolder: If true, copy will copy contents in shared folder, otherwise cantCopySharedFolder
    /// in RelocationError will be returned if fromPath contains shared folder. This field is always true for move.
    /// - parameter autorename: If there's a conflict, have the Dropbox server try to autorename the file to avoid the
    /// conflict.
    /// - parameter allowOwnershipTransfer: Allow moves by owner even if it would result in an ownership transfer for
    /// the content being moved. This does not apply to copies.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Files.Metadata` object on success or a
    /// `Files.RelocationError` object on failure.
    @available(*, unavailable, message:"move is deprecated. Use move_v2.")
    @discardableResult open func move(fromPath: String, toPath: String, allowSharedFolder: Bool = false, autorename: Bool = false, allowOwnershipTransfer: Bool = false) -> RpcRequest<Files.MetadataSerializer, Files.RelocationErrorSerializer> {
        let route = Files.move
        let serverArgs = Files.RelocationArg(fromPath: fromPath, toPath: toPath, allowSharedFolder: allowSharedFolder, autorename: autorename, allowOwnershipTransfer: allowOwnershipTransfer)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Move multiple files or folders to different locations at once in the user's Dropbox. This route is 'all or
    /// nothing', which means if one entry fails, the whole transaction will abort. This route will return job ID
    /// immediately and do the async moving job in background. Please use moveBatchCheck to check the job status.
    ///
    /// - parameter entries: List of entries to be moved or copied. Each entry is RelocationPath.
    /// - parameter allowSharedFolder: If true, copyBatch will copy contents in shared folder, otherwise
    /// cantCopySharedFolder in RelocationError will be returned if fromPath in RelocationPath contains shared folder.
    /// This field is always true for moveBatch.
    /// - parameter autorename: If there's a conflict with any file, have the Dropbox server try to autorename that file
    /// to avoid the conflict.
    /// - parameter allowOwnershipTransfer: Allow moves by owner even if it would result in an ownership transfer for
    /// the content being moved. This does not apply to copies.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Files.RelocationBatchLaunch` object on
    /// success or a `Void` object on failure.
    @discardableResult open func moveBatch(entries: Array<Files.RelocationPath>, allowSharedFolder: Bool = false, autorename: Bool = false, allowOwnershipTransfer: Bool = false) -> RpcRequest<Files.RelocationBatchLaunchSerializer, VoidSerializer> {
        let route = Files.moveBatch
        let serverArgs = Files.RelocationBatchArg(entries: entries, allowSharedFolder: allowSharedFolder, autorename: autorename, allowOwnershipTransfer: allowOwnershipTransfer)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Returns the status of an asynchronous job for moveBatch. If success, it returns list of results for each entry.
    ///
    /// - parameter asyncJobId: Id of the asynchronous job. This is the value of a response returned from the method
    /// that launched the job.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Files.RelocationBatchJobStatus` object on
    /// success or a `Async.PollError` object on failure.
    @discardableResult open func moveBatchCheck(asyncJobId: String) -> RpcRequest<Files.RelocationBatchJobStatusSerializer, Async.PollErrorSerializer> {
        let route = Files.moveBatchCheck
        let serverArgs = Async.PollArg(asyncJobId: asyncJobId)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Move a file or folder to a different location in the user's Dropbox. If the source path is a folder all its
    /// contents will be moved.
    ///
    /// - parameter allowSharedFolder: If true, copy will copy contents in shared folder, otherwise cantCopySharedFolder
    /// in RelocationError will be returned if fromPath contains shared folder. This field is always true for move.
    /// - parameter autorename: If there's a conflict, have the Dropbox server try to autorename the file to avoid the
    /// conflict.
    /// - parameter allowOwnershipTransfer: Allow moves by owner even if it would result in an ownership transfer for
    /// the content being moved. This does not apply to copies.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Files.RelocationResult` object on success
    /// or a `Files.RelocationError` object on failure.
    @discardableResult open func moveV2(fromPath: String, toPath: String, allowSharedFolder: Bool = false, autorename: Bool = false, allowOwnershipTransfer: Bool = false) -> RpcRequest<Files.RelocationResultSerializer, Files.RelocationErrorSerializer> {
        let route = Files.moveV2
        let serverArgs = Files.RelocationArg(fromPath: fromPath, toPath: toPath, allowSharedFolder: allowSharedFolder, autorename: autorename, allowOwnershipTransfer: allowOwnershipTransfer)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Permanently delete the file or folder at a given path (see https://www.dropbox.com/en/help/40). Note: This
    /// endpoint is only available for Dropbox Business apps.
    ///
    /// - parameter path: Path in the user's Dropbox to delete.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Void` object on success or a
    /// `Files.DeleteError` object on failure.
    @discardableResult open func permanentlyDelete(path: String) -> RpcRequest<VoidSerializer, Files.DeleteErrorSerializer> {
        let route = Files.permanentlyDelete
        let serverArgs = Files.DeleteArg(path: path)
        return client.request(route, serverArgs: serverArgs)
    }

    /// The propertiesAdd route
    ///
    /// - parameter path: A unique identifier for the file or folder.
    /// - parameter propertyGroups: The property groups which are to be added to a Dropbox file.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Void` object on success or a
    /// `FileProperties.AddPropertiesError` object on failure.
    @available(*, unavailable, message:"properties/add is deprecated.")
    @discardableResult open func propertiesAdd(path: String, propertyGroups: Array<FileProperties.PropertyGroup>) -> RpcRequest<VoidSerializer, FileProperties.AddPropertiesErrorSerializer> {
        let route = Files.propertiesAdd
        let serverArgs = FileProperties.AddPropertiesArg(path: path, propertyGroups: propertyGroups)
        return client.request(route, serverArgs: serverArgs)
    }

    /// The propertiesOverwrite route
    ///
    /// - parameter path: A unique identifier for the file or folder.
    /// - parameter propertyGroups: The property groups "snapshot" updates to force apply.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Void` object on success or a
    /// `FileProperties.InvalidPropertyGroupError` object on failure.
    @available(*, unavailable, message:"properties/overwrite is deprecated.")
    @discardableResult open func propertiesOverwrite(path: String, propertyGroups: Array<FileProperties.PropertyGroup>) -> RpcRequest<VoidSerializer, FileProperties.InvalidPropertyGroupErrorSerializer> {
        let route = Files.propertiesOverwrite
        let serverArgs = FileProperties.OverwritePropertyGroupArg(path: path, propertyGroups: propertyGroups)
        return client.request(route, serverArgs: serverArgs)
    }

    /// The propertiesRemove route
    ///
    /// - parameter path: A unique identifier for the file or folder.
    /// - parameter propertyTemplateIds: A list of identifiers for a template created by templatesAddForUser or
    /// templatesAddForTeam.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Void` object on success or a
    /// `FileProperties.RemovePropertiesError` object on failure.
    @available(*, unavailable, message:"properties/remove is deprecated.")
    @discardableResult open func propertiesRemove(path: String, propertyTemplateIds: Array<String>) -> RpcRequest<VoidSerializer, FileProperties.RemovePropertiesErrorSerializer> {
        let route = Files.propertiesRemove
        let serverArgs = FileProperties.RemovePropertiesArg(path: path, propertyTemplateIds: propertyTemplateIds)
        return client.request(route, serverArgs: serverArgs)
    }

    /// The propertiesTemplateGet route
    ///
    /// - parameter templateId: An identifier for template added by route  See templatesAddForUser or
    /// templatesAddForTeam.
    ///
    ///  - returns: Through the response callback, the caller will receive a `FileProperties.GetTemplateResult` object
    /// on success or a `FileProperties.TemplateError` object on failure.
    @available(*, unavailable, message:"properties/template/get is deprecated.")
    @discardableResult open func propertiesTemplateGet(templateId: String) -> RpcRequest<FileProperties.GetTemplateResultSerializer, FileProperties.TemplateErrorSerializer> {
        let route = Files.propertiesTemplateGet
        let serverArgs = FileProperties.GetTemplateArg(templateId: templateId)
        return client.request(route, serverArgs: serverArgs)
    }

    /// The propertiesTemplateList route
    ///
    ///
    ///  - returns: Through the response callback, the caller will receive a `FileProperties.ListTemplateResult` object
    /// on success or a `FileProperties.TemplateError` object on failure.
    @available(*, unavailable, message:"properties/template/list is deprecated.")
    @discardableResult open func propertiesTemplateList() -> RpcRequest<FileProperties.ListTemplateResultSerializer, FileProperties.TemplateErrorSerializer> {
        let route = Files.propertiesTemplateList
        return client.request(route)
    }

    /// The propertiesUpdate route
    ///
    /// - parameter path: A unique identifier for the file or folder.
    /// - parameter updatePropertyGroups: The property groups "delta" updates to apply.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Void` object on success or a
    /// `FileProperties.UpdatePropertiesError` object on failure.
    @available(*, unavailable, message:"properties/update is deprecated.")
    @discardableResult open func propertiesUpdate(path: String, updatePropertyGroups: Array<FileProperties.PropertyGroupUpdate>) -> RpcRequest<VoidSerializer, FileProperties.UpdatePropertiesErrorSerializer> {
        let route = Files.propertiesUpdate
        let serverArgs = FileProperties.UpdatePropertiesArg(path: path, updatePropertyGroups: updatePropertyGroups)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Restore a file to a specific revision.
    ///
    /// - parameter path: The path to the file you want to restore.
    /// - parameter rev: The revision to restore for the file.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Files.FileMetadata` object on success or a
    /// `Files.RestoreError` object on failure.
    @discardableResult open func restore(path: String, rev: String) -> RpcRequest<Files.FileMetadataSerializer, Files.RestoreErrorSerializer> {
        let route = Files.restore
        let serverArgs = Files.RestoreArg(path: path, rev: rev)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Save a specified URL into a file in user's Dropbox. If the given path already exists, the file will be renamed
    /// to avoid the conflict (e.g. myfile (1).txt).
    ///
    /// - parameter path: The path in Dropbox where the URL will be saved to.
    /// - parameter url: The URL to be saved.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Files.SaveUrlResult` object on success or
    /// a `Files.SaveUrlError` object on failure.
    @discardableResult open func saveUrl(path: String, url: String) -> RpcRequest<Files.SaveUrlResultSerializer, Files.SaveUrlErrorSerializer> {
        let route = Files.saveUrl
        let serverArgs = Files.SaveUrlArg(path: path, url: url)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Check the status of a saveUrl job.
    ///
    /// - parameter asyncJobId: Id of the asynchronous job. This is the value of a response returned from the method
    /// that launched the job.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Files.SaveUrlJobStatus` object on success
    /// or a `Async.PollError` object on failure.
    @discardableResult open func saveUrlCheckJobStatus(asyncJobId: String) -> RpcRequest<Files.SaveUrlJobStatusSerializer, Async.PollErrorSerializer> {
        let route = Files.saveUrlCheckJobStatus
        let serverArgs = Async.PollArg(asyncJobId: asyncJobId)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Searches for files and folders. Note: Recent changes may not immediately be reflected in search results due to a
    /// short delay in indexing.
    ///
    /// - parameter path: The path in the user's Dropbox to search. Should probably be a folder.
    /// - parameter query: The string to search for. The search string is split on spaces into multiple tokens. For file
    /// name searching, the last token is used for prefix matching (i.e. "bat c" matches "bat cave" but not "batman
    /// car").
    /// - parameter start: The starting index within the search results (used for paging).
    /// - parameter maxResults: The maximum number of search results to return.
    /// - parameter mode: The search mode (filename, filename_and_content, or deleted_filename). Note that searching
    /// file content is only available for Dropbox Business accounts.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Files.SearchResult` object on success or a
    /// `Files.SearchError` object on failure.
    @discardableResult open func search(path: String, query: String, start: UInt64 = 0, maxResults: UInt64 = 100, mode: Files.SearchMode = .filename) -> RpcRequest<Files.SearchResultSerializer, Files.SearchErrorSerializer> {
        let route = Files.search
        let serverArgs = Files.SearchArg(path: path, query: query, start: start, maxResults: maxResults, mode: mode)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Create a new file with the contents provided in the request. Do not use this to upload a file larger than 150
    /// MB. Instead, create an upload session with uploadSessionStart.
    ///
    /// - parameter path: Path in the user's Dropbox to save the file.
    /// - parameter mode: Selects what to do if the file already exists.
    /// - parameter autorename: If there's a conflict, as determined by mode, have the Dropbox server try to autorename
    /// the file to avoid conflict.
    /// - parameter clientModified: The value to store as the clientModified timestamp. Dropbox automatically records
    /// the time at which the file was written to the Dropbox servers. It can also record an additional timestamp,
    /// provided by Dropbox desktop clients, mobile clients, and API apps of when the file was actually created or
    /// modified.
    /// - parameter mute: Normally, users are made aware of any file modifications in their Dropbox account via
    /// notifications in the client software. If true, this tells the clients that this modification shouldn't result in
    /// a user notification.
    /// - parameter input: The file to upload, as an Data object.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Files.FileMetadata` object on success or a
    /// `Files.UploadError` object on failure.
    @discardableResult open func upload(path: String, mode: Files.WriteMode = .add, autorename: Bool = false, clientModified: Date? = nil, mute: Bool = false, input: Data) -> UploadRequest<Files.FileMetadataSerializer, Files.UploadErrorSerializer> {
        let route = Files.upload
        let serverArgs = Files.CommitInfo(path: path, mode: mode, autorename: autorename, clientModified: clientModified, mute: mute)
        return client.request(route, serverArgs: serverArgs, input: .data(input))
    }

    /// Create a new file with the contents provided in the request. Do not use this to upload a file larger than 150
    /// MB. Instead, create an upload session with uploadSessionStart.
    ///
    /// - parameter path: Path in the user's Dropbox to save the file.
    /// - parameter mode: Selects what to do if the file already exists.
    /// - parameter autorename: If there's a conflict, as determined by mode, have the Dropbox server try to autorename
    /// the file to avoid conflict.
    /// - parameter clientModified: The value to store as the clientModified timestamp. Dropbox automatically records
    /// the time at which the file was written to the Dropbox servers. It can also record an additional timestamp,
    /// provided by Dropbox desktop clients, mobile clients, and API apps of when the file was actually created or
    /// modified.
    /// - parameter mute: Normally, users are made aware of any file modifications in their Dropbox account via
    /// notifications in the client software. If true, this tells the clients that this modification shouldn't result in
    /// a user notification.
    /// - parameter input: The file to upload, as an URL object.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Files.FileMetadata` object on success or a
    /// `Files.UploadError` object on failure.
    @discardableResult open func upload(path: String, mode: Files.WriteMode = .add, autorename: Bool = false, clientModified: Date? = nil, mute: Bool = false, input: URL) -> UploadRequest<Files.FileMetadataSerializer, Files.UploadErrorSerializer> {
        let route = Files.upload
        let serverArgs = Files.CommitInfo(path: path, mode: mode, autorename: autorename, clientModified: clientModified, mute: mute)
        return client.request(route, serverArgs: serverArgs, input: .file(input))
    }

    /// Create a new file with the contents provided in the request. Do not use this to upload a file larger than 150
    /// MB. Instead, create an upload session with uploadSessionStart.
    ///
    /// - parameter path: Path in the user's Dropbox to save the file.
    /// - parameter mode: Selects what to do if the file already exists.
    /// - parameter autorename: If there's a conflict, as determined by mode, have the Dropbox server try to autorename
    /// the file to avoid conflict.
    /// - parameter clientModified: The value to store as the clientModified timestamp. Dropbox automatically records
    /// the time at which the file was written to the Dropbox servers. It can also record an additional timestamp,
    /// provided by Dropbox desktop clients, mobile clients, and API apps of when the file was actually created or
    /// modified.
    /// - parameter mute: Normally, users are made aware of any file modifications in their Dropbox account via
    /// notifications in the client software. If true, this tells the clients that this modification shouldn't result in
    /// a user notification.
    /// - parameter input: The file to upload, as an InputStream object.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Files.FileMetadata` object on success or a
    /// `Files.UploadError` object on failure.
    @discardableResult open func upload(path: String, mode: Files.WriteMode = .add, autorename: Bool = false, clientModified: Date? = nil, mute: Bool = false, input: InputStream) -> UploadRequest<Files.FileMetadataSerializer, Files.UploadErrorSerializer> {
        let route = Files.upload
        let serverArgs = Files.CommitInfo(path: path, mode: mode, autorename: autorename, clientModified: clientModified, mute: mute)
        return client.request(route, serverArgs: serverArgs, input: .stream(input))
    }

    /// Append more data to an upload session. A single request should not upload more than 150 MB.
    ///
    /// - parameter sessionId: The upload session ID (returned by uploadSessionStart).
    /// - parameter offset: The amount of data that has been uploaded so far. We use this to make sure upload data isn't
    /// lost or duplicated in the event of a network error.
    /// - parameter input: The file to upload, as an Data object.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Void` object on success or a
    /// `Files.UploadSessionLookupError` object on failure.
    @available(*, unavailable, message:"upload_session/append is deprecated. Use upload_session/append_v2.")
    @discardableResult open func uploadSessionAppend(sessionId: String, offset: UInt64, input: Data) -> UploadRequest<VoidSerializer, Files.UploadSessionLookupErrorSerializer> {
        let route = Files.uploadSessionAppend
        let serverArgs = Files.UploadSessionCursor(sessionId: sessionId, offset: offset)
        return client.request(route, serverArgs: serverArgs, input: .data(input))
    }

    /// Append more data to an upload session. A single request should not upload more than 150 MB.
    ///
    /// - parameter sessionId: The upload session ID (returned by uploadSessionStart).
    /// - parameter offset: The amount of data that has been uploaded so far. We use this to make sure upload data isn't
    /// lost or duplicated in the event of a network error.
    /// - parameter input: The file to upload, as an URL object.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Void` object on success or a
    /// `Files.UploadSessionLookupError` object on failure.
    @available(*, unavailable, message:"upload_session/append is deprecated. Use upload_session/append_v2.")
    @discardableResult open func uploadSessionAppend(sessionId: String, offset: UInt64, input: URL) -> UploadRequest<VoidSerializer, Files.UploadSessionLookupErrorSerializer> {
        let route = Files.uploadSessionAppend
        let serverArgs = Files.UploadSessionCursor(sessionId: sessionId, offset: offset)
        return client.request(route, serverArgs: serverArgs, input: .file(input))
    }

    /// Append more data to an upload session. A single request should not upload more than 150 MB.
    ///
    /// - parameter sessionId: The upload session ID (returned by uploadSessionStart).
    /// - parameter offset: The amount of data that has been uploaded so far. We use this to make sure upload data isn't
    /// lost or duplicated in the event of a network error.
    /// - parameter input: The file to upload, as an InputStream object.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Void` object on success or a
    /// `Files.UploadSessionLookupError` object on failure.
    @available(*, unavailable, message:"upload_session/append is deprecated. Use upload_session/append_v2.")
    @discardableResult open func uploadSessionAppend(sessionId: String, offset: UInt64, input: InputStream) -> UploadRequest<VoidSerializer, Files.UploadSessionLookupErrorSerializer> {
        let route = Files.uploadSessionAppend
        let serverArgs = Files.UploadSessionCursor(sessionId: sessionId, offset: offset)
        return client.request(route, serverArgs: serverArgs, input: .stream(input))
    }

    /// Append more data to an upload session. When the parameter close is set, this call will close the session. A
    /// single request should not upload more than 150 MB.
    ///
    /// - parameter cursor: Contains the upload session ID and the offset.
    /// - parameter close: If true, the current session will be closed, at which point you won't be able to call
    /// uploadSessionAppendV2 anymore with the current session.
    /// - parameter input: The file to upload, as an Data object.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Void` object on success or a
    /// `Files.UploadSessionLookupError` object on failure.
    @discardableResult open func uploadSessionAppendV2(cursor: Files.UploadSessionCursor, close: Bool = false, input: Data) -> UploadRequest<VoidSerializer, Files.UploadSessionLookupErrorSerializer> {
        let route = Files.uploadSessionAppendV2
        let serverArgs = Files.UploadSessionAppendArg(cursor: cursor, close: close)
        return client.request(route, serverArgs: serverArgs, input: .data(input))
    }

    /// Append more data to an upload session. When the parameter close is set, this call will close the session. A
    /// single request should not upload more than 150 MB.
    ///
    /// - parameter cursor: Contains the upload session ID and the offset.
    /// - parameter close: If true, the current session will be closed, at which point you won't be able to call
    /// uploadSessionAppendV2 anymore with the current session.
    /// - parameter input: The file to upload, as an URL object.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Void` object on success or a
    /// `Files.UploadSessionLookupError` object on failure.
    @discardableResult open func uploadSessionAppendV2(cursor: Files.UploadSessionCursor, close: Bool = false, input: URL) -> UploadRequest<VoidSerializer, Files.UploadSessionLookupErrorSerializer> {
        let route = Files.uploadSessionAppendV2
        let serverArgs = Files.UploadSessionAppendArg(cursor: cursor, close: close)
        return client.request(route, serverArgs: serverArgs, input: .file(input))
    }

    /// Append more data to an upload session. When the parameter close is set, this call will close the session. A
    /// single request should not upload more than 150 MB.
    ///
    /// - parameter cursor: Contains the upload session ID and the offset.
    /// - parameter close: If true, the current session will be closed, at which point you won't be able to call
    /// uploadSessionAppendV2 anymore with the current session.
    /// - parameter input: The file to upload, as an InputStream object.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Void` object on success or a
    /// `Files.UploadSessionLookupError` object on failure.
    @discardableResult open func uploadSessionAppendV2(cursor: Files.UploadSessionCursor, close: Bool = false, input: InputStream) -> UploadRequest<VoidSerializer, Files.UploadSessionLookupErrorSerializer> {
        let route = Files.uploadSessionAppendV2
        let serverArgs = Files.UploadSessionAppendArg(cursor: cursor, close: close)
        return client.request(route, serverArgs: serverArgs, input: .stream(input))
    }

    /// Finish an upload session and save the uploaded data to the given file path. A single request should not upload
    /// more than 150 MB.
    ///
    /// - parameter cursor: Contains the upload session ID and the offset.
    /// - parameter commit: Contains the path and other optional modifiers for the commit.
    /// - parameter input: The file to upload, as an Data object.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Files.FileMetadata` object on success or a
    /// `Files.UploadSessionFinishError` object on failure.
    @discardableResult open func uploadSessionFinish(cursor: Files.UploadSessionCursor, commit: Files.CommitInfo, input: Data) -> UploadRequest<Files.FileMetadataSerializer, Files.UploadSessionFinishErrorSerializer> {
        let route = Files.uploadSessionFinish
        let serverArgs = Files.UploadSessionFinishArg(cursor: cursor, commit: commit)
        return client.request(route, serverArgs: serverArgs, input: .data(input))
    }

    /// Finish an upload session and save the uploaded data to the given file path. A single request should not upload
    /// more than 150 MB.
    ///
    /// - parameter cursor: Contains the upload session ID and the offset.
    /// - parameter commit: Contains the path and other optional modifiers for the commit.
    /// - parameter input: The file to upload, as an URL object.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Files.FileMetadata` object on success or a
    /// `Files.UploadSessionFinishError` object on failure.
    @discardableResult open func uploadSessionFinish(cursor: Files.UploadSessionCursor, commit: Files.CommitInfo, input: URL) -> UploadRequest<Files.FileMetadataSerializer, Files.UploadSessionFinishErrorSerializer> {
        let route = Files.uploadSessionFinish
        let serverArgs = Files.UploadSessionFinishArg(cursor: cursor, commit: commit)
        return client.request(route, serverArgs: serverArgs, input: .file(input))
    }

    /// Finish an upload session and save the uploaded data to the given file path. A single request should not upload
    /// more than 150 MB.
    ///
    /// - parameter cursor: Contains the upload session ID and the offset.
    /// - parameter commit: Contains the path and other optional modifiers for the commit.
    /// - parameter input: The file to upload, as an InputStream object.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Files.FileMetadata` object on success or a
    /// `Files.UploadSessionFinishError` object on failure.
    @discardableResult open func uploadSessionFinish(cursor: Files.UploadSessionCursor, commit: Files.CommitInfo, input: InputStream) -> UploadRequest<Files.FileMetadataSerializer, Files.UploadSessionFinishErrorSerializer> {
        let route = Files.uploadSessionFinish
        let serverArgs = Files.UploadSessionFinishArg(cursor: cursor, commit: commit)
        return client.request(route, serverArgs: serverArgs, input: .stream(input))
    }

    /// This route helps you commit many files at once into a user's Dropbox. Use uploadSessionStart and
    /// uploadSessionAppendV2 to upload file contents. We recommend uploading many files in parallel to increase
    /// throughput. Once the file contents have been uploaded, rather than calling uploadSessionFinish, use this route
    /// to finish all your upload sessions in a single request. close in UploadSessionStartArg or close in
    /// UploadSessionAppendArg needs to be true for the last uploadSessionStart or uploadSessionAppendV2 call. This
    /// route will return a job_id immediately and do the async commit job in background. Use
    /// uploadSessionFinishBatchCheck to check the job status. For the same account, this route should be executed
    /// serially. That means you should not start the next job before current job finishes. We allow up to 1000 entries
    /// in a single request.
    ///
    /// - parameter entries: Commit information for each file in the batch.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Files.UploadSessionFinishBatchLaunch`
    /// object on success or a `Void` object on failure.
    @discardableResult open func uploadSessionFinishBatch(entries: Array<Files.UploadSessionFinishArg>) -> RpcRequest<Files.UploadSessionFinishBatchLaunchSerializer, VoidSerializer> {
        let route = Files.uploadSessionFinishBatch
        let serverArgs = Files.UploadSessionFinishBatchArg(entries: entries)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Returns the status of an asynchronous job for uploadSessionFinishBatch. If success, it returns list of result
    /// for each entry.
    ///
    /// - parameter asyncJobId: Id of the asynchronous job. This is the value of a response returned from the method
    /// that launched the job.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Files.UploadSessionFinishBatchJobStatus`
    /// object on success or a `Async.PollError` object on failure.
    @discardableResult open func uploadSessionFinishBatchCheck(asyncJobId: String) -> RpcRequest<Files.UploadSessionFinishBatchJobStatusSerializer, Async.PollErrorSerializer> {
        let route = Files.uploadSessionFinishBatchCheck
        let serverArgs = Async.PollArg(asyncJobId: asyncJobId)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Upload sessions allow you to upload a single file in one or more requests, for example where the size of the
    /// file is greater than 150 MB.  This call starts a new upload session with the given data. You can then use
    /// uploadSessionAppendV2 to add more data and uploadSessionFinish to save all the data to a file in Dropbox. A
    /// single request should not upload more than 150 MB. An upload session can be used for a maximum of 48 hours.
    /// Attempting to use an sessionId in UploadSessionStartResult with uploadSessionAppendV2 or uploadSessionFinish
    /// more than 48 hours after its creation will return a notFound in UploadSessionLookupError.
    ///
    /// - parameter close: If true, the current session will be closed, at which point you won't be able to call
    /// uploadSessionAppendV2 anymore with the current session.
    /// - parameter input: The file to upload, as an Data object.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Files.UploadSessionStartResult` object on
    /// success or a `Void` object on failure.
    @discardableResult open func uploadSessionStart(close: Bool = false, input: Data) -> UploadRequest<Files.UploadSessionStartResultSerializer, VoidSerializer> {
        let route = Files.uploadSessionStart
        let serverArgs = Files.UploadSessionStartArg(close: close)
        return client.request(route, serverArgs: serverArgs, input: .data(input))
    }

    /// Upload sessions allow you to upload a single file in one or more requests, for example where the size of the
    /// file is greater than 150 MB.  This call starts a new upload session with the given data. You can then use
    /// uploadSessionAppendV2 to add more data and uploadSessionFinish to save all the data to a file in Dropbox. A
    /// single request should not upload more than 150 MB. An upload session can be used for a maximum of 48 hours.
    /// Attempting to use an sessionId in UploadSessionStartResult with uploadSessionAppendV2 or uploadSessionFinish
    /// more than 48 hours after its creation will return a notFound in UploadSessionLookupError.
    ///
    /// - parameter close: If true, the current session will be closed, at which point you won't be able to call
    /// uploadSessionAppendV2 anymore with the current session.
    /// - parameter input: The file to upload, as an URL object.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Files.UploadSessionStartResult` object on
    /// success or a `Void` object on failure.
    @discardableResult open func uploadSessionStart(close: Bool = false, input: URL) -> UploadRequest<Files.UploadSessionStartResultSerializer, VoidSerializer> {
        let route = Files.uploadSessionStart
        let serverArgs = Files.UploadSessionStartArg(close: close)
        return client.request(route, serverArgs: serverArgs, input: .file(input))
    }

    /// Upload sessions allow you to upload a single file in one or more requests, for example where the size of the
    /// file is greater than 150 MB.  This call starts a new upload session with the given data. You can then use
    /// uploadSessionAppendV2 to add more data and uploadSessionFinish to save all the data to a file in Dropbox. A
    /// single request should not upload more than 150 MB. An upload session can be used for a maximum of 48 hours.
    /// Attempting to use an sessionId in UploadSessionStartResult with uploadSessionAppendV2 or uploadSessionFinish
    /// more than 48 hours after its creation will return a notFound in UploadSessionLookupError.
    ///
    /// - parameter close: If true, the current session will be closed, at which point you won't be able to call
    /// uploadSessionAppendV2 anymore with the current session.
    /// - parameter input: The file to upload, as an InputStream object.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Files.UploadSessionStartResult` object on
    /// success or a `Void` object on failure.
    @discardableResult open func uploadSessionStart(close: Bool = false, input: InputStream) -> UploadRequest<Files.UploadSessionStartResultSerializer, VoidSerializer> {
        let route = Files.uploadSessionStart
        let serverArgs = Files.UploadSessionStartArg(close: close)
        return client.request(route, serverArgs: serverArgs, input: .stream(input))
    }

}
