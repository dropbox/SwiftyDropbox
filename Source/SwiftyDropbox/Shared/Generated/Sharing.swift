///
/// Copyright (c) 2016 Dropbox, Inc. All rights reserved.
///
/// Auto-generated by Stone, do not modify.
///

import Foundation

/// Datatypes and serializers for the sharing namespace
public class Sharing {
    /// Information about the inheritance policy of a shared folder.
    public enum AccessInheritance: CustomStringConvertible, JSONRepresentable {
        /// The shared folder inherits its members from the parent folder.
        case inherit
        /// The shared folder does not inherit its members from the parent folder.
        case noInherit
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try AccessInheritanceSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try AccessInheritanceSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for AccessInheritance: \(error)"
            }
        }
    }

    public class AccessInheritanceSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: AccessInheritance) throws -> JSON {
            switch value {
            case .inherit:
                var d = [String: JSON]()
                d[".tag"] = .str("inherit")
                return .dictionary(d)
            case .noInherit:
                var d = [String: JSON]()
                d[".tag"] = .str("no_inherit")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> AccessInheritance {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "inherit":
                    return AccessInheritance.inherit
                case "no_inherit":
                    return AccessInheritance.noInherit
                case "other":
                    return AccessInheritance.other
                default:
                    return AccessInheritance.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: AccessInheritance.self, json: json)
            }
        }
    }

    /// Defines the access levels for collaborators.
    public enum AccessLevel: CustomStringConvertible, JSONRepresentable {
        /// The collaborator is the owner of the shared folder. Owners can view and edit the shared folder as well as
        /// set the folder's policies using updateFolderPolicy.
        case owner
        /// The collaborator can both view and edit the shared folder.
        case editor
        /// The collaborator can only view the shared folder.
        case viewer
        /// The collaborator can only view the shared folder and does not have any access to comments.
        case viewerNoComment
        /// The collaborator can only view the shared folder that they have access to.
        case traverse
        /// If there is a Righteous Link on the folder which grants access and the user has visited such link, they are
        /// allowed to perform certain action (i.e. add themselves to the folder) via the link access even
        /// though the user themselves are not a member on the shared folder yet.
        case noAccess
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try AccessLevelSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try AccessLevelSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for AccessLevel: \(error)"
            }
        }
    }

    public class AccessLevelSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: AccessLevel) throws -> JSON {
            switch value {
            case .owner:
                var d = [String: JSON]()
                d[".tag"] = .str("owner")
                return .dictionary(d)
            case .editor:
                var d = [String: JSON]()
                d[".tag"] = .str("editor")
                return .dictionary(d)
            case .viewer:
                var d = [String: JSON]()
                d[".tag"] = .str("viewer")
                return .dictionary(d)
            case .viewerNoComment:
                var d = [String: JSON]()
                d[".tag"] = .str("viewer_no_comment")
                return .dictionary(d)
            case .traverse:
                var d = [String: JSON]()
                d[".tag"] = .str("traverse")
                return .dictionary(d)
            case .noAccess:
                var d = [String: JSON]()
                d[".tag"] = .str("no_access")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> AccessLevel {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "owner":
                    return AccessLevel.owner
                case "editor":
                    return AccessLevel.editor
                case "viewer":
                    return AccessLevel.viewer
                case "viewer_no_comment":
                    return AccessLevel.viewerNoComment
                case "traverse":
                    return AccessLevel.traverse
                case "no_access":
                    return AccessLevel.noAccess
                case "other":
                    return AccessLevel.other
                default:
                    return AccessLevel.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: AccessLevel.self, json: json)
            }
        }
    }

    /// Who can change a shared folder's access control list (ACL). In other words, who can add, remove, or change the
    /// privileges of members.
    public enum AclUpdatePolicy: CustomStringConvertible, JSONRepresentable {
        /// Only the owner can update the ACL.
        case owner
        /// Any editor can update the ACL. This may be further restricted to editors on the same team.
        case editors
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try AclUpdatePolicySerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try AclUpdatePolicySerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for AclUpdatePolicy: \(error)"
            }
        }
    }

    public class AclUpdatePolicySerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: AclUpdatePolicy) throws -> JSON {
            switch value {
            case .owner:
                var d = [String: JSON]()
                d[".tag"] = .str("owner")
                return .dictionary(d)
            case .editors:
                var d = [String: JSON]()
                d[".tag"] = .str("editors")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> AclUpdatePolicy {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "owner":
                    return AclUpdatePolicy.owner
                case "editors":
                    return AclUpdatePolicy.editors
                case "other":
                    return AclUpdatePolicy.other
                default:
                    return AclUpdatePolicy.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: AclUpdatePolicy.self, json: json)
            }
        }
    }

    /// Arguments for addFileMember.
    public class AddFileMemberArgs: CustomStringConvertible, JSONRepresentable {
        /// File to which to add members.
        public let file: String
        /// Members to add. Note that even an email address is given, this may result in a user being directly added to
        /// the membership if that email is the user's main account email.
        public let members: [Sharing.MemberSelector]
        /// Message to send to added members in their invitation.
        public let customMessage: String?
        /// Whether added members should be notified via email and device notifications of their invitation.
        public let quiet: Bool
        /// AccessLevel union object, describing what access level we want to give new members.
        public let accessLevel: Sharing.AccessLevel
        /// If the custom message should be added as a comment on the file.
        public let addMessageAsComment: Bool
        public init(
            file: String,
            members: [Sharing.MemberSelector],
            customMessage: String? = nil,
            quiet: Bool = false,
            accessLevel: Sharing.AccessLevel = .viewer,
            addMessageAsComment: Bool = false
        ) {
            stringValidator(minLength: 1, pattern: "((/|id:).*|nspath:[0-9]+:.*)|ns:[0-9]+(/.*)?")(file)
            self.file = file
            self.members = members
            nullableValidator(stringValidator())(customMessage)
            self.customMessage = customMessage
            self.quiet = quiet
            self.accessLevel = accessLevel
            self.addMessageAsComment = addMessageAsComment
        }

        func json() throws -> JSON {
            try AddFileMemberArgsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try AddFileMemberArgsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for AddFileMemberArgs: \(error)"
            }
        }
    }

    public class AddFileMemberArgsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: AddFileMemberArgs) throws -> JSON {
            let output = [
                "file": try Serialization._StringSerializer.serialize(value.file),
                "members": try ArraySerializer(Sharing.MemberSelectorSerializer()).serialize(value.members),
                "custom_message": try NullableSerializer(Serialization._StringSerializer).serialize(value.customMessage),
                "quiet": try Serialization._BoolSerializer.serialize(value.quiet),
                "access_level": try Sharing.AccessLevelSerializer().serialize(value.accessLevel),
                "add_message_as_comment": try Serialization._BoolSerializer.serialize(value.addMessageAsComment),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> AddFileMemberArgs {
            switch json {
            case .dictionary(let dict):
                let file = try Serialization._StringSerializer.deserialize(dict["file"] ?? .null)
                let members = try ArraySerializer(Sharing.MemberSelectorSerializer()).deserialize(dict["members"] ?? .null)
                let customMessage = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["custom_message"] ?? .null)
                let quiet = try Serialization._BoolSerializer.deserialize(dict["quiet"] ?? .number(0))
                let accessLevel = try Sharing.AccessLevelSerializer()
                    .deserialize(dict["access_level"] ?? Sharing.AccessLevelSerializer().serialize(.viewer))
                let addMessageAsComment = try Serialization._BoolSerializer.deserialize(dict["add_message_as_comment"] ?? .number(0))
                return AddFileMemberArgs(
                    file: file,
                    members: members,
                    customMessage: customMessage,
                    quiet: quiet,
                    accessLevel: accessLevel,
                    addMessageAsComment: addMessageAsComment
                )
            default:
                throw JSONSerializerError.deserializeError(type: AddFileMemberArgs.self, json: json)
            }
        }
    }

    /// Errors for addFileMember.
    public enum AddFileMemberError: CustomStringConvertible, JSONRepresentable {
        /// An unspecified error.
        case userError(Sharing.SharingUserError)
        /// An unspecified error.
        case accessError(Sharing.SharingFileAccessError)
        /// The user has reached the rate limit for invitations.
        case rateLimit
        /// The custom message did not pass comment permissions checks.
        case invalidComment
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try AddFileMemberErrorSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try AddFileMemberErrorSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for AddFileMemberError: \(error)"
            }
        }
    }

    public class AddFileMemberErrorSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: AddFileMemberError) throws -> JSON {
            switch value {
            case .userError(let arg):
                var d = try ["user_error": Sharing.SharingUserErrorSerializer().serialize(arg)]
                d[".tag"] = .str("user_error")
                return .dictionary(d)
            case .accessError(let arg):
                var d = try ["access_error": Sharing.SharingFileAccessErrorSerializer().serialize(arg)]
                d[".tag"] = .str("access_error")
                return .dictionary(d)
            case .rateLimit:
                var d = [String: JSON]()
                d[".tag"] = .str("rate_limit")
                return .dictionary(d)
            case .invalidComment:
                var d = [String: JSON]()
                d[".tag"] = .str("invalid_comment")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> AddFileMemberError {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "user_error":
                    let v = try Sharing.SharingUserErrorSerializer().deserialize(d["user_error"] ?? .null)
                    return AddFileMemberError.userError(v)
                case "access_error":
                    let v = try Sharing.SharingFileAccessErrorSerializer().deserialize(d["access_error"] ?? .null)
                    return AddFileMemberError.accessError(v)
                case "rate_limit":
                    return AddFileMemberError.rateLimit
                case "invalid_comment":
                    return AddFileMemberError.invalidComment
                case "other":
                    return AddFileMemberError.other
                default:
                    return AddFileMemberError.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: AddFileMemberError.self, json: json)
            }
        }
    }

    /// The AddFolderMemberArg struct
    public class AddFolderMemberArg: CustomStringConvertible, JSONRepresentable {
        /// The ID for the shared folder.
        public let sharedFolderId: String
        /// The intended list of members to add.  Added members will receive invites to join the shared folder.
        public let members: [Sharing.AddMember]
        /// Whether added members should be notified via email and device notifications of their invite.
        public let quiet: Bool
        /// Optional message to display to added members in their invitation.
        public let customMessage: String?
        public init(sharedFolderId: String, members: [Sharing.AddMember], quiet: Bool = false, customMessage: String? = nil) {
            stringValidator(pattern: "[-_0-9a-zA-Z:]+")(sharedFolderId)
            self.sharedFolderId = sharedFolderId
            self.members = members
            self.quiet = quiet
            nullableValidator(stringValidator(minLength: 1))(customMessage)
            self.customMessage = customMessage
        }

        func json() throws -> JSON {
            try AddFolderMemberArgSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try AddFolderMemberArgSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for AddFolderMemberArg: \(error)"
            }
        }
    }

    public class AddFolderMemberArgSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: AddFolderMemberArg) throws -> JSON {
            let output = [
                "shared_folder_id": try Serialization._StringSerializer.serialize(value.sharedFolderId),
                "members": try ArraySerializer(Sharing.AddMemberSerializer()).serialize(value.members),
                "quiet": try Serialization._BoolSerializer.serialize(value.quiet),
                "custom_message": try NullableSerializer(Serialization._StringSerializer).serialize(value.customMessage),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> AddFolderMemberArg {
            switch json {
            case .dictionary(let dict):
                let sharedFolderId = try Serialization._StringSerializer.deserialize(dict["shared_folder_id"] ?? .null)
                let members = try ArraySerializer(Sharing.AddMemberSerializer()).deserialize(dict["members"] ?? .null)
                let quiet = try Serialization._BoolSerializer.deserialize(dict["quiet"] ?? .number(0))
                let customMessage = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["custom_message"] ?? .null)
                return AddFolderMemberArg(sharedFolderId: sharedFolderId, members: members, quiet: quiet, customMessage: customMessage)
            default:
                throw JSONSerializerError.deserializeError(type: AddFolderMemberArg.self, json: json)
            }
        }
    }

    /// The AddFolderMemberError union
    public enum AddFolderMemberError: CustomStringConvertible, JSONRepresentable {
        /// Unable to access shared folder.
        case accessError(Sharing.SharedFolderAccessError)
        /// This user's email address is not verified. This functionality is only available on accounts with a verified
        /// email address. Users can verify their email address here https://www.dropbox.com/help/317.
        case emailUnverified
        /// The current user has been banned.
        case bannedMember
        /// members in AddFolderMemberArg contains a bad invitation recipient.
        case badMember(Sharing.AddMemberSelectorError)
        /// Your team policy does not allow sharing outside of the team.
        case cantShareOutsideTeam
        /// The value is the member limit that was reached.
        case tooManyMembers(UInt64)
        /// The value is the pending invite limit that was reached.
        case tooManyPendingInvites(UInt64)
        /// The current user has hit the limit of invites they can send per day. Try again in 24 hours.
        case rateLimit
        /// The current user is trying to share with too many people at once.
        case tooManyInvitees
        /// The current user's account doesn't support this action. An example of this is when adding a read-only
        /// member. This action can only be performed by users that have upgraded to a Pro or Business plan.
        case insufficientPlan
        /// This action cannot be performed on a team shared folder.
        case teamFolder
        /// The current user does not have permission to perform this action.
        case noPermission
        /// Invalid shared folder error will be returned as an access_error.
        case invalidSharedFolder
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try AddFolderMemberErrorSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try AddFolderMemberErrorSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for AddFolderMemberError: \(error)"
            }
        }
    }

    public class AddFolderMemberErrorSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: AddFolderMemberError) throws -> JSON {
            switch value {
            case .accessError(let arg):
                var d = try ["access_error": Sharing.SharedFolderAccessErrorSerializer().serialize(arg)]
                d[".tag"] = .str("access_error")
                return .dictionary(d)
            case .emailUnverified:
                var d = [String: JSON]()
                d[".tag"] = .str("email_unverified")
                return .dictionary(d)
            case .bannedMember:
                var d = [String: JSON]()
                d[".tag"] = .str("banned_member")
                return .dictionary(d)
            case .badMember(let arg):
                var d = try ["bad_member": Sharing.AddMemberSelectorErrorSerializer().serialize(arg)]
                d[".tag"] = .str("bad_member")
                return .dictionary(d)
            case .cantShareOutsideTeam:
                var d = [String: JSON]()
                d[".tag"] = .str("cant_share_outside_team")
                return .dictionary(d)
            case .tooManyMembers(let arg):
                var d = try ["too_many_members": Serialization._UInt64Serializer.serialize(arg)]
                d[".tag"] = .str("too_many_members")
                return .dictionary(d)
            case .tooManyPendingInvites(let arg):
                var d = try ["too_many_pending_invites": Serialization._UInt64Serializer.serialize(arg)]
                d[".tag"] = .str("too_many_pending_invites")
                return .dictionary(d)
            case .rateLimit:
                var d = [String: JSON]()
                d[".tag"] = .str("rate_limit")
                return .dictionary(d)
            case .tooManyInvitees:
                var d = [String: JSON]()
                d[".tag"] = .str("too_many_invitees")
                return .dictionary(d)
            case .insufficientPlan:
                var d = [String: JSON]()
                d[".tag"] = .str("insufficient_plan")
                return .dictionary(d)
            case .teamFolder:
                var d = [String: JSON]()
                d[".tag"] = .str("team_folder")
                return .dictionary(d)
            case .noPermission:
                var d = [String: JSON]()
                d[".tag"] = .str("no_permission")
                return .dictionary(d)
            case .invalidSharedFolder:
                var d = [String: JSON]()
                d[".tag"] = .str("invalid_shared_folder")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> AddFolderMemberError {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "access_error":
                    let v = try Sharing.SharedFolderAccessErrorSerializer().deserialize(d["access_error"] ?? .null)
                    return AddFolderMemberError.accessError(v)
                case "email_unverified":
                    return AddFolderMemberError.emailUnverified
                case "banned_member":
                    return AddFolderMemberError.bannedMember
                case "bad_member":
                    let v = try Sharing.AddMemberSelectorErrorSerializer().deserialize(d["bad_member"] ?? .null)
                    return AddFolderMemberError.badMember(v)
                case "cant_share_outside_team":
                    return AddFolderMemberError.cantShareOutsideTeam
                case "too_many_members":
                    let v = try Serialization._UInt64Serializer.deserialize(d["too_many_members"] ?? .null)
                    return AddFolderMemberError.tooManyMembers(v)
                case "too_many_pending_invites":
                    let v = try Serialization._UInt64Serializer.deserialize(d["too_many_pending_invites"] ?? .null)
                    return AddFolderMemberError.tooManyPendingInvites(v)
                case "rate_limit":
                    return AddFolderMemberError.rateLimit
                case "too_many_invitees":
                    return AddFolderMemberError.tooManyInvitees
                case "insufficient_plan":
                    return AddFolderMemberError.insufficientPlan
                case "team_folder":
                    return AddFolderMemberError.teamFolder
                case "no_permission":
                    return AddFolderMemberError.noPermission
                case "invalid_shared_folder":
                    return AddFolderMemberError.invalidSharedFolder
                case "other":
                    return AddFolderMemberError.other
                default:
                    return AddFolderMemberError.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: AddFolderMemberError.self, json: json)
            }
        }
    }

    /// The member and type of access the member should have when added to a shared folder.
    public class AddMember: CustomStringConvertible, JSONRepresentable {
        /// The member to add to the shared folder.
        public let member: Sharing.MemberSelector
        /// The access level to grant member to the shared folder.  owner in AccessLevel is disallowed.
        public let accessLevel: Sharing.AccessLevel
        public init(member: Sharing.MemberSelector, accessLevel: Sharing.AccessLevel = .viewer) {
            self.member = member
            self.accessLevel = accessLevel
        }

        func json() throws -> JSON {
            try AddMemberSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try AddMemberSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for AddMember: \(error)"
            }
        }
    }

    public class AddMemberSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: AddMember) throws -> JSON {
            let output = [
                "member": try Sharing.MemberSelectorSerializer().serialize(value.member),
                "access_level": try Sharing.AccessLevelSerializer().serialize(value.accessLevel),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> AddMember {
            switch json {
            case .dictionary(let dict):
                let member = try Sharing.MemberSelectorSerializer().deserialize(dict["member"] ?? .null)
                let accessLevel = try Sharing.AccessLevelSerializer()
                    .deserialize(dict["access_level"] ?? Sharing.AccessLevelSerializer().serialize(.viewer))
                return AddMember(member: member, accessLevel: accessLevel)
            default:
                throw JSONSerializerError.deserializeError(type: AddMember.self, json: json)
            }
        }
    }

    /// The AddMemberSelectorError union
    public enum AddMemberSelectorError: CustomStringConvertible, JSONRepresentable {
        /// Automatically created groups can only be added to team folders.
        case automaticGroup
        /// The value is the ID that could not be identified.
        case invalidDropboxId(String)
        /// The value is the e-email address that is malformed.
        case invalidEmail(String)
        /// The value is the ID of the Dropbox user with an unverified email address. Invite unverified users by email
        /// address instead of by their Dropbox ID.
        case unverifiedDropboxId(String)
        /// At least one of the specified groups in members in AddFolderMemberArg is deleted.
        case groupDeleted
        /// Sharing to a group that is not on the current user's team.
        case groupNotOnTeam
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try AddMemberSelectorErrorSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try AddMemberSelectorErrorSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for AddMemberSelectorError: \(error)"
            }
        }
    }

    public class AddMemberSelectorErrorSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: AddMemberSelectorError) throws -> JSON {
            switch value {
            case .automaticGroup:
                var d = [String: JSON]()
                d[".tag"] = .str("automatic_group")
                return .dictionary(d)
            case .invalidDropboxId(let arg):
                var d = try ["invalid_dropbox_id": Serialization._StringSerializer.serialize(arg)]
                d[".tag"] = .str("invalid_dropbox_id")
                return .dictionary(d)
            case .invalidEmail(let arg):
                var d = try ["invalid_email": Serialization._StringSerializer.serialize(arg)]
                d[".tag"] = .str("invalid_email")
                return .dictionary(d)
            case .unverifiedDropboxId(let arg):
                var d = try ["unverified_dropbox_id": Serialization._StringSerializer.serialize(arg)]
                d[".tag"] = .str("unverified_dropbox_id")
                return .dictionary(d)
            case .groupDeleted:
                var d = [String: JSON]()
                d[".tag"] = .str("group_deleted")
                return .dictionary(d)
            case .groupNotOnTeam:
                var d = [String: JSON]()
                d[".tag"] = .str("group_not_on_team")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> AddMemberSelectorError {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "automatic_group":
                    return AddMemberSelectorError.automaticGroup
                case "invalid_dropbox_id":
                    let v = try Serialization._StringSerializer.deserialize(d["invalid_dropbox_id"] ?? .null)
                    return AddMemberSelectorError.invalidDropboxId(v)
                case "invalid_email":
                    let v = try Serialization._StringSerializer.deserialize(d["invalid_email"] ?? .null)
                    return AddMemberSelectorError.invalidEmail(v)
                case "unverified_dropbox_id":
                    let v = try Serialization._StringSerializer.deserialize(d["unverified_dropbox_id"] ?? .null)
                    return AddMemberSelectorError.unverifiedDropboxId(v)
                case "group_deleted":
                    return AddMemberSelectorError.groupDeleted
                case "group_not_on_team":
                    return AddMemberSelectorError.groupNotOnTeam
                case "other":
                    return AddMemberSelectorError.other
                default:
                    return AddMemberSelectorError.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: AddMemberSelectorError.self, json: json)
            }
        }
    }

    /// The access permission that can be requested by the caller for the shared link. Note that the final resolved
    /// visibility of the shared link takes into account other aspects, such as team and shared folder settings.
    /// Check the ResolvedVisibility for more info on the possible resolved visibility values of shared links.
    public enum RequestedVisibility: CustomStringConvertible, JSONRepresentable {
        /// Anyone who has received the link can access it. No login required.
        case public_
        /// Only members of the same team can access the link. Login is required.
        case teamOnly
        /// A link-specific password is required to access the link. Login is not required.
        case password

        func json() throws -> JSON {
            try RequestedVisibilitySerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try RequestedVisibilitySerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for RequestedVisibility: \(error)"
            }
        }
    }

    public class RequestedVisibilitySerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: RequestedVisibility) throws -> JSON {
            switch value {
            case .public_:
                var d = [String: JSON]()
                d[".tag"] = .str("public")
                return .dictionary(d)
            case .teamOnly:
                var d = [String: JSON]()
                d[".tag"] = .str("team_only")
                return .dictionary(d)
            case .password:
                var d = [String: JSON]()
                d[".tag"] = .str("password")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> RequestedVisibility {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "public":
                    return RequestedVisibility.public_
                case "team_only":
                    return RequestedVisibility.teamOnly
                case "password":
                    return RequestedVisibility.password
                default:
                    throw JSONSerializerError.unknownTag(type: RequestedVisibility.self, json: json, tag: tag)
                }
            default:
                throw JSONSerializerError.deserializeError(type: RequestedVisibility.self, json: json)
            }
        }
    }

    /// The actual access permissions values of shared links after taking into account user preferences and the team and
    /// shared folder settings. Check the RequestedVisibility for more info on the possible visibility values that
    /// can be set by the shared link's owner.
    public enum ResolvedVisibility: CustomStringConvertible, JSONRepresentable {
        /// Anyone who has received the link can access it. No login required.
        case public_
        /// Only members of the same team can access the link. Login is required.
        case teamOnly
        /// A link-specific password is required to access the link. Login is not required.
        case password
        /// Only members of the same team who have the link-specific password can access the link. Login is required.
        case teamAndPassword
        /// Only members of the shared folder containing the linked file can access the link. Login is required.
        case sharedFolderOnly
        /// The link merely points the user to the content, and does not grant any additional rights. Existing members
        /// of the content who use this link can only access the content with their pre-existing access rights.
        /// Either on the file directly, or inherited from a parent folder.
        case noOne
        /// Only the current user can view this link.
        case onlyYou
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try ResolvedVisibilitySerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ResolvedVisibilitySerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ResolvedVisibility: \(error)"
            }
        }
    }

    public class ResolvedVisibilitySerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ResolvedVisibility) throws -> JSON {
            switch value {
            case .public_:
                var d = [String: JSON]()
                d[".tag"] = .str("public")
                return .dictionary(d)
            case .teamOnly:
                var d = [String: JSON]()
                d[".tag"] = .str("team_only")
                return .dictionary(d)
            case .password:
                var d = [String: JSON]()
                d[".tag"] = .str("password")
                return .dictionary(d)
            case .teamAndPassword:
                var d = [String: JSON]()
                d[".tag"] = .str("team_and_password")
                return .dictionary(d)
            case .sharedFolderOnly:
                var d = [String: JSON]()
                d[".tag"] = .str("shared_folder_only")
                return .dictionary(d)
            case .noOne:
                var d = [String: JSON]()
                d[".tag"] = .str("no_one")
                return .dictionary(d)
            case .onlyYou:
                var d = [String: JSON]()
                d[".tag"] = .str("only_you")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> ResolvedVisibility {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "public":
                    return ResolvedVisibility.public_
                case "team_only":
                    return ResolvedVisibility.teamOnly
                case "password":
                    return ResolvedVisibility.password
                case "team_and_password":
                    return ResolvedVisibility.teamAndPassword
                case "shared_folder_only":
                    return ResolvedVisibility.sharedFolderOnly
                case "no_one":
                    return ResolvedVisibility.noOne
                case "only_you":
                    return ResolvedVisibility.onlyYou
                case "other":
                    return ResolvedVisibility.other
                default:
                    return ResolvedVisibility.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: ResolvedVisibility.self, json: json)
            }
        }
    }

    /// check documentation for ResolvedVisibility.
    public enum AlphaResolvedVisibility: CustomStringConvertible, JSONRepresentable {
        /// Anyone who has received the link can access it. No login required.
        case public_
        /// Only members of the same team can access the link. Login is required.
        case teamOnly
        /// A link-specific password is required to access the link. Login is not required.
        case password
        /// Only members of the same team who have the link-specific password can access the link. Login is required.
        case teamAndPassword
        /// Only members of the shared folder containing the linked file can access the link. Login is required.
        case sharedFolderOnly
        /// The link merely points the user to the content, and does not grant any additional rights. Existing members
        /// of the content who use this link can only access the content with their pre-existing access rights.
        /// Either on the file directly, or inherited from a parent folder.
        case noOne
        /// Only the current user can view this link.
        case onlyYou
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try AlphaResolvedVisibilitySerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try AlphaResolvedVisibilitySerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for AlphaResolvedVisibility: \(error)"
            }
        }
    }

    public class AlphaResolvedVisibilitySerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: AlphaResolvedVisibility) throws -> JSON {
            switch value {
            case .public_:
                var d = [String: JSON]()
                d[".tag"] = .str("public")
                return .dictionary(d)
            case .teamOnly:
                var d = [String: JSON]()
                d[".tag"] = .str("team_only")
                return .dictionary(d)
            case .password:
                var d = [String: JSON]()
                d[".tag"] = .str("password")
                return .dictionary(d)
            case .teamAndPassword:
                var d = [String: JSON]()
                d[".tag"] = .str("team_and_password")
                return .dictionary(d)
            case .sharedFolderOnly:
                var d = [String: JSON]()
                d[".tag"] = .str("shared_folder_only")
                return .dictionary(d)
            case .noOne:
                var d = [String: JSON]()
                d[".tag"] = .str("no_one")
                return .dictionary(d)
            case .onlyYou:
                var d = [String: JSON]()
                d[".tag"] = .str("only_you")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> AlphaResolvedVisibility {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "public":
                    return AlphaResolvedVisibility.public_
                case "team_only":
                    return AlphaResolvedVisibility.teamOnly
                case "password":
                    return AlphaResolvedVisibility.password
                case "team_and_password":
                    return AlphaResolvedVisibility.teamAndPassword
                case "shared_folder_only":
                    return AlphaResolvedVisibility.sharedFolderOnly
                case "no_one":
                    return AlphaResolvedVisibility.noOne
                case "only_you":
                    return AlphaResolvedVisibility.onlyYou
                case "other":
                    return AlphaResolvedVisibility.other
                default:
                    throw JSONSerializerError.unknownTag(type: AlphaResolvedVisibility.self, json: json, tag: tag)
                }
            default:
                throw JSONSerializerError.deserializeError(type: AlphaResolvedVisibility.self, json: json)
            }
        }
    }

    /// Information about the content that has a link audience different than that of this folder.
    public class AudienceExceptionContentInfo: CustomStringConvertible, JSONRepresentable {
        /// The name of the content, which is either a file or a folder.
        public let name: String
        public init(name: String) {
            stringValidator()(name)
            self.name = name
        }

        func json() throws -> JSON {
            try AudienceExceptionContentInfoSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try AudienceExceptionContentInfoSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for AudienceExceptionContentInfo: \(error)"
            }
        }
    }

    public class AudienceExceptionContentInfoSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: AudienceExceptionContentInfo) throws -> JSON {
            let output = [
                "name": try Serialization._StringSerializer.serialize(value.name),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> AudienceExceptionContentInfo {
            switch json {
            case .dictionary(let dict):
                let name = try Serialization._StringSerializer.deserialize(dict["name"] ?? .null)
                return AudienceExceptionContentInfo(name: name)
            default:
                throw JSONSerializerError.deserializeError(type: AudienceExceptionContentInfo.self, json: json)
            }
        }
    }

    /// The total count and truncated list of information of content inside this folder that has a different audience
    /// than the link on this folder. This is only returned for folders.
    public class AudienceExceptions: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let count: UInt32
        /// A truncated list of some of the content that is an exception. The length of this list could be smaller than
        /// the count since it is only a sample but will not be empty as long as count is not 0.
        public let exceptions: [Sharing.AudienceExceptionContentInfo]
        public init(count: UInt32, exceptions: [Sharing.AudienceExceptionContentInfo]) {
            comparableValidator()(count)
            self.count = count
            self.exceptions = exceptions
        }

        func json() throws -> JSON {
            try AudienceExceptionsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try AudienceExceptionsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for AudienceExceptions: \(error)"
            }
        }
    }

    public class AudienceExceptionsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: AudienceExceptions) throws -> JSON {
            let output = [
                "count": try Serialization._UInt32Serializer.serialize(value.count),
                "exceptions": try ArraySerializer(Sharing.AudienceExceptionContentInfoSerializer()).serialize(value.exceptions),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> AudienceExceptions {
            switch json {
            case .dictionary(let dict):
                let count = try Serialization._UInt32Serializer.deserialize(dict["count"] ?? .null)
                let exceptions = try ArraySerializer(Sharing.AudienceExceptionContentInfoSerializer()).deserialize(dict["exceptions"] ?? .null)
                return AudienceExceptions(count: count, exceptions: exceptions)
            default:
                throw JSONSerializerError.deserializeError(type: AudienceExceptions.self, json: json)
            }
        }
    }

    /// Information about the shared folder that prevents the link audience for this link from being more restrictive.
    public class AudienceRestrictingSharedFolder: CustomStringConvertible, JSONRepresentable {
        /// The ID of the shared folder.
        public let sharedFolderId: String
        /// The name of the shared folder.
        public let name: String
        /// The link audience of the shared folder.
        public let audience: Sharing.LinkAudience
        public init(sharedFolderId: String, name: String, audience: Sharing.LinkAudience) {
            stringValidator(pattern: "[-_0-9a-zA-Z:]+")(sharedFolderId)
            self.sharedFolderId = sharedFolderId
            stringValidator()(name)
            self.name = name
            self.audience = audience
        }

        func json() throws -> JSON {
            try AudienceRestrictingSharedFolderSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try AudienceRestrictingSharedFolderSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for AudienceRestrictingSharedFolder: \(error)"
            }
        }
    }

    public class AudienceRestrictingSharedFolderSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: AudienceRestrictingSharedFolder) throws -> JSON {
            let output = [
                "shared_folder_id": try Serialization._StringSerializer.serialize(value.sharedFolderId),
                "name": try Serialization._StringSerializer.serialize(value.name),
                "audience": try Sharing.LinkAudienceSerializer().serialize(value.audience),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> AudienceRestrictingSharedFolder {
            switch json {
            case .dictionary(let dict):
                let sharedFolderId = try Serialization._StringSerializer.deserialize(dict["shared_folder_id"] ?? .null)
                let name = try Serialization._StringSerializer.deserialize(dict["name"] ?? .null)
                let audience = try Sharing.LinkAudienceSerializer().deserialize(dict["audience"] ?? .null)
                return AudienceRestrictingSharedFolder(sharedFolderId: sharedFolderId, name: name, audience: audience)
            default:
                throw JSONSerializerError.deserializeError(type: AudienceRestrictingSharedFolder.self, json: json)
            }
        }
    }

    /// Metadata for a shared link. This can be either a PathLinkMetadata or CollectionLinkMetadata.
    public class LinkMetadata: CustomStringConvertible, JSONRepresentable {
        /// URL of the shared link.
        public let url: String
        /// Who can access the link.
        public let visibility: Sharing.Visibility
        /// Expiration time, if set. By default the link won't expire.
        public let expires: Date?
        public init(url: String, visibility: Sharing.Visibility, expires: Date? = nil) {
            stringValidator()(url)
            self.url = url
            self.visibility = visibility
            self.expires = expires
        }

        func json() throws -> JSON {
            try LinkMetadataSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try LinkMetadataSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for LinkMetadata: \(error)"
            }
        }
    }

    public class LinkMetadataSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: LinkMetadata) throws -> JSON {
            var output = [
                "url": try Serialization._StringSerializer.serialize(value.url),
                "visibility": try Sharing.VisibilitySerializer().serialize(value.visibility),
                "expires": try NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.expires),
            ]
            switch value {
            case let path as Sharing.PathLinkMetadata:
                for (k, v) in try Serialization.getFields(Sharing.PathLinkMetadataSerializer().serialize(path)) {
                    output[k] = v
                }
                output[".tag"] = .str("path")
            case let collection as Sharing.CollectionLinkMetadata:
                for (k, v) in try Serialization.getFields(Sharing.CollectionLinkMetadataSerializer().serialize(collection)) {
                    output[k] = v
                }
                output[".tag"] = .str("collection")
            default:
                throw JSONSerializerError.unexpectedSubtype(type: LinkMetadata.self, subtype: value)
            }
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> LinkMetadata {
            switch json {
            case .dictionary(let dict):
                let tag = try Serialization.getTag(dict)
                switch tag {
                case "path":
                    return try Sharing.PathLinkMetadataSerializer().deserialize(json)
                case "collection":
                    return try Sharing.CollectionLinkMetadataSerializer().deserialize(json)
                default:
                    let url = try Serialization._StringSerializer.deserialize(dict["url"] ?? .null)
                    let visibility = try Sharing.VisibilitySerializer().deserialize(dict["visibility"] ?? .null)
                    let expires = try NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).deserialize(dict["expires"] ?? .null)
                    return LinkMetadata(url: url, visibility: visibility, expires: expires)
                }
            default:
                throw JSONSerializerError.deserializeError(type: LinkMetadata.self, json: json)
            }
        }
    }

    /// Metadata for a collection-based shared link.
    public class CollectionLinkMetadata: Sharing.LinkMetadata {
        public override var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try CollectionLinkMetadataSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for CollectionLinkMetadata: \(error)"
            }
        }
    }

    public class CollectionLinkMetadataSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: CollectionLinkMetadata) throws -> JSON {
            let output = [
                "url": try Serialization._StringSerializer.serialize(value.url),
                "visibility": try Sharing.VisibilitySerializer().serialize(value.visibility),
                "expires": try NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.expires),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> CollectionLinkMetadata {
            switch json {
            case .dictionary(let dict):
                let url = try Serialization._StringSerializer.deserialize(dict["url"] ?? .null)
                let visibility = try Sharing.VisibilitySerializer().deserialize(dict["visibility"] ?? .null)
                let expires = try NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).deserialize(dict["expires"] ?? .null)
                return CollectionLinkMetadata(url: url, visibility: visibility, expires: expires)
            default:
                throw JSONSerializerError.deserializeError(type: CollectionLinkMetadata.self, json: json)
            }
        }
    }

    /// The CreateSharedLinkArg struct
    public class CreateSharedLinkArg: CustomStringConvertible, JSONRepresentable {
        /// The path to share.
        public let path: String
        /// (no description)
        public let shortUrl: Bool
        /// If it's okay to share a path that does not yet exist, set this to either file in PendingUploadMode or folder
        /// in PendingUploadMode to indicate whether to assume it's a file or folder.
        public let pendingUpload: Sharing.PendingUploadMode?
        public init(path: String, shortUrl: Bool = false, pendingUpload: Sharing.PendingUploadMode? = nil) {
            stringValidator()(path)
            self.path = path
            self.shortUrl = shortUrl
            self.pendingUpload = pendingUpload
        }

        func json() throws -> JSON {
            try CreateSharedLinkArgSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try CreateSharedLinkArgSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for CreateSharedLinkArg: \(error)"
            }
        }
    }

    public class CreateSharedLinkArgSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: CreateSharedLinkArg) throws -> JSON {
            let output = [
                "path": try Serialization._StringSerializer.serialize(value.path),
                "short_url": try Serialization._BoolSerializer.serialize(value.shortUrl),
                "pending_upload": try NullableSerializer(Sharing.PendingUploadModeSerializer()).serialize(value.pendingUpload),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> CreateSharedLinkArg {
            switch json {
            case .dictionary(let dict):
                let path = try Serialization._StringSerializer.deserialize(dict["path"] ?? .null)
                let shortUrl = try Serialization._BoolSerializer.deserialize(dict["short_url"] ?? .number(0))
                let pendingUpload = try NullableSerializer(Sharing.PendingUploadModeSerializer()).deserialize(dict["pending_upload"] ?? .null)
                return CreateSharedLinkArg(path: path, shortUrl: shortUrl, pendingUpload: pendingUpload)
            default:
                throw JSONSerializerError.deserializeError(type: CreateSharedLinkArg.self, json: json)
            }
        }
    }

    /// The CreateSharedLinkError union
    public enum CreateSharedLinkError: CustomStringConvertible, JSONRepresentable {
        /// An unspecified error.
        case path(Files.LookupError)
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try CreateSharedLinkErrorSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try CreateSharedLinkErrorSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for CreateSharedLinkError: \(error)"
            }
        }
    }

    public class CreateSharedLinkErrorSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: CreateSharedLinkError) throws -> JSON {
            switch value {
            case .path(let arg):
                var d = try ["path": Files.LookupErrorSerializer().serialize(arg)]
                d[".tag"] = .str("path")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> CreateSharedLinkError {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "path":
                    let v = try Files.LookupErrorSerializer().deserialize(d["path"] ?? .null)
                    return CreateSharedLinkError.path(v)
                case "other":
                    return CreateSharedLinkError.other
                default:
                    return CreateSharedLinkError.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: CreateSharedLinkError.self, json: json)
            }
        }
    }

    /// The CreateSharedLinkWithSettingsArg struct
    public class CreateSharedLinkWithSettingsArg: CustomStringConvertible, JSONRepresentable {
        /// The path to be shared by the shared link.
        public let path: String
        /// The requested settings for the newly created shared link.
        public let settings: Sharing.SharedLinkSettings?
        public init(path: String, settings: Sharing.SharedLinkSettings? = nil) {
            stringValidator(pattern: "(/(.|[\\r\\n])*|id:.*)|(rev:[0-9a-f]{9,})|(ns:[0-9]+(/.*)?)")(path)
            self.path = path
            self.settings = settings
        }

        func json() throws -> JSON {
            try CreateSharedLinkWithSettingsArgSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try CreateSharedLinkWithSettingsArgSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for CreateSharedLinkWithSettingsArg: \(error)"
            }
        }
    }

    public class CreateSharedLinkWithSettingsArgSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: CreateSharedLinkWithSettingsArg) throws -> JSON {
            let output = [
                "path": try Serialization._StringSerializer.serialize(value.path),
                "settings": try NullableSerializer(Sharing.SharedLinkSettingsSerializer()).serialize(value.settings),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> CreateSharedLinkWithSettingsArg {
            switch json {
            case .dictionary(let dict):
                let path = try Serialization._StringSerializer.deserialize(dict["path"] ?? .null)
                let settings = try NullableSerializer(Sharing.SharedLinkSettingsSerializer()).deserialize(dict["settings"] ?? .null)
                return CreateSharedLinkWithSettingsArg(path: path, settings: settings)
            default:
                throw JSONSerializerError.deserializeError(type: CreateSharedLinkWithSettingsArg.self, json: json)
            }
        }
    }

    /// The CreateSharedLinkWithSettingsError union
    public enum CreateSharedLinkWithSettingsError: CustomStringConvertible, JSONRepresentable {
        /// An unspecified error.
        case path(Files.LookupError)
        /// This user's email address is not verified. This functionality is only available on accounts with a verified
        /// email address. Users can verify their email address here https://www.dropbox.com/help/317.
        case emailNotVerified
        /// The shared link already exists. You can call listSharedLinks to get the  existing link, or use the provided
        /// metadata if it is returned.
        case sharedLinkAlreadyExists(Sharing.SharedLinkAlreadyExistsMetadata?)
        /// There is an error with the given settings.
        case settingsError(Sharing.SharedLinkSettingsError)
        /// The user is not allowed to create a shared link to the specified file. For  example, this can occur if the
        /// file is restricted or if the user's links are  banned
        /// https://help.dropbox.com/files-folders/share/banned-links.
        case accessDenied

        func json() throws -> JSON {
            try CreateSharedLinkWithSettingsErrorSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try CreateSharedLinkWithSettingsErrorSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for CreateSharedLinkWithSettingsError: \(error)"
            }
        }
    }

    public class CreateSharedLinkWithSettingsErrorSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: CreateSharedLinkWithSettingsError) throws -> JSON {
            switch value {
            case .path(let arg):
                var d = try ["path": Files.LookupErrorSerializer().serialize(arg)]
                d[".tag"] = .str("path")
                return .dictionary(d)
            case .emailNotVerified:
                var d = [String: JSON]()
                d[".tag"] = .str("email_not_verified")
                return .dictionary(d)
            case .sharedLinkAlreadyExists(let arg):
                var d = try ["shared_link_already_exists": NullableSerializer(Sharing.SharedLinkAlreadyExistsMetadataSerializer()).serialize(arg)]
                d[".tag"] = .str("shared_link_already_exists")
                return .dictionary(d)
            case .settingsError(let arg):
                var d = try ["settings_error": Sharing.SharedLinkSettingsErrorSerializer().serialize(arg)]
                d[".tag"] = .str("settings_error")
                return .dictionary(d)
            case .accessDenied:
                var d = [String: JSON]()
                d[".tag"] = .str("access_denied")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> CreateSharedLinkWithSettingsError {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "path":
                    let v = try Files.LookupErrorSerializer().deserialize(d["path"] ?? .null)
                    return CreateSharedLinkWithSettingsError.path(v)
                case "email_not_verified":
                    return CreateSharedLinkWithSettingsError.emailNotVerified
                case "shared_link_already_exists":
                    let v = try NullableSerializer(Sharing.SharedLinkAlreadyExistsMetadataSerializer())
                        .deserialize(d["shared_link_already_exists"] ?? .null)
                    return CreateSharedLinkWithSettingsError.sharedLinkAlreadyExists(v)
                case "settings_error":
                    let v = try Sharing.SharedLinkSettingsErrorSerializer().deserialize(d["settings_error"] ?? .null)
                    return CreateSharedLinkWithSettingsError.settingsError(v)
                case "access_denied":
                    return CreateSharedLinkWithSettingsError.accessDenied
                default:
                    throw JSONSerializerError.unknownTag(type: CreateSharedLinkWithSettingsError.self, json: json, tag: tag)
                }
            default:
                throw JSONSerializerError.deserializeError(type: CreateSharedLinkWithSettingsError.self, json: json)
            }
        }
    }

    /// The SharedContentLinkMetadataBase struct
    public class SharedContentLinkMetadataBase: CustomStringConvertible, JSONRepresentable {
        /// The access level on the link for this file.
        public let accessLevel: Sharing.AccessLevel?
        /// The audience options that are available for the content. Some audience options may be unavailable. For
        /// example, team_only may be unavailable if the content is not owned by a user on a team. The 'default'
        /// audience option is always available if the user can modify link settings.
        public let audienceOptions: [Sharing.LinkAudience]
        /// The shared folder that prevents the link audience for this link from being more restrictive.
        public let audienceRestrictingSharedFolder: Sharing.AudienceRestrictingSharedFolder?
        /// The current audience of the link.
        public let currentAudience: Sharing.LinkAudience
        /// Whether the link has an expiry set on it. A link with an expiry will have its  audience changed to members
        /// when the expiry is reached.
        public let expiry: Date?
        /// A list of permissions for actions you can perform on the link.
        public let linkPermissions: [Sharing.LinkPermission]
        /// Whether the link is protected by a password.
        public let passwordProtected: Bool
        public init(
            audienceOptions: [Sharing.LinkAudience],
            currentAudience: Sharing.LinkAudience,
            linkPermissions: [Sharing.LinkPermission],
            passwordProtected: Bool,
            accessLevel: Sharing.AccessLevel? = nil,
            audienceRestrictingSharedFolder: Sharing.AudienceRestrictingSharedFolder? = nil,
            expiry: Date? = nil
        ) {
            self.accessLevel = accessLevel
            self.audienceOptions = audienceOptions
            self.audienceRestrictingSharedFolder = audienceRestrictingSharedFolder
            self.currentAudience = currentAudience
            self.expiry = expiry
            self.linkPermissions = linkPermissions
            self.passwordProtected = passwordProtected
        }

        func json() throws -> JSON {
            try SharedContentLinkMetadataBaseSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharedContentLinkMetadataBaseSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharedContentLinkMetadataBase: \(error)"
            }
        }
    }

    public class SharedContentLinkMetadataBaseSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharedContentLinkMetadataBase) throws -> JSON {
            let output = [
                "audience_options": try ArraySerializer(Sharing.LinkAudienceSerializer()).serialize(value.audienceOptions),
                "current_audience": try Sharing.LinkAudienceSerializer().serialize(value.currentAudience),
                "link_permissions": try ArraySerializer(Sharing.LinkPermissionSerializer()).serialize(value.linkPermissions),
                "password_protected": try Serialization._BoolSerializer.serialize(value.passwordProtected),
                "access_level": try NullableSerializer(Sharing.AccessLevelSerializer()).serialize(value.accessLevel),
                "audience_restricting_shared_folder": try NullableSerializer(Sharing.AudienceRestrictingSharedFolderSerializer())
                    .serialize(value.audienceRestrictingSharedFolder),
                "expiry": try NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.expiry),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharedContentLinkMetadataBase {
            switch json {
            case .dictionary(let dict):
                let audienceOptions = try ArraySerializer(Sharing.LinkAudienceSerializer()).deserialize(dict["audience_options"] ?? .null)
                let currentAudience = try Sharing.LinkAudienceSerializer().deserialize(dict["current_audience"] ?? .null)
                let linkPermissions = try ArraySerializer(Sharing.LinkPermissionSerializer()).deserialize(dict["link_permissions"] ?? .null)
                let passwordProtected = try Serialization._BoolSerializer.deserialize(dict["password_protected"] ?? .null)
                let accessLevel = try NullableSerializer(Sharing.AccessLevelSerializer()).deserialize(dict["access_level"] ?? .null)
                let audienceRestrictingSharedFolder = try NullableSerializer(Sharing.AudienceRestrictingSharedFolderSerializer())
                    .deserialize(dict["audience_restricting_shared_folder"] ?? .null)
                let expiry = try NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).deserialize(dict["expiry"] ?? .null)
                return SharedContentLinkMetadataBase(
                    audienceOptions: audienceOptions,
                    currentAudience: currentAudience,
                    linkPermissions: linkPermissions,
                    passwordProtected: passwordProtected,
                    accessLevel: accessLevel,
                    audienceRestrictingSharedFolder: audienceRestrictingSharedFolder,
                    expiry: expiry
                )
            default:
                throw JSONSerializerError.deserializeError(type: SharedContentLinkMetadataBase.self, json: json)
            }
        }
    }

    /// The expected metadata of a shared link for a file or folder when a link is first created for the content. Absent
    /// if the link already exists.
    public class ExpectedSharedContentLinkMetadata: Sharing.SharedContentLinkMetadataBase {
        public override var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ExpectedSharedContentLinkMetadataSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ExpectedSharedContentLinkMetadata: \(error)"
            }
        }
    }

    public class ExpectedSharedContentLinkMetadataSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ExpectedSharedContentLinkMetadata) throws -> JSON {
            let output = [
                "audience_options": try ArraySerializer(Sharing.LinkAudienceSerializer()).serialize(value.audienceOptions),
                "current_audience": try Sharing.LinkAudienceSerializer().serialize(value.currentAudience),
                "link_permissions": try ArraySerializer(Sharing.LinkPermissionSerializer()).serialize(value.linkPermissions),
                "password_protected": try Serialization._BoolSerializer.serialize(value.passwordProtected),
                "access_level": try NullableSerializer(Sharing.AccessLevelSerializer()).serialize(value.accessLevel),
                "audience_restricting_shared_folder": try NullableSerializer(Sharing.AudienceRestrictingSharedFolderSerializer())
                    .serialize(value.audienceRestrictingSharedFolder),
                "expiry": try NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.expiry),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ExpectedSharedContentLinkMetadata {
            switch json {
            case .dictionary(let dict):
                let audienceOptions = try ArraySerializer(Sharing.LinkAudienceSerializer()).deserialize(dict["audience_options"] ?? .null)
                let currentAudience = try Sharing.LinkAudienceSerializer().deserialize(dict["current_audience"] ?? .null)
                let linkPermissions = try ArraySerializer(Sharing.LinkPermissionSerializer()).deserialize(dict["link_permissions"] ?? .null)
                let passwordProtected = try Serialization._BoolSerializer.deserialize(dict["password_protected"] ?? .null)
                let accessLevel = try NullableSerializer(Sharing.AccessLevelSerializer()).deserialize(dict["access_level"] ?? .null)
                let audienceRestrictingSharedFolder = try NullableSerializer(Sharing.AudienceRestrictingSharedFolderSerializer())
                    .deserialize(dict["audience_restricting_shared_folder"] ?? .null)
                let expiry = try NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).deserialize(dict["expiry"] ?? .null)
                return ExpectedSharedContentLinkMetadata(
                    audienceOptions: audienceOptions,
                    currentAudience: currentAudience,
                    linkPermissions: linkPermissions,
                    passwordProtected: passwordProtected,
                    accessLevel: accessLevel,
                    audienceRestrictingSharedFolder: audienceRestrictingSharedFolder,
                    expiry: expiry
                )
            default:
                throw JSONSerializerError.deserializeError(type: ExpectedSharedContentLinkMetadata.self, json: json)
            }
        }
    }

    /// Sharing actions that may be taken on files.
    public enum FileAction: CustomStringConvertible, JSONRepresentable {
        /// Disable viewer information on the file.
        case disableViewerInfo
        /// Change or edit contents of the file.
        case editContents
        /// Enable viewer information on the file.
        case enableViewerInfo
        /// Add a member with view permissions.
        case inviteViewer
        /// Add a member with view permissions but no comment permissions.
        case inviteViewerNoComment
        /// Add a member with edit permissions.
        case inviteEditor
        /// Stop sharing this file.
        case unshare
        /// Relinquish one's own membership to the file.
        case relinquishMembership
        /// Use create_view_link and create_edit_link instead.
        case shareLink
        /// Use create_view_link and create_edit_link instead.
        case createLink
        /// Create a shared link to a file that only allows users to view the content.
        case createViewLink
        /// Create a shared link to a file that allows users to edit the content.
        case createEditLink
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try FileActionSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try FileActionSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for FileAction: \(error)"
            }
        }
    }

    public class FileActionSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: FileAction) throws -> JSON {
            switch value {
            case .disableViewerInfo:
                var d = [String: JSON]()
                d[".tag"] = .str("disable_viewer_info")
                return .dictionary(d)
            case .editContents:
                var d = [String: JSON]()
                d[".tag"] = .str("edit_contents")
                return .dictionary(d)
            case .enableViewerInfo:
                var d = [String: JSON]()
                d[".tag"] = .str("enable_viewer_info")
                return .dictionary(d)
            case .inviteViewer:
                var d = [String: JSON]()
                d[".tag"] = .str("invite_viewer")
                return .dictionary(d)
            case .inviteViewerNoComment:
                var d = [String: JSON]()
                d[".tag"] = .str("invite_viewer_no_comment")
                return .dictionary(d)
            case .inviteEditor:
                var d = [String: JSON]()
                d[".tag"] = .str("invite_editor")
                return .dictionary(d)
            case .unshare:
                var d = [String: JSON]()
                d[".tag"] = .str("unshare")
                return .dictionary(d)
            case .relinquishMembership:
                var d = [String: JSON]()
                d[".tag"] = .str("relinquish_membership")
                return .dictionary(d)
            case .shareLink:
                var d = [String: JSON]()
                d[".tag"] = .str("share_link")
                return .dictionary(d)
            case .createLink:
                var d = [String: JSON]()
                d[".tag"] = .str("create_link")
                return .dictionary(d)
            case .createViewLink:
                var d = [String: JSON]()
                d[".tag"] = .str("create_view_link")
                return .dictionary(d)
            case .createEditLink:
                var d = [String: JSON]()
                d[".tag"] = .str("create_edit_link")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> FileAction {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "disable_viewer_info":
                    return FileAction.disableViewerInfo
                case "edit_contents":
                    return FileAction.editContents
                case "enable_viewer_info":
                    return FileAction.enableViewerInfo
                case "invite_viewer":
                    return FileAction.inviteViewer
                case "invite_viewer_no_comment":
                    return FileAction.inviteViewerNoComment
                case "invite_editor":
                    return FileAction.inviteEditor
                case "unshare":
                    return FileAction.unshare
                case "relinquish_membership":
                    return FileAction.relinquishMembership
                case "share_link":
                    return FileAction.shareLink
                case "create_link":
                    return FileAction.createLink
                case "create_view_link":
                    return FileAction.createViewLink
                case "create_edit_link":
                    return FileAction.createEditLink
                case "other":
                    return FileAction.other
                default:
                    return FileAction.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: FileAction.self, json: json)
            }
        }
    }

    /// The FileErrorResult union
    public enum FileErrorResult: CustomStringConvertible, JSONRepresentable {
        /// File specified by id was not found.
        case fileNotFoundError(String)
        /// User does not have permission to take the specified action on the file.
        case invalidFileActionError(String)
        /// User does not have permission to access file specified by file.Id.
        case permissionDeniedError(String)
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try FileErrorResultSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try FileErrorResultSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for FileErrorResult: \(error)"
            }
        }
    }

    public class FileErrorResultSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: FileErrorResult) throws -> JSON {
            switch value {
            case .fileNotFoundError(let arg):
                var d = try ["file_not_found_error": Serialization._StringSerializer.serialize(arg)]
                d[".tag"] = .str("file_not_found_error")
                return .dictionary(d)
            case .invalidFileActionError(let arg):
                var d = try ["invalid_file_action_error": Serialization._StringSerializer.serialize(arg)]
                d[".tag"] = .str("invalid_file_action_error")
                return .dictionary(d)
            case .permissionDeniedError(let arg):
                var d = try ["permission_denied_error": Serialization._StringSerializer.serialize(arg)]
                d[".tag"] = .str("permission_denied_error")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> FileErrorResult {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "file_not_found_error":
                    let v = try Serialization._StringSerializer.deserialize(d["file_not_found_error"] ?? .null)
                    return FileErrorResult.fileNotFoundError(v)
                case "invalid_file_action_error":
                    let v = try Serialization._StringSerializer.deserialize(d["invalid_file_action_error"] ?? .null)
                    return FileErrorResult.invalidFileActionError(v)
                case "permission_denied_error":
                    let v = try Serialization._StringSerializer.deserialize(d["permission_denied_error"] ?? .null)
                    return FileErrorResult.permissionDeniedError(v)
                case "other":
                    return FileErrorResult.other
                default:
                    return FileErrorResult.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: FileErrorResult.self, json: json)
            }
        }
    }

    /// The metadata of a shared link.
    public class SharedLinkMetadata: CustomStringConvertible, JSONRepresentable {
        /// URL of the shared link.
        public let url: String
        /// A unique identifier for the linked file.
        public let id: String?
        /// The linked file name (including extension). This never contains a slash.
        public let name: String
        /// Expiration time, if set. By default the link won't expire.
        public let expires: Date?
        /// The lowercased full path in the user's Dropbox. This always starts with a slash. This field will only be
        /// present only if the linked file is in the authenticated user's  dropbox.
        public let pathLower: String?
        /// The link's access permissions.
        public let linkPermissions: Sharing.LinkPermissions
        /// The team membership information of the link's owner.  This field will only be present  if the link's owner
        /// is a team member.
        public let teamMemberInfo: Sharing.TeamMemberInfo?
        /// The team information of the content's owner. This field will only be present if the content's owner is a
        /// team member and the content's owner team is different from the link's owner team.
        public let contentOwnerTeamInfo: Users.Team?
        public init(
            url: String,
            name: String,
            linkPermissions: Sharing.LinkPermissions,
            id: String? = nil,
            expires: Date? = nil,
            pathLower: String? = nil,
            teamMemberInfo: Sharing.TeamMemberInfo? = nil,
            contentOwnerTeamInfo: Users.Team? = nil
        ) {
            stringValidator()(url)
            self.url = url
            nullableValidator(stringValidator(minLength: 1))(id)
            self.id = id
            stringValidator()(name)
            self.name = name
            self.expires = expires
            nullableValidator(stringValidator())(pathLower)
            self.pathLower = pathLower
            self.linkPermissions = linkPermissions
            self.teamMemberInfo = teamMemberInfo
            self.contentOwnerTeamInfo = contentOwnerTeamInfo
        }

        func json() throws -> JSON {
            try SharedLinkMetadataSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharedLinkMetadataSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharedLinkMetadata: \(error)"
            }
        }
    }

    public class SharedLinkMetadataSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharedLinkMetadata) throws -> JSON {
            var output = [
                "url": try Serialization._StringSerializer.serialize(value.url),
                "name": try Serialization._StringSerializer.serialize(value.name),
                "link_permissions": try Sharing.LinkPermissionsSerializer().serialize(value.linkPermissions),
                "id": try NullableSerializer(Serialization._StringSerializer).serialize(value.id),
                "expires": try NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.expires),
                "path_lower": try NullableSerializer(Serialization._StringSerializer).serialize(value.pathLower),
                "team_member_info": try NullableSerializer(Sharing.TeamMemberInfoSerializer()).serialize(value.teamMemberInfo),
                "content_owner_team_info": try NullableSerializer(Users.TeamSerializer()).serialize(value.contentOwnerTeamInfo),
            ]
            switch value {
            case let file as Sharing.FileLinkMetadata:
                for (k, v) in try Serialization.getFields(Sharing.FileLinkMetadataSerializer().serialize(file)) {
                    output[k] = v
                }
                output[".tag"] = .str("file")
            case let folder as Sharing.FolderLinkMetadata:
                for (k, v) in try Serialization.getFields(Sharing.FolderLinkMetadataSerializer().serialize(folder)) {
                    output[k] = v
                }
                output[".tag"] = .str("folder")
            default:
                throw JSONSerializerError.unexpectedSubtype(type: SharedLinkMetadata.self, subtype: value)
            }
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharedLinkMetadata {
            switch json {
            case .dictionary(let dict):
                let tag = try Serialization.getTag(dict)
                switch tag {
                case "file":
                    return try Sharing.FileLinkMetadataSerializer().deserialize(json)
                case "folder":
                    return try Sharing.FolderLinkMetadataSerializer().deserialize(json)
                default:
                    let url = try Serialization._StringSerializer.deserialize(dict["url"] ?? .null)
                    let name = try Serialization._StringSerializer.deserialize(dict["name"] ?? .null)
                    let linkPermissions = try Sharing.LinkPermissionsSerializer().deserialize(dict["link_permissions"] ?? .null)
                    let id = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["id"] ?? .null)
                    let expires = try NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).deserialize(dict["expires"] ?? .null)
                    let pathLower = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["path_lower"] ?? .null)
                    let teamMemberInfo = try NullableSerializer(Sharing.TeamMemberInfoSerializer()).deserialize(dict["team_member_info"] ?? .null)
                    let contentOwnerTeamInfo = try NullableSerializer(Users.TeamSerializer()).deserialize(dict["content_owner_team_info"] ?? .null)
                    return SharedLinkMetadata(
                        url: url,
                        name: name,
                        linkPermissions: linkPermissions,
                        id: id,
                        expires: expires,
                        pathLower: pathLower,
                        teamMemberInfo: teamMemberInfo,
                        contentOwnerTeamInfo: contentOwnerTeamInfo
                    )
                }
            default:
                throw JSONSerializerError.deserializeError(type: SharedLinkMetadata.self, json: json)
            }
        }
    }

    /// The metadata of a file shared link.
    public class FileLinkMetadata: Sharing.SharedLinkMetadata {
        /// The modification time set by the desktop client when the file was added to Dropbox. Since this time is not
        /// verified (the Dropbox server stores whatever the desktop client sends up), this should only be used
        /// for display purposes (such as sorting) and not, for example, to determine if a file has changed or
        /// not.
        public let clientModified: Date
        /// The last time the file was modified on Dropbox.
        public let serverModified: Date
        /// A unique identifier for the current revision of a file. This field is the same rev as elsewhere in the API
        /// and can be used to detect changes and avoid conflicts.
        public let rev: String
        /// The file size in bytes.
        public let size: UInt64
        public init(
            url: String,
            name: String,
            linkPermissions: Sharing.LinkPermissions,
            clientModified: Date,
            serverModified: Date,
            rev: String,
            size: UInt64,
            id: String? = nil,
            expires: Date? = nil,
            pathLower: String? = nil,
            teamMemberInfo: Sharing.TeamMemberInfo? = nil,
            contentOwnerTeamInfo: Users.Team? = nil
        ) {
            self.clientModified = clientModified
            self.serverModified = serverModified
            stringValidator(minLength: 9, pattern: "[0-9a-f]+")(rev)
            self.rev = rev
            comparableValidator()(size)
            self.size = size
            super.init(
                url: url,
                name: name,
                linkPermissions: linkPermissions,
                id: id,
                expires: expires,
                pathLower: pathLower,
                teamMemberInfo: teamMemberInfo,
                contentOwnerTeamInfo: contentOwnerTeamInfo
            )
        }

        public override var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try FileLinkMetadataSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for FileLinkMetadata: \(error)"
            }
        }
    }

    public class FileLinkMetadataSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: FileLinkMetadata) throws -> JSON {
            let output = [
                "url": try Serialization._StringSerializer.serialize(value.url),
                "name": try Serialization._StringSerializer.serialize(value.name),
                "link_permissions": try Sharing.LinkPermissionsSerializer().serialize(value.linkPermissions),
                "client_modified": try NSDateSerializer("%Y-%m-%dT%H:%M:%SZ").serialize(value.clientModified),
                "server_modified": try NSDateSerializer("%Y-%m-%dT%H:%M:%SZ").serialize(value.serverModified),
                "rev": try Serialization._StringSerializer.serialize(value.rev),
                "size": try Serialization._UInt64Serializer.serialize(value.size),
                "id": try NullableSerializer(Serialization._StringSerializer).serialize(value.id),
                "expires": try NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.expires),
                "path_lower": try NullableSerializer(Serialization._StringSerializer).serialize(value.pathLower),
                "team_member_info": try NullableSerializer(Sharing.TeamMemberInfoSerializer()).serialize(value.teamMemberInfo),
                "content_owner_team_info": try NullableSerializer(Users.TeamSerializer()).serialize(value.contentOwnerTeamInfo),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> FileLinkMetadata {
            switch json {
            case .dictionary(let dict):
                let url = try Serialization._StringSerializer.deserialize(dict["url"] ?? .null)
                let name = try Serialization._StringSerializer.deserialize(dict["name"] ?? .null)
                let linkPermissions = try Sharing.LinkPermissionsSerializer().deserialize(dict["link_permissions"] ?? .null)
                let clientModified = try NSDateSerializer("%Y-%m-%dT%H:%M:%SZ").deserialize(dict["client_modified"] ?? .null)
                let serverModified = try NSDateSerializer("%Y-%m-%dT%H:%M:%SZ").deserialize(dict["server_modified"] ?? .null)
                let rev = try Serialization._StringSerializer.deserialize(dict["rev"] ?? .null)
                let size = try Serialization._UInt64Serializer.deserialize(dict["size"] ?? .null)
                let id = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["id"] ?? .null)
                let expires = try NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).deserialize(dict["expires"] ?? .null)
                let pathLower = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["path_lower"] ?? .null)
                let teamMemberInfo = try NullableSerializer(Sharing.TeamMemberInfoSerializer()).deserialize(dict["team_member_info"] ?? .null)
                let contentOwnerTeamInfo = try NullableSerializer(Users.TeamSerializer()).deserialize(dict["content_owner_team_info"] ?? .null)
                return FileLinkMetadata(
                    url: url,
                    name: name,
                    linkPermissions: linkPermissions,
                    clientModified: clientModified,
                    serverModified: serverModified,
                    rev: rev,
                    size: size,
                    id: id,
                    expires: expires,
                    pathLower: pathLower,
                    teamMemberInfo: teamMemberInfo,
                    contentOwnerTeamInfo: contentOwnerTeamInfo
                )
            default:
                throw JSONSerializerError.deserializeError(type: FileLinkMetadata.self, json: json)
            }
        }
    }

    /// The FileMemberActionError union
    public enum FileMemberActionError: CustomStringConvertible, JSONRepresentable {
        /// Specified member was not found.
        case invalidMember
        /// User does not have permission to perform this action on this member.
        case noPermission
        /// Specified file was invalid or user does not have access.
        case accessError(Sharing.SharingFileAccessError)
        /// The action cannot be completed because the target member does not have explicit access to the file. The
        /// return value is the access that the member has to the file from a parent folder.
        case noExplicitAccess(Sharing.MemberAccessLevelResult)
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try FileMemberActionErrorSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try FileMemberActionErrorSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for FileMemberActionError: \(error)"
            }
        }
    }

    public class FileMemberActionErrorSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: FileMemberActionError) throws -> JSON {
            switch value {
            case .invalidMember:
                var d = [String: JSON]()
                d[".tag"] = .str("invalid_member")
                return .dictionary(d)
            case .noPermission:
                var d = [String: JSON]()
                d[".tag"] = .str("no_permission")
                return .dictionary(d)
            case .accessError(let arg):
                var d = try ["access_error": Sharing.SharingFileAccessErrorSerializer().serialize(arg)]
                d[".tag"] = .str("access_error")
                return .dictionary(d)
            case .noExplicitAccess(let arg):
                var d = try Serialization.getFields(Sharing.MemberAccessLevelResultSerializer().serialize(arg))
                d[".tag"] = .str("no_explicit_access")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> FileMemberActionError {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "invalid_member":
                    return FileMemberActionError.invalidMember
                case "no_permission":
                    return FileMemberActionError.noPermission
                case "access_error":
                    let v = try Sharing.SharingFileAccessErrorSerializer().deserialize(d["access_error"] ?? .null)
                    return FileMemberActionError.accessError(v)
                case "no_explicit_access":
                    let v = try Sharing.MemberAccessLevelResultSerializer().deserialize(json)
                    return FileMemberActionError.noExplicitAccess(v)
                case "other":
                    return FileMemberActionError.other
                default:
                    return FileMemberActionError.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: FileMemberActionError.self, json: json)
            }
        }
    }

    /// The FileMemberActionIndividualResult union
    public enum FileMemberActionIndividualResult: CustomStringConvertible, JSONRepresentable {
        /// Part of the response for both add_file_member and remove_file_member_v1 (deprecated). For add_file_member,
        /// indicates giving access was successful and at what AccessLevel. For remove_file_member_v1, indicates
        /// member was successfully removed from the file. If AccessLevel is given, the member still has access
        /// via a parent shared folder.
        case success(Sharing.AccessLevel?)
        /// User was not able to perform this action.
        case memberError(Sharing.FileMemberActionError)

        func json() throws -> JSON {
            try FileMemberActionIndividualResultSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try FileMemberActionIndividualResultSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for FileMemberActionIndividualResult: \(error)"
            }
        }
    }

    public class FileMemberActionIndividualResultSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: FileMemberActionIndividualResult) throws -> JSON {
            switch value {
            case .success(let arg):
                var d = try ["success": NullableSerializer(Sharing.AccessLevelSerializer()).serialize(arg)]
                d[".tag"] = .str("success")
                return .dictionary(d)
            case .memberError(let arg):
                var d = try ["member_error": Sharing.FileMemberActionErrorSerializer().serialize(arg)]
                d[".tag"] = .str("member_error")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> FileMemberActionIndividualResult {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "success":
                    let v = try NullableSerializer(Sharing.AccessLevelSerializer()).deserialize(d["success"] ?? .null)
                    return FileMemberActionIndividualResult.success(v)
                case "member_error":
                    let v = try Sharing.FileMemberActionErrorSerializer().deserialize(d["member_error"] ?? .null)
                    return FileMemberActionIndividualResult.memberError(v)
                default:
                    throw JSONSerializerError.unknownTag(type: FileMemberActionIndividualResult.self, json: json, tag: tag)
                }
            default:
                throw JSONSerializerError.deserializeError(type: FileMemberActionIndividualResult.self, json: json)
            }
        }
    }

    /// Per-member result for addFileMember.
    public class FileMemberActionResult: CustomStringConvertible, JSONRepresentable {
        /// One of specified input members.
        public let member: Sharing.MemberSelector
        /// The outcome of the action on this member.
        public let result: Sharing.FileMemberActionIndividualResult
        /// The SHA-1 encrypted shared content key.
        public let sckeySha1: String?
        /// The sharing sender-recipient invitation signatures for the input member_id. A member_id can be a group and
        /// thus have multiple users and multiple invitation signatures.
        public let invitationSignature: [String]?
        public init(
            member: Sharing.MemberSelector,
            result: Sharing.FileMemberActionIndividualResult,
            sckeySha1: String? = nil,
            invitationSignature: [String]? = nil
        ) {
            self.member = member
            self.result = result
            nullableValidator(stringValidator())(sckeySha1)
            self.sckeySha1 = sckeySha1
            nullableValidator(arrayValidator(itemValidator: stringValidator()))(invitationSignature)
            self.invitationSignature = invitationSignature
        }

        func json() throws -> JSON {
            try FileMemberActionResultSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try FileMemberActionResultSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for FileMemberActionResult: \(error)"
            }
        }
    }

    public class FileMemberActionResultSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: FileMemberActionResult) throws -> JSON {
            let output = [
                "member": try Sharing.MemberSelectorSerializer().serialize(value.member),
                "result": try Sharing.FileMemberActionIndividualResultSerializer().serialize(value.result),
                "sckey_sha1": try NullableSerializer(Serialization._StringSerializer).serialize(value.sckeySha1),
                "invitation_signature": try NullableSerializer(ArraySerializer(Serialization._StringSerializer)).serialize(value.invitationSignature),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> FileMemberActionResult {
            switch json {
            case .dictionary(let dict):
                let member = try Sharing.MemberSelectorSerializer().deserialize(dict["member"] ?? .null)
                let result = try Sharing.FileMemberActionIndividualResultSerializer().deserialize(dict["result"] ?? .null)
                let sckeySha1 = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["sckey_sha1"] ?? .null)
                let invitationSignature = try NullableSerializer(ArraySerializer(Serialization._StringSerializer))
                    .deserialize(dict["invitation_signature"] ?? .null)
                return FileMemberActionResult(member: member, result: result, sckeySha1: sckeySha1, invitationSignature: invitationSignature)
            default:
                throw JSONSerializerError.deserializeError(type: FileMemberActionResult.self, json: json)
            }
        }
    }

    /// The FileMemberRemoveActionResult union
    public enum FileMemberRemoveActionResult: CustomStringConvertible, JSONRepresentable {
        /// Member was successfully removed from this file.
        case success(Sharing.MemberAccessLevelResult)
        /// User was not able to remove this member.
        case memberError(Sharing.FileMemberActionError)
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try FileMemberRemoveActionResultSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try FileMemberRemoveActionResultSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for FileMemberRemoveActionResult: \(error)"
            }
        }
    }

    public class FileMemberRemoveActionResultSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: FileMemberRemoveActionResult) throws -> JSON {
            switch value {
            case .success(let arg):
                var d = try Serialization.getFields(Sharing.MemberAccessLevelResultSerializer().serialize(arg))
                d[".tag"] = .str("success")
                return .dictionary(d)
            case .memberError(let arg):
                var d = try ["member_error": Sharing.FileMemberActionErrorSerializer().serialize(arg)]
                d[".tag"] = .str("member_error")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> FileMemberRemoveActionResult {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "success":
                    let v = try Sharing.MemberAccessLevelResultSerializer().deserialize(json)
                    return FileMemberRemoveActionResult.success(v)
                case "member_error":
                    let v = try Sharing.FileMemberActionErrorSerializer().deserialize(d["member_error"] ?? .null)
                    return FileMemberRemoveActionResult.memberError(v)
                case "other":
                    return FileMemberRemoveActionResult.other
                default:
                    return FileMemberRemoveActionResult.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: FileMemberRemoveActionResult.self, json: json)
            }
        }
    }

    /// Whether the user is allowed to take the sharing action on the file.
    public class FilePermission: CustomStringConvertible, JSONRepresentable {
        /// The action that the user may wish to take on the file.
        public let action: Sharing.FileAction
        /// True if the user is allowed to take the action.
        public let allow: Bool
        /// The reason why the user is denied the permission. Not present if the action is allowed.
        public let reason: Sharing.PermissionDeniedReason?
        public init(action: Sharing.FileAction, allow: Bool, reason: Sharing.PermissionDeniedReason? = nil) {
            self.action = action
            self.allow = allow
            self.reason = reason
        }

        func json() throws -> JSON {
            try FilePermissionSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try FilePermissionSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for FilePermission: \(error)"
            }
        }
    }

    public class FilePermissionSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: FilePermission) throws -> JSON {
            let output = [
                "action": try Sharing.FileActionSerializer().serialize(value.action),
                "allow": try Serialization._BoolSerializer.serialize(value.allow),
                "reason": try NullableSerializer(Sharing.PermissionDeniedReasonSerializer()).serialize(value.reason),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> FilePermission {
            switch json {
            case .dictionary(let dict):
                let action = try Sharing.FileActionSerializer().deserialize(dict["action"] ?? .null)
                let allow = try Serialization._BoolSerializer.deserialize(dict["allow"] ?? .null)
                let reason = try NullableSerializer(Sharing.PermissionDeniedReasonSerializer()).deserialize(dict["reason"] ?? .null)
                return FilePermission(action: action, allow: allow, reason: reason)
            default:
                throw JSONSerializerError.deserializeError(type: FilePermission.self, json: json)
            }
        }
    }

    /// Actions that may be taken on shared folders.
    public enum FolderAction: CustomStringConvertible, JSONRepresentable {
        /// Change folder options, such as who can be invited to join the folder.
        case changeOptions
        /// Disable viewer information for this folder.
        case disableViewerInfo
        /// Change or edit contents of the folder.
        case editContents
        /// Enable viewer information on the folder.
        case enableViewerInfo
        /// Invite a user or group to join the folder with read and write permission.
        case inviteEditor
        /// Invite a user or group to join the folder with read permission.
        case inviteViewer
        /// Invite a user or group to join the folder with read permission but no comment permissions.
        case inviteViewerNoComment
        /// Relinquish one's own membership in the folder.
        case relinquishMembership
        /// Unmount the folder.
        case unmount
        /// Stop sharing this folder.
        case unshare
        /// Keep a copy of the contents upon leaving or being kicked from the folder.
        case leaveACopy
        /// Use create_link instead.
        case shareLink
        /// Create a shared link for folder.
        case createLink
        /// Set whether the folder inherits permissions from its parent.
        case setAccessInheritance
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try FolderActionSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try FolderActionSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for FolderAction: \(error)"
            }
        }
    }

    public class FolderActionSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: FolderAction) throws -> JSON {
            switch value {
            case .changeOptions:
                var d = [String: JSON]()
                d[".tag"] = .str("change_options")
                return .dictionary(d)
            case .disableViewerInfo:
                var d = [String: JSON]()
                d[".tag"] = .str("disable_viewer_info")
                return .dictionary(d)
            case .editContents:
                var d = [String: JSON]()
                d[".tag"] = .str("edit_contents")
                return .dictionary(d)
            case .enableViewerInfo:
                var d = [String: JSON]()
                d[".tag"] = .str("enable_viewer_info")
                return .dictionary(d)
            case .inviteEditor:
                var d = [String: JSON]()
                d[".tag"] = .str("invite_editor")
                return .dictionary(d)
            case .inviteViewer:
                var d = [String: JSON]()
                d[".tag"] = .str("invite_viewer")
                return .dictionary(d)
            case .inviteViewerNoComment:
                var d = [String: JSON]()
                d[".tag"] = .str("invite_viewer_no_comment")
                return .dictionary(d)
            case .relinquishMembership:
                var d = [String: JSON]()
                d[".tag"] = .str("relinquish_membership")
                return .dictionary(d)
            case .unmount:
                var d = [String: JSON]()
                d[".tag"] = .str("unmount")
                return .dictionary(d)
            case .unshare:
                var d = [String: JSON]()
                d[".tag"] = .str("unshare")
                return .dictionary(d)
            case .leaveACopy:
                var d = [String: JSON]()
                d[".tag"] = .str("leave_a_copy")
                return .dictionary(d)
            case .shareLink:
                var d = [String: JSON]()
                d[".tag"] = .str("share_link")
                return .dictionary(d)
            case .createLink:
                var d = [String: JSON]()
                d[".tag"] = .str("create_link")
                return .dictionary(d)
            case .setAccessInheritance:
                var d = [String: JSON]()
                d[".tag"] = .str("set_access_inheritance")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> FolderAction {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "change_options":
                    return FolderAction.changeOptions
                case "disable_viewer_info":
                    return FolderAction.disableViewerInfo
                case "edit_contents":
                    return FolderAction.editContents
                case "enable_viewer_info":
                    return FolderAction.enableViewerInfo
                case "invite_editor":
                    return FolderAction.inviteEditor
                case "invite_viewer":
                    return FolderAction.inviteViewer
                case "invite_viewer_no_comment":
                    return FolderAction.inviteViewerNoComment
                case "relinquish_membership":
                    return FolderAction.relinquishMembership
                case "unmount":
                    return FolderAction.unmount
                case "unshare":
                    return FolderAction.unshare
                case "leave_a_copy":
                    return FolderAction.leaveACopy
                case "share_link":
                    return FolderAction.shareLink
                case "create_link":
                    return FolderAction.createLink
                case "set_access_inheritance":
                    return FolderAction.setAccessInheritance
                case "other":
                    return FolderAction.other
                default:
                    return FolderAction.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: FolderAction.self, json: json)
            }
        }
    }

    /// The metadata of a folder shared link.
    public class FolderLinkMetadata: Sharing.SharedLinkMetadata {
        public override var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try FolderLinkMetadataSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for FolderLinkMetadata: \(error)"
            }
        }
    }

    public class FolderLinkMetadataSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: FolderLinkMetadata) throws -> JSON {
            let output = [
                "url": try Serialization._StringSerializer.serialize(value.url),
                "name": try Serialization._StringSerializer.serialize(value.name),
                "link_permissions": try Sharing.LinkPermissionsSerializer().serialize(value.linkPermissions),
                "id": try NullableSerializer(Serialization._StringSerializer).serialize(value.id),
                "expires": try NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.expires),
                "path_lower": try NullableSerializer(Serialization._StringSerializer).serialize(value.pathLower),
                "team_member_info": try NullableSerializer(Sharing.TeamMemberInfoSerializer()).serialize(value.teamMemberInfo),
                "content_owner_team_info": try NullableSerializer(Users.TeamSerializer()).serialize(value.contentOwnerTeamInfo),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> FolderLinkMetadata {
            switch json {
            case .dictionary(let dict):
                let url = try Serialization._StringSerializer.deserialize(dict["url"] ?? .null)
                let name = try Serialization._StringSerializer.deserialize(dict["name"] ?? .null)
                let linkPermissions = try Sharing.LinkPermissionsSerializer().deserialize(dict["link_permissions"] ?? .null)
                let id = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["id"] ?? .null)
                let expires = try NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).deserialize(dict["expires"] ?? .null)
                let pathLower = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["path_lower"] ?? .null)
                let teamMemberInfo = try NullableSerializer(Sharing.TeamMemberInfoSerializer()).deserialize(dict["team_member_info"] ?? .null)
                let contentOwnerTeamInfo = try NullableSerializer(Users.TeamSerializer()).deserialize(dict["content_owner_team_info"] ?? .null)
                return FolderLinkMetadata(
                    url: url,
                    name: name,
                    linkPermissions: linkPermissions,
                    id: id,
                    expires: expires,
                    pathLower: pathLower,
                    teamMemberInfo: teamMemberInfo,
                    contentOwnerTeamInfo: contentOwnerTeamInfo
                )
            default:
                throw JSONSerializerError.deserializeError(type: FolderLinkMetadata.self, json: json)
            }
        }
    }

    /// Whether the user is allowed to take the action on the shared folder.
    public class FolderPermission: CustomStringConvertible, JSONRepresentable {
        /// The action that the user may wish to take on the folder.
        public let action: Sharing.FolderAction
        /// True if the user is allowed to take the action.
        public let allow: Bool
        /// The reason why the user is denied the permission. Not present if the action is allowed, or if no reason is
        /// available.
        public let reason: Sharing.PermissionDeniedReason?
        public init(action: Sharing.FolderAction, allow: Bool, reason: Sharing.PermissionDeniedReason? = nil) {
            self.action = action
            self.allow = allow
            self.reason = reason
        }

        func json() throws -> JSON {
            try FolderPermissionSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try FolderPermissionSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for FolderPermission: \(error)"
            }
        }
    }

    public class FolderPermissionSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: FolderPermission) throws -> JSON {
            let output = [
                "action": try Sharing.FolderActionSerializer().serialize(value.action),
                "allow": try Serialization._BoolSerializer.serialize(value.allow),
                "reason": try NullableSerializer(Sharing.PermissionDeniedReasonSerializer()).serialize(value.reason),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> FolderPermission {
            switch json {
            case .dictionary(let dict):
                let action = try Sharing.FolderActionSerializer().deserialize(dict["action"] ?? .null)
                let allow = try Serialization._BoolSerializer.deserialize(dict["allow"] ?? .null)
                let reason = try NullableSerializer(Sharing.PermissionDeniedReasonSerializer()).deserialize(dict["reason"] ?? .null)
                return FolderPermission(action: action, allow: allow, reason: reason)
            default:
                throw JSONSerializerError.deserializeError(type: FolderPermission.self, json: json)
            }
        }
    }

    /// A set of policies governing membership and privileges for a shared folder.
    public class FolderPolicy: CustomStringConvertible, JSONRepresentable {
        /// Who can be a member of this shared folder, as set on the folder itself. The effective policy may differ from
        /// this value if the team-wide policy is more restrictive. Present only if the folder is owned by a
        /// team.
        public let memberPolicy: Sharing.MemberPolicy?
        /// Who can be a member of this shared folder, taking into account both the folder and the team-wide policy.
        /// This value may differ from that of member_policy if the team-wide policy is more restrictive than
        /// the folder policy. Present only if the folder is owned by a team.
        public let resolvedMemberPolicy: Sharing.MemberPolicy?
        /// Who can add and remove members from this shared folder.
        public let aclUpdatePolicy: Sharing.AclUpdatePolicy
        /// Who links can be shared with.
        public let sharedLinkPolicy: Sharing.SharedLinkPolicy
        /// Who can enable/disable viewer info for this shared folder.
        public let viewerInfoPolicy: Sharing.ViewerInfoPolicy?
        public init(
            aclUpdatePolicy: Sharing.AclUpdatePolicy,
            sharedLinkPolicy: Sharing.SharedLinkPolicy,
            memberPolicy: Sharing.MemberPolicy? = nil,
            resolvedMemberPolicy: Sharing.MemberPolicy? = nil,
            viewerInfoPolicy: Sharing.ViewerInfoPolicy? = nil
        ) {
            self.memberPolicy = memberPolicy
            self.resolvedMemberPolicy = resolvedMemberPolicy
            self.aclUpdatePolicy = aclUpdatePolicy
            self.sharedLinkPolicy = sharedLinkPolicy
            self.viewerInfoPolicy = viewerInfoPolicy
        }

        func json() throws -> JSON {
            try FolderPolicySerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try FolderPolicySerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for FolderPolicy: \(error)"
            }
        }
    }

    public class FolderPolicySerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: FolderPolicy) throws -> JSON {
            let output = [
                "acl_update_policy": try Sharing.AclUpdatePolicySerializer().serialize(value.aclUpdatePolicy),
                "shared_link_policy": try Sharing.SharedLinkPolicySerializer().serialize(value.sharedLinkPolicy),
                "member_policy": try NullableSerializer(Sharing.MemberPolicySerializer()).serialize(value.memberPolicy),
                "resolved_member_policy": try NullableSerializer(Sharing.MemberPolicySerializer()).serialize(value.resolvedMemberPolicy),
                "viewer_info_policy": try NullableSerializer(Sharing.ViewerInfoPolicySerializer()).serialize(value.viewerInfoPolicy),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> FolderPolicy {
            switch json {
            case .dictionary(let dict):
                let aclUpdatePolicy = try Sharing.AclUpdatePolicySerializer().deserialize(dict["acl_update_policy"] ?? .null)
                let sharedLinkPolicy = try Sharing.SharedLinkPolicySerializer().deserialize(dict["shared_link_policy"] ?? .null)
                let memberPolicy = try NullableSerializer(Sharing.MemberPolicySerializer()).deserialize(dict["member_policy"] ?? .null)
                let resolvedMemberPolicy = try NullableSerializer(Sharing.MemberPolicySerializer()).deserialize(dict["resolved_member_policy"] ?? .null)
                let viewerInfoPolicy = try NullableSerializer(Sharing.ViewerInfoPolicySerializer()).deserialize(dict["viewer_info_policy"] ?? .null)
                return FolderPolicy(
                    aclUpdatePolicy: aclUpdatePolicy,
                    sharedLinkPolicy: sharedLinkPolicy,
                    memberPolicy: memberPolicy,
                    resolvedMemberPolicy: resolvedMemberPolicy,
                    viewerInfoPolicy: viewerInfoPolicy
                )
            default:
                throw JSONSerializerError.deserializeError(type: FolderPolicy.self, json: json)
            }
        }
    }

    /// Arguments of getFileMetadata.
    public class GetFileMetadataArg: CustomStringConvertible, JSONRepresentable {
        /// The file to query.
        public let file: String
        /// A list of `FileAction`s corresponding to `FilePermission`s that should appear in the  response's permissions
        /// in SharedFileMetadata field describing the actions the  authenticated user can perform on the file.
        public let actions: [Sharing.FileAction]?
        public init(file: String, actions: [Sharing.FileAction]? = nil) {
            stringValidator(minLength: 1, pattern: "((/|id:).*|nspath:[0-9]+:.*)|ns:[0-9]+(/.*)?")(file)
            self.file = file
            self.actions = actions
        }

        func json() throws -> JSON {
            try GetFileMetadataArgSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try GetFileMetadataArgSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for GetFileMetadataArg: \(error)"
            }
        }
    }

    public class GetFileMetadataArgSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: GetFileMetadataArg) throws -> JSON {
            let output = [
                "file": try Serialization._StringSerializer.serialize(value.file),
                "actions": try NullableSerializer(ArraySerializer(Sharing.FileActionSerializer())).serialize(value.actions),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> GetFileMetadataArg {
            switch json {
            case .dictionary(let dict):
                let file = try Serialization._StringSerializer.deserialize(dict["file"] ?? .null)
                let actions = try NullableSerializer(ArraySerializer(Sharing.FileActionSerializer())).deserialize(dict["actions"] ?? .null)
                return GetFileMetadataArg(file: file, actions: actions)
            default:
                throw JSONSerializerError.deserializeError(type: GetFileMetadataArg.self, json: json)
            }
        }
    }

    /// Arguments of getFileMetadataBatch.
    public class GetFileMetadataBatchArg: CustomStringConvertible, JSONRepresentable {
        /// The files to query.
        public let files: [String]
        /// A list of `FileAction`s corresponding to `FilePermission`s that should appear in the  response's permissions
        /// in SharedFileMetadata field describing the actions the  authenticated user can perform on the file.
        public let actions: [Sharing.FileAction]?
        public init(files: [String], actions: [Sharing.FileAction]? = nil) {
            arrayValidator(maxItems: 100, itemValidator: stringValidator(minLength: 1, pattern: "((/|id:).*|nspath:[0-9]+:.*)|ns:[0-9]+(/.*)?"))(files)
            self.files = files
            self.actions = actions
        }

        func json() throws -> JSON {
            try GetFileMetadataBatchArgSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try GetFileMetadataBatchArgSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for GetFileMetadataBatchArg: \(error)"
            }
        }
    }

    public class GetFileMetadataBatchArgSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: GetFileMetadataBatchArg) throws -> JSON {
            let output = [
                "files": try ArraySerializer(Serialization._StringSerializer).serialize(value.files),
                "actions": try NullableSerializer(ArraySerializer(Sharing.FileActionSerializer())).serialize(value.actions),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> GetFileMetadataBatchArg {
            switch json {
            case .dictionary(let dict):
                let files = try ArraySerializer(Serialization._StringSerializer).deserialize(dict["files"] ?? .null)
                let actions = try NullableSerializer(ArraySerializer(Sharing.FileActionSerializer())).deserialize(dict["actions"] ?? .null)
                return GetFileMetadataBatchArg(files: files, actions: actions)
            default:
                throw JSONSerializerError.deserializeError(type: GetFileMetadataBatchArg.self, json: json)
            }
        }
    }

    /// Per file results of getFileMetadataBatch.
    public class GetFileMetadataBatchResult: CustomStringConvertible, JSONRepresentable {
        /// This is the input file identifier corresponding to one of files in GetFileMetadataBatchArg.
        public let file: String
        /// The result for this particular file.
        public let result: Sharing.GetFileMetadataIndividualResult
        public init(file: String, result: Sharing.GetFileMetadataIndividualResult) {
            stringValidator(minLength: 1, pattern: "((/|id:).*|nspath:[0-9]+:.*)|ns:[0-9]+(/.*)?")(file)
            self.file = file
            self.result = result
        }

        func json() throws -> JSON {
            try GetFileMetadataBatchResultSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try GetFileMetadataBatchResultSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for GetFileMetadataBatchResult: \(error)"
            }
        }
    }

    public class GetFileMetadataBatchResultSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: GetFileMetadataBatchResult) throws -> JSON {
            let output = [
                "file": try Serialization._StringSerializer.serialize(value.file),
                "result": try Sharing.GetFileMetadataIndividualResultSerializer().serialize(value.result),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> GetFileMetadataBatchResult {
            switch json {
            case .dictionary(let dict):
                let file = try Serialization._StringSerializer.deserialize(dict["file"] ?? .null)
                let result = try Sharing.GetFileMetadataIndividualResultSerializer().deserialize(dict["result"] ?? .null)
                return GetFileMetadataBatchResult(file: file, result: result)
            default:
                throw JSONSerializerError.deserializeError(type: GetFileMetadataBatchResult.self, json: json)
            }
        }
    }

    /// Error result for getFileMetadata.
    public enum GetFileMetadataError: CustomStringConvertible, JSONRepresentable {
        /// An unspecified error.
        case userError(Sharing.SharingUserError)
        /// An unspecified error.
        case accessError(Sharing.SharingFileAccessError)
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try GetFileMetadataErrorSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try GetFileMetadataErrorSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for GetFileMetadataError: \(error)"
            }
        }
    }

    public class GetFileMetadataErrorSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: GetFileMetadataError) throws -> JSON {
            switch value {
            case .userError(let arg):
                var d = try ["user_error": Sharing.SharingUserErrorSerializer().serialize(arg)]
                d[".tag"] = .str("user_error")
                return .dictionary(d)
            case .accessError(let arg):
                var d = try ["access_error": Sharing.SharingFileAccessErrorSerializer().serialize(arg)]
                d[".tag"] = .str("access_error")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> GetFileMetadataError {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "user_error":
                    let v = try Sharing.SharingUserErrorSerializer().deserialize(d["user_error"] ?? .null)
                    return GetFileMetadataError.userError(v)
                case "access_error":
                    let v = try Sharing.SharingFileAccessErrorSerializer().deserialize(d["access_error"] ?? .null)
                    return GetFileMetadataError.accessError(v)
                case "other":
                    return GetFileMetadataError.other
                default:
                    return GetFileMetadataError.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: GetFileMetadataError.self, json: json)
            }
        }
    }

    /// The GetFileMetadataIndividualResult union
    public enum GetFileMetadataIndividualResult: CustomStringConvertible, JSONRepresentable {
        /// The result for this file if it was successful.
        case metadata(Sharing.SharedFileMetadata)
        /// The result for this file if it was an error.
        case accessError(Sharing.SharingFileAccessError)
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try GetFileMetadataIndividualResultSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try GetFileMetadataIndividualResultSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for GetFileMetadataIndividualResult: \(error)"
            }
        }
    }

    public class GetFileMetadataIndividualResultSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: GetFileMetadataIndividualResult) throws -> JSON {
            switch value {
            case .metadata(let arg):
                var d = try Serialization.getFields(Sharing.SharedFileMetadataSerializer().serialize(arg))
                d[".tag"] = .str("metadata")
                return .dictionary(d)
            case .accessError(let arg):
                var d = try ["access_error": Sharing.SharingFileAccessErrorSerializer().serialize(arg)]
                d[".tag"] = .str("access_error")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> GetFileMetadataIndividualResult {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "metadata":
                    let v = try Sharing.SharedFileMetadataSerializer().deserialize(json)
                    return GetFileMetadataIndividualResult.metadata(v)
                case "access_error":
                    let v = try Sharing.SharingFileAccessErrorSerializer().deserialize(d["access_error"] ?? .null)
                    return GetFileMetadataIndividualResult.accessError(v)
                case "other":
                    return GetFileMetadataIndividualResult.other
                default:
                    return GetFileMetadataIndividualResult.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: GetFileMetadataIndividualResult.self, json: json)
            }
        }
    }

    /// The GetMetadataArgs struct
    public class GetMetadataArgs: CustomStringConvertible, JSONRepresentable {
        /// The ID for the shared folder.
        public let sharedFolderId: String
        /// A list of `FolderAction`s corresponding to `FolderPermission`s that should appear in the  response's
        /// permissions in SharedFolderMetadata field describing the actions the  authenticated user can perform
        /// on the folder.
        public let actions: [Sharing.FolderAction]?
        public init(sharedFolderId: String, actions: [Sharing.FolderAction]? = nil) {
            stringValidator(pattern: "[-_0-9a-zA-Z:]+")(sharedFolderId)
            self.sharedFolderId = sharedFolderId
            self.actions = actions
        }

        func json() throws -> JSON {
            try GetMetadataArgsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try GetMetadataArgsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for GetMetadataArgs: \(error)"
            }
        }
    }

    public class GetMetadataArgsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: GetMetadataArgs) throws -> JSON {
            let output = [
                "shared_folder_id": try Serialization._StringSerializer.serialize(value.sharedFolderId),
                "actions": try NullableSerializer(ArraySerializer(Sharing.FolderActionSerializer())).serialize(value.actions),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> GetMetadataArgs {
            switch json {
            case .dictionary(let dict):
                let sharedFolderId = try Serialization._StringSerializer.deserialize(dict["shared_folder_id"] ?? .null)
                let actions = try NullableSerializer(ArraySerializer(Sharing.FolderActionSerializer())).deserialize(dict["actions"] ?? .null)
                return GetMetadataArgs(sharedFolderId: sharedFolderId, actions: actions)
            default:
                throw JSONSerializerError.deserializeError(type: GetMetadataArgs.self, json: json)
            }
        }
    }

    /// The SharedLinkError union
    public enum SharedLinkError: CustomStringConvertible, JSONRepresentable {
        /// The shared link wasn't found.
        case sharedLinkNotFound
        /// The caller is not allowed to access this shared link.
        case sharedLinkAccessDenied
        /// This type of link is not supported; use files instead.
        case unsupportedLinkType
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try SharedLinkErrorSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharedLinkErrorSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharedLinkError: \(error)"
            }
        }
    }

    public class SharedLinkErrorSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharedLinkError) throws -> JSON {
            switch value {
            case .sharedLinkNotFound:
                var d = [String: JSON]()
                d[".tag"] = .str("shared_link_not_found")
                return .dictionary(d)
            case .sharedLinkAccessDenied:
                var d = [String: JSON]()
                d[".tag"] = .str("shared_link_access_denied")
                return .dictionary(d)
            case .unsupportedLinkType:
                var d = [String: JSON]()
                d[".tag"] = .str("unsupported_link_type")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> SharedLinkError {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "shared_link_not_found":
                    return SharedLinkError.sharedLinkNotFound
                case "shared_link_access_denied":
                    return SharedLinkError.sharedLinkAccessDenied
                case "unsupported_link_type":
                    return SharedLinkError.unsupportedLinkType
                case "other":
                    return SharedLinkError.other
                default:
                    return SharedLinkError.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: SharedLinkError.self, json: json)
            }
        }
    }

    /// The GetSharedLinkFileError union
    public enum GetSharedLinkFileError: CustomStringConvertible, JSONRepresentable {
        /// The shared link wasn't found.
        case sharedLinkNotFound
        /// The caller is not allowed to access this shared link.
        case sharedLinkAccessDenied
        /// This type of link is not supported; use files instead.
        case unsupportedLinkType
        /// An unspecified error.
        case other
        /// Directories cannot be retrieved by this endpoint.
        case sharedLinkIsDirectory

        func json() throws -> JSON {
            try GetSharedLinkFileErrorSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try GetSharedLinkFileErrorSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for GetSharedLinkFileError: \(error)"
            }
        }
    }

    public class GetSharedLinkFileErrorSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: GetSharedLinkFileError) throws -> JSON {
            switch value {
            case .sharedLinkNotFound:
                var d = [String: JSON]()
                d[".tag"] = .str("shared_link_not_found")
                return .dictionary(d)
            case .sharedLinkAccessDenied:
                var d = [String: JSON]()
                d[".tag"] = .str("shared_link_access_denied")
                return .dictionary(d)
            case .unsupportedLinkType:
                var d = [String: JSON]()
                d[".tag"] = .str("unsupported_link_type")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            case .sharedLinkIsDirectory:
                var d = [String: JSON]()
                d[".tag"] = .str("shared_link_is_directory")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> GetSharedLinkFileError {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "shared_link_not_found":
                    return GetSharedLinkFileError.sharedLinkNotFound
                case "shared_link_access_denied":
                    return GetSharedLinkFileError.sharedLinkAccessDenied
                case "unsupported_link_type":
                    return GetSharedLinkFileError.unsupportedLinkType
                case "other":
                    return GetSharedLinkFileError.other
                case "shared_link_is_directory":
                    return GetSharedLinkFileError.sharedLinkIsDirectory
                default:
                    throw JSONSerializerError.unknownTag(type: GetSharedLinkFileError.self, json: json, tag: tag)
                }
            default:
                throw JSONSerializerError.deserializeError(type: GetSharedLinkFileError.self, json: json)
            }
        }
    }

    /// The GetSharedLinkMetadataArg struct
    public class GetSharedLinkMetadataArg: CustomStringConvertible, JSONRepresentable {
        /// URL of the shared link.
        public let url: String
        /// If the shared link is to a folder, this parameter can be used to retrieve the metadata for a specific file
        /// or sub-folder in this folder. A relative path should be used.
        public let path: String?
        /// If the shared link has a password, this parameter can be used.
        public let linkPassword: String?
        public init(url: String, path: String? = nil, linkPassword: String? = nil) {
            stringValidator()(url)
            self.url = url
            nullableValidator(stringValidator(pattern: "/(.|[\\r\\n])*"))(path)
            self.path = path
            nullableValidator(stringValidator())(linkPassword)
            self.linkPassword = linkPassword
        }

        func json() throws -> JSON {
            try GetSharedLinkMetadataArgSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try GetSharedLinkMetadataArgSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for GetSharedLinkMetadataArg: \(error)"
            }
        }
    }

    public class GetSharedLinkMetadataArgSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: GetSharedLinkMetadataArg) throws -> JSON {
            let output = [
                "url": try Serialization._StringSerializer.serialize(value.url),
                "path": try NullableSerializer(Serialization._StringSerializer).serialize(value.path),
                "link_password": try NullableSerializer(Serialization._StringSerializer).serialize(value.linkPassword),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> GetSharedLinkMetadataArg {
            switch json {
            case .dictionary(let dict):
                let url = try Serialization._StringSerializer.deserialize(dict["url"] ?? .null)
                let path = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["path"] ?? .null)
                let linkPassword = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["link_password"] ?? .null)
                return GetSharedLinkMetadataArg(url: url, path: path, linkPassword: linkPassword)
            default:
                throw JSONSerializerError.deserializeError(type: GetSharedLinkMetadataArg.self, json: json)
            }
        }
    }

    /// The GetSharedLinksArg struct
    public class GetSharedLinksArg: CustomStringConvertible, JSONRepresentable {
        /// See getSharedLinks description.
        public let path: String?
        public init(path: String? = nil) {
            nullableValidator(stringValidator())(path)
            self.path = path
        }

        func json() throws -> JSON {
            try GetSharedLinksArgSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try GetSharedLinksArgSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for GetSharedLinksArg: \(error)"
            }
        }
    }

    public class GetSharedLinksArgSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: GetSharedLinksArg) throws -> JSON {
            let output = [
                "path": try NullableSerializer(Serialization._StringSerializer).serialize(value.path),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> GetSharedLinksArg {
            switch json {
            case .dictionary(let dict):
                let path = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["path"] ?? .null)
                return GetSharedLinksArg(path: path)
            default:
                throw JSONSerializerError.deserializeError(type: GetSharedLinksArg.self, json: json)
            }
        }
    }

    /// The GetSharedLinksError union
    public enum GetSharedLinksError: CustomStringConvertible, JSONRepresentable {
        /// An unspecified error.
        case path(String?)
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try GetSharedLinksErrorSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try GetSharedLinksErrorSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for GetSharedLinksError: \(error)"
            }
        }
    }

    public class GetSharedLinksErrorSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: GetSharedLinksError) throws -> JSON {
            switch value {
            case .path(let arg):
                var d = try ["path": NullableSerializer(Serialization._StringSerializer).serialize(arg)]
                d[".tag"] = .str("path")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> GetSharedLinksError {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "path":
                    let v = try NullableSerializer(Serialization._StringSerializer).deserialize(d["path"] ?? .null)
                    return GetSharedLinksError.path(v)
                case "other":
                    return GetSharedLinksError.other
                default:
                    return GetSharedLinksError.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: GetSharedLinksError.self, json: json)
            }
        }
    }

    /// The GetSharedLinksResult struct
    public class GetSharedLinksResult: CustomStringConvertible, JSONRepresentable {
        /// Shared links applicable to the path argument.
        public let links: [Sharing.LinkMetadata]
        public init(links: [Sharing.LinkMetadata]) {
            self.links = links
        }

        func json() throws -> JSON {
            try GetSharedLinksResultSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try GetSharedLinksResultSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for GetSharedLinksResult: \(error)"
            }
        }
    }

    public class GetSharedLinksResultSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: GetSharedLinksResult) throws -> JSON {
            let output = [
                "links": try ArraySerializer(Sharing.LinkMetadataSerializer()).serialize(value.links),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> GetSharedLinksResult {
            switch json {
            case .dictionary(let dict):
                let links = try ArraySerializer(Sharing.LinkMetadataSerializer()).deserialize(dict["links"] ?? .null)
                return GetSharedLinksResult(links: links)
            default:
                throw JSONSerializerError.deserializeError(type: GetSharedLinksResult.self, json: json)
            }
        }
    }

    /// The information about a group. Groups is a way to manage a list of users  who need same access permission to the
    /// shared folder.
    public class GroupInfo: TeamCommon.GroupSummary {
        /// The type of group.
        public let groupType: TeamCommon.GroupType
        /// If the current user is a member of the group.
        public let isMember: Bool
        /// If the current user is an owner of the group.
        public let isOwner: Bool
        /// If the group is owned by the current user's team.
        public let sameTeam: Bool
        public init(
            groupName: String,
            groupId: String,
            groupManagementType: TeamCommon.GroupManagementType,
            groupType: TeamCommon.GroupType,
            isMember: Bool,
            isOwner: Bool,
            sameTeam: Bool,
            groupExternalId: String? = nil,
            memberCount: UInt32? = nil
        ) {
            self.groupType = groupType
            self.isMember = isMember
            self.isOwner = isOwner
            self.sameTeam = sameTeam
            super.init(
                groupName: groupName,
                groupId: groupId,
                groupManagementType: groupManagementType,
                groupExternalId: groupExternalId,
                memberCount: memberCount
            )
        }

        public override var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try GroupInfoSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for GroupInfo: \(error)"
            }
        }
    }

    public class GroupInfoSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: GroupInfo) throws -> JSON {
            let output = [
                "group_name": try Serialization._StringSerializer.serialize(value.groupName),
                "group_id": try Serialization._StringSerializer.serialize(value.groupId),
                "group_management_type": try TeamCommon.GroupManagementTypeSerializer().serialize(value.groupManagementType),
                "group_type": try TeamCommon.GroupTypeSerializer().serialize(value.groupType),
                "is_member": try Serialization._BoolSerializer.serialize(value.isMember),
                "is_owner": try Serialization._BoolSerializer.serialize(value.isOwner),
                "same_team": try Serialization._BoolSerializer.serialize(value.sameTeam),
                "group_external_id": try NullableSerializer(Serialization._StringSerializer).serialize(value.groupExternalId),
                "member_count": try NullableSerializer(Serialization._UInt32Serializer).serialize(value.memberCount),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> GroupInfo {
            switch json {
            case .dictionary(let dict):
                let groupName = try Serialization._StringSerializer.deserialize(dict["group_name"] ?? .null)
                let groupId = try Serialization._StringSerializer.deserialize(dict["group_id"] ?? .null)
                let groupManagementType = try TeamCommon.GroupManagementTypeSerializer().deserialize(dict["group_management_type"] ?? .null)
                let groupType = try TeamCommon.GroupTypeSerializer().deserialize(dict["group_type"] ?? .null)
                let isMember = try Serialization._BoolSerializer.deserialize(dict["is_member"] ?? .null)
                let isOwner = try Serialization._BoolSerializer.deserialize(dict["is_owner"] ?? .null)
                let sameTeam = try Serialization._BoolSerializer.deserialize(dict["same_team"] ?? .null)
                let groupExternalId = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["group_external_id"] ?? .null)
                let memberCount = try NullableSerializer(Serialization._UInt32Serializer).deserialize(dict["member_count"] ?? .null)
                return GroupInfo(
                    groupName: groupName,
                    groupId: groupId,
                    groupManagementType: groupManagementType,
                    groupType: groupType,
                    isMember: isMember,
                    isOwner: isOwner,
                    sameTeam: sameTeam,
                    groupExternalId: groupExternalId,
                    memberCount: memberCount
                )
            default:
                throw JSONSerializerError.deserializeError(type: GroupInfo.self, json: json)
            }
        }
    }

    /// The information about a member of the shared content.
    public class MembershipInfo: CustomStringConvertible, JSONRepresentable {
        /// The access type for this member. It contains inherited access type from parent folder, and acquired access
        /// type from this folder.
        public let accessType: Sharing.AccessLevel
        /// The permissions that requesting user has on this member. The set of permissions corresponds to the
        /// MemberActions in the request.
        public let permissions: [Sharing.MemberPermission]?
        /// Never set.
        public let initials: String?
        /// True if the member has access from a parent folder.
        public let isInherited: Bool
        public init(accessType: Sharing.AccessLevel, permissions: [Sharing.MemberPermission]? = nil, initials: String? = nil, isInherited: Bool = false) {
            self.accessType = accessType
            self.permissions = permissions
            nullableValidator(stringValidator())(initials)
            self.initials = initials
            self.isInherited = isInherited
        }

        func json() throws -> JSON {
            try MembershipInfoSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try MembershipInfoSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for MembershipInfo: \(error)"
            }
        }
    }

    public class MembershipInfoSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: MembershipInfo) throws -> JSON {
            let output = [
                "access_type": try Sharing.AccessLevelSerializer().serialize(value.accessType),
                "permissions": try NullableSerializer(ArraySerializer(Sharing.MemberPermissionSerializer())).serialize(value.permissions),
                "initials": try NullableSerializer(Serialization._StringSerializer).serialize(value.initials),
                "is_inherited": try Serialization._BoolSerializer.serialize(value.isInherited),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> MembershipInfo {
            switch json {
            case .dictionary(let dict):
                let accessType = try Sharing.AccessLevelSerializer().deserialize(dict["access_type"] ?? .null)
                let permissions = try NullableSerializer(ArraySerializer(Sharing.MemberPermissionSerializer())).deserialize(dict["permissions"] ?? .null)
                let initials = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["initials"] ?? .null)
                let isInherited = try Serialization._BoolSerializer.deserialize(dict["is_inherited"] ?? .number(0))
                return MembershipInfo(accessType: accessType, permissions: permissions, initials: initials, isInherited: isInherited)
            default:
                throw JSONSerializerError.deserializeError(type: MembershipInfo.self, json: json)
            }
        }
    }

    /// The information about a group member of the shared content.
    public class GroupMembershipInfo: Sharing.MembershipInfo {
        /// The information about the membership group.
        public let group: Sharing.GroupInfo
        public init(
            accessType: Sharing.AccessLevel,
            group: Sharing.GroupInfo,
            permissions: [Sharing.MemberPermission]? = nil,
            initials: String? = nil,
            isInherited: Bool = false
        ) {
            self.group = group
            super.init(accessType: accessType, permissions: permissions, initials: initials, isInherited: isInherited)
        }

        public override var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try GroupMembershipInfoSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for GroupMembershipInfo: \(error)"
            }
        }
    }

    public class GroupMembershipInfoSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: GroupMembershipInfo) throws -> JSON {
            let output = [
                "access_type": try Sharing.AccessLevelSerializer().serialize(value.accessType),
                "group": try Sharing.GroupInfoSerializer().serialize(value.group),
                "permissions": try NullableSerializer(ArraySerializer(Sharing.MemberPermissionSerializer())).serialize(value.permissions),
                "initials": try NullableSerializer(Serialization._StringSerializer).serialize(value.initials),
                "is_inherited": try Serialization._BoolSerializer.serialize(value.isInherited),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> GroupMembershipInfo {
            switch json {
            case .dictionary(let dict):
                let accessType = try Sharing.AccessLevelSerializer().deserialize(dict["access_type"] ?? .null)
                let group = try Sharing.GroupInfoSerializer().deserialize(dict["group"] ?? .null)
                let permissions = try NullableSerializer(ArraySerializer(Sharing.MemberPermissionSerializer())).deserialize(dict["permissions"] ?? .null)
                let initials = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["initials"] ?? .null)
                let isInherited = try Serialization._BoolSerializer.deserialize(dict["is_inherited"] ?? .number(0))
                return GroupMembershipInfo(accessType: accessType, group: group, permissions: permissions, initials: initials, isInherited: isInherited)
            default:
                throw JSONSerializerError.deserializeError(type: GroupMembershipInfo.self, json: json)
            }
        }
    }

    /// The InsufficientPlan struct
    public class InsufficientPlan: CustomStringConvertible, JSONRepresentable {
        /// A message to tell the user to upgrade in order to support expected action.
        public let message: String
        /// A URL to send the user to in order to obtain the account type they need, e.g. upgrading. Absent if there is
        /// no action the user can take to upgrade.
        public let upsellUrl: String?
        public init(message: String, upsellUrl: String? = nil) {
            stringValidator()(message)
            self.message = message
            nullableValidator(stringValidator())(upsellUrl)
            self.upsellUrl = upsellUrl
        }

        func json() throws -> JSON {
            try InsufficientPlanSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try InsufficientPlanSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for InsufficientPlan: \(error)"
            }
        }
    }

    public class InsufficientPlanSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: InsufficientPlan) throws -> JSON {
            let output = [
                "message": try Serialization._StringSerializer.serialize(value.message),
                "upsell_url": try NullableSerializer(Serialization._StringSerializer).serialize(value.upsellUrl),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> InsufficientPlan {
            switch json {
            case .dictionary(let dict):
                let message = try Serialization._StringSerializer.deserialize(dict["message"] ?? .null)
                let upsellUrl = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["upsell_url"] ?? .null)
                return InsufficientPlan(message: message, upsellUrl: upsellUrl)
            default:
                throw JSONSerializerError.deserializeError(type: InsufficientPlan.self, json: json)
            }
        }
    }

    /// The InsufficientQuotaAmounts struct
    public class InsufficientQuotaAmounts: CustomStringConvertible, JSONRepresentable {
        /// The amount of space needed to add the item (the size of the item).
        public let spaceNeeded: UInt64
        /// The amount of extra space needed to add the item.
        public let spaceShortage: UInt64
        /// The amount of space left in the user's Dropbox, less than space_needed.
        public let spaceLeft: UInt64
        public init(spaceNeeded: UInt64, spaceShortage: UInt64, spaceLeft: UInt64) {
            comparableValidator()(spaceNeeded)
            self.spaceNeeded = spaceNeeded
            comparableValidator()(spaceShortage)
            self.spaceShortage = spaceShortage
            comparableValidator()(spaceLeft)
            self.spaceLeft = spaceLeft
        }

        func json() throws -> JSON {
            try InsufficientQuotaAmountsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try InsufficientQuotaAmountsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for InsufficientQuotaAmounts: \(error)"
            }
        }
    }

    public class InsufficientQuotaAmountsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: InsufficientQuotaAmounts) throws -> JSON {
            let output = [
                "space_needed": try Serialization._UInt64Serializer.serialize(value.spaceNeeded),
                "space_shortage": try Serialization._UInt64Serializer.serialize(value.spaceShortage),
                "space_left": try Serialization._UInt64Serializer.serialize(value.spaceLeft),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> InsufficientQuotaAmounts {
            switch json {
            case .dictionary(let dict):
                let spaceNeeded = try Serialization._UInt64Serializer.deserialize(dict["space_needed"] ?? .null)
                let spaceShortage = try Serialization._UInt64Serializer.deserialize(dict["space_shortage"] ?? .null)
                let spaceLeft = try Serialization._UInt64Serializer.deserialize(dict["space_left"] ?? .null)
                return InsufficientQuotaAmounts(spaceNeeded: spaceNeeded, spaceShortage: spaceShortage, spaceLeft: spaceLeft)
            default:
                throw JSONSerializerError.deserializeError(type: InsufficientQuotaAmounts.self, json: json)
            }
        }
    }

    /// Information about the recipient of a shared content invitation.
    public enum InviteeInfo: CustomStringConvertible, JSONRepresentable {
        /// Email address of invited user.
        case email(String)
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try InviteeInfoSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try InviteeInfoSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for InviteeInfo: \(error)"
            }
        }
    }

    public class InviteeInfoSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: InviteeInfo) throws -> JSON {
            switch value {
            case .email(let arg):
                var d = try ["email": Serialization._StringSerializer.serialize(arg)]
                d[".tag"] = .str("email")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> InviteeInfo {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "email":
                    let v = try Serialization._StringSerializer.deserialize(d["email"] ?? .null)
                    return InviteeInfo.email(v)
                case "other":
                    return InviteeInfo.other
                default:
                    return InviteeInfo.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: InviteeInfo.self, json: json)
            }
        }
    }

    /// Information about an invited member of a shared content.
    public class InviteeMembershipInfo: Sharing.MembershipInfo {
        /// Recipient of the invitation.
        public let invitee: Sharing.InviteeInfo
        /// The user this invitation is tied to, if available.
        public let user: Sharing.UserInfo?
        public init(
            accessType: Sharing.AccessLevel,
            invitee: Sharing.InviteeInfo,
            permissions: [Sharing.MemberPermission]? = nil,
            initials: String? = nil,
            isInherited: Bool = false,
            user: Sharing.UserInfo? = nil
        ) {
            self.invitee = invitee
            self.user = user
            super.init(accessType: accessType, permissions: permissions, initials: initials, isInherited: isInherited)
        }

        public override var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try InviteeMembershipInfoSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for InviteeMembershipInfo: \(error)"
            }
        }
    }

    public class InviteeMembershipInfoSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: InviteeMembershipInfo) throws -> JSON {
            let output = [
                "access_type": try Sharing.AccessLevelSerializer().serialize(value.accessType),
                "invitee": try Sharing.InviteeInfoSerializer().serialize(value.invitee),
                "permissions": try NullableSerializer(ArraySerializer(Sharing.MemberPermissionSerializer())).serialize(value.permissions),
                "initials": try NullableSerializer(Serialization._StringSerializer).serialize(value.initials),
                "is_inherited": try Serialization._BoolSerializer.serialize(value.isInherited),
                "user": try NullableSerializer(Sharing.UserInfoSerializer()).serialize(value.user),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> InviteeMembershipInfo {
            switch json {
            case .dictionary(let dict):
                let accessType = try Sharing.AccessLevelSerializer().deserialize(dict["access_type"] ?? .null)
                let invitee = try Sharing.InviteeInfoSerializer().deserialize(dict["invitee"] ?? .null)
                let permissions = try NullableSerializer(ArraySerializer(Sharing.MemberPermissionSerializer())).deserialize(dict["permissions"] ?? .null)
                let initials = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["initials"] ?? .null)
                let isInherited = try Serialization._BoolSerializer.deserialize(dict["is_inherited"] ?? .number(0))
                let user = try NullableSerializer(Sharing.UserInfoSerializer()).deserialize(dict["user"] ?? .null)
                return InviteeMembershipInfo(
                    accessType: accessType,
                    invitee: invitee,
                    permissions: permissions,
                    initials: initials,
                    isInherited: isInherited,
                    user: user
                )
            default:
                throw JSONSerializerError.deserializeError(type: InviteeMembershipInfo.self, json: json)
            }
        }
    }

    /// Error occurred while performing an asynchronous job from unshareFolder or removeFolderMember.
    public enum JobError: CustomStringConvertible, JSONRepresentable {
        /// Error occurred while performing unshareFolder action.
        case unshareFolderError(Sharing.UnshareFolderError)
        /// Error occurred while performing removeFolderMember action.
        case removeFolderMemberError(Sharing.RemoveFolderMemberError)
        /// Error occurred while performing relinquishFolderMembership action.
        case relinquishFolderMembershipError(Sharing.RelinquishFolderMembershipError)
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try JobErrorSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try JobErrorSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for JobError: \(error)"
            }
        }
    }

    public class JobErrorSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: JobError) throws -> JSON {
            switch value {
            case .unshareFolderError(let arg):
                var d = try ["unshare_folder_error": Sharing.UnshareFolderErrorSerializer().serialize(arg)]
                d[".tag"] = .str("unshare_folder_error")
                return .dictionary(d)
            case .removeFolderMemberError(let arg):
                var d = try ["remove_folder_member_error": Sharing.RemoveFolderMemberErrorSerializer().serialize(arg)]
                d[".tag"] = .str("remove_folder_member_error")
                return .dictionary(d)
            case .relinquishFolderMembershipError(let arg):
                var d = try ["relinquish_folder_membership_error": Sharing.RelinquishFolderMembershipErrorSerializer().serialize(arg)]
                d[".tag"] = .str("relinquish_folder_membership_error")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> JobError {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "unshare_folder_error":
                    let v = try Sharing.UnshareFolderErrorSerializer().deserialize(d["unshare_folder_error"] ?? .null)
                    return JobError.unshareFolderError(v)
                case "remove_folder_member_error":
                    let v = try Sharing.RemoveFolderMemberErrorSerializer().deserialize(d["remove_folder_member_error"] ?? .null)
                    return JobError.removeFolderMemberError(v)
                case "relinquish_folder_membership_error":
                    let v = try Sharing.RelinquishFolderMembershipErrorSerializer().deserialize(d["relinquish_folder_membership_error"] ?? .null)
                    return JobError.relinquishFolderMembershipError(v)
                case "other":
                    return JobError.other
                default:
                    return JobError.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: JobError.self, json: json)
            }
        }
    }

    /// The JobStatus union
    public enum JobStatus: CustomStringConvertible, JSONRepresentable {
        /// The asynchronous job is still in progress.
        case inProgress
        /// The asynchronous job has finished.
        case complete
        /// The asynchronous job returned an error.
        case failed(Sharing.JobError)

        func json() throws -> JSON {
            try JobStatusSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try JobStatusSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for JobStatus: \(error)"
            }
        }
    }

    public class JobStatusSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: JobStatus) throws -> JSON {
            switch value {
            case .inProgress:
                var d = [String: JSON]()
                d[".tag"] = .str("in_progress")
                return .dictionary(d)
            case .complete:
                var d = [String: JSON]()
                d[".tag"] = .str("complete")
                return .dictionary(d)
            case .failed(let arg):
                var d = try ["failed": Sharing.JobErrorSerializer().serialize(arg)]
                d[".tag"] = .str("failed")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> JobStatus {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "in_progress":
                    return JobStatus.inProgress
                case "complete":
                    return JobStatus.complete
                case "failed":
                    let v = try Sharing.JobErrorSerializer().deserialize(d["failed"] ?? .null)
                    return JobStatus.failed(v)
                default:
                    throw JSONSerializerError.unknownTag(type: JobStatus.self, json: json, tag: tag)
                }
            default:
                throw JSONSerializerError.deserializeError(type: JobStatus.self, json: json)
            }
        }
    }

    /// The LinkAccessLevel union
    public enum LinkAccessLevel: CustomStringConvertible, JSONRepresentable {
        /// Users who use the link can view and comment on the content.
        case viewer
        /// Users who use the link can edit, view and comment on the content.
        case editor
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try LinkAccessLevelSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try LinkAccessLevelSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for LinkAccessLevel: \(error)"
            }
        }
    }

    public class LinkAccessLevelSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: LinkAccessLevel) throws -> JSON {
            switch value {
            case .viewer:
                var d = [String: JSON]()
                d[".tag"] = .str("viewer")
                return .dictionary(d)
            case .editor:
                var d = [String: JSON]()
                d[".tag"] = .str("editor")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> LinkAccessLevel {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "viewer":
                    return LinkAccessLevel.viewer
                case "editor":
                    return LinkAccessLevel.editor
                case "other":
                    return LinkAccessLevel.other
                default:
                    return LinkAccessLevel.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: LinkAccessLevel.self, json: json)
            }
        }
    }

    /// Actions that can be performed on a link.
    public enum LinkAction: CustomStringConvertible, JSONRepresentable {
        /// Change the access level of the link.
        case changeAccessLevel
        /// Change the audience of the link.
        case changeAudience
        /// Remove the expiry date of the link.
        case removeExpiry
        /// Remove the password of the link.
        case removePassword
        /// Create or modify the expiry date of the link.
        case setExpiry
        /// Create or modify the password of the link.
        case setPassword
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try LinkActionSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try LinkActionSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for LinkAction: \(error)"
            }
        }
    }

    public class LinkActionSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: LinkAction) throws -> JSON {
            switch value {
            case .changeAccessLevel:
                var d = [String: JSON]()
                d[".tag"] = .str("change_access_level")
                return .dictionary(d)
            case .changeAudience:
                var d = [String: JSON]()
                d[".tag"] = .str("change_audience")
                return .dictionary(d)
            case .removeExpiry:
                var d = [String: JSON]()
                d[".tag"] = .str("remove_expiry")
                return .dictionary(d)
            case .removePassword:
                var d = [String: JSON]()
                d[".tag"] = .str("remove_password")
                return .dictionary(d)
            case .setExpiry:
                var d = [String: JSON]()
                d[".tag"] = .str("set_expiry")
                return .dictionary(d)
            case .setPassword:
                var d = [String: JSON]()
                d[".tag"] = .str("set_password")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> LinkAction {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "change_access_level":
                    return LinkAction.changeAccessLevel
                case "change_audience":
                    return LinkAction.changeAudience
                case "remove_expiry":
                    return LinkAction.removeExpiry
                case "remove_password":
                    return LinkAction.removePassword
                case "set_expiry":
                    return LinkAction.setExpiry
                case "set_password":
                    return LinkAction.setPassword
                case "other":
                    return LinkAction.other
                default:
                    return LinkAction.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: LinkAction.self, json: json)
            }
        }
    }

    /// The LinkAudience union
    public enum LinkAudience: CustomStringConvertible, JSONRepresentable {
        /// Link is accessible by anyone.
        case public_
        /// Link is accessible only by team members.
        case team
        /// The link can be used by no one. The link merely points the user to the content, and does not grant
        /// additional rights to the user. Members of the content who use this link can only access the content
        /// with their pre-existing access rights.
        case noOne
        /// Use `require_password` instead. A link-specific password is required to access the link. Login is not
        /// required.
        case password
        /// Link is accessible only by members of the content.
        case members
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try LinkAudienceSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try LinkAudienceSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for LinkAudience: \(error)"
            }
        }
    }

    public class LinkAudienceSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: LinkAudience) throws -> JSON {
            switch value {
            case .public_:
                var d = [String: JSON]()
                d[".tag"] = .str("public")
                return .dictionary(d)
            case .team:
                var d = [String: JSON]()
                d[".tag"] = .str("team")
                return .dictionary(d)
            case .noOne:
                var d = [String: JSON]()
                d[".tag"] = .str("no_one")
                return .dictionary(d)
            case .password:
                var d = [String: JSON]()
                d[".tag"] = .str("password")
                return .dictionary(d)
            case .members:
                var d = [String: JSON]()
                d[".tag"] = .str("members")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> LinkAudience {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "public":
                    return LinkAudience.public_
                case "team":
                    return LinkAudience.team
                case "no_one":
                    return LinkAudience.noOne
                case "password":
                    return LinkAudience.password
                case "members":
                    return LinkAudience.members
                case "other":
                    return LinkAudience.other
                default:
                    return LinkAudience.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: LinkAudience.self, json: json)
            }
        }
    }

    /// The VisibilityPolicyDisallowedReason union
    public enum VisibilityPolicyDisallowedReason: CustomStringConvertible, JSONRepresentable {
        /// The user needs to delete and recreate the link to change the visibility policy.
        case deleteAndRecreate
        /// The parent shared folder restricts sharing of links outside the shared folder. To change the visibility
        /// policy, remove the restriction from the parent shared folder.
        case restrictedBySharedFolder
        /// The team policy prevents links being shared outside the team.
        case restrictedByTeam
        /// The user needs to be on a team to set this policy.
        case userNotOnTeam
        /// The user is a basic user or is on a limited team.
        case userAccountType
        /// The user does not have permission.
        case permissionDenied
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try VisibilityPolicyDisallowedReasonSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try VisibilityPolicyDisallowedReasonSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for VisibilityPolicyDisallowedReason: \(error)"
            }
        }
    }

    public class VisibilityPolicyDisallowedReasonSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: VisibilityPolicyDisallowedReason) throws -> JSON {
            switch value {
            case .deleteAndRecreate:
                var d = [String: JSON]()
                d[".tag"] = .str("delete_and_recreate")
                return .dictionary(d)
            case .restrictedBySharedFolder:
                var d = [String: JSON]()
                d[".tag"] = .str("restricted_by_shared_folder")
                return .dictionary(d)
            case .restrictedByTeam:
                var d = [String: JSON]()
                d[".tag"] = .str("restricted_by_team")
                return .dictionary(d)
            case .userNotOnTeam:
                var d = [String: JSON]()
                d[".tag"] = .str("user_not_on_team")
                return .dictionary(d)
            case .userAccountType:
                var d = [String: JSON]()
                d[".tag"] = .str("user_account_type")
                return .dictionary(d)
            case .permissionDenied:
                var d = [String: JSON]()
                d[".tag"] = .str("permission_denied")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> VisibilityPolicyDisallowedReason {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "delete_and_recreate":
                    return VisibilityPolicyDisallowedReason.deleteAndRecreate
                case "restricted_by_shared_folder":
                    return VisibilityPolicyDisallowedReason.restrictedBySharedFolder
                case "restricted_by_team":
                    return VisibilityPolicyDisallowedReason.restrictedByTeam
                case "user_not_on_team":
                    return VisibilityPolicyDisallowedReason.userNotOnTeam
                case "user_account_type":
                    return VisibilityPolicyDisallowedReason.userAccountType
                case "permission_denied":
                    return VisibilityPolicyDisallowedReason.permissionDenied
                case "other":
                    return VisibilityPolicyDisallowedReason.other
                default:
                    return VisibilityPolicyDisallowedReason.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: VisibilityPolicyDisallowedReason.self, json: json)
            }
        }
    }

    /// check documentation for VisibilityPolicyDisallowedReason.
    public enum LinkAudienceDisallowedReason: CustomStringConvertible, JSONRepresentable {
        /// The user needs to delete and recreate the link to change the visibility policy.
        case deleteAndRecreate
        /// The parent shared folder restricts sharing of links outside the shared folder. To change the visibility
        /// policy, remove the restriction from the parent shared folder.
        case restrictedBySharedFolder
        /// The team policy prevents links being shared outside the team.
        case restrictedByTeam
        /// The user needs to be on a team to set this policy.
        case userNotOnTeam
        /// The user is a basic user or is on a limited team.
        case userAccountType
        /// The user does not have permission.
        case permissionDenied
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try LinkAudienceDisallowedReasonSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try LinkAudienceDisallowedReasonSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for LinkAudienceDisallowedReason: \(error)"
            }
        }
    }

    public class LinkAudienceDisallowedReasonSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: LinkAudienceDisallowedReason) throws -> JSON {
            switch value {
            case .deleteAndRecreate:
                var d = [String: JSON]()
                d[".tag"] = .str("delete_and_recreate")
                return .dictionary(d)
            case .restrictedBySharedFolder:
                var d = [String: JSON]()
                d[".tag"] = .str("restricted_by_shared_folder")
                return .dictionary(d)
            case .restrictedByTeam:
                var d = [String: JSON]()
                d[".tag"] = .str("restricted_by_team")
                return .dictionary(d)
            case .userNotOnTeam:
                var d = [String: JSON]()
                d[".tag"] = .str("user_not_on_team")
                return .dictionary(d)
            case .userAccountType:
                var d = [String: JSON]()
                d[".tag"] = .str("user_account_type")
                return .dictionary(d)
            case .permissionDenied:
                var d = [String: JSON]()
                d[".tag"] = .str("permission_denied")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> LinkAudienceDisallowedReason {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "delete_and_recreate":
                    return LinkAudienceDisallowedReason.deleteAndRecreate
                case "restricted_by_shared_folder":
                    return LinkAudienceDisallowedReason.restrictedBySharedFolder
                case "restricted_by_team":
                    return LinkAudienceDisallowedReason.restrictedByTeam
                case "user_not_on_team":
                    return LinkAudienceDisallowedReason.userNotOnTeam
                case "user_account_type":
                    return LinkAudienceDisallowedReason.userAccountType
                case "permission_denied":
                    return LinkAudienceDisallowedReason.permissionDenied
                case "other":
                    return LinkAudienceDisallowedReason.other
                default:
                    throw JSONSerializerError.unknownTag(type: LinkAudienceDisallowedReason.self, json: json, tag: tag)
                }
            default:
                throw JSONSerializerError.deserializeError(type: LinkAudienceDisallowedReason.self, json: json)
            }
        }
    }

    /// The LinkAudienceOption struct
    public class LinkAudienceOption: CustomStringConvertible, JSONRepresentable {
        /// Specifies who can access the link.
        public let audience: Sharing.LinkAudience
        /// Whether the user calling this API can select this audience option.
        public let allowed: Bool
        /// If allowed is false, this will provide the reason that the user is not permitted to set the visibility to
        /// this policy.
        public let disallowedReason: Sharing.LinkAudienceDisallowedReason?
        public init(audience: Sharing.LinkAudience, allowed: Bool, disallowedReason: Sharing.LinkAudienceDisallowedReason? = nil) {
            self.audience = audience
            self.allowed = allowed
            self.disallowedReason = disallowedReason
        }

        func json() throws -> JSON {
            try LinkAudienceOptionSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try LinkAudienceOptionSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for LinkAudienceOption: \(error)"
            }
        }
    }

    public class LinkAudienceOptionSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: LinkAudienceOption) throws -> JSON {
            let output = [
                "audience": try Sharing.LinkAudienceSerializer().serialize(value.audience),
                "allowed": try Serialization._BoolSerializer.serialize(value.allowed),
                "disallowed_reason": try NullableSerializer(Sharing.LinkAudienceDisallowedReasonSerializer()).serialize(value.disallowedReason),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> LinkAudienceOption {
            switch json {
            case .dictionary(let dict):
                let audience = try Sharing.LinkAudienceSerializer().deserialize(dict["audience"] ?? .null)
                let allowed = try Serialization._BoolSerializer.deserialize(dict["allowed"] ?? .null)
                let disallowedReason = try NullableSerializer(Sharing.LinkAudienceDisallowedReasonSerializer())
                    .deserialize(dict["disallowed_reason"] ?? .null)
                return LinkAudienceOption(audience: audience, allowed: allowed, disallowedReason: disallowedReason)
            default:
                throw JSONSerializerError.deserializeError(type: LinkAudienceOption.self, json: json)
            }
        }
    }

    /// The LinkExpiry union
    public enum LinkExpiry: CustomStringConvertible, JSONRepresentable {
        /// Remove the currently set expiry for the link.
        case removeExpiry
        /// Set a new expiry or change an existing expiry.
        case setExpiry(Date)
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try LinkExpirySerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try LinkExpirySerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for LinkExpiry: \(error)"
            }
        }
    }

    public class LinkExpirySerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: LinkExpiry) throws -> JSON {
            switch value {
            case .removeExpiry:
                var d = [String: JSON]()
                d[".tag"] = .str("remove_expiry")
                return .dictionary(d)
            case .setExpiry(let arg):
                var d = try ["set_expiry": NSDateSerializer("%Y-%m-%dT%H:%M:%SZ").serialize(arg)]
                d[".tag"] = .str("set_expiry")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> LinkExpiry {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "remove_expiry":
                    return LinkExpiry.removeExpiry
                case "set_expiry":
                    let v = try NSDateSerializer("%Y-%m-%dT%H:%M:%SZ").deserialize(d["set_expiry"] ?? .null)
                    return LinkExpiry.setExpiry(v)
                case "other":
                    return LinkExpiry.other
                default:
                    return LinkExpiry.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: LinkExpiry.self, json: json)
            }
        }
    }

    /// The LinkPassword union
    public enum LinkPassword: CustomStringConvertible, JSONRepresentable {
        /// Remove the currently set password for the link.
        case removePassword
        /// Set a new password or change an existing password.
        case setPassword(String)
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try LinkPasswordSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try LinkPasswordSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for LinkPassword: \(error)"
            }
        }
    }

    public class LinkPasswordSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: LinkPassword) throws -> JSON {
            switch value {
            case .removePassword:
                var d = [String: JSON]()
                d[".tag"] = .str("remove_password")
                return .dictionary(d)
            case .setPassword(let arg):
                var d = try ["set_password": Serialization._StringSerializer.serialize(arg)]
                d[".tag"] = .str("set_password")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> LinkPassword {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "remove_password":
                    return LinkPassword.removePassword
                case "set_password":
                    let v = try Serialization._StringSerializer.deserialize(d["set_password"] ?? .null)
                    return LinkPassword.setPassword(v)
                case "other":
                    return LinkPassword.other
                default:
                    return LinkPassword.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: LinkPassword.self, json: json)
            }
        }
    }

    /// Permissions for actions that can be performed on a link.
    public class LinkPermission: CustomStringConvertible, JSONRepresentable {
        /// (no description)
        public let action: Sharing.LinkAction
        /// (no description)
        public let allow: Bool
        /// (no description)
        public let reason: Sharing.PermissionDeniedReason?
        public init(action: Sharing.LinkAction, allow: Bool, reason: Sharing.PermissionDeniedReason? = nil) {
            self.action = action
            self.allow = allow
            self.reason = reason
        }

        func json() throws -> JSON {
            try LinkPermissionSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try LinkPermissionSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for LinkPermission: \(error)"
            }
        }
    }

    public class LinkPermissionSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: LinkPermission) throws -> JSON {
            let output = [
                "action": try Sharing.LinkActionSerializer().serialize(value.action),
                "allow": try Serialization._BoolSerializer.serialize(value.allow),
                "reason": try NullableSerializer(Sharing.PermissionDeniedReasonSerializer()).serialize(value.reason),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> LinkPermission {
            switch json {
            case .dictionary(let dict):
                let action = try Sharing.LinkActionSerializer().deserialize(dict["action"] ?? .null)
                let allow = try Serialization._BoolSerializer.deserialize(dict["allow"] ?? .null)
                let reason = try NullableSerializer(Sharing.PermissionDeniedReasonSerializer()).deserialize(dict["reason"] ?? .null)
                return LinkPermission(action: action, allow: allow, reason: reason)
            default:
                throw JSONSerializerError.deserializeError(type: LinkPermission.self, json: json)
            }
        }
    }

    /// The LinkPermissions struct
    public class LinkPermissions: CustomStringConvertible, JSONRepresentable {
        /// The current visibility of the link after considering the shared links policies of the the team (in case the
        /// link's owner is part of a team) and the shared folder (in case the linked file is part of a shared
        /// folder). This field is shown only if the caller has access to this info (the link's owner always has
        /// access to this data). For some links, an effective_audience value is returned instead.
        public let resolvedVisibility: Sharing.ResolvedVisibility?
        /// The shared link's requested visibility. This can be overridden by the team and shared folder policies. The
        /// final visibility, after considering these policies, can be found in resolvedVisibility. This is
        /// shown only if the caller is the link's owner and resolved_visibility is returned instead of
        /// effective_audience.
        public let requestedVisibility: Sharing.RequestedVisibility?
        /// Whether the caller can revoke the shared link.
        public let canRevoke: Bool
        /// The failure reason for revoking the link. This field will only be present if the canRevoke is false.
        public let revokeFailureReason: Sharing.SharedLinkAccessFailureReason?
        /// The type of audience who can benefit from the access level specified by the `link_access_level` field.
        public let effectiveAudience: Sharing.LinkAudience?
        /// The access level that the link will grant to its users. A link can grant additional rights to a user beyond
        /// their current access level. For example, if a user was invited as a viewer to a file, and then opens
        /// a link with `link_access_level` set to `editor`, then they will gain editor privileges. The
        /// `link_access_level` is a property of the link, and does not depend on who is calling this API. In
        /// particular, `link_access_level` does not take into account the API caller's current permissions to
        /// the content.
        public let linkAccessLevel: Sharing.LinkAccessLevel?
        /// A list of policies that the user might be able to set for the visibility.
        public let visibilityPolicies: [Sharing.VisibilityPolicy]
        /// Whether the user can set the expiry settings of the link. This refers to the ability to create a new expiry
        /// and modify an existing expiry.
        public let canSetExpiry: Bool
        /// Whether the user can remove the expiry of the link.
        public let canRemoveExpiry: Bool
        /// Whether the link can be downloaded or not.
        public let allowDownload: Bool
        /// Whether the user can allow downloads via the link. This refers to the ability to remove a no-download
        /// restriction on the link.
        public let canAllowDownload: Bool
        /// Whether the user can disallow downloads via the link. This refers to the ability to impose a no-download
        /// restriction on the link.
        public let canDisallowDownload: Bool
        /// Whether comments are enabled for the linked file. This takes the team commenting policy into account.
        public let allowComments: Bool
        /// Whether the team has disabled commenting globally.
        public let teamRestrictsComments: Bool
        /// A list of link audience options the user might be able to set as the new audience.
        public let audienceOptions: [Sharing.LinkAudienceOption]?
        /// Whether the user can set a password for the link.
        public let canSetPassword: Bool?
        /// Whether the user can remove the password of the link.
        public let canRemovePassword: Bool?
        /// Whether the user is required to provide a password to view the link.
        public let requirePassword: Bool?
        /// Whether the user can use extended sharing controls, based on their account type.
        public let canUseExtendedSharingControls: Bool?
        public init(
            canRevoke: Bool,
            visibilityPolicies: [Sharing.VisibilityPolicy],
            canSetExpiry: Bool,
            canRemoveExpiry: Bool,
            allowDownload: Bool,
            canAllowDownload: Bool,
            canDisallowDownload: Bool,
            allowComments: Bool,
            teamRestrictsComments: Bool,
            resolvedVisibility: Sharing.ResolvedVisibility? = nil,
            requestedVisibility: Sharing.RequestedVisibility? = nil,
            revokeFailureReason: Sharing.SharedLinkAccessFailureReason? = nil,
            effectiveAudience: Sharing.LinkAudience? = nil,
            linkAccessLevel: Sharing.LinkAccessLevel? = nil,
            audienceOptions: [Sharing.LinkAudienceOption]? = nil,
            canSetPassword: Bool? = nil,
            canRemovePassword: Bool? = nil,
            requirePassword: Bool? = nil,
            canUseExtendedSharingControls: Bool? = nil
        ) {
            self.resolvedVisibility = resolvedVisibility
            self.requestedVisibility = requestedVisibility
            self.canRevoke = canRevoke
            self.revokeFailureReason = revokeFailureReason
            self.effectiveAudience = effectiveAudience
            self.linkAccessLevel = linkAccessLevel
            self.visibilityPolicies = visibilityPolicies
            self.canSetExpiry = canSetExpiry
            self.canRemoveExpiry = canRemoveExpiry
            self.allowDownload = allowDownload
            self.canAllowDownload = canAllowDownload
            self.canDisallowDownload = canDisallowDownload
            self.allowComments = allowComments
            self.teamRestrictsComments = teamRestrictsComments
            self.audienceOptions = audienceOptions
            self.canSetPassword = canSetPassword
            self.canRemovePassword = canRemovePassword
            self.requirePassword = requirePassword
            self.canUseExtendedSharingControls = canUseExtendedSharingControls
        }

        func json() throws -> JSON {
            try LinkPermissionsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try LinkPermissionsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for LinkPermissions: \(error)"
            }
        }
    }

    public class LinkPermissionsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: LinkPermissions) throws -> JSON {
            let output = [
                "can_revoke": try Serialization._BoolSerializer.serialize(value.canRevoke),
                "visibility_policies": try ArraySerializer(Sharing.VisibilityPolicySerializer()).serialize(value.visibilityPolicies),
                "can_set_expiry": try Serialization._BoolSerializer.serialize(value.canSetExpiry),
                "can_remove_expiry": try Serialization._BoolSerializer.serialize(value.canRemoveExpiry),
                "allow_download": try Serialization._BoolSerializer.serialize(value.allowDownload),
                "can_allow_download": try Serialization._BoolSerializer.serialize(value.canAllowDownload),
                "can_disallow_download": try Serialization._BoolSerializer.serialize(value.canDisallowDownload),
                "allow_comments": try Serialization._BoolSerializer.serialize(value.allowComments),
                "team_restricts_comments": try Serialization._BoolSerializer.serialize(value.teamRestrictsComments),
                "resolved_visibility": try NullableSerializer(Sharing.ResolvedVisibilitySerializer()).serialize(value.resolvedVisibility),
                "requested_visibility": try NullableSerializer(Sharing.RequestedVisibilitySerializer()).serialize(value.requestedVisibility),
                "revoke_failure_reason": try NullableSerializer(Sharing.SharedLinkAccessFailureReasonSerializer()).serialize(value.revokeFailureReason),
                "effective_audience": try NullableSerializer(Sharing.LinkAudienceSerializer()).serialize(value.effectiveAudience),
                "link_access_level": try NullableSerializer(Sharing.LinkAccessLevelSerializer()).serialize(value.linkAccessLevel),
                "audience_options": try NullableSerializer(ArraySerializer(Sharing.LinkAudienceOptionSerializer())).serialize(value.audienceOptions),
                "can_set_password": try NullableSerializer(Serialization._BoolSerializer).serialize(value.canSetPassword),
                "can_remove_password": try NullableSerializer(Serialization._BoolSerializer).serialize(value.canRemovePassword),
                "require_password": try NullableSerializer(Serialization._BoolSerializer).serialize(value.requirePassword),
                "can_use_extended_sharing_controls": try NullableSerializer(Serialization._BoolSerializer).serialize(value.canUseExtendedSharingControls),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> LinkPermissions {
            switch json {
            case .dictionary(let dict):
                let canRevoke = try Serialization._BoolSerializer.deserialize(dict["can_revoke"] ?? .null)
                let visibilityPolicies = try ArraySerializer(Sharing.VisibilityPolicySerializer()).deserialize(dict["visibility_policies"] ?? .null)
                let canSetExpiry = try Serialization._BoolSerializer.deserialize(dict["can_set_expiry"] ?? .null)
                let canRemoveExpiry = try Serialization._BoolSerializer.deserialize(dict["can_remove_expiry"] ?? .null)
                let allowDownload = try Serialization._BoolSerializer.deserialize(dict["allow_download"] ?? .null)
                let canAllowDownload = try Serialization._BoolSerializer.deserialize(dict["can_allow_download"] ?? .null)
                let canDisallowDownload = try Serialization._BoolSerializer.deserialize(dict["can_disallow_download"] ?? .null)
                let allowComments = try Serialization._BoolSerializer.deserialize(dict["allow_comments"] ?? .null)
                let teamRestrictsComments = try Serialization._BoolSerializer.deserialize(dict["team_restricts_comments"] ?? .null)
                let resolvedVisibility = try NullableSerializer(Sharing.ResolvedVisibilitySerializer()).deserialize(dict["resolved_visibility"] ?? .null)
                let requestedVisibility = try NullableSerializer(Sharing.RequestedVisibilitySerializer()).deserialize(dict["requested_visibility"] ?? .null)
                let revokeFailureReason = try NullableSerializer(Sharing.SharedLinkAccessFailureReasonSerializer())
                    .deserialize(dict["revoke_failure_reason"] ?? .null)
                let effectiveAudience = try NullableSerializer(Sharing.LinkAudienceSerializer()).deserialize(dict["effective_audience"] ?? .null)
                let linkAccessLevel = try NullableSerializer(Sharing.LinkAccessLevelSerializer()).deserialize(dict["link_access_level"] ?? .null)
                let audienceOptions = try NullableSerializer(ArraySerializer(Sharing.LinkAudienceOptionSerializer()))
                    .deserialize(dict["audience_options"] ?? .null)
                let canSetPassword = try NullableSerializer(Serialization._BoolSerializer).deserialize(dict["can_set_password"] ?? .null)
                let canRemovePassword = try NullableSerializer(Serialization._BoolSerializer).deserialize(dict["can_remove_password"] ?? .null)
                let requirePassword = try NullableSerializer(Serialization._BoolSerializer).deserialize(dict["require_password"] ?? .null)
                let canUseExtendedSharingControls = try NullableSerializer(Serialization._BoolSerializer)
                    .deserialize(dict["can_use_extended_sharing_controls"] ?? .null)
                return LinkPermissions(
                    canRevoke: canRevoke,
                    visibilityPolicies: visibilityPolicies,
                    canSetExpiry: canSetExpiry,
                    canRemoveExpiry: canRemoveExpiry,
                    allowDownload: allowDownload,
                    canAllowDownload: canAllowDownload,
                    canDisallowDownload: canDisallowDownload,
                    allowComments: allowComments,
                    teamRestrictsComments: teamRestrictsComments,
                    resolvedVisibility: resolvedVisibility,
                    requestedVisibility: requestedVisibility,
                    revokeFailureReason: revokeFailureReason,
                    effectiveAudience: effectiveAudience,
                    linkAccessLevel: linkAccessLevel,
                    audienceOptions: audienceOptions,
                    canSetPassword: canSetPassword,
                    canRemovePassword: canRemovePassword,
                    requirePassword: requirePassword,
                    canUseExtendedSharingControls: canUseExtendedSharingControls
                )
            default:
                throw JSONSerializerError.deserializeError(type: LinkPermissions.self, json: json)
            }
        }
    }

    /// Settings that apply to a link.
    public class LinkSettings: CustomStringConvertible, JSONRepresentable {
        /// The access level on the link for this file. Currently, it only accepts 'viewer' and 'viewer_no_comment'.
        public let accessLevel: Sharing.AccessLevel?
        /// The type of audience on the link for this file.
        public let audience: Sharing.LinkAudience?
        /// An expiry timestamp to set on a link.
        public let expiry: Sharing.LinkExpiry?
        /// The password for the link.
        public let password: Sharing.LinkPassword?
        public init(
            accessLevel: Sharing.AccessLevel? = nil,
            audience: Sharing.LinkAudience? = nil,
            expiry: Sharing.LinkExpiry? = nil,
            password: Sharing.LinkPassword? = nil
        ) {
            self.accessLevel = accessLevel
            self.audience = audience
            self.expiry = expiry
            self.password = password
        }

        func json() throws -> JSON {
            try LinkSettingsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try LinkSettingsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for LinkSettings: \(error)"
            }
        }
    }

    public class LinkSettingsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: LinkSettings) throws -> JSON {
            let output = [
                "access_level": try NullableSerializer(Sharing.AccessLevelSerializer()).serialize(value.accessLevel),
                "audience": try NullableSerializer(Sharing.LinkAudienceSerializer()).serialize(value.audience),
                "expiry": try NullableSerializer(Sharing.LinkExpirySerializer()).serialize(value.expiry),
                "password": try NullableSerializer(Sharing.LinkPasswordSerializer()).serialize(value.password),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> LinkSettings {
            switch json {
            case .dictionary(let dict):
                let accessLevel = try NullableSerializer(Sharing.AccessLevelSerializer()).deserialize(dict["access_level"] ?? .null)
                let audience = try NullableSerializer(Sharing.LinkAudienceSerializer()).deserialize(dict["audience"] ?? .null)
                let expiry = try NullableSerializer(Sharing.LinkExpirySerializer()).deserialize(dict["expiry"] ?? .null)
                let password = try NullableSerializer(Sharing.LinkPasswordSerializer()).deserialize(dict["password"] ?? .null)
                return LinkSettings(accessLevel: accessLevel, audience: audience, expiry: expiry, password: password)
            default:
                throw JSONSerializerError.deserializeError(type: LinkSettings.self, json: json)
            }
        }
    }

    /// Arguments for listFileMembers.
    public class ListFileMembersArg: CustomStringConvertible, JSONRepresentable {
        /// The file for which you want to see members.
        public let file: String
        /// The actions for which to return permissions on a member.
        public let actions: [Sharing.MemberAction]?
        /// Whether to include members who only have access from a parent shared folder.
        public let includeInherited: Bool
        /// Number of members to return max per query. Defaults to 100 if no limit is specified.
        public let limit: UInt32
        public init(file: String, actions: [Sharing.MemberAction]? = nil, includeInherited: Bool = true, limit: UInt32 = 100) {
            stringValidator(minLength: 1, pattern: "((/|id:).*|nspath:[0-9]+:.*)|ns:[0-9]+(/.*)?")(file)
            self.file = file
            self.actions = actions
            self.includeInherited = includeInherited
            comparableValidator(minValue: 1, maxValue: 300)(limit)
            self.limit = limit
        }

        func json() throws -> JSON {
            try ListFileMembersArgSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ListFileMembersArgSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ListFileMembersArg: \(error)"
            }
        }
    }

    public class ListFileMembersArgSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ListFileMembersArg) throws -> JSON {
            let output = [
                "file": try Serialization._StringSerializer.serialize(value.file),
                "actions": try NullableSerializer(ArraySerializer(Sharing.MemberActionSerializer())).serialize(value.actions),
                "include_inherited": try Serialization._BoolSerializer.serialize(value.includeInherited),
                "limit": try Serialization._UInt32Serializer.serialize(value.limit),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ListFileMembersArg {
            switch json {
            case .dictionary(let dict):
                let file = try Serialization._StringSerializer.deserialize(dict["file"] ?? .null)
                let actions = try NullableSerializer(ArraySerializer(Sharing.MemberActionSerializer())).deserialize(dict["actions"] ?? .null)
                let includeInherited = try Serialization._BoolSerializer.deserialize(dict["include_inherited"] ?? .number(1))
                let limit = try Serialization._UInt32Serializer.deserialize(dict["limit"] ?? .number(100))
                return ListFileMembersArg(file: file, actions: actions, includeInherited: includeInherited, limit: limit)
            default:
                throw JSONSerializerError.deserializeError(type: ListFileMembersArg.self, json: json)
            }
        }
    }

    /// Arguments for listFileMembersBatch.
    public class ListFileMembersBatchArg: CustomStringConvertible, JSONRepresentable {
        /// Files for which to return members.
        public let files: [String]
        /// Number of members to return max per query. Defaults to 10 if no limit is specified.
        public let limit: UInt32
        public init(files: [String], limit: UInt32 = 10) {
            arrayValidator(maxItems: 100, itemValidator: stringValidator(minLength: 1, pattern: "((/|id:).*|nspath:[0-9]+:.*)|ns:[0-9]+(/.*)?"))(files)
            self.files = files
            comparableValidator(maxValue: 20)(limit)
            self.limit = limit
        }

        func json() throws -> JSON {
            try ListFileMembersBatchArgSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ListFileMembersBatchArgSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ListFileMembersBatchArg: \(error)"
            }
        }
    }

    public class ListFileMembersBatchArgSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ListFileMembersBatchArg) throws -> JSON {
            let output = [
                "files": try ArraySerializer(Serialization._StringSerializer).serialize(value.files),
                "limit": try Serialization._UInt32Serializer.serialize(value.limit),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ListFileMembersBatchArg {
            switch json {
            case .dictionary(let dict):
                let files = try ArraySerializer(Serialization._StringSerializer).deserialize(dict["files"] ?? .null)
                let limit = try Serialization._UInt32Serializer.deserialize(dict["limit"] ?? .number(10))
                return ListFileMembersBatchArg(files: files, limit: limit)
            default:
                throw JSONSerializerError.deserializeError(type: ListFileMembersBatchArg.self, json: json)
            }
        }
    }

    /// Per-file result for listFileMembersBatch.
    public class ListFileMembersBatchResult: CustomStringConvertible, JSONRepresentable {
        /// This is the input file identifier, whether an ID or a path.
        public let file: String
        /// The result for this particular file.
        public let result: Sharing.ListFileMembersIndividualResult
        public init(file: String, result: Sharing.ListFileMembersIndividualResult) {
            stringValidator(minLength: 1, pattern: "((/|id:).*|nspath:[0-9]+:.*)|ns:[0-9]+(/.*)?")(file)
            self.file = file
            self.result = result
        }

        func json() throws -> JSON {
            try ListFileMembersBatchResultSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ListFileMembersBatchResultSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ListFileMembersBatchResult: \(error)"
            }
        }
    }

    public class ListFileMembersBatchResultSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ListFileMembersBatchResult) throws -> JSON {
            let output = [
                "file": try Serialization._StringSerializer.serialize(value.file),
                "result": try Sharing.ListFileMembersIndividualResultSerializer().serialize(value.result),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ListFileMembersBatchResult {
            switch json {
            case .dictionary(let dict):
                let file = try Serialization._StringSerializer.deserialize(dict["file"] ?? .null)
                let result = try Sharing.ListFileMembersIndividualResultSerializer().deserialize(dict["result"] ?? .null)
                return ListFileMembersBatchResult(file: file, result: result)
            default:
                throw JSONSerializerError.deserializeError(type: ListFileMembersBatchResult.self, json: json)
            }
        }
    }

    /// Arguments for listFileMembersContinue.
    public class ListFileMembersContinueArg: CustomStringConvertible, JSONRepresentable {
        /// The cursor returned by your last call to listFileMembers, listFileMembersContinue, or listFileMembersBatch.
        public let cursor: String
        public init(cursor: String) {
            stringValidator()(cursor)
            self.cursor = cursor
        }

        func json() throws -> JSON {
            try ListFileMembersContinueArgSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ListFileMembersContinueArgSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ListFileMembersContinueArg: \(error)"
            }
        }
    }

    public class ListFileMembersContinueArgSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ListFileMembersContinueArg) throws -> JSON {
            let output = [
                "cursor": try Serialization._StringSerializer.serialize(value.cursor),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ListFileMembersContinueArg {
            switch json {
            case .dictionary(let dict):
                let cursor = try Serialization._StringSerializer.deserialize(dict["cursor"] ?? .null)
                return ListFileMembersContinueArg(cursor: cursor)
            default:
                throw JSONSerializerError.deserializeError(type: ListFileMembersContinueArg.self, json: json)
            }
        }
    }

    /// Error for listFileMembersContinue.
    public enum ListFileMembersContinueError: CustomStringConvertible, JSONRepresentable {
        /// An unspecified error.
        case userError(Sharing.SharingUserError)
        /// An unspecified error.
        case accessError(Sharing.SharingFileAccessError)
        /// cursor in ListFileMembersContinueArg is invalid.
        case invalidCursor
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try ListFileMembersContinueErrorSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ListFileMembersContinueErrorSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ListFileMembersContinueError: \(error)"
            }
        }
    }

    public class ListFileMembersContinueErrorSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ListFileMembersContinueError) throws -> JSON {
            switch value {
            case .userError(let arg):
                var d = try ["user_error": Sharing.SharingUserErrorSerializer().serialize(arg)]
                d[".tag"] = .str("user_error")
                return .dictionary(d)
            case .accessError(let arg):
                var d = try ["access_error": Sharing.SharingFileAccessErrorSerializer().serialize(arg)]
                d[".tag"] = .str("access_error")
                return .dictionary(d)
            case .invalidCursor:
                var d = [String: JSON]()
                d[".tag"] = .str("invalid_cursor")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> ListFileMembersContinueError {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "user_error":
                    let v = try Sharing.SharingUserErrorSerializer().deserialize(d["user_error"] ?? .null)
                    return ListFileMembersContinueError.userError(v)
                case "access_error":
                    let v = try Sharing.SharingFileAccessErrorSerializer().deserialize(d["access_error"] ?? .null)
                    return ListFileMembersContinueError.accessError(v)
                case "invalid_cursor":
                    return ListFileMembersContinueError.invalidCursor
                case "other":
                    return ListFileMembersContinueError.other
                default:
                    return ListFileMembersContinueError.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: ListFileMembersContinueError.self, json: json)
            }
        }
    }

    /// The ListFileMembersCountResult struct
    public class ListFileMembersCountResult: CustomStringConvertible, JSONRepresentable {
        /// A list of members on this file.
        public let members: Sharing.SharedFileMembers
        /// The number of members on this file. This does not include inherited members.
        public let memberCount: UInt32
        public init(members: Sharing.SharedFileMembers, memberCount: UInt32) {
            self.members = members
            comparableValidator()(memberCount)
            self.memberCount = memberCount
        }

        func json() throws -> JSON {
            try ListFileMembersCountResultSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ListFileMembersCountResultSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ListFileMembersCountResult: \(error)"
            }
        }
    }

    public class ListFileMembersCountResultSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ListFileMembersCountResult) throws -> JSON {
            let output = [
                "members": try Sharing.SharedFileMembersSerializer().serialize(value.members),
                "member_count": try Serialization._UInt32Serializer.serialize(value.memberCount),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ListFileMembersCountResult {
            switch json {
            case .dictionary(let dict):
                let members = try Sharing.SharedFileMembersSerializer().deserialize(dict["members"] ?? .null)
                let memberCount = try Serialization._UInt32Serializer.deserialize(dict["member_count"] ?? .null)
                return ListFileMembersCountResult(members: members, memberCount: memberCount)
            default:
                throw JSONSerializerError.deserializeError(type: ListFileMembersCountResult.self, json: json)
            }
        }
    }

    /// Error for listFileMembers.
    public enum ListFileMembersError: CustomStringConvertible, JSONRepresentable {
        /// An unspecified error.
        case userError(Sharing.SharingUserError)
        /// An unspecified error.
        case accessError(Sharing.SharingFileAccessError)
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try ListFileMembersErrorSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ListFileMembersErrorSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ListFileMembersError: \(error)"
            }
        }
    }

    public class ListFileMembersErrorSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ListFileMembersError) throws -> JSON {
            switch value {
            case .userError(let arg):
                var d = try ["user_error": Sharing.SharingUserErrorSerializer().serialize(arg)]
                d[".tag"] = .str("user_error")
                return .dictionary(d)
            case .accessError(let arg):
                var d = try ["access_error": Sharing.SharingFileAccessErrorSerializer().serialize(arg)]
                d[".tag"] = .str("access_error")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> ListFileMembersError {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "user_error":
                    let v = try Sharing.SharingUserErrorSerializer().deserialize(d["user_error"] ?? .null)
                    return ListFileMembersError.userError(v)
                case "access_error":
                    let v = try Sharing.SharingFileAccessErrorSerializer().deserialize(d["access_error"] ?? .null)
                    return ListFileMembersError.accessError(v)
                case "other":
                    return ListFileMembersError.other
                default:
                    return ListFileMembersError.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: ListFileMembersError.self, json: json)
            }
        }
    }

    /// The ListFileMembersIndividualResult union
    public enum ListFileMembersIndividualResult: CustomStringConvertible, JSONRepresentable {
        /// The results of the query for this file if it was successful.
        case result(Sharing.ListFileMembersCountResult)
        /// The result of the query for this file if it was an error.
        case accessError(Sharing.SharingFileAccessError)
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try ListFileMembersIndividualResultSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ListFileMembersIndividualResultSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ListFileMembersIndividualResult: \(error)"
            }
        }
    }

    public class ListFileMembersIndividualResultSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ListFileMembersIndividualResult) throws -> JSON {
            switch value {
            case .result(let arg):
                var d = try Serialization.getFields(Sharing.ListFileMembersCountResultSerializer().serialize(arg))
                d[".tag"] = .str("result")
                return .dictionary(d)
            case .accessError(let arg):
                var d = try ["access_error": Sharing.SharingFileAccessErrorSerializer().serialize(arg)]
                d[".tag"] = .str("access_error")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> ListFileMembersIndividualResult {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "result":
                    let v = try Sharing.ListFileMembersCountResultSerializer().deserialize(json)
                    return ListFileMembersIndividualResult.result(v)
                case "access_error":
                    let v = try Sharing.SharingFileAccessErrorSerializer().deserialize(d["access_error"] ?? .null)
                    return ListFileMembersIndividualResult.accessError(v)
                case "other":
                    return ListFileMembersIndividualResult.other
                default:
                    return ListFileMembersIndividualResult.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: ListFileMembersIndividualResult.self, json: json)
            }
        }
    }

    /// Arguments for listReceivedFiles.
    public class ListFilesArg: CustomStringConvertible, JSONRepresentable {
        /// Number of files to return max per query. Defaults to 100 if no limit is specified.
        public let limit: UInt32
        /// A list of `FileAction`s corresponding to `FilePermission`s that should appear in the  response's permissions
        /// in SharedFileMetadata field describing the actions the  authenticated user can perform on the file.
        public let actions: [Sharing.FileAction]?
        public init(limit: UInt32 = 100, actions: [Sharing.FileAction]? = nil) {
            comparableValidator(minValue: 1, maxValue: 300)(limit)
            self.limit = limit
            self.actions = actions
        }

        func json() throws -> JSON {
            try ListFilesArgSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ListFilesArgSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ListFilesArg: \(error)"
            }
        }
    }

    public class ListFilesArgSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ListFilesArg) throws -> JSON {
            let output = [
                "limit": try Serialization._UInt32Serializer.serialize(value.limit),
                "actions": try NullableSerializer(ArraySerializer(Sharing.FileActionSerializer())).serialize(value.actions),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ListFilesArg {
            switch json {
            case .dictionary(let dict):
                let limit = try Serialization._UInt32Serializer.deserialize(dict["limit"] ?? .number(100))
                let actions = try NullableSerializer(ArraySerializer(Sharing.FileActionSerializer())).deserialize(dict["actions"] ?? .null)
                return ListFilesArg(limit: limit, actions: actions)
            default:
                throw JSONSerializerError.deserializeError(type: ListFilesArg.self, json: json)
            }
        }
    }

    /// Arguments for listReceivedFilesContinue.
    public class ListFilesContinueArg: CustomStringConvertible, JSONRepresentable {
        /// Cursor in cursor in ListFilesResult.
        public let cursor: String
        public init(cursor: String) {
            stringValidator()(cursor)
            self.cursor = cursor
        }

        func json() throws -> JSON {
            try ListFilesContinueArgSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ListFilesContinueArgSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ListFilesContinueArg: \(error)"
            }
        }
    }

    public class ListFilesContinueArgSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ListFilesContinueArg) throws -> JSON {
            let output = [
                "cursor": try Serialization._StringSerializer.serialize(value.cursor),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ListFilesContinueArg {
            switch json {
            case .dictionary(let dict):
                let cursor = try Serialization._StringSerializer.deserialize(dict["cursor"] ?? .null)
                return ListFilesContinueArg(cursor: cursor)
            default:
                throw JSONSerializerError.deserializeError(type: ListFilesContinueArg.self, json: json)
            }
        }
    }

    /// Error results for listReceivedFilesContinue.
    public enum ListFilesContinueError: CustomStringConvertible, JSONRepresentable {
        /// User account had a problem.
        case userError(Sharing.SharingUserError)
        /// cursor in ListFilesContinueArg is invalid.
        case invalidCursor
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try ListFilesContinueErrorSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ListFilesContinueErrorSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ListFilesContinueError: \(error)"
            }
        }
    }

    public class ListFilesContinueErrorSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ListFilesContinueError) throws -> JSON {
            switch value {
            case .userError(let arg):
                var d = try ["user_error": Sharing.SharingUserErrorSerializer().serialize(arg)]
                d[".tag"] = .str("user_error")
                return .dictionary(d)
            case .invalidCursor:
                var d = [String: JSON]()
                d[".tag"] = .str("invalid_cursor")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> ListFilesContinueError {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "user_error":
                    let v = try Sharing.SharingUserErrorSerializer().deserialize(d["user_error"] ?? .null)
                    return ListFilesContinueError.userError(v)
                case "invalid_cursor":
                    return ListFilesContinueError.invalidCursor
                case "other":
                    return ListFilesContinueError.other
                default:
                    return ListFilesContinueError.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: ListFilesContinueError.self, json: json)
            }
        }
    }

    /// Success results for listReceivedFiles.
    public class ListFilesResult: CustomStringConvertible, JSONRepresentable {
        /// Information about the files shared with current user.
        public let entries: [Sharing.SharedFileMetadata]
        /// Cursor used to obtain additional shared files.
        public let cursor: String?
        public init(entries: [Sharing.SharedFileMetadata], cursor: String? = nil) {
            self.entries = entries
            nullableValidator(stringValidator())(cursor)
            self.cursor = cursor
        }

        func json() throws -> JSON {
            try ListFilesResultSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ListFilesResultSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ListFilesResult: \(error)"
            }
        }
    }

    public class ListFilesResultSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ListFilesResult) throws -> JSON {
            let output = [
                "entries": try ArraySerializer(Sharing.SharedFileMetadataSerializer()).serialize(value.entries),
                "cursor": try NullableSerializer(Serialization._StringSerializer).serialize(value.cursor),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ListFilesResult {
            switch json {
            case .dictionary(let dict):
                let entries = try ArraySerializer(Sharing.SharedFileMetadataSerializer()).deserialize(dict["entries"] ?? .null)
                let cursor = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["cursor"] ?? .null)
                return ListFilesResult(entries: entries, cursor: cursor)
            default:
                throw JSONSerializerError.deserializeError(type: ListFilesResult.self, json: json)
            }
        }
    }

    /// The ListFolderMembersCursorArg struct
    public class ListFolderMembersCursorArg: CustomStringConvertible, JSONRepresentable {
        /// This is a list indicating whether each returned member will include a boolean value allow in
        /// MemberPermission that describes whether the current user can perform the MemberAction on the member.
        public let actions: [Sharing.MemberAction]?
        /// The maximum number of results that include members, groups and invitees to return per request.
        public let limit: UInt32
        public init(actions: [Sharing.MemberAction]? = nil, limit: UInt32 = 1_000) {
            self.actions = actions
            comparableValidator(minValue: 1, maxValue: 1_000)(limit)
            self.limit = limit
        }

        func json() throws -> JSON {
            try ListFolderMembersCursorArgSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ListFolderMembersCursorArgSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ListFolderMembersCursorArg: \(error)"
            }
        }
    }

    public class ListFolderMembersCursorArgSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ListFolderMembersCursorArg) throws -> JSON {
            let output = [
                "actions": try NullableSerializer(ArraySerializer(Sharing.MemberActionSerializer())).serialize(value.actions),
                "limit": try Serialization._UInt32Serializer.serialize(value.limit),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ListFolderMembersCursorArg {
            switch json {
            case .dictionary(let dict):
                let actions = try NullableSerializer(ArraySerializer(Sharing.MemberActionSerializer())).deserialize(dict["actions"] ?? .null)
                let limit = try Serialization._UInt32Serializer.deserialize(dict["limit"] ?? .number(1_000))
                return ListFolderMembersCursorArg(actions: actions, limit: limit)
            default:
                throw JSONSerializerError.deserializeError(type: ListFolderMembersCursorArg.self, json: json)
            }
        }
    }

    /// The ListFolderMembersArgs struct
    public class ListFolderMembersArgs: Sharing.ListFolderMembersCursorArg {
        /// The ID for the shared folder.
        public let sharedFolderId: String
        public init(sharedFolderId: String, actions: [Sharing.MemberAction]? = nil, limit: UInt32 = 1_000) {
            stringValidator(pattern: "[-_0-9a-zA-Z:]+")(sharedFolderId)
            self.sharedFolderId = sharedFolderId
            super.init(actions: actions, limit: limit)
        }

        public override var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ListFolderMembersArgsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ListFolderMembersArgs: \(error)"
            }
        }
    }

    public class ListFolderMembersArgsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ListFolderMembersArgs) throws -> JSON {
            let output = [
                "shared_folder_id": try Serialization._StringSerializer.serialize(value.sharedFolderId),
                "actions": try NullableSerializer(ArraySerializer(Sharing.MemberActionSerializer())).serialize(value.actions),
                "limit": try Serialization._UInt32Serializer.serialize(value.limit),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ListFolderMembersArgs {
            switch json {
            case .dictionary(let dict):
                let sharedFolderId = try Serialization._StringSerializer.deserialize(dict["shared_folder_id"] ?? .null)
                let actions = try NullableSerializer(ArraySerializer(Sharing.MemberActionSerializer())).deserialize(dict["actions"] ?? .null)
                let limit = try Serialization._UInt32Serializer.deserialize(dict["limit"] ?? .number(1_000))
                return ListFolderMembersArgs(sharedFolderId: sharedFolderId, actions: actions, limit: limit)
            default:
                throw JSONSerializerError.deserializeError(type: ListFolderMembersArgs.self, json: json)
            }
        }
    }

    /// The ListFolderMembersContinueArg struct
    public class ListFolderMembersContinueArg: CustomStringConvertible, JSONRepresentable {
        /// The cursor returned by your last call to listFolderMembers or listFolderMembersContinue.
        public let cursor: String
        public init(cursor: String) {
            stringValidator()(cursor)
            self.cursor = cursor
        }

        func json() throws -> JSON {
            try ListFolderMembersContinueArgSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ListFolderMembersContinueArgSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ListFolderMembersContinueArg: \(error)"
            }
        }
    }

    public class ListFolderMembersContinueArgSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ListFolderMembersContinueArg) throws -> JSON {
            let output = [
                "cursor": try Serialization._StringSerializer.serialize(value.cursor),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ListFolderMembersContinueArg {
            switch json {
            case .dictionary(let dict):
                let cursor = try Serialization._StringSerializer.deserialize(dict["cursor"] ?? .null)
                return ListFolderMembersContinueArg(cursor: cursor)
            default:
                throw JSONSerializerError.deserializeError(type: ListFolderMembersContinueArg.self, json: json)
            }
        }
    }

    /// The ListFolderMembersContinueError union
    public enum ListFolderMembersContinueError: CustomStringConvertible, JSONRepresentable {
        /// An unspecified error.
        case accessError(Sharing.SharedFolderAccessError)
        /// cursor in ListFolderMembersContinueArg is invalid.
        case invalidCursor
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try ListFolderMembersContinueErrorSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ListFolderMembersContinueErrorSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ListFolderMembersContinueError: \(error)"
            }
        }
    }

    public class ListFolderMembersContinueErrorSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ListFolderMembersContinueError) throws -> JSON {
            switch value {
            case .accessError(let arg):
                var d = try ["access_error": Sharing.SharedFolderAccessErrorSerializer().serialize(arg)]
                d[".tag"] = .str("access_error")
                return .dictionary(d)
            case .invalidCursor:
                var d = [String: JSON]()
                d[".tag"] = .str("invalid_cursor")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> ListFolderMembersContinueError {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "access_error":
                    let v = try Sharing.SharedFolderAccessErrorSerializer().deserialize(d["access_error"] ?? .null)
                    return ListFolderMembersContinueError.accessError(v)
                case "invalid_cursor":
                    return ListFolderMembersContinueError.invalidCursor
                case "other":
                    return ListFolderMembersContinueError.other
                default:
                    return ListFolderMembersContinueError.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: ListFolderMembersContinueError.self, json: json)
            }
        }
    }

    /// The ListFoldersArgs struct
    public class ListFoldersArgs: CustomStringConvertible, JSONRepresentable {
        /// The maximum number of results to return per request.
        public let limit: UInt32
        /// A list of `FolderAction`s corresponding to `FolderPermission`s that should appear in the  response's
        /// permissions in SharedFolderMetadata field describing the actions the  authenticated user can perform
        /// on the folder.
        public let actions: [Sharing.FolderAction]?
        public init(limit: UInt32 = 1_000, actions: [Sharing.FolderAction]? = nil) {
            comparableValidator(minValue: 1, maxValue: 1_000)(limit)
            self.limit = limit
            self.actions = actions
        }

        func json() throws -> JSON {
            try ListFoldersArgsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ListFoldersArgsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ListFoldersArgs: \(error)"
            }
        }
    }

    public class ListFoldersArgsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ListFoldersArgs) throws -> JSON {
            let output = [
                "limit": try Serialization._UInt32Serializer.serialize(value.limit),
                "actions": try NullableSerializer(ArraySerializer(Sharing.FolderActionSerializer())).serialize(value.actions),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ListFoldersArgs {
            switch json {
            case .dictionary(let dict):
                let limit = try Serialization._UInt32Serializer.deserialize(dict["limit"] ?? .number(1_000))
                let actions = try NullableSerializer(ArraySerializer(Sharing.FolderActionSerializer())).deserialize(dict["actions"] ?? .null)
                return ListFoldersArgs(limit: limit, actions: actions)
            default:
                throw JSONSerializerError.deserializeError(type: ListFoldersArgs.self, json: json)
            }
        }
    }

    /// The ListFoldersContinueArg struct
    public class ListFoldersContinueArg: CustomStringConvertible, JSONRepresentable {
        /// The cursor returned by the previous API call specified in the endpoint description.
        public let cursor: String
        public init(cursor: String) {
            stringValidator()(cursor)
            self.cursor = cursor
        }

        func json() throws -> JSON {
            try ListFoldersContinueArgSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ListFoldersContinueArgSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ListFoldersContinueArg: \(error)"
            }
        }
    }

    public class ListFoldersContinueArgSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ListFoldersContinueArg) throws -> JSON {
            let output = [
                "cursor": try Serialization._StringSerializer.serialize(value.cursor),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ListFoldersContinueArg {
            switch json {
            case .dictionary(let dict):
                let cursor = try Serialization._StringSerializer.deserialize(dict["cursor"] ?? .null)
                return ListFoldersContinueArg(cursor: cursor)
            default:
                throw JSONSerializerError.deserializeError(type: ListFoldersContinueArg.self, json: json)
            }
        }
    }

    /// The ListFoldersContinueError union
    public enum ListFoldersContinueError: CustomStringConvertible, JSONRepresentable {
        /// cursor in ListFoldersContinueArg is invalid.
        case invalidCursor
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try ListFoldersContinueErrorSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ListFoldersContinueErrorSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ListFoldersContinueError: \(error)"
            }
        }
    }

    public class ListFoldersContinueErrorSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ListFoldersContinueError) throws -> JSON {
            switch value {
            case .invalidCursor:
                var d = [String: JSON]()
                d[".tag"] = .str("invalid_cursor")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> ListFoldersContinueError {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "invalid_cursor":
                    return ListFoldersContinueError.invalidCursor
                case "other":
                    return ListFoldersContinueError.other
                default:
                    return ListFoldersContinueError.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: ListFoldersContinueError.self, json: json)
            }
        }
    }

    /// Result for listFolders or listMountableFolders, depending on which endpoint was requested. Unmounted shared
    /// folders can be identified by the absence of pathLower in SharedFolderMetadata.
    public class ListFoldersResult: CustomStringConvertible, JSONRepresentable {
        /// List of all shared folders the authenticated user has access to.
        public let entries: [Sharing.SharedFolderMetadata]
        /// Present if there are additional shared folders that have not been returned yet. Pass the cursor into the
        /// corresponding continue endpoint (either listFoldersContinue or listMountableFoldersContinue) to list
        /// additional folders.
        public let cursor: String?
        public init(entries: [Sharing.SharedFolderMetadata], cursor: String? = nil) {
            self.entries = entries
            nullableValidator(stringValidator())(cursor)
            self.cursor = cursor
        }

        func json() throws -> JSON {
            try ListFoldersResultSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ListFoldersResultSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ListFoldersResult: \(error)"
            }
        }
    }

    public class ListFoldersResultSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ListFoldersResult) throws -> JSON {
            let output = [
                "entries": try ArraySerializer(Sharing.SharedFolderMetadataSerializer()).serialize(value.entries),
                "cursor": try NullableSerializer(Serialization._StringSerializer).serialize(value.cursor),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ListFoldersResult {
            switch json {
            case .dictionary(let dict):
                let entries = try ArraySerializer(Sharing.SharedFolderMetadataSerializer()).deserialize(dict["entries"] ?? .null)
                let cursor = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["cursor"] ?? .null)
                return ListFoldersResult(entries: entries, cursor: cursor)
            default:
                throw JSONSerializerError.deserializeError(type: ListFoldersResult.self, json: json)
            }
        }
    }

    /// The ListSharedLinksArg struct
    public class ListSharedLinksArg: CustomStringConvertible, JSONRepresentable {
        /// See listSharedLinks description.
        public let path: String?
        /// The cursor returned by your last call to listSharedLinks.
        public let cursor: String?
        /// See listSharedLinks description.
        public let directOnly: Bool?
        public init(path: String? = nil, cursor: String? = nil, directOnly: Bool? = nil) {
            nullableValidator(stringValidator(pattern: "(/(.|[\\r\\n])*|id:.*)|(rev:[0-9a-f]{9,})|(ns:[0-9]+(/.*)?)"))(path)
            self.path = path
            nullableValidator(stringValidator())(cursor)
            self.cursor = cursor
            self.directOnly = directOnly
        }

        func json() throws -> JSON {
            try ListSharedLinksArgSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ListSharedLinksArgSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ListSharedLinksArg: \(error)"
            }
        }
    }

    public class ListSharedLinksArgSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ListSharedLinksArg) throws -> JSON {
            let output = [
                "path": try NullableSerializer(Serialization._StringSerializer).serialize(value.path),
                "cursor": try NullableSerializer(Serialization._StringSerializer).serialize(value.cursor),
                "direct_only": try NullableSerializer(Serialization._BoolSerializer).serialize(value.directOnly),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ListSharedLinksArg {
            switch json {
            case .dictionary(let dict):
                let path = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["path"] ?? .null)
                let cursor = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["cursor"] ?? .null)
                let directOnly = try NullableSerializer(Serialization._BoolSerializer).deserialize(dict["direct_only"] ?? .null)
                return ListSharedLinksArg(path: path, cursor: cursor, directOnly: directOnly)
            default:
                throw JSONSerializerError.deserializeError(type: ListSharedLinksArg.self, json: json)
            }
        }
    }

    /// The ListSharedLinksError union
    public enum ListSharedLinksError: CustomStringConvertible, JSONRepresentable {
        /// An unspecified error.
        case path(Files.LookupError)
        /// Indicates that the cursor has been invalidated. Call listSharedLinks to obtain a new cursor.
        case reset
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try ListSharedLinksErrorSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ListSharedLinksErrorSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ListSharedLinksError: \(error)"
            }
        }
    }

    public class ListSharedLinksErrorSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ListSharedLinksError) throws -> JSON {
            switch value {
            case .path(let arg):
                var d = try ["path": Files.LookupErrorSerializer().serialize(arg)]
                d[".tag"] = .str("path")
                return .dictionary(d)
            case .reset:
                var d = [String: JSON]()
                d[".tag"] = .str("reset")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> ListSharedLinksError {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "path":
                    let v = try Files.LookupErrorSerializer().deserialize(d["path"] ?? .null)
                    return ListSharedLinksError.path(v)
                case "reset":
                    return ListSharedLinksError.reset
                case "other":
                    return ListSharedLinksError.other
                default:
                    return ListSharedLinksError.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: ListSharedLinksError.self, json: json)
            }
        }
    }

    /// The ListSharedLinksResult struct
    public class ListSharedLinksResult: CustomStringConvertible, JSONRepresentable {
        /// Shared links applicable to the path argument.
        public let links: [Sharing.SharedLinkMetadata]
        /// Is true if there are additional shared links that have not been returned yet. Pass the cursor into
        /// listSharedLinks to retrieve them.
        public let hasMore: Bool
        /// Pass the cursor into listSharedLinks to obtain the additional links. Cursor is returned only if no path is
        /// given.
        public let cursor: String?
        public init(links: [Sharing.SharedLinkMetadata], hasMore: Bool, cursor: String? = nil) {
            self.links = links
            self.hasMore = hasMore
            nullableValidator(stringValidator())(cursor)
            self.cursor = cursor
        }

        func json() throws -> JSON {
            try ListSharedLinksResultSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ListSharedLinksResultSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ListSharedLinksResult: \(error)"
            }
        }
    }

    public class ListSharedLinksResultSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ListSharedLinksResult) throws -> JSON {
            let output = [
                "links": try ArraySerializer(Sharing.SharedLinkMetadataSerializer()).serialize(value.links),
                "has_more": try Serialization._BoolSerializer.serialize(value.hasMore),
                "cursor": try NullableSerializer(Serialization._StringSerializer).serialize(value.cursor),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ListSharedLinksResult {
            switch json {
            case .dictionary(let dict):
                let links = try ArraySerializer(Sharing.SharedLinkMetadataSerializer()).deserialize(dict["links"] ?? .null)
                let hasMore = try Serialization._BoolSerializer.deserialize(dict["has_more"] ?? .null)
                let cursor = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["cursor"] ?? .null)
                return ListSharedLinksResult(links: links, hasMore: hasMore, cursor: cursor)
            default:
                throw JSONSerializerError.deserializeError(type: ListSharedLinksResult.self, json: json)
            }
        }
    }

    /// Contains information about a member's access level to content after an operation.
    public class MemberAccessLevelResult: CustomStringConvertible, JSONRepresentable {
        /// The member still has this level of access to the content through a parent folder.
        public let accessLevel: Sharing.AccessLevel?
        /// A localized string with additional information about why the user has this access level to the content.
        public let warning: String?
        /// The parent folders that a member has access to. The field is present if the user has access to the first
        /// parent folder where the member gains access.
        public let accessDetails: [Sharing.ParentFolderAccessInfo]?
        public init(accessLevel: Sharing.AccessLevel? = nil, warning: String? = nil, accessDetails: [Sharing.ParentFolderAccessInfo]? = nil) {
            self.accessLevel = accessLevel
            nullableValidator(stringValidator())(warning)
            self.warning = warning
            self.accessDetails = accessDetails
        }

        func json() throws -> JSON {
            try MemberAccessLevelResultSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try MemberAccessLevelResultSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for MemberAccessLevelResult: \(error)"
            }
        }
    }

    public class MemberAccessLevelResultSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: MemberAccessLevelResult) throws -> JSON {
            let output = [
                "access_level": try NullableSerializer(Sharing.AccessLevelSerializer()).serialize(value.accessLevel),
                "warning": try NullableSerializer(Serialization._StringSerializer).serialize(value.warning),
                "access_details": try NullableSerializer(ArraySerializer(Sharing.ParentFolderAccessInfoSerializer())).serialize(value.accessDetails),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> MemberAccessLevelResult {
            switch json {
            case .dictionary(let dict):
                let accessLevel = try NullableSerializer(Sharing.AccessLevelSerializer()).deserialize(dict["access_level"] ?? .null)
                let warning = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["warning"] ?? .null)
                let accessDetails = try NullableSerializer(ArraySerializer(Sharing.ParentFolderAccessInfoSerializer()))
                    .deserialize(dict["access_details"] ?? .null)
                return MemberAccessLevelResult(accessLevel: accessLevel, warning: warning, accessDetails: accessDetails)
            default:
                throw JSONSerializerError.deserializeError(type: MemberAccessLevelResult.self, json: json)
            }
        }
    }

    /// Actions that may be taken on members of a shared folder.
    public enum MemberAction: CustomStringConvertible, JSONRepresentable {
        /// Allow the member to keep a copy of the folder when removing.
        case leaveACopy
        /// Make the member an editor of the folder.
        case makeEditor
        /// Make the member an owner of the folder.
        case makeOwner
        /// Make the member a viewer of the folder.
        case makeViewer
        /// Make the member a viewer of the folder without commenting permissions.
        case makeViewerNoComment
        /// Remove the member from the folder.
        case remove
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try MemberActionSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try MemberActionSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for MemberAction: \(error)"
            }
        }
    }

    public class MemberActionSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: MemberAction) throws -> JSON {
            switch value {
            case .leaveACopy:
                var d = [String: JSON]()
                d[".tag"] = .str("leave_a_copy")
                return .dictionary(d)
            case .makeEditor:
                var d = [String: JSON]()
                d[".tag"] = .str("make_editor")
                return .dictionary(d)
            case .makeOwner:
                var d = [String: JSON]()
                d[".tag"] = .str("make_owner")
                return .dictionary(d)
            case .makeViewer:
                var d = [String: JSON]()
                d[".tag"] = .str("make_viewer")
                return .dictionary(d)
            case .makeViewerNoComment:
                var d = [String: JSON]()
                d[".tag"] = .str("make_viewer_no_comment")
                return .dictionary(d)
            case .remove:
                var d = [String: JSON]()
                d[".tag"] = .str("remove")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> MemberAction {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "leave_a_copy":
                    return MemberAction.leaveACopy
                case "make_editor":
                    return MemberAction.makeEditor
                case "make_owner":
                    return MemberAction.makeOwner
                case "make_viewer":
                    return MemberAction.makeViewer
                case "make_viewer_no_comment":
                    return MemberAction.makeViewerNoComment
                case "remove":
                    return MemberAction.remove
                case "other":
                    return MemberAction.other
                default:
                    return MemberAction.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: MemberAction.self, json: json)
            }
        }
    }

    /// Whether the user is allowed to take the action on the associated member.
    public class MemberPermission: CustomStringConvertible, JSONRepresentable {
        /// The action that the user may wish to take on the member.
        public let action: Sharing.MemberAction
        /// True if the user is allowed to take the action.
        public let allow: Bool
        /// The reason why the user is denied the permission. Not present if the action is allowed.
        public let reason: Sharing.PermissionDeniedReason?
        public init(action: Sharing.MemberAction, allow: Bool, reason: Sharing.PermissionDeniedReason? = nil) {
            self.action = action
            self.allow = allow
            self.reason = reason
        }

        func json() throws -> JSON {
            try MemberPermissionSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try MemberPermissionSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for MemberPermission: \(error)"
            }
        }
    }

    public class MemberPermissionSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: MemberPermission) throws -> JSON {
            let output = [
                "action": try Sharing.MemberActionSerializer().serialize(value.action),
                "allow": try Serialization._BoolSerializer.serialize(value.allow),
                "reason": try NullableSerializer(Sharing.PermissionDeniedReasonSerializer()).serialize(value.reason),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> MemberPermission {
            switch json {
            case .dictionary(let dict):
                let action = try Sharing.MemberActionSerializer().deserialize(dict["action"] ?? .null)
                let allow = try Serialization._BoolSerializer.deserialize(dict["allow"] ?? .null)
                let reason = try NullableSerializer(Sharing.PermissionDeniedReasonSerializer()).deserialize(dict["reason"] ?? .null)
                return MemberPermission(action: action, allow: allow, reason: reason)
            default:
                throw JSONSerializerError.deserializeError(type: MemberPermission.self, json: json)
            }
        }
    }

    /// Policy governing who can be a member of a shared folder. Only applicable to folders owned by a user on a team.
    public enum MemberPolicy: CustomStringConvertible, JSONRepresentable {
        /// Only a teammate can become a member.
        case team
        /// Anyone can become a member.
        case anyone
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try MemberPolicySerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try MemberPolicySerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for MemberPolicy: \(error)"
            }
        }
    }

    public class MemberPolicySerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: MemberPolicy) throws -> JSON {
            switch value {
            case .team:
                var d = [String: JSON]()
                d[".tag"] = .str("team")
                return .dictionary(d)
            case .anyone:
                var d = [String: JSON]()
                d[".tag"] = .str("anyone")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> MemberPolicy {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "team":
                    return MemberPolicy.team
                case "anyone":
                    return MemberPolicy.anyone
                case "other":
                    return MemberPolicy.other
                default:
                    return MemberPolicy.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: MemberPolicy.self, json: json)
            }
        }
    }

    /// Includes different ways to identify a member of a shared folder.
    public enum MemberSelector: CustomStringConvertible, JSONRepresentable {
        /// Dropbox account, team member, or group ID of member.
        case dropboxId(String)
        /// Email address of member.
        case email(String)
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try MemberSelectorSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try MemberSelectorSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for MemberSelector: \(error)"
            }
        }
    }

    public class MemberSelectorSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: MemberSelector) throws -> JSON {
            switch value {
            case .dropboxId(let arg):
                var d = try ["dropbox_id": Serialization._StringSerializer.serialize(arg)]
                d[".tag"] = .str("dropbox_id")
                return .dictionary(d)
            case .email(let arg):
                var d = try ["email": Serialization._StringSerializer.serialize(arg)]
                d[".tag"] = .str("email")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> MemberSelector {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "dropbox_id":
                    let v = try Serialization._StringSerializer.deserialize(d["dropbox_id"] ?? .null)
                    return MemberSelector.dropboxId(v)
                case "email":
                    let v = try Serialization._StringSerializer.deserialize(d["email"] ?? .null)
                    return MemberSelector.email(v)
                case "other":
                    return MemberSelector.other
                default:
                    return MemberSelector.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: MemberSelector.self, json: json)
            }
        }
    }

    /// The ModifySharedLinkSettingsArgs struct
    public class ModifySharedLinkSettingsArgs: CustomStringConvertible, JSONRepresentable {
        /// URL of the shared link to change its settings.
        public let url: String
        /// Set of settings for the shared link.
        public let settings: Sharing.SharedLinkSettings
        /// If set to true, removes the expiration of the shared link.
        public let removeExpiration: Bool
        public init(url: String, settings: Sharing.SharedLinkSettings, removeExpiration: Bool = false) {
            stringValidator()(url)
            self.url = url
            self.settings = settings
            self.removeExpiration = removeExpiration
        }

        func json() throws -> JSON {
            try ModifySharedLinkSettingsArgsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ModifySharedLinkSettingsArgsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ModifySharedLinkSettingsArgs: \(error)"
            }
        }
    }

    public class ModifySharedLinkSettingsArgsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ModifySharedLinkSettingsArgs) throws -> JSON {
            let output = [
                "url": try Serialization._StringSerializer.serialize(value.url),
                "settings": try Sharing.SharedLinkSettingsSerializer().serialize(value.settings),
                "remove_expiration": try Serialization._BoolSerializer.serialize(value.removeExpiration),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ModifySharedLinkSettingsArgs {
            switch json {
            case .dictionary(let dict):
                let url = try Serialization._StringSerializer.deserialize(dict["url"] ?? .null)
                let settings = try Sharing.SharedLinkSettingsSerializer().deserialize(dict["settings"] ?? .null)
                let removeExpiration = try Serialization._BoolSerializer.deserialize(dict["remove_expiration"] ?? .number(0))
                return ModifySharedLinkSettingsArgs(url: url, settings: settings, removeExpiration: removeExpiration)
            default:
                throw JSONSerializerError.deserializeError(type: ModifySharedLinkSettingsArgs.self, json: json)
            }
        }
    }

    /// The ModifySharedLinkSettingsError union
    public enum ModifySharedLinkSettingsError: CustomStringConvertible, JSONRepresentable {
        /// The shared link wasn't found.
        case sharedLinkNotFound
        /// The caller is not allowed to access this shared link.
        case sharedLinkAccessDenied
        /// This type of link is not supported; use files instead.
        case unsupportedLinkType
        /// An unspecified error.
        case other
        /// There is an error with the given settings.
        case settingsError(Sharing.SharedLinkSettingsError)
        /// This user's email address is not verified. This functionality is only available on accounts with a verified
        /// email address. Users can verify their email address here https://www.dropbox.com/help/317.
        case emailNotVerified

        func json() throws -> JSON {
            try ModifySharedLinkSettingsErrorSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ModifySharedLinkSettingsErrorSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ModifySharedLinkSettingsError: \(error)"
            }
        }
    }

    public class ModifySharedLinkSettingsErrorSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ModifySharedLinkSettingsError) throws -> JSON {
            switch value {
            case .sharedLinkNotFound:
                var d = [String: JSON]()
                d[".tag"] = .str("shared_link_not_found")
                return .dictionary(d)
            case .sharedLinkAccessDenied:
                var d = [String: JSON]()
                d[".tag"] = .str("shared_link_access_denied")
                return .dictionary(d)
            case .unsupportedLinkType:
                var d = [String: JSON]()
                d[".tag"] = .str("unsupported_link_type")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            case .settingsError(let arg):
                var d = try ["settings_error": Sharing.SharedLinkSettingsErrorSerializer().serialize(arg)]
                d[".tag"] = .str("settings_error")
                return .dictionary(d)
            case .emailNotVerified:
                var d = [String: JSON]()
                d[".tag"] = .str("email_not_verified")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> ModifySharedLinkSettingsError {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "shared_link_not_found":
                    return ModifySharedLinkSettingsError.sharedLinkNotFound
                case "shared_link_access_denied":
                    return ModifySharedLinkSettingsError.sharedLinkAccessDenied
                case "unsupported_link_type":
                    return ModifySharedLinkSettingsError.unsupportedLinkType
                case "other":
                    return ModifySharedLinkSettingsError.other
                case "settings_error":
                    let v = try Sharing.SharedLinkSettingsErrorSerializer().deserialize(d["settings_error"] ?? .null)
                    return ModifySharedLinkSettingsError.settingsError(v)
                case "email_not_verified":
                    return ModifySharedLinkSettingsError.emailNotVerified
                default:
                    throw JSONSerializerError.unknownTag(type: ModifySharedLinkSettingsError.self, json: json, tag: tag)
                }
            default:
                throw JSONSerializerError.deserializeError(type: ModifySharedLinkSettingsError.self, json: json)
            }
        }
    }

    /// The MountFolderArg struct
    public class MountFolderArg: CustomStringConvertible, JSONRepresentable {
        /// The ID of the shared folder to mount.
        public let sharedFolderId: String
        public init(sharedFolderId: String) {
            stringValidator(pattern: "[-_0-9a-zA-Z:]+")(sharedFolderId)
            self.sharedFolderId = sharedFolderId
        }

        func json() throws -> JSON {
            try MountFolderArgSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try MountFolderArgSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for MountFolderArg: \(error)"
            }
        }
    }

    public class MountFolderArgSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: MountFolderArg) throws -> JSON {
            let output = [
                "shared_folder_id": try Serialization._StringSerializer.serialize(value.sharedFolderId),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> MountFolderArg {
            switch json {
            case .dictionary(let dict):
                let sharedFolderId = try Serialization._StringSerializer.deserialize(dict["shared_folder_id"] ?? .null)
                return MountFolderArg(sharedFolderId: sharedFolderId)
            default:
                throw JSONSerializerError.deserializeError(type: MountFolderArg.self, json: json)
            }
        }
    }

    /// The MountFolderError union
    public enum MountFolderError: CustomStringConvertible, JSONRepresentable {
        /// An unspecified error.
        case accessError(Sharing.SharedFolderAccessError)
        /// Mounting would cause a shared folder to be inside another, which is disallowed.
        case insideSharedFolder
        /// The current user does not have enough space to mount the shared folder.
        case insufficientQuota(Sharing.InsufficientQuotaAmounts)
        /// The shared folder is already mounted.
        case alreadyMounted
        /// The current user does not have permission to perform this action.
        case noPermission
        /// The shared folder is not mountable. One example where this can occur is when the shared folder belongs
        /// within a team folder in the user's Dropbox.
        case notMountable
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try MountFolderErrorSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try MountFolderErrorSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for MountFolderError: \(error)"
            }
        }
    }

    public class MountFolderErrorSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: MountFolderError) throws -> JSON {
            switch value {
            case .accessError(let arg):
                var d = try ["access_error": Sharing.SharedFolderAccessErrorSerializer().serialize(arg)]
                d[".tag"] = .str("access_error")
                return .dictionary(d)
            case .insideSharedFolder:
                var d = [String: JSON]()
                d[".tag"] = .str("inside_shared_folder")
                return .dictionary(d)
            case .insufficientQuota(let arg):
                var d = try Serialization.getFields(Sharing.InsufficientQuotaAmountsSerializer().serialize(arg))
                d[".tag"] = .str("insufficient_quota")
                return .dictionary(d)
            case .alreadyMounted:
                var d = [String: JSON]()
                d[".tag"] = .str("already_mounted")
                return .dictionary(d)
            case .noPermission:
                var d = [String: JSON]()
                d[".tag"] = .str("no_permission")
                return .dictionary(d)
            case .notMountable:
                var d = [String: JSON]()
                d[".tag"] = .str("not_mountable")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> MountFolderError {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "access_error":
                    let v = try Sharing.SharedFolderAccessErrorSerializer().deserialize(d["access_error"] ?? .null)
                    return MountFolderError.accessError(v)
                case "inside_shared_folder":
                    return MountFolderError.insideSharedFolder
                case "insufficient_quota":
                    let v = try Sharing.InsufficientQuotaAmountsSerializer().deserialize(json)
                    return MountFolderError.insufficientQuota(v)
                case "already_mounted":
                    return MountFolderError.alreadyMounted
                case "no_permission":
                    return MountFolderError.noPermission
                case "not_mountable":
                    return MountFolderError.notMountable
                case "other":
                    return MountFolderError.other
                default:
                    return MountFolderError.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: MountFolderError.self, json: json)
            }
        }
    }

    /// Contains information about a parent folder that a member has access to.
    public class ParentFolderAccessInfo: CustomStringConvertible, JSONRepresentable {
        /// Display name for the folder.
        public let folderName: String
        /// The identifier of the parent shared folder.
        public let sharedFolderId: String
        /// The user's permissions for the parent shared folder.
        public let permissions: [Sharing.MemberPermission]
        /// The full path to the parent shared folder relative to the acting user's root.
        public let path: String
        public init(folderName: String, sharedFolderId: String, permissions: [Sharing.MemberPermission], path: String) {
            stringValidator()(folderName)
            self.folderName = folderName
            stringValidator(pattern: "[-_0-9a-zA-Z:]+")(sharedFolderId)
            self.sharedFolderId = sharedFolderId
            self.permissions = permissions
            stringValidator()(path)
            self.path = path
        }

        func json() throws -> JSON {
            try ParentFolderAccessInfoSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ParentFolderAccessInfoSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ParentFolderAccessInfo: \(error)"
            }
        }
    }

    public class ParentFolderAccessInfoSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ParentFolderAccessInfo) throws -> JSON {
            let output = [
                "folder_name": try Serialization._StringSerializer.serialize(value.folderName),
                "shared_folder_id": try Serialization._StringSerializer.serialize(value.sharedFolderId),
                "permissions": try ArraySerializer(Sharing.MemberPermissionSerializer()).serialize(value.permissions),
                "path": try Serialization._StringSerializer.serialize(value.path),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ParentFolderAccessInfo {
            switch json {
            case .dictionary(let dict):
                let folderName = try Serialization._StringSerializer.deserialize(dict["folder_name"] ?? .null)
                let sharedFolderId = try Serialization._StringSerializer.deserialize(dict["shared_folder_id"] ?? .null)
                let permissions = try ArraySerializer(Sharing.MemberPermissionSerializer()).deserialize(dict["permissions"] ?? .null)
                let path = try Serialization._StringSerializer.deserialize(dict["path"] ?? .null)
                return ParentFolderAccessInfo(folderName: folderName, sharedFolderId: sharedFolderId, permissions: permissions, path: path)
            default:
                throw JSONSerializerError.deserializeError(type: ParentFolderAccessInfo.self, json: json)
            }
        }
    }

    /// Metadata for a path-based shared link.
    public class PathLinkMetadata: Sharing.LinkMetadata {
        /// Path in user's Dropbox.
        public let path: String
        public init(url: String, visibility: Sharing.Visibility, path: String, expires: Date? = nil) {
            stringValidator()(path)
            self.path = path
            super.init(url: url, visibility: visibility, expires: expires)
        }

        public override var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PathLinkMetadataSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PathLinkMetadata: \(error)"
            }
        }
    }

    public class PathLinkMetadataSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PathLinkMetadata) throws -> JSON {
            let output = [
                "url": try Serialization._StringSerializer.serialize(value.url),
                "visibility": try Sharing.VisibilitySerializer().serialize(value.visibility),
                "path": try Serialization._StringSerializer.serialize(value.path),
                "expires": try NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.expires),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> PathLinkMetadata {
            switch json {
            case .dictionary(let dict):
                let url = try Serialization._StringSerializer.deserialize(dict["url"] ?? .null)
                let visibility = try Sharing.VisibilitySerializer().deserialize(dict["visibility"] ?? .null)
                let path = try Serialization._StringSerializer.deserialize(dict["path"] ?? .null)
                let expires = try NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).deserialize(dict["expires"] ?? .null)
                return PathLinkMetadata(url: url, visibility: visibility, path: path, expires: expires)
            default:
                throw JSONSerializerError.deserializeError(type: PathLinkMetadata.self, json: json)
            }
        }
    }

    /// Flag to indicate pending upload default (for linking to not-yet-existing paths).
    public enum PendingUploadMode: CustomStringConvertible, JSONRepresentable {
        /// Assume pending uploads are files.
        case file
        /// Assume pending uploads are folders.
        case folder

        func json() throws -> JSON {
            try PendingUploadModeSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PendingUploadModeSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PendingUploadMode: \(error)"
            }
        }
    }

    public class PendingUploadModeSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PendingUploadMode) throws -> JSON {
            switch value {
            case .file:
                var d = [String: JSON]()
                d[".tag"] = .str("file")
                return .dictionary(d)
            case .folder:
                var d = [String: JSON]()
                d[".tag"] = .str("folder")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> PendingUploadMode {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "file":
                    return PendingUploadMode.file
                case "folder":
                    return PendingUploadMode.folder
                default:
                    throw JSONSerializerError.unknownTag(type: PendingUploadMode.self, json: json, tag: tag)
                }
            default:
                throw JSONSerializerError.deserializeError(type: PendingUploadMode.self, json: json)
            }
        }
    }

    /// Possible reasons the user is denied a permission.
    public enum PermissionDeniedReason: CustomStringConvertible, JSONRepresentable {
        /// User is not on the same team as the folder owner.
        case userNotSameTeamAsOwner
        /// User is prohibited by the owner from taking the action.
        case userNotAllowedByOwner
        /// Target is indirectly a member of the folder, for example by being part of a group.
        case targetIsIndirectMember
        /// Target is the owner of the folder.
        case targetIsOwner
        /// Target is the user itself.
        case targetIsSelf
        /// Target is not an active member of the team.
        case targetNotActive
        /// Folder is team folder for a limited team.
        case folderIsLimitedTeamFolder
        /// The content owner needs to be on a Dropbox team to perform this action.
        case ownerNotOnTeam
        /// The user does not have permission to perform this action on the link.
        case permissionDenied
        /// The user's team policy prevents performing this action on the link.
        case restrictedByTeam
        /// The user's account type does not support this action.
        case userAccountType
        /// The user needs to be on a Dropbox team to perform this action.
        case userNotOnTeam
        /// Folder is inside of another shared folder.
        case folderIsInsideSharedFolder
        /// Policy cannot be changed due to restrictions from parent folder.
        case restrictedByParentFolder
        /// An unspecified error.
        case insufficientPlan(Sharing.InsufficientPlan)
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try PermissionDeniedReasonSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try PermissionDeniedReasonSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for PermissionDeniedReason: \(error)"
            }
        }
    }

    public class PermissionDeniedReasonSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: PermissionDeniedReason) throws -> JSON {
            switch value {
            case .userNotSameTeamAsOwner:
                var d = [String: JSON]()
                d[".tag"] = .str("user_not_same_team_as_owner")
                return .dictionary(d)
            case .userNotAllowedByOwner:
                var d = [String: JSON]()
                d[".tag"] = .str("user_not_allowed_by_owner")
                return .dictionary(d)
            case .targetIsIndirectMember:
                var d = [String: JSON]()
                d[".tag"] = .str("target_is_indirect_member")
                return .dictionary(d)
            case .targetIsOwner:
                var d = [String: JSON]()
                d[".tag"] = .str("target_is_owner")
                return .dictionary(d)
            case .targetIsSelf:
                var d = [String: JSON]()
                d[".tag"] = .str("target_is_self")
                return .dictionary(d)
            case .targetNotActive:
                var d = [String: JSON]()
                d[".tag"] = .str("target_not_active")
                return .dictionary(d)
            case .folderIsLimitedTeamFolder:
                var d = [String: JSON]()
                d[".tag"] = .str("folder_is_limited_team_folder")
                return .dictionary(d)
            case .ownerNotOnTeam:
                var d = [String: JSON]()
                d[".tag"] = .str("owner_not_on_team")
                return .dictionary(d)
            case .permissionDenied:
                var d = [String: JSON]()
                d[".tag"] = .str("permission_denied")
                return .dictionary(d)
            case .restrictedByTeam:
                var d = [String: JSON]()
                d[".tag"] = .str("restricted_by_team")
                return .dictionary(d)
            case .userAccountType:
                var d = [String: JSON]()
                d[".tag"] = .str("user_account_type")
                return .dictionary(d)
            case .userNotOnTeam:
                var d = [String: JSON]()
                d[".tag"] = .str("user_not_on_team")
                return .dictionary(d)
            case .folderIsInsideSharedFolder:
                var d = [String: JSON]()
                d[".tag"] = .str("folder_is_inside_shared_folder")
                return .dictionary(d)
            case .restrictedByParentFolder:
                var d = [String: JSON]()
                d[".tag"] = .str("restricted_by_parent_folder")
                return .dictionary(d)
            case .insufficientPlan(let arg):
                var d = try Serialization.getFields(Sharing.InsufficientPlanSerializer().serialize(arg))
                d[".tag"] = .str("insufficient_plan")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> PermissionDeniedReason {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "user_not_same_team_as_owner":
                    return PermissionDeniedReason.userNotSameTeamAsOwner
                case "user_not_allowed_by_owner":
                    return PermissionDeniedReason.userNotAllowedByOwner
                case "target_is_indirect_member":
                    return PermissionDeniedReason.targetIsIndirectMember
                case "target_is_owner":
                    return PermissionDeniedReason.targetIsOwner
                case "target_is_self":
                    return PermissionDeniedReason.targetIsSelf
                case "target_not_active":
                    return PermissionDeniedReason.targetNotActive
                case "folder_is_limited_team_folder":
                    return PermissionDeniedReason.folderIsLimitedTeamFolder
                case "owner_not_on_team":
                    return PermissionDeniedReason.ownerNotOnTeam
                case "permission_denied":
                    return PermissionDeniedReason.permissionDenied
                case "restricted_by_team":
                    return PermissionDeniedReason.restrictedByTeam
                case "user_account_type":
                    return PermissionDeniedReason.userAccountType
                case "user_not_on_team":
                    return PermissionDeniedReason.userNotOnTeam
                case "folder_is_inside_shared_folder":
                    return PermissionDeniedReason.folderIsInsideSharedFolder
                case "restricted_by_parent_folder":
                    return PermissionDeniedReason.restrictedByParentFolder
                case "insufficient_plan":
                    let v = try Sharing.InsufficientPlanSerializer().deserialize(json)
                    return PermissionDeniedReason.insufficientPlan(v)
                case "other":
                    return PermissionDeniedReason.other
                default:
                    return PermissionDeniedReason.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: PermissionDeniedReason.self, json: json)
            }
        }
    }

    /// The RelinquishFileMembershipArg struct
    public class RelinquishFileMembershipArg: CustomStringConvertible, JSONRepresentable {
        /// The path or id for the file.
        public let file: String
        public init(file: String) {
            stringValidator(minLength: 1, pattern: "((/|id:).*|nspath:[0-9]+:.*)|ns:[0-9]+(/.*)?")(file)
            self.file = file
        }

        func json() throws -> JSON {
            try RelinquishFileMembershipArgSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try RelinquishFileMembershipArgSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for RelinquishFileMembershipArg: \(error)"
            }
        }
    }

    public class RelinquishFileMembershipArgSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: RelinquishFileMembershipArg) throws -> JSON {
            let output = [
                "file": try Serialization._StringSerializer.serialize(value.file),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> RelinquishFileMembershipArg {
            switch json {
            case .dictionary(let dict):
                let file = try Serialization._StringSerializer.deserialize(dict["file"] ?? .null)
                return RelinquishFileMembershipArg(file: file)
            default:
                throw JSONSerializerError.deserializeError(type: RelinquishFileMembershipArg.self, json: json)
            }
        }
    }

    /// The RelinquishFileMembershipError union
    public enum RelinquishFileMembershipError: CustomStringConvertible, JSONRepresentable {
        /// An unspecified error.
        case accessError(Sharing.SharingFileAccessError)
        /// The current user has access to the shared file via a group.  You can't relinquish membership to a file
        /// shared via groups.
        case groupAccess
        /// The current user does not have permission to perform this action.
        case noPermission
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try RelinquishFileMembershipErrorSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try RelinquishFileMembershipErrorSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for RelinquishFileMembershipError: \(error)"
            }
        }
    }

    public class RelinquishFileMembershipErrorSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: RelinquishFileMembershipError) throws -> JSON {
            switch value {
            case .accessError(let arg):
                var d = try ["access_error": Sharing.SharingFileAccessErrorSerializer().serialize(arg)]
                d[".tag"] = .str("access_error")
                return .dictionary(d)
            case .groupAccess:
                var d = [String: JSON]()
                d[".tag"] = .str("group_access")
                return .dictionary(d)
            case .noPermission:
                var d = [String: JSON]()
                d[".tag"] = .str("no_permission")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> RelinquishFileMembershipError {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "access_error":
                    let v = try Sharing.SharingFileAccessErrorSerializer().deserialize(d["access_error"] ?? .null)
                    return RelinquishFileMembershipError.accessError(v)
                case "group_access":
                    return RelinquishFileMembershipError.groupAccess
                case "no_permission":
                    return RelinquishFileMembershipError.noPermission
                case "other":
                    return RelinquishFileMembershipError.other
                default:
                    return RelinquishFileMembershipError.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: RelinquishFileMembershipError.self, json: json)
            }
        }
    }

    /// The RelinquishFolderMembershipArg struct
    public class RelinquishFolderMembershipArg: CustomStringConvertible, JSONRepresentable {
        /// The ID for the shared folder.
        public let sharedFolderId: String
        /// Keep a copy of the folder's contents upon relinquishing membership. This must be set to false when the
        /// folder is within a team folder or another shared folder.
        public let leaveACopy: Bool
        public init(sharedFolderId: String, leaveACopy: Bool = false) {
            stringValidator(pattern: "[-_0-9a-zA-Z:]+")(sharedFolderId)
            self.sharedFolderId = sharedFolderId
            self.leaveACopy = leaveACopy
        }

        func json() throws -> JSON {
            try RelinquishFolderMembershipArgSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try RelinquishFolderMembershipArgSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for RelinquishFolderMembershipArg: \(error)"
            }
        }
    }

    public class RelinquishFolderMembershipArgSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: RelinquishFolderMembershipArg) throws -> JSON {
            let output = [
                "shared_folder_id": try Serialization._StringSerializer.serialize(value.sharedFolderId),
                "leave_a_copy": try Serialization._BoolSerializer.serialize(value.leaveACopy),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> RelinquishFolderMembershipArg {
            switch json {
            case .dictionary(let dict):
                let sharedFolderId = try Serialization._StringSerializer.deserialize(dict["shared_folder_id"] ?? .null)
                let leaveACopy = try Serialization._BoolSerializer.deserialize(dict["leave_a_copy"] ?? .number(0))
                return RelinquishFolderMembershipArg(sharedFolderId: sharedFolderId, leaveACopy: leaveACopy)
            default:
                throw JSONSerializerError.deserializeError(type: RelinquishFolderMembershipArg.self, json: json)
            }
        }
    }

    /// The RelinquishFolderMembershipError union
    public enum RelinquishFolderMembershipError: CustomStringConvertible, JSONRepresentable {
        /// An unspecified error.
        case accessError(Sharing.SharedFolderAccessError)
        /// The current user is the owner of the shared folder. Owners cannot relinquish membership to their own
        /// folders. Try unsharing or transferring ownership first.
        case folderOwner
        /// The shared folder is currently mounted.  Unmount the shared folder before relinquishing membership.
        case mounted
        /// The current user has access to the shared folder via a group.  You can't relinquish membership to folders
        /// shared via groups.
        case groupAccess
        /// This action cannot be performed on a team shared folder.
        case teamFolder
        /// The current user does not have permission to perform this action.
        case noPermission
        /// The current user only has inherited access to the shared folder.  You can't relinquish inherited membership
        /// to folders.
        case noExplicitAccess
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try RelinquishFolderMembershipErrorSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try RelinquishFolderMembershipErrorSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for RelinquishFolderMembershipError: \(error)"
            }
        }
    }

    public class RelinquishFolderMembershipErrorSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: RelinquishFolderMembershipError) throws -> JSON {
            switch value {
            case .accessError(let arg):
                var d = try ["access_error": Sharing.SharedFolderAccessErrorSerializer().serialize(arg)]
                d[".tag"] = .str("access_error")
                return .dictionary(d)
            case .folderOwner:
                var d = [String: JSON]()
                d[".tag"] = .str("folder_owner")
                return .dictionary(d)
            case .mounted:
                var d = [String: JSON]()
                d[".tag"] = .str("mounted")
                return .dictionary(d)
            case .groupAccess:
                var d = [String: JSON]()
                d[".tag"] = .str("group_access")
                return .dictionary(d)
            case .teamFolder:
                var d = [String: JSON]()
                d[".tag"] = .str("team_folder")
                return .dictionary(d)
            case .noPermission:
                var d = [String: JSON]()
                d[".tag"] = .str("no_permission")
                return .dictionary(d)
            case .noExplicitAccess:
                var d = [String: JSON]()
                d[".tag"] = .str("no_explicit_access")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> RelinquishFolderMembershipError {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "access_error":
                    let v = try Sharing.SharedFolderAccessErrorSerializer().deserialize(d["access_error"] ?? .null)
                    return RelinquishFolderMembershipError.accessError(v)
                case "folder_owner":
                    return RelinquishFolderMembershipError.folderOwner
                case "mounted":
                    return RelinquishFolderMembershipError.mounted
                case "group_access":
                    return RelinquishFolderMembershipError.groupAccess
                case "team_folder":
                    return RelinquishFolderMembershipError.teamFolder
                case "no_permission":
                    return RelinquishFolderMembershipError.noPermission
                case "no_explicit_access":
                    return RelinquishFolderMembershipError.noExplicitAccess
                case "other":
                    return RelinquishFolderMembershipError.other
                default:
                    return RelinquishFolderMembershipError.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: RelinquishFolderMembershipError.self, json: json)
            }
        }
    }

    /// Arguments for removeFileMember2.
    public class RemoveFileMemberArg: CustomStringConvertible, JSONRepresentable {
        /// File from which to remove members.
        public let file: String
        /// Member to remove from this file. Note that even if an email is specified, it may result in the removal of a
        /// user (not an invitee) if the user's main account corresponds to that email address.
        public let member: Sharing.MemberSelector
        public init(file: String, member: Sharing.MemberSelector) {
            stringValidator(minLength: 1, pattern: "((/|id:).*|nspath:[0-9]+:.*)|ns:[0-9]+(/.*)?")(file)
            self.file = file
            self.member = member
        }

        func json() throws -> JSON {
            try RemoveFileMemberArgSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try RemoveFileMemberArgSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for RemoveFileMemberArg: \(error)"
            }
        }
    }

    public class RemoveFileMemberArgSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: RemoveFileMemberArg) throws -> JSON {
            let output = [
                "file": try Serialization._StringSerializer.serialize(value.file),
                "member": try Sharing.MemberSelectorSerializer().serialize(value.member),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> RemoveFileMemberArg {
            switch json {
            case .dictionary(let dict):
                let file = try Serialization._StringSerializer.deserialize(dict["file"] ?? .null)
                let member = try Sharing.MemberSelectorSerializer().deserialize(dict["member"] ?? .null)
                return RemoveFileMemberArg(file: file, member: member)
            default:
                throw JSONSerializerError.deserializeError(type: RemoveFileMemberArg.self, json: json)
            }
        }
    }

    /// Errors for removeFileMember2.
    public enum RemoveFileMemberError: CustomStringConvertible, JSONRepresentable {
        /// An unspecified error.
        case userError(Sharing.SharingUserError)
        /// An unspecified error.
        case accessError(Sharing.SharingFileAccessError)
        /// This member does not have explicit access to the file and therefore cannot be removed. The return value is
        /// the access that a user might have to the file from a parent folder.
        case noExplicitAccess(Sharing.MemberAccessLevelResult)
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try RemoveFileMemberErrorSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try RemoveFileMemberErrorSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for RemoveFileMemberError: \(error)"
            }
        }
    }

    public class RemoveFileMemberErrorSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: RemoveFileMemberError) throws -> JSON {
            switch value {
            case .userError(let arg):
                var d = try ["user_error": Sharing.SharingUserErrorSerializer().serialize(arg)]
                d[".tag"] = .str("user_error")
                return .dictionary(d)
            case .accessError(let arg):
                var d = try ["access_error": Sharing.SharingFileAccessErrorSerializer().serialize(arg)]
                d[".tag"] = .str("access_error")
                return .dictionary(d)
            case .noExplicitAccess(let arg):
                var d = try Serialization.getFields(Sharing.MemberAccessLevelResultSerializer().serialize(arg))
                d[".tag"] = .str("no_explicit_access")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> RemoveFileMemberError {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "user_error":
                    let v = try Sharing.SharingUserErrorSerializer().deserialize(d["user_error"] ?? .null)
                    return RemoveFileMemberError.userError(v)
                case "access_error":
                    let v = try Sharing.SharingFileAccessErrorSerializer().deserialize(d["access_error"] ?? .null)
                    return RemoveFileMemberError.accessError(v)
                case "no_explicit_access":
                    let v = try Sharing.MemberAccessLevelResultSerializer().deserialize(json)
                    return RemoveFileMemberError.noExplicitAccess(v)
                case "other":
                    return RemoveFileMemberError.other
                default:
                    return RemoveFileMemberError.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: RemoveFileMemberError.self, json: json)
            }
        }
    }

    /// The RemoveFolderMemberArg struct
    public class RemoveFolderMemberArg: CustomStringConvertible, JSONRepresentable {
        /// The ID for the shared folder.
        public let sharedFolderId: String
        /// The member to remove from the folder.
        public let member: Sharing.MemberSelector
        /// If true, the removed user will keep their copy of the folder after it's unshared, assuming it was mounted.
        /// Otherwise, it will be removed from their Dropbox. This must be set to false when removing a group,
        /// or when the folder is within a team folder or another shared folder.
        public let leaveACopy: Bool
        public init(sharedFolderId: String, member: Sharing.MemberSelector, leaveACopy: Bool) {
            stringValidator(pattern: "[-_0-9a-zA-Z:]+")(sharedFolderId)
            self.sharedFolderId = sharedFolderId
            self.member = member
            self.leaveACopy = leaveACopy
        }

        func json() throws -> JSON {
            try RemoveFolderMemberArgSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try RemoveFolderMemberArgSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for RemoveFolderMemberArg: \(error)"
            }
        }
    }

    public class RemoveFolderMemberArgSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: RemoveFolderMemberArg) throws -> JSON {
            let output = [
                "shared_folder_id": try Serialization._StringSerializer.serialize(value.sharedFolderId),
                "member": try Sharing.MemberSelectorSerializer().serialize(value.member),
                "leave_a_copy": try Serialization._BoolSerializer.serialize(value.leaveACopy),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> RemoveFolderMemberArg {
            switch json {
            case .dictionary(let dict):
                let sharedFolderId = try Serialization._StringSerializer.deserialize(dict["shared_folder_id"] ?? .null)
                let member = try Sharing.MemberSelectorSerializer().deserialize(dict["member"] ?? .null)
                let leaveACopy = try Serialization._BoolSerializer.deserialize(dict["leave_a_copy"] ?? .null)
                return RemoveFolderMemberArg(sharedFolderId: sharedFolderId, member: member, leaveACopy: leaveACopy)
            default:
                throw JSONSerializerError.deserializeError(type: RemoveFolderMemberArg.self, json: json)
            }
        }
    }

    /// The RemoveFolderMemberError union
    public enum RemoveFolderMemberError: CustomStringConvertible, JSONRepresentable {
        /// An unspecified error.
        case accessError(Sharing.SharedFolderAccessError)
        /// An unspecified error.
        case memberError(Sharing.SharedFolderMemberError)
        /// The target user is the owner of the shared folder. You can't remove this user until ownership has been
        /// transferred to another member.
        case folderOwner
        /// The target user has access to the shared folder via a group.
        case groupAccess
        /// This action cannot be performed on a team shared folder.
        case teamFolder
        /// The current user does not have permission to perform this action.
        case noPermission
        /// This shared folder has too many files for leaving a copy. You can still remove this user without leaving a
        /// copy.
        case tooManyFiles
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try RemoveFolderMemberErrorSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try RemoveFolderMemberErrorSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for RemoveFolderMemberError: \(error)"
            }
        }
    }

    public class RemoveFolderMemberErrorSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: RemoveFolderMemberError) throws -> JSON {
            switch value {
            case .accessError(let arg):
                var d = try ["access_error": Sharing.SharedFolderAccessErrorSerializer().serialize(arg)]
                d[".tag"] = .str("access_error")
                return .dictionary(d)
            case .memberError(let arg):
                var d = try ["member_error": Sharing.SharedFolderMemberErrorSerializer().serialize(arg)]
                d[".tag"] = .str("member_error")
                return .dictionary(d)
            case .folderOwner:
                var d = [String: JSON]()
                d[".tag"] = .str("folder_owner")
                return .dictionary(d)
            case .groupAccess:
                var d = [String: JSON]()
                d[".tag"] = .str("group_access")
                return .dictionary(d)
            case .teamFolder:
                var d = [String: JSON]()
                d[".tag"] = .str("team_folder")
                return .dictionary(d)
            case .noPermission:
                var d = [String: JSON]()
                d[".tag"] = .str("no_permission")
                return .dictionary(d)
            case .tooManyFiles:
                var d = [String: JSON]()
                d[".tag"] = .str("too_many_files")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> RemoveFolderMemberError {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "access_error":
                    let v = try Sharing.SharedFolderAccessErrorSerializer().deserialize(d["access_error"] ?? .null)
                    return RemoveFolderMemberError.accessError(v)
                case "member_error":
                    let v = try Sharing.SharedFolderMemberErrorSerializer().deserialize(d["member_error"] ?? .null)
                    return RemoveFolderMemberError.memberError(v)
                case "folder_owner":
                    return RemoveFolderMemberError.folderOwner
                case "group_access":
                    return RemoveFolderMemberError.groupAccess
                case "team_folder":
                    return RemoveFolderMemberError.teamFolder
                case "no_permission":
                    return RemoveFolderMemberError.noPermission
                case "too_many_files":
                    return RemoveFolderMemberError.tooManyFiles
                case "other":
                    return RemoveFolderMemberError.other
                default:
                    return RemoveFolderMemberError.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: RemoveFolderMemberError.self, json: json)
            }
        }
    }

    /// The RemoveMemberJobStatus union
    public enum RemoveMemberJobStatus: CustomStringConvertible, JSONRepresentable {
        /// The asynchronous job is still in progress.
        case inProgress
        /// Removing the folder member has finished. The value is information about whether the member has another form
        /// of access.
        case complete(Sharing.MemberAccessLevelResult)
        /// An unspecified error.
        case failed(Sharing.RemoveFolderMemberError)

        func json() throws -> JSON {
            try RemoveMemberJobStatusSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try RemoveMemberJobStatusSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for RemoveMemberJobStatus: \(error)"
            }
        }
    }

    public class RemoveMemberJobStatusSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: RemoveMemberJobStatus) throws -> JSON {
            switch value {
            case .inProgress:
                var d = [String: JSON]()
                d[".tag"] = .str("in_progress")
                return .dictionary(d)
            case .complete(let arg):
                var d = try Serialization.getFields(Sharing.MemberAccessLevelResultSerializer().serialize(arg))
                d[".tag"] = .str("complete")
                return .dictionary(d)
            case .failed(let arg):
                var d = try ["failed": Sharing.RemoveFolderMemberErrorSerializer().serialize(arg)]
                d[".tag"] = .str("failed")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> RemoveMemberJobStatus {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "in_progress":
                    return RemoveMemberJobStatus.inProgress
                case "complete":
                    let v = try Sharing.MemberAccessLevelResultSerializer().deserialize(json)
                    return RemoveMemberJobStatus.complete(v)
                case "failed":
                    let v = try Sharing.RemoveFolderMemberErrorSerializer().deserialize(d["failed"] ?? .null)
                    return RemoveMemberJobStatus.failed(v)
                default:
                    throw JSONSerializerError.unknownTag(type: RemoveMemberJobStatus.self, json: json, tag: tag)
                }
            default:
                throw JSONSerializerError.deserializeError(type: RemoveMemberJobStatus.self, json: json)
            }
        }
    }

    /// The RequestedLinkAccessLevel union
    public enum RequestedLinkAccessLevel: CustomStringConvertible, JSONRepresentable {
        /// Users who use the link can view and comment on the content.
        case viewer
        /// Users who use the link can edit, view and comment on the content. Note not all file types support edit links
        /// yet.
        case editor
        /// Request for the maximum access level you can set the link to.
        case max
        /// Request for the default access level the user has set.
        case default_
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try RequestedLinkAccessLevelSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try RequestedLinkAccessLevelSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for RequestedLinkAccessLevel: \(error)"
            }
        }
    }

    public class RequestedLinkAccessLevelSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: RequestedLinkAccessLevel) throws -> JSON {
            switch value {
            case .viewer:
                var d = [String: JSON]()
                d[".tag"] = .str("viewer")
                return .dictionary(d)
            case .editor:
                var d = [String: JSON]()
                d[".tag"] = .str("editor")
                return .dictionary(d)
            case .max:
                var d = [String: JSON]()
                d[".tag"] = .str("max")
                return .dictionary(d)
            case .default_:
                var d = [String: JSON]()
                d[".tag"] = .str("default")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> RequestedLinkAccessLevel {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "viewer":
                    return RequestedLinkAccessLevel.viewer
                case "editor":
                    return RequestedLinkAccessLevel.editor
                case "max":
                    return RequestedLinkAccessLevel.max
                case "default":
                    return RequestedLinkAccessLevel.default_
                case "other":
                    return RequestedLinkAccessLevel.other
                default:
                    return RequestedLinkAccessLevel.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: RequestedLinkAccessLevel.self, json: json)
            }
        }
    }

    /// The RevokeSharedLinkArg struct
    public class RevokeSharedLinkArg: CustomStringConvertible, JSONRepresentable {
        /// URL of the shared link.
        public let url: String
        public init(url: String) {
            stringValidator()(url)
            self.url = url
        }

        func json() throws -> JSON {
            try RevokeSharedLinkArgSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try RevokeSharedLinkArgSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for RevokeSharedLinkArg: \(error)"
            }
        }
    }

    public class RevokeSharedLinkArgSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: RevokeSharedLinkArg) throws -> JSON {
            let output = [
                "url": try Serialization._StringSerializer.serialize(value.url),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> RevokeSharedLinkArg {
            switch json {
            case .dictionary(let dict):
                let url = try Serialization._StringSerializer.deserialize(dict["url"] ?? .null)
                return RevokeSharedLinkArg(url: url)
            default:
                throw JSONSerializerError.deserializeError(type: RevokeSharedLinkArg.self, json: json)
            }
        }
    }

    /// The RevokeSharedLinkError union
    public enum RevokeSharedLinkError: CustomStringConvertible, JSONRepresentable {
        /// The shared link wasn't found.
        case sharedLinkNotFound
        /// The caller is not allowed to access this shared link.
        case sharedLinkAccessDenied
        /// This type of link is not supported; use files instead.
        case unsupportedLinkType
        /// An unspecified error.
        case other
        /// Shared link is malformed.
        case sharedLinkMalformed

        func json() throws -> JSON {
            try RevokeSharedLinkErrorSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try RevokeSharedLinkErrorSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for RevokeSharedLinkError: \(error)"
            }
        }
    }

    public class RevokeSharedLinkErrorSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: RevokeSharedLinkError) throws -> JSON {
            switch value {
            case .sharedLinkNotFound:
                var d = [String: JSON]()
                d[".tag"] = .str("shared_link_not_found")
                return .dictionary(d)
            case .sharedLinkAccessDenied:
                var d = [String: JSON]()
                d[".tag"] = .str("shared_link_access_denied")
                return .dictionary(d)
            case .unsupportedLinkType:
                var d = [String: JSON]()
                d[".tag"] = .str("unsupported_link_type")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            case .sharedLinkMalformed:
                var d = [String: JSON]()
                d[".tag"] = .str("shared_link_malformed")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> RevokeSharedLinkError {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "shared_link_not_found":
                    return RevokeSharedLinkError.sharedLinkNotFound
                case "shared_link_access_denied":
                    return RevokeSharedLinkError.sharedLinkAccessDenied
                case "unsupported_link_type":
                    return RevokeSharedLinkError.unsupportedLinkType
                case "other":
                    return RevokeSharedLinkError.other
                case "shared_link_malformed":
                    return RevokeSharedLinkError.sharedLinkMalformed
                default:
                    throw JSONSerializerError.unknownTag(type: RevokeSharedLinkError.self, json: json, tag: tag)
                }
            default:
                throw JSONSerializerError.deserializeError(type: RevokeSharedLinkError.self, json: json)
            }
        }
    }

    /// The SetAccessInheritanceArg struct
    public class SetAccessInheritanceArg: CustomStringConvertible, JSONRepresentable {
        /// The access inheritance settings for the folder.
        public let accessInheritance: Sharing.AccessInheritance
        /// The ID for the shared folder.
        public let sharedFolderId: String
        public init(sharedFolderId: String, accessInheritance: Sharing.AccessInheritance = .inherit) {
            self.accessInheritance = accessInheritance
            stringValidator(pattern: "[-_0-9a-zA-Z:]+")(sharedFolderId)
            self.sharedFolderId = sharedFolderId
        }

        func json() throws -> JSON {
            try SetAccessInheritanceArgSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SetAccessInheritanceArgSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SetAccessInheritanceArg: \(error)"
            }
        }
    }

    public class SetAccessInheritanceArgSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SetAccessInheritanceArg) throws -> JSON {
            let output = [
                "shared_folder_id": try Serialization._StringSerializer.serialize(value.sharedFolderId),
                "access_inheritance": try Sharing.AccessInheritanceSerializer().serialize(value.accessInheritance),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SetAccessInheritanceArg {
            switch json {
            case .dictionary(let dict):
                let sharedFolderId = try Serialization._StringSerializer.deserialize(dict["shared_folder_id"] ?? .null)
                let accessInheritance = try Sharing.AccessInheritanceSerializer()
                    .deserialize(dict["access_inheritance"] ?? Sharing.AccessInheritanceSerializer().serialize(.inherit))
                return SetAccessInheritanceArg(sharedFolderId: sharedFolderId, accessInheritance: accessInheritance)
            default:
                throw JSONSerializerError.deserializeError(type: SetAccessInheritanceArg.self, json: json)
            }
        }
    }

    /// The SetAccessInheritanceError union
    public enum SetAccessInheritanceError: CustomStringConvertible, JSONRepresentable {
        /// Unable to access shared folder.
        case accessError(Sharing.SharedFolderAccessError)
        /// The current user does not have permission to perform this action.
        case noPermission
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try SetAccessInheritanceErrorSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SetAccessInheritanceErrorSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SetAccessInheritanceError: \(error)"
            }
        }
    }

    public class SetAccessInheritanceErrorSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SetAccessInheritanceError) throws -> JSON {
            switch value {
            case .accessError(let arg):
                var d = try ["access_error": Sharing.SharedFolderAccessErrorSerializer().serialize(arg)]
                d[".tag"] = .str("access_error")
                return .dictionary(d)
            case .noPermission:
                var d = [String: JSON]()
                d[".tag"] = .str("no_permission")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> SetAccessInheritanceError {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "access_error":
                    let v = try Sharing.SharedFolderAccessErrorSerializer().deserialize(d["access_error"] ?? .null)
                    return SetAccessInheritanceError.accessError(v)
                case "no_permission":
                    return SetAccessInheritanceError.noPermission
                case "other":
                    return SetAccessInheritanceError.other
                default:
                    return SetAccessInheritanceError.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: SetAccessInheritanceError.self, json: json)
            }
        }
    }

    /// The ShareFolderArgBase struct
    public class ShareFolderArgBase: CustomStringConvertible, JSONRepresentable {
        /// Who can add and remove members of this shared folder.
        public let aclUpdatePolicy: Sharing.AclUpdatePolicy?
        /// Whether to force the share to happen asynchronously.
        public let forceAsync: Bool
        /// Who can be a member of this shared folder. Only applicable if the current user is on a team.
        public let memberPolicy: Sharing.MemberPolicy?
        /// The path or the file id to the folder to share. If it does not exist, then a new one is created.
        public let path: String
        /// The policy to apply to shared links created for content inside this shared folder.  The current user must be
        /// on a team to set this policy to members in SharedLinkPolicy.
        public let sharedLinkPolicy: Sharing.SharedLinkPolicy?
        /// Who can enable/disable viewer info for this shared folder.
        public let viewerInfoPolicy: Sharing.ViewerInfoPolicy?
        /// The access inheritance settings for the folder.
        public let accessInheritance: Sharing.AccessInheritance
        public init(
            path: String,
            aclUpdatePolicy: Sharing.AclUpdatePolicy? = nil,
            forceAsync: Bool = false,
            memberPolicy: Sharing.MemberPolicy? = nil,
            sharedLinkPolicy: Sharing.SharedLinkPolicy? = nil,
            viewerInfoPolicy: Sharing.ViewerInfoPolicy? = nil,
            accessInheritance: Sharing.AccessInheritance = .inherit
        ) {
            self.aclUpdatePolicy = aclUpdatePolicy
            self.forceAsync = forceAsync
            self.memberPolicy = memberPolicy
            stringValidator(pattern: "(/(.|[\\r\\n])*)|(ns:[0-9]+(/.*)?)|(id:.*)")(path)
            self.path = path
            self.sharedLinkPolicy = sharedLinkPolicy
            self.viewerInfoPolicy = viewerInfoPolicy
            self.accessInheritance = accessInheritance
        }

        func json() throws -> JSON {
            try ShareFolderArgBaseSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ShareFolderArgBaseSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ShareFolderArgBase: \(error)"
            }
        }
    }

    public class ShareFolderArgBaseSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ShareFolderArgBase) throws -> JSON {
            let output = [
                "path": try Serialization._StringSerializer.serialize(value.path),
                "acl_update_policy": try NullableSerializer(Sharing.AclUpdatePolicySerializer()).serialize(value.aclUpdatePolicy),
                "force_async": try Serialization._BoolSerializer.serialize(value.forceAsync),
                "member_policy": try NullableSerializer(Sharing.MemberPolicySerializer()).serialize(value.memberPolicy),
                "shared_link_policy": try NullableSerializer(Sharing.SharedLinkPolicySerializer()).serialize(value.sharedLinkPolicy),
                "viewer_info_policy": try NullableSerializer(Sharing.ViewerInfoPolicySerializer()).serialize(value.viewerInfoPolicy),
                "access_inheritance": try Sharing.AccessInheritanceSerializer().serialize(value.accessInheritance),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ShareFolderArgBase {
            switch json {
            case .dictionary(let dict):
                let path = try Serialization._StringSerializer.deserialize(dict["path"] ?? .null)
                let aclUpdatePolicy = try NullableSerializer(Sharing.AclUpdatePolicySerializer()).deserialize(dict["acl_update_policy"] ?? .null)
                let forceAsync = try Serialization._BoolSerializer.deserialize(dict["force_async"] ?? .number(0))
                let memberPolicy = try NullableSerializer(Sharing.MemberPolicySerializer()).deserialize(dict["member_policy"] ?? .null)
                let sharedLinkPolicy = try NullableSerializer(Sharing.SharedLinkPolicySerializer()).deserialize(dict["shared_link_policy"] ?? .null)
                let viewerInfoPolicy = try NullableSerializer(Sharing.ViewerInfoPolicySerializer()).deserialize(dict["viewer_info_policy"] ?? .null)
                let accessInheritance = try Sharing.AccessInheritanceSerializer()
                    .deserialize(dict["access_inheritance"] ?? Sharing.AccessInheritanceSerializer().serialize(.inherit))
                return ShareFolderArgBase(
                    path: path,
                    aclUpdatePolicy: aclUpdatePolicy,
                    forceAsync: forceAsync,
                    memberPolicy: memberPolicy,
                    sharedLinkPolicy: sharedLinkPolicy,
                    viewerInfoPolicy: viewerInfoPolicy,
                    accessInheritance: accessInheritance
                )
            default:
                throw JSONSerializerError.deserializeError(type: ShareFolderArgBase.self, json: json)
            }
        }
    }

    /// The ShareFolderArg struct
    public class ShareFolderArg: Sharing.ShareFolderArgBase {
        /// A list of `FolderAction`s corresponding to `FolderPermission`s that should appear in the  response's
        /// permissions in SharedFolderMetadata field describing the actions the  authenticated user can perform
        /// on the folder.
        public let actions: [Sharing.FolderAction]?
        /// Settings on the link for this folder.
        public let linkSettings: Sharing.LinkSettings?
        public init(
            path: String,
            aclUpdatePolicy: Sharing.AclUpdatePolicy? = nil,
            forceAsync: Bool = false,
            memberPolicy: Sharing.MemberPolicy? = nil,
            sharedLinkPolicy: Sharing.SharedLinkPolicy? = nil,
            viewerInfoPolicy: Sharing.ViewerInfoPolicy? = nil,
            accessInheritance: Sharing.AccessInheritance = .inherit,
            actions: [Sharing.FolderAction]? = nil,
            linkSettings: Sharing.LinkSettings? = nil
        ) {
            self.actions = actions
            self.linkSettings = linkSettings
            super.init(
                path: path,
                aclUpdatePolicy: aclUpdatePolicy,
                forceAsync: forceAsync,
                memberPolicy: memberPolicy,
                sharedLinkPolicy: sharedLinkPolicy,
                viewerInfoPolicy: viewerInfoPolicy,
                accessInheritance: accessInheritance
            )
        }

        public override var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ShareFolderArgSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ShareFolderArg: \(error)"
            }
        }
    }

    public class ShareFolderArgSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ShareFolderArg) throws -> JSON {
            let output = [
                "path": try Serialization._StringSerializer.serialize(value.path),
                "acl_update_policy": try NullableSerializer(Sharing.AclUpdatePolicySerializer()).serialize(value.aclUpdatePolicy),
                "force_async": try Serialization._BoolSerializer.serialize(value.forceAsync),
                "member_policy": try NullableSerializer(Sharing.MemberPolicySerializer()).serialize(value.memberPolicy),
                "shared_link_policy": try NullableSerializer(Sharing.SharedLinkPolicySerializer()).serialize(value.sharedLinkPolicy),
                "viewer_info_policy": try NullableSerializer(Sharing.ViewerInfoPolicySerializer()).serialize(value.viewerInfoPolicy),
                "access_inheritance": try Sharing.AccessInheritanceSerializer().serialize(value.accessInheritance),
                "actions": try NullableSerializer(ArraySerializer(Sharing.FolderActionSerializer())).serialize(value.actions),
                "link_settings": try NullableSerializer(Sharing.LinkSettingsSerializer()).serialize(value.linkSettings),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> ShareFolderArg {
            switch json {
            case .dictionary(let dict):
                let path = try Serialization._StringSerializer.deserialize(dict["path"] ?? .null)
                let aclUpdatePolicy = try NullableSerializer(Sharing.AclUpdatePolicySerializer()).deserialize(dict["acl_update_policy"] ?? .null)
                let forceAsync = try Serialization._BoolSerializer.deserialize(dict["force_async"] ?? .number(0))
                let memberPolicy = try NullableSerializer(Sharing.MemberPolicySerializer()).deserialize(dict["member_policy"] ?? .null)
                let sharedLinkPolicy = try NullableSerializer(Sharing.SharedLinkPolicySerializer()).deserialize(dict["shared_link_policy"] ?? .null)
                let viewerInfoPolicy = try NullableSerializer(Sharing.ViewerInfoPolicySerializer()).deserialize(dict["viewer_info_policy"] ?? .null)
                let accessInheritance = try Sharing.AccessInheritanceSerializer()
                    .deserialize(dict["access_inheritance"] ?? Sharing.AccessInheritanceSerializer().serialize(.inherit))
                let actions = try NullableSerializer(ArraySerializer(Sharing.FolderActionSerializer())).deserialize(dict["actions"] ?? .null)
                let linkSettings = try NullableSerializer(Sharing.LinkSettingsSerializer()).deserialize(dict["link_settings"] ?? .null)
                return ShareFolderArg(
                    path: path,
                    aclUpdatePolicy: aclUpdatePolicy,
                    forceAsync: forceAsync,
                    memberPolicy: memberPolicy,
                    sharedLinkPolicy: sharedLinkPolicy,
                    viewerInfoPolicy: viewerInfoPolicy,
                    accessInheritance: accessInheritance,
                    actions: actions,
                    linkSettings: linkSettings
                )
            default:
                throw JSONSerializerError.deserializeError(type: ShareFolderArg.self, json: json)
            }
        }
    }

    /// The ShareFolderErrorBase union
    public enum ShareFolderErrorBase: CustomStringConvertible, JSONRepresentable {
        /// This user's email address is not verified. This functionality is only available on accounts with a verified
        /// email address. Users can verify their email address here https://www.dropbox.com/help/317.
        case emailUnverified
        /// path in ShareFolderArg is invalid.
        case badPath(Sharing.SharePathError)
        /// Team policy is more restrictive than memberPolicy in ShareFolderArg.
        case teamPolicyDisallowsMemberPolicy
        /// The current user's account is not allowed to select the specified sharedLinkPolicy in ShareFolderArg.
        case disallowedSharedLinkPolicy
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try ShareFolderErrorBaseSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ShareFolderErrorBaseSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ShareFolderErrorBase: \(error)"
            }
        }
    }

    public class ShareFolderErrorBaseSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ShareFolderErrorBase) throws -> JSON {
            switch value {
            case .emailUnverified:
                var d = [String: JSON]()
                d[".tag"] = .str("email_unverified")
                return .dictionary(d)
            case .badPath(let arg):
                var d = try ["bad_path": Sharing.SharePathErrorSerializer().serialize(arg)]
                d[".tag"] = .str("bad_path")
                return .dictionary(d)
            case .teamPolicyDisallowsMemberPolicy:
                var d = [String: JSON]()
                d[".tag"] = .str("team_policy_disallows_member_policy")
                return .dictionary(d)
            case .disallowedSharedLinkPolicy:
                var d = [String: JSON]()
                d[".tag"] = .str("disallowed_shared_link_policy")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> ShareFolderErrorBase {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "email_unverified":
                    return ShareFolderErrorBase.emailUnverified
                case "bad_path":
                    let v = try Sharing.SharePathErrorSerializer().deserialize(d["bad_path"] ?? .null)
                    return ShareFolderErrorBase.badPath(v)
                case "team_policy_disallows_member_policy":
                    return ShareFolderErrorBase.teamPolicyDisallowsMemberPolicy
                case "disallowed_shared_link_policy":
                    return ShareFolderErrorBase.disallowedSharedLinkPolicy
                case "other":
                    return ShareFolderErrorBase.other
                default:
                    return ShareFolderErrorBase.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: ShareFolderErrorBase.self, json: json)
            }
        }
    }

    /// The ShareFolderError union
    public enum ShareFolderError: CustomStringConvertible, JSONRepresentable {
        /// This user's email address is not verified. This functionality is only available on accounts with a verified
        /// email address. Users can verify their email address here https://www.dropbox.com/help/317.
        case emailUnverified
        /// path in ShareFolderArg is invalid.
        case badPath(Sharing.SharePathError)
        /// Team policy is more restrictive than memberPolicy in ShareFolderArg.
        case teamPolicyDisallowsMemberPolicy
        /// The current user's account is not allowed to select the specified sharedLinkPolicy in ShareFolderArg.
        case disallowedSharedLinkPolicy
        /// An unspecified error.
        case other
        /// The current user does not have permission to perform this action.
        case noPermission

        func json() throws -> JSON {
            try ShareFolderErrorSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ShareFolderErrorSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ShareFolderError: \(error)"
            }
        }
    }

    public class ShareFolderErrorSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ShareFolderError) throws -> JSON {
            switch value {
            case .emailUnverified:
                var d = [String: JSON]()
                d[".tag"] = .str("email_unverified")
                return .dictionary(d)
            case .badPath(let arg):
                var d = try ["bad_path": Sharing.SharePathErrorSerializer().serialize(arg)]
                d[".tag"] = .str("bad_path")
                return .dictionary(d)
            case .teamPolicyDisallowsMemberPolicy:
                var d = [String: JSON]()
                d[".tag"] = .str("team_policy_disallows_member_policy")
                return .dictionary(d)
            case .disallowedSharedLinkPolicy:
                var d = [String: JSON]()
                d[".tag"] = .str("disallowed_shared_link_policy")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            case .noPermission:
                var d = [String: JSON]()
                d[".tag"] = .str("no_permission")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> ShareFolderError {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "email_unverified":
                    return ShareFolderError.emailUnverified
                case "bad_path":
                    let v = try Sharing.SharePathErrorSerializer().deserialize(d["bad_path"] ?? .null)
                    return ShareFolderError.badPath(v)
                case "team_policy_disallows_member_policy":
                    return ShareFolderError.teamPolicyDisallowsMemberPolicy
                case "disallowed_shared_link_policy":
                    return ShareFolderError.disallowedSharedLinkPolicy
                case "other":
                    return ShareFolderError.other
                case "no_permission":
                    return ShareFolderError.noPermission
                default:
                    throw JSONSerializerError.unknownTag(type: ShareFolderError.self, json: json, tag: tag)
                }
            default:
                throw JSONSerializerError.deserializeError(type: ShareFolderError.self, json: json)
            }
        }
    }

    /// The ShareFolderJobStatus union
    public enum ShareFolderJobStatus: CustomStringConvertible, JSONRepresentable {
        /// The asynchronous job is still in progress.
        case inProgress
        /// The share job has finished. The value is the metadata for the folder.
        case complete(Sharing.SharedFolderMetadata)
        /// An unspecified error.
        case failed(Sharing.ShareFolderError)

        func json() throws -> JSON {
            try ShareFolderJobStatusSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ShareFolderJobStatusSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ShareFolderJobStatus: \(error)"
            }
        }
    }

    public class ShareFolderJobStatusSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ShareFolderJobStatus) throws -> JSON {
            switch value {
            case .inProgress:
                var d = [String: JSON]()
                d[".tag"] = .str("in_progress")
                return .dictionary(d)
            case .complete(let arg):
                var d = try Serialization.getFields(Sharing.SharedFolderMetadataSerializer().serialize(arg))
                d[".tag"] = .str("complete")
                return .dictionary(d)
            case .failed(let arg):
                var d = try ["failed": Sharing.ShareFolderErrorSerializer().serialize(arg)]
                d[".tag"] = .str("failed")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> ShareFolderJobStatus {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "in_progress":
                    return ShareFolderJobStatus.inProgress
                case "complete":
                    let v = try Sharing.SharedFolderMetadataSerializer().deserialize(json)
                    return ShareFolderJobStatus.complete(v)
                case "failed":
                    let v = try Sharing.ShareFolderErrorSerializer().deserialize(d["failed"] ?? .null)
                    return ShareFolderJobStatus.failed(v)
                default:
                    throw JSONSerializerError.unknownTag(type: ShareFolderJobStatus.self, json: json, tag: tag)
                }
            default:
                throw JSONSerializerError.deserializeError(type: ShareFolderJobStatus.self, json: json)
            }
        }
    }

    /// The ShareFolderLaunch union
    public enum ShareFolderLaunch: CustomStringConvertible, JSONRepresentable {
        /// This response indicates that the processing is asynchronous. The string is an id that can be used to obtain
        /// the status of the asynchronous job.
        case asyncJobId(String)
        /// An unspecified error.
        case complete(Sharing.SharedFolderMetadata)

        func json() throws -> JSON {
            try ShareFolderLaunchSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ShareFolderLaunchSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ShareFolderLaunch: \(error)"
            }
        }
    }

    public class ShareFolderLaunchSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ShareFolderLaunch) throws -> JSON {
            switch value {
            case .asyncJobId(let arg):
                var d = try ["async_job_id": Serialization._StringSerializer.serialize(arg)]
                d[".tag"] = .str("async_job_id")
                return .dictionary(d)
            case .complete(let arg):
                var d = try Serialization.getFields(Sharing.SharedFolderMetadataSerializer().serialize(arg))
                d[".tag"] = .str("complete")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> ShareFolderLaunch {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "async_job_id":
                    let v = try Serialization._StringSerializer.deserialize(d["async_job_id"] ?? .null)
                    return ShareFolderLaunch.asyncJobId(v)
                case "complete":
                    let v = try Sharing.SharedFolderMetadataSerializer().deserialize(json)
                    return ShareFolderLaunch.complete(v)
                default:
                    throw JSONSerializerError.unknownTag(type: ShareFolderLaunch.self, json: json, tag: tag)
                }
            default:
                throw JSONSerializerError.deserializeError(type: ShareFolderLaunch.self, json: json)
            }
        }
    }

    /// The SharePathError union
    public enum SharePathError: CustomStringConvertible, JSONRepresentable {
        /// A file is at the specified path.
        case isFile
        /// We do not support sharing a folder inside a shared folder.
        case insideSharedFolder
        /// We do not support shared folders that contain shared folders.
        case containsSharedFolder
        /// We do not support shared folders that contain app folders.
        case containsAppFolder
        /// We do not support shared folders that contain team folders.
        case containsTeamFolder
        /// We do not support sharing an app folder.
        case isAppFolder
        /// We do not support sharing a folder inside an app folder.
        case insideAppFolder
        /// A public folder can't be shared this way. Use a public link instead.
        case isPublicFolder
        /// A folder inside a public folder can't be shared this way. Use a public link instead.
        case insidePublicFolder
        /// Folder is already shared. Contains metadata about the existing shared folder.
        case alreadyShared(Sharing.SharedFolderMetadata)
        /// Path is not valid.
        case invalidPath
        /// We do not support sharing a Mac OS X package.
        case isOsxPackage
        /// We do not support sharing a folder inside a Mac OS X package.
        case insideOsxPackage
        /// We do not support sharing the Vault folder.
        case isVault
        /// We do not support sharing a folder inside a locked Vault.
        case isVaultLocked
        /// We do not support sharing the Family folder.
        case isFamily
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try SharePathErrorSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharePathErrorSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharePathError: \(error)"
            }
        }
    }

    public class SharePathErrorSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharePathError) throws -> JSON {
            switch value {
            case .isFile:
                var d = [String: JSON]()
                d[".tag"] = .str("is_file")
                return .dictionary(d)
            case .insideSharedFolder:
                var d = [String: JSON]()
                d[".tag"] = .str("inside_shared_folder")
                return .dictionary(d)
            case .containsSharedFolder:
                var d = [String: JSON]()
                d[".tag"] = .str("contains_shared_folder")
                return .dictionary(d)
            case .containsAppFolder:
                var d = [String: JSON]()
                d[".tag"] = .str("contains_app_folder")
                return .dictionary(d)
            case .containsTeamFolder:
                var d = [String: JSON]()
                d[".tag"] = .str("contains_team_folder")
                return .dictionary(d)
            case .isAppFolder:
                var d = [String: JSON]()
                d[".tag"] = .str("is_app_folder")
                return .dictionary(d)
            case .insideAppFolder:
                var d = [String: JSON]()
                d[".tag"] = .str("inside_app_folder")
                return .dictionary(d)
            case .isPublicFolder:
                var d = [String: JSON]()
                d[".tag"] = .str("is_public_folder")
                return .dictionary(d)
            case .insidePublicFolder:
                var d = [String: JSON]()
                d[".tag"] = .str("inside_public_folder")
                return .dictionary(d)
            case .alreadyShared(let arg):
                var d = try Serialization.getFields(Sharing.SharedFolderMetadataSerializer().serialize(arg))
                d[".tag"] = .str("already_shared")
                return .dictionary(d)
            case .invalidPath:
                var d = [String: JSON]()
                d[".tag"] = .str("invalid_path")
                return .dictionary(d)
            case .isOsxPackage:
                var d = [String: JSON]()
                d[".tag"] = .str("is_osx_package")
                return .dictionary(d)
            case .insideOsxPackage:
                var d = [String: JSON]()
                d[".tag"] = .str("inside_osx_package")
                return .dictionary(d)
            case .isVault:
                var d = [String: JSON]()
                d[".tag"] = .str("is_vault")
                return .dictionary(d)
            case .isVaultLocked:
                var d = [String: JSON]()
                d[".tag"] = .str("is_vault_locked")
                return .dictionary(d)
            case .isFamily:
                var d = [String: JSON]()
                d[".tag"] = .str("is_family")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> SharePathError {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "is_file":
                    return SharePathError.isFile
                case "inside_shared_folder":
                    return SharePathError.insideSharedFolder
                case "contains_shared_folder":
                    return SharePathError.containsSharedFolder
                case "contains_app_folder":
                    return SharePathError.containsAppFolder
                case "contains_team_folder":
                    return SharePathError.containsTeamFolder
                case "is_app_folder":
                    return SharePathError.isAppFolder
                case "inside_app_folder":
                    return SharePathError.insideAppFolder
                case "is_public_folder":
                    return SharePathError.isPublicFolder
                case "inside_public_folder":
                    return SharePathError.insidePublicFolder
                case "already_shared":
                    let v = try Sharing.SharedFolderMetadataSerializer().deserialize(json)
                    return SharePathError.alreadyShared(v)
                case "invalid_path":
                    return SharePathError.invalidPath
                case "is_osx_package":
                    return SharePathError.isOsxPackage
                case "inside_osx_package":
                    return SharePathError.insideOsxPackage
                case "is_vault":
                    return SharePathError.isVault
                case "is_vault_locked":
                    return SharePathError.isVaultLocked
                case "is_family":
                    return SharePathError.isFamily
                case "other":
                    return SharePathError.other
                default:
                    return SharePathError.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: SharePathError.self, json: json)
            }
        }
    }

    /// Metadata of a shared link for a file or folder.
    public class SharedContentLinkMetadata: Sharing.SharedContentLinkMetadataBase {
        /// The content inside this folder with link audience different than this folder's. This is only returned when
        /// an endpoint that returns metadata for a single shared folder is called, e.g. /get_folder_metadata.
        public let audienceExceptions: Sharing.AudienceExceptions?
        /// The URL of the link.
        public let url: String
        public init(
            audienceOptions: [Sharing.LinkAudience],
            currentAudience: Sharing.LinkAudience,
            linkPermissions: [Sharing.LinkPermission],
            passwordProtected: Bool,
            url: String,
            accessLevel: Sharing.AccessLevel? = nil,
            audienceRestrictingSharedFolder: Sharing.AudienceRestrictingSharedFolder? = nil,
            expiry: Date? = nil,
            audienceExceptions: Sharing.AudienceExceptions? = nil
        ) {
            self.audienceExceptions = audienceExceptions
            stringValidator()(url)
            self.url = url
            super.init(
                audienceOptions: audienceOptions,
                currentAudience: currentAudience,
                linkPermissions: linkPermissions,
                passwordProtected: passwordProtected,
                accessLevel: accessLevel,
                audienceRestrictingSharedFolder: audienceRestrictingSharedFolder,
                expiry: expiry
            )
        }

        public override var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharedContentLinkMetadataSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharedContentLinkMetadata: \(error)"
            }
        }
    }

    public class SharedContentLinkMetadataSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharedContentLinkMetadata) throws -> JSON {
            let output = [
                "audience_options": try ArraySerializer(Sharing.LinkAudienceSerializer()).serialize(value.audienceOptions),
                "current_audience": try Sharing.LinkAudienceSerializer().serialize(value.currentAudience),
                "link_permissions": try ArraySerializer(Sharing.LinkPermissionSerializer()).serialize(value.linkPermissions),
                "password_protected": try Serialization._BoolSerializer.serialize(value.passwordProtected),
                "url": try Serialization._StringSerializer.serialize(value.url),
                "access_level": try NullableSerializer(Sharing.AccessLevelSerializer()).serialize(value.accessLevel),
                "audience_restricting_shared_folder": try NullableSerializer(Sharing.AudienceRestrictingSharedFolderSerializer())
                    .serialize(value.audienceRestrictingSharedFolder),
                "expiry": try NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.expiry),
                "audience_exceptions": try NullableSerializer(Sharing.AudienceExceptionsSerializer()).serialize(value.audienceExceptions),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharedContentLinkMetadata {
            switch json {
            case .dictionary(let dict):
                let audienceOptions = try ArraySerializer(Sharing.LinkAudienceSerializer()).deserialize(dict["audience_options"] ?? .null)
                let currentAudience = try Sharing.LinkAudienceSerializer().deserialize(dict["current_audience"] ?? .null)
                let linkPermissions = try ArraySerializer(Sharing.LinkPermissionSerializer()).deserialize(dict["link_permissions"] ?? .null)
                let passwordProtected = try Serialization._BoolSerializer.deserialize(dict["password_protected"] ?? .null)
                let url = try Serialization._StringSerializer.deserialize(dict["url"] ?? .null)
                let accessLevel = try NullableSerializer(Sharing.AccessLevelSerializer()).deserialize(dict["access_level"] ?? .null)
                let audienceRestrictingSharedFolder = try NullableSerializer(Sharing.AudienceRestrictingSharedFolderSerializer())
                    .deserialize(dict["audience_restricting_shared_folder"] ?? .null)
                let expiry = try NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).deserialize(dict["expiry"] ?? .null)
                let audienceExceptions = try NullableSerializer(Sharing.AudienceExceptionsSerializer()).deserialize(dict["audience_exceptions"] ?? .null)
                return SharedContentLinkMetadata(
                    audienceOptions: audienceOptions,
                    currentAudience: currentAudience,
                    linkPermissions: linkPermissions,
                    passwordProtected: passwordProtected,
                    url: url,
                    accessLevel: accessLevel,
                    audienceRestrictingSharedFolder: audienceRestrictingSharedFolder,
                    expiry: expiry,
                    audienceExceptions: audienceExceptions
                )
            default:
                throw JSONSerializerError.deserializeError(type: SharedContentLinkMetadata.self, json: json)
            }
        }
    }

    /// Shared file user, group, and invitee membership. Used for the results of listFileMembers and
    /// listFileMembersContinue, and used as part of the results for listFileMembersBatch.
    public class SharedFileMembers: CustomStringConvertible, JSONRepresentable {
        /// The list of user members of the shared file.
        public let users: [Sharing.UserFileMembershipInfo]
        /// The list of group members of the shared file.
        public let groups: [Sharing.GroupMembershipInfo]
        /// The list of invited members of a file, but have not logged in and claimed this.
        public let invitees: [Sharing.InviteeMembershipInfo]
        /// Present if there are additional shared file members that have not been returned yet. Pass the cursor into
        /// listFileMembersContinue to list additional members.
        public let cursor: String?
        public init(
            users: [Sharing.UserFileMembershipInfo],
            groups: [Sharing.GroupMembershipInfo],
            invitees: [Sharing.InviteeMembershipInfo],
            cursor: String? = nil
        ) {
            self.users = users
            self.groups = groups
            self.invitees = invitees
            nullableValidator(stringValidator())(cursor)
            self.cursor = cursor
        }

        func json() throws -> JSON {
            try SharedFileMembersSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharedFileMembersSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharedFileMembers: \(error)"
            }
        }
    }

    public class SharedFileMembersSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharedFileMembers) throws -> JSON {
            let output = [
                "users": try ArraySerializer(Sharing.UserFileMembershipInfoSerializer()).serialize(value.users),
                "groups": try ArraySerializer(Sharing.GroupMembershipInfoSerializer()).serialize(value.groups),
                "invitees": try ArraySerializer(Sharing.InviteeMembershipInfoSerializer()).serialize(value.invitees),
                "cursor": try NullableSerializer(Serialization._StringSerializer).serialize(value.cursor),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharedFileMembers {
            switch json {
            case .dictionary(let dict):
                let users = try ArraySerializer(Sharing.UserFileMembershipInfoSerializer()).deserialize(dict["users"] ?? .null)
                let groups = try ArraySerializer(Sharing.GroupMembershipInfoSerializer()).deserialize(dict["groups"] ?? .null)
                let invitees = try ArraySerializer(Sharing.InviteeMembershipInfoSerializer()).deserialize(dict["invitees"] ?? .null)
                let cursor = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["cursor"] ?? .null)
                return SharedFileMembers(users: users, groups: groups, invitees: invitees, cursor: cursor)
            default:
                throw JSONSerializerError.deserializeError(type: SharedFileMembers.self, json: json)
            }
        }
    }

    /// Properties of the shared file.
    public class SharedFileMetadata: CustomStringConvertible, JSONRepresentable {
        /// The current user's access level for this shared file.
        public let accessType: Sharing.AccessLevel?
        /// The ID of the file.
        public let id: String
        /// The expected metadata of the link associated for the file when it is first shared. Absent if the link
        /// already exists. This is for an unreleased feature so it may not be returned yet.
        public let expectedLinkMetadata: Sharing.ExpectedSharedContentLinkMetadata?
        /// The metadata of the link associated for the file. This is for an unreleased feature so it may not be
        /// returned yet.
        public let linkMetadata: Sharing.SharedContentLinkMetadata?
        /// The name of this file.
        public let name: String
        /// The display names of the users that own the file. If the file is part of a team folder, the display names of
        /// the team admins are also included. Absent if the owner display names cannot be fetched.
        public let ownerDisplayNames: [String]?
        /// The team that owns the file. This field is not present if the file is not owned by a team.
        public let ownerTeam: Users.Team?
        /// The ID of the parent shared folder. This field is present only if the file is contained within a shared
        /// folder.
        public let parentSharedFolderId: String?
        /// The cased path to be used for display purposes only. In rare instances the casing will not correctly match
        /// the user's filesystem, but this behavior will match the path provided in the Core API v1. Absent for
        /// unmounted files.
        public let pathDisplay: String?
        /// The lower-case full path of this file. Absent for unmounted files.
        public let pathLower: String?
        /// The sharing permissions that requesting user has on this file. This corresponds to the entries given in
        /// actions in GetFileMetadataBatchArg or actions in GetFileMetadataArg.
        public let permissions: [Sharing.FilePermission]?
        /// Policies governing this shared file.
        public let policy: Sharing.FolderPolicy
        /// URL for displaying a web preview of the shared file.
        public let previewUrl: String
        /// Timestamp indicating when the current user was invited to this shared file. If the user was not invited to
        /// the shared file, the timestamp will indicate when the user was invited to the parent shared folder.
        /// This value may be absent.
        public let timeInvited: Date?
        public init(
            id: String,
            name: String,
            policy: Sharing.FolderPolicy,
            previewUrl: String,
            accessType: Sharing.AccessLevel? = nil,
            expectedLinkMetadata: Sharing.ExpectedSharedContentLinkMetadata? = nil,
            linkMetadata: Sharing.SharedContentLinkMetadata? = nil,
            ownerDisplayNames: [String]? = nil,
            ownerTeam: Users.Team? = nil,
            parentSharedFolderId: String? = nil,
            pathDisplay: String? = nil,
            pathLower: String? = nil,
            permissions: [Sharing.FilePermission]? = nil,
            timeInvited: Date? = nil
        ) {
            self.accessType = accessType
            stringValidator(minLength: 4, pattern: "id:.+")(id)
            self.id = id
            self.expectedLinkMetadata = expectedLinkMetadata
            self.linkMetadata = linkMetadata
            stringValidator()(name)
            self.name = name
            nullableValidator(arrayValidator(itemValidator: stringValidator()))(ownerDisplayNames)
            self.ownerDisplayNames = ownerDisplayNames
            self.ownerTeam = ownerTeam
            nullableValidator(stringValidator(pattern: "[-_0-9a-zA-Z:]+"))(parentSharedFolderId)
            self.parentSharedFolderId = parentSharedFolderId
            nullableValidator(stringValidator())(pathDisplay)
            self.pathDisplay = pathDisplay
            nullableValidator(stringValidator())(pathLower)
            self.pathLower = pathLower
            self.permissions = permissions
            self.policy = policy
            stringValidator()(previewUrl)
            self.previewUrl = previewUrl
            self.timeInvited = timeInvited
        }

        func json() throws -> JSON {
            try SharedFileMetadataSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharedFileMetadataSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharedFileMetadata: \(error)"
            }
        }
    }

    public class SharedFileMetadataSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharedFileMetadata) throws -> JSON {
            let output = [
                "id": try Serialization._StringSerializer.serialize(value.id),
                "name": try Serialization._StringSerializer.serialize(value.name),
                "policy": try Sharing.FolderPolicySerializer().serialize(value.policy),
                "preview_url": try Serialization._StringSerializer.serialize(value.previewUrl),
                "access_type": try NullableSerializer(Sharing.AccessLevelSerializer()).serialize(value.accessType),
                "expected_link_metadata": try NullableSerializer(Sharing.ExpectedSharedContentLinkMetadataSerializer()).serialize(value.expectedLinkMetadata),
                "link_metadata": try NullableSerializer(Sharing.SharedContentLinkMetadataSerializer()).serialize(value.linkMetadata),
                "owner_display_names": try NullableSerializer(ArraySerializer(Serialization._StringSerializer)).serialize(value.ownerDisplayNames),
                "owner_team": try NullableSerializer(Users.TeamSerializer()).serialize(value.ownerTeam),
                "parent_shared_folder_id": try NullableSerializer(Serialization._StringSerializer).serialize(value.parentSharedFolderId),
                "path_display": try NullableSerializer(Serialization._StringSerializer).serialize(value.pathDisplay),
                "path_lower": try NullableSerializer(Serialization._StringSerializer).serialize(value.pathLower),
                "permissions": try NullableSerializer(ArraySerializer(Sharing.FilePermissionSerializer())).serialize(value.permissions),
                "time_invited": try NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.timeInvited),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharedFileMetadata {
            switch json {
            case .dictionary(let dict):
                let id = try Serialization._StringSerializer.deserialize(dict["id"] ?? .null)
                let name = try Serialization._StringSerializer.deserialize(dict["name"] ?? .null)
                let policy = try Sharing.FolderPolicySerializer().deserialize(dict["policy"] ?? .null)
                let previewUrl = try Serialization._StringSerializer.deserialize(dict["preview_url"] ?? .null)
                let accessType = try NullableSerializer(Sharing.AccessLevelSerializer()).deserialize(dict["access_type"] ?? .null)
                let expectedLinkMetadata = try NullableSerializer(Sharing.ExpectedSharedContentLinkMetadataSerializer())
                    .deserialize(dict["expected_link_metadata"] ?? .null)
                let linkMetadata = try NullableSerializer(Sharing.SharedContentLinkMetadataSerializer()).deserialize(dict["link_metadata"] ?? .null)
                let ownerDisplayNames = try NullableSerializer(ArraySerializer(Serialization._StringSerializer))
                    .deserialize(dict["owner_display_names"] ?? .null)
                let ownerTeam = try NullableSerializer(Users.TeamSerializer()).deserialize(dict["owner_team"] ?? .null)
                let parentSharedFolderId = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["parent_shared_folder_id"] ?? .null)
                let pathDisplay = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["path_display"] ?? .null)
                let pathLower = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["path_lower"] ?? .null)
                let permissions = try NullableSerializer(ArraySerializer(Sharing.FilePermissionSerializer())).deserialize(dict["permissions"] ?? .null)
                let timeInvited = try NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).deserialize(dict["time_invited"] ?? .null)
                return SharedFileMetadata(
                    id: id,
                    name: name,
                    policy: policy,
                    previewUrl: previewUrl,
                    accessType: accessType,
                    expectedLinkMetadata: expectedLinkMetadata,
                    linkMetadata: linkMetadata,
                    ownerDisplayNames: ownerDisplayNames,
                    ownerTeam: ownerTeam,
                    parentSharedFolderId: parentSharedFolderId,
                    pathDisplay: pathDisplay,
                    pathLower: pathLower,
                    permissions: permissions,
                    timeInvited: timeInvited
                )
            default:
                throw JSONSerializerError.deserializeError(type: SharedFileMetadata.self, json: json)
            }
        }
    }

    /// There is an error accessing the shared folder.
    public enum SharedFolderAccessError: CustomStringConvertible, JSONRepresentable {
        /// This shared folder ID is invalid.
        case invalidId
        /// The user is not a member of the shared folder thus cannot access it.
        case notAMember
        /// The user does not exist or their account is disabled.
        case invalidMember
        /// Never set.
        case emailUnverified
        /// The shared folder is unmounted.
        case unmounted
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try SharedFolderAccessErrorSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharedFolderAccessErrorSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharedFolderAccessError: \(error)"
            }
        }
    }

    public class SharedFolderAccessErrorSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharedFolderAccessError) throws -> JSON {
            switch value {
            case .invalidId:
                var d = [String: JSON]()
                d[".tag"] = .str("invalid_id")
                return .dictionary(d)
            case .notAMember:
                var d = [String: JSON]()
                d[".tag"] = .str("not_a_member")
                return .dictionary(d)
            case .invalidMember:
                var d = [String: JSON]()
                d[".tag"] = .str("invalid_member")
                return .dictionary(d)
            case .emailUnverified:
                var d = [String: JSON]()
                d[".tag"] = .str("email_unverified")
                return .dictionary(d)
            case .unmounted:
                var d = [String: JSON]()
                d[".tag"] = .str("unmounted")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> SharedFolderAccessError {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "invalid_id":
                    return SharedFolderAccessError.invalidId
                case "not_a_member":
                    return SharedFolderAccessError.notAMember
                case "invalid_member":
                    return SharedFolderAccessError.invalidMember
                case "email_unverified":
                    return SharedFolderAccessError.emailUnverified
                case "unmounted":
                    return SharedFolderAccessError.unmounted
                case "other":
                    return SharedFolderAccessError.other
                default:
                    return SharedFolderAccessError.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: SharedFolderAccessError.self, json: json)
            }
        }
    }

    /// The SharedFolderMemberError union
    public enum SharedFolderMemberError: CustomStringConvertible, JSONRepresentable {
        /// The target dropbox_id is invalid.
        case invalidDropboxId
        /// The target dropbox_id is not a member of the shared folder.
        case notAMember
        /// The target member only has inherited access to the shared folder.
        case noExplicitAccess(Sharing.MemberAccessLevelResult)
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try SharedFolderMemberErrorSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharedFolderMemberErrorSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharedFolderMemberError: \(error)"
            }
        }
    }

    public class SharedFolderMemberErrorSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharedFolderMemberError) throws -> JSON {
            switch value {
            case .invalidDropboxId:
                var d = [String: JSON]()
                d[".tag"] = .str("invalid_dropbox_id")
                return .dictionary(d)
            case .notAMember:
                var d = [String: JSON]()
                d[".tag"] = .str("not_a_member")
                return .dictionary(d)
            case .noExplicitAccess(let arg):
                var d = try Serialization.getFields(Sharing.MemberAccessLevelResultSerializer().serialize(arg))
                d[".tag"] = .str("no_explicit_access")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> SharedFolderMemberError {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "invalid_dropbox_id":
                    return SharedFolderMemberError.invalidDropboxId
                case "not_a_member":
                    return SharedFolderMemberError.notAMember
                case "no_explicit_access":
                    let v = try Sharing.MemberAccessLevelResultSerializer().deserialize(json)
                    return SharedFolderMemberError.noExplicitAccess(v)
                case "other":
                    return SharedFolderMemberError.other
                default:
                    return SharedFolderMemberError.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: SharedFolderMemberError.self, json: json)
            }
        }
    }

    /// Shared folder user and group membership.
    public class SharedFolderMembers: CustomStringConvertible, JSONRepresentable {
        /// The list of user members of the shared folder.
        public let users: [Sharing.UserMembershipInfo]
        /// The list of group members of the shared folder.
        public let groups: [Sharing.GroupMembershipInfo]
        /// The list of invitees to the shared folder.
        public let invitees: [Sharing.InviteeMembershipInfo]
        /// Present if there are additional shared folder members that have not been returned yet. Pass the cursor into
        /// listFolderMembersContinue to list additional members.
        public let cursor: String?
        public init(
            users: [Sharing.UserMembershipInfo],
            groups: [Sharing.GroupMembershipInfo],
            invitees: [Sharing.InviteeMembershipInfo],
            cursor: String? = nil
        ) {
            self.users = users
            self.groups = groups
            self.invitees = invitees
            nullableValidator(stringValidator())(cursor)
            self.cursor = cursor
        }

        func json() throws -> JSON {
            try SharedFolderMembersSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharedFolderMembersSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharedFolderMembers: \(error)"
            }
        }
    }

    public class SharedFolderMembersSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharedFolderMembers) throws -> JSON {
            let output = [
                "users": try ArraySerializer(Sharing.UserMembershipInfoSerializer()).serialize(value.users),
                "groups": try ArraySerializer(Sharing.GroupMembershipInfoSerializer()).serialize(value.groups),
                "invitees": try ArraySerializer(Sharing.InviteeMembershipInfoSerializer()).serialize(value.invitees),
                "cursor": try NullableSerializer(Serialization._StringSerializer).serialize(value.cursor),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharedFolderMembers {
            switch json {
            case .dictionary(let dict):
                let users = try ArraySerializer(Sharing.UserMembershipInfoSerializer()).deserialize(dict["users"] ?? .null)
                let groups = try ArraySerializer(Sharing.GroupMembershipInfoSerializer()).deserialize(dict["groups"] ?? .null)
                let invitees = try ArraySerializer(Sharing.InviteeMembershipInfoSerializer()).deserialize(dict["invitees"] ?? .null)
                let cursor = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["cursor"] ?? .null)
                return SharedFolderMembers(users: users, groups: groups, invitees: invitees, cursor: cursor)
            default:
                throw JSONSerializerError.deserializeError(type: SharedFolderMembers.self, json: json)
            }
        }
    }

    /// Properties of the shared folder.
    public class SharedFolderMetadataBase: CustomStringConvertible, JSONRepresentable {
        /// The current user's access level for this shared folder.
        public let accessType: Sharing.AccessLevel
        /// Whether this folder is inside of a team folder.
        public let isInsideTeamFolder: Bool
        /// Whether this folder is a team folder https://www.dropbox.com/en/help/986.
        public let isTeamFolder: Bool
        /// The display names of the users that own the folder. If the folder is part of a team folder, the display
        /// names of the team admins are also included. Absent if the owner display names cannot be fetched.
        public let ownerDisplayNames: [String]?
        /// The team that owns the folder. This field is not present if the folder is not owned by a team.
        public let ownerTeam: Users.Team?
        /// The ID of the parent shared folder. This field is present only if the folder is contained within another
        /// shared folder.
        public let parentSharedFolderId: String?
        /// The full path of this shared folder. Absent for unmounted folders.
        public let pathDisplay: String?
        /// The lower-cased full path of this shared folder. Absent for unmounted folders.
        public let pathLower: String?
        /// Display name for the parent folder.
        public let parentFolderName: String?
        public init(
            accessType: Sharing.AccessLevel,
            isInsideTeamFolder: Bool,
            isTeamFolder: Bool,
            ownerDisplayNames: [String]? = nil,
            ownerTeam: Users.Team? = nil,
            parentSharedFolderId: String? = nil,
            pathDisplay: String? = nil,
            pathLower: String? = nil,
            parentFolderName: String? = nil
        ) {
            self.accessType = accessType
            self.isInsideTeamFolder = isInsideTeamFolder
            self.isTeamFolder = isTeamFolder
            nullableValidator(arrayValidator(itemValidator: stringValidator()))(ownerDisplayNames)
            self.ownerDisplayNames = ownerDisplayNames
            self.ownerTeam = ownerTeam
            nullableValidator(stringValidator(pattern: "[-_0-9a-zA-Z:]+"))(parentSharedFolderId)
            self.parentSharedFolderId = parentSharedFolderId
            nullableValidator(stringValidator())(pathDisplay)
            self.pathDisplay = pathDisplay
            nullableValidator(stringValidator())(pathLower)
            self.pathLower = pathLower
            nullableValidator(stringValidator())(parentFolderName)
            self.parentFolderName = parentFolderName
        }

        func json() throws -> JSON {
            try SharedFolderMetadataBaseSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharedFolderMetadataBaseSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharedFolderMetadataBase: \(error)"
            }
        }
    }

    public class SharedFolderMetadataBaseSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharedFolderMetadataBase) throws -> JSON {
            let output = [
                "access_type": try Sharing.AccessLevelSerializer().serialize(value.accessType),
                "is_inside_team_folder": try Serialization._BoolSerializer.serialize(value.isInsideTeamFolder),
                "is_team_folder": try Serialization._BoolSerializer.serialize(value.isTeamFolder),
                "owner_display_names": try NullableSerializer(ArraySerializer(Serialization._StringSerializer)).serialize(value.ownerDisplayNames),
                "owner_team": try NullableSerializer(Users.TeamSerializer()).serialize(value.ownerTeam),
                "parent_shared_folder_id": try NullableSerializer(Serialization._StringSerializer).serialize(value.parentSharedFolderId),
                "path_display": try NullableSerializer(Serialization._StringSerializer).serialize(value.pathDisplay),
                "path_lower": try NullableSerializer(Serialization._StringSerializer).serialize(value.pathLower),
                "parent_folder_name": try NullableSerializer(Serialization._StringSerializer).serialize(value.parentFolderName),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharedFolderMetadataBase {
            switch json {
            case .dictionary(let dict):
                let accessType = try Sharing.AccessLevelSerializer().deserialize(dict["access_type"] ?? .null)
                let isInsideTeamFolder = try Serialization._BoolSerializer.deserialize(dict["is_inside_team_folder"] ?? .null)
                let isTeamFolder = try Serialization._BoolSerializer.deserialize(dict["is_team_folder"] ?? .null)
                let ownerDisplayNames = try NullableSerializer(ArraySerializer(Serialization._StringSerializer))
                    .deserialize(dict["owner_display_names"] ?? .null)
                let ownerTeam = try NullableSerializer(Users.TeamSerializer()).deserialize(dict["owner_team"] ?? .null)
                let parentSharedFolderId = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["parent_shared_folder_id"] ?? .null)
                let pathDisplay = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["path_display"] ?? .null)
                let pathLower = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["path_lower"] ?? .null)
                let parentFolderName = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["parent_folder_name"] ?? .null)
                return SharedFolderMetadataBase(
                    accessType: accessType,
                    isInsideTeamFolder: isInsideTeamFolder,
                    isTeamFolder: isTeamFolder,
                    ownerDisplayNames: ownerDisplayNames,
                    ownerTeam: ownerTeam,
                    parentSharedFolderId: parentSharedFolderId,
                    pathDisplay: pathDisplay,
                    pathLower: pathLower,
                    parentFolderName: parentFolderName
                )
            default:
                throw JSONSerializerError.deserializeError(type: SharedFolderMetadataBase.self, json: json)
            }
        }
    }

    /// The metadata which includes basic information about the shared folder.
    public class SharedFolderMetadata: Sharing.SharedFolderMetadataBase {
        /// The metadata of the shared content link to this shared folder. Absent if there is no link on the folder.
        /// This is for an unreleased feature so it may not be returned yet.
        public let linkMetadata: Sharing.SharedContentLinkMetadata?
        /// The name of the this shared folder.
        public let name: String
        /// Actions the current user may perform on the folder and its contents. The set of permissions corresponds to
        /// the FolderActions in the request.
        public let permissions: [Sharing.FolderPermission]?
        /// Policies governing this shared folder.
        public let policy: Sharing.FolderPolicy
        /// URL for displaying a web preview of the shared folder.
        public let previewUrl: String
        /// The ID of the shared folder.
        public let sharedFolderId: String
        /// Timestamp indicating when the current user was invited to this shared folder.
        public let timeInvited: Date
        /// Whether the folder inherits its members from its parent.
        public let accessInheritance: Sharing.AccessInheritance
        public init(
            accessType: Sharing.AccessLevel,
            isInsideTeamFolder: Bool,
            isTeamFolder: Bool,
            name: String,
            policy: Sharing.FolderPolicy,
            previewUrl: String,
            sharedFolderId: String,
            timeInvited: Date,
            ownerDisplayNames: [String]? = nil,
            ownerTeam: Users.Team? = nil,
            parentSharedFolderId: String? = nil,
            pathDisplay: String? = nil,
            pathLower: String? = nil,
            parentFolderName: String? = nil,
            linkMetadata: Sharing.SharedContentLinkMetadata? = nil,
            permissions: [Sharing.FolderPermission]? = nil,
            accessInheritance: Sharing.AccessInheritance = .inherit
        ) {
            self.linkMetadata = linkMetadata
            stringValidator()(name)
            self.name = name
            self.permissions = permissions
            self.policy = policy
            stringValidator()(previewUrl)
            self.previewUrl = previewUrl
            stringValidator(pattern: "[-_0-9a-zA-Z:]+")(sharedFolderId)
            self.sharedFolderId = sharedFolderId
            self.timeInvited = timeInvited
            self.accessInheritance = accessInheritance
            super.init(
                accessType: accessType,
                isInsideTeamFolder: isInsideTeamFolder,
                isTeamFolder: isTeamFolder,
                ownerDisplayNames: ownerDisplayNames,
                ownerTeam: ownerTeam,
                parentSharedFolderId: parentSharedFolderId,
                pathDisplay: pathDisplay,
                pathLower: pathLower,
                parentFolderName: parentFolderName
            )
        }

        public override var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharedFolderMetadataSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharedFolderMetadata: \(error)"
            }
        }
    }

    public class SharedFolderMetadataSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharedFolderMetadata) throws -> JSON {
            let output = [
                "access_type": try Sharing.AccessLevelSerializer().serialize(value.accessType),
                "is_inside_team_folder": try Serialization._BoolSerializer.serialize(value.isInsideTeamFolder),
                "is_team_folder": try Serialization._BoolSerializer.serialize(value.isTeamFolder),
                "name": try Serialization._StringSerializer.serialize(value.name),
                "policy": try Sharing.FolderPolicySerializer().serialize(value.policy),
                "preview_url": try Serialization._StringSerializer.serialize(value.previewUrl),
                "shared_folder_id": try Serialization._StringSerializer.serialize(value.sharedFolderId),
                "time_invited": try NSDateSerializer("%Y-%m-%dT%H:%M:%SZ").serialize(value.timeInvited),
                "owner_display_names": try NullableSerializer(ArraySerializer(Serialization._StringSerializer)).serialize(value.ownerDisplayNames),
                "owner_team": try NullableSerializer(Users.TeamSerializer()).serialize(value.ownerTeam),
                "parent_shared_folder_id": try NullableSerializer(Serialization._StringSerializer).serialize(value.parentSharedFolderId),
                "path_display": try NullableSerializer(Serialization._StringSerializer).serialize(value.pathDisplay),
                "path_lower": try NullableSerializer(Serialization._StringSerializer).serialize(value.pathLower),
                "parent_folder_name": try NullableSerializer(Serialization._StringSerializer).serialize(value.parentFolderName),
                "link_metadata": try NullableSerializer(Sharing.SharedContentLinkMetadataSerializer()).serialize(value.linkMetadata),
                "permissions": try NullableSerializer(ArraySerializer(Sharing.FolderPermissionSerializer())).serialize(value.permissions),
                "access_inheritance": try Sharing.AccessInheritanceSerializer().serialize(value.accessInheritance),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharedFolderMetadata {
            switch json {
            case .dictionary(let dict):
                let accessType = try Sharing.AccessLevelSerializer().deserialize(dict["access_type"] ?? .null)
                let isInsideTeamFolder = try Serialization._BoolSerializer.deserialize(dict["is_inside_team_folder"] ?? .null)
                let isTeamFolder = try Serialization._BoolSerializer.deserialize(dict["is_team_folder"] ?? .null)
                let name = try Serialization._StringSerializer.deserialize(dict["name"] ?? .null)
                let policy = try Sharing.FolderPolicySerializer().deserialize(dict["policy"] ?? .null)
                let previewUrl = try Serialization._StringSerializer.deserialize(dict["preview_url"] ?? .null)
                let sharedFolderId = try Serialization._StringSerializer.deserialize(dict["shared_folder_id"] ?? .null)
                let timeInvited = try NSDateSerializer("%Y-%m-%dT%H:%M:%SZ").deserialize(dict["time_invited"] ?? .null)
                let ownerDisplayNames = try NullableSerializer(ArraySerializer(Serialization._StringSerializer))
                    .deserialize(dict["owner_display_names"] ?? .null)
                let ownerTeam = try NullableSerializer(Users.TeamSerializer()).deserialize(dict["owner_team"] ?? .null)
                let parentSharedFolderId = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["parent_shared_folder_id"] ?? .null)
                let pathDisplay = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["path_display"] ?? .null)
                let pathLower = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["path_lower"] ?? .null)
                let parentFolderName = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["parent_folder_name"] ?? .null)
                let linkMetadata = try NullableSerializer(Sharing.SharedContentLinkMetadataSerializer()).deserialize(dict["link_metadata"] ?? .null)
                let permissions = try NullableSerializer(ArraySerializer(Sharing.FolderPermissionSerializer())).deserialize(dict["permissions"] ?? .null)
                let accessInheritance = try Sharing.AccessInheritanceSerializer()
                    .deserialize(dict["access_inheritance"] ?? Sharing.AccessInheritanceSerializer().serialize(.inherit))
                return SharedFolderMetadata(
                    accessType: accessType,
                    isInsideTeamFolder: isInsideTeamFolder,
                    isTeamFolder: isTeamFolder,
                    name: name,
                    policy: policy,
                    previewUrl: previewUrl,
                    sharedFolderId: sharedFolderId,
                    timeInvited: timeInvited,
                    ownerDisplayNames: ownerDisplayNames,
                    ownerTeam: ownerTeam,
                    parentSharedFolderId: parentSharedFolderId,
                    pathDisplay: pathDisplay,
                    pathLower: pathLower,
                    parentFolderName: parentFolderName,
                    linkMetadata: linkMetadata,
                    permissions: permissions,
                    accessInheritance: accessInheritance
                )
            default:
                throw JSONSerializerError.deserializeError(type: SharedFolderMetadata.self, json: json)
            }
        }
    }

    /// The SharedLinkAccessFailureReason union
    public enum SharedLinkAccessFailureReason: CustomStringConvertible, JSONRepresentable {
        /// User is not logged in.
        case loginRequired
        /// This user's email address is not verified. This functionality is only available on accounts with a verified
        /// email address. Users can verify their email address here https://www.dropbox.com/help/317.
        case emailVerifyRequired
        /// The link is password protected.
        case passwordRequired
        /// Access is allowed for team members only.
        case teamOnly
        /// Access is allowed for the shared link's owner only.
        case ownerOnly
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try SharedLinkAccessFailureReasonSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharedLinkAccessFailureReasonSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharedLinkAccessFailureReason: \(error)"
            }
        }
    }

    public class SharedLinkAccessFailureReasonSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharedLinkAccessFailureReason) throws -> JSON {
            switch value {
            case .loginRequired:
                var d = [String: JSON]()
                d[".tag"] = .str("login_required")
                return .dictionary(d)
            case .emailVerifyRequired:
                var d = [String: JSON]()
                d[".tag"] = .str("email_verify_required")
                return .dictionary(d)
            case .passwordRequired:
                var d = [String: JSON]()
                d[".tag"] = .str("password_required")
                return .dictionary(d)
            case .teamOnly:
                var d = [String: JSON]()
                d[".tag"] = .str("team_only")
                return .dictionary(d)
            case .ownerOnly:
                var d = [String: JSON]()
                d[".tag"] = .str("owner_only")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> SharedLinkAccessFailureReason {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "login_required":
                    return SharedLinkAccessFailureReason.loginRequired
                case "email_verify_required":
                    return SharedLinkAccessFailureReason.emailVerifyRequired
                case "password_required":
                    return SharedLinkAccessFailureReason.passwordRequired
                case "team_only":
                    return SharedLinkAccessFailureReason.teamOnly
                case "owner_only":
                    return SharedLinkAccessFailureReason.ownerOnly
                case "other":
                    return SharedLinkAccessFailureReason.other
                default:
                    return SharedLinkAccessFailureReason.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: SharedLinkAccessFailureReason.self, json: json)
            }
        }
    }

    /// The SharedLinkAlreadyExistsMetadata union
    public enum SharedLinkAlreadyExistsMetadata: CustomStringConvertible, JSONRepresentable {
        /// Metadata of the shared link that already exists.
        case metadata(Sharing.SharedLinkMetadata)
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try SharedLinkAlreadyExistsMetadataSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharedLinkAlreadyExistsMetadataSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharedLinkAlreadyExistsMetadata: \(error)"
            }
        }
    }

    public class SharedLinkAlreadyExistsMetadataSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharedLinkAlreadyExistsMetadata) throws -> JSON {
            switch value {
            case .metadata(let arg):
                var d = try ["metadata": Sharing.SharedLinkMetadataSerializer().serialize(arg)]
                d[".tag"] = .str("metadata")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> SharedLinkAlreadyExistsMetadata {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "metadata":
                    let v = try Sharing.SharedLinkMetadataSerializer().deserialize(d["metadata"] ?? .null)
                    return SharedLinkAlreadyExistsMetadata.metadata(v)
                case "other":
                    return SharedLinkAlreadyExistsMetadata.other
                default:
                    return SharedLinkAlreadyExistsMetadata.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: SharedLinkAlreadyExistsMetadata.self, json: json)
            }
        }
    }

    /// Who can view shared links in this folder.
    public enum SharedLinkPolicy: CustomStringConvertible, JSONRepresentable {
        /// Links can be shared with anyone.
        case anyone
        /// Links can be shared with anyone on the same team as the owner.
        case team
        /// Links can only be shared among members of the shared folder.
        case members
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try SharedLinkPolicySerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharedLinkPolicySerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharedLinkPolicy: \(error)"
            }
        }
    }

    public class SharedLinkPolicySerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharedLinkPolicy) throws -> JSON {
            switch value {
            case .anyone:
                var d = [String: JSON]()
                d[".tag"] = .str("anyone")
                return .dictionary(d)
            case .team:
                var d = [String: JSON]()
                d[".tag"] = .str("team")
                return .dictionary(d)
            case .members:
                var d = [String: JSON]()
                d[".tag"] = .str("members")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> SharedLinkPolicy {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "anyone":
                    return SharedLinkPolicy.anyone
                case "team":
                    return SharedLinkPolicy.team
                case "members":
                    return SharedLinkPolicy.members
                case "other":
                    return SharedLinkPolicy.other
                default:
                    return SharedLinkPolicy.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: SharedLinkPolicy.self, json: json)
            }
        }
    }

    /// The SharedLinkSettings struct
    public class SharedLinkSettings: CustomStringConvertible, JSONRepresentable {
        /// Boolean flag to enable or disable password protection.
        public let requirePassword: Bool?
        /// If requirePassword is true, this is needed to specify the password to access the link.
        public let linkPassword: String?
        /// Expiration time of the shared link. By default the link won't expire.
        public let expires: Date?
        /// The new audience who can benefit from the access level specified by the link's access level specified in the
        /// `link_access_level` field of `LinkPermissions`. This is used in conjunction with team policies and
        /// shared folder policies to determine the final effective audience type in the `effective_audience`
        /// field of `LinkPermissions.
        public let audience: Sharing.LinkAudience?
        /// Requested access level you want the audience to gain from this link. Note, modifying access level for an
        /// existing link is not supported.
        public let access: Sharing.RequestedLinkAccessLevel?
        /// Use audience instead.  The requested access for this shared link.
        public let requestedVisibility: Sharing.RequestedVisibility?
        /// Boolean flag to allow or not download capabilities for shared links.
        public let allowDownload: Bool?
        public init(
            requirePassword: Bool? = nil,
            linkPassword: String? = nil,
            expires: Date? = nil,
            audience: Sharing.LinkAudience? = nil,
            access: Sharing.RequestedLinkAccessLevel? = nil,
            requestedVisibility: Sharing.RequestedVisibility? = nil,
            allowDownload: Bool? = nil
        ) {
            self.requirePassword = requirePassword
            nullableValidator(stringValidator())(linkPassword)
            self.linkPassword = linkPassword
            self.expires = expires
            self.audience = audience
            self.access = access
            self.requestedVisibility = requestedVisibility
            self.allowDownload = allowDownload
        }

        func json() throws -> JSON {
            try SharedLinkSettingsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharedLinkSettingsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharedLinkSettings: \(error)"
            }
        }
    }

    public class SharedLinkSettingsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharedLinkSettings) throws -> JSON {
            let output = [
                "require_password": try NullableSerializer(Serialization._BoolSerializer).serialize(value.requirePassword),
                "link_password": try NullableSerializer(Serialization._StringSerializer).serialize(value.linkPassword),
                "expires": try NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.expires),
                "audience": try NullableSerializer(Sharing.LinkAudienceSerializer()).serialize(value.audience),
                "access": try NullableSerializer(Sharing.RequestedLinkAccessLevelSerializer()).serialize(value.access),
                "requested_visibility": try NullableSerializer(Sharing.RequestedVisibilitySerializer()).serialize(value.requestedVisibility),
                "allow_download": try NullableSerializer(Serialization._BoolSerializer).serialize(value.allowDownload),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> SharedLinkSettings {
            switch json {
            case .dictionary(let dict):
                let requirePassword = try NullableSerializer(Serialization._BoolSerializer).deserialize(dict["require_password"] ?? .null)
                let linkPassword = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["link_password"] ?? .null)
                let expires = try NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).deserialize(dict["expires"] ?? .null)
                let audience = try NullableSerializer(Sharing.LinkAudienceSerializer()).deserialize(dict["audience"] ?? .null)
                let access = try NullableSerializer(Sharing.RequestedLinkAccessLevelSerializer()).deserialize(dict["access"] ?? .null)
                let requestedVisibility = try NullableSerializer(Sharing.RequestedVisibilitySerializer()).deserialize(dict["requested_visibility"] ?? .null)
                let allowDownload = try NullableSerializer(Serialization._BoolSerializer).deserialize(dict["allow_download"] ?? .null)
                return SharedLinkSettings(
                    requirePassword: requirePassword,
                    linkPassword: linkPassword,
                    expires: expires,
                    audience: audience,
                    access: access,
                    requestedVisibility: requestedVisibility,
                    allowDownload: allowDownload
                )
            default:
                throw JSONSerializerError.deserializeError(type: SharedLinkSettings.self, json: json)
            }
        }
    }

    /// The SharedLinkSettingsError union
    public enum SharedLinkSettingsError: CustomStringConvertible, JSONRepresentable {
        /// The given settings are invalid (for example, all attributes of the SharedLinkSettings are empty, the
        /// requested visibility is password in RequestedVisibility but the linkPassword in SharedLinkSettings
        /// is missing, expires in SharedLinkSettings is set to the past, etc.).
        case invalidSettings
        /// User is not allowed to modify the settings of this link. Note that basic users can only set public_ in
        /// RequestedVisibility as the requestedVisibility in SharedLinkSettings and cannot set expires in
        /// SharedLinkSettings.
        case notAuthorized

        func json() throws -> JSON {
            try SharedLinkSettingsErrorSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharedLinkSettingsErrorSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharedLinkSettingsError: \(error)"
            }
        }
    }

    public class SharedLinkSettingsErrorSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharedLinkSettingsError) throws -> JSON {
            switch value {
            case .invalidSettings:
                var d = [String: JSON]()
                d[".tag"] = .str("invalid_settings")
                return .dictionary(d)
            case .notAuthorized:
                var d = [String: JSON]()
                d[".tag"] = .str("not_authorized")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> SharedLinkSettingsError {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "invalid_settings":
                    return SharedLinkSettingsError.invalidSettings
                case "not_authorized":
                    return SharedLinkSettingsError.notAuthorized
                default:
                    throw JSONSerializerError.unknownTag(type: SharedLinkSettingsError.self, json: json, tag: tag)
                }
            default:
                throw JSONSerializerError.deserializeError(type: SharedLinkSettingsError.self, json: json)
            }
        }
    }

    /// User could not access this file.
    public enum SharingFileAccessError: CustomStringConvertible, JSONRepresentable {
        /// Current user does not have sufficient privileges to perform the desired action.
        case noPermission
        /// File specified was not found.
        case invalidFile
        /// A folder can't be shared this way. Use folder sharing or a shared link instead.
        case isFolder
        /// A file inside a public folder can't be shared this way. Use a public link instead.
        case insidePublicFolder
        /// A Mac OS X package can't be shared this way. Use a shared link instead.
        case insideOsxPackage
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try SharingFileAccessErrorSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharingFileAccessErrorSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharingFileAccessError: \(error)"
            }
        }
    }

    public class SharingFileAccessErrorSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharingFileAccessError) throws -> JSON {
            switch value {
            case .noPermission:
                var d = [String: JSON]()
                d[".tag"] = .str("no_permission")
                return .dictionary(d)
            case .invalidFile:
                var d = [String: JSON]()
                d[".tag"] = .str("invalid_file")
                return .dictionary(d)
            case .isFolder:
                var d = [String: JSON]()
                d[".tag"] = .str("is_folder")
                return .dictionary(d)
            case .insidePublicFolder:
                var d = [String: JSON]()
                d[".tag"] = .str("inside_public_folder")
                return .dictionary(d)
            case .insideOsxPackage:
                var d = [String: JSON]()
                d[".tag"] = .str("inside_osx_package")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> SharingFileAccessError {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "no_permission":
                    return SharingFileAccessError.noPermission
                case "invalid_file":
                    return SharingFileAccessError.invalidFile
                case "is_folder":
                    return SharingFileAccessError.isFolder
                case "inside_public_folder":
                    return SharingFileAccessError.insidePublicFolder
                case "inside_osx_package":
                    return SharingFileAccessError.insideOsxPackage
                case "other":
                    return SharingFileAccessError.other
                default:
                    return SharingFileAccessError.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: SharingFileAccessError.self, json: json)
            }
        }
    }

    /// User account had a problem preventing this action.
    public enum SharingUserError: CustomStringConvertible, JSONRepresentable {
        /// This user's email address is not verified. This functionality is only available on accounts with a verified
        /// email address. Users can verify their email address here https://www.dropbox.com/help/317.
        case emailUnverified
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try SharingUserErrorSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try SharingUserErrorSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for SharingUserError: \(error)"
            }
        }
    }

    public class SharingUserErrorSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: SharingUserError) throws -> JSON {
            switch value {
            case .emailUnverified:
                var d = [String: JSON]()
                d[".tag"] = .str("email_unverified")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> SharingUserError {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "email_unverified":
                    return SharingUserError.emailUnverified
                case "other":
                    return SharingUserError.other
                default:
                    return SharingUserError.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: SharingUserError.self, json: json)
            }
        }
    }

    /// Information about a team member.
    public class TeamMemberInfo: CustomStringConvertible, JSONRepresentable {
        /// Information about the member's team.
        public let teamInfo: Users.Team
        /// The display name of the user.
        public let displayName: String
        /// ID of user as a member of a team. This field will only be present if the member is in the same team as
        /// current user.
        public let memberId: String?
        public init(teamInfo: Users.Team, displayName: String, memberId: String? = nil) {
            self.teamInfo = teamInfo
            stringValidator()(displayName)
            self.displayName = displayName
            nullableValidator(stringValidator())(memberId)
            self.memberId = memberId
        }

        func json() throws -> JSON {
            try TeamMemberInfoSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TeamMemberInfoSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TeamMemberInfo: \(error)"
            }
        }
    }

    public class TeamMemberInfoSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TeamMemberInfo) throws -> JSON {
            let output = [
                "team_info": try Users.TeamSerializer().serialize(value.teamInfo),
                "display_name": try Serialization._StringSerializer.serialize(value.displayName),
                "member_id": try NullableSerializer(Serialization._StringSerializer).serialize(value.memberId),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> TeamMemberInfo {
            switch json {
            case .dictionary(let dict):
                let teamInfo = try Users.TeamSerializer().deserialize(dict["team_info"] ?? .null)
                let displayName = try Serialization._StringSerializer.deserialize(dict["display_name"] ?? .null)
                let memberId = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["member_id"] ?? .null)
                return TeamMemberInfo(teamInfo: teamInfo, displayName: displayName, memberId: memberId)
            default:
                throw JSONSerializerError.deserializeError(type: TeamMemberInfo.self, json: json)
            }
        }
    }

    /// The TransferFolderArg struct
    public class TransferFolderArg: CustomStringConvertible, JSONRepresentable {
        /// The ID for the shared folder.
        public let sharedFolderId: String
        /// A account or team member ID to transfer ownership to.
        public let toDropboxId: String
        public init(sharedFolderId: String, toDropboxId: String) {
            stringValidator(pattern: "[-_0-9a-zA-Z:]+")(sharedFolderId)
            self.sharedFolderId = sharedFolderId
            stringValidator(minLength: 1)(toDropboxId)
            self.toDropboxId = toDropboxId
        }

        func json() throws -> JSON {
            try TransferFolderArgSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TransferFolderArgSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TransferFolderArg: \(error)"
            }
        }
    }

    public class TransferFolderArgSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TransferFolderArg) throws -> JSON {
            let output = [
                "shared_folder_id": try Serialization._StringSerializer.serialize(value.sharedFolderId),
                "to_dropbox_id": try Serialization._StringSerializer.serialize(value.toDropboxId),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> TransferFolderArg {
            switch json {
            case .dictionary(let dict):
                let sharedFolderId = try Serialization._StringSerializer.deserialize(dict["shared_folder_id"] ?? .null)
                let toDropboxId = try Serialization._StringSerializer.deserialize(dict["to_dropbox_id"] ?? .null)
                return TransferFolderArg(sharedFolderId: sharedFolderId, toDropboxId: toDropboxId)
            default:
                throw JSONSerializerError.deserializeError(type: TransferFolderArg.self, json: json)
            }
        }
    }

    /// The TransferFolderError union
    public enum TransferFolderError: CustomStringConvertible, JSONRepresentable {
        /// An unspecified error.
        case accessError(Sharing.SharedFolderAccessError)
        /// toDropboxId in TransferFolderArg is invalid.
        case invalidDropboxId
        /// The new designated owner is not currently a member of the shared folder.
        case newOwnerNotAMember
        /// The new designated owner has not added the folder to their Dropbox.
        case newOwnerUnmounted
        /// The new designated owner's email address is not verified. This functionality is only available on accounts
        /// with a verified email address. Users can verify their email address here
        /// https://www.dropbox.com/help/317.
        case newOwnerEmailUnverified
        /// This action cannot be performed on a team shared folder.
        case teamFolder
        /// The current user does not have permission to perform this action.
        case noPermission
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try TransferFolderErrorSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try TransferFolderErrorSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for TransferFolderError: \(error)"
            }
        }
    }

    public class TransferFolderErrorSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: TransferFolderError) throws -> JSON {
            switch value {
            case .accessError(let arg):
                var d = try ["access_error": Sharing.SharedFolderAccessErrorSerializer().serialize(arg)]
                d[".tag"] = .str("access_error")
                return .dictionary(d)
            case .invalidDropboxId:
                var d = [String: JSON]()
                d[".tag"] = .str("invalid_dropbox_id")
                return .dictionary(d)
            case .newOwnerNotAMember:
                var d = [String: JSON]()
                d[".tag"] = .str("new_owner_not_a_member")
                return .dictionary(d)
            case .newOwnerUnmounted:
                var d = [String: JSON]()
                d[".tag"] = .str("new_owner_unmounted")
                return .dictionary(d)
            case .newOwnerEmailUnverified:
                var d = [String: JSON]()
                d[".tag"] = .str("new_owner_email_unverified")
                return .dictionary(d)
            case .teamFolder:
                var d = [String: JSON]()
                d[".tag"] = .str("team_folder")
                return .dictionary(d)
            case .noPermission:
                var d = [String: JSON]()
                d[".tag"] = .str("no_permission")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> TransferFolderError {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "access_error":
                    let v = try Sharing.SharedFolderAccessErrorSerializer().deserialize(d["access_error"] ?? .null)
                    return TransferFolderError.accessError(v)
                case "invalid_dropbox_id":
                    return TransferFolderError.invalidDropboxId
                case "new_owner_not_a_member":
                    return TransferFolderError.newOwnerNotAMember
                case "new_owner_unmounted":
                    return TransferFolderError.newOwnerUnmounted
                case "new_owner_email_unverified":
                    return TransferFolderError.newOwnerEmailUnverified
                case "team_folder":
                    return TransferFolderError.teamFolder
                case "no_permission":
                    return TransferFolderError.noPermission
                case "other":
                    return TransferFolderError.other
                default:
                    return TransferFolderError.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: TransferFolderError.self, json: json)
            }
        }
    }

    /// The UnmountFolderArg struct
    public class UnmountFolderArg: CustomStringConvertible, JSONRepresentable {
        /// The ID for the shared folder.
        public let sharedFolderId: String
        public init(sharedFolderId: String) {
            stringValidator(pattern: "[-_0-9a-zA-Z:]+")(sharedFolderId)
            self.sharedFolderId = sharedFolderId
        }

        func json() throws -> JSON {
            try UnmountFolderArgSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try UnmountFolderArgSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for UnmountFolderArg: \(error)"
            }
        }
    }

    public class UnmountFolderArgSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: UnmountFolderArg) throws -> JSON {
            let output = [
                "shared_folder_id": try Serialization._StringSerializer.serialize(value.sharedFolderId),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> UnmountFolderArg {
            switch json {
            case .dictionary(let dict):
                let sharedFolderId = try Serialization._StringSerializer.deserialize(dict["shared_folder_id"] ?? .null)
                return UnmountFolderArg(sharedFolderId: sharedFolderId)
            default:
                throw JSONSerializerError.deserializeError(type: UnmountFolderArg.self, json: json)
            }
        }
    }

    /// The UnmountFolderError union
    public enum UnmountFolderError: CustomStringConvertible, JSONRepresentable {
        /// An unspecified error.
        case accessError(Sharing.SharedFolderAccessError)
        /// The current user does not have permission to perform this action.
        case noPermission
        /// The shared folder can't be unmounted. One example where this can occur is when the shared folder's parent
        /// folder is also a shared folder that resides in the current user's Dropbox.
        case notUnmountable
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try UnmountFolderErrorSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try UnmountFolderErrorSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for UnmountFolderError: \(error)"
            }
        }
    }

    public class UnmountFolderErrorSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: UnmountFolderError) throws -> JSON {
            switch value {
            case .accessError(let arg):
                var d = try ["access_error": Sharing.SharedFolderAccessErrorSerializer().serialize(arg)]
                d[".tag"] = .str("access_error")
                return .dictionary(d)
            case .noPermission:
                var d = [String: JSON]()
                d[".tag"] = .str("no_permission")
                return .dictionary(d)
            case .notUnmountable:
                var d = [String: JSON]()
                d[".tag"] = .str("not_unmountable")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> UnmountFolderError {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "access_error":
                    let v = try Sharing.SharedFolderAccessErrorSerializer().deserialize(d["access_error"] ?? .null)
                    return UnmountFolderError.accessError(v)
                case "no_permission":
                    return UnmountFolderError.noPermission
                case "not_unmountable":
                    return UnmountFolderError.notUnmountable
                case "other":
                    return UnmountFolderError.other
                default:
                    return UnmountFolderError.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: UnmountFolderError.self, json: json)
            }
        }
    }

    /// Arguments for unshareFile.
    public class UnshareFileArg: CustomStringConvertible, JSONRepresentable {
        /// The file to unshare.
        public let file: String
        public init(file: String) {
            stringValidator(minLength: 1, pattern: "((/|id:).*|nspath:[0-9]+:.*)|ns:[0-9]+(/.*)?")(file)
            self.file = file
        }

        func json() throws -> JSON {
            try UnshareFileArgSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try UnshareFileArgSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for UnshareFileArg: \(error)"
            }
        }
    }

    public class UnshareFileArgSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: UnshareFileArg) throws -> JSON {
            let output = [
                "file": try Serialization._StringSerializer.serialize(value.file),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> UnshareFileArg {
            switch json {
            case .dictionary(let dict):
                let file = try Serialization._StringSerializer.deserialize(dict["file"] ?? .null)
                return UnshareFileArg(file: file)
            default:
                throw JSONSerializerError.deserializeError(type: UnshareFileArg.self, json: json)
            }
        }
    }

    /// Error result for unshareFile.
    public enum UnshareFileError: CustomStringConvertible, JSONRepresentable {
        /// An unspecified error.
        case userError(Sharing.SharingUserError)
        /// An unspecified error.
        case accessError(Sharing.SharingFileAccessError)
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try UnshareFileErrorSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try UnshareFileErrorSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for UnshareFileError: \(error)"
            }
        }
    }

    public class UnshareFileErrorSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: UnshareFileError) throws -> JSON {
            switch value {
            case .userError(let arg):
                var d = try ["user_error": Sharing.SharingUserErrorSerializer().serialize(arg)]
                d[".tag"] = .str("user_error")
                return .dictionary(d)
            case .accessError(let arg):
                var d = try ["access_error": Sharing.SharingFileAccessErrorSerializer().serialize(arg)]
                d[".tag"] = .str("access_error")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> UnshareFileError {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "user_error":
                    let v = try Sharing.SharingUserErrorSerializer().deserialize(d["user_error"] ?? .null)
                    return UnshareFileError.userError(v)
                case "access_error":
                    let v = try Sharing.SharingFileAccessErrorSerializer().deserialize(d["access_error"] ?? .null)
                    return UnshareFileError.accessError(v)
                case "other":
                    return UnshareFileError.other
                default:
                    return UnshareFileError.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: UnshareFileError.self, json: json)
            }
        }
    }

    /// The UnshareFolderArg struct
    public class UnshareFolderArg: CustomStringConvertible, JSONRepresentable {
        /// The ID for the shared folder.
        public let sharedFolderId: String
        /// If true, members of this shared folder will get a copy of this folder after it's unshared. Otherwise, it
        /// will be removed from their Dropbox. The current user, who is an owner, will always retain their
        /// copy.
        public let leaveACopy: Bool
        public init(sharedFolderId: String, leaveACopy: Bool = false) {
            stringValidator(pattern: "[-_0-9a-zA-Z:]+")(sharedFolderId)
            self.sharedFolderId = sharedFolderId
            self.leaveACopy = leaveACopy
        }

        func json() throws -> JSON {
            try UnshareFolderArgSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try UnshareFolderArgSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for UnshareFolderArg: \(error)"
            }
        }
    }

    public class UnshareFolderArgSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: UnshareFolderArg) throws -> JSON {
            let output = [
                "shared_folder_id": try Serialization._StringSerializer.serialize(value.sharedFolderId),
                "leave_a_copy": try Serialization._BoolSerializer.serialize(value.leaveACopy),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> UnshareFolderArg {
            switch json {
            case .dictionary(let dict):
                let sharedFolderId = try Serialization._StringSerializer.deserialize(dict["shared_folder_id"] ?? .null)
                let leaveACopy = try Serialization._BoolSerializer.deserialize(dict["leave_a_copy"] ?? .number(0))
                return UnshareFolderArg(sharedFolderId: sharedFolderId, leaveACopy: leaveACopy)
            default:
                throw JSONSerializerError.deserializeError(type: UnshareFolderArg.self, json: json)
            }
        }
    }

    /// The UnshareFolderError union
    public enum UnshareFolderError: CustomStringConvertible, JSONRepresentable {
        /// An unspecified error.
        case accessError(Sharing.SharedFolderAccessError)
        /// This action cannot be performed on a team shared folder.
        case teamFolder
        /// The current user does not have permission to perform this action.
        case noPermission
        /// This shared folder has too many files to be unshared.
        case tooManyFiles
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try UnshareFolderErrorSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try UnshareFolderErrorSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for UnshareFolderError: \(error)"
            }
        }
    }

    public class UnshareFolderErrorSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: UnshareFolderError) throws -> JSON {
            switch value {
            case .accessError(let arg):
                var d = try ["access_error": Sharing.SharedFolderAccessErrorSerializer().serialize(arg)]
                d[".tag"] = .str("access_error")
                return .dictionary(d)
            case .teamFolder:
                var d = [String: JSON]()
                d[".tag"] = .str("team_folder")
                return .dictionary(d)
            case .noPermission:
                var d = [String: JSON]()
                d[".tag"] = .str("no_permission")
                return .dictionary(d)
            case .tooManyFiles:
                var d = [String: JSON]()
                d[".tag"] = .str("too_many_files")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> UnshareFolderError {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "access_error":
                    let v = try Sharing.SharedFolderAccessErrorSerializer().deserialize(d["access_error"] ?? .null)
                    return UnshareFolderError.accessError(v)
                case "team_folder":
                    return UnshareFolderError.teamFolder
                case "no_permission":
                    return UnshareFolderError.noPermission
                case "too_many_files":
                    return UnshareFolderError.tooManyFiles
                case "other":
                    return UnshareFolderError.other
                default:
                    return UnshareFolderError.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: UnshareFolderError.self, json: json)
            }
        }
    }

    /// Arguments for updateFileMember.
    public class UpdateFileMemberArgs: CustomStringConvertible, JSONRepresentable {
        /// File for which we are changing a member's access.
        public let file: String
        /// The member whose access we are changing.
        public let member: Sharing.MemberSelector
        /// The new access level for the member.
        public let accessLevel: Sharing.AccessLevel
        public init(file: String, member: Sharing.MemberSelector, accessLevel: Sharing.AccessLevel) {
            stringValidator(minLength: 1, pattern: "((/|id:).*|nspath:[0-9]+:.*)|ns:[0-9]+(/.*)?")(file)
            self.file = file
            self.member = member
            self.accessLevel = accessLevel
        }

        func json() throws -> JSON {
            try UpdateFileMemberArgsSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try UpdateFileMemberArgsSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for UpdateFileMemberArgs: \(error)"
            }
        }
    }

    public class UpdateFileMemberArgsSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: UpdateFileMemberArgs) throws -> JSON {
            let output = [
                "file": try Serialization._StringSerializer.serialize(value.file),
                "member": try Sharing.MemberSelectorSerializer().serialize(value.member),
                "access_level": try Sharing.AccessLevelSerializer().serialize(value.accessLevel),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> UpdateFileMemberArgs {
            switch json {
            case .dictionary(let dict):
                let file = try Serialization._StringSerializer.deserialize(dict["file"] ?? .null)
                let member = try Sharing.MemberSelectorSerializer().deserialize(dict["member"] ?? .null)
                let accessLevel = try Sharing.AccessLevelSerializer().deserialize(dict["access_level"] ?? .null)
                return UpdateFileMemberArgs(file: file, member: member, accessLevel: accessLevel)
            default:
                throw JSONSerializerError.deserializeError(type: UpdateFileMemberArgs.self, json: json)
            }
        }
    }

    /// The UpdateFolderMemberArg struct
    public class UpdateFolderMemberArg: CustomStringConvertible, JSONRepresentable {
        /// The ID for the shared folder.
        public let sharedFolderId: String
        /// The member of the shared folder to update.  Only the dropboxId in MemberSelector may be set at this time.
        public let member: Sharing.MemberSelector
        /// The new access level for member. owner in AccessLevel is disallowed.
        public let accessLevel: Sharing.AccessLevel
        public init(sharedFolderId: String, member: Sharing.MemberSelector, accessLevel: Sharing.AccessLevel) {
            stringValidator(pattern: "[-_0-9a-zA-Z:]+")(sharedFolderId)
            self.sharedFolderId = sharedFolderId
            self.member = member
            self.accessLevel = accessLevel
        }

        func json() throws -> JSON {
            try UpdateFolderMemberArgSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try UpdateFolderMemberArgSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for UpdateFolderMemberArg: \(error)"
            }
        }
    }

    public class UpdateFolderMemberArgSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: UpdateFolderMemberArg) throws -> JSON {
            let output = [
                "shared_folder_id": try Serialization._StringSerializer.serialize(value.sharedFolderId),
                "member": try Sharing.MemberSelectorSerializer().serialize(value.member),
                "access_level": try Sharing.AccessLevelSerializer().serialize(value.accessLevel),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> UpdateFolderMemberArg {
            switch json {
            case .dictionary(let dict):
                let sharedFolderId = try Serialization._StringSerializer.deserialize(dict["shared_folder_id"] ?? .null)
                let member = try Sharing.MemberSelectorSerializer().deserialize(dict["member"] ?? .null)
                let accessLevel = try Sharing.AccessLevelSerializer().deserialize(dict["access_level"] ?? .null)
                return UpdateFolderMemberArg(sharedFolderId: sharedFolderId, member: member, accessLevel: accessLevel)
            default:
                throw JSONSerializerError.deserializeError(type: UpdateFolderMemberArg.self, json: json)
            }
        }
    }

    /// The UpdateFolderMemberError union
    public enum UpdateFolderMemberError: CustomStringConvertible, JSONRepresentable {
        /// An unspecified error.
        case accessError(Sharing.SharedFolderAccessError)
        /// An unspecified error.
        case memberError(Sharing.SharedFolderMemberError)
        /// If updating the access type required the member to be added to the shared folder and there was an error when
        /// adding the member.
        case noExplicitAccess(Sharing.AddFolderMemberError)
        /// The current user's account doesn't support this action. An example of this is when downgrading a member from
        /// editor to viewer. This action can only be performed by users that have upgraded to a Pro or Business
        /// plan.
        case insufficientPlan
        /// The current user does not have permission to perform this action.
        case noPermission
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try UpdateFolderMemberErrorSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try UpdateFolderMemberErrorSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for UpdateFolderMemberError: \(error)"
            }
        }
    }

    public class UpdateFolderMemberErrorSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: UpdateFolderMemberError) throws -> JSON {
            switch value {
            case .accessError(let arg):
                var d = try ["access_error": Sharing.SharedFolderAccessErrorSerializer().serialize(arg)]
                d[".tag"] = .str("access_error")
                return .dictionary(d)
            case .memberError(let arg):
                var d = try ["member_error": Sharing.SharedFolderMemberErrorSerializer().serialize(arg)]
                d[".tag"] = .str("member_error")
                return .dictionary(d)
            case .noExplicitAccess(let arg):
                var d = try ["no_explicit_access": Sharing.AddFolderMemberErrorSerializer().serialize(arg)]
                d[".tag"] = .str("no_explicit_access")
                return .dictionary(d)
            case .insufficientPlan:
                var d = [String: JSON]()
                d[".tag"] = .str("insufficient_plan")
                return .dictionary(d)
            case .noPermission:
                var d = [String: JSON]()
                d[".tag"] = .str("no_permission")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> UpdateFolderMemberError {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "access_error":
                    let v = try Sharing.SharedFolderAccessErrorSerializer().deserialize(d["access_error"] ?? .null)
                    return UpdateFolderMemberError.accessError(v)
                case "member_error":
                    let v = try Sharing.SharedFolderMemberErrorSerializer().deserialize(d["member_error"] ?? .null)
                    return UpdateFolderMemberError.memberError(v)
                case "no_explicit_access":
                    let v = try Sharing.AddFolderMemberErrorSerializer().deserialize(d["no_explicit_access"] ?? .null)
                    return UpdateFolderMemberError.noExplicitAccess(v)
                case "insufficient_plan":
                    return UpdateFolderMemberError.insufficientPlan
                case "no_permission":
                    return UpdateFolderMemberError.noPermission
                case "other":
                    return UpdateFolderMemberError.other
                default:
                    return UpdateFolderMemberError.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: UpdateFolderMemberError.self, json: json)
            }
        }
    }

    /// If any of the policies are unset, then they retain their current setting.
    public class UpdateFolderPolicyArg: CustomStringConvertible, JSONRepresentable {
        /// The ID for the shared folder.
        public let sharedFolderId: String
        /// Who can be a member of this shared folder. Only applicable if the current user is on a team.
        public let memberPolicy: Sharing.MemberPolicy?
        /// Who can add and remove members of this shared folder.
        public let aclUpdatePolicy: Sharing.AclUpdatePolicy?
        /// Who can enable/disable viewer info for this shared folder.
        public let viewerInfoPolicy: Sharing.ViewerInfoPolicy?
        /// The policy to apply to shared links created for content inside this shared folder. The current user must be
        /// on a team to set this policy to members in SharedLinkPolicy.
        public let sharedLinkPolicy: Sharing.SharedLinkPolicy?
        /// Settings on the link for this folder.
        public let linkSettings: Sharing.LinkSettings?
        /// A list of `FolderAction`s corresponding to `FolderPermission`s that should appear in the  response's
        /// permissions in SharedFolderMetadata field describing the actions the  authenticated user can perform
        /// on the folder.
        public let actions: [Sharing.FolderAction]?
        public init(
            sharedFolderId: String,
            memberPolicy: Sharing.MemberPolicy? = nil,
            aclUpdatePolicy: Sharing.AclUpdatePolicy? = nil,
            viewerInfoPolicy: Sharing.ViewerInfoPolicy? = nil,
            sharedLinkPolicy: Sharing.SharedLinkPolicy? = nil,
            linkSettings: Sharing.LinkSettings? = nil,
            actions: [Sharing.FolderAction]? = nil
        ) {
            stringValidator(pattern: "[-_0-9a-zA-Z:]+")(sharedFolderId)
            self.sharedFolderId = sharedFolderId
            self.memberPolicy = memberPolicy
            self.aclUpdatePolicy = aclUpdatePolicy
            self.viewerInfoPolicy = viewerInfoPolicy
            self.sharedLinkPolicy = sharedLinkPolicy
            self.linkSettings = linkSettings
            self.actions = actions
        }

        func json() throws -> JSON {
            try UpdateFolderPolicyArgSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try UpdateFolderPolicyArgSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for UpdateFolderPolicyArg: \(error)"
            }
        }
    }

    public class UpdateFolderPolicyArgSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: UpdateFolderPolicyArg) throws -> JSON {
            let output = [
                "shared_folder_id": try Serialization._StringSerializer.serialize(value.sharedFolderId),
                "member_policy": try NullableSerializer(Sharing.MemberPolicySerializer()).serialize(value.memberPolicy),
                "acl_update_policy": try NullableSerializer(Sharing.AclUpdatePolicySerializer()).serialize(value.aclUpdatePolicy),
                "viewer_info_policy": try NullableSerializer(Sharing.ViewerInfoPolicySerializer()).serialize(value.viewerInfoPolicy),
                "shared_link_policy": try NullableSerializer(Sharing.SharedLinkPolicySerializer()).serialize(value.sharedLinkPolicy),
                "link_settings": try NullableSerializer(Sharing.LinkSettingsSerializer()).serialize(value.linkSettings),
                "actions": try NullableSerializer(ArraySerializer(Sharing.FolderActionSerializer())).serialize(value.actions),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> UpdateFolderPolicyArg {
            switch json {
            case .dictionary(let dict):
                let sharedFolderId = try Serialization._StringSerializer.deserialize(dict["shared_folder_id"] ?? .null)
                let memberPolicy = try NullableSerializer(Sharing.MemberPolicySerializer()).deserialize(dict["member_policy"] ?? .null)
                let aclUpdatePolicy = try NullableSerializer(Sharing.AclUpdatePolicySerializer()).deserialize(dict["acl_update_policy"] ?? .null)
                let viewerInfoPolicy = try NullableSerializer(Sharing.ViewerInfoPolicySerializer()).deserialize(dict["viewer_info_policy"] ?? .null)
                let sharedLinkPolicy = try NullableSerializer(Sharing.SharedLinkPolicySerializer()).deserialize(dict["shared_link_policy"] ?? .null)
                let linkSettings = try NullableSerializer(Sharing.LinkSettingsSerializer()).deserialize(dict["link_settings"] ?? .null)
                let actions = try NullableSerializer(ArraySerializer(Sharing.FolderActionSerializer())).deserialize(dict["actions"] ?? .null)
                return UpdateFolderPolicyArg(
                    sharedFolderId: sharedFolderId,
                    memberPolicy: memberPolicy,
                    aclUpdatePolicy: aclUpdatePolicy,
                    viewerInfoPolicy: viewerInfoPolicy,
                    sharedLinkPolicy: sharedLinkPolicy,
                    linkSettings: linkSettings,
                    actions: actions
                )
            default:
                throw JSONSerializerError.deserializeError(type: UpdateFolderPolicyArg.self, json: json)
            }
        }
    }

    /// The UpdateFolderPolicyError union
    public enum UpdateFolderPolicyError: CustomStringConvertible, JSONRepresentable {
        /// An unspecified error.
        case accessError(Sharing.SharedFolderAccessError)
        /// memberPolicy in UpdateFolderPolicyArg was set even though user is not on a team.
        case notOnTeam
        /// Team policy is more restrictive than memberPolicy in ShareFolderArg.
        case teamPolicyDisallowsMemberPolicy
        /// The current account is not allowed to select the specified sharedLinkPolicy in ShareFolderArg.
        case disallowedSharedLinkPolicy
        /// The current user does not have permission to perform this action.
        case noPermission
        /// This action cannot be performed on a team shared folder.
        case teamFolder
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try UpdateFolderPolicyErrorSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try UpdateFolderPolicyErrorSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for UpdateFolderPolicyError: \(error)"
            }
        }
    }

    public class UpdateFolderPolicyErrorSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: UpdateFolderPolicyError) throws -> JSON {
            switch value {
            case .accessError(let arg):
                var d = try ["access_error": Sharing.SharedFolderAccessErrorSerializer().serialize(arg)]
                d[".tag"] = .str("access_error")
                return .dictionary(d)
            case .notOnTeam:
                var d = [String: JSON]()
                d[".tag"] = .str("not_on_team")
                return .dictionary(d)
            case .teamPolicyDisallowsMemberPolicy:
                var d = [String: JSON]()
                d[".tag"] = .str("team_policy_disallows_member_policy")
                return .dictionary(d)
            case .disallowedSharedLinkPolicy:
                var d = [String: JSON]()
                d[".tag"] = .str("disallowed_shared_link_policy")
                return .dictionary(d)
            case .noPermission:
                var d = [String: JSON]()
                d[".tag"] = .str("no_permission")
                return .dictionary(d)
            case .teamFolder:
                var d = [String: JSON]()
                d[".tag"] = .str("team_folder")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> UpdateFolderPolicyError {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "access_error":
                    let v = try Sharing.SharedFolderAccessErrorSerializer().deserialize(d["access_error"] ?? .null)
                    return UpdateFolderPolicyError.accessError(v)
                case "not_on_team":
                    return UpdateFolderPolicyError.notOnTeam
                case "team_policy_disallows_member_policy":
                    return UpdateFolderPolicyError.teamPolicyDisallowsMemberPolicy
                case "disallowed_shared_link_policy":
                    return UpdateFolderPolicyError.disallowedSharedLinkPolicy
                case "no_permission":
                    return UpdateFolderPolicyError.noPermission
                case "team_folder":
                    return UpdateFolderPolicyError.teamFolder
                case "other":
                    return UpdateFolderPolicyError.other
                default:
                    return UpdateFolderPolicyError.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: UpdateFolderPolicyError.self, json: json)
            }
        }
    }

    /// The information about a user member of the shared content.
    public class UserMembershipInfo: Sharing.MembershipInfo {
        /// The account information for the membership user.
        public let user: Sharing.UserInfo
        public init(
            accessType: Sharing.AccessLevel,
            user: Sharing.UserInfo,
            permissions: [Sharing.MemberPermission]? = nil,
            initials: String? = nil,
            isInherited: Bool = false
        ) {
            self.user = user
            super.init(accessType: accessType, permissions: permissions, initials: initials, isInherited: isInherited)
        }

        public override var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try UserMembershipInfoSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for UserMembershipInfo: \(error)"
            }
        }
    }

    public class UserMembershipInfoSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: UserMembershipInfo) throws -> JSON {
            let output = [
                "access_type": try Sharing.AccessLevelSerializer().serialize(value.accessType),
                "user": try Sharing.UserInfoSerializer().serialize(value.user),
                "permissions": try NullableSerializer(ArraySerializer(Sharing.MemberPermissionSerializer())).serialize(value.permissions),
                "initials": try NullableSerializer(Serialization._StringSerializer).serialize(value.initials),
                "is_inherited": try Serialization._BoolSerializer.serialize(value.isInherited),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> UserMembershipInfo {
            switch json {
            case .dictionary(let dict):
                let accessType = try Sharing.AccessLevelSerializer().deserialize(dict["access_type"] ?? .null)
                let user = try Sharing.UserInfoSerializer().deserialize(dict["user"] ?? .null)
                let permissions = try NullableSerializer(ArraySerializer(Sharing.MemberPermissionSerializer())).deserialize(dict["permissions"] ?? .null)
                let initials = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["initials"] ?? .null)
                let isInherited = try Serialization._BoolSerializer.deserialize(dict["is_inherited"] ?? .number(0))
                return UserMembershipInfo(accessType: accessType, user: user, permissions: permissions, initials: initials, isInherited: isInherited)
            default:
                throw JSONSerializerError.deserializeError(type: UserMembershipInfo.self, json: json)
            }
        }
    }

    /// The information about a user member of the shared content with an appended last seen timestamp.
    public class UserFileMembershipInfo: Sharing.UserMembershipInfo {
        /// The UTC timestamp of when the user has last seen the content. Only populated if the user has seen the
        /// content and the caller has a plan that includes viewer history.
        public let timeLastSeen: Date?
        /// The platform on which the user has last seen the content, or unknown.
        public let platformType: SeenState.PlatformType?
        public init(
            accessType: Sharing.AccessLevel,
            user: Sharing.UserInfo,
            permissions: [Sharing.MemberPermission]? = nil,
            initials: String? = nil,
            isInherited: Bool = false,
            timeLastSeen: Date? = nil,
            platformType: SeenState.PlatformType? = nil
        ) {
            self.timeLastSeen = timeLastSeen
            self.platformType = platformType
            super.init(accessType: accessType, user: user, permissions: permissions, initials: initials, isInherited: isInherited)
        }

        public override var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try UserFileMembershipInfoSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for UserFileMembershipInfo: \(error)"
            }
        }
    }

    public class UserFileMembershipInfoSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: UserFileMembershipInfo) throws -> JSON {
            let output = [
                "access_type": try Sharing.AccessLevelSerializer().serialize(value.accessType),
                "user": try Sharing.UserInfoSerializer().serialize(value.user),
                "permissions": try NullableSerializer(ArraySerializer(Sharing.MemberPermissionSerializer())).serialize(value.permissions),
                "initials": try NullableSerializer(Serialization._StringSerializer).serialize(value.initials),
                "is_inherited": try Serialization._BoolSerializer.serialize(value.isInherited),
                "time_last_seen": try NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.timeLastSeen),
                "platform_type": try NullableSerializer(SeenState.PlatformTypeSerializer()).serialize(value.platformType),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> UserFileMembershipInfo {
            switch json {
            case .dictionary(let dict):
                let accessType = try Sharing.AccessLevelSerializer().deserialize(dict["access_type"] ?? .null)
                let user = try Sharing.UserInfoSerializer().deserialize(dict["user"] ?? .null)
                let permissions = try NullableSerializer(ArraySerializer(Sharing.MemberPermissionSerializer())).deserialize(dict["permissions"] ?? .null)
                let initials = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["initials"] ?? .null)
                let isInherited = try Serialization._BoolSerializer.deserialize(dict["is_inherited"] ?? .number(0))
                let timeLastSeen = try NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).deserialize(dict["time_last_seen"] ?? .null)
                let platformType = try NullableSerializer(SeenState.PlatformTypeSerializer()).deserialize(dict["platform_type"] ?? .null)
                return UserFileMembershipInfo(
                    accessType: accessType,
                    user: user,
                    permissions: permissions,
                    initials: initials,
                    isInherited: isInherited,
                    timeLastSeen: timeLastSeen,
                    platformType: platformType
                )
            default:
                throw JSONSerializerError.deserializeError(type: UserFileMembershipInfo.self, json: json)
            }
        }
    }

    /// Basic information about a user. Use usersAccount and usersAccountBatch to obtain more detailed information.
    public class UserInfo: CustomStringConvertible, JSONRepresentable {
        /// The account ID of the user.
        public let accountId: String
        /// Email address of user.
        public let email: String
        /// The display name of the user.
        public let displayName: String
        /// If the user is in the same team as current user.
        public let sameTeam: Bool
        /// The team member ID of the shared folder member. Only present if sameTeam is true.
        public let teamMemberId: String?
        public init(accountId: String, email: String, displayName: String, sameTeam: Bool, teamMemberId: String? = nil) {
            stringValidator(minLength: 40, maxLength: 40)(accountId)
            self.accountId = accountId
            stringValidator()(email)
            self.email = email
            stringValidator()(displayName)
            self.displayName = displayName
            self.sameTeam = sameTeam
            nullableValidator(stringValidator())(teamMemberId)
            self.teamMemberId = teamMemberId
        }

        func json() throws -> JSON {
            try UserInfoSerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try UserInfoSerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for UserInfo: \(error)"
            }
        }
    }

    public class UserInfoSerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: UserInfo) throws -> JSON {
            let output = [
                "account_id": try Serialization._StringSerializer.serialize(value.accountId),
                "email": try Serialization._StringSerializer.serialize(value.email),
                "display_name": try Serialization._StringSerializer.serialize(value.displayName),
                "same_team": try Serialization._BoolSerializer.serialize(value.sameTeam),
                "team_member_id": try NullableSerializer(Serialization._StringSerializer).serialize(value.teamMemberId),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> UserInfo {
            switch json {
            case .dictionary(let dict):
                let accountId = try Serialization._StringSerializer.deserialize(dict["account_id"] ?? .null)
                let email = try Serialization._StringSerializer.deserialize(dict["email"] ?? .null)
                let displayName = try Serialization._StringSerializer.deserialize(dict["display_name"] ?? .null)
                let sameTeam = try Serialization._BoolSerializer.deserialize(dict["same_team"] ?? .null)
                let teamMemberId = try NullableSerializer(Serialization._StringSerializer).deserialize(dict["team_member_id"] ?? .null)
                return UserInfo(accountId: accountId, email: email, displayName: displayName, sameTeam: sameTeam, teamMemberId: teamMemberId)
            default:
                throw JSONSerializerError.deserializeError(type: UserInfo.self, json: json)
            }
        }
    }

    /// The ViewerInfoPolicy union
    public enum ViewerInfoPolicy: CustomStringConvertible, JSONRepresentable {
        /// Viewer information is available on this file.
        case enabled
        /// Viewer information is disabled on this file.
        case disabled
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try ViewerInfoPolicySerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try ViewerInfoPolicySerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for ViewerInfoPolicy: \(error)"
            }
        }
    }

    public class ViewerInfoPolicySerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: ViewerInfoPolicy) throws -> JSON {
            switch value {
            case .enabled:
                var d = [String: JSON]()
                d[".tag"] = .str("enabled")
                return .dictionary(d)
            case .disabled:
                var d = [String: JSON]()
                d[".tag"] = .str("disabled")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> ViewerInfoPolicy {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "enabled":
                    return ViewerInfoPolicy.enabled
                case "disabled":
                    return ViewerInfoPolicy.disabled
                case "other":
                    return ViewerInfoPolicy.other
                default:
                    return ViewerInfoPolicy.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: ViewerInfoPolicy.self, json: json)
            }
        }
    }

    /// Who can access a shared link. The most open visibility is public_. The default depends on many aspects, such as
    /// team and user preferences and shared folder settings.
    public enum Visibility: CustomStringConvertible, JSONRepresentable {
        /// Anyone who has received the link can access it. No login required.
        case public_
        /// Only members of the same team can access the link. Login is required.
        case teamOnly
        /// A link-specific password is required to access the link. Login is not required.
        case password
        /// Only members of the same team who have the link-specific password can access the link.
        case teamAndPassword
        /// Only members of the shared folder containing the linked file can access the link. Login is required.
        case sharedFolderOnly
        /// An unspecified error.
        case other

        func json() throws -> JSON {
            try VisibilitySerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try VisibilitySerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for Visibility: \(error)"
            }
        }
    }

    public class VisibilitySerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: Visibility) throws -> JSON {
            switch value {
            case .public_:
                var d = [String: JSON]()
                d[".tag"] = .str("public")
                return .dictionary(d)
            case .teamOnly:
                var d = [String: JSON]()
                d[".tag"] = .str("team_only")
                return .dictionary(d)
            case .password:
                var d = [String: JSON]()
                d[".tag"] = .str("password")
                return .dictionary(d)
            case .teamAndPassword:
                var d = [String: JSON]()
                d[".tag"] = .str("team_and_password")
                return .dictionary(d)
            case .sharedFolderOnly:
                var d = [String: JSON]()
                d[".tag"] = .str("shared_folder_only")
                return .dictionary(d)
            case .other:
                var d = [String: JSON]()
                d[".tag"] = .str("other")
                return .dictionary(d)
            }
        }

        public func deserialize(_ json: JSON) throws -> Visibility {
            switch json {
            case .dictionary(let d):
                let tag = try Serialization.getTag(d)
                switch tag {
                case "public":
                    return Visibility.public_
                case "team_only":
                    return Visibility.teamOnly
                case "password":
                    return Visibility.password
                case "team_and_password":
                    return Visibility.teamAndPassword
                case "shared_folder_only":
                    return Visibility.sharedFolderOnly
                case "other":
                    return Visibility.other
                default:
                    return Visibility.other
                }
            default:
                throw JSONSerializerError.deserializeError(type: Visibility.self, json: json)
            }
        }
    }

    /// The VisibilityPolicy struct
    public class VisibilityPolicy: CustomStringConvertible, JSONRepresentable {
        /// This is the value to submit when saving the visibility setting.
        public let policy: Sharing.RequestedVisibility
        /// This is what the effective policy would be, if you selected this option. The resolved policy is obtained
        /// after considering external effects such as shared folder settings and team policy. This value is
        /// guaranteed to be provided.
        public let resolvedPolicy: Sharing.AlphaResolvedVisibility
        /// Whether the user is permitted to set the visibility to this policy.
        public let allowed: Bool
        /// If allowed is false, this will provide the reason that the user is not permitted to set the visibility to
        /// this policy.
        public let disallowedReason: Sharing.VisibilityPolicyDisallowedReason?
        public init(
            policy: Sharing.RequestedVisibility,
            resolvedPolicy: Sharing.AlphaResolvedVisibility,
            allowed: Bool,
            disallowedReason: Sharing.VisibilityPolicyDisallowedReason? = nil
        ) {
            self.policy = policy
            self.resolvedPolicy = resolvedPolicy
            self.allowed = allowed
            self.disallowedReason = disallowedReason
        }

        func json() throws -> JSON {
            try VisibilityPolicySerializer().serialize(self)
        }

        public var description: String {
            do {
                return "\(SerializeUtil.prepareJSONForSerialization(try VisibilityPolicySerializer().serialize(self)))"
            } catch {
                return "Failed to generate description for VisibilityPolicy: \(error)"
            }
        }
    }

    public class VisibilityPolicySerializer: JSONSerializer {
        public init() {}
        public func serialize(_ value: VisibilityPolicy) throws -> JSON {
            let output = [
                "policy": try Sharing.RequestedVisibilitySerializer().serialize(value.policy),
                "resolved_policy": try Sharing.AlphaResolvedVisibilitySerializer().serialize(value.resolvedPolicy),
                "allowed": try Serialization._BoolSerializer.serialize(value.allowed),
                "disallowed_reason": try NullableSerializer(Sharing.VisibilityPolicyDisallowedReasonSerializer()).serialize(value.disallowedReason),
            ]
            return .dictionary(output)
        }

        public func deserialize(_ json: JSON) throws -> VisibilityPolicy {
            switch json {
            case .dictionary(let dict):
                let policy = try Sharing.RequestedVisibilitySerializer().deserialize(dict["policy"] ?? .null)
                let resolvedPolicy = try Sharing.AlphaResolvedVisibilitySerializer().deserialize(dict["resolved_policy"] ?? .null)
                let allowed = try Serialization._BoolSerializer.deserialize(dict["allowed"] ?? .null)
                let disallowedReason = try NullableSerializer(Sharing.VisibilityPolicyDisallowedReasonSerializer())
                    .deserialize(dict["disallowed_reason"] ?? .null)
                return VisibilityPolicy(policy: policy, resolvedPolicy: resolvedPolicy, allowed: allowed, disallowedReason: disallowedReason)
            default:
                throw JSONSerializerError.deserializeError(type: VisibilityPolicy.self, json: json)
            }
        }
    }

    /// Stone Route Objects

    static let addFileMember = Route(
        name: "add_file_member",
        version: 1,
        namespace: "sharing",
        deprecated: false,
        argSerializer: Sharing.AddFileMemberArgsSerializer(),
        responseSerializer: ArraySerializer(Sharing.FileMemberActionResultSerializer()),
        errorSerializer: Sharing.AddFileMemberErrorSerializer(),
        attributes: RouteAttributes(
            auth: [.user],
            host: .api,
            style: .rpc
        )
    )
    static let addFolderMember = Route(
        name: "add_folder_member",
        version: 1,
        namespace: "sharing",
        deprecated: false,
        argSerializer: Sharing.AddFolderMemberArgSerializer(),
        responseSerializer: Serialization._VoidSerializer,
        errorSerializer: Sharing.AddFolderMemberErrorSerializer(),
        attributes: RouteAttributes(
            auth: [.user],
            host: .api,
            style: .rpc
        )
    )
    static let checkJobStatus = Route(
        name: "check_job_status",
        version: 1,
        namespace: "sharing",
        deprecated: false,
        argSerializer: Async.PollArgSerializer(),
        responseSerializer: Sharing.JobStatusSerializer(),
        errorSerializer: Async.PollErrorSerializer(),
        attributes: RouteAttributes(
            auth: [.user],
            host: .api,
            style: .rpc
        )
    )
    static let checkRemoveMemberJobStatus = Route(
        name: "check_remove_member_job_status",
        version: 1,
        namespace: "sharing",
        deprecated: false,
        argSerializer: Async.PollArgSerializer(),
        responseSerializer: Sharing.RemoveMemberJobStatusSerializer(),
        errorSerializer: Async.PollErrorSerializer(),
        attributes: RouteAttributes(
            auth: [.user],
            host: .api,
            style: .rpc
        )
    )
    static let checkShareJobStatus = Route(
        name: "check_share_job_status",
        version: 1,
        namespace: "sharing",
        deprecated: false,
        argSerializer: Async.PollArgSerializer(),
        responseSerializer: Sharing.ShareFolderJobStatusSerializer(),
        errorSerializer: Async.PollErrorSerializer(),
        attributes: RouteAttributes(
            auth: [.user],
            host: .api,
            style: .rpc
        )
    )
    static let createSharedLink = Route(
        name: "create_shared_link",
        version: 1,
        namespace: "sharing",
        deprecated: true,
        argSerializer: Sharing.CreateSharedLinkArgSerializer(),
        responseSerializer: Sharing.PathLinkMetadataSerializer(),
        errorSerializer: Sharing.CreateSharedLinkErrorSerializer(),
        attributes: RouteAttributes(
            auth: [.user],
            host: .api,
            style: .rpc
        )
    )
    static let createSharedLinkWithSettings = Route(
        name: "create_shared_link_with_settings",
        version: 1,
        namespace: "sharing",
        deprecated: false,
        argSerializer: Sharing.CreateSharedLinkWithSettingsArgSerializer(),
        responseSerializer: Sharing.SharedLinkMetadataSerializer(),
        errorSerializer: Sharing.CreateSharedLinkWithSettingsErrorSerializer(),
        attributes: RouteAttributes(
            auth: [.user],
            host: .api,
            style: .rpc
        )
    )
    static let getFileMetadata = Route(
        name: "get_file_metadata",
        version: 1,
        namespace: "sharing",
        deprecated: false,
        argSerializer: Sharing.GetFileMetadataArgSerializer(),
        responseSerializer: Sharing.SharedFileMetadataSerializer(),
        errorSerializer: Sharing.GetFileMetadataErrorSerializer(),
        attributes: RouteAttributes(
            auth: [.user],
            host: .api,
            style: .rpc
        )
    )
    static let getFileMetadataBatch = Route(
        name: "get_file_metadata/batch",
        version: 1,
        namespace: "sharing",
        deprecated: false,
        argSerializer: Sharing.GetFileMetadataBatchArgSerializer(),
        responseSerializer: ArraySerializer(Sharing.GetFileMetadataBatchResultSerializer()),
        errorSerializer: Sharing.SharingUserErrorSerializer(),
        attributes: RouteAttributes(
            auth: [.user],
            host: .api,
            style: .rpc
        )
    )
    static let getFolderMetadata = Route(
        name: "get_folder_metadata",
        version: 1,
        namespace: "sharing",
        deprecated: false,
        argSerializer: Sharing.GetMetadataArgsSerializer(),
        responseSerializer: Sharing.SharedFolderMetadataSerializer(),
        errorSerializer: Sharing.SharedFolderAccessErrorSerializer(),
        attributes: RouteAttributes(
            auth: [.user],
            host: .api,
            style: .rpc
        )
    )
    static let getSharedLinkFile = Route(
        name: "get_shared_link_file",
        version: 1,
        namespace: "sharing",
        deprecated: false,
        argSerializer: Sharing.GetSharedLinkMetadataArgSerializer(),
        responseSerializer: Sharing.SharedLinkMetadataSerializer(),
        errorSerializer: Sharing.GetSharedLinkFileErrorSerializer(),
        attributes: RouteAttributes(
            auth: [.user],
            host: .content,
            style: .download
        )
    )
    static let getSharedLinkMetadata = Route(
        name: "get_shared_link_metadata",
        version: 1,
        namespace: "sharing",
        deprecated: false,
        argSerializer: Sharing.GetSharedLinkMetadataArgSerializer(),
        responseSerializer: Sharing.SharedLinkMetadataSerializer(),
        errorSerializer: Sharing.SharedLinkErrorSerializer(),
        attributes: RouteAttributes(
            auth: [.app, .user],
            host: .api,
            style: .rpc
        )
    )
    static let getSharedLinks = Route(
        name: "get_shared_links",
        version: 1,
        namespace: "sharing",
        deprecated: true,
        argSerializer: Sharing.GetSharedLinksArgSerializer(),
        responseSerializer: Sharing.GetSharedLinksResultSerializer(),
        errorSerializer: Sharing.GetSharedLinksErrorSerializer(),
        attributes: RouteAttributes(
            auth: [.user],
            host: .api,
            style: .rpc
        )
    )
    static let listFileMembers = Route(
        name: "list_file_members",
        version: 1,
        namespace: "sharing",
        deprecated: false,
        argSerializer: Sharing.ListFileMembersArgSerializer(),
        responseSerializer: Sharing.SharedFileMembersSerializer(),
        errorSerializer: Sharing.ListFileMembersErrorSerializer(),
        attributes: RouteAttributes(
            auth: [.user],
            host: .api,
            style: .rpc
        )
    )
    static let listFileMembersBatch = Route(
        name: "list_file_members/batch",
        version: 1,
        namespace: "sharing",
        deprecated: false,
        argSerializer: Sharing.ListFileMembersBatchArgSerializer(),
        responseSerializer: ArraySerializer(Sharing.ListFileMembersBatchResultSerializer()),
        errorSerializer: Sharing.SharingUserErrorSerializer(),
        attributes: RouteAttributes(
            auth: [.user],
            host: .api,
            style: .rpc
        )
    )
    static let listFileMembersContinue = Route(
        name: "list_file_members/continue",
        version: 1,
        namespace: "sharing",
        deprecated: false,
        argSerializer: Sharing.ListFileMembersContinueArgSerializer(),
        responseSerializer: Sharing.SharedFileMembersSerializer(),
        errorSerializer: Sharing.ListFileMembersContinueErrorSerializer(),
        attributes: RouteAttributes(
            auth: [.user],
            host: .api,
            style: .rpc
        )
    )
    static let listFolderMembers = Route(
        name: "list_folder_members",
        version: 1,
        namespace: "sharing",
        deprecated: false,
        argSerializer: Sharing.ListFolderMembersArgsSerializer(),
        responseSerializer: Sharing.SharedFolderMembersSerializer(),
        errorSerializer: Sharing.SharedFolderAccessErrorSerializer(),
        attributes: RouteAttributes(
            auth: [.user],
            host: .api,
            style: .rpc
        )
    )
    static let listFolderMembersContinue = Route(
        name: "list_folder_members/continue",
        version: 1,
        namespace: "sharing",
        deprecated: false,
        argSerializer: Sharing.ListFolderMembersContinueArgSerializer(),
        responseSerializer: Sharing.SharedFolderMembersSerializer(),
        errorSerializer: Sharing.ListFolderMembersContinueErrorSerializer(),
        attributes: RouteAttributes(
            auth: [.user],
            host: .api,
            style: .rpc
        )
    )
    static let listFolders = Route(
        name: "list_folders",
        version: 1,
        namespace: "sharing",
        deprecated: false,
        argSerializer: Sharing.ListFoldersArgsSerializer(),
        responseSerializer: Sharing.ListFoldersResultSerializer(),
        errorSerializer: Serialization._VoidSerializer,
        attributes: RouteAttributes(
            auth: [.user],
            host: .api,
            style: .rpc
        )
    )
    static let listFoldersContinue = Route(
        name: "list_folders/continue",
        version: 1,
        namespace: "sharing",
        deprecated: false,
        argSerializer: Sharing.ListFoldersContinueArgSerializer(),
        responseSerializer: Sharing.ListFoldersResultSerializer(),
        errorSerializer: Sharing.ListFoldersContinueErrorSerializer(),
        attributes: RouteAttributes(
            auth: [.user],
            host: .api,
            style: .rpc
        )
    )
    static let listMountableFolders = Route(
        name: "list_mountable_folders",
        version: 1,
        namespace: "sharing",
        deprecated: false,
        argSerializer: Sharing.ListFoldersArgsSerializer(),
        responseSerializer: Sharing.ListFoldersResultSerializer(),
        errorSerializer: Serialization._VoidSerializer,
        attributes: RouteAttributes(
            auth: [.user],
            host: .api,
            style: .rpc
        )
    )
    static let listMountableFoldersContinue = Route(
        name: "list_mountable_folders/continue",
        version: 1,
        namespace: "sharing",
        deprecated: false,
        argSerializer: Sharing.ListFoldersContinueArgSerializer(),
        responseSerializer: Sharing.ListFoldersResultSerializer(),
        errorSerializer: Sharing.ListFoldersContinueErrorSerializer(),
        attributes: RouteAttributes(
            auth: [.user],
            host: .api,
            style: .rpc
        )
    )
    static let listReceivedFiles = Route(
        name: "list_received_files",
        version: 1,
        namespace: "sharing",
        deprecated: false,
        argSerializer: Sharing.ListFilesArgSerializer(),
        responseSerializer: Sharing.ListFilesResultSerializer(),
        errorSerializer: Sharing.SharingUserErrorSerializer(),
        attributes: RouteAttributes(
            auth: [.user],
            host: .api,
            style: .rpc
        )
    )
    static let listReceivedFilesContinue = Route(
        name: "list_received_files/continue",
        version: 1,
        namespace: "sharing",
        deprecated: false,
        argSerializer: Sharing.ListFilesContinueArgSerializer(),
        responseSerializer: Sharing.ListFilesResultSerializer(),
        errorSerializer: Sharing.ListFilesContinueErrorSerializer(),
        attributes: RouteAttributes(
            auth: [.user],
            host: .api,
            style: .rpc
        )
    )
    static let listSharedLinks = Route(
        name: "list_shared_links",
        version: 1,
        namespace: "sharing",
        deprecated: false,
        argSerializer: Sharing.ListSharedLinksArgSerializer(),
        responseSerializer: Sharing.ListSharedLinksResultSerializer(),
        errorSerializer: Sharing.ListSharedLinksErrorSerializer(),
        attributes: RouteAttributes(
            auth: [.user],
            host: .api,
            style: .rpc
        )
    )
    static let modifySharedLinkSettings = Route(
        name: "modify_shared_link_settings",
        version: 1,
        namespace: "sharing",
        deprecated: false,
        argSerializer: Sharing.ModifySharedLinkSettingsArgsSerializer(),
        responseSerializer: Sharing.SharedLinkMetadataSerializer(),
        errorSerializer: Sharing.ModifySharedLinkSettingsErrorSerializer(),
        attributes: RouteAttributes(
            auth: [.user],
            host: .api,
            style: .rpc
        )
    )
    static let mountFolder = Route(
        name: "mount_folder",
        version: 1,
        namespace: "sharing",
        deprecated: false,
        argSerializer: Sharing.MountFolderArgSerializer(),
        responseSerializer: Sharing.SharedFolderMetadataSerializer(),
        errorSerializer: Sharing.MountFolderErrorSerializer(),
        attributes: RouteAttributes(
            auth: [.user],
            host: .api,
            style: .rpc
        )
    )
    static let relinquishFileMembership = Route(
        name: "relinquish_file_membership",
        version: 1,
        namespace: "sharing",
        deprecated: false,
        argSerializer: Sharing.RelinquishFileMembershipArgSerializer(),
        responseSerializer: Serialization._VoidSerializer,
        errorSerializer: Sharing.RelinquishFileMembershipErrorSerializer(),
        attributes: RouteAttributes(
            auth: [.user],
            host: .api,
            style: .rpc
        )
    )
    static let relinquishFolderMembership = Route(
        name: "relinquish_folder_membership",
        version: 1,
        namespace: "sharing",
        deprecated: false,
        argSerializer: Sharing.RelinquishFolderMembershipArgSerializer(),
        responseSerializer: Async.LaunchEmptyResultSerializer(),
        errorSerializer: Sharing.RelinquishFolderMembershipErrorSerializer(),
        attributes: RouteAttributes(
            auth: [.user],
            host: .api,
            style: .rpc
        )
    )
    static let removeFileMember = Route(
        name: "remove_file_member",
        version: 1,
        namespace: "sharing",
        deprecated: true,
        argSerializer: Sharing.RemoveFileMemberArgSerializer(),
        responseSerializer: Sharing.FileMemberActionIndividualResultSerializer(),
        errorSerializer: Sharing.RemoveFileMemberErrorSerializer(),
        attributes: RouteAttributes(
            auth: [.user],
            host: .api,
            style: .rpc
        )
    )
    static let removeFileMember2 = Route(
        name: "remove_file_member_2",
        version: 1,
        namespace: "sharing",
        deprecated: false,
        argSerializer: Sharing.RemoveFileMemberArgSerializer(),
        responseSerializer: Sharing.FileMemberRemoveActionResultSerializer(),
        errorSerializer: Sharing.RemoveFileMemberErrorSerializer(),
        attributes: RouteAttributes(
            auth: [.user],
            host: .api,
            style: .rpc
        )
    )
    static let removeFolderMember = Route(
        name: "remove_folder_member",
        version: 1,
        namespace: "sharing",
        deprecated: false,
        argSerializer: Sharing.RemoveFolderMemberArgSerializer(),
        responseSerializer: Async.LaunchResultBaseSerializer(),
        errorSerializer: Sharing.RemoveFolderMemberErrorSerializer(),
        attributes: RouteAttributes(
            auth: [.user],
            host: .api,
            style: .rpc
        )
    )
    static let revokeSharedLink = Route(
        name: "revoke_shared_link",
        version: 1,
        namespace: "sharing",
        deprecated: false,
        argSerializer: Sharing.RevokeSharedLinkArgSerializer(),
        responseSerializer: Serialization._VoidSerializer,
        errorSerializer: Sharing.RevokeSharedLinkErrorSerializer(),
        attributes: RouteAttributes(
            auth: [.user],
            host: .api,
            style: .rpc
        )
    )
    static let setAccessInheritance = Route(
        name: "set_access_inheritance",
        version: 1,
        namespace: "sharing",
        deprecated: false,
        argSerializer: Sharing.SetAccessInheritanceArgSerializer(),
        responseSerializer: Sharing.ShareFolderLaunchSerializer(),
        errorSerializer: Sharing.SetAccessInheritanceErrorSerializer(),
        attributes: RouteAttributes(
            auth: [.user],
            host: .api,
            style: .rpc
        )
    )
    static let shareFolder = Route(
        name: "share_folder",
        version: 1,
        namespace: "sharing",
        deprecated: false,
        argSerializer: Sharing.ShareFolderArgSerializer(),
        responseSerializer: Sharing.ShareFolderLaunchSerializer(),
        errorSerializer: Sharing.ShareFolderErrorSerializer(),
        attributes: RouteAttributes(
            auth: [.user],
            host: .api,
            style: .rpc
        )
    )
    static let transferFolder = Route(
        name: "transfer_folder",
        version: 1,
        namespace: "sharing",
        deprecated: false,
        argSerializer: Sharing.TransferFolderArgSerializer(),
        responseSerializer: Serialization._VoidSerializer,
        errorSerializer: Sharing.TransferFolderErrorSerializer(),
        attributes: RouteAttributes(
            auth: [.user],
            host: .api,
            style: .rpc
        )
    )
    static let unmountFolder = Route(
        name: "unmount_folder",
        version: 1,
        namespace: "sharing",
        deprecated: false,
        argSerializer: Sharing.UnmountFolderArgSerializer(),
        responseSerializer: Serialization._VoidSerializer,
        errorSerializer: Sharing.UnmountFolderErrorSerializer(),
        attributes: RouteAttributes(
            auth: [.user],
            host: .api,
            style: .rpc
        )
    )
    static let unshareFile = Route(
        name: "unshare_file",
        version: 1,
        namespace: "sharing",
        deprecated: false,
        argSerializer: Sharing.UnshareFileArgSerializer(),
        responseSerializer: Serialization._VoidSerializer,
        errorSerializer: Sharing.UnshareFileErrorSerializer(),
        attributes: RouteAttributes(
            auth: [.user],
            host: .api,
            style: .rpc
        )
    )
    static let unshareFolder = Route(
        name: "unshare_folder",
        version: 1,
        namespace: "sharing",
        deprecated: false,
        argSerializer: Sharing.UnshareFolderArgSerializer(),
        responseSerializer: Async.LaunchEmptyResultSerializer(),
        errorSerializer: Sharing.UnshareFolderErrorSerializer(),
        attributes: RouteAttributes(
            auth: [.user],
            host: .api,
            style: .rpc
        )
    )
    static let updateFileMember = Route(
        name: "update_file_member",
        version: 1,
        namespace: "sharing",
        deprecated: false,
        argSerializer: Sharing.UpdateFileMemberArgsSerializer(),
        responseSerializer: Sharing.MemberAccessLevelResultSerializer(),
        errorSerializer: Sharing.FileMemberActionErrorSerializer(),
        attributes: RouteAttributes(
            auth: [.user],
            host: .api,
            style: .rpc
        )
    )
    static let updateFolderMember = Route(
        name: "update_folder_member",
        version: 1,
        namespace: "sharing",
        deprecated: false,
        argSerializer: Sharing.UpdateFolderMemberArgSerializer(),
        responseSerializer: Sharing.MemberAccessLevelResultSerializer(),
        errorSerializer: Sharing.UpdateFolderMemberErrorSerializer(),
        attributes: RouteAttributes(
            auth: [.user],
            host: .api,
            style: .rpc
        )
    )
    static let updateFolderPolicy = Route(
        name: "update_folder_policy",
        version: 1,
        namespace: "sharing",
        deprecated: false,
        argSerializer: Sharing.UpdateFolderPolicyArgSerializer(),
        responseSerializer: Sharing.SharedFolderMetadataSerializer(),
        errorSerializer: Sharing.UpdateFolderPolicyErrorSerializer(),
        attributes: RouteAttributes(
            auth: [.user],
            host: .api,
            style: .rpc
        )
    )
}
