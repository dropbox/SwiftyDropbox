///
/// Copyright (c) 2016 Dropbox, Inc. All rights reserved.
///
/// Auto-generated by Stone, do not modify.
///

import Foundation

/// Datatypes and serializers for the users namespace
open class Users {
    /// The amount of detail revealed about an account depends on the user being queried and the user making the query.
    open class Account: CustomStringConvertible {
        /// The user's unique Dropbox ID.
        open let accountId: String
        /// Details of a user's name.
        open let name: Users.Name
        /// The user's e-mail address. Do not rely on this without checking the emailVerified field. Even then, it's
        /// possible that the user has since lost access to their e-mail.
        open let email: String
        /// Whether the user has verified their e-mail address.
        open let emailVerified: Bool
        /// URL for the photo representing the user, if one is set.
        open let profilePhotoUrl: String?
        /// Whether the user has been disabled.
        open let disabled: Bool
        public init(accountId: String, name: Users.Name, email: String, emailVerified: Bool, disabled: Bool, profilePhotoUrl: String? = nil) {
            stringValidator(minLength: 40, maxLength: 40)(accountId)
            self.accountId = accountId
            self.name = name
            stringValidator()(email)
            self.email = email
            self.emailVerified = emailVerified
            nullableValidator(stringValidator())(profilePhotoUrl)
            self.profilePhotoUrl = profilePhotoUrl
            self.disabled = disabled
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(AccountSerializer().serialize(self)))"
        }
    }
    open class AccountSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: Account) -> JSON {
            let output = [ 
            "account_id": Serialization._StringSerializer.serialize(value.accountId),
            "name": Users.NameSerializer().serialize(value.name),
            "email": Serialization._StringSerializer.serialize(value.email),
            "email_verified": Serialization._BoolSerializer.serialize(value.emailVerified),
            "disabled": Serialization._BoolSerializer.serialize(value.disabled),
            "profile_photo_url": NullableSerializer(Serialization._StringSerializer).serialize(value.profilePhotoUrl),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> Account {
            switch json {
                case .dictionary(let dict):
                    let accountId = Serialization._StringSerializer.deserialize(dict["account_id"] ?? .null)
                    let name = Users.NameSerializer().deserialize(dict["name"] ?? .null)
                    let email = Serialization._StringSerializer.deserialize(dict["email"] ?? .null)
                    let emailVerified = Serialization._BoolSerializer.deserialize(dict["email_verified"] ?? .null)
                    let disabled = Serialization._BoolSerializer.deserialize(dict["disabled"] ?? .null)
                    let profilePhotoUrl = NullableSerializer(Serialization._StringSerializer).deserialize(dict["profile_photo_url"] ?? .null)
                    return Account(accountId: accountId, name: name, email: email, emailVerified: emailVerified, disabled: disabled, profilePhotoUrl: profilePhotoUrl)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Basic information about any account.
    open class BasicAccount: Users.Account {
        /// Whether this user is a teammate of the current user. If this account is the current user's account, then
        /// this will be true.
        open let isTeammate: Bool
        /// The user's unique team member id. This field will only be present if the user is part of a team and
        /// isTeammate is true.
        open let teamMemberId: String?
        public init(accountId: String, name: Users.Name, email: String, emailVerified: Bool, disabled: Bool, isTeammate: Bool, profilePhotoUrl: String? = nil, teamMemberId: String? = nil) {
            self.isTeammate = isTeammate
            nullableValidator(stringValidator())(teamMemberId)
            self.teamMemberId = teamMemberId
            super.init(accountId: accountId, name: name, email: email, emailVerified: emailVerified, disabled: disabled, profilePhotoUrl: profilePhotoUrl)
        }
        open override var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(BasicAccountSerializer().serialize(self)))"
        }
    }
    open class BasicAccountSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: BasicAccount) -> JSON {
            let output = [ 
            "account_id": Serialization._StringSerializer.serialize(value.accountId),
            "name": Users.NameSerializer().serialize(value.name),
            "email": Serialization._StringSerializer.serialize(value.email),
            "email_verified": Serialization._BoolSerializer.serialize(value.emailVerified),
            "disabled": Serialization._BoolSerializer.serialize(value.disabled),
            "is_teammate": Serialization._BoolSerializer.serialize(value.isTeammate),
            "profile_photo_url": NullableSerializer(Serialization._StringSerializer).serialize(value.profilePhotoUrl),
            "team_member_id": NullableSerializer(Serialization._StringSerializer).serialize(value.teamMemberId),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> BasicAccount {
            switch json {
                case .dictionary(let dict):
                    let accountId = Serialization._StringSerializer.deserialize(dict["account_id"] ?? .null)
                    let name = Users.NameSerializer().deserialize(dict["name"] ?? .null)
                    let email = Serialization._StringSerializer.deserialize(dict["email"] ?? .null)
                    let emailVerified = Serialization._BoolSerializer.deserialize(dict["email_verified"] ?? .null)
                    let disabled = Serialization._BoolSerializer.deserialize(dict["disabled"] ?? .null)
                    let isTeammate = Serialization._BoolSerializer.deserialize(dict["is_teammate"] ?? .null)
                    let profilePhotoUrl = NullableSerializer(Serialization._StringSerializer).deserialize(dict["profile_photo_url"] ?? .null)
                    let teamMemberId = NullableSerializer(Serialization._StringSerializer).deserialize(dict["team_member_id"] ?? .null)
                    return BasicAccount(accountId: accountId, name: name, email: email, emailVerified: emailVerified, disabled: disabled, isTeammate: isTeammate, profilePhotoUrl: profilePhotoUrl, teamMemberId: teamMemberId)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Detailed information about the current user's account.
    open class FullAccount: Users.Account {
        /// The user's two-letter country code, if available. Country codes are based on ISO 3166-1
        /// http://en.wikipedia.org/wiki/ISO_3166-1.
        open let country: String?
        /// The language that the user specified. Locale tags will be IETF language tags
        /// http://en.wikipedia.org/wiki/IETF_language_tag.
        open let locale: String
        /// The user's referral link https://www.dropbox.com/referrals.
        open let referralLink: String
        /// If this account is a member of a team, information about that team.
        open let team: Users.FullTeam?
        /// This account's unique team member id. This field will only be present if team is present.
        open let teamMemberId: String?
        /// Whether the user has a personal and work account. If the current account is personal, then team will always
        /// be null, but isPaired will indicate if a work account is linked.
        open let isPaired: Bool
        /// What type of account this user has.
        open let accountType: UsersCommon.AccountType
        /// The root info for this account.
        open let rootInfo: Common.RootInfo
        public init(accountId: String, name: Users.Name, email: String, emailVerified: Bool, disabled: Bool, locale: String, referralLink: String, isPaired: Bool, accountType: UsersCommon.AccountType, rootInfo: Common.RootInfo, profilePhotoUrl: String? = nil, country: String? = nil, team: Users.FullTeam? = nil, teamMemberId: String? = nil) {
            nullableValidator(stringValidator(minLength: 2, maxLength: 2))(country)
            self.country = country
            stringValidator(minLength: 2)(locale)
            self.locale = locale
            stringValidator()(referralLink)
            self.referralLink = referralLink
            self.team = team
            nullableValidator(stringValidator())(teamMemberId)
            self.teamMemberId = teamMemberId
            self.isPaired = isPaired
            self.accountType = accountType
            self.rootInfo = rootInfo
            super.init(accountId: accountId, name: name, email: email, emailVerified: emailVerified, disabled: disabled, profilePhotoUrl: profilePhotoUrl)
        }
        open override var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(FullAccountSerializer().serialize(self)))"
        }
    }
    open class FullAccountSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: FullAccount) -> JSON {
            let output = [ 
            "account_id": Serialization._StringSerializer.serialize(value.accountId),
            "name": Users.NameSerializer().serialize(value.name),
            "email": Serialization._StringSerializer.serialize(value.email),
            "email_verified": Serialization._BoolSerializer.serialize(value.emailVerified),
            "disabled": Serialization._BoolSerializer.serialize(value.disabled),
            "locale": Serialization._StringSerializer.serialize(value.locale),
            "referral_link": Serialization._StringSerializer.serialize(value.referralLink),
            "is_paired": Serialization._BoolSerializer.serialize(value.isPaired),
            "account_type": UsersCommon.AccountTypeSerializer().serialize(value.accountType),
            "root_info": Common.RootInfoSerializer().serialize(value.rootInfo),
            "profile_photo_url": NullableSerializer(Serialization._StringSerializer).serialize(value.profilePhotoUrl),
            "country": NullableSerializer(Serialization._StringSerializer).serialize(value.country),
            "team": NullableSerializer(Users.FullTeamSerializer()).serialize(value.team),
            "team_member_id": NullableSerializer(Serialization._StringSerializer).serialize(value.teamMemberId),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> FullAccount {
            switch json {
                case .dictionary(let dict):
                    let accountId = Serialization._StringSerializer.deserialize(dict["account_id"] ?? .null)
                    let name = Users.NameSerializer().deserialize(dict["name"] ?? .null)
                    let email = Serialization._StringSerializer.deserialize(dict["email"] ?? .null)
                    let emailVerified = Serialization._BoolSerializer.deserialize(dict["email_verified"] ?? .null)
                    let disabled = Serialization._BoolSerializer.deserialize(dict["disabled"] ?? .null)
                    let locale = Serialization._StringSerializer.deserialize(dict["locale"] ?? .null)
                    let referralLink = Serialization._StringSerializer.deserialize(dict["referral_link"] ?? .null)
                    let isPaired = Serialization._BoolSerializer.deserialize(dict["is_paired"] ?? .null)
                    let accountType = UsersCommon.AccountTypeSerializer().deserialize(dict["account_type"] ?? .null)
                    let rootInfo = Common.RootInfoSerializer().deserialize(dict["root_info"] ?? .null)
                    let profilePhotoUrl = NullableSerializer(Serialization._StringSerializer).deserialize(dict["profile_photo_url"] ?? .null)
                    let country = NullableSerializer(Serialization._StringSerializer).deserialize(dict["country"] ?? .null)
                    let team = NullableSerializer(Users.FullTeamSerializer()).deserialize(dict["team"] ?? .null)
                    let teamMemberId = NullableSerializer(Serialization._StringSerializer).deserialize(dict["team_member_id"] ?? .null)
                    return FullAccount(accountId: accountId, name: name, email: email, emailVerified: emailVerified, disabled: disabled, locale: locale, referralLink: referralLink, isPaired: isPaired, accountType: accountType, rootInfo: rootInfo, profilePhotoUrl: profilePhotoUrl, country: country, team: team, teamMemberId: teamMemberId)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Information about a team.
    open class Team: CustomStringConvertible {
        /// The team's unique ID.
        open let id: String
        /// The name of the team.
        open let name: String
        public init(id: String, name: String) {
            stringValidator()(id)
            self.id = id
            stringValidator()(name)
            self.name = name
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(TeamSerializer().serialize(self)))"
        }
    }
    open class TeamSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: Team) -> JSON {
            let output = [ 
            "id": Serialization._StringSerializer.serialize(value.id),
            "name": Serialization._StringSerializer.serialize(value.name),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> Team {
            switch json {
                case .dictionary(let dict):
                    let id = Serialization._StringSerializer.deserialize(dict["id"] ?? .null)
                    let name = Serialization._StringSerializer.deserialize(dict["name"] ?? .null)
                    return Team(id: id, name: name)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Detailed information about a team.
    open class FullTeam: Users.Team {
        /// Team policies governing sharing.
        open let sharingPolicies: TeamPolicies.TeamSharingPolicies
        /// Team policy governing the use of the Office Add-In.
        open let officeAddinPolicy: TeamPolicies.OfficeAddInPolicy
        public init(id: String, name: String, sharingPolicies: TeamPolicies.TeamSharingPolicies, officeAddinPolicy: TeamPolicies.OfficeAddInPolicy) {
            self.sharingPolicies = sharingPolicies
            self.officeAddinPolicy = officeAddinPolicy
            super.init(id: id, name: name)
        }
        open override var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(FullTeamSerializer().serialize(self)))"
        }
    }
    open class FullTeamSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: FullTeam) -> JSON {
            let output = [ 
            "id": Serialization._StringSerializer.serialize(value.id),
            "name": Serialization._StringSerializer.serialize(value.name),
            "sharing_policies": TeamPolicies.TeamSharingPoliciesSerializer().serialize(value.sharingPolicies),
            "office_addin_policy": TeamPolicies.OfficeAddInPolicySerializer().serialize(value.officeAddinPolicy),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> FullTeam {
            switch json {
                case .dictionary(let dict):
                    let id = Serialization._StringSerializer.deserialize(dict["id"] ?? .null)
                    let name = Serialization._StringSerializer.deserialize(dict["name"] ?? .null)
                    let sharingPolicies = TeamPolicies.TeamSharingPoliciesSerializer().deserialize(dict["sharing_policies"] ?? .null)
                    let officeAddinPolicy = TeamPolicies.OfficeAddInPolicySerializer().deserialize(dict["office_addin_policy"] ?? .null)
                    return FullTeam(id: id, name: name, sharingPolicies: sharingPolicies, officeAddinPolicy: officeAddinPolicy)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The GetAccountArg struct
    open class GetAccountArg: CustomStringConvertible {
        /// A user's account identifier.
        open let accountId: String
        public init(accountId: String) {
            stringValidator(minLength: 40, maxLength: 40)(accountId)
            self.accountId = accountId
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GetAccountArgSerializer().serialize(self)))"
        }
    }
    open class GetAccountArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GetAccountArg) -> JSON {
            let output = [ 
            "account_id": Serialization._StringSerializer.serialize(value.accountId),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> GetAccountArg {
            switch json {
                case .dictionary(let dict):
                    let accountId = Serialization._StringSerializer.deserialize(dict["account_id"] ?? .null)
                    return GetAccountArg(accountId: accountId)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The GetAccountBatchArg struct
    open class GetAccountBatchArg: CustomStringConvertible {
        /// List of user account identifiers.  Should not contain any duplicate account IDs.
        open let accountIds: Array<String>
        public init(accountIds: Array<String>) {
            arrayValidator(minItems: 1, itemValidator: stringValidator(minLength: 40, maxLength: 40))(accountIds)
            self.accountIds = accountIds
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GetAccountBatchArgSerializer().serialize(self)))"
        }
    }
    open class GetAccountBatchArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GetAccountBatchArg) -> JSON {
            let output = [ 
            "account_ids": ArraySerializer(Serialization._StringSerializer).serialize(value.accountIds),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> GetAccountBatchArg {
            switch json {
                case .dictionary(let dict):
                    let accountIds = ArraySerializer(Serialization._StringSerializer).deserialize(dict["account_ids"] ?? .null)
                    return GetAccountBatchArg(accountIds: accountIds)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The GetAccountBatchError union
    public enum GetAccountBatchError: CustomStringConvertible {
        /// The value is an account ID specified in accountIds in GetAccountBatchArg that does not exist.
        case noAccount(String)
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GetAccountBatchErrorSerializer().serialize(self)))"
        }
    }
    open class GetAccountBatchErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GetAccountBatchError) -> JSON {
            switch value {
                case .noAccount(let arg):
                    var d = ["no_account": Serialization._StringSerializer.serialize(arg)]
                    d[".tag"] = .str("no_account")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> GetAccountBatchError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "no_account":
                            let v = Serialization._StringSerializer.deserialize(d["no_account"] ?? .null)
                            return GetAccountBatchError.noAccount(v)
                        case "other":
                            return GetAccountBatchError.other
                        default:
                            return GetAccountBatchError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The GetAccountError union
    public enum GetAccountError: CustomStringConvertible {
        /// The specified accountId in GetAccountArg does not exist.
        case noAccount
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GetAccountErrorSerializer().serialize(self)))"
        }
    }
    open class GetAccountErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GetAccountError) -> JSON {
            switch value {
                case .noAccount:
                    var d = [String: JSON]()
                    d[".tag"] = .str("no_account")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> GetAccountError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "no_account":
                            return GetAccountError.noAccount
                        case "other":
                            return GetAccountError.other
                        default:
                            return GetAccountError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The IndividualSpaceAllocation struct
    open class IndividualSpaceAllocation: CustomStringConvertible {
        /// The total space allocated to the user's account (bytes).
        open let allocated: UInt64
        public init(allocated: UInt64) {
            comparableValidator()(allocated)
            self.allocated = allocated
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(IndividualSpaceAllocationSerializer().serialize(self)))"
        }
    }
    open class IndividualSpaceAllocationSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: IndividualSpaceAllocation) -> JSON {
            let output = [ 
            "allocated": Serialization._UInt64Serializer.serialize(value.allocated),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> IndividualSpaceAllocation {
            switch json {
                case .dictionary(let dict):
                    let allocated = Serialization._UInt64Serializer.deserialize(dict["allocated"] ?? .null)
                    return IndividualSpaceAllocation(allocated: allocated)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Representations for a person's name to assist with internationalization.
    open class Name: CustomStringConvertible {
        /// Also known as a first name.
        open let givenName: String
        /// Also known as a last name or family name.
        open let surname: String
        /// Locale-dependent name. In the US, a person's familiar name is their givenName, but elsewhere, it could be
        /// any combination of a person's givenName and surname.
        open let familiarName: String
        /// A name that can be used directly to represent the name of a user's Dropbox account.
        open let displayName: String
        /// An abbreviated form of the person's name. Their initials in most locales.
        open let abbreviatedName: String
        public init(givenName: String, surname: String, familiarName: String, displayName: String, abbreviatedName: String) {
            stringValidator()(givenName)
            self.givenName = givenName
            stringValidator()(surname)
            self.surname = surname
            stringValidator()(familiarName)
            self.familiarName = familiarName
            stringValidator()(displayName)
            self.displayName = displayName
            stringValidator()(abbreviatedName)
            self.abbreviatedName = abbreviatedName
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(NameSerializer().serialize(self)))"
        }
    }
    open class NameSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: Name) -> JSON {
            let output = [ 
            "given_name": Serialization._StringSerializer.serialize(value.givenName),
            "surname": Serialization._StringSerializer.serialize(value.surname),
            "familiar_name": Serialization._StringSerializer.serialize(value.familiarName),
            "display_name": Serialization._StringSerializer.serialize(value.displayName),
            "abbreviated_name": Serialization._StringSerializer.serialize(value.abbreviatedName),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> Name {
            switch json {
                case .dictionary(let dict):
                    let givenName = Serialization._StringSerializer.deserialize(dict["given_name"] ?? .null)
                    let surname = Serialization._StringSerializer.deserialize(dict["surname"] ?? .null)
                    let familiarName = Serialization._StringSerializer.deserialize(dict["familiar_name"] ?? .null)
                    let displayName = Serialization._StringSerializer.deserialize(dict["display_name"] ?? .null)
                    let abbreviatedName = Serialization._StringSerializer.deserialize(dict["abbreviated_name"] ?? .null)
                    return Name(givenName: givenName, surname: surname, familiarName: familiarName, displayName: displayName, abbreviatedName: abbreviatedName)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Space is allocated differently based on the type of account.
    public enum SpaceAllocation: CustomStringConvertible {
        /// The user's space allocation applies only to their individual account.
        case individual(Users.IndividualSpaceAllocation)
        /// The user shares space with other members of their team.
        case team(Users.TeamSpaceAllocation)
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SpaceAllocationSerializer().serialize(self)))"
        }
    }
    open class SpaceAllocationSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SpaceAllocation) -> JSON {
            switch value {
                case .individual(let arg):
                    var d = Serialization.getFields(Users.IndividualSpaceAllocationSerializer().serialize(arg))
                    d[".tag"] = .str("individual")
                    return .dictionary(d)
                case .team(let arg):
                    var d = Serialization.getFields(Users.TeamSpaceAllocationSerializer().serialize(arg))
                    d[".tag"] = .str("team")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> SpaceAllocation {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "individual":
                            let v = Users.IndividualSpaceAllocationSerializer().deserialize(json)
                            return SpaceAllocation.individual(v)
                        case "team":
                            let v = Users.TeamSpaceAllocationSerializer().deserialize(json)
                            return SpaceAllocation.team(v)
                        case "other":
                            return SpaceAllocation.other
                        default:
                            return SpaceAllocation.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Information about a user's space usage and quota.
    open class SpaceUsage: CustomStringConvertible {
        /// The user's total space usage (bytes).
        open let used: UInt64
        /// The user's space allocation.
        open let allocation: Users.SpaceAllocation
        public init(used: UInt64, allocation: Users.SpaceAllocation) {
            comparableValidator()(used)
            self.used = used
            self.allocation = allocation
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(SpaceUsageSerializer().serialize(self)))"
        }
    }
    open class SpaceUsageSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SpaceUsage) -> JSON {
            let output = [ 
            "used": Serialization._UInt64Serializer.serialize(value.used),
            "allocation": Users.SpaceAllocationSerializer().serialize(value.allocation),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SpaceUsage {
            switch json {
                case .dictionary(let dict):
                    let used = Serialization._UInt64Serializer.deserialize(dict["used"] ?? .null)
                    let allocation = Users.SpaceAllocationSerializer().deserialize(dict["allocation"] ?? .null)
                    return SpaceUsage(used: used, allocation: allocation)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The TeamSpaceAllocation struct
    open class TeamSpaceAllocation: CustomStringConvertible {
        /// The total space currently used by the user's team (bytes).
        open let used: UInt64
        /// The total space allocated to the user's team (bytes).
        open let allocated: UInt64
        /// The total space allocated to the user within its team allocated space (0 means that no restriction is
        /// imposed on the user's quota within its team).
        open let userWithinTeamSpaceAllocated: UInt64
        /// The type of the space limit imposed on the team member (off, alert_only, stop_sync).
        open let userWithinTeamSpaceLimitType: TeamCommon.MemberSpaceLimitType
        public init(used: UInt64, allocated: UInt64, userWithinTeamSpaceAllocated: UInt64, userWithinTeamSpaceLimitType: TeamCommon.MemberSpaceLimitType) {
            comparableValidator()(used)
            self.used = used
            comparableValidator()(allocated)
            self.allocated = allocated
            comparableValidator()(userWithinTeamSpaceAllocated)
            self.userWithinTeamSpaceAllocated = userWithinTeamSpaceAllocated
            self.userWithinTeamSpaceLimitType = userWithinTeamSpaceLimitType
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(TeamSpaceAllocationSerializer().serialize(self)))"
        }
    }
    open class TeamSpaceAllocationSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: TeamSpaceAllocation) -> JSON {
            let output = [ 
            "used": Serialization._UInt64Serializer.serialize(value.used),
            "allocated": Serialization._UInt64Serializer.serialize(value.allocated),
            "user_within_team_space_allocated": Serialization._UInt64Serializer.serialize(value.userWithinTeamSpaceAllocated),
            "user_within_team_space_limit_type": TeamCommon.MemberSpaceLimitTypeSerializer().serialize(value.userWithinTeamSpaceLimitType),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> TeamSpaceAllocation {
            switch json {
                case .dictionary(let dict):
                    let used = Serialization._UInt64Serializer.deserialize(dict["used"] ?? .null)
                    let allocated = Serialization._UInt64Serializer.deserialize(dict["allocated"] ?? .null)
                    let userWithinTeamSpaceAllocated = Serialization._UInt64Serializer.deserialize(dict["user_within_team_space_allocated"] ?? .null)
                    let userWithinTeamSpaceLimitType = TeamCommon.MemberSpaceLimitTypeSerializer().deserialize(dict["user_within_team_space_limit_type"] ?? .null)
                    return TeamSpaceAllocation(used: used, allocated: allocated, userWithinTeamSpaceAllocated: userWithinTeamSpaceAllocated, userWithinTeamSpaceLimitType: userWithinTeamSpaceLimitType)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }


    /// Stone Route Objects

    static let getAccount = Route(
        name: "get_account",
        namespace: "users",
        deprecated: false,
        argSerializer: Users.GetAccountArgSerializer(),
        responseSerializer: Users.BasicAccountSerializer(),
        errorSerializer: Users.GetAccountErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let getAccountBatch = Route(
        name: "get_account_batch",
        namespace: "users",
        deprecated: false,
        argSerializer: Users.GetAccountBatchArgSerializer(),
        responseSerializer: ArraySerializer(Users.BasicAccountSerializer()),
        errorSerializer: Users.GetAccountBatchErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let getCurrentAccount = Route(
        name: "get_current_account",
        namespace: "users",
        deprecated: false,
        argSerializer: Serialization._VoidSerializer,
        responseSerializer: Users.FullAccountSerializer(),
        errorSerializer: Serialization._VoidSerializer,
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let getSpaceUsage = Route(
        name: "get_space_usage",
        namespace: "users",
        deprecated: false,
        argSerializer: Serialization._VoidSerializer,
        responseSerializer: Users.SpaceUsageSerializer(),
        errorSerializer: Serialization._VoidSerializer,
        attrs: ["host": "api",
                "style": "rpc"]
    )
}
