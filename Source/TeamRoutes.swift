///
/// Auto-generated by Stone, do not modify.
///

/// Routes for the team namespace
public class TeamRoutes {
    public let client: DropboxTransportClient
    init(client: DropboxTransportClient) {
        self.client = client
    }

    /// Creates a new, empty group, with a requested name. Permission : Team member management
    ///
    /// - parameter groupName: Group name.
    /// - parameter groupExternalId: The creator of a team can associate an arbitrary external ID to the group.
    /// - parameter groupManagementType: Whether the team can be managed by selected users, or only by team admins
    ///
    ///  - returns: Through the response callback, the caller will receive a `Team.GroupFullInfo` object on success or a
    /// `Team.GroupCreateError` object on failure.
    public func alphaGroupsCreate(groupName groupName: String, groupExternalId: String? = nil, groupManagementType: TeamCommon.GroupManagementType? = nil) -> RpcRequest<Team.GroupFullInfoSerializer, Team.GroupCreateErrorSerializer> {
        let route = Team.alphaGroupsCreate
        let serverArgs = Team.GroupCreateArg(groupName: groupName, groupExternalId: groupExternalId, groupManagementType: groupManagementType)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Retrieves information about one or more groups. Permission : Team Information
    ///
    /// - parameter groupsSelector: Argument for selecting a list of groups, either by group_ids, or external group IDs.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Array<Team.GroupsGetInfoItem>` object on
    /// success or a `Team.GroupsGetInfoError` object on failure.
    public func alphaGroupsGetInfo(groupsSelector groupsSelector: Team.GroupsSelector) -> RpcRequest<ArraySerializer<Team.GroupsGetInfoItemSerializer>, Team.GroupsGetInfoErrorSerializer> {
        let route = Team.alphaGroupsGetInfo
        let serverArgs = groupsSelector
        return client.request(route, serverArgs: serverArgs)
    }

    /// Lists groups on a team. Permission : Team Information
    ///
    /// - parameter limit: Number of results to return per call.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Team.GroupsListResult` object on success
    /// or a `Void` object on failure.
    public func alphaGroupsList(limit: UInt32 = 1000) -> RpcRequest<Team.GroupsListResultSerializer, VoidSerializer> {
        let route = Team.alphaGroupsList
        let serverArgs = Team.GroupsListArg(limit: limit)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Once a cursor has been retrieved from alphaGroupsList, use this to paginate through all groups. Permission :
    /// Team information
    ///
    /// - parameter cursor: Indicates from what point to get the next set of groups.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Team.GroupsListResult` object on success
    /// or a `Team.GroupsListContinueError` object on failure.
    public func alphaGroupsListContinue(cursor cursor: String) -> RpcRequest<Team.GroupsListResultSerializer, Team.GroupsListContinueErrorSerializer> {
        let route = Team.alphaGroupsListContinue
        let serverArgs = Team.GroupsListContinueArg(cursor: cursor)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Updates a group's name, external ID or management type. Permission : Team member management
    ///
    /// - parameter group: Specify a group.
    /// - parameter newGroupName: Optional argument. Set group name to this if provided.
    /// - parameter newGroupExternalId: Optional argument. New group external ID. If the argument is None, the group's
    /// external_id won't be updated. If the argument is empty string, the group's external id will be cleared.
    /// - parameter newGroupManagementType: Set new group management type, if provided.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Team.GroupFullInfo` object on success or a
    /// `Team.GroupUpdateError` object on failure.
    public func alphaGroupsUpdate(group group: Team.GroupSelector, returnMembers: Bool = true, newGroupName: String? = nil, newGroupExternalId: String? = nil, newGroupManagementType: TeamCommon.GroupManagementType? = nil) -> RpcRequest<Team.GroupFullInfoSerializer, Team.GroupUpdateErrorSerializer> {
        let route = Team.alphaGroupsUpdate
        let serverArgs = Team.GroupUpdateArgs(group: group, returnMembers: returnMembers, newGroupName: newGroupName, newGroupExternalId: newGroupExternalId, newGroupManagementType: newGroupManagementType)
        return client.request(route, serverArgs: serverArgs)
    }

    /// List all device sessions of a team's member.
    ///
    /// - parameter teamMemberId: The team's member id
    /// - parameter includeWebSessions: Whether to list web sessions of the team's member
    /// - parameter includeDesktopClients: Whether to list linked desktop devices of the team's member
    /// - parameter includeMobileClients: Whether to list linked mobile devices of the team's member
    ///
    ///  - returns: Through the response callback, the caller will receive a `Team.ListMemberDevicesResult` object on
    /// success or a `Team.ListMemberDevicesError` object on failure.
    public func devicesListMemberDevices(teamMemberId teamMemberId: String, includeWebSessions: Bool = true, includeDesktopClients: Bool = true, includeMobileClients: Bool = true) -> RpcRequest<Team.ListMemberDevicesResultSerializer, Team.ListMemberDevicesErrorSerializer> {
        let route = Team.devicesListMemberDevices
        let serverArgs = Team.ListMemberDevicesArg(teamMemberId: teamMemberId, includeWebSessions: includeWebSessions, includeDesktopClients: includeDesktopClients, includeMobileClients: includeMobileClients)
        return client.request(route, serverArgs: serverArgs)
    }

    /// List all device sessions of a team.
    ///
    /// - parameter cursor: At the first call to the devicesListMembersDevices the cursor shouldn't be passed. Then, if
    /// the result of the call includes a cursor, the following requests should include the received cursors in order to
    /// receive the next sub list of team devices
    /// - parameter includeWebSessions: Whether to list web sessions of the team members
    /// - parameter includeDesktopClients: Whether to list desktop clients of the team members
    /// - parameter includeMobileClients: Whether to list mobile clients of the team members
    ///
    ///  - returns: Through the response callback, the caller will receive a `Team.ListMembersDevicesResult` object on
    /// success or a `Team.ListMembersDevicesError` object on failure.
    public func devicesListMembersDevices(cursor: String? = nil, includeWebSessions: Bool = true, includeDesktopClients: Bool = true, includeMobileClients: Bool = true) -> RpcRequest<Team.ListMembersDevicesResultSerializer, Team.ListMembersDevicesErrorSerializer> {
        let route = Team.devicesListMembersDevices
        let serverArgs = Team.ListMembersDevicesArg(cursor: cursor, includeWebSessions: includeWebSessions, includeDesktopClients: includeDesktopClients, includeMobileClients: includeMobileClients)
        return client.request(route, serverArgs: serverArgs)
    }

    /// List all device sessions of a team.
    ///
    /// - parameter cursor: At the first call to the devicesListTeamDevices the cursor shouldn't be passed. Then, if the
    /// result of the call includes a cursor, the following requests should include the received cursors in order to
    /// receive the next sub list of team devices
    /// - parameter includeWebSessions: Whether to list web sessions of the team members
    /// - parameter includeDesktopClients: Whether to list desktop clients of the team members
    /// - parameter includeMobileClients: Whether to list mobile clients of the team members
    ///
    ///  - returns: Through the response callback, the caller will receive a `Team.ListTeamDevicesResult` object on
    /// success or a `Team.ListTeamDevicesError` object on failure.
    @available(*, unavailable, message="devices/list_team_devices is deprecated. Use devices/list_members_devices.")
    public func devicesListTeamDevices(cursor: String? = nil, includeWebSessions: Bool = true, includeDesktopClients: Bool = true, includeMobileClients: Bool = true) -> RpcRequest<Team.ListTeamDevicesResultSerializer, Team.ListTeamDevicesErrorSerializer> {
        let route = Team.devicesListTeamDevices
        let serverArgs = Team.ListTeamDevicesArg(cursor: cursor, includeWebSessions: includeWebSessions, includeDesktopClients: includeDesktopClients, includeMobileClients: includeMobileClients)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Revoke a device session of a team's member
    ///
    /// - parameter revokeDeviceSessionArg: The RevokeDeviceSessionArg union
    ///
    ///  - returns: Through the response callback, the caller will receive a `Void` object on success or a
    /// `Team.RevokeDeviceSessionError` object on failure.
    public func devicesRevokeDeviceSession(revokeDeviceSessionArg revokeDeviceSessionArg: Team.RevokeDeviceSessionArg) -> RpcRequest<VoidSerializer, Team.RevokeDeviceSessionErrorSerializer> {
        let route = Team.devicesRevokeDeviceSession
        let serverArgs = revokeDeviceSessionArg
        return client.request(route, serverArgs: serverArgs)
    }

    /// Revoke a list of device sessions of team members
    ///
    ///
    ///  - returns: Through the response callback, the caller will receive a `Team.RevokeDeviceSessionBatchResult`
    /// object on success or a `Team.RevokeDeviceSessionBatchError` object on failure.
    public func devicesRevokeDeviceSessionBatch(revokeDevices revokeDevices: Array<Team.RevokeDeviceSessionArg>) -> RpcRequest<Team.RevokeDeviceSessionBatchResultSerializer, Team.RevokeDeviceSessionBatchErrorSerializer> {
        let route = Team.devicesRevokeDeviceSessionBatch
        let serverArgs = Team.RevokeDeviceSessionBatchArg(revokeDevices: revokeDevices)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Retrieves information about a team.
    ///
    ///
    ///  - returns: Through the response callback, the caller will receive a `Team.TeamGetInfoResult` object on success
    /// or a `Void` object on failure.
    public func getInfo() -> RpcRequest<Team.TeamGetInfoResultSerializer, VoidSerializer> {
        let route = Team.getInfo
        return client.request(route)
    }

    /// Creates a new, empty group, with a requested name. Permission : Team member management
    ///
    /// - parameter groupName: Group name.
    /// - parameter groupExternalId: The creator of a team can associate an arbitrary external ID to the group.
    /// - parameter groupManagementType: Whether the team can be managed by selected users, or only by team admins
    ///
    ///  - returns: Through the response callback, the caller will receive a `Team.GroupFullInfo` object on success or a
    /// `Team.GroupCreateError` object on failure.
    public func groupsCreate(groupName groupName: String, groupExternalId: String? = nil, groupManagementType: TeamCommon.GroupManagementType? = nil) -> RpcRequest<Team.GroupFullInfoSerializer, Team.GroupCreateErrorSerializer> {
        let route = Team.groupsCreate
        let serverArgs = Team.GroupCreateArg(groupName: groupName, groupExternalId: groupExternalId, groupManagementType: groupManagementType)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Deletes a group. The group is deleted immediately. However the revoking of group-owned resources may take
    /// additional time. Use the groupsJobStatusGet to determine whether this process has completed. Permission : Team
    /// member management
    ///
    /// - parameter groupSelector: Argument for selecting a single group, either by group_id or by external group ID.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Async.LaunchEmptyResult` object on success
    /// or a `Team.GroupDeleteError` object on failure.
    public func groupsDelete(groupSelector groupSelector: Team.GroupSelector) -> RpcRequest<Async.LaunchEmptyResultSerializer, Team.GroupDeleteErrorSerializer> {
        let route = Team.groupsDelete
        let serverArgs = groupSelector
        return client.request(route, serverArgs: serverArgs)
    }

    /// Retrieves information about one or more groups. Permission : Team Information
    ///
    /// - parameter groupsSelector: Argument for selecting a list of groups, either by group_ids, or external group IDs.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Array<Team.GroupsGetInfoItem>` object on
    /// success or a `Team.GroupsGetInfoError` object on failure.
    public func groupsGetInfo(groupsSelector groupsSelector: Team.GroupsSelector) -> RpcRequest<ArraySerializer<Team.GroupsGetInfoItemSerializer>, Team.GroupsGetInfoErrorSerializer> {
        let route = Team.groupsGetInfo
        let serverArgs = groupsSelector
        return client.request(route, serverArgs: serverArgs)
    }

    /// Once an async_job_id is returned from groupsDelete, groupsMembersAdd , or groupsMembersRemove use this method to
    /// poll the status of granting/revoking group members' access to group-owned resources. Permission : Team member
    /// management
    ///
    /// - parameter asyncJobId: Id of the asynchronous job. This is the value of a response returned from the method
    /// that launched the job.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Async.PollEmptyResult` object on success
    /// or a `Team.GroupsPollError` object on failure.
    public func groupsJobStatusGet(asyncJobId asyncJobId: String) -> RpcRequest<Async.PollEmptyResultSerializer, Team.GroupsPollErrorSerializer> {
        let route = Team.groupsJobStatusGet
        let serverArgs = Async.PollArg(asyncJobId: asyncJobId)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Lists groups on a team. Permission : Team Information
    ///
    /// - parameter limit: Number of results to return per call.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Team.GroupsListResult` object on success
    /// or a `Void` object on failure.
    public func groupsList(limit: UInt32 = 1000) -> RpcRequest<Team.GroupsListResultSerializer, VoidSerializer> {
        let route = Team.groupsList
        let serverArgs = Team.GroupsListArg(limit: limit)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Once a cursor has been retrieved from groupsList, use this to paginate through all groups. Permission : Team
    /// information
    ///
    /// - parameter cursor: Indicates from what point to get the next set of groups.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Team.GroupsListResult` object on success
    /// or a `Team.GroupsListContinueError` object on failure.
    public func groupsListContinue(cursor cursor: String) -> RpcRequest<Team.GroupsListResultSerializer, Team.GroupsListContinueErrorSerializer> {
        let route = Team.groupsListContinue
        let serverArgs = Team.GroupsListContinueArg(cursor: cursor)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Adds members to a group. The members are added immediately. However the granting of group-owned resources may
    /// take additional time. Use the groupsJobStatusGet to determine whether this process has completed. Permission :
    /// Team member management
    ///
    /// - parameter group: Group to which users will be added.
    /// - parameter members: List of users to be added to the group.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Team.GroupMembersChangeResult` object on
    /// success or a `Team.GroupMembersAddError` object on failure.
    public func groupsMembersAdd(group group: Team.GroupSelector, members: Array<Team.MemberAccess>, returnMembers: Bool = true) -> RpcRequest<Team.GroupMembersChangeResultSerializer, Team.GroupMembersAddErrorSerializer> {
        let route = Team.groupsMembersAdd
        let serverArgs = Team.GroupMembersAddArg(group: group, members: members, returnMembers: returnMembers)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Lists members of a group. Permission : Team Information
    ///
    /// - parameter group: The group whose members are to be listed.
    /// - parameter limit: Number of results to return per call.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Team.GroupsMembersListResult` object on
    /// success or a `Team.GroupSelectorError` object on failure.
    public func groupsMembersList(group group: Team.GroupSelector, limit: UInt32 = 1000) -> RpcRequest<Team.GroupsMembersListResultSerializer, Team.GroupSelectorErrorSerializer> {
        let route = Team.groupsMembersList
        let serverArgs = Team.GroupsMembersListArg(group: group, limit: limit)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Once a cursor has been retrieved from groupsMembersList, use this to paginate through all members of the group.
    /// Permission : Team information
    ///
    /// - parameter cursor: Indicates from what point to get the next set of groups.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Team.GroupsMembersListResult` object on
    /// success or a `Team.GroupsMembersListContinueError` object on failure.
    public func groupsMembersListContinue(cursor cursor: String) -> RpcRequest<Team.GroupsMembersListResultSerializer, Team.GroupsMembersListContinueErrorSerializer> {
        let route = Team.groupsMembersListContinue
        let serverArgs = Team.GroupsMembersListContinueArg(cursor: cursor)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Removes members from a group. The members are removed immediately. However the revoking of group-owned resources
    /// may take additional time. Use the groupsJobStatusGet to determine whether this process has completed. This
    /// method permits removing the only owner of a group, even in cases where this is not possible via the web client.
    /// Permission : Team member management
    ///
    /// - parameter group: Group from which users will be removed.
    /// - parameter users: List of users to be removed from the group.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Team.GroupMembersChangeResult` object on
    /// success or a `Team.GroupMembersRemoveError` object on failure.
    public func groupsMembersRemove(group group: Team.GroupSelector, users: Array<Team.UserSelectorArg>, returnMembers: Bool = true) -> RpcRequest<Team.GroupMembersChangeResultSerializer, Team.GroupMembersRemoveErrorSerializer> {
        let route = Team.groupsMembersRemove
        let serverArgs = Team.GroupMembersRemoveArg(group: group, users: users, returnMembers: returnMembers)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Sets a member's access type in a group. Permission : Team member management
    ///
    /// - parameter accessType: New group access type the user will have.
    /// - parameter returnMembers: Whether to return the list of members in the group.  Note that the default value will
    /// cause all the group members  to be returned in the response. This may take a long time for large groups.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Array<Team.GroupsGetInfoItem>` object on
    /// success or a `Team.GroupMemberSetAccessTypeError` object on failure.
    public func groupsMembersSetAccessType(group group: Team.GroupSelector, user: Team.UserSelectorArg, accessType: Team.GroupAccessType, returnMembers: Bool = true) -> RpcRequest<ArraySerializer<Team.GroupsGetInfoItemSerializer>, Team.GroupMemberSetAccessTypeErrorSerializer> {
        let route = Team.groupsMembersSetAccessType
        let serverArgs = Team.GroupMembersSetAccessTypeArg(group: group, user: user, accessType: accessType, returnMembers: returnMembers)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Updates a group's name and/or external ID. Permission : Team member management
    ///
    /// - parameter group: Specify a group.
    /// - parameter newGroupName: Optional argument. Set group name to this if provided.
    /// - parameter newGroupExternalId: Optional argument. New group external ID. If the argument is None, the group's
    /// external_id won't be updated. If the argument is empty string, the group's external id will be cleared.
    /// - parameter newGroupManagementType: Set new group management type, if provided.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Team.GroupFullInfo` object on success or a
    /// `Team.GroupUpdateError` object on failure.
    public func groupsUpdate(group group: Team.GroupSelector, returnMembers: Bool = true, newGroupName: String? = nil, newGroupExternalId: String? = nil, newGroupManagementType: TeamCommon.GroupManagementType? = nil) -> RpcRequest<Team.GroupFullInfoSerializer, Team.GroupUpdateErrorSerializer> {
        let route = Team.groupsUpdate
        let serverArgs = Team.GroupUpdateArgs(group: group, returnMembers: returnMembers, newGroupName: newGroupName, newGroupExternalId: newGroupExternalId, newGroupManagementType: newGroupManagementType)
        return client.request(route, serverArgs: serverArgs)
    }

    /// List all linked applications of the team member. Note, this endpoint does not list any team-linked applications.
    ///
    /// - parameter teamMemberId: The team member id
    ///
    ///  - returns: Through the response callback, the caller will receive a `Team.ListMemberAppsResult` object on
    /// success or a `Team.ListMemberAppsError` object on failure.
    public func linkedAppsListMemberLinkedApps(teamMemberId teamMemberId: String) -> RpcRequest<Team.ListMemberAppsResultSerializer, Team.ListMemberAppsErrorSerializer> {
        let route = Team.linkedAppsListMemberLinkedApps
        let serverArgs = Team.ListMemberAppsArg(teamMemberId: teamMemberId)
        return client.request(route, serverArgs: serverArgs)
    }

    /// List all applications linked to the team members' accounts. Note, this endpoint does not list any team-linked
    /// applications.
    ///
    /// - parameter cursor: At the first call to the linkedAppsListMembersLinkedApps the cursor shouldn't be passed.
    /// Then, if the result of the call includes a cursor, the following requests should include the received cursors in
    /// order to receive the next sub list of the team applications
    ///
    ///  - returns: Through the response callback, the caller will receive a `Team.ListMembersAppsResult` object on
    /// success or a `Team.ListMembersAppsError` object on failure.
    public func linkedAppsListMembersLinkedApps(cursor: String? = nil) -> RpcRequest<Team.ListMembersAppsResultSerializer, Team.ListMembersAppsErrorSerializer> {
        let route = Team.linkedAppsListMembersLinkedApps
        let serverArgs = Team.ListMembersAppsArg(cursor: cursor)
        return client.request(route, serverArgs: serverArgs)
    }

    /// List all applications linked to the team members' accounts. Note, this endpoint doesn't list any team-linked
    /// applications.
    ///
    /// - parameter cursor: At the first call to the linkedAppsListTeamLinkedApps the cursor shouldn't be passed. Then,
    /// if the result of the call includes a cursor, the following requests should include the received cursors in order
    /// to receive the next sub list of the team applications
    ///
    ///  - returns: Through the response callback, the caller will receive a `Team.ListTeamAppsResult` object on success
    /// or a `Team.ListTeamAppsError` object on failure.
    @available(*, unavailable, message="linked_apps/list_team_linked_apps is deprecated. Use linked_apps/list_members_linked_apps.")
    public func linkedAppsListTeamLinkedApps(cursor: String? = nil) -> RpcRequest<Team.ListTeamAppsResultSerializer, Team.ListTeamAppsErrorSerializer> {
        let route = Team.linkedAppsListTeamLinkedApps
        let serverArgs = Team.ListTeamAppsArg(cursor: cursor)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Revoke a linked application of the team member
    ///
    /// - parameter appId: The application's unique id
    /// - parameter teamMemberId: The unique id of the member owning the device
    /// - parameter keepAppFolder: Whether to keep the application dedicated folder (in case the application uses  one)
    ///
    ///  - returns: Through the response callback, the caller will receive a `Void` object on success or a
    /// `Team.RevokeLinkedAppError` object on failure.
    public func linkedAppsRevokeLinkedApp(appId appId: String, teamMemberId: String, keepAppFolder: Bool = true) -> RpcRequest<VoidSerializer, Team.RevokeLinkedAppErrorSerializer> {
        let route = Team.linkedAppsRevokeLinkedApp
        let serverArgs = Team.RevokeLinkedApiAppArg(appId: appId, teamMemberId: teamMemberId, keepAppFolder: keepAppFolder)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Revoke a list of linked applications of the team members
    ///
    ///
    ///  - returns: Through the response callback, the caller will receive a `Team.RevokeLinkedAppBatchResult` object on
    /// success or a `Team.RevokeLinkedAppBatchError` object on failure.
    public func linkedAppsRevokeLinkedAppBatch(revokeLinkedApp revokeLinkedApp: Array<Team.RevokeLinkedApiAppArg>) -> RpcRequest<Team.RevokeLinkedAppBatchResultSerializer, Team.RevokeLinkedAppBatchErrorSerializer> {
        let route = Team.linkedAppsRevokeLinkedAppBatch
        let serverArgs = Team.RevokeLinkedApiAppBatchArg(revokeLinkedApp: revokeLinkedApp)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Adds members to a team. Permission : Team member management A maximum of 20 members can be specified in a single
    /// call. If no Dropbox account exists with the email address specified, a new Dropbox account will be created with
    /// the given email address, and that account will be invited to the team. If a personal Dropbox account exists with
    /// the email address specified in the call, this call will create a placeholder Dropbox account for the user on the
    /// team and send an email inviting the user to migrate their existing personal account onto the team. Team member
    /// management apps are required to set an initial given_name and surname for a user to use in the team invitation
    /// and for 'Perform as team member' actions taken on the user before they become 'active'.
    ///
    /// - parameter newMembers: Details of new members to be added to the team.
    /// - parameter forceAsync: Whether to force the add to happen asynchronously.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Team.MembersAddLaunch` object on success
    /// or a `Void` object on failure.
    public func membersAdd(newMembers newMembers: Array<Team.MemberAddArg>, forceAsync: Bool = false) -> RpcRequest<Team.MembersAddLaunchSerializer, VoidSerializer> {
        let route = Team.membersAdd
        let serverArgs = Team.MembersAddArg(newMembers: newMembers, forceAsync: forceAsync)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Once an async_job_id is returned from membersAdd , use this to poll the status of the asynchronous request.
    /// Permission : Team member management
    ///
    /// - parameter asyncJobId: Id of the asynchronous job. This is the value of a response returned from the method
    /// that launched the job.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Team.MembersAddJobStatus` object on
    /// success or a `Async.PollError` object on failure.
    public func membersAddJobStatusGet(asyncJobId asyncJobId: String) -> RpcRequest<Team.MembersAddJobStatusSerializer, Async.PollErrorSerializer> {
        let route = Team.membersAddJobStatusGet
        let serverArgs = Async.PollArg(asyncJobId: asyncJobId)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Returns information about multiple team members. Permission : Team information This endpoint will return
    /// idNotFound in MembersGetInfoItem, for IDs (or emails) that cannot be matched to a valid team member.
    ///
    /// - parameter members: List of team members.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Array<Team.MembersGetInfoItem>` object on
    /// success or a `Team.MembersGetInfoError` object on failure.
    public func membersGetInfo(members members: Array<Team.UserSelectorArg>) -> RpcRequest<ArraySerializer<Team.MembersGetInfoItemSerializer>, Team.MembersGetInfoErrorSerializer> {
        let route = Team.membersGetInfo
        let serverArgs = Team.MembersGetInfoArgs(members: members)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Lists members of a team. Permission : Team information
    ///
    /// - parameter limit: Number of results to return per call.
    /// - parameter includeRemoved: Whether to return removed members.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Team.MembersListResult` object on success
    /// or a `Team.MembersListError` object on failure.
    public func membersList(limit: UInt32 = 1000, includeRemoved: Bool = false) -> RpcRequest<Team.MembersListResultSerializer, Team.MembersListErrorSerializer> {
        let route = Team.membersList
        let serverArgs = Team.MembersListArg(limit: limit, includeRemoved: includeRemoved)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Once a cursor has been retrieved from membersList, use this to paginate through all team members. Permission :
    /// Team information
    ///
    /// - parameter cursor: Indicates from what point to get the next set of members.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Team.MembersListResult` object on success
    /// or a `Team.MembersListContinueError` object on failure.
    public func membersListContinue(cursor cursor: String) -> RpcRequest<Team.MembersListResultSerializer, Team.MembersListContinueErrorSerializer> {
        let route = Team.membersListContinue
        let serverArgs = Team.MembersListContinueArg(cursor: cursor)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Recover a deleted member. Permission : Team member management Exactly one of team_member_id, email, or
    /// external_id must be provided to identify the user account.
    ///
    /// - parameter user: Identity of user to recover.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Void` object on success or a
    /// `Team.MembersRecoverError` object on failure.
    public func membersRecover(user user: Team.UserSelectorArg) -> RpcRequest<VoidSerializer, Team.MembersRecoverErrorSerializer> {
        let route = Team.membersRecover
        let serverArgs = Team.MembersRecoverArg(user: user)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Removes a member from a team. Permission : Team member management Exactly one of team_member_id, email, or
    /// external_id must be provided to identify the user account. This is not a deactivation where the account can be
    /// re-activated again. Calling membersAdd with the removed user's email address will create a new account with a
    /// new team_member_id that will not have access to any content that was shared with the initial account. This
    /// endpoint may initiate an asynchronous job. To obtain the final result of the job, the client should periodically
    /// poll membersRemoveJobStatusGet.
    ///
    /// - parameter transferDestId: If provided, files from the deleted member account will be transferred to this user.
    /// - parameter transferAdminId: If provided, errors during the transfer process will be sent via email to this
    /// user. If the transfer_dest_id argument was provided, then this argument must be provided as well.
    /// - parameter keepAccount: Downgrade the member to a Basic account. The user will retain the email address
    /// associated with their Dropbox  account and data in their account that is not restricted to team members.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Async.LaunchEmptyResult` object on success
    /// or a `Team.MembersRemoveError` object on failure.
    public func membersRemove(user user: Team.UserSelectorArg, wipeData: Bool = true, transferDestId: Team.UserSelectorArg? = nil, transferAdminId: Team.UserSelectorArg? = nil, keepAccount: Bool = false) -> RpcRequest<Async.LaunchEmptyResultSerializer, Team.MembersRemoveErrorSerializer> {
        let route = Team.membersRemove
        let serverArgs = Team.MembersRemoveArg(user: user, wipeData: wipeData, transferDestId: transferDestId, transferAdminId: transferAdminId, keepAccount: keepAccount)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Once an async_job_id is returned from membersRemove , use this to poll the status of the asynchronous request.
    /// Permission : Team member management
    ///
    /// - parameter asyncJobId: Id of the asynchronous job. This is the value of a response returned from the method
    /// that launched the job.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Async.PollEmptyResult` object on success
    /// or a `Async.PollError` object on failure.
    public func membersRemoveJobStatusGet(asyncJobId asyncJobId: String) -> RpcRequest<Async.PollEmptyResultSerializer, Async.PollErrorSerializer> {
        let route = Team.membersRemoveJobStatusGet
        let serverArgs = Async.PollArg(asyncJobId: asyncJobId)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Sends welcome email to pending team member. Permission : Team member management Exactly one of team_member_id,
    /// email, or external_id must be provided to identify the user account. No-op if team member is not pending.
    ///
    /// - parameter userSelectorArg: Argument for selecting a single user, either by team_member_id, external_id or
    /// email.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Void` object on success or a
    /// `Team.MembersSendWelcomeError` object on failure.
    public func membersSendWelcomeEmail(userSelectorArg userSelectorArg: Team.UserSelectorArg) -> RpcRequest<VoidSerializer, Team.MembersSendWelcomeErrorSerializer> {
        let route = Team.membersSendWelcomeEmail
        let serverArgs = userSelectorArg
        return client.request(route, serverArgs: serverArgs)
    }

    /// Updates a team member's permissions. Permission : Team member management
    ///
    /// - parameter user: Identity of user whose role will be set.
    /// - parameter newRole: The new role of the member.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Team.MembersSetPermissionsResult` object
    /// on success or a `Team.MembersSetPermissionsError` object on failure.
    public func membersSetAdminPermissions(user user: Team.UserSelectorArg, newRole: Team.AdminTier) -> RpcRequest<Team.MembersSetPermissionsResultSerializer, Team.MembersSetPermissionsErrorSerializer> {
        let route = Team.membersSetAdminPermissions
        let serverArgs = Team.MembersSetPermissionsArg(user: user, newRole: newRole)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Updates a team member's profile. Permission : Team member management
    ///
    /// - parameter user: Identity of user whose profile will be set.
    /// - parameter newEmail: New email for member.
    /// - parameter newExternalId: New external ID for member.
    /// - parameter newGivenName: New given name for member.
    /// - parameter newSurname: New surname for member.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Team.TeamMemberInfo` object on success or
    /// a `Team.MembersSetProfileError` object on failure.
    public func membersSetProfile(user user: Team.UserSelectorArg, newEmail: String? = nil, newExternalId: String? = nil, newGivenName: String? = nil, newSurname: String? = nil) -> RpcRequest<Team.TeamMemberInfoSerializer, Team.MembersSetProfileErrorSerializer> {
        let route = Team.membersSetProfile
        let serverArgs = Team.MembersSetProfileArg(user: user, newEmail: newEmail, newExternalId: newExternalId, newGivenName: newGivenName, newSurname: newSurname)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Suspend a member from a team. Permission : Team member management Exactly one of team_member_id, email, or
    /// external_id must be provided to identify the user account.
    ///
    /// - parameter user: Identity of user to remove/suspend.
    /// - parameter wipeData: If provided, controls if the user's data will be deleted on their linked devices.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Void` object on success or a
    /// `Team.MembersSuspendError` object on failure.
    public func membersSuspend(user user: Team.UserSelectorArg, wipeData: Bool = true) -> RpcRequest<VoidSerializer, Team.MembersSuspendErrorSerializer> {
        let route = Team.membersSuspend
        let serverArgs = Team.MembersDeactivateArg(user: user, wipeData: wipeData)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Unsuspend a member from a team. Permission : Team member management Exactly one of team_member_id, email, or
    /// external_id must be provided to identify the user account.
    ///
    /// - parameter user: Identity of user to unsuspend.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Void` object on success or a
    /// `Team.MembersUnsuspendError` object on failure.
    public func membersUnsuspend(user user: Team.UserSelectorArg) -> RpcRequest<VoidSerializer, Team.MembersUnsuspendErrorSerializer> {
        let route = Team.membersUnsuspend
        let serverArgs = Team.MembersUnsuspendArg(user: user)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Add a property template. See route files/properties/add to add properties to a file.
    ///
    ///
    ///  - returns: Through the response callback, the caller will receive a `Team.AddPropertyTemplateResult` object on
    /// success or a `Properties.ModifyPropertyTemplateError` object on failure.
    public func propertiesTemplateAdd(name name: String, description_: String, fields: Array<Properties.PropertyFieldTemplate>) -> RpcRequest<Team.AddPropertyTemplateResultSerializer, Properties.ModifyPropertyTemplateErrorSerializer> {
        let route = Team.propertiesTemplateAdd
        let serverArgs = Team.AddPropertyTemplateArg(name: name, description_: description_, fields: fields)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Get the schema for a specified template.
    ///
    /// - parameter templateId: An identifier for property template added by route properties/template/add.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Properties.GetPropertyTemplateResult`
    /// object on success or a `Properties.PropertyTemplateError` object on failure.
    public func propertiesTemplateGet(templateId templateId: String) -> RpcRequest<Properties.GetPropertyTemplateResultSerializer, Properties.PropertyTemplateErrorSerializer> {
        let route = Team.propertiesTemplateGet
        let serverArgs = Properties.GetPropertyTemplateArg(templateId: templateId)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Get the property template identifiers for a team. To get the schema of each template use propertiesTemplateGet.
    ///
    ///
    ///  - returns: Through the response callback, the caller will receive a `Properties.ListPropertyTemplateIds` object
    /// on success or a `Properties.PropertyTemplateError` object on failure.
    public func propertiesTemplateList() -> RpcRequest<Properties.ListPropertyTemplateIdsSerializer, Properties.PropertyTemplateErrorSerializer> {
        let route = Team.propertiesTemplateList
        return client.request(route)
    }

    /// Update a property template. This route can update the template name, the template description and add optional
    /// properties to templates.
    ///
    /// - parameter templateId: An identifier for property template added by propertiesTemplateAdd.
    /// - parameter name: A display name for the property template. Property template names can be up to 256 bytes.
    /// - parameter description_: Description for new property template. Property template descriptions can be up to
    /// 1024 bytes.
    /// - parameter addFields: This is a list of custom properties to add to the property template. There can be up to
    /// 64 properties in a single property template.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Team.UpdatePropertyTemplateResult` object
    /// on success or a `Properties.ModifyPropertyTemplateError` object on failure.
    public func propertiesTemplateUpdate(templateId templateId: String, name: String? = nil, description_: String? = nil, addFields: Array<Properties.PropertyFieldTemplate>? = nil) -> RpcRequest<Team.UpdatePropertyTemplateResultSerializer, Properties.ModifyPropertyTemplateErrorSerializer> {
        let route = Team.propertiesTemplateUpdate
        let serverArgs = Team.UpdatePropertyTemplateArg(templateId: templateId, name: name, description_: description_, addFields: addFields)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Retrieves reporting data about a team's user activity.
    ///
    /// - parameter startDate: Optional starting date (inclusive)
    /// - parameter endDate: Optional ending date (exclusive)
    ///
    ///  - returns: Through the response callback, the caller will receive a `Team.GetActivityReport` object on success
    /// or a `Team.DateRangeError` object on failure.
    public func reportsGetActivity(startDate: NSDate? = nil, endDate: NSDate? = nil) -> RpcRequest<Team.GetActivityReportSerializer, Team.DateRangeErrorSerializer> {
        let route = Team.reportsGetActivity
        let serverArgs = Team.DateRange(startDate: startDate, endDate: endDate)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Retrieves reporting data about a team's linked devices.
    ///
    /// - parameter startDate: Optional starting date (inclusive)
    /// - parameter endDate: Optional ending date (exclusive)
    ///
    ///  - returns: Through the response callback, the caller will receive a `Team.GetDevicesReport` object on success
    /// or a `Team.DateRangeError` object on failure.
    public func reportsGetDevices(startDate: NSDate? = nil, endDate: NSDate? = nil) -> RpcRequest<Team.GetDevicesReportSerializer, Team.DateRangeErrorSerializer> {
        let route = Team.reportsGetDevices
        let serverArgs = Team.DateRange(startDate: startDate, endDate: endDate)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Retrieves reporting data about a team's membership.
    ///
    /// - parameter startDate: Optional starting date (inclusive)
    /// - parameter endDate: Optional ending date (exclusive)
    ///
    ///  - returns: Through the response callback, the caller will receive a `Team.GetMembershipReport` object on
    /// success or a `Team.DateRangeError` object on failure.
    public func reportsGetMembership(startDate: NSDate? = nil, endDate: NSDate? = nil) -> RpcRequest<Team.GetMembershipReportSerializer, Team.DateRangeErrorSerializer> {
        let route = Team.reportsGetMembership
        let serverArgs = Team.DateRange(startDate: startDate, endDate: endDate)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Retrieves reporting data about a team's storage usage.
    ///
    /// - parameter startDate: Optional starting date (inclusive)
    /// - parameter endDate: Optional ending date (exclusive)
    ///
    ///  - returns: Through the response callback, the caller will receive a `Team.GetStorageReport` object on success
    /// or a `Team.DateRangeError` object on failure.
    public func reportsGetStorage(startDate: NSDate? = nil, endDate: NSDate? = nil) -> RpcRequest<Team.GetStorageReportSerializer, Team.DateRangeErrorSerializer> {
        let route = Team.reportsGetStorage
        let serverArgs = Team.DateRange(startDate: startDate, endDate: endDate)
        return client.request(route, serverArgs: serverArgs)
    }

}
