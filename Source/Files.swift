
/* Autogenerated. Do not edit. */

import Foundation
public class Files {
    /// Metadata for a file or folder.
    ///
    /// - parameter name:
    ///        The last component of the path (including extension). This never
    ///        contains a slash.
    /// - parameter pathLower:
    ///        The lowercased full path in the user's Dropbox. This always
    ///        starts with a slash.
    public class Metadata: CustomStringConvertible {
        public let name : String
        public let pathLower : String
        public init(name: String, pathLower: String) {
            stringValidator()(value: name)
            self.name = name
            stringValidator()(value: pathLower)
            self.pathLower = pathLower
        }
        public var description : String {
            return "\(prepareJSONForSerialization(MetadataSerializer().serialize(self)))"
        }
    }
    public class MetadataSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: Metadata) -> JSON {
            var output = [ 
            "name": Serialization._StringSerializer.serialize(value.name),
            "path_lower": Serialization._StringSerializer.serialize(value.pathLower),
            ]
            switch value {
                case let file as Files.FileMetadata:
                    for (k,v) in Serialization.getFields(FileMetadataSerializer().serialize(file)) {
                        output[k] = v
                    }
                    output[".tag"] = .Str("file")
                case let folder as Files.FolderMetadata:
                    for (k,v) in Serialization.getFields(FolderMetadataSerializer().serialize(folder)) {
                        output[k] = v
                    }
                    output[".tag"] = .Str("folder")
                case let deleted as Files.DeletedMetadata:
                    for (k,v) in Serialization.getFields(DeletedMetadataSerializer().serialize(deleted)) {
                        output[k] = v
                    }
                    output[".tag"] = .Str("deleted")
                default: fatalError("Tried to serialize unexpected subtype")
            }
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> Metadata {
            switch json {
                case .Dictionary(let dict):
                    let tag = Serialization.getTag(dict)
                    switch tag {
                        case "file":
                            return FileMetadataSerializer().deserialize(json)
                        case "folder":
                            return FolderMetadataSerializer().deserialize(json)
                        case "deleted":
                            return DeletedMetadataSerializer().deserialize(json)
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    assert(false, "Type error deserializing")
            }
        }
    }
    /// Metadata (excluding name or path) for a file.
    ///
    /// - parameter id:
    ///        A unique identifier for the file.
    /// - parameter clientModified:
    ///        For files, this is the modification time set by the desktop
    ///        client when the file was added to Dropbox. Since this time is not
    ///        verified (the Dropbox server stores whatever the desktop client
    ///        sends up), this should only be used for display purposes (such as
    ///        sorting) and not, for example, to determine if a file has changed
    ///        or not.
    /// - parameter serverModified:
    ///        The last time the file was modified on Dropbox.
    /// - parameter rev:
    ///        A unique identifier for the current revision of a file. This
    ///        field is the same rev as elsewhere in the API and can be used to
    ///        detect changes and avoid conflicts.
    /// - parameter size:
    ///        The file size in bytes.
    public class FileMetadata: Metadata {
        public let id : String?
        public let clientModified : NSDate
        public let serverModified : NSDate
        public let rev : String
        public let size : UInt64
        public init(name: String, pathLower: String, clientModified: NSDate, serverModified: NSDate, rev: String, size: UInt64, id: String? = nil) {
            nullableValidator(stringValidator(maxLength: 1))(value: id)
            self.id = id
            self.clientModified = clientModified
            self.serverModified = serverModified
            stringValidator(maxLength: 9, pattern: "[0-9a-f]+")(value: rev)
            self.rev = rev
            comparableValidator()(value: size)
            self.size = size
            super.init(name: name, pathLower: pathLower)
        }
        public override var description : String {
            return "\(prepareJSONForSerialization(FileMetadataSerializer().serialize(self)))"
        }
    }
    public class FileMetadataSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: FileMetadata) -> JSON {
            let output = [ 
            "name": Serialization._StringSerializer.serialize(value.name),
            "path_lower": Serialization._StringSerializer.serialize(value.pathLower),
            "client_modified": NSDateSerializer("%Y-%m-%dT%H:%M:%SZ").serialize(value.clientModified),
            "server_modified": NSDateSerializer("%Y-%m-%dT%H:%M:%SZ").serialize(value.serverModified),
            "rev": Serialization._StringSerializer.serialize(value.rev),
            "size": Serialization._UInt64Serializer.serialize(value.size),
            "id": NullableSerializer(Serialization._StringSerializer).serialize(value.id),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> FileMetadata {
            switch json {
                case .Dictionary(let dict):
                    let name = Serialization._StringSerializer.deserialize(dict["name"] ?? .Null)
                    let pathLower = Serialization._StringSerializer.deserialize(dict["path_lower"] ?? .Null)
                    let clientModified = NSDateSerializer("%Y-%m-%dT%H:%M:%SZ").deserialize(dict["client_modified"] ?? .Null)
                    let serverModified = NSDateSerializer("%Y-%m-%dT%H:%M:%SZ").deserialize(dict["server_modified"] ?? .Null)
                    let rev = Serialization._StringSerializer.deserialize(dict["rev"] ?? .Null)
                    let size = Serialization._UInt64Serializer.deserialize(dict["size"] ?? .Null)
                    let id = NullableSerializer(Serialization._StringSerializer).deserialize(dict["id"] ?? .Null)
                    return FileMetadata(name: name, pathLower: pathLower, clientModified: clientModified, serverModified: serverModified, rev: rev, size: size, id: id)
                default:
                    assert(false, "Type error deserializing")
            }
        }
    }
    /// Metadata (excluding name or path) for a folder. (There are currently no
    /// fields defined here, but we will add folder-specific metadata in the
    /// future.)
    ///
    /// - parameter id:
    ///        A unique identifier for the folder.
    public class FolderMetadata: Metadata {
        public let id : String?
        public init(name: String, pathLower: String, id: String? = nil) {
            nullableValidator(stringValidator(maxLength: 1))(value: id)
            self.id = id
            super.init(name: name, pathLower: pathLower)
        }
        public override var description : String {
            return "\(prepareJSONForSerialization(FolderMetadataSerializer().serialize(self)))"
        }
    }
    public class FolderMetadataSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: FolderMetadata) -> JSON {
            let output = [ 
            "name": Serialization._StringSerializer.serialize(value.name),
            "path_lower": Serialization._StringSerializer.serialize(value.pathLower),
            "id": NullableSerializer(Serialization._StringSerializer).serialize(value.id),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> FolderMetadata {
            switch json {
                case .Dictionary(let dict):
                    let name = Serialization._StringSerializer.deserialize(dict["name"] ?? .Null)
                    let pathLower = Serialization._StringSerializer.deserialize(dict["path_lower"] ?? .Null)
                    let id = NullableSerializer(Serialization._StringSerializer).deserialize(dict["id"] ?? .Null)
                    return FolderMetadata(name: name, pathLower: pathLower, id: id)
                default:
                    assert(false, "Type error deserializing")
            }
        }
    }
    /// Indicates a deleted file or folder in results returned by
    /// `list_folder/continue` or `search`.
    ///
    public class DeletedMetadata: Metadata {
        public override var description : String {
            return "\(prepareJSONForSerialization(DeletedMetadataSerializer().serialize(self)))"
        }
    }
    public class DeletedMetadataSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: DeletedMetadata) -> JSON {
            let output = [ 
            "name": Serialization._StringSerializer.serialize(value.name),
            "path_lower": Serialization._StringSerializer.serialize(value.pathLower),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> DeletedMetadata {
            switch json {
                case .Dictionary(let dict):
                    let name = Serialization._StringSerializer.deserialize(dict["name"] ?? .Null)
                    let pathLower = Serialization._StringSerializer.deserialize(dict["path_lower"] ?? .Null)
                    return DeletedMetadata(name: name, pathLower: pathLower)
                default:
                    assert(false, "Type error deserializing")
            }
        }
    }
    /// Error returned by `get_metadata`.
    ///
    /// - NotFound:
    ///   File is not found at the specified path.
    /// - Other:
    ///   An unspecified error.
    public enum GetMetadataError : CustomStringConvertible {
        case NotFound
        case Other
        public var description : String {
            return "\(prepareJSONForSerialization(GetMetadataErrorSerializer().serialize(self)))"
        }
    }
    public class GetMetadataErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: GetMetadataError) -> JSON {
            switch value {
                case .NotFound:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("not_found")
                    return .Dictionary(d)
                case .Other:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> GetMetadataError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "not_found":
                            return GetMetadataError.NotFound
                        case "other":
                            return GetMetadataError.Other
                        default:
                            return GetMetadataError.Other
                    }
                default:
                    assert(false, "Failed to deserialize")
            }
        }
    }
    /// Arguments for `get_metadata`.
    ///
    /// - parameter path:
    ///        The path or ID of a file or folder on Dropbox. Must not be the
    ///        root.
    public class GetMetadataArg: CustomStringConvertible {
        public let path : String
        public init(path: String) {
            stringValidator()(value: path)
            self.path = path
        }
        public var description : String {
            return "\(prepareJSONForSerialization(GetMetadataArgSerializer().serialize(self)))"
        }
    }
    public class GetMetadataArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: GetMetadataArg) -> JSON {
            let output = [ 
            "path": Serialization._StringSerializer.serialize(value.path),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> GetMetadataArg {
            switch json {
                case .Dictionary(let dict):
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .Null)
                    return GetMetadataArg(path: path)
                default:
                    assert(false, "Type error deserializing")
            }
        }
    }
    /// Arguments for `list_folder`.
    ///
    /// - parameter path:
    ///        The path to the folder you want to see the contents of. May be
    ///        the root (i.e. empty).
    /// - parameter recursive:
    ///        If true, list folder operation will be applied recursively to all
    ///        subfolders. And the response will contain contents of all
    ///        subfolders
    public class ListFolderArg: CustomStringConvertible {
        public let path : String
        public let recursive : Bool
        public init(path: String, recursive: Bool = false) {
            stringValidator()(value: path)
            self.path = path
            self.recursive = recursive
        }
        public var description : String {
            return "\(prepareJSONForSerialization(ListFolderArgSerializer().serialize(self)))"
        }
    }
    public class ListFolderArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: ListFolderArg) -> JSON {
            let output = [ 
            "path": Serialization._StringSerializer.serialize(value.path),
            "recursive": Serialization._BoolSerializer.serialize(value.recursive),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> ListFolderArg {
            switch json {
                case .Dictionary(let dict):
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .Null)
                    let recursive = Serialization._BoolSerializer.deserialize(dict["recursive"] ?? .Null)
                    return ListFolderArg(path: path, recursive: recursive)
                default:
                    assert(false, "Type error deserializing")
            }
        }
    }
    /// Information returned by `list_folder`.
    ///
    /// - parameter entries:
    ///        The files and (direct) subfolders in the folder.
    /// - parameter cursor:
    ///        Pass the cursor into `list_folder/continue` to see what's changed
    ///        in the folder since your previous query.
    /// - parameter hasMore:
    ///        If true, then there are more entries available. Pass the cursor
    ///        to `list_folder/continue` to retrieve the rest.
    public class ListFolderResult: CustomStringConvertible {
        public let entries : Array<Metadata>
        public let cursor : String
        public let hasMore : Bool
        public init(entries: Array<Metadata>, cursor: String, hasMore: Bool) {
            self.entries = entries
            stringValidator()(value: cursor)
            self.cursor = cursor
            self.hasMore = hasMore
        }
        public var description : String {
            return "\(prepareJSONForSerialization(ListFolderResultSerializer().serialize(self)))"
        }
    }
    public class ListFolderResultSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: ListFolderResult) -> JSON {
            let output = [ 
            "entries": ArraySerializer(MetadataSerializer()).serialize(value.entries),
            "cursor": Serialization._StringSerializer.serialize(value.cursor),
            "has_more": Serialization._BoolSerializer.serialize(value.hasMore),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> ListFolderResult {
            switch json {
                case .Dictionary(let dict):
                    let entries = ArraySerializer(MetadataSerializer()).deserialize(dict["entries"] ?? .Null)
                    let cursor = Serialization._StringSerializer.deserialize(dict["cursor"] ?? .Null)
                    let hasMore = Serialization._BoolSerializer.deserialize(dict["has_more"] ?? .Null)
                    return ListFolderResult(entries: entries, cursor: cursor, hasMore: hasMore)
                default:
                    assert(false, "Type error deserializing")
            }
        }
    }
    /// Base class for errors returned by `list_folder`.
    ///
    /// - NotFound:
    ///   There is no file or folder at the given path.
    /// - NotFolder:
    ///   Entry at path is not a folder.
    public enum FolderPathError : CustomStringConvertible {
        case NotFound
        case NotFolder
        public var description : String {
            return "\(prepareJSONForSerialization(FolderPathErrorSerializer().serialize(self)))"
        }
    }
    public class FolderPathErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: FolderPathError) -> JSON {
            switch value {
                case .NotFound:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("not_found")
                    return .Dictionary(d)
                case .NotFolder:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("not_folder")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> FolderPathError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "not_found":
                            return FolderPathError.NotFound
                        case "not_folder":
                            return FolderPathError.NotFolder
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    assert(false, "Failed to deserialize")
            }
        }
    }
    /// Error returned by `list_folder` and `list_folder/continue`.
    ///
    /// - Other:
    ///   An unspecified error.
    public enum ListFolderError : CustomStringConvertible {
        case Other
        public var description : String {
            return "\(prepareJSONForSerialization(ListFolderErrorSerializer().serialize(self)))"
        }
    }
    public class ListFolderErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: ListFolderError) -> JSON {
            switch value {
                case .Other:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> ListFolderError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "other":
                            return ListFolderError.Other
                        default:
                            return ListFolderError.Other
                    }
                default:
                    assert(false, "Failed to deserialize")
            }
        }
    }
    /// Arguments for `list_folder/continue`.
    ///
    /// - parameter cursor:
    ///        The cursor returned by `list_folder` or `list_folder/continue`.
    public class ListFolderContinueArg: CustomStringConvertible {
        public let cursor : String
        public init(cursor: String) {
            stringValidator()(value: cursor)
            self.cursor = cursor
        }
        public var description : String {
            return "\(prepareJSONForSerialization(ListFolderContinueArgSerializer().serialize(self)))"
        }
    }
    public class ListFolderContinueArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: ListFolderContinueArg) -> JSON {
            let output = [ 
            "cursor": Serialization._StringSerializer.serialize(value.cursor),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> ListFolderContinueArg {
            switch json {
                case .Dictionary(let dict):
                    let cursor = Serialization._StringSerializer.deserialize(dict["cursor"] ?? .Null)
                    return ListFolderContinueArg(cursor: cursor)
                default:
                    assert(false, "Type error deserializing")
            }
        }
    }
    /// Error returned by `list_folder/continue`.
    ///
    /// - Reset:
    ///   Indicates that the cursor has been invalidated. Call `list_folder` to
    ///   obtain a new cursor.
    public enum ListFolderContinueError : CustomStringConvertible {
        case Reset
        public var description : String {
            return "\(prepareJSONForSerialization(ListFolderContinueErrorSerializer().serialize(self)))"
        }
    }
    public class ListFolderContinueErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: ListFolderContinueError) -> JSON {
            switch value {
                case .Reset:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("reset")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> ListFolderContinueError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "reset":
                            return ListFolderContinueError.Reset
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    assert(false, "Failed to deserialize")
            }
        }
    }
    /// Information returned by `list_folder/get_latest_cursor`.
    ///
    /// - parameter cursor:
    ///        Pass the cursor into `list_folder/continue` to see what's changed
    ///        in the folder since your previous query.
    public class ListFolderGetLatestCursorResult: CustomStringConvertible {
        public let cursor : String
        public init(cursor: String) {
            stringValidator()(value: cursor)
            self.cursor = cursor
        }
        public var description : String {
            return "\(prepareJSONForSerialization(ListFolderGetLatestCursorResultSerializer().serialize(self)))"
        }
    }
    public class ListFolderGetLatestCursorResultSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: ListFolderGetLatestCursorResult) -> JSON {
            let output = [ 
            "cursor": Serialization._StringSerializer.serialize(value.cursor),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> ListFolderGetLatestCursorResult {
            switch json {
                case .Dictionary(let dict):
                    let cursor = Serialization._StringSerializer.deserialize(dict["cursor"] ?? .Null)
                    return ListFolderGetLatestCursorResult(cursor: cursor)
                default:
                    assert(false, "Type error deserializing")
            }
        }
    }
    /// Errors from `download` when the file cannot be downloaded.
    ///
    /// - NotFound:
    ///   The path is not found.
    /// - IsFolder:
    ///   The path refers to a folder. Only files can be downloaded.
    public enum NoFileReason : CustomStringConvertible {
        case NotFound
        case IsFolder
        public var description : String {
            return "\(prepareJSONForSerialization(NoFileReasonSerializer().serialize(self)))"
        }
    }
    public class NoFileReasonSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: NoFileReason) -> JSON {
            switch value {
                case .NotFound:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("not_found")
                    return .Dictionary(d)
                case .IsFolder:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("is_folder")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> NoFileReason {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "not_found":
                            return NoFileReason.NotFound
                        case "is_folder":
                            return NoFileReason.IsFolder
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    assert(false, "Failed to deserialize")
            }
        }
    }
    /// Error structure for `download`.
    ///
    /// - parameter reason:
    ///        The path could not be downloaded. The value gives the reason.
    public class NoFile: CustomStringConvertible {
        public let reason : NoFileReason
        public init(reason: NoFileReason) {
            self.reason = reason
        }
        public var description : String {
            return "\(prepareJSONForSerialization(NoFileSerializer().serialize(self)))"
        }
    }
    public class NoFileSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: NoFile) -> JSON {
            let output = [ 
            "reason": NoFileReasonSerializer().serialize(value.reason),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> NoFile {
            switch json {
                case .Dictionary(let dict):
                    let reason = NoFileReasonSerializer().deserialize(dict["reason"] ?? .Null)
                    return NoFile(reason: reason)
                default:
                    assert(false, "Type error deserializing")
            }
        }
    }
    /// Errors for `download` when download is forbidden.
    ///
    /// - Dmca:
    ///   The download is forbidden because of a DMCA (U.S. Digital Millenium
    ///   Copyright Act) takedown request.
    /// - Other:
    ///   The download is forbidden for some other reason.
    public enum RestrictedReason : CustomStringConvertible {
        case Dmca
        case Other
        public var description : String {
            return "\(prepareJSONForSerialization(RestrictedReasonSerializer().serialize(self)))"
        }
    }
    public class RestrictedReasonSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: RestrictedReason) -> JSON {
            switch value {
                case .Dmca:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("dmca")
                    return .Dictionary(d)
                case .Other:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> RestrictedReason {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "dmca":
                            return RestrictedReason.Dmca
                        case "other":
                            return RestrictedReason.Other
                        default:
                            return RestrictedReason.Other
                    }
                default:
                    assert(false, "Failed to deserialize")
            }
        }
    }
    /// Error structure for `download`.
    ///
    /// - parameter reason:
    ///        The download is forbidden. The value gives the reason.
    public class Restricted: CustomStringConvertible {
        public let reason : RestrictedReason
        public init(reason: RestrictedReason) {
            self.reason = reason
        }
        public var description : String {
            return "\(prepareJSONForSerialization(RestrictedSerializer().serialize(self)))"
        }
    }
    public class RestrictedSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: Restricted) -> JSON {
            let output = [ 
            "reason": RestrictedReasonSerializer().serialize(value.reason),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> Restricted {
            switch json {
                case .Dictionary(let dict):
                    let reason = RestrictedReasonSerializer().deserialize(dict["reason"] ?? .Null)
                    return Restricted(reason: reason)
                default:
                    assert(false, "Type error deserializing")
            }
        }
    }
    /// Errors for `download` when download is disallowed or forbidden.
    ///
    /// - Permission:
    ///   The requesting user has no permission to access the file.
    /// - Restricted:
    ///   The download is forbidden; see the value for the reason.
    public enum DisallowedReason : CustomStringConvertible {
        case Permission
        case Restricted(Files.Restricted)
        public var description : String {
            return "\(prepareJSONForSerialization(DisallowedReasonSerializer().serialize(self)))"
        }
    }
    public class DisallowedReasonSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: DisallowedReason) -> JSON {
            switch value {
                case .Permission:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("permission")
                    return .Dictionary(d)
                case .Restricted(let arg):
                    var d = Serialization.getFields(RestrictedSerializer().serialize(arg))
                    d[".tag"] = .Str("restricted")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> DisallowedReason {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "permission":
                            return DisallowedReason.Permission
                        case "restricted":
                            let v = RestrictedSerializer().deserialize(json)
                            return DisallowedReason.Restricted(v)
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    assert(false, "Failed to deserialize")
            }
        }
    }
    /// Error structure for `download`.
    ///
    /// - parameter reason:
    ///        The reason why the download is disallowed.
    public class Disallowed: CustomStringConvertible {
        public let reason : DisallowedReason
        public init(reason: DisallowedReason) {
            self.reason = reason
        }
        public var description : String {
            return "\(prepareJSONForSerialization(DisallowedSerializer().serialize(self)))"
        }
    }
    public class DisallowedSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: Disallowed) -> JSON {
            let output = [ 
            "reason": DisallowedReasonSerializer().serialize(value.reason),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> Disallowed {
            switch json {
                case .Dictionary(let dict):
                    let reason = DisallowedReasonSerializer().deserialize(dict["reason"] ?? .Null)
                    return Disallowed(reason: reason)
                default:
                    assert(false, "Type error deserializing")
            }
        }
    }
    /// Errors from `download`.
    ///
    /// - Disallowed:
    ///   The download is disallowed or forbidden; see the value for the reason.
    /// - NoFile:
    ///   The path cannot be downloaded.
    /// - Other:
    ///   An unspecified error.
    public enum DownloadError : CustomStringConvertible {
        case Disallowed(Files.Disallowed)
        case NoFile(Files.NoFile)
        case Other
        public var description : String {
            return "\(prepareJSONForSerialization(DownloadErrorSerializer().serialize(self)))"
        }
    }
    public class DownloadErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: DownloadError) -> JSON {
            switch value {
                case .Disallowed(let arg):
                    var d = Serialization.getFields(DisallowedSerializer().serialize(arg))
                    d[".tag"] = .Str("disallowed")
                    return .Dictionary(d)
                case .NoFile(let arg):
                    var d = Serialization.getFields(NoFileSerializer().serialize(arg))
                    d[".tag"] = .Str("no_file")
                    return .Dictionary(d)
                case .Other:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> DownloadError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "disallowed":
                            let v = DisallowedSerializer().deserialize(json)
                            return DownloadError.Disallowed(v)
                        case "no_file":
                            let v = NoFileSerializer().deserialize(json)
                            return DownloadError.NoFile(v)
                        case "other":
                            return DownloadError.Other
                        default:
                            return DownloadError.Other
                    }
                default:
                    assert(false, "Failed to deserialize")
            }
        }
    }
    /// Arguments for `download`.
    ///
    /// - parameter path:
    ///        The path of the file to download.
    /// - parameter rev:
    ///        Optional revision, taken from the corresponding `Metadata` field.
    public class DownloadArg: CustomStringConvertible {
        public let path : String
        public let rev : String?
        public init(path: String, rev: String? = nil) {
            stringValidator()(value: path)
            self.path = path
            nullableValidator(stringValidator(maxLength: 9, pattern: "[0-9a-f]+"))(value: rev)
            self.rev = rev
        }
        public var description : String {
            return "\(prepareJSONForSerialization(DownloadArgSerializer().serialize(self)))"
        }
    }
    public class DownloadArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: DownloadArg) -> JSON {
            let output = [ 
            "path": Serialization._StringSerializer.serialize(value.path),
            "rev": NullableSerializer(Serialization._StringSerializer).serialize(value.rev),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> DownloadArg {
            switch json {
                case .Dictionary(let dict):
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .Null)
                    let rev = NullableSerializer(Serialization._StringSerializer).deserialize(dict["rev"] ?? .Null)
                    return DownloadArg(path: path, rev: rev)
                default:
                    assert(false, "Type error deserializing")
            }
        }
    }
    /// Errors related to commit conflicts.
    ///
    /// - File:
    ///   A file already exists at this path.
    /// - Folder:
    ///   A folder already exists at this path.
    /// - AutorenameFailed:
    ///   File could not be automatically renamed.
    /// - Other:
    ///   An unspecified error.
    public enum CommitConflictError : CustomStringConvertible {
        case File
        case Folder
        case AutorenameFailed
        case Other
        public var description : String {
            return "\(prepareJSONForSerialization(CommitConflictErrorSerializer().serialize(self)))"
        }
    }
    public class CommitConflictErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: CommitConflictError) -> JSON {
            switch value {
                case .File:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("file")
                    return .Dictionary(d)
                case .Folder:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("folder")
                    return .Dictionary(d)
                case .AutorenameFailed:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("autorename_failed")
                    return .Dictionary(d)
                case .Other:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> CommitConflictError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "file":
                            return CommitConflictError.File
                        case "folder":
                            return CommitConflictError.Folder
                        case "autorename_failed":
                            return CommitConflictError.AutorenameFailed
                        case "other":
                            return CommitConflictError.Other
                        default:
                            return CommitConflictError.Other
                    }
                default:
                    assert(false, "Failed to deserialize")
            }
        }
    }
    /// Errors from `upload`.
    ///
    /// - Conflict:
    ///   A conflict prevented the commit. See the value for the reason.
    /// - NoWritePermission:
    ///   User does not have permission to write in the folder. An example of
    ///   this is if the folder is a read-only shared folder.
    /// - InsufficientQuota:
    ///   User does not have sufficient space quota to save the file.
    /// - Other:
    ///   An unspecified error.
    public enum CommitError : CustomStringConvertible {
        case Conflict(Files.CommitConflictError)
        case NoWritePermission
        case InsufficientQuota
        case Other
        public var description : String {
            return "\(prepareJSONForSerialization(CommitErrorSerializer().serialize(self)))"
        }
    }
    public class CommitErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: CommitError) -> JSON {
            switch value {
                case .Conflict(let arg):
                    var d = ["conflict": CommitConflictErrorSerializer().serialize(arg)]
                    d[".tag"] = .Str("conflict")
                    return .Dictionary(d)
                case .NoWritePermission:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("no_write_permission")
                    return .Dictionary(d)
                case .InsufficientQuota:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("insufficient_quota")
                    return .Dictionary(d)
                case .Other:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> CommitError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "conflict":
                            let v = CommitConflictErrorSerializer().deserialize(d["conflict"] ?? .Null)
                            return CommitError.Conflict(v)
                        case "no_write_permission":
                            return CommitError.NoWritePermission
                        case "insufficient_quota":
                            return CommitError.InsufficientQuota
                        case "other":
                            return CommitError.Other
                        default:
                            return CommitError.Other
                    }
                default:
                    assert(false, "Failed to deserialize")
            }
        }
    }
    /// Error structure for commit errors.
    ///
    /// - parameter reason:
    ///        The reason why the commit failed.
    /// - parameter uploadSessionId:
    ///        The upload session ID; this may be used to retry the commit.
    public class UploadCommitError: CustomStringConvertible {
        public let reason : CommitError
        public let uploadSessionId : String
        public init(reason: CommitError, uploadSessionId: String) {
            self.reason = reason
            stringValidator()(value: uploadSessionId)
            self.uploadSessionId = uploadSessionId
        }
        public var description : String {
            return "\(prepareJSONForSerialization(UploadCommitErrorSerializer().serialize(self)))"
        }
    }
    public class UploadCommitErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: UploadCommitError) -> JSON {
            let output = [ 
            "reason": CommitErrorSerializer().serialize(value.reason),
            "upload_session_id": Serialization._StringSerializer.serialize(value.uploadSessionId),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> UploadCommitError {
            switch json {
                case .Dictionary(let dict):
                    let reason = CommitErrorSerializer().deserialize(dict["reason"] ?? .Null)
                    let uploadSessionId = Serialization._StringSerializer.deserialize(dict["upload_session_id"] ?? .Null)
                    return UploadCommitError(reason: reason, uploadSessionId: uploadSessionId)
                default:
                    assert(false, "Type error deserializing")
            }
        }
    }
    /// Error structure for recovering the correct upload offset.
    ///
    /// - parameter correctOffset:
    ///        The offset up to which data has been collected.
    public class UploadSessionOffsetError: CustomStringConvertible {
        public let correctOffset : UInt64
        public init(correctOffset: UInt64) {
            comparableValidator()(value: correctOffset)
            self.correctOffset = correctOffset
        }
        public var description : String {
            return "\(prepareJSONForSerialization(UploadSessionOffsetErrorSerializer().serialize(self)))"
        }
    }
    public class UploadSessionOffsetErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: UploadSessionOffsetError) -> JSON {
            let output = [ 
            "correct_offset": Serialization._UInt64Serializer.serialize(value.correctOffset),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> UploadSessionOffsetError {
            switch json {
                case .Dictionary(let dict):
                    let correctOffset = Serialization._UInt64Serializer.deserialize(dict["correct_offset"] ?? .Null)
                    return UploadSessionOffsetError(correctOffset: correctOffset)
                default:
                    assert(false, "Type error deserializing")
            }
        }
    }
    /// Errors related to upload sessions.
    ///
    /// - NotFound:
    ///   The upload session id was not found.
    /// - IncorrectOffset:
    ///   The specified offset was incorrect. See the value for the correct
    ///   offset. (This error may occur when a previous request was received and
    ///   processed successfully but the client did not receive the response,
    ///   e.g. due to a network error.)
    /// - Closed:
    ///   You are attempting to append data to an upload session that has alread
    ///   been closed (i.e. committed).
    /// - Other:
    ///   An unspecified error.
    public enum UploadSessionLookupError : CustomStringConvertible {
        case NotFound
        case IncorrectOffset(Files.UploadSessionOffsetError)
        case Closed
        case Other
        public var description : String {
            return "\(prepareJSONForSerialization(UploadSessionLookupErrorSerializer().serialize(self)))"
        }
    }
    public class UploadSessionLookupErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: UploadSessionLookupError) -> JSON {
            switch value {
                case .NotFound:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("not_found")
                    return .Dictionary(d)
                case .IncorrectOffset(let arg):
                    var d = Serialization.getFields(UploadSessionOffsetErrorSerializer().serialize(arg))
                    d[".tag"] = .Str("incorrect_offset")
                    return .Dictionary(d)
                case .Closed:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("closed")
                    return .Dictionary(d)
                case .Other:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> UploadSessionLookupError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "not_found":
                            return UploadSessionLookupError.NotFound
                        case "incorrect_offset":
                            let v = UploadSessionOffsetErrorSerializer().deserialize(json)
                            return UploadSessionLookupError.IncorrectOffset(v)
                        case "closed":
                            return UploadSessionLookupError.Closed
                        case "other":
                            return UploadSessionLookupError.Other
                        default:
                            return UploadSessionLookupError.Other
                    }
                default:
                    assert(false, "Failed to deserialize")
            }
        }
    }
    /// Errors for upload.
    ///
    /// - CommitFailed:
    ///   The upload failed; the value explains the reason.
    /// - Other:
    ///   An unspecified error.
    public enum UploadError : CustomStringConvertible {
        case CommitFailed(Files.UploadCommitError)
        case Other
        public var description : String {
            return "\(prepareJSONForSerialization(UploadErrorSerializer().serialize(self)))"
        }
    }
    public class UploadErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: UploadError) -> JSON {
            switch value {
                case .CommitFailed(let arg):
                    var d = Serialization.getFields(UploadCommitErrorSerializer().serialize(arg))
                    d[".tag"] = .Str("commit_failed")
                    return .Dictionary(d)
                case .Other:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> UploadError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "commit_failed":
                            let v = UploadCommitErrorSerializer().deserialize(json)
                            return UploadError.CommitFailed(v)
                        case "other":
                            return UploadError.Other
                        default:
                            return UploadError.Other
                    }
                default:
                    assert(false, "Failed to deserialize")
            }
        }
    }
    /// Errors for `upload_session/finish`.
    ///
    /// - LookupFailed:
    ///   The session arguments are incorrect; the value explains the reason.
    /// - CommitFailed:
    ///   The commit failed; the value explains the reason.
    /// - Other:
    ///   An unspecified error.
    public enum UploadSessionFinishError : CustomStringConvertible {
        case LookupFailed(Files.UploadSessionLookupError)
        case CommitFailed(Files.CommitError)
        case Other
        public var description : String {
            return "\(prepareJSONForSerialization(UploadSessionFinishErrorSerializer().serialize(self)))"
        }
    }
    public class UploadSessionFinishErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: UploadSessionFinishError) -> JSON {
            switch value {
                case .LookupFailed(let arg):
                    var d = ["lookup_failed": UploadSessionLookupErrorSerializer().serialize(arg)]
                    d[".tag"] = .Str("lookup_failed")
                    return .Dictionary(d)
                case .CommitFailed(let arg):
                    var d = ["commit_failed": CommitErrorSerializer().serialize(arg)]
                    d[".tag"] = .Str("commit_failed")
                    return .Dictionary(d)
                case .Other:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> UploadSessionFinishError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "lookup_failed":
                            let v = UploadSessionLookupErrorSerializer().deserialize(d["lookup_failed"] ?? .Null)
                            return UploadSessionFinishError.LookupFailed(v)
                        case "commit_failed":
                            let v = CommitErrorSerializer().deserialize(d["commit_failed"] ?? .Null)
                            return UploadSessionFinishError.CommitFailed(v)
                        case "other":
                            return UploadSessionFinishError.Other
                        default:
                            return UploadSessionFinishError.Other
                    }
                default:
                    assert(false, "Failed to deserialize")
            }
        }
    }
    /// The result of `upload_session/start`.
    ///
    /// - parameter sessionId:
    ///        A unique identifier for the upload session. Pass this to
    ///        `upload_session/append` and `upload_session/finish`.
    public class UploadSessionStartResult: CustomStringConvertible {
        public let sessionId : String
        public init(sessionId: String) {
            stringValidator()(value: sessionId)
            self.sessionId = sessionId
        }
        public var description : String {
            return "\(prepareJSONForSerialization(UploadSessionStartResultSerializer().serialize(self)))"
        }
    }
    public class UploadSessionStartResultSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: UploadSessionStartResult) -> JSON {
            let output = [ 
            "session_id": Serialization._StringSerializer.serialize(value.sessionId),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> UploadSessionStartResult {
            switch json {
                case .Dictionary(let dict):
                    let sessionId = Serialization._StringSerializer.deserialize(dict["session_id"] ?? .Null)
                    return UploadSessionStartResult(sessionId: sessionId)
                default:
                    assert(false, "Type error deserializing")
            }
        }
    }
    /// Arguments for `upload_session/append`. Also used by
    /// `upload_session/finish`.
    ///
    /// - parameter sessionId:
    ///        The upload session ID (returned by `upload_session/start`).
    /// - parameter offset:
    ///        The amount of data that has been uploaded so far. We use this to
    ///        make sure upload data isn't lost or duplicated in the event of a
    ///        network error.
    public class UploadSessionCursor: CustomStringConvertible {
        public let sessionId : String
        public let offset : UInt64
        public init(sessionId: String, offset: UInt64) {
            stringValidator()(value: sessionId)
            self.sessionId = sessionId
            comparableValidator()(value: offset)
            self.offset = offset
        }
        public var description : String {
            return "\(prepareJSONForSerialization(UploadSessionCursorSerializer().serialize(self)))"
        }
    }
    public class UploadSessionCursorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: UploadSessionCursor) -> JSON {
            let output = [ 
            "session_id": Serialization._StringSerializer.serialize(value.sessionId),
            "offset": Serialization._UInt64Serializer.serialize(value.offset),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> UploadSessionCursor {
            switch json {
                case .Dictionary(let dict):
                    let sessionId = Serialization._StringSerializer.deserialize(dict["session_id"] ?? .Null)
                    let offset = Serialization._UInt64Serializer.deserialize(dict["offset"] ?? .Null)
                    return UploadSessionCursor(sessionId: sessionId, offset: offset)
                default:
                    assert(false, "Type error deserializing")
            }
        }
    }
    /// Your intent when writing a file to some path. This is used to determine
    /// what constitutes a conflict and what the autorename strategy is. In some
    /// situations, the conflict behavior is identical: (a) If the target path
    /// doesn't contain anything, the file is always written; no conflict. (b)
    /// If the target path contains a folder, it's always a conflict. (c) If the
    /// target path contains a file with identical contents, nothing gets
    /// written; no conflict. The conflict checking differs in the case where
    /// there's a file at the target path with contents different from the
    /// contents you're trying to write.
    ///
    /// - Add:
    ///   It's always a conflict. The autorename strategy is to append a number
    ///   to the file name. For example "document.txt" might become "document
    ///   (2).txt".
    /// - Overwrite:
    ///   It's never a conflict. Overwrite the existing file. The autorename
    ///   strategy is the same as it is for `add`.
    /// - Update:
    ///   It's a conflict only if the current "rev" doesn't match the given
    ///   "rev". The autorename strategy is to append the string "conflicted
    ///   copy" to the file name. For example, "document.txt" might become
    ///   "document (conflicted copy).txt" or "document (Panda's conflicted
    ///   copy).txt".
    public enum WriteMode : CustomStringConvertible {
        case Add
        case Overwrite
        case Update(String)
        public var description : String {
            return "\(prepareJSONForSerialization(WriteModeSerializer().serialize(self)))"
        }
    }
    public class WriteModeSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: WriteMode) -> JSON {
            switch value {
                case .Add:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("add")
                    return .Dictionary(d)
                case .Overwrite:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("overwrite")
                    return .Dictionary(d)
                case .Update(let arg):
                    var d = ["update": Serialization._StringSerializer.serialize(arg)]
                    d[".tag"] = .Str("update")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> WriteMode {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "add":
                            return WriteMode.Add
                        case "overwrite":
                            return WriteMode.Overwrite
                        case "update":
                            let v = Serialization._StringSerializer.deserialize(d["update"] ?? .Null)
                            return WriteMode.Update(v)
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    assert(false, "Failed to deserialize")
            }
        }
    }
    /// Arguments for `upload`. Also part of the arguments to
    /// `upload_session/finish`.
    ///
    /// - parameter path:
    ///        Path in the user's Dropbox to save the file.
    /// - parameter mode:
    ///        Selects what to do if the file already exists.
    /// - parameter autorename:
    ///        If there's a conflict, as determined by `mode`, have the Dropbox
    ///        server try to autorename the file to avoid conflict.
    /// - parameter clientModified:
    ///        The value to store as the `client_modified` timestamp. Dropbox
    ///        automatically records the time at which the file was written to
    ///        the Dropbox servers. It can also record an additional timestamp,
    ///        provided by Dropbox desktop clients, mobile clients, and API apps
    ///        of when the file was actually created or modified.
    /// - parameter mute:
    ///        Normally, users are made aware of any file modifications in their
    ///        Dropbox account via notifications in the client software. If
    ///        `true`, this tells the clients that this modification shouldn't
    ///        result in a user notification.
    public class CommitInfo: CustomStringConvertible {
        public let path : String
        public let mode : WriteMode
        public let autorename : Bool
        public let clientModified : NSDate?
        public let mute : Bool
        public init(path: String, mode: WriteMode = .Add, autorename: Bool = false, clientModified: NSDate? = nil, mute: Bool = false) {
            stringValidator()(value: path)
            self.path = path
            self.mode = mode
            self.autorename = autorename
            self.clientModified = clientModified
            self.mute = mute
        }
        public var description : String {
            return "\(prepareJSONForSerialization(CommitInfoSerializer().serialize(self)))"
        }
    }
    public class CommitInfoSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: CommitInfo) -> JSON {
            let output = [ 
            "path": Serialization._StringSerializer.serialize(value.path),
            "mode": WriteModeSerializer().serialize(value.mode),
            "autorename": Serialization._BoolSerializer.serialize(value.autorename),
            "client_modified": NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.clientModified),
            "mute": Serialization._BoolSerializer.serialize(value.mute),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> CommitInfo {
            switch json {
                case .Dictionary(let dict):
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .Null)
                    let mode = WriteModeSerializer().deserialize(dict["mode"] ?? .Null)
                    let autorename = Serialization._BoolSerializer.deserialize(dict["autorename"] ?? .Null)
                    let clientModified = NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).deserialize(dict["client_modified"] ?? .Null)
                    let mute = Serialization._BoolSerializer.deserialize(dict["mute"] ?? .Null)
                    return CommitInfo(path: path, mode: mode, autorename: autorename, clientModified: clientModified, mute: mute)
                default:
                    assert(false, "Type error deserializing")
            }
        }
    }
    /// Arguments for `upload_session/finish`.
    ///
    /// - parameter cursor:
    ///        Contains the upload session ID and the offset.
    /// - parameter commit:
    ///        Contains the path and other optional modifiers for the commit.
    public class UploadSessionFinishArg: CustomStringConvertible {
        public let cursor : UploadSessionCursor
        public let commit : CommitInfo
        public init(cursor: UploadSessionCursor, commit: CommitInfo) {
            self.cursor = cursor
            self.commit = commit
        }
        public var description : String {
            return "\(prepareJSONForSerialization(UploadSessionFinishArgSerializer().serialize(self)))"
        }
    }
    public class UploadSessionFinishArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: UploadSessionFinishArg) -> JSON {
            let output = [ 
            "cursor": UploadSessionCursorSerializer().serialize(value.cursor),
            "commit": CommitInfoSerializer().serialize(value.commit),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> UploadSessionFinishArg {
            switch json {
                case .Dictionary(let dict):
                    let cursor = UploadSessionCursorSerializer().deserialize(dict["cursor"] ?? .Null)
                    let commit = CommitInfoSerializer().deserialize(dict["commit"] ?? .Null)
                    return UploadSessionFinishArg(cursor: cursor, commit: commit)
                default:
                    assert(false, "Type error deserializing")
            }
        }
    }
    /// Select which type of data to search.
    ///
    /// - Filename:
    ///   Search file and folder names.
    /// - FilenameAndContent:
    ///   Search file and folder names as well as file contents.
    /// - DeletedFilename:
    ///   Search for deleted file and folder names.
    public enum SearchMode : CustomStringConvertible {
        case Filename
        case FilenameAndContent
        case DeletedFilename
        public var description : String {
            return "\(prepareJSONForSerialization(SearchModeSerializer().serialize(self)))"
        }
    }
    public class SearchModeSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: SearchMode) -> JSON {
            switch value {
                case .Filename:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("filename")
                    return .Dictionary(d)
                case .FilenameAndContent:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("filename_and_content")
                    return .Dictionary(d)
                case .DeletedFilename:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("deleted_filename")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> SearchMode {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "filename":
                            return SearchMode.Filename
                        case "filename_and_content":
                            return SearchMode.FilenameAndContent
                        case "deleted_filename":
                            return SearchMode.DeletedFilename
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    assert(false, "Failed to deserialize")
            }
        }
    }
    /// Arguments for `search`.
    ///
    /// - parameter path:
    ///        The path in the user's Dropbox to search. Should probably be a
    ///        folder. May be the root (i.e. empty).
    /// - parameter query:
    ///        The string to search for. The search string is split on spaces
    ///        into multiple tokens. For file name searching, the last token is
    ///        used for prefix matching (i.e. "bat c" matches "bat cave" but not
    ///        "batman car").
    /// - parameter start:
    ///        The starting index within the search results (used for paging).
    /// - parameter maxResults:
    ///        The maximum number of search results to return.
    /// - parameter mode:
    ///        The search mode (filename, filename_and_content, or
    ///        deleted_filename).
    public class SearchQuery: CustomStringConvertible {
        public let path : String
        public let query : String
        public let start : UInt64
        public let maxResults : UInt64
        public let mode : SearchMode
        public init(path: String, query: String, start: UInt64 = 0, maxResults: UInt64 = 100, mode: SearchMode = .Filename) {
            stringValidator()(value: path)
            self.path = path
            stringValidator()(value: query)
            self.query = query
            comparableValidator()(value: start)
            self.start = start
            comparableValidator(1, maxValue: 1000)(value: maxResults)
            self.maxResults = maxResults
            self.mode = mode
        }
        public var description : String {
            return "\(prepareJSONForSerialization(SearchQuerySerializer().serialize(self)))"
        }
    }
    public class SearchQuerySerializer: JSONSerializer {
        public init() { }
        public func serialize(value: SearchQuery) -> JSON {
            let output = [ 
            "path": Serialization._StringSerializer.serialize(value.path),
            "query": Serialization._StringSerializer.serialize(value.query),
            "start": Serialization._UInt64Serializer.serialize(value.start),
            "max_results": Serialization._UInt64Serializer.serialize(value.maxResults),
            "mode": SearchModeSerializer().serialize(value.mode),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> SearchQuery {
            switch json {
                case .Dictionary(let dict):
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .Null)
                    let query = Serialization._StringSerializer.deserialize(dict["query"] ?? .Null)
                    let start = Serialization._UInt64Serializer.deserialize(dict["start"] ?? .Null)
                    let maxResults = Serialization._UInt64Serializer.deserialize(dict["max_results"] ?? .Null)
                    let mode = SearchModeSerializer().deserialize(dict["mode"] ?? .Null)
                    return SearchQuery(path: path, query: query, start: start, maxResults: maxResults, mode: mode)
                default:
                    assert(false, "Type error deserializing")
            }
        }
    }
    /// Indicates what type of match was found for a given item.
    ///
    /// - Filename:
    ///   This item was matched on its file or folder name.
    /// - Content:
    ///   This item was matched based on its file contents.
    /// - Both:
    ///   This item was matched based on both its contents and its file name.
    public enum SearchMatchType : CustomStringConvertible {
        case Filename
        case Content
        case Both
        public var description : String {
            return "\(prepareJSONForSerialization(SearchMatchTypeSerializer().serialize(self)))"
        }
    }
    public class SearchMatchTypeSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: SearchMatchType) -> JSON {
            switch value {
                case .Filename:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("filename")
                    return .Dictionary(d)
                case .Content:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("content")
                    return .Dictionary(d)
                case .Both:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("both")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> SearchMatchType {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "filename":
                            return SearchMatchType.Filename
                        case "content":
                            return SearchMatchType.Content
                        case "both":
                            return SearchMatchType.Both
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    assert(false, "Failed to deserialize")
            }
        }
    }
    /// Describes a search result.
    ///
    /// - parameter matchType:
    ///        The type of the match.
    /// - parameter metadata:
    ///        The metadata for the matched file or folder.
    public class SearchMatch: CustomStringConvertible {
        public let matchType : SearchMatchType
        public let metadata : Metadata
        public init(matchType: SearchMatchType, metadata: Metadata) {
            self.matchType = matchType
            self.metadata = metadata
        }
        public var description : String {
            return "\(prepareJSONForSerialization(SearchMatchSerializer().serialize(self)))"
        }
    }
    public class SearchMatchSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: SearchMatch) -> JSON {
            let output = [ 
            "match_type": SearchMatchTypeSerializer().serialize(value.matchType),
            "metadata": MetadataSerializer().serialize(value.metadata),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> SearchMatch {
            switch json {
                case .Dictionary(let dict):
                    let matchType = SearchMatchTypeSerializer().deserialize(dict["match_type"] ?? .Null)
                    let metadata = MetadataSerializer().deserialize(dict["metadata"] ?? .Null)
                    return SearchMatch(matchType: matchType, metadata: metadata)
                default:
                    assert(false, "Type error deserializing")
            }
        }
    }
    /// Information returned by `search`.
    ///
    /// - parameter matches:
    ///        A list (possibly empty) of matches for the query.
    /// - parameter more:
    ///        Used for paging. If true, indicates there is another page of
    ///        results available that can be fetched by calling `search` again.
    /// - parameter start:
    ///        Used for paging. Value to set the start argument to when calling
    ///        `search` to fetch the next page of results.
    public class SearchResults: CustomStringConvertible {
        public let matches : Array<SearchMatch>
        public let more : Bool
        public let start : UInt64
        public init(matches: Array<SearchMatch>, more: Bool, start: UInt64) {
            self.matches = matches
            self.more = more
            comparableValidator()(value: start)
            self.start = start
        }
        public var description : String {
            return "\(prepareJSONForSerialization(SearchResultsSerializer().serialize(self)))"
        }
    }
    public class SearchResultsSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: SearchResults) -> JSON {
            let output = [ 
            "matches": ArraySerializer(SearchMatchSerializer()).serialize(value.matches),
            "more": Serialization._BoolSerializer.serialize(value.more),
            "start": Serialization._UInt64Serializer.serialize(value.start),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> SearchResults {
            switch json {
                case .Dictionary(let dict):
                    let matches = ArraySerializer(SearchMatchSerializer()).deserialize(dict["matches"] ?? .Null)
                    let more = Serialization._BoolSerializer.deserialize(dict["more"] ?? .Null)
                    let start = Serialization._UInt64Serializer.deserialize(dict["start"] ?? .Null)
                    return SearchResults(matches: matches, more: more, start: start)
                default:
                    assert(false, "Type error deserializing")
            }
        }
    }
    /// Errors for `search`.
    ///
    /// - Other:
    ///   An unspecified error.
    public enum SearchError : CustomStringConvertible {
        case Other
        public var description : String {
            return "\(prepareJSONForSerialization(SearchErrorSerializer().serialize(self)))"
        }
    }
    public class SearchErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: SearchError) -> JSON {
            switch value {
                case .Other:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> SearchError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "other":
                            return SearchError.Other
                        default:
                            return SearchError.Other
                    }
                default:
                    assert(false, "Failed to deserialize")
            }
        }
    }
    /// Path validation errors.
    ///
    /// - RootDisallowed:
    ///   The path should not be empty.
    /// - MalformedPath:
    ///   The path is invalid; the message gives more info.
    /// - NotFound:
    ///   The path does not exist.
    /// - FileDisallowed:
    ///   The path should refer to a folder.
    /// - FolderDisallowed:
    ///   The path should refer to a file.
    /// - ConflictFile:
    ///   A file already exists there.
    /// - ConflictFolder:
    ///   A folder already exists there.
    /// - ConflictFileAncestor:
    ///   An ancestor is a file.
    /// - ReadOnly:
    ///   No write permission.
    /// - SharedFolderDisallowed:
    ///   The path should not refer to a shared folder.
    /// - AutorenameFiled:
    ///   Automatic rename would result in a malformed path (e.g. too long).
    /// - Misc:
    ///   Miscellaneous error (see error message).
    /// - Other:
    ///   An unspecified error.
    public enum PathError : CustomStringConvertible {
        case RootDisallowed
        case MalformedPath(String)
        case NotFound
        case FileDisallowed
        case FolderDisallowed
        case ConflictFile
        case ConflictFolder
        case ConflictFileAncestor
        case ReadOnly
        case SharedFolderDisallowed
        case AutorenameFiled
        case Misc(String)
        case Other
        public var description : String {
            return "\(prepareJSONForSerialization(PathErrorSerializer().serialize(self)))"
        }
    }
    public class PathErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: PathError) -> JSON {
            switch value {
                case .RootDisallowed:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("root_disallowed")
                    return .Dictionary(d)
                case .MalformedPath(let arg):
                    var d = ["malformed_path": Serialization._StringSerializer.serialize(arg)]
                    d[".tag"] = .Str("malformed_path")
                    return .Dictionary(d)
                case .NotFound:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("not_found")
                    return .Dictionary(d)
                case .FileDisallowed:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("file_disallowed")
                    return .Dictionary(d)
                case .FolderDisallowed:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("folder_disallowed")
                    return .Dictionary(d)
                case .ConflictFile:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("conflict_file")
                    return .Dictionary(d)
                case .ConflictFolder:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("conflict_folder")
                    return .Dictionary(d)
                case .ConflictFileAncestor:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("conflict_file_ancestor")
                    return .Dictionary(d)
                case .ReadOnly:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("read_only")
                    return .Dictionary(d)
                case .SharedFolderDisallowed:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("shared_folder_disallowed")
                    return .Dictionary(d)
                case .AutorenameFiled:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("autorename_filed")
                    return .Dictionary(d)
                case .Misc(let arg):
                    var d = ["misc": Serialization._StringSerializer.serialize(arg)]
                    d[".tag"] = .Str("misc")
                    return .Dictionary(d)
                case .Other:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> PathError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "root_disallowed":
                            return PathError.RootDisallowed
                        case "malformed_path":
                            let v = Serialization._StringSerializer.deserialize(d["malformed_path"] ?? .Null)
                            return PathError.MalformedPath(v)
                        case "not_found":
                            return PathError.NotFound
                        case "file_disallowed":
                            return PathError.FileDisallowed
                        case "folder_disallowed":
                            return PathError.FolderDisallowed
                        case "conflict_file":
                            return PathError.ConflictFile
                        case "conflict_folder":
                            return PathError.ConflictFolder
                        case "conflict_file_ancestor":
                            return PathError.ConflictFileAncestor
                        case "read_only":
                            return PathError.ReadOnly
                        case "shared_folder_disallowed":
                            return PathError.SharedFolderDisallowed
                        case "autorename_filed":
                            return PathError.AutorenameFiled
                        case "misc":
                            let v = Serialization._StringSerializer.deserialize(d["misc"] ?? .Null)
                            return PathError.Misc(v)
                        case "other":
                            return PathError.Other
                        default:
                            return PathError.Other
                    }
                default:
                    assert(false, "Failed to deserialize")
            }
        }
    }
    /// Arguments for `create_folder`.
    ///
    /// - parameter path:
    ///        Path in the user's Dropbox to create.
    public class CreateFolderArg: CustomStringConvertible {
        public let path : String
        public init(path: String) {
            stringValidator()(value: path)
            self.path = path
        }
        public var description : String {
            return "\(prepareJSONForSerialization(CreateFolderArgSerializer().serialize(self)))"
        }
    }
    public class CreateFolderArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: CreateFolderArg) -> JSON {
            let output = [ 
            "path": Serialization._StringSerializer.serialize(value.path),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> CreateFolderArg {
            switch json {
                case .Dictionary(let dict):
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .Null)
                    return CreateFolderArg(path: path)
                default:
                    assert(false, "Type error deserializing")
            }
        }
    }
    /// Arguments for `delete`.
    ///
    /// - parameter path:
    ///        Path in the user's Dropbox to delete.
    public class DeleteArg: CustomStringConvertible {
        public let path : String
        public init(path: String) {
            stringValidator()(value: path)
            self.path = path
        }
        public var description : String {
            return "\(prepareJSONForSerialization(DeleteArgSerializer().serialize(self)))"
        }
    }
    public class DeleteArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: DeleteArg) -> JSON {
            let output = [ 
            "path": Serialization._StringSerializer.serialize(value.path),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> DeleteArg {
            switch json {
                case .Dictionary(let dict):
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .Null)
                    return DeleteArg(path: path)
                default:
                    assert(false, "Type error deserializing")
            }
        }
    }
    /// Arguments for `copy` and `move`.
    ///
    /// - parameter fromPath:
    ///        Path in the user's Dropbox to be copied or moved.
    /// - parameter toPath:
    ///        Path in the user's Dropbox that is the destination.
    public class RelocationArg: CustomStringConvertible {
        public let fromPath : String
        public let toPath : String
        public init(fromPath: String, toPath: String) {
            stringValidator()(value: fromPath)
            self.fromPath = fromPath
            stringValidator()(value: toPath)
            self.toPath = toPath
        }
        public var description : String {
            return "\(prepareJSONForSerialization(RelocationArgSerializer().serialize(self)))"
        }
    }
    public class RelocationArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: RelocationArg) -> JSON {
            let output = [ 
            "from_path": Serialization._StringSerializer.serialize(value.fromPath),
            "to_path": Serialization._StringSerializer.serialize(value.toPath),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> RelocationArg {
            switch json {
                case .Dictionary(let dict):
                    let fromPath = Serialization._StringSerializer.deserialize(dict["from_path"] ?? .Null)
                    let toPath = Serialization._StringSerializer.deserialize(dict["to_path"] ?? .Null)
                    return RelocationArg(fromPath: fromPath, toPath: toPath)
                default:
                    assert(false, "Type error deserializing")
            }
        }
    }
    /// Errors reported by `copy` and `move`. This is not just an extension of
    /// PathError; there are alternatives for errors relating to the source, the
    /// destination, and the copy operation itself.
    ///
    /// - FromError:
    ///   The operation is disallowed due to a problem with the source path.
    /// - ToError:
    ///   The operation is disallowed due to a problem with the destination
    ///   path.
    /// - TooManyFiles:
    ///   The operation would involve more than 10,000 files and folders.
    /// - QuotaError:
    ///   Quota exceeded.
    /// - Other:
    ///   An unspecified error.
    public enum RelocationError : CustomStringConvertible {
        case FromError(Files.PathError)
        case ToError(Files.PathError)
        case TooManyFiles
        case QuotaError
        case Other
        public var description : String {
            return "\(prepareJSONForSerialization(RelocationErrorSerializer().serialize(self)))"
        }
    }
    public class RelocationErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: RelocationError) -> JSON {
            switch value {
                case .FromError(let arg):
                    var d = ["from_error": PathErrorSerializer().serialize(arg)]
                    d[".tag"] = .Str("from_error")
                    return .Dictionary(d)
                case .ToError(let arg):
                    var d = ["to_error": PathErrorSerializer().serialize(arg)]
                    d[".tag"] = .Str("to_error")
                    return .Dictionary(d)
                case .TooManyFiles:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("too_many_files")
                    return .Dictionary(d)
                case .QuotaError:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("quota_error")
                    return .Dictionary(d)
                case .Other:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> RelocationError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "from_error":
                            let v = PathErrorSerializer().deserialize(d["from_error"] ?? .Null)
                            return RelocationError.FromError(v)
                        case "to_error":
                            let v = PathErrorSerializer().deserialize(d["to_error"] ?? .Null)
                            return RelocationError.ToError(v)
                        case "too_many_files":
                            return RelocationError.TooManyFiles
                        case "quota_error":
                            return RelocationError.QuotaError
                        case "other":
                            return RelocationError.Other
                        default:
                            return RelocationError.Other
                    }
                default:
                    assert(false, "Failed to deserialize")
            }
        }
    }
    /// The size option for thumbnail image.
    ///
    /// - Xs:
    ///   32 by 32 px.
    /// - S:
    ///   64 by 64 px.
    /// - M:
    ///   128 by 128 px.
    /// - L:
    ///   640 by 480 px.
    /// - Xl:
    ///   1024 by 768
    public enum ThumbnailSize : CustomStringConvertible {
        case Xs
        case S
        case M
        case L
        case Xl
        public var description : String {
            return "\(prepareJSONForSerialization(ThumbnailSizeSerializer().serialize(self)))"
        }
    }
    public class ThumbnailSizeSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: ThumbnailSize) -> JSON {
            switch value {
                case .Xs:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("xs")
                    return .Dictionary(d)
                case .S:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("s")
                    return .Dictionary(d)
                case .M:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("m")
                    return .Dictionary(d)
                case .L:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("l")
                    return .Dictionary(d)
                case .Xl:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("xl")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> ThumbnailSize {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "xs":
                            return ThumbnailSize.Xs
                        case "s":
                            return ThumbnailSize.S
                        case "m":
                            return ThumbnailSize.M
                        case "l":
                            return ThumbnailSize.L
                        case "xl":
                            return ThumbnailSize.Xl
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    assert(false, "Failed to deserialize")
            }
        }
    }
    /// The format option for thumbnail image.
    ///
    /// - Jpeg
    /// - Png
    public enum ThumbnailFormat : CustomStringConvertible {
        case Jpeg
        case Png
        public var description : String {
            return "\(prepareJSONForSerialization(ThumbnailFormatSerializer().serialize(self)))"
        }
    }
    public class ThumbnailFormatSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: ThumbnailFormat) -> JSON {
            switch value {
                case .Jpeg:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("jpeg")
                    return .Dictionary(d)
                case .Png:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("png")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> ThumbnailFormat {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "jpeg":
                            return ThumbnailFormat.Jpeg
                        case "png":
                            return ThumbnailFormat.Png
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    assert(false, "Failed to deserialize")
            }
        }
    }
    /// Arguments for `get_thumbnail`. This method currently supports files with
    /// the following file extensions: jpg, jpeg, png, tiff, tif, gif and bmp.
    /// Photos that are larger than 20MB in size won't be converted to a
    /// thumbnail.
    ///
    /// - parameter path:
    ///        The path to the image file you want to thumbnail.
    /// - parameter format:
    ///        The format for the thumbnail image, jpeg (default) or png. For
    ///        images that are photos, jpeg should be preferred, while png is
    ///        better for screenshots and digital arts.
    /// - parameter size:
    ///        The size for the thumbnail image (default s).
    public class ThumbnailArg: CustomStringConvertible {
        public let path : String
        public let format : ThumbnailFormat
        public let size : ThumbnailSize
        public init(path: String, format: ThumbnailFormat = .Jpeg, size: ThumbnailSize = .S) {
            stringValidator()(value: path)
            self.path = path
            self.format = format
            self.size = size
        }
        public var description : String {
            return "\(prepareJSONForSerialization(ThumbnailArgSerializer().serialize(self)))"
        }
    }
    public class ThumbnailArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: ThumbnailArg) -> JSON {
            let output = [ 
            "path": Serialization._StringSerializer.serialize(value.path),
            "format": ThumbnailFormatSerializer().serialize(value.format),
            "size": ThumbnailSizeSerializer().serialize(value.size),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> ThumbnailArg {
            switch json {
                case .Dictionary(let dict):
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .Null)
                    let format = ThumbnailFormatSerializer().deserialize(dict["format"] ?? .Null)
                    let size = ThumbnailSizeSerializer().deserialize(dict["size"] ?? .Null)
                    return ThumbnailArg(path: path, format: format, size: size)
                default:
                    assert(false, "Type error deserializing")
            }
        }
    }
    /// Errors reported by `get_thumbnail`.
    ///
    /// - DownloadError:
    ///   An error occurs when downloading metadata for the image.
    /// - UnsupportedExtension:
    ///   The file extension doesn't allow conversion to a thumbnail.
    /// - UnsupportedFormat:
    ///   The thumbnail format specified is not supported.
    /// - UnsupportedSize:
    ///   The size value specified is not supported.
    /// - UnsupportedImage:
    ///   The image cannot be converted to a thumbnail.
    /// - ConversionError:
    ///   An error occurs during thumbnail conversion.
    public enum ThumbnailError : CustomStringConvertible {
        case DownloadError(Files.DownloadError)
        case UnsupportedExtension
        case UnsupportedFormat
        case UnsupportedSize
        case UnsupportedImage
        case ConversionError
        public var description : String {
            return "\(prepareJSONForSerialization(ThumbnailErrorSerializer().serialize(self)))"
        }
    }
    public class ThumbnailErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: ThumbnailError) -> JSON {
            switch value {
                case .DownloadError(let arg):
                    var d = ["download_error": DownloadErrorSerializer().serialize(arg)]
                    d[".tag"] = .Str("download_error")
                    return .Dictionary(d)
                case .UnsupportedExtension:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("unsupported_extension")
                    return .Dictionary(d)
                case .UnsupportedFormat:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("unsupported_format")
                    return .Dictionary(d)
                case .UnsupportedSize:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("unsupported_size")
                    return .Dictionary(d)
                case .UnsupportedImage:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("unsupported_image")
                    return .Dictionary(d)
                case .ConversionError:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("conversion_error")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> ThumbnailError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "download_error":
                            let v = DownloadErrorSerializer().deserialize(d["download_error"] ?? .Null)
                            return ThumbnailError.DownloadError(v)
                        case "unsupported_extension":
                            return ThumbnailError.UnsupportedExtension
                        case "unsupported_format":
                            return ThumbnailError.UnsupportedFormat
                        case "unsupported_size":
                            return ThumbnailError.UnsupportedSize
                        case "unsupported_image":
                            return ThumbnailError.UnsupportedImage
                        case "conversion_error":
                            return ThumbnailError.ConversionError
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    assert(false, "Failed to deserialize")
            }
        }
    }
    /// Arguments for `get_preview`.
    ///
    /// - parameter path:
    ///        The path of the file to preview.
    /// - parameter rev:
    ///        Optional revision, taken from the corresponding `Metadata` field.
    public class PreviewArg: CustomStringConvertible {
        public let path : String
        public let rev : String?
        public init(path: String, rev: String? = nil) {
            stringValidator()(value: path)
            self.path = path
            nullableValidator(stringValidator(maxLength: 9, pattern: "[0-9a-f]+"))(value: rev)
            self.rev = rev
        }
        public var description : String {
            return "\(prepareJSONForSerialization(PreviewArgSerializer().serialize(self)))"
        }
    }
    public class PreviewArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: PreviewArg) -> JSON {
            let output = [ 
            "path": Serialization._StringSerializer.serialize(value.path),
            "rev": NullableSerializer(Serialization._StringSerializer).serialize(value.rev),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> PreviewArg {
            switch json {
                case .Dictionary(let dict):
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .Null)
                    let rev = NullableSerializer(Serialization._StringSerializer).deserialize(dict["rev"] ?? .Null)
                    return PreviewArg(path: path, rev: rev)
                default:
                    assert(false, "Type error deserializing")
            }
        }
    }
    /// Errors reported by `get_preview`.
    ///
    /// - DownloadError:
    ///   An error occurs when downloading metadata for the file.
    /// - InProgress:
    ///   This preview generation is still in progress and the file is not ready
    ///   for preview yet.
    /// - UnsupportedExtension:
    ///   The file extension is not supported preview generation.
    /// - UnsupportedContent:
    ///   The file content is not supported for preview generation.
    public enum PreviewError : CustomStringConvertible {
        case DownloadError(Files.DownloadError)
        case InProgress
        case UnsupportedExtension
        case UnsupportedContent
        public var description : String {
            return "\(prepareJSONForSerialization(PreviewErrorSerializer().serialize(self)))"
        }
    }
    public class PreviewErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: PreviewError) -> JSON {
            switch value {
                case .DownloadError(let arg):
                    var d = ["download_error": DownloadErrorSerializer().serialize(arg)]
                    d[".tag"] = .Str("download_error")
                    return .Dictionary(d)
                case .InProgress:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("in_progress")
                    return .Dictionary(d)
                case .UnsupportedExtension:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("unsupported_extension")
                    return .Dictionary(d)
                case .UnsupportedContent:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("unsupported_content")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> PreviewError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "download_error":
                            let v = DownloadErrorSerializer().deserialize(d["download_error"] ?? .Null)
                            return PreviewError.DownloadError(v)
                        case "in_progress":
                            return PreviewError.InProgress
                        case "unsupported_extension":
                            return PreviewError.UnsupportedExtension
                        case "unsupported_content":
                            return PreviewError.UnsupportedContent
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    assert(false, "Failed to deserialize")
            }
        }
    }
    /// Arguments for `list_revisions`.
    ///
    /// - parameter path:
    ///        The path to the file you want to see the revisions of.
    /// - parameter limit:
    ///        The maximum number of revision entries returned.
    public class ListRevisionsArg: CustomStringConvertible {
        public let path : String
        public let limit : UInt64
        public init(path: String, limit: UInt64 = 10) {
            stringValidator()(value: path)
            self.path = path
            comparableValidator(1, maxValue: 100)(value: limit)
            self.limit = limit
        }
        public var description : String {
            return "\(prepareJSONForSerialization(ListRevisionsArgSerializer().serialize(self)))"
        }
    }
    public class ListRevisionsArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: ListRevisionsArg) -> JSON {
            let output = [ 
            "path": Serialization._StringSerializer.serialize(value.path),
            "limit": Serialization._UInt64Serializer.serialize(value.limit),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> ListRevisionsArg {
            switch json {
                case .Dictionary(let dict):
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .Null)
                    let limit = Serialization._UInt64Serializer.deserialize(dict["limit"] ?? .Null)
                    return ListRevisionsArg(path: path, limit: limit)
                default:
                    assert(false, "Type error deserializing")
            }
        }
    }
    /// Errors reported by `list_revisions`.
    ///
    /// - DownloadError:
    ///   An error occurs when downloading metadata for the file.
    public enum ListRevisionsError : CustomStringConvertible {
        case DownloadError(Files.DownloadError)
        public var description : String {
            return "\(prepareJSONForSerialization(ListRevisionsErrorSerializer().serialize(self)))"
        }
    }
    public class ListRevisionsErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: ListRevisionsError) -> JSON {
            switch value {
                case .DownloadError(let arg):
                    var d = ["download_error": DownloadErrorSerializer().serialize(arg)]
                    d[".tag"] = .Str("download_error")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> ListRevisionsError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "download_error":
                            let v = DownloadErrorSerializer().deserialize(d["download_error"] ?? .Null)
                            return ListRevisionsError.DownloadError(v)
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    assert(false, "Failed to deserialize")
            }
        }
    }
    /// Information returned by `list_revisions`.
    ///
    /// - parameter isDeleted:
    ///        If the file is deleted.
    /// - parameter entries:
    ///        The revisions for the file. Only non-delete revisions will show
    ///        up here.
    public class ListRevisionsResult: CustomStringConvertible {
        public let isDeleted : Bool
        public let entries : Array<FileMetadata>
        public init(isDeleted: Bool, entries: Array<FileMetadata>) {
            self.isDeleted = isDeleted
            self.entries = entries
        }
        public var description : String {
            return "\(prepareJSONForSerialization(ListRevisionsResultSerializer().serialize(self)))"
        }
    }
    public class ListRevisionsResultSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: ListRevisionsResult) -> JSON {
            let output = [ 
            "is_deleted": Serialization._BoolSerializer.serialize(value.isDeleted),
            "entries": ArraySerializer(FileMetadataSerializer()).serialize(value.entries),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> ListRevisionsResult {
            switch json {
                case .Dictionary(let dict):
                    let isDeleted = Serialization._BoolSerializer.deserialize(dict["is_deleted"] ?? .Null)
                    let entries = ArraySerializer(FileMetadataSerializer()).deserialize(dict["entries"] ?? .Null)
                    return ListRevisionsResult(isDeleted: isDeleted, entries: entries)
                default:
                    assert(false, "Type error deserializing")
            }
        }
    }
    /// Arguments for `restore`.
    ///
    /// - parameter path:
    ///        The path to the file you want to restore.
    /// - parameter rev:
    ///        The revision to restore for the file.
    public class RestoreArg: CustomStringConvertible {
        public let path : String
        public let rev : String
        public init(path: String, rev: String) {
            stringValidator()(value: path)
            self.path = path
            stringValidator(maxLength: 9, pattern: "[0-9a-f]+")(value: rev)
            self.rev = rev
        }
        public var description : String {
            return "\(prepareJSONForSerialization(RestoreArgSerializer().serialize(self)))"
        }
    }
    public class RestoreArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: RestoreArg) -> JSON {
            let output = [ 
            "path": Serialization._StringSerializer.serialize(value.path),
            "rev": Serialization._StringSerializer.serialize(value.rev),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> RestoreArg {
            switch json {
                case .Dictionary(let dict):
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .Null)
                    let rev = Serialization._StringSerializer.deserialize(dict["rev"] ?? .Null)
                    return RestoreArg(path: path, rev: rev)
                default:
                    assert(false, "Type error deserializing")
            }
        }
    }
    /// Errors reported by `restore`.
    ///
    /// - DownloadError:
    ///   An error occurs when downloading metadata for the file.
    /// - CommitFailed:
    ///   The commit for the restore failed.
    /// - InvalidRevision:
    ///   The revision is invalid. It may point to a different file.
    public enum RestoreError : CustomStringConvertible {
        case DownloadError(Files.DownloadError)
        case CommitFailed(Files.CommitError)
        case InvalidRevision
        public var description : String {
            return "\(prepareJSONForSerialization(RestoreErrorSerializer().serialize(self)))"
        }
    }
    public class RestoreErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: RestoreError) -> JSON {
            switch value {
                case .DownloadError(let arg):
                    var d = ["download_error": DownloadErrorSerializer().serialize(arg)]
                    d[".tag"] = .Str("download_error")
                    return .Dictionary(d)
                case .CommitFailed(let arg):
                    var d = ["commit_failed": CommitErrorSerializer().serialize(arg)]
                    d[".tag"] = .Str("commit_failed")
                    return .Dictionary(d)
                case .InvalidRevision:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("invalid_revision")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> RestoreError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "download_error":
                            let v = DownloadErrorSerializer().deserialize(d["download_error"] ?? .Null)
                            return RestoreError.DownloadError(v)
                        case "commit_failed":
                            let v = CommitErrorSerializer().deserialize(d["commit_failed"] ?? .Null)
                            return RestoreError.CommitFailed(v)
                        case "invalid_revision":
                            return RestoreError.InvalidRevision
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    assert(false, "Failed to deserialize")
            }
        }
    }
}
extension BabelClient {
    /// Returns the metadata for a file or folder.
    ///
    /// - parameter path:
    ///        The path or ID of a file or folder on Dropbox. Must not be the
    ///        root.
    public func filesGetMetadata(path path: String) -> BabelRpcRequest<Files.MetadataSerializer, Files.GetMetadataErrorSerializer> {
        let request = Files.GetMetadataArg(path: path)
        return BabelRpcRequest(client: self, host: "meta", route: "/files/get_metadata", params: Files.GetMetadataArgSerializer().serialize(request), responseSerializer: Files.MetadataSerializer(), errorSerializer: Files.GetMetadataErrorSerializer())
    }
    /// Returns the contents of a folder. NOTE: We're definitely going to
    /// streamline this interface.
    ///
    /// - parameter path:
    ///        The path to the folder you want to see the contents of. May be
    ///        the root (i.e. empty).
    /// - parameter recursive:
    ///        If true, list folder operation will be applied recursively to all
    ///        subfolders. And the response will contain contents of all
    ///        subfolders
    public func filesListFolder(path path: String, recursive: Bool = false) -> BabelRpcRequest<Files.ListFolderResultSerializer, Files.ListFolderErrorSerializer> {
        let request = Files.ListFolderArg(path: path, recursive: recursive)
        return BabelRpcRequest(client: self, host: "meta", route: "/files/list_folder", params: Files.ListFolderArgSerializer().serialize(request), responseSerializer: Files.ListFolderResultSerializer(), errorSerializer: Files.ListFolderErrorSerializer())
    }
    /// Once a cursor has been retrieved from :route:`list_folder`, use this to
    /// paginate through all files and retrieve updates to the folder. NOTE:
    /// We're definitely going to streamline this interface.
    ///
    /// - parameter cursor:
    ///        The cursor returned by `list_folder` or `list_folder/continue`.
    public func filesListFolderContinue(cursor cursor: String) -> BabelRpcRequest<Files.ListFolderResultSerializer, Files.ListFolderContinueErrorSerializer> {
        let request = Files.ListFolderContinueArg(cursor: cursor)
        return BabelRpcRequest(client: self, host: "meta", route: "/files/list_folder/continue", params: Files.ListFolderContinueArgSerializer().serialize(request), responseSerializer: Files.ListFolderResultSerializer(), errorSerializer: Files.ListFolderContinueErrorSerializer())
    }
    /// A way to quickly get a cursor for the folder's state. Unlike
    /// :route:`list_folder`, :route:`list_folder/get_latest_cursor` doesn't
    /// return any entries. This endpoint is for app which only needs to know
    /// about new files and modifications and doesn't need to know about files
    /// that already exist in Dropbox.
    ///
    /// - parameter path:
    ///        The path to the folder you want to see the contents of. May be
    ///        the root (i.e. empty).
    /// - parameter recursive:
    ///        If true, list folder operation will be applied recursively to all
    ///        subfolders. And the response will contain contents of all
    ///        subfolders
    public func filesListFolderGetLatestCursor(path path: String, recursive: Bool = false) -> BabelRpcRequest<Files.ListFolderGetLatestCursorResultSerializer, Files.ListFolderErrorSerializer> {
        let request = Files.ListFolderArg(path: path, recursive: recursive)
        return BabelRpcRequest(client: self, host: "meta", route: "/files/list_folder/get_latest_cursor", params: Files.ListFolderArgSerializer().serialize(request), responseSerializer: Files.ListFolderGetLatestCursorResultSerializer(), errorSerializer: Files.ListFolderErrorSerializer())
    }
    /// Download a file from a user's Dropbox.
    ///
    /// - parameter path:
    ///        The path of the file to download.
    /// - parameter rev:
    ///        Optional revision, taken from the corresponding `Metadata` field.
    public func filesDownload(path path: String, rev: String? = nil) -> BabelDownloadRequest<Files.FileMetadataSerializer, Files.DownloadErrorSerializer> {
        let request = Files.DownloadArg(path: path, rev: rev)
        return BabelDownloadRequest(client: self, host: "content", route: "/files/download", params: Files.DownloadArgSerializer().serialize(request), responseSerializer: Files.FileMetadataSerializer(), errorSerializer: Files.DownloadErrorSerializer())
    }
    /// Start a new upload session. This is used to upload a single file with
    /// multiple calls.
    ///
    /// - parameter body:
    ///        The binary payload to upload
    public func filesUploadSessionStart(body body: NSData) -> BabelUploadRequest<Files.UploadSessionStartResultSerializer, VoidSerializer> {
        return BabelUploadRequest(client: self, host: "content", route: "/files/upload_session/start", params: Serialization._VoidSerializer.serialize(), body: body, responseSerializer: Files.UploadSessionStartResultSerializer(), errorSerializer: Serialization._VoidSerializer)
    }
    /// Append more data to an upload session.
    ///
    /// - parameter sessionId:
    ///        The upload session ID (returned by `upload_session/start`).
    /// - parameter offset:
    ///        The amount of data that has been uploaded so far. We use this to
    ///        make sure upload data isn't lost or duplicated in the event of a
    ///        network error.
    /// - parameter body:
    ///        The binary payload to upload
    public func filesUploadSessionAppend(sessionId sessionId: String, offset: UInt64, body: NSData) -> BabelUploadRequest<VoidSerializer, Files.UploadSessionLookupErrorSerializer> {
        let request = Files.UploadSessionCursor(sessionId: sessionId, offset: offset)
        return BabelUploadRequest(client: self, host: "content", route: "/files/upload_session/append", params: Files.UploadSessionCursorSerializer().serialize(request), body: body, responseSerializer: Serialization._VoidSerializer, errorSerializer: Files.UploadSessionLookupErrorSerializer())
    }
    /// Finish an upload session and save the uploaded data to the given file
    /// path.
    ///
    /// - parameter cursor:
    ///        Contains the upload session ID and the offset.
    /// - parameter commit:
    ///        Contains the path and other optional modifiers for the commit.
    /// - parameter body:
    ///        The binary payload to upload
    public func filesUploadSessionFinish(cursor cursor: Files.UploadSessionCursor, commit: Files.CommitInfo, body: NSData) -> BabelUploadRequest<Files.FileMetadataSerializer, Files.UploadSessionFinishErrorSerializer> {
        let request = Files.UploadSessionFinishArg(cursor: cursor, commit: commit)
        return BabelUploadRequest(client: self, host: "content", route: "/files/upload_session/finish", params: Files.UploadSessionFinishArgSerializer().serialize(request), body: body, responseSerializer: Files.FileMetadataSerializer(), errorSerializer: Files.UploadSessionFinishErrorSerializer())
    }
    /// Create a new file with the contents provided in the request.
    ///
    /// - parameter path:
    ///        Path in the user's Dropbox to save the file.
    /// - parameter mode:
    ///        Selects what to do if the file already exists.
    /// - parameter autorename:
    ///        If there's a conflict, as determined by `mode`, have the Dropbox
    ///        server try to autorename the file to avoid conflict.
    /// - parameter clientModified:
    ///        The value to store as the `client_modified` timestamp. Dropbox
    ///        automatically records the time at which the file was written to
    ///        the Dropbox servers. It can also record an additional timestamp,
    ///        provided by Dropbox desktop clients, mobile clients, and API apps
    ///        of when the file was actually created or modified.
    /// - parameter mute:
    ///        Normally, users are made aware of any file modifications in their
    ///        Dropbox account via notifications in the client software. If
    ///        `true`, this tells the clients that this modification shouldn't
    ///        result in a user notification.
    /// - parameter body:
    ///        The binary payload to upload
    public func filesUpload(path path: String, mode: Files.WriteMode = .Add, autorename: Bool = false, clientModified: NSDate? = nil, mute: Bool = false, body: NSData) -> BabelUploadRequest<Files.FileMetadataSerializer, Files.UploadErrorSerializer> {
        let request = Files.CommitInfo(path: path, mode: mode, autorename: autorename, clientModified: clientModified, mute: mute)
        return BabelUploadRequest(client: self, host: "content", route: "/files/upload", params: Files.CommitInfoSerializer().serialize(request), body: body, responseSerializer: Files.FileMetadataSerializer(), errorSerializer: Files.UploadErrorSerializer())
    }
    /// Searches for files and folders.
    ///
    /// - parameter path:
    ///        The path in the user's Dropbox to search. Should probably be a
    ///        folder. May be the root (i.e. empty).
    /// - parameter query:
    ///        The string to search for. The search string is split on spaces
    ///        into multiple tokens. For file name searching, the last token is
    ///        used for prefix matching (i.e. "bat c" matches "bat cave" but not
    ///        "batman car").
    /// - parameter start:
    ///        The starting index within the search results (used for paging).
    /// - parameter maxResults:
    ///        The maximum number of search results to return.
    /// - parameter mode:
    ///        The search mode (filename, filename_and_content, or
    ///        deleted_filename).
    public func filesSearch(path path: String, query: String, start: UInt64 = 0, maxResults: UInt64 = 100, mode: Files.SearchMode = .Filename) -> BabelRpcRequest<Files.SearchResultsSerializer, Files.SearchErrorSerializer> {
        let request = Files.SearchQuery(path: path, query: query, start: start, maxResults: maxResults, mode: mode)
        return BabelRpcRequest(client: self, host: "meta", route: "/files/search", params: Files.SearchQuerySerializer().serialize(request), responseSerializer: Files.SearchResultsSerializer(), errorSerializer: Files.SearchErrorSerializer())
    }
    /// Create a folder at a given path. No file or folder may exist at the
    /// path. The parent folder will be created if it does not already exist
    /// (and so on). If the parent exists it must be a folder (and the same for
    /// any ancestor). If an ancestor is a shared folder it must have write
    /// access.
    ///
    /// - parameter path:
    ///        Path in the user's Dropbox to create.
    public func filesCreateFolder(path path: String) -> BabelRpcRequest<Files.FolderMetadataSerializer, Files.PathErrorSerializer> {
        let request = Files.CreateFolderArg(path: path)
        return BabelRpcRequest(client: self, host: "meta", route: "/files/create_folder", params: Files.CreateFolderArgSerializer().serialize(request), responseSerializer: Files.FolderMetadataSerializer(), errorSerializer: Files.PathErrorSerializer())
    }
    /// Delete the file or folder at a given path. If the path is a folder all
    /// its contents will be deleted too.
    ///
    /// - parameter path:
    ///        Path in the user's Dropbox to delete.
    public func filesDelete(path path: String) -> BabelRpcRequest<Files.MetadataSerializer, Files.PathErrorSerializer> {
        let request = Files.DeleteArg(path: path)
        return BabelRpcRequest(client: self, host: "meta", route: "/files/delete", params: Files.DeleteArgSerializer().serialize(request), responseSerializer: Files.MetadataSerializer(), errorSerializer: Files.PathErrorSerializer())
    }
    /// Copy a file or folder to a different destination in the user's Dropbox.
    /// If the source path is a folder all its contents will be copied. The
    /// destination path must not yet exist.
    ///
    /// - parameter fromPath:
    ///        Path in the user's Dropbox to be copied or moved.
    /// - parameter toPath:
    ///        Path in the user's Dropbox that is the destination.
    public func filesCopy(fromPath fromPath: String, toPath: String) -> BabelRpcRequest<Files.MetadataSerializer, Files.RelocationErrorSerializer> {
        let request = Files.RelocationArg(fromPath: fromPath, toPath: toPath)
        return BabelRpcRequest(client: self, host: "meta", route: "/files/copy", params: Files.RelocationArgSerializer().serialize(request), responseSerializer: Files.MetadataSerializer(), errorSerializer: Files.RelocationErrorSerializer())
    }
    /// Move a file or folder to a different destination in the user's Dropbox.
    /// If the source path is a folder all its contents will be moved. The
    /// destination path must not yet exist.
    ///
    /// - parameter fromPath:
    ///        Path in the user's Dropbox to be copied or moved.
    /// - parameter toPath:
    ///        Path in the user's Dropbox that is the destination.
    public func filesMove(fromPath fromPath: String, toPath: String) -> BabelRpcRequest<Files.MetadataSerializer, Files.RelocationErrorSerializer> {
        let request = Files.RelocationArg(fromPath: fromPath, toPath: toPath)
        return BabelRpcRequest(client: self, host: "meta", route: "/files/move", params: Files.RelocationArgSerializer().serialize(request), responseSerializer: Files.MetadataSerializer(), errorSerializer: Files.RelocationErrorSerializer())
    }
    /// Get a thumbnail for an image.
    ///
    /// - parameter path:
    ///        The path to the image file you want to thumbnail.
    /// - parameter format:
    ///        The format for the thumbnail image, jpeg (default) or png. For
    ///        images that are photos, jpeg should be preferred, while png is
    ///        better for screenshots and digital arts.
    /// - parameter size:
    ///        The size for the thumbnail image (default s).
    public func filesGetThumbnail(path path: String, format: Files.ThumbnailFormat = .Jpeg, size: Files.ThumbnailSize = .S) -> BabelDownloadRequest<Files.FileMetadataSerializer, Files.ThumbnailErrorSerializer> {
        let request = Files.ThumbnailArg(path: path, format: format, size: size)
        return BabelDownloadRequest(client: self, host: "content", route: "/files/get_thumbnail", params: Files.ThumbnailArgSerializer().serialize(request), responseSerializer: Files.FileMetadataSerializer(), errorSerializer: Files.ThumbnailErrorSerializer())
    }
    /// Get a preview for a file. Currently previews are only generated for the
    /// files with  the following extensions: .doc, .docx, .docm, .ppt, .pps,
    /// .ppsx, .ppsm, .pptx, .pptm,  .xls, .xlsx, .xlsm, .rtf
    ///
    /// - parameter path:
    ///        The path of the file to preview.
    /// - parameter rev:
    ///        Optional revision, taken from the corresponding `Metadata` field.
    public func filesGetPreview(path path: String, rev: String? = nil) -> BabelDownloadRequest<Files.FileMetadataSerializer, Files.PreviewErrorSerializer> {
        let request = Files.PreviewArg(path: path, rev: rev)
        return BabelDownloadRequest(client: self, host: "content", route: "/files/get_preview", params: Files.PreviewArgSerializer().serialize(request), responseSerializer: Files.FileMetadataSerializer(), errorSerializer: Files.PreviewErrorSerializer())
    }
    /// Return revisions of a file
    ///
    /// - parameter path:
    ///        The path to the file you want to see the revisions of.
    /// - parameter limit:
    ///        The maximum number of revision entries returned.
    public func filesListRevisions(path path: String, limit: UInt64 = 10) -> BabelRpcRequest<Files.ListRevisionsResultSerializer, Files.ListRevisionsErrorSerializer> {
        let request = Files.ListRevisionsArg(path: path, limit: limit)
        return BabelRpcRequest(client: self, host: "meta", route: "/files/list_revisions", params: Files.ListRevisionsArgSerializer().serialize(request), responseSerializer: Files.ListRevisionsResultSerializer(), errorSerializer: Files.ListRevisionsErrorSerializer())
    }
    /// Restore a file to a specific revision
    ///
    /// - parameter path:
    ///        The path to the file you want to restore.
    /// - parameter rev:
    ///        The revision to restore for the file.
    public func filesRestore(path path: String, rev: String) -> BabelRpcRequest<Files.FileMetadataSerializer, Files.RestoreErrorSerializer> {
        let request = Files.RestoreArg(path: path, rev: rev)
        return BabelRpcRequest(client: self, host: "meta", route: "/files/restore", params: Files.RestoreArgSerializer().serialize(request), responseSerializer: Files.FileMetadataSerializer(), errorSerializer: Files.RestoreErrorSerializer())
    }
}
