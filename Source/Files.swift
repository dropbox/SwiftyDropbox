
/* Autogenerated. Do not edit. */

import Foundation
public class Files {
    /// Metadata for a file or folder. You should never see a bare `Metadata`
    /// instance; you will always receive an instance of `FileMetadata` or
    /// `FolderMetadata`.
    ///
    /// :param: name
    ///        The last component of the path (including extension). This never
    ///        contains a slash.
    /// :param: pathLower
    ///        The lowercased full path in the user's Dropbox. This always
    ///        starts with a slash.
    public class Metadata: Printable {
        public let name : String
        public let pathLower : String
        public init(name: String, pathLower: String) {
            stringValidator()(value: name)
            self.name = name
            stringValidator()(value: pathLower)
            self.pathLower = pathLower
        }
        public var description : String {
            return "\(prepareJSONForSerialization(MetadataSerializer().serialize(self)))"
        }
    }
    public class MetadataSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: Metadata) -> JSON {
            var output = [ 
            "name": Serialization._StringSerializer.serialize(value.name),
            "path_lower": Serialization._StringSerializer.serialize(value.pathLower),
            ]
            switch value {
                case let file as Files.FileMetadata:
                    for (k,v) in Serialization.getFields(FileMetadataSerializer().serialize(file)) {
                        output[k] = v
                    }
                    output[".tag"] = .Str("file")
                case let folder as Files.FolderMetadata:
                    for (k,v) in Serialization.getFields(FolderMetadataSerializer().serialize(folder)) {
                        output[k] = v
                    }
                    output[".tag"] = .Str("folder")
                case let deleted as Files.DeletedMetadata:
                    for (k,v) in Serialization.getFields(DeletedMetadataSerializer().serialize(deleted)) {
                        output[k] = v
                    }
                    output[".tag"] = .Str("deleted")
                default: fatalError("Tried to serialize unexpected subtype")
            }
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> Metadata {
            switch json {
                case .Dictionary(let dict):
                    let tag = Serialization.getTag(dict)
                    switch tag {
                        case "file":
                            return FileMetadataSerializer().deserialize(json)
                        case "folder":
                            return FolderMetadataSerializer().deserialize(json)
                        case "deleted":
                            return DeletedMetadataSerializer().deserialize(json)
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    assert(false, "Type error deserializing")
            }
        }
    }
    /// Metadata (excluding name or path) for a file.
    ///
    /// :param: clientModified
    ///        For files, this is the modification time set by the desktop
    ///        client when the file was added to Dropbox. Since this time is not
    ///        verified (the Dropbox server stores whatever the desktop client
    ///        sends up), this should only be used for display purposes (such as
    ///        sorting) and not, for example, to determine if a file has changed
    ///        or not.
    /// :param: serverModified
    ///        The last time the file was modified on Dropbox.
    /// :param: rev
    ///        A unique identifier for the current revision of a file. This
    ///        field is the same rev as elsewhere in the API and can be used to
    ///        detect changes and avoid conflicts.
    /// :param: size
    ///        The file size in bytes.
    public class FileMetadata: Metadata, Printable {
        public let clientModified : NSDate
        public let serverModified : NSDate
        public let rev : String
        public let size : UInt64
        public init(name: String, pathLower: String, clientModified: NSDate, serverModified: NSDate, rev: String, size: UInt64) {
            self.clientModified = clientModified
            self.serverModified = serverModified
            stringValidator(minLength: 9, pattern: "[0-9a-f]+")(value: rev)
            self.rev = rev
            comparableValidator()(value: size)
            self.size = size
            super.init(name: name, pathLower: pathLower)
        }
        public override var description : String {
            return "\(prepareJSONForSerialization(FileMetadataSerializer().serialize(self)))"
        }
    }
    public class FileMetadataSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: FileMetadata) -> JSON {
            var output = [ 
            "name": Serialization._StringSerializer.serialize(value.name),
            "path_lower": Serialization._StringSerializer.serialize(value.pathLower),
            "client_modified": NSDateSerializer("%Y-%m-%dT%H:%M:%SZ").serialize(value.clientModified),
            "server_modified": NSDateSerializer("%Y-%m-%dT%H:%M:%SZ").serialize(value.serverModified),
            "rev": Serialization._StringSerializer.serialize(value.rev),
            "size": Serialization._UInt64Serializer.serialize(value.size),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> FileMetadata {
            switch json {
                case .Dictionary(let dict):
                    let name = Serialization._StringSerializer.deserialize(dict["name"] ?? .Null)
                    let pathLower = Serialization._StringSerializer.deserialize(dict["path_lower"] ?? .Null)
                    let clientModified = NSDateSerializer("%Y-%m-%dT%H:%M:%SZ").deserialize(dict["client_modified"] ?? .Null)
                    let serverModified = NSDateSerializer("%Y-%m-%dT%H:%M:%SZ").deserialize(dict["server_modified"] ?? .Null)
                    let rev = Serialization._StringSerializer.deserialize(dict["rev"] ?? .Null)
                    let size = Serialization._UInt64Serializer.deserialize(dict["size"] ?? .Null)
                    return FileMetadata(name: name, pathLower: pathLower, clientModified: clientModified, serverModified: serverModified, rev: rev, size: size)
                default:
                    assert(false, "Type error deserializing")
            }
        }
    }
    /// Metadata (excluding name or path) for a folder. (There are currently no
    /// fields defined here, but we will add folder-specific metadata in the
    /// future.)
    ///
    public class FolderMetadata: Metadata, Printable {
        public override var description : String {
            return "\(prepareJSONForSerialization(FolderMetadataSerializer().serialize(self)))"
        }
    }
    public class FolderMetadataSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: FolderMetadata) -> JSON {
            var output = [ 
            "name": Serialization._StringSerializer.serialize(value.name),
            "path_lower": Serialization._StringSerializer.serialize(value.pathLower),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> FolderMetadata {
            switch json {
                case .Dictionary(let dict):
                    let name = Serialization._StringSerializer.deserialize(dict["name"] ?? .Null)
                    let pathLower = Serialization._StringSerializer.deserialize(dict["path_lower"] ?? .Null)
                    return FolderMetadata(name: name, pathLower: pathLower)
                default:
                    assert(false, "Type error deserializing")
            }
        }
    }
    /// Indicates a deleted file or folder in results returned by
    /// `list_folder/continue` or `search`.
    ///
    public class DeletedMetadata: Metadata, Printable {
        public override var description : String {
            return "\(prepareJSONForSerialization(DeletedMetadataSerializer().serialize(self)))"
        }
    }
    public class DeletedMetadataSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: DeletedMetadata) -> JSON {
            var output = [ 
            "name": Serialization._StringSerializer.serialize(value.name),
            "path_lower": Serialization._StringSerializer.serialize(value.pathLower),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> DeletedMetadata {
            switch json {
                case .Dictionary(let dict):
                    let name = Serialization._StringSerializer.deserialize(dict["name"] ?? .Null)
                    let pathLower = Serialization._StringSerializer.deserialize(dict["path_lower"] ?? .Null)
                    return DeletedMetadata(name: name, pathLower: pathLower)
                default:
                    assert(false, "Type error deserializing")
            }
        }
    }
    /// Error returned by `get_metadata`.
    ///
    /// - NotFound:
    ///   File is not found at the specified path.
    /// - Other:
    ///   An unspecified error.
    public enum GetMetadataError : Printable {
        case NotFound
        case Other
        public var description : String {
            return "\(prepareJSONForSerialization(GetMetadataErrorSerializer().serialize(self)))"
        }
    }
    public class GetMetadataErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: GetMetadataError) -> JSON {
            switch value {
                case .NotFound:
                    return .Dictionary([".tag": .Str("not_found")])
                case .Other:
                    return .Dictionary([".tag": .Str("other")])
            }
        }
        public func deserialize(json: JSON) -> GetMetadataError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "not_found":
                            return GetMetadataError.NotFound
                        case "other":
                            return GetMetadataError.Other
                        default:
                            return GetMetadataError.Other
                    }
                default:
                    assert(false, "Failed to deserialize")
            }
        }
    }
    /// Arguments for `get_metadata`.
    ///
    /// :param: path
    ///        The path of the file or folder on Dropbox. Must not be the root.
    public class GetMetadataArg: Printable {
        public let path : String
        public init(path: String) {
            stringValidator()(value: path)
            self.path = path
        }
        public var description : String {
            return "\(prepareJSONForSerialization(GetMetadataArgSerializer().serialize(self)))"
        }
    }
    public class GetMetadataArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: GetMetadataArg) -> JSON {
            var output = [ 
            "path": Serialization._StringSerializer.serialize(value.path),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> GetMetadataArg {
            switch json {
                case .Dictionary(let dict):
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .Null)
                    return GetMetadataArg(path: path)
                default:
                    assert(false, "Type error deserializing")
            }
        }
    }
    /// Arguments for `list_folder`.
    ///
    /// :param: path
    ///        The path to the folder you want to see the contents of. May be
    ///        the root (i.e. empty).
    public class ListFolderArg: Printable {
        public let path : String
        public init(path: String) {
            stringValidator()(value: path)
            self.path = path
        }
        public var description : String {
            return "\(prepareJSONForSerialization(ListFolderArgSerializer().serialize(self)))"
        }
    }
    public class ListFolderArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: ListFolderArg) -> JSON {
            var output = [ 
            "path": Serialization._StringSerializer.serialize(value.path),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> ListFolderArg {
            switch json {
                case .Dictionary(let dict):
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .Null)
                    return ListFolderArg(path: path)
                default:
                    assert(false, "Type error deserializing")
            }
        }
    }
    /// Information returned by `list_folder`.
    ///
    /// :param: entries
    ///        The files and (direct) subfolders in the folder.
    /// :param: cursor
    ///        Pass the cursor into `list_folder/continue` to see what's changed
    ///        in the folder since your previous query.
    /// :param: hasMore
    ///        If true, then there are more entries available. Pass the cursor
    ///        to `list_folder/continue` to retrieve the rest.
    public class ListFolderResult: Printable {
        public let entries : Array<Metadata>
        public let cursor : String
        public let hasMore : Bool
        public init(entries: Array<Metadata>, cursor: String, hasMore: Bool) {
            self.entries = entries
            stringValidator()(value: cursor)
            self.cursor = cursor
            self.hasMore = hasMore
        }
        public var description : String {
            return "\(prepareJSONForSerialization(ListFolderResultSerializer().serialize(self)))"
        }
    }
    public class ListFolderResultSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: ListFolderResult) -> JSON {
            var output = [ 
            "entries": ArraySerializer(MetadataSerializer()).serialize(value.entries),
            "cursor": Serialization._StringSerializer.serialize(value.cursor),
            "has_more": Serialization._BoolSerializer.serialize(value.hasMore),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> ListFolderResult {
            switch json {
                case .Dictionary(let dict):
                    let entries = ArraySerializer(MetadataSerializer()).deserialize(dict["entries"] ?? .Null)
                    let cursor = Serialization._StringSerializer.deserialize(dict["cursor"] ?? .Null)
                    let hasMore = Serialization._BoolSerializer.deserialize(dict["has_more"] ?? .Null)
                    return ListFolderResult(entries: entries, cursor: cursor, hasMore: hasMore)
                default:
                    assert(false, "Type error deserializing")
            }
        }
    }
    /// Base class for errors returned by `list_folder`.
    ///
    /// - NotFound:
    ///   There is no file or folder at the given path.
    /// - NotFolder:
    ///   Entry at path is not a folder.
    public enum FolderPathError : Printable {
        case NotFound
        case NotFolder
        public var description : String {
            return "\(prepareJSONForSerialization(FolderPathErrorSerializer().serialize(self)))"
        }
    }
    public class FolderPathErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: FolderPathError) -> JSON {
            switch value {
                case .NotFound:
                    return .Dictionary([".tag": .Str("not_found")])
                case .NotFolder:
                    return .Dictionary([".tag": .Str("not_folder")])
            }
        }
        public func deserialize(json: JSON) -> FolderPathError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "not_found":
                            return FolderPathError.NotFound
                        case "not_folder":
                            return FolderPathError.NotFolder
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    assert(false, "Failed to deserialize")
            }
        }
    }
    /// Error returned by `list_folder` and `list_folder/continue`.
    ///
    /// - Other:
    ///   An unspecified error.
    public enum ListFolderError : Printable {
        case Other
        public var description : String {
            return "\(prepareJSONForSerialization(ListFolderErrorSerializer().serialize(self)))"
        }
    }
    public class ListFolderErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: ListFolderError) -> JSON {
            switch value {
                case .Other:
                    return .Dictionary([".tag": .Str("other")])
            }
        }
        public func deserialize(json: JSON) -> ListFolderError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "other":
                            return ListFolderError.Other
                        default:
                            return ListFolderError.Other
                    }
                default:
                    assert(false, "Failed to deserialize")
            }
        }
    }
    /// Arguments for `list_folder/continue`.
    ///
    /// :param: cursor
    ///        The cursor returned by `list_folder` or `list_folder/continue`.
    public class ListFolderContinueArg: Printable {
        public let cursor : String
        public init(cursor: String) {
            stringValidator()(value: cursor)
            self.cursor = cursor
        }
        public var description : String {
            return "\(prepareJSONForSerialization(ListFolderContinueArgSerializer().serialize(self)))"
        }
    }
    public class ListFolderContinueArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: ListFolderContinueArg) -> JSON {
            var output = [ 
            "cursor": Serialization._StringSerializer.serialize(value.cursor),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> ListFolderContinueArg {
            switch json {
                case .Dictionary(let dict):
                    let cursor = Serialization._StringSerializer.deserialize(dict["cursor"] ?? .Null)
                    return ListFolderContinueArg(cursor: cursor)
                default:
                    assert(false, "Type error deserializing")
            }
        }
    }
    /// Error returned by `list_folder/continue`.
    ///
    /// - Reset:
    ///   Indicates that the cursor has been invalidated. Call `list_folder` to
    ///   obtain a new cursor.
    public enum ListFolderContinueError : Printable {
        case Reset
        public var description : String {
            return "\(prepareJSONForSerialization(ListFolderContinueErrorSerializer().serialize(self)))"
        }
    }
    public class ListFolderContinueErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: ListFolderContinueError) -> JSON {
            switch value {
                case .Reset:
                    return .Dictionary([".tag": .Str("reset")])
            }
        }
        public func deserialize(json: JSON) -> ListFolderContinueError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "reset":
                            return ListFolderContinueError.Reset
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    assert(false, "Failed to deserialize")
            }
        }
    }
    /// Errors from `download` when the file cannot be downloaded.
    ///
    /// - NotFound:
    ///   The path is not found.
    /// - IsFolder:
    ///   The path refers to a folder. Only files can be downloaded.
    public enum NoFileReason : Printable {
        case NotFound
        case IsFolder
        public var description : String {
            return "\(prepareJSONForSerialization(NoFileReasonSerializer().serialize(self)))"
        }
    }
    public class NoFileReasonSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: NoFileReason) -> JSON {
            switch value {
                case .NotFound:
                    return .Dictionary([".tag": .Str("not_found")])
                case .IsFolder:
                    return .Dictionary([".tag": .Str("is_folder")])
            }
        }
        public func deserialize(json: JSON) -> NoFileReason {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "not_found":
                            return NoFileReason.NotFound
                        case "is_folder":
                            return NoFileReason.IsFolder
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    assert(false, "Failed to deserialize")
            }
        }
    }
    /// Error structure for `download`.
    ///
    /// :param: reason
    ///        The path could not be downloaded. The value gives the reason.
    public class NoFile: Printable {
        public let reason : NoFileReason
        public init(reason: NoFileReason) {
            self.reason = reason
        }
        public var description : String {
            return "\(prepareJSONForSerialization(NoFileSerializer().serialize(self)))"
        }
    }
    public class NoFileSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: NoFile) -> JSON {
            var output = [ 
            "reason": NoFileReasonSerializer().serialize(value.reason),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> NoFile {
            switch json {
                case .Dictionary(let dict):
                    let reason = NoFileReasonSerializer().deserialize(dict["reason"] ?? .Null)
                    return NoFile(reason: reason)
                default:
                    assert(false, "Type error deserializing")
            }
        }
    }
    /// Errors for `download` when download is forbidden.
    ///
    /// - Dmca:
    ///   The download is forbidden because of a DMCA (U.S. Digital Millenium
    ///   Copyright Act) takedown request.
    /// - Other:
    ///   The download is forbidden for some other reason.
    public enum RestrictedReason : Printable {
        case Dmca
        case Other
        public var description : String {
            return "\(prepareJSONForSerialization(RestrictedReasonSerializer().serialize(self)))"
        }
    }
    public class RestrictedReasonSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: RestrictedReason) -> JSON {
            switch value {
                case .Dmca:
                    return .Dictionary([".tag": .Str("dmca")])
                case .Other:
                    return .Dictionary([".tag": .Str("other")])
            }
        }
        public func deserialize(json: JSON) -> RestrictedReason {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "dmca":
                            return RestrictedReason.Dmca
                        case "other":
                            return RestrictedReason.Other
                        default:
                            return RestrictedReason.Other
                    }
                default:
                    assert(false, "Failed to deserialize")
            }
        }
    }
    /// Error structure for `download`.
    ///
    /// :param: reason
    ///        The download is forbidden. The value gives the reason.
    public class Restricted: Printable {
        public let reason : RestrictedReason
        public init(reason: RestrictedReason) {
            self.reason = reason
        }
        public var description : String {
            return "\(prepareJSONForSerialization(RestrictedSerializer().serialize(self)))"
        }
    }
    public class RestrictedSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: Restricted) -> JSON {
            var output = [ 
            "reason": RestrictedReasonSerializer().serialize(value.reason),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> Restricted {
            switch json {
                case .Dictionary(let dict):
                    let reason = RestrictedReasonSerializer().deserialize(dict["reason"] ?? .Null)
                    return Restricted(reason: reason)
                default:
                    assert(false, "Type error deserializing")
            }
        }
    }
    /// Errors for `download` when download is disallowed or forbidden.
    ///
    /// - Permission:
    ///   The requesting user has no permission to access the file.
    /// - Restricted:
    ///   The download is forbidden; see the value for the reason.
    public enum DisallowedReason : Printable {
        case Permission
        case Restricted(Files.Restricted)
        public var description : String {
            return "\(prepareJSONForSerialization(DisallowedReasonSerializer().serialize(self)))"
        }
    }
    public class DisallowedReasonSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: DisallowedReason) -> JSON {
            switch value {
                case .Permission:
                    return .Dictionary([".tag": .Str("permission")])
                case .Restricted(let arg):
                    return .Dictionary([".tag": .Str("restricted"), "restricted": RestrictedSerializer().serialize(arg)])
            }
        }
        public func deserialize(json: JSON) -> DisallowedReason {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "permission":
                            return DisallowedReason.Permission
                        case "restricted":
                            let v = RestrictedSerializer().deserialize(d["restricted"] ?? .Null)
                            return DisallowedReason.Restricted(v)
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    assert(false, "Failed to deserialize")
            }
        }
    }
    /// Error structure for `download`.
    ///
    /// :param: reason
    ///        The reason why the download is disallowed.
    public class Disallowed: Printable {
        public let reason : DisallowedReason
        public init(reason: DisallowedReason) {
            self.reason = reason
        }
        public var description : String {
            return "\(prepareJSONForSerialization(DisallowedSerializer().serialize(self)))"
        }
    }
    public class DisallowedSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: Disallowed) -> JSON {
            var output = [ 
            "reason": DisallowedReasonSerializer().serialize(value.reason),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> Disallowed {
            switch json {
                case .Dictionary(let dict):
                    let reason = DisallowedReasonSerializer().deserialize(dict["reason"] ?? .Null)
                    return Disallowed(reason: reason)
                default:
                    assert(false, "Type error deserializing")
            }
        }
    }
    /// Errors from `download`.
    ///
    /// - Disallowed:
    ///   The download is disallowed or forbidden; see the value for the reason.
    /// - NoFile:
    ///   The path cannot be downloaded.
    /// - Other:
    ///   An unspecified error.
    public enum DownloadError : Printable {
        case Disallowed(Files.Disallowed)
        case NoFile(Files.NoFile)
        case Other
        public var description : String {
            return "\(prepareJSONForSerialization(DownloadErrorSerializer().serialize(self)))"
        }
    }
    public class DownloadErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: DownloadError) -> JSON {
            switch value {
                case .Disallowed(let arg):
                    return .Dictionary([".tag": .Str("disallowed"), "disallowed": DisallowedSerializer().serialize(arg)])
                case .NoFile(let arg):
                    return .Dictionary([".tag": .Str("no_file"), "no_file": NoFileSerializer().serialize(arg)])
                case .Other:
                    return .Dictionary([".tag": .Str("other")])
            }
        }
        public func deserialize(json: JSON) -> DownloadError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "disallowed":
                            let v = DisallowedSerializer().deserialize(d["disallowed"] ?? .Null)
                            return DownloadError.Disallowed(v)
                        case "no_file":
                            let v = NoFileSerializer().deserialize(d["no_file"] ?? .Null)
                            return DownloadError.NoFile(v)
                        case "other":
                            return DownloadError.Other
                        default:
                            return DownloadError.Other
                    }
                default:
                    assert(false, "Failed to deserialize")
            }
        }
    }
    /// Arguments for `download`.
    ///
    /// :param: path
    ///        The path of the file to download.
    /// :param: rev
    ///        Optional revision, taken from the corresponding `Metadata` field.
    public class DownloadArg: Printable {
        public let path : String
        public let rev : String?
        public init(path: String, rev: String? = nil) {
            stringValidator()(value: path)
            self.path = path
            nullableValidator(stringValidator(minLength: 9, pattern: "[0-9a-f]+"))(value: rev)
            self.rev = rev
        }
        public var description : String {
            return "\(prepareJSONForSerialization(DownloadArgSerializer().serialize(self)))"
        }
    }
    public class DownloadArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: DownloadArg) -> JSON {
            var output = [ 
            "path": Serialization._StringSerializer.serialize(value.path),
            "rev": NullableSerializer(Serialization._StringSerializer).serialize(value.rev),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> DownloadArg {
            switch json {
                case .Dictionary(let dict):
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .Null)
                    let rev = NullableSerializer(Serialization._StringSerializer).deserialize(dict["rev"] ?? .Null)
                    return DownloadArg(path: path, rev: rev)
                default:
                    assert(false, "Type error deserializing")
            }
        }
    }
    /// Errors related to commit conflicts.
    ///
    /// - File:
    ///   A file already exists at this path.
    /// - Folder:
    ///   A folder already exists at this path.
    /// - AutorenameFailed:
    ///   File could not be automatically renamed.
    /// - Other:
    ///   An unspecified error.
    public enum CommitConflictError : Printable {
        case File
        case Folder
        case AutorenameFailed
        case Other
        public var description : String {
            return "\(prepareJSONForSerialization(CommitConflictErrorSerializer().serialize(self)))"
        }
    }
    public class CommitConflictErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: CommitConflictError) -> JSON {
            switch value {
                case .File:
                    return .Dictionary([".tag": .Str("file")])
                case .Folder:
                    return .Dictionary([".tag": .Str("folder")])
                case .AutorenameFailed:
                    return .Dictionary([".tag": .Str("autorename_failed")])
                case .Other:
                    return .Dictionary([".tag": .Str("other")])
            }
        }
        public func deserialize(json: JSON) -> CommitConflictError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "file":
                            return CommitConflictError.File
                        case "folder":
                            return CommitConflictError.Folder
                        case "autorename_failed":
                            return CommitConflictError.AutorenameFailed
                        case "other":
                            return CommitConflictError.Other
                        default:
                            return CommitConflictError.Other
                    }
                default:
                    assert(false, "Failed to deserialize")
            }
        }
    }
    /// Errors from `upload`.
    ///
    /// - Conflict:
    ///   A conflict prevented the commit. See the value for the reason.
    /// - NoWritePermission:
    ///   User does not have permission to write in the folder. An example of
    ///   this is if the folder is a read-only shared folder.
    /// - InsufficientQuota:
    ///   User does not have sufficient space quota to save the file.
    /// - Other:
    ///   An unspecified error.
    public enum CommitError : Printable {
        case Conflict(Files.CommitConflictError)
        case NoWritePermission
        case InsufficientQuota
        case Other
        public var description : String {
            return "\(prepareJSONForSerialization(CommitErrorSerializer().serialize(self)))"
        }
    }
    public class CommitErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: CommitError) -> JSON {
            switch value {
                case .Conflict(let arg):
                    return .Dictionary([".tag": .Str("conflict"), "conflict": CommitConflictErrorSerializer().serialize(arg)])
                case .NoWritePermission:
                    return .Dictionary([".tag": .Str("no_write_permission")])
                case .InsufficientQuota:
                    return .Dictionary([".tag": .Str("insufficient_quota")])
                case .Other:
                    return .Dictionary([".tag": .Str("other")])
            }
        }
        public func deserialize(json: JSON) -> CommitError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "conflict":
                            let v = CommitConflictErrorSerializer().deserialize(d["conflict"] ?? .Null)
                            return CommitError.Conflict(v)
                        case "no_write_permission":
                            return CommitError.NoWritePermission
                        case "insufficient_quota":
                            return CommitError.InsufficientQuota
                        case "other":
                            return CommitError.Other
                        default:
                            return CommitError.Other
                    }
                default:
                    assert(false, "Failed to deserialize")
            }
        }
    }
    /// Error structure for commit errors.
    ///
    /// :param: reason
    ///        The reason why the commit failed.
    /// :param: uploadSessionId
    ///        The upload session ID; this may be used to retry the commit.
    public class UploadCommitError: Printable {
        public let reason : CommitError
        public let uploadSessionId : String
        public init(reason: CommitError, uploadSessionId: String) {
            self.reason = reason
            stringValidator()(value: uploadSessionId)
            self.uploadSessionId = uploadSessionId
        }
        public var description : String {
            return "\(prepareJSONForSerialization(UploadCommitErrorSerializer().serialize(self)))"
        }
    }
    public class UploadCommitErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: UploadCommitError) -> JSON {
            var output = [ 
            "reason": CommitErrorSerializer().serialize(value.reason),
            "upload_session_id": Serialization._StringSerializer.serialize(value.uploadSessionId),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> UploadCommitError {
            switch json {
                case .Dictionary(let dict):
                    let reason = CommitErrorSerializer().deserialize(dict["reason"] ?? .Null)
                    let uploadSessionId = Serialization._StringSerializer.deserialize(dict["upload_session_id"] ?? .Null)
                    return UploadCommitError(reason: reason, uploadSessionId: uploadSessionId)
                default:
                    assert(false, "Type error deserializing")
            }
        }
    }
    /// Error structure for recovering the correct upload offset.
    ///
    /// :param: correctOffset
    ///        The offset up to which data has been collected.
    public class UploadSessionOffsetError: Printable {
        public let correctOffset : UInt64
        public init(correctOffset: UInt64) {
            comparableValidator()(value: correctOffset)
            self.correctOffset = correctOffset
        }
        public var description : String {
            return "\(prepareJSONForSerialization(UploadSessionOffsetErrorSerializer().serialize(self)))"
        }
    }
    public class UploadSessionOffsetErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: UploadSessionOffsetError) -> JSON {
            var output = [ 
            "correct_offset": Serialization._UInt64Serializer.serialize(value.correctOffset),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> UploadSessionOffsetError {
            switch json {
                case .Dictionary(let dict):
                    let correctOffset = Serialization._UInt64Serializer.deserialize(dict["correct_offset"] ?? .Null)
                    return UploadSessionOffsetError(correctOffset: correctOffset)
                default:
                    assert(false, "Type error deserializing")
            }
        }
    }
    /// Errors related to upload sessions.
    ///
    /// - NotFound:
    ///   The upload session id was not found.
    /// - IncorrectOffset:
    ///   The specified offset was incorrect. See the value for the correct
    ///   offset. (This error may occur when a previous request was received and
    ///   processed successfully but the client did not receive the response,
    ///   e.g. due to a network error.)
    /// - Closed:
    ///   You are attempting to append data to an upload session that has alread
    ///   been closed (i.e. committed).
    /// - Other:
    ///   An unspecified error.
    public enum UploadSessionLookupError : Printable {
        case NotFound
        case IncorrectOffset(Files.UploadSessionOffsetError)
        case Closed
        case Other
        public var description : String {
            return "\(prepareJSONForSerialization(UploadSessionLookupErrorSerializer().serialize(self)))"
        }
    }
    public class UploadSessionLookupErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: UploadSessionLookupError) -> JSON {
            switch value {
                case .NotFound:
                    return .Dictionary([".tag": .Str("not_found")])
                case .IncorrectOffset(let arg):
                    return .Dictionary([".tag": .Str("incorrect_offset"), "incorrect_offset": UploadSessionOffsetErrorSerializer().serialize(arg)])
                case .Closed:
                    return .Dictionary([".tag": .Str("closed")])
                case .Other:
                    return .Dictionary([".tag": .Str("other")])
            }
        }
        public func deserialize(json: JSON) -> UploadSessionLookupError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "not_found":
                            return UploadSessionLookupError.NotFound
                        case "incorrect_offset":
                            let v = UploadSessionOffsetErrorSerializer().deserialize(d["incorrect_offset"] ?? .Null)
                            return UploadSessionLookupError.IncorrectOffset(v)
                        case "closed":
                            return UploadSessionLookupError.Closed
                        case "other":
                            return UploadSessionLookupError.Other
                        default:
                            return UploadSessionLookupError.Other
                    }
                default:
                    assert(false, "Failed to deserialize")
            }
        }
    }
    /// Errors for upload.
    ///
    /// - CommitFailed:
    ///   The upload failed; the value explains the reason.
    /// - Other:
    ///   An unspecified error.
    public enum UploadError : Printable {
        case CommitFailed(Files.UploadCommitError)
        case Other
        public var description : String {
            return "\(prepareJSONForSerialization(UploadErrorSerializer().serialize(self)))"
        }
    }
    public class UploadErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: UploadError) -> JSON {
            switch value {
                case .CommitFailed(let arg):
                    return .Dictionary([".tag": .Str("commit_failed"), "commit_failed": UploadCommitErrorSerializer().serialize(arg)])
                case .Other:
                    return .Dictionary([".tag": .Str("other")])
            }
        }
        public func deserialize(json: JSON) -> UploadError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "commit_failed":
                            let v = UploadCommitErrorSerializer().deserialize(d["commit_failed"] ?? .Null)
                            return UploadError.CommitFailed(v)
                        case "other":
                            return UploadError.Other
                        default:
                            return UploadError.Other
                    }
                default:
                    assert(false, "Failed to deserialize")
            }
        }
    }
    /// Errors for `upload_session/finish`.
    ///
    /// - LookupFailed:
    ///   The session arguments are incorrect; the value explains the reason.
    /// - CommitFailed:
    ///   The commit failed; the value explains the reason.
    /// - Other:
    ///   An unspecified error.
    public enum UploadSessionFinishError : Printable {
        case LookupFailed(Files.UploadSessionLookupError)
        case CommitFailed(Files.CommitError)
        case Other
        public var description : String {
            return "\(prepareJSONForSerialization(UploadSessionFinishErrorSerializer().serialize(self)))"
        }
    }
    public class UploadSessionFinishErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: UploadSessionFinishError) -> JSON {
            switch value {
                case .LookupFailed(let arg):
                    return .Dictionary([".tag": .Str("lookup_failed"), "lookup_failed": UploadSessionLookupErrorSerializer().serialize(arg)])
                case .CommitFailed(let arg):
                    return .Dictionary([".tag": .Str("commit_failed"), "commit_failed": CommitErrorSerializer().serialize(arg)])
                case .Other:
                    return .Dictionary([".tag": .Str("other")])
            }
        }
        public func deserialize(json: JSON) -> UploadSessionFinishError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "lookup_failed":
                            let v = UploadSessionLookupErrorSerializer().deserialize(d["lookup_failed"] ?? .Null)
                            return UploadSessionFinishError.LookupFailed(v)
                        case "commit_failed":
                            let v = CommitErrorSerializer().deserialize(d["commit_failed"] ?? .Null)
                            return UploadSessionFinishError.CommitFailed(v)
                        case "other":
                            return UploadSessionFinishError.Other
                        default:
                            return UploadSessionFinishError.Other
                    }
                default:
                    assert(false, "Failed to deserialize")
            }
        }
    }
    /// The result of `upload_session/start`.
    ///
    /// :param: sessionId
    ///        A unique identifier for the upload session. Pass this to
    ///        `upload_session/append` and `upload_session/finish`.
    public class UploadSessionStartResult: Printable {
        public let sessionId : String
        public init(sessionId: String) {
            stringValidator()(value: sessionId)
            self.sessionId = sessionId
        }
        public var description : String {
            return "\(prepareJSONForSerialization(UploadSessionStartResultSerializer().serialize(self)))"
        }
    }
    public class UploadSessionStartResultSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: UploadSessionStartResult) -> JSON {
            var output = [ 
            "session_id": Serialization._StringSerializer.serialize(value.sessionId),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> UploadSessionStartResult {
            switch json {
                case .Dictionary(let dict):
                    let sessionId = Serialization._StringSerializer.deserialize(dict["session_id"] ?? .Null)
                    return UploadSessionStartResult(sessionId: sessionId)
                default:
                    assert(false, "Type error deserializing")
            }
        }
    }
    /// Arguments for `upload_session/append`. Also used by
    /// `upload_session/finish`.
    ///
    /// :param: sessionId
    ///        The upload session ID (returned by `upload_session/start`).
    /// :param: offset
    ///        The amount of data that has been uploaded so far. We use this to
    ///        make sure upload data isn't lost or duplicated in the event of a
    ///        network error.
    public class UploadSessionCursor: Printable {
        public let sessionId : String
        public let offset : UInt64
        public init(sessionId: String, offset: UInt64) {
            stringValidator()(value: sessionId)
            self.sessionId = sessionId
            comparableValidator()(value: offset)
            self.offset = offset
        }
        public var description : String {
            return "\(prepareJSONForSerialization(UploadSessionCursorSerializer().serialize(self)))"
        }
    }
    public class UploadSessionCursorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: UploadSessionCursor) -> JSON {
            var output = [ 
            "session_id": Serialization._StringSerializer.serialize(value.sessionId),
            "offset": Serialization._UInt64Serializer.serialize(value.offset),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> UploadSessionCursor {
            switch json {
                case .Dictionary(let dict):
                    let sessionId = Serialization._StringSerializer.deserialize(dict["session_id"] ?? .Null)
                    let offset = Serialization._UInt64Serializer.deserialize(dict["offset"] ?? .Null)
                    return UploadSessionCursor(sessionId: sessionId, offset: offset)
                default:
                    assert(false, "Type error deserializing")
            }
        }
    }
    /// Your intent when writing a file to some path. This is used to determine
    /// what constitutes a conflict and what the autorename strategy is. In some
    /// situations, the conflict behavior is identical: (a) If the target path
    /// doesn't contain anything, the file is always written; no conflict. (b)
    /// If the target path contains a folder, it's always a conflict. (c) If the
    /// target path contains a file with identical contents, nothing gets
    /// written; no conflict. The conflict checking differs in the case where
    /// there's a file at the target path with contents different from the
    /// contents you're trying to write.
    ///
    /// - Add:
    ///   It's always a conflict. The autorename strategy is to append a number
    ///   to the file name. For example "document.txt" might become "document
    ///   (2).txt".
    /// - Overwrite:
    ///   It's never a conflict. Overwrite the existing file. The autorename
    ///   strategy is the same as it is for `add`.
    /// - Update:
    ///   It's a conflict only if the current "rev" doesn't match the given
    ///   "rev". The autorename strategy is to append the string "conflicted
    ///   copy" to the file name. For example, "document.txt" might become
    ///   "document (conflicted copy).txt" or "document (Panda's conflicted
    ///   copy).txt".
    public enum WriteMode : Printable {
        case Add
        case Overwrite
        case Update(String)
        public var description : String {
            return "\(prepareJSONForSerialization(WriteModeSerializer().serialize(self)))"
        }
    }
    public class WriteModeSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: WriteMode) -> JSON {
            switch value {
                case .Add:
                    return .Dictionary([".tag": .Str("add")])
                case .Overwrite:
                    return .Dictionary([".tag": .Str("overwrite")])
                case .Update(let arg):
                    return .Dictionary([".tag": .Str("update"), "update": Serialization._StringSerializer.serialize(arg)])
            }
        }
        public func deserialize(json: JSON) -> WriteMode {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "add":
                            return WriteMode.Add
                        case "overwrite":
                            return WriteMode.Overwrite
                        case "update":
                            let v = Serialization._StringSerializer.deserialize(d["update"] ?? .Null)
                            return WriteMode.Update(v)
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    assert(false, "Failed to deserialize")
            }
        }
    }
    /// Arguments for `upload`. Also part of the arguments to
    /// `upload_session/finish`.
    ///
    /// :param: path
    ///        Path in the user's Dropbox to save the file.
    /// :param: mode
    ///        Selects what to do if the file already exists.
    /// :param: autorename
    ///        If there's a conflict, as determined by `mode`, have the Dropbox
    ///        server try to autorename the file to avoid conflict.
    /// :param: clientModified
    ///        The value to store as the `client_modified` timestamp. Dropbox
    ///        automatically records the time at which the file was written to
    ///        the Dropbox servers. It can also record an additional timestamp,
    ///        provided by Dropbox desktop clients, mobile clients, and API apps
    ///        of when the file was actually created or modified.
    /// :param: mute
    ///        Normally, users are made aware of any file modifications in their
    ///        Dropbox account via notifications in the client software. If
    ///        `true`, this tells the clients that this modification shouldn't
    ///        result in a user notification.
    public class CommitInfo: Printable {
        public let path : String
        public let mode : WriteMode
        public let autorename : Bool
        public let clientModified : NSDate?
        public let mute : Bool
        public init(path: String, mode: WriteMode = .Add, autorename: Bool = false, clientModified: NSDate? = nil, mute: Bool = false) {
            stringValidator()(value: path)
            self.path = path
            self.mode = mode
            self.autorename = autorename
            self.clientModified = clientModified
            self.mute = mute
        }
        public var description : String {
            return "\(prepareJSONForSerialization(CommitInfoSerializer().serialize(self)))"
        }
    }
    public class CommitInfoSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: CommitInfo) -> JSON {
            var output = [ 
            "path": Serialization._StringSerializer.serialize(value.path),
            "mode": WriteModeSerializer().serialize(value.mode),
            "autorename": Serialization._BoolSerializer.serialize(value.autorename),
            "client_modified": NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.clientModified),
            "mute": Serialization._BoolSerializer.serialize(value.mute),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> CommitInfo {
            switch json {
                case .Dictionary(let dict):
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .Null)
                    let mode = WriteModeSerializer().deserialize(dict["mode"] ?? .Null)
                    let autorename = Serialization._BoolSerializer.deserialize(dict["autorename"] ?? .Null)
                    let clientModified = NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).deserialize(dict["client_modified"] ?? .Null)
                    let mute = Serialization._BoolSerializer.deserialize(dict["mute"] ?? .Null)
                    return CommitInfo(path: path, mode: mode, autorename: autorename, clientModified: clientModified, mute: mute)
                default:
                    assert(false, "Type error deserializing")
            }
        }
    }
    /// Arguments for `upload_session/finish`.
    ///
    /// :param: cursor
    ///        Contains the upload session ID and the offset.
    /// :param: commit
    ///        Contains the path and other optional modifiers for the commit.
    public class UploadSessionFinishArg: Printable {
        public let cursor : UploadSessionCursor
        public let commit : CommitInfo
        public init(cursor: UploadSessionCursor, commit: CommitInfo) {
            self.cursor = cursor
            self.commit = commit
        }
        public var description : String {
            return "\(prepareJSONForSerialization(UploadSessionFinishArgSerializer().serialize(self)))"
        }
    }
    public class UploadSessionFinishArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: UploadSessionFinishArg) -> JSON {
            var output = [ 
            "cursor": UploadSessionCursorSerializer().serialize(value.cursor),
            "commit": CommitInfoSerializer().serialize(value.commit),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> UploadSessionFinishArg {
            switch json {
                case .Dictionary(let dict):
                    let cursor = UploadSessionCursorSerializer().deserialize(dict["cursor"] ?? .Null)
                    let commit = CommitInfoSerializer().deserialize(dict["commit"] ?? .Null)
                    return UploadSessionFinishArg(cursor: cursor, commit: commit)
                default:
                    assert(false, "Type error deserializing")
            }
        }
    }
    /// Select which type of data to search.
    ///
    /// - Filename:
    ///   Search file and folder names.
    /// - FilenameAndContent:
    ///   Search file and folder names as well as file contents.
    /// - DeletedFilename:
    ///   Search for deleted file and folder names.
    public enum SearchMode : Printable {
        case Filename
        case FilenameAndContent
        case DeletedFilename
        public var description : String {
            return "\(prepareJSONForSerialization(SearchModeSerializer().serialize(self)))"
        }
    }
    public class SearchModeSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: SearchMode) -> JSON {
            switch value {
                case .Filename:
                    return .Dictionary([".tag": .Str("filename")])
                case .FilenameAndContent:
                    return .Dictionary([".tag": .Str("filename_and_content")])
                case .DeletedFilename:
                    return .Dictionary([".tag": .Str("deleted_filename")])
            }
        }
        public func deserialize(json: JSON) -> SearchMode {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "filename":
                            return SearchMode.Filename
                        case "filename_and_content":
                            return SearchMode.FilenameAndContent
                        case "deleted_filename":
                            return SearchMode.DeletedFilename
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    assert(false, "Failed to deserialize")
            }
        }
    }
    /// Arguments for `search`.
    ///
    /// :param: path
    ///        The path in the user's Dropbox to search. Should probably be a
    ///        folder. May be the root (i.e. empty).
    /// :param: query
    ///        The string to search for. The search string is split on spaces
    ///        into multiple tokens. For file name searching, the last token is
    ///        used for prefix matching (i.e. "bat c" matches "bat cave" but not
    ///        "batman car").
    /// :param: start
    ///        The starting index within the search results (used for paging).
    /// :param: maxResults
    ///        The maximum number of search results to return.
    /// :param: mode
    ///        The search mode (filename, filename_and_content, or
    ///        deleted_filename).
    public class SearchQuery: Printable {
        public let path : String
        public let query : String
        public let start : UInt64
        public let maxResults : UInt64
        public let mode : SearchMode
        public init(path: String, query: String, start: UInt64 = 0, maxResults: UInt64 = 100, mode: SearchMode = .Filename) {
            stringValidator()(value: path)
            self.path = path
            stringValidator()(value: query)
            self.query = query
            comparableValidator()(value: start)
            self.start = start
            comparableValidator(minValue: 1, maxValue: 1000)(value: maxResults)
            self.maxResults = maxResults
            self.mode = mode
        }
        public var description : String {
            return "\(prepareJSONForSerialization(SearchQuerySerializer().serialize(self)))"
        }
    }
    public class SearchQuerySerializer: JSONSerializer {
        public init() { }
        public func serialize(value: SearchQuery) -> JSON {
            var output = [ 
            "path": Serialization._StringSerializer.serialize(value.path),
            "query": Serialization._StringSerializer.serialize(value.query),
            "start": Serialization._UInt64Serializer.serialize(value.start),
            "max_results": Serialization._UInt64Serializer.serialize(value.maxResults),
            "mode": SearchModeSerializer().serialize(value.mode),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> SearchQuery {
            switch json {
                case .Dictionary(let dict):
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .Null)
                    let query = Serialization._StringSerializer.deserialize(dict["query"] ?? .Null)
                    let start = Serialization._UInt64Serializer.deserialize(dict["start"] ?? .Null)
                    let maxResults = Serialization._UInt64Serializer.deserialize(dict["max_results"] ?? .Null)
                    let mode = SearchModeSerializer().deserialize(dict["mode"] ?? .Null)
                    return SearchQuery(path: path, query: query, start: start, maxResults: maxResults, mode: mode)
                default:
                    assert(false, "Type error deserializing")
            }
        }
    }
    /// Indicates what type of match was found for a given item.
    ///
    /// - Filename:
    ///   This item was matched on its file or folder name.
    /// - Content:
    ///   This item was matched based on its file contents.
    /// - Both:
    ///   This item was matched based on both its contents and its file name.
    public enum SearchMatchType : Printable {
        case Filename
        case Content
        case Both
        public var description : String {
            return "\(prepareJSONForSerialization(SearchMatchTypeSerializer().serialize(self)))"
        }
    }
    public class SearchMatchTypeSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: SearchMatchType) -> JSON {
            switch value {
                case .Filename:
                    return .Dictionary([".tag": .Str("filename")])
                case .Content:
                    return .Dictionary([".tag": .Str("content")])
                case .Both:
                    return .Dictionary([".tag": .Str("both")])
            }
        }
        public func deserialize(json: JSON) -> SearchMatchType {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "filename":
                            return SearchMatchType.Filename
                        case "content":
                            return SearchMatchType.Content
                        case "both":
                            return SearchMatchType.Both
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    assert(false, "Failed to deserialize")
            }
        }
    }
    /// Describes a search result.
    ///
    /// :param: matchType
    ///        The type of the match.
    /// :param: metadata
    ///        The metadata for the matched file or folder.
    public class SearchMatch: Printable {
        public let matchType : SearchMatchType
        public let metadata : Metadata
        public init(matchType: SearchMatchType, metadata: Metadata) {
            self.matchType = matchType
            self.metadata = metadata
        }
        public var description : String {
            return "\(prepareJSONForSerialization(SearchMatchSerializer().serialize(self)))"
        }
    }
    public class SearchMatchSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: SearchMatch) -> JSON {
            var output = [ 
            "match_type": SearchMatchTypeSerializer().serialize(value.matchType),
            "metadata": MetadataSerializer().serialize(value.metadata),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> SearchMatch {
            switch json {
                case .Dictionary(let dict):
                    let matchType = SearchMatchTypeSerializer().deserialize(dict["match_type"] ?? .Null)
                    let metadata = MetadataSerializer().deserialize(dict["metadata"] ?? .Null)
                    return SearchMatch(matchType: matchType, metadata: metadata)
                default:
                    assert(false, "Type error deserializing")
            }
        }
    }
    /// Information returned by `search`.
    ///
    /// :param: matches
    ///        A list (possibly empty) of matches for the query.
    /// :param: more
    ///        Used for paging. If true, indicates there is another page of
    ///        results available that can be fetched by calling `search` again.
    /// :param: start
    ///        Used for paging. Value to set the start argument to when calling
    ///        `search` to fetch the next page of results.
    public class SearchResults: Printable {
        public let matches : Array<SearchMatch>
        public let more : Bool
        public let start : UInt64
        public init(matches: Array<SearchMatch>, more: Bool, start: UInt64) {
            self.matches = matches
            self.more = more
            comparableValidator()(value: start)
            self.start = start
        }
        public var description : String {
            return "\(prepareJSONForSerialization(SearchResultsSerializer().serialize(self)))"
        }
    }
    public class SearchResultsSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: SearchResults) -> JSON {
            var output = [ 
            "matches": ArraySerializer(SearchMatchSerializer()).serialize(value.matches),
            "more": Serialization._BoolSerializer.serialize(value.more),
            "start": Serialization._UInt64Serializer.serialize(value.start),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> SearchResults {
            switch json {
                case .Dictionary(let dict):
                    let matches = ArraySerializer(SearchMatchSerializer()).deserialize(dict["matches"] ?? .Null)
                    let more = Serialization._BoolSerializer.deserialize(dict["more"] ?? .Null)
                    let start = Serialization._UInt64Serializer.deserialize(dict["start"] ?? .Null)
                    return SearchResults(matches: matches, more: more, start: start)
                default:
                    assert(false, "Type error deserializing")
            }
        }
    }
    /// Errors for `search`.
    ///
    /// - Other:
    ///   An unspecified error.
    public enum SearchError : Printable {
        case Other
        public var description : String {
            return "\(prepareJSONForSerialization(SearchErrorSerializer().serialize(self)))"
        }
    }
    public class SearchErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: SearchError) -> JSON {
            switch value {
                case .Other:
                    return .Dictionary([".tag": .Str("other")])
            }
        }
        public func deserialize(json: JSON) -> SearchError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "other":
                            return SearchError.Other
                        default:
                            return SearchError.Other
                    }
                default:
                    assert(false, "Failed to deserialize")
            }
        }
    }
    /// Path validation errors.
    ///
    /// - RootDisallowed:
    ///   The path should not be empty.
    /// - MalformedPath:
    ///   The path is invalid; the message gives more info.
    /// - NotFound:
    ///   The path does not exist.
    /// - FileDisallowed:
    ///   The path should refer to a folder.
    /// - FolderDisallowed:
    ///   The path should refer to a file.
    /// - ConflictFile:
    ///   A file already exists there.
    /// - ConflictFolder:
    ///   A folder already exists there.
    /// - ConflictFileAncestor:
    ///   An ancestor is a file.
    /// - ReadOnly:
    ///   No write permission.
    /// - SharedFolderDisallowed:
    ///   The path should not refer to a shared folder.
    /// - AutorenameFiled:
    ///   Automatic rename would result in a malformed path (e.g. too long).
    /// - Misc:
    ///   Miscellaneous error (see error message).
    /// - Other:
    ///   An unspecified error.
    public enum PathError : Printable {
        case RootDisallowed
        case MalformedPath(String)
        case NotFound
        case FileDisallowed
        case FolderDisallowed
        case ConflictFile
        case ConflictFolder
        case ConflictFileAncestor
        case ReadOnly
        case SharedFolderDisallowed
        case AutorenameFiled
        case Misc(String)
        case Other
        public var description : String {
            return "\(prepareJSONForSerialization(PathErrorSerializer().serialize(self)))"
        }
    }
    public class PathErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: PathError) -> JSON {
            switch value {
                case .RootDisallowed:
                    return .Dictionary([".tag": .Str("root_disallowed")])
                case .MalformedPath(let arg):
                    return .Dictionary([".tag": .Str("malformed_path"), "malformed_path": Serialization._StringSerializer.serialize(arg)])
                case .NotFound:
                    return .Dictionary([".tag": .Str("not_found")])
                case .FileDisallowed:
                    return .Dictionary([".tag": .Str("file_disallowed")])
                case .FolderDisallowed:
                    return .Dictionary([".tag": .Str("folder_disallowed")])
                case .ConflictFile:
                    return .Dictionary([".tag": .Str("conflict_file")])
                case .ConflictFolder:
                    return .Dictionary([".tag": .Str("conflict_folder")])
                case .ConflictFileAncestor:
                    return .Dictionary([".tag": .Str("conflict_file_ancestor")])
                case .ReadOnly:
                    return .Dictionary([".tag": .Str("read_only")])
                case .SharedFolderDisallowed:
                    return .Dictionary([".tag": .Str("shared_folder_disallowed")])
                case .AutorenameFiled:
                    return .Dictionary([".tag": .Str("autorename_filed")])
                case .Misc(let arg):
                    return .Dictionary([".tag": .Str("misc"), "misc": Serialization._StringSerializer.serialize(arg)])
                case .Other:
                    return .Dictionary([".tag": .Str("other")])
            }
        }
        public func deserialize(json: JSON) -> PathError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "root_disallowed":
                            return PathError.RootDisallowed
                        case "malformed_path":
                            let v = Serialization._StringSerializer.deserialize(d["malformed_path"] ?? .Null)
                            return PathError.MalformedPath(v)
                        case "not_found":
                            return PathError.NotFound
                        case "file_disallowed":
                            return PathError.FileDisallowed
                        case "folder_disallowed":
                            return PathError.FolderDisallowed
                        case "conflict_file":
                            return PathError.ConflictFile
                        case "conflict_folder":
                            return PathError.ConflictFolder
                        case "conflict_file_ancestor":
                            return PathError.ConflictFileAncestor
                        case "read_only":
                            return PathError.ReadOnly
                        case "shared_folder_disallowed":
                            return PathError.SharedFolderDisallowed
                        case "autorename_filed":
                            return PathError.AutorenameFiled
                        case "misc":
                            let v = Serialization._StringSerializer.deserialize(d["misc"] ?? .Null)
                            return PathError.Misc(v)
                        case "other":
                            return PathError.Other
                        default:
                            return PathError.Other
                    }
                default:
                    assert(false, "Failed to deserialize")
            }
        }
    }
    /// Arguments for `create_folder`.
    ///
    /// :param: path
    ///        Path in the user's Dropbox to create.
    public class CreateFolderArg: Printable {
        public let path : String
        public init(path: String) {
            stringValidator()(value: path)
            self.path = path
        }
        public var description : String {
            return "\(prepareJSONForSerialization(CreateFolderArgSerializer().serialize(self)))"
        }
    }
    public class CreateFolderArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: CreateFolderArg) -> JSON {
            var output = [ 
            "path": Serialization._StringSerializer.serialize(value.path),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> CreateFolderArg {
            switch json {
                case .Dictionary(let dict):
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .Null)
                    return CreateFolderArg(path: path)
                default:
                    assert(false, "Type error deserializing")
            }
        }
    }
    /// Arguments for `delete`.
    ///
    /// :param: path
    ///        Path in the user's Dropbox to delete.
    public class DeleteArg: Printable {
        public let path : String
        public init(path: String) {
            stringValidator()(value: path)
            self.path = path
        }
        public var description : String {
            return "\(prepareJSONForSerialization(DeleteArgSerializer().serialize(self)))"
        }
    }
    public class DeleteArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: DeleteArg) -> JSON {
            var output = [ 
            "path": Serialization._StringSerializer.serialize(value.path),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> DeleteArg {
            switch json {
                case .Dictionary(let dict):
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .Null)
                    return DeleteArg(path: path)
                default:
                    assert(false, "Type error deserializing")
            }
        }
    }
    /// Arguments for `copy` and `move`.
    ///
    /// :param: fromPath
    ///        Path in the user's Dropbox to be copied or moved.
    /// :param: toPath
    ///        Path in the user's Dropbox that is the destination.
    public class RelocationArg: Printable {
        public let fromPath : String
        public let toPath : String
        public init(fromPath: String, toPath: String) {
            stringValidator()(value: fromPath)
            self.fromPath = fromPath
            stringValidator()(value: toPath)
            self.toPath = toPath
        }
        public var description : String {
            return "\(prepareJSONForSerialization(RelocationArgSerializer().serialize(self)))"
        }
    }
    public class RelocationArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: RelocationArg) -> JSON {
            var output = [ 
            "from_path": Serialization._StringSerializer.serialize(value.fromPath),
            "to_path": Serialization._StringSerializer.serialize(value.toPath),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> RelocationArg {
            switch json {
                case .Dictionary(let dict):
                    let fromPath = Serialization._StringSerializer.deserialize(dict["from_path"] ?? .Null)
                    let toPath = Serialization._StringSerializer.deserialize(dict["to_path"] ?? .Null)
                    return RelocationArg(fromPath: fromPath, toPath: toPath)
                default:
                    assert(false, "Type error deserializing")
            }
        }
    }
    /// Errors reported by `copy` and `move`. This is not just an extension of
    /// PathError; there are alternatives for errors relating to the source, the
    /// destination, and the copy operation itself.
    ///
    /// - FromError:
    ///   The operation is disallowed due to a problem with the source path.
    /// - ToError:
    ///   The operation is disallowed due to a problem with the destination
    ///   path.
    /// - TooManyFiles:
    ///   The operation would involve more than 10,000 files and folders.
    /// - QuotaError:
    ///   Quota exceeded.
    /// - Other:
    ///   An unspecified error.
    public enum RelocationError : Printable {
        case FromError(Files.PathError)
        case ToError(Files.PathError)
        case TooManyFiles
        case QuotaError
        case Other
        public var description : String {
            return "\(prepareJSONForSerialization(RelocationErrorSerializer().serialize(self)))"
        }
    }
    public class RelocationErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: RelocationError) -> JSON {
            switch value {
                case .FromError(let arg):
                    return .Dictionary([".tag": .Str("from_error"), "from_error": PathErrorSerializer().serialize(arg)])
                case .ToError(let arg):
                    return .Dictionary([".tag": .Str("to_error"), "to_error": PathErrorSerializer().serialize(arg)])
                case .TooManyFiles:
                    return .Dictionary([".tag": .Str("too_many_files")])
                case .QuotaError:
                    return .Dictionary([".tag": .Str("quota_error")])
                case .Other:
                    return .Dictionary([".tag": .Str("other")])
            }
        }
        public func deserialize(json: JSON) -> RelocationError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "from_error":
                            let v = PathErrorSerializer().deserialize(d["from_error"] ?? .Null)
                            return RelocationError.FromError(v)
                        case "to_error":
                            let v = PathErrorSerializer().deserialize(d["to_error"] ?? .Null)
                            return RelocationError.ToError(v)
                        case "too_many_files":
                            return RelocationError.TooManyFiles
                        case "quota_error":
                            return RelocationError.QuotaError
                        case "other":
                            return RelocationError.Other
                        default:
                            return RelocationError.Other
                    }
                default:
                    assert(false, "Failed to deserialize")
            }
        }
    }
}
extension BabelClient {
    /// Returns the metadata for a file or folder.
    ///
    /// :param: path
    ///        The path of the file or folder on Dropbox. Must not be the root.
    public func filesGetMetadata(#path: String) -> BabelRpcRequest<Files.MetadataSerializer, Files.GetMetadataErrorSerializer> {
        let request = Files.GetMetadataArg(path: path)
        return BabelRpcRequest(client: self, host: "meta", route: "/files/get_metadata", params: Files.GetMetadataArgSerializer().serialize(request), responseSerializer: Files.MetadataSerializer(), errorSerializer: Files.GetMetadataErrorSerializer())
    }
    /// Returns the contents of a folder. NOTE: We're definitely going to
    /// streamline this interface.
    ///
    /// :param: path
    ///        The path to the folder you want to see the contents of. May be
    ///        the root (i.e. empty).
    public func filesListFolder(#path: String) -> BabelRpcRequest<Files.ListFolderResultSerializer, Files.ListFolderErrorSerializer> {
        let request = Files.ListFolderArg(path: path)
        return BabelRpcRequest(client: self, host: "meta", route: "/files/list_folder", params: Files.ListFolderArgSerializer().serialize(request), responseSerializer: Files.ListFolderResultSerializer(), errorSerializer: Files.ListFolderErrorSerializer())
    }
    /// Once a cursor has been retrieved from :route:`list_folder`, use this to
    /// paginate through all files and retrieve updates to the folder. NOTE:
    /// We're definitely going to streamline this interface.
    ///
    /// :param: cursor
    ///        The cursor returned by `list_folder` or `list_folder/continue`.
    public func filesListFolderContinue(#cursor: String) -> BabelRpcRequest<Files.ListFolderResultSerializer, Files.ListFolderContinueErrorSerializer> {
        let request = Files.ListFolderContinueArg(cursor: cursor)
        return BabelRpcRequest(client: self, host: "meta", route: "/files/list_folder/continue", params: Files.ListFolderContinueArgSerializer().serialize(request), responseSerializer: Files.ListFolderResultSerializer(), errorSerializer: Files.ListFolderContinueErrorSerializer())
    }
    /// Download a file from a user's Dropbox.
    ///
    /// :param: path
    ///        The path of the file to download.
    /// :param: rev
    ///        Optional revision, taken from the corresponding `Metadata` field.
    public func filesDownload(#path: String, rev: String? = nil) -> BabelDownloadRequest<Files.FileMetadataSerializer, Files.DownloadErrorSerializer> {
        let request = Files.DownloadArg(path: path, rev: rev)
        return BabelDownloadRequest(client: self, host: "content", route: "/files/download", params: Files.DownloadArgSerializer().serialize(request), responseSerializer: Files.FileMetadataSerializer(), errorSerializer: Files.DownloadErrorSerializer())
    }
    /// Start a new upload session. This is used to upload a single file with
    /// multiple calls.
    ///
    /// :param: body
    ///        The binary payload to upload
    public func filesUploadSessionStart(#body: NSData) -> BabelUploadRequest<Files.UploadSessionStartResultSerializer, VoidSerializer> {
        return BabelUploadRequest(client: self, host: "content", route: "/files/upload_session/start", params: Serialization._VoidSerializer.serialize(), body: body, responseSerializer: Files.UploadSessionStartResultSerializer(), errorSerializer: Serialization._VoidSerializer)
    }
    /// Append more data to an upload session.
    ///
    /// :param: sessionId
    ///        The upload session ID (returned by `upload_session/start`).
    /// :param: offset
    ///        The amount of data that has been uploaded so far. We use this to
    ///        make sure upload data isn't lost or duplicated in the event of a
    ///        network error.
    /// :param: body
    ///        The binary payload to upload
    public func filesUploadSessionAppend(#sessionId: String, offset: UInt64, body: NSData) -> BabelUploadRequest<VoidSerializer, Files.UploadSessionLookupErrorSerializer> {
        let request = Files.UploadSessionCursor(sessionId: sessionId, offset: offset)
        return BabelUploadRequest(client: self, host: "content", route: "/files/upload_session/append", params: Files.UploadSessionCursorSerializer().serialize(request), body: body, responseSerializer: Serialization._VoidSerializer, errorSerializer: Files.UploadSessionLookupErrorSerializer())
    }
    /// Finish an upload session and save the uploaded data to the given file
    /// path.
    ///
    /// :param: cursor
    ///        Contains the upload session ID and the offset.
    /// :param: commit
    ///        Contains the path and other optional modifiers for the commit.
    /// :param: body
    ///        The binary payload to upload
    public func filesUploadSessionFinish(#cursor: Files.UploadSessionCursor, commit: Files.CommitInfo, body: NSData) -> BabelUploadRequest<Files.FileMetadataSerializer, Files.UploadSessionFinishErrorSerializer> {
        let request = Files.UploadSessionFinishArg(cursor: cursor, commit: commit)
        return BabelUploadRequest(client: self, host: "content", route: "/files/upload_session/finish", params: Files.UploadSessionFinishArgSerializer().serialize(request), body: body, responseSerializer: Files.FileMetadataSerializer(), errorSerializer: Files.UploadSessionFinishErrorSerializer())
    }
    /// Create a new file with the contents provided in the request.
    ///
    /// :param: path
    ///        Path in the user's Dropbox to save the file.
    /// :param: mode
    ///        Selects what to do if the file already exists.
    /// :param: autorename
    ///        If there's a conflict, as determined by `mode`, have the Dropbox
    ///        server try to autorename the file to avoid conflict.
    /// :param: clientModified
    ///        The value to store as the `client_modified` timestamp. Dropbox
    ///        automatically records the time at which the file was written to
    ///        the Dropbox servers. It can also record an additional timestamp,
    ///        provided by Dropbox desktop clients, mobile clients, and API apps
    ///        of when the file was actually created or modified.
    /// :param: mute
    ///        Normally, users are made aware of any file modifications in their
    ///        Dropbox account via notifications in the client software. If
    ///        `true`, this tells the clients that this modification shouldn't
    ///        result in a user notification.
    /// :param: body
    ///        The binary payload to upload
    public func filesUpload(#path: String, mode: Files.WriteMode = .Add, autorename: Bool = false, clientModified: NSDate? = nil, mute: Bool = false, body: NSData) -> BabelUploadRequest<Files.FileMetadataSerializer, Files.UploadErrorSerializer> {
        let request = Files.CommitInfo(path: path, mode: mode, autorename: autorename, clientModified: clientModified, mute: mute)
        return BabelUploadRequest(client: self, host: "content", route: "/files/upload", params: Files.CommitInfoSerializer().serialize(request), body: body, responseSerializer: Files.FileMetadataSerializer(), errorSerializer: Files.UploadErrorSerializer())
    }
    /// Searches for files and folders.
    ///
    /// :param: path
    ///        The path in the user's Dropbox to search. Should probably be a
    ///        folder. May be the root (i.e. empty).
    /// :param: query
    ///        The string to search for. The search string is split on spaces
    ///        into multiple tokens. For file name searching, the last token is
    ///        used for prefix matching (i.e. "bat c" matches "bat cave" but not
    ///        "batman car").
    /// :param: start
    ///        The starting index within the search results (used for paging).
    /// :param: maxResults
    ///        The maximum number of search results to return.
    /// :param: mode
    ///        The search mode (filename, filename_and_content, or
    ///        deleted_filename).
    public func filesSearch(#path: String, query: String, start: UInt64 = 0, maxResults: UInt64 = 100, mode: Files.SearchMode = .Filename) -> BabelRpcRequest<Files.SearchResultsSerializer, Files.SearchErrorSerializer> {
        let request = Files.SearchQuery(path: path, query: query, start: start, maxResults: maxResults, mode: mode)
        return BabelRpcRequest(client: self, host: "meta", route: "/files/search", params: Files.SearchQuerySerializer().serialize(request), responseSerializer: Files.SearchResultsSerializer(), errorSerializer: Files.SearchErrorSerializer())
    }
    /// Create a folder at a given path. No file or folder may exist at the
    /// path. The parent folder will be created if it does not already exist
    /// (and so on). If the parent exists it must be a folder (and the same for
    /// any ancestor). If an ancestor is a shared folder it must have write
    /// access.
    ///
    /// :param: path
    ///        Path in the user's Dropbox to create.
    public func filesCreateFolder(#path: String) -> BabelRpcRequest<Files.FolderMetadataSerializer, Files.PathErrorSerializer> {
        let request = Files.CreateFolderArg(path: path)
        return BabelRpcRequest(client: self, host: "meta", route: "/files/create_folder", params: Files.CreateFolderArgSerializer().serialize(request), responseSerializer: Files.FolderMetadataSerializer(), errorSerializer: Files.PathErrorSerializer())
    }
    /// Delete the file or folder at a given path. If the path is a folder all
    /// its contents will be deleted too.
    ///
    /// :param: path
    ///        Path in the user's Dropbox to delete.
    public func filesDelete(#path: String) -> BabelRpcRequest<Files.MetadataSerializer, Files.PathErrorSerializer> {
        let request = Files.DeleteArg(path: path)
        return BabelRpcRequest(client: self, host: "meta", route: "/files/delete", params: Files.DeleteArgSerializer().serialize(request), responseSerializer: Files.MetadataSerializer(), errorSerializer: Files.PathErrorSerializer())
    }
    /// Copy a file or folder to a different destination in the user's Dropbox.
    /// If the source path is a folder all its contents will be copied. The
    /// destination path must not yet exist.
    ///
    /// :param: fromPath
    ///        Path in the user's Dropbox to be copied or moved.
    /// :param: toPath
    ///        Path in the user's Dropbox that is the destination.
    public func filesCopy(#fromPath: String, toPath: String) -> BabelRpcRequest<Files.MetadataSerializer, Files.RelocationErrorSerializer> {
        let request = Files.RelocationArg(fromPath: fromPath, toPath: toPath)
        return BabelRpcRequest(client: self, host: "meta", route: "/files/copy", params: Files.RelocationArgSerializer().serialize(request), responseSerializer: Files.MetadataSerializer(), errorSerializer: Files.RelocationErrorSerializer())
    }
    /// Move a file or folder to a different destination in the user's Dropbox.
    /// If the source path is a folder all its contents will be moved. The
    /// destination path must not yet exist.
    ///
    /// :param: fromPath
    ///        Path in the user's Dropbox to be copied or moved.
    /// :param: toPath
    ///        Path in the user's Dropbox that is the destination.
    public func filesMove(#fromPath: String, toPath: String) -> BabelRpcRequest<Files.MetadataSerializer, Files.RelocationErrorSerializer> {
        let request = Files.RelocationArg(fromPath: fromPath, toPath: toPath)
        return BabelRpcRequest(client: self, host: "meta", route: "/files/move", params: Files.RelocationArgSerializer().serialize(request), responseSerializer: Files.MetadataSerializer(), errorSerializer: Files.RelocationErrorSerializer())
    }
}
