///
/// Auto-generated by Stone, do not modify.
///

/// Routes for the files namespace
public class FilesRoutes {
    public let client: DropboxTransportClient
    init(client: DropboxTransportClient) {
        self.client = client
    }

    /// Returns the metadata for a file or folder. This is an alpha endpoint compatible with the properties API. Note:
    /// Metadata for the root folder is unsupported.
    ///
    /// - parameter includePropertyTemplates: If true, propertyGroups in FileMetadata is set for files with custom
    /// properties.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Files.Metadata` object on success or a
    /// `Files.AlphaGetMetadataError` object on failure.
    public func alphaGetMetadata(path path: String, includeMediaInfo: Bool = false, includeDeleted: Bool = false, includeHasExplicitSharedMembers: Bool = false, includePropertyTemplates: Array<String>? = nil) -> RpcRequest<Files.MetadataSerializer, Files.AlphaGetMetadataErrorSerializer> {
        let route = Files.alphaGetMetadata
        let serverArgs = Files.AlphaGetMetadataArg(path: path, includeMediaInfo: includeMediaInfo, includeDeleted: includeDeleted, includeHasExplicitSharedMembers: includeHasExplicitSharedMembers, includePropertyTemplates: includePropertyTemplates)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Create a new file with the contents provided in the request. Note that this endpoint is part of the properties
    /// API alpha and is slightly different from upload. Do not use this to upload a file larger than 150 MB. Instead,
    /// create an upload session with uploadSessionStart.
    ///
    /// - parameter propertyGroups: List of custom properties to add to file.
    /// - parameter input: The file to upload, as an NSData object.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Files.FileMetadata` object on success or a
    /// `Files.UploadErrorWithProperties` object on failure.
    public func alphaUpload(path path: String, mode: Files.WriteMode = .Add, autorename: Bool = false, clientModified: NSDate? = nil, mute: Bool = false, propertyGroups: Array<Properties.PropertyGroup>? = nil, input: NSData) -> UploadRequest<Files.FileMetadataSerializer, Files.UploadErrorWithPropertiesSerializer> {
        let route = Files.alphaUpload
        let serverArgs = Files.CommitInfoWithProperties(path: path, mode: mode, autorename: autorename, clientModified: clientModified, mute: mute, propertyGroups: propertyGroups)
        return client.request(route, serverArgs: serverArgs, input: .Data(input))
    }

    /// Create a new file with the contents provided in the request. Note that this endpoint is part of the properties
    /// API alpha and is slightly different from upload. Do not use this to upload a file larger than 150 MB. Instead,
    /// create an upload session with uploadSessionStart.
    ///
    /// - parameter propertyGroups: List of custom properties to add to file.
    /// - parameter input: The file to upload, as an NSURL object.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Files.FileMetadata` object on success or a
    /// `Files.UploadErrorWithProperties` object on failure.
    public func alphaUpload(path path: String, mode: Files.WriteMode = .Add, autorename: Bool = false, clientModified: NSDate? = nil, mute: Bool = false, propertyGroups: Array<Properties.PropertyGroup>? = nil, input: NSURL) -> UploadRequest<Files.FileMetadataSerializer, Files.UploadErrorWithPropertiesSerializer> {
        let route = Files.alphaUpload
        let serverArgs = Files.CommitInfoWithProperties(path: path, mode: mode, autorename: autorename, clientModified: clientModified, mute: mute, propertyGroups: propertyGroups)
        return client.request(route, serverArgs: serverArgs, input: .File(input))
    }

    /// Create a new file with the contents provided in the request. Note that this endpoint is part of the properties
    /// API alpha and is slightly different from upload. Do not use this to upload a file larger than 150 MB. Instead,
    /// create an upload session with uploadSessionStart.
    ///
    /// - parameter propertyGroups: List of custom properties to add to file.
    /// - parameter input: The file to upload, as an NSInputStream object.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Files.FileMetadata` object on success or a
    /// `Files.UploadErrorWithProperties` object on failure.
    public func alphaUpload(path path: String, mode: Files.WriteMode = .Add, autorename: Bool = false, clientModified: NSDate? = nil, mute: Bool = false, propertyGroups: Array<Properties.PropertyGroup>? = nil, input: NSInputStream) -> UploadRequest<Files.FileMetadataSerializer, Files.UploadErrorWithPropertiesSerializer> {
        let route = Files.alphaUpload
        let serverArgs = Files.CommitInfoWithProperties(path: path, mode: mode, autorename: autorename, clientModified: clientModified, mute: mute, propertyGroups: propertyGroups)
        return client.request(route, serverArgs: serverArgs, input: .Stream(input))
    }

    /// Copy a file or folder to a different location in the user's Dropbox. If the source path is a folder all its
    /// contents will be copied.
    ///
    /// - parameter fromPath: Path in the user's Dropbox to be copied or moved.
    /// - parameter toPath: Path in the user's Dropbox that is the destination.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Files.Metadata` object on success or a
    /// `Files.RelocationError` object on failure.
    public func copy(fromPath fromPath: String, toPath: String) -> RpcRequest<Files.MetadataSerializer, Files.RelocationErrorSerializer> {
        let route = Files.copy
        let serverArgs = Files.RelocationArg(fromPath: fromPath, toPath: toPath)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Get a copy reference to a file or folder. This reference string can be used to save that file or folder to
    /// another user's Dropbox by passing it to copyReferenceSave.
    ///
    /// - parameter path: The path to the file or folder you want to get a copy reference to.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Files.GetCopyReferenceResult` object on
    /// success or a `Files.GetCopyReferenceError` object on failure.
    public func copyReferenceGet(path path: String) -> RpcRequest<Files.GetCopyReferenceResultSerializer, Files.GetCopyReferenceErrorSerializer> {
        let route = Files.copyReferenceGet
        let serverArgs = Files.GetCopyReferenceArg(path: path)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Save a copy reference returned by copyReferenceGet to the user's Dropbox.
    ///
    /// - parameter copyReference: A copy reference returned by copyReferenceGet.
    /// - parameter path: Path in the user's Dropbox that is the destination.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Files.SaveCopyReferenceResult` object on
    /// success or a `Files.SaveCopyReferenceError` object on failure.
    public func copyReferenceSave(copyReference copyReference: String, path: String) -> RpcRequest<Files.SaveCopyReferenceResultSerializer, Files.SaveCopyReferenceErrorSerializer> {
        let route = Files.copyReferenceSave
        let serverArgs = Files.SaveCopyReferenceArg(copyReference: copyReference, path: path)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Create a folder at a given path.
    ///
    /// - parameter path: Path in the user's Dropbox to create.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Files.FolderMetadata` object on success or
    /// a `Files.CreateFolderError` object on failure.
    public func createFolder(path path: String) -> RpcRequest<Files.FolderMetadataSerializer, Files.CreateFolderErrorSerializer> {
        let route = Files.createFolder
        let serverArgs = Files.CreateFolderArg(path: path)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Delete the file or folder at a given path. If the path is a folder, all its contents will be deleted too. A
    /// successful response indicates that the file or folder was deleted. The returned metadata will be the
    /// corresponding FileMetadata or FolderMetadata for the item at time of deletion, and not a DeletedMetadata object.
    ///
    /// - parameter path: Path in the user's Dropbox to delete.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Files.Metadata` object on success or a
    /// `Files.DeleteError` object on failure.
    public func delete(path path: String) -> RpcRequest<Files.MetadataSerializer, Files.DeleteErrorSerializer> {
        let route = Files.delete
        let serverArgs = Files.DeleteArg(path: path)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Download a file from a user's Dropbox.
    ///
    /// - parameter path: The path of the file to download.
    /// - parameter rev: Deprecated. Please specify revision in path instead
    /// - parameter overwrite: A boolean to set behavior in the event of a naming conflict. `True` will overwrite
    /// conflicting file at destination. `False` will take no action (but if left unhandled in destination closure, an
    /// NSError will be thrown).
    /// - parameter destination: A closure used to compute the destination, given the temporary file location and the
    /// response.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Files.FileMetadata` object on success or a
    /// `Files.DownloadError` object on failure.
    public func download(path path: String, rev: String? = nil, overwrite: Bool = false, destination: (NSURL, NSHTTPURLResponse) -> NSURL) -> DownloadRequestFile<Files.FileMetadataSerializer, Files.DownloadErrorSerializer> {
        let route = Files.download
        let serverArgs = Files.DownloadArg(path: path, rev: rev)
        return client.request(route, serverArgs: serverArgs, overwrite: overwrite, destination: destination)
    }

    /// Download a file from a user's Dropbox.
    ///
    /// - parameter path: The path of the file to download.
    /// - parameter rev: Deprecated. Please specify revision in path instead
    ///
    ///  - returns: Through the response callback, the caller will receive a `Files.FileMetadata` object on success or a
    /// `Files.DownloadError` object on failure.
    public func download(path path: String, rev: String? = nil) -> DownloadRequestMemory<Files.FileMetadataSerializer, Files.DownloadErrorSerializer> {
        let route = Files.download
        let serverArgs = Files.DownloadArg(path: path, rev: rev)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Returns the metadata for a file or folder. Note: Metadata for the root folder is unsupported.
    ///
    /// - parameter path: The path of a file or folder on Dropbox.
    /// - parameter includeMediaInfo: If true, mediaInfo in FileMetadata is set for photo and video.
    /// - parameter includeDeleted: If true, DeletedMetadata will be returned for deleted file or folder, otherwise
    /// notFound in LookupError will be returned.
    /// - parameter includeHasExplicitSharedMembers: If true, the results will include a flag for each file indicating
    /// whether or not  that file has any explicit members.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Files.Metadata` object on success or a
    /// `Files.GetMetadataError` object on failure.
    public func getMetadata(path path: String, includeMediaInfo: Bool = false, includeDeleted: Bool = false, includeHasExplicitSharedMembers: Bool = false) -> RpcRequest<Files.MetadataSerializer, Files.GetMetadataErrorSerializer> {
        let route = Files.getMetadata
        let serverArgs = Files.GetMetadataArg(path: path, includeMediaInfo: includeMediaInfo, includeDeleted: includeDeleted, includeHasExplicitSharedMembers: includeHasExplicitSharedMembers)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Get a preview for a file. Currently previews are only generated for the files with  the following extensions:
    /// .doc, .docx, .docm, .ppt, .pps, .ppsx, .ppsm, .pptx, .pptm,  .xls, .xlsx, .xlsm, .rtf
    ///
    /// - parameter path: The path of the file to preview.
    /// - parameter rev: Deprecated. Please specify revision in path instead
    /// - parameter overwrite: A boolean to set behavior in the event of a naming conflict. `True` will overwrite
    /// conflicting file at destination. `False` will take no action (but if left unhandled in destination closure, an
    /// NSError will be thrown).
    /// - parameter destination: A closure used to compute the destination, given the temporary file location and the
    /// response.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Files.FileMetadata` object on success or a
    /// `Files.PreviewError` object on failure.
    public func getPreview(path path: String, rev: String? = nil, overwrite: Bool = false, destination: (NSURL, NSHTTPURLResponse) -> NSURL) -> DownloadRequestFile<Files.FileMetadataSerializer, Files.PreviewErrorSerializer> {
        let route = Files.getPreview
        let serverArgs = Files.PreviewArg(path: path, rev: rev)
        return client.request(route, serverArgs: serverArgs, overwrite: overwrite, destination: destination)
    }

    /// Get a preview for a file. Currently previews are only generated for the files with  the following extensions:
    /// .doc, .docx, .docm, .ppt, .pps, .ppsx, .ppsm, .pptx, .pptm,  .xls, .xlsx, .xlsm, .rtf
    ///
    /// - parameter path: The path of the file to preview.
    /// - parameter rev: Deprecated. Please specify revision in path instead
    ///
    ///  - returns: Through the response callback, the caller will receive a `Files.FileMetadata` object on success or a
    /// `Files.PreviewError` object on failure.
    public func getPreview(path path: String, rev: String? = nil) -> DownloadRequestMemory<Files.FileMetadataSerializer, Files.PreviewErrorSerializer> {
        let route = Files.getPreview
        let serverArgs = Files.PreviewArg(path: path, rev: rev)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Get a temporary link to stream content of a file. This link will expire in four hours and afterwards you will
    /// get 410 Gone. Content-Type of the link is determined automatically by the file's mime type.
    ///
    /// - parameter path: The path to the file you want a temporary link to.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Files.GetTemporaryLinkResult` object on
    /// success or a `Files.GetTemporaryLinkError` object on failure.
    public func getTemporaryLink(path path: String) -> RpcRequest<Files.GetTemporaryLinkResultSerializer, Files.GetTemporaryLinkErrorSerializer> {
        let route = Files.getTemporaryLink
        let serverArgs = Files.GetTemporaryLinkArg(path: path)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Get a thumbnail for an image. This method currently supports files with the following file extensions: jpg,
    /// jpeg, png, tiff, tif, gif and bmp. Photos that are larger than 20MB in size won't be converted to a thumbnail.
    ///
    /// - parameter path: The path to the image file you want to thumbnail.
    /// - parameter format: The format for the thumbnail image, jpeg (default) or png. For  images that are photos, jpeg
    /// should be preferred, while png is  better for screenshots and digital arts.
    /// - parameter size: The size for the thumbnail image.
    /// - parameter overwrite: A boolean to set behavior in the event of a naming conflict. `True` will overwrite
    /// conflicting file at destination. `False` will take no action (but if left unhandled in destination closure, an
    /// NSError will be thrown).
    /// - parameter destination: A closure used to compute the destination, given the temporary file location and the
    /// response.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Files.FileMetadata` object on success or a
    /// `Files.ThumbnailError` object on failure.
    public func getThumbnail(path path: String, format: Files.ThumbnailFormat = .Jpeg, size: Files.ThumbnailSize = .W64h64, overwrite: Bool = false, destination: (NSURL, NSHTTPURLResponse) -> NSURL) -> DownloadRequestFile<Files.FileMetadataSerializer, Files.ThumbnailErrorSerializer> {
        let route = Files.getThumbnail
        let serverArgs = Files.ThumbnailArg(path: path, format: format, size: size)
        return client.request(route, serverArgs: serverArgs, overwrite: overwrite, destination: destination)
    }

    /// Get a thumbnail for an image. This method currently supports files with the following file extensions: jpg,
    /// jpeg, png, tiff, tif, gif and bmp. Photos that are larger than 20MB in size won't be converted to a thumbnail.
    ///
    /// - parameter path: The path to the image file you want to thumbnail.
    /// - parameter format: The format for the thumbnail image, jpeg (default) or png. For  images that are photos, jpeg
    /// should be preferred, while png is  better for screenshots and digital arts.
    /// - parameter size: The size for the thumbnail image.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Files.FileMetadata` object on success or a
    /// `Files.ThumbnailError` object on failure.
    public func getThumbnail(path path: String, format: Files.ThumbnailFormat = .Jpeg, size: Files.ThumbnailSize = .W64h64) -> DownloadRequestMemory<Files.FileMetadataSerializer, Files.ThumbnailErrorSerializer> {
        let route = Files.getThumbnail
        let serverArgs = Files.ThumbnailArg(path: path, format: format, size: size)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Returns the contents of a folder.
    ///
    /// - parameter path: The path to the folder you want to see the contents of.
    /// - parameter recursive: If true, the list folder operation will be applied recursively to all subfolders and the
    /// response will contain contents of all subfolders.
    /// - parameter includeMediaInfo: If true, mediaInfo in FileMetadata is set for photo and video.
    /// - parameter includeDeleted: If true, the results will include entries for files and folders that used to exist
    /// but were deleted.
    /// - parameter includeHasExplicitSharedMembers: If true, the results will include a flag for each file indicating
    /// whether or not  that file has any explicit members.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Files.ListFolderResult` object on success
    /// or a `Files.ListFolderError` object on failure.
    public func listFolder(path path: String, recursive: Bool = false, includeMediaInfo: Bool = false, includeDeleted: Bool = false, includeHasExplicitSharedMembers: Bool = false) -> RpcRequest<Files.ListFolderResultSerializer, Files.ListFolderErrorSerializer> {
        let route = Files.listFolder
        let serverArgs = Files.ListFolderArg(path: path, recursive: recursive, includeMediaInfo: includeMediaInfo, includeDeleted: includeDeleted, includeHasExplicitSharedMembers: includeHasExplicitSharedMembers)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Once a cursor has been retrieved from listFolder, use this to paginate through all files and retrieve updates to
    /// the folder.
    ///
    /// - parameter cursor: The cursor returned by your last call to listFolder or listFolderContinue.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Files.ListFolderResult` object on success
    /// or a `Files.ListFolderContinueError` object on failure.
    public func listFolderContinue(cursor cursor: String) -> RpcRequest<Files.ListFolderResultSerializer, Files.ListFolderContinueErrorSerializer> {
        let route = Files.listFolderContinue
        let serverArgs = Files.ListFolderContinueArg(cursor: cursor)
        return client.request(route, serverArgs: serverArgs)
    }

    /// A way to quickly get a cursor for the folder's state. Unlike listFolder, listFolderGetLatestCursor doesn't
    /// return any entries. This endpoint is for app which only needs to know about new files and modifications and
    /// doesn't need to know about files that already exist in Dropbox.
    ///
    /// - parameter path: The path to the folder you want to see the contents of.
    /// - parameter recursive: If true, the list folder operation will be applied recursively to all subfolders and the
    /// response will contain contents of all subfolders.
    /// - parameter includeMediaInfo: If true, mediaInfo in FileMetadata is set for photo and video.
    /// - parameter includeDeleted: If true, the results will include entries for files and folders that used to exist
    /// but were deleted.
    /// - parameter includeHasExplicitSharedMembers: If true, the results will include a flag for each file indicating
    /// whether or not  that file has any explicit members.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Files.ListFolderGetLatestCursorResult`
    /// object on success or a `Files.ListFolderError` object on failure.
    public func listFolderGetLatestCursor(path path: String, recursive: Bool = false, includeMediaInfo: Bool = false, includeDeleted: Bool = false, includeHasExplicitSharedMembers: Bool = false) -> RpcRequest<Files.ListFolderGetLatestCursorResultSerializer, Files.ListFolderErrorSerializer> {
        let route = Files.listFolderGetLatestCursor
        let serverArgs = Files.ListFolderArg(path: path, recursive: recursive, includeMediaInfo: includeMediaInfo, includeDeleted: includeDeleted, includeHasExplicitSharedMembers: includeHasExplicitSharedMembers)
        return client.request(route, serverArgs: serverArgs)
    }

    /// A longpoll endpoint to wait for changes on an account. In conjunction with listFolderContinue, this call gives
    /// you a low-latency way to monitor an account for file changes. The connection will block until there are changes
    /// available or a timeout occurs. This endpoint is useful mostly for client-side apps. If you're looking for
    /// server-side notifications, check out our webhooks documentation
    /// https://www.dropbox.com/developers/reference/webhooks.
    ///
    /// - parameter cursor: A cursor as returned by listFolder or listFolderContinue. Cursors retrieved by setting
    /// includeMediaInfo in ListFolderArg to true are not supported.
    /// - parameter timeout: A timeout in seconds. The request will block for at most this length of time, plus up to 90
    /// seconds of random jitter added to avoid the thundering herd problem. Care should be taken when using this
    /// parameter, as some network infrastructure does not support long timeouts.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Files.ListFolderLongpollResult` object on
    /// success or a `Files.ListFolderLongpollError` object on failure.
    public func listFolderLongpoll(cursor cursor: String, timeout: UInt64 = 30) -> RpcRequest<Files.ListFolderLongpollResultSerializer, Files.ListFolderLongpollErrorSerializer> {
        let route = Files.listFolderLongpoll
        let serverArgs = Files.ListFolderLongpollArg(cursor: cursor, timeout: timeout)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Return revisions of a file
    ///
    /// - parameter path: The path to the file you want to see the revisions of.
    /// - parameter limit: The maximum number of revision entries returned.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Files.ListRevisionsResult` object on
    /// success or a `Files.ListRevisionsError` object on failure.
    public func listRevisions(path path: String, limit: UInt64 = 10) -> RpcRequest<Files.ListRevisionsResultSerializer, Files.ListRevisionsErrorSerializer> {
        let route = Files.listRevisions
        let serverArgs = Files.ListRevisionsArg(path: path, limit: limit)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Move a file or folder to a different location in the user's Dropbox. If the source path is a folder all its
    /// contents will be moved.
    ///
    /// - parameter fromPath: Path in the user's Dropbox to be copied or moved.
    /// - parameter toPath: Path in the user's Dropbox that is the destination.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Files.Metadata` object on success or a
    /// `Files.RelocationError` object on failure.
    public func move(fromPath fromPath: String, toPath: String) -> RpcRequest<Files.MetadataSerializer, Files.RelocationErrorSerializer> {
        let route = Files.move
        let serverArgs = Files.RelocationArg(fromPath: fromPath, toPath: toPath)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Permanently delete the file or folder at a given path (see https://www.dropbox.com/en/help/40). Note: This
    /// endpoint is only available for Dropbox Business apps.
    ///
    /// - parameter path: Path in the user's Dropbox to delete.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Void` object on success or a
    /// `Files.DeleteError` object on failure.
    public func permanentlyDelete(path path: String) -> RpcRequest<VoidSerializer, Files.DeleteErrorSerializer> {
        let route = Files.permanentlyDelete
        let serverArgs = Files.DeleteArg(path: path)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Add custom properties to a file using a filled property template. See properties/template/add to create new
    /// property templates.
    ///
    /// - parameter path: A unique identifier for the file.
    /// - parameter propertyGroups: Filled custom property templates associated with a file.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Void` object on success or a
    /// `Files.AddPropertiesError` object on failure.
    public func propertiesAdd(path path: String, propertyGroups: Array<Properties.PropertyGroup>) -> RpcRequest<VoidSerializer, Files.AddPropertiesErrorSerializer> {
        let route = Files.propertiesAdd
        let serverArgs = Files.PropertyGroupWithPath(path: path, propertyGroups: propertyGroups)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Overwrite custom properties from a specified template associated with a file.
    ///
    /// - parameter path: A unique identifier for the file.
    /// - parameter propertyGroups: Filled custom property templates associated with a file.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Void` object on success or a
    /// `Files.InvalidPropertyGroupError` object on failure.
    public func propertiesOverwrite(path path: String, propertyGroups: Array<Properties.PropertyGroup>) -> RpcRequest<VoidSerializer, Files.InvalidPropertyGroupErrorSerializer> {
        let route = Files.propertiesOverwrite
        let serverArgs = Files.PropertyGroupWithPath(path: path, propertyGroups: propertyGroups)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Remove all custom properties from a specified template associated with a file. To remove specific property key
    /// value pairs, see propertiesUpdate. To update a property template, see properties/template/update. Property
    /// templates can't be removed once created.
    ///
    /// - parameter path: A unique identifier for the file.
    /// - parameter propertyTemplateIds: A list of identifiers for a property template created by route
    /// properties/template/add.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Void` object on success or a
    /// `Files.RemovePropertiesError` object on failure.
    public func propertiesRemove(path path: String, propertyTemplateIds: Array<String>) -> RpcRequest<VoidSerializer, Files.RemovePropertiesErrorSerializer> {
        let route = Files.propertiesRemove
        let serverArgs = Files.RemovePropertiesArg(path: path, propertyTemplateIds: propertyTemplateIds)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Get the schema for a specified template.
    ///
    /// - parameter templateId: An identifier for property template added by route properties/template/add.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Properties.GetPropertyTemplateResult`
    /// object on success or a `Properties.PropertyTemplateError` object on failure.
    public func propertiesTemplateGet(templateId templateId: String) -> RpcRequest<Properties.GetPropertyTemplateResultSerializer, Properties.PropertyTemplateErrorSerializer> {
        let route = Files.propertiesTemplateGet
        let serverArgs = Properties.GetPropertyTemplateArg(templateId: templateId)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Get the property template identifiers for a user. To get the schema of each template use propertiesTemplateGet.
    ///
    ///
    ///  - returns: Through the response callback, the caller will receive a `Properties.ListPropertyTemplateIds` object
    /// on success or a `Properties.PropertyTemplateError` object on failure.
    public func propertiesTemplateList() -> RpcRequest<Properties.ListPropertyTemplateIdsSerializer, Properties.PropertyTemplateErrorSerializer> {
        let route = Files.propertiesTemplateList
        return client.request(route)
    }

    /// Add, update or remove custom properties from a specified template associated with a file. Fields that already
    /// exist and not described in the request will not be modified.
    ///
    /// - parameter path: A unique identifier for the file.
    /// - parameter updatePropertyGroups: Filled custom property templates associated with a file.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Void` object on success or a
    /// `Files.UpdatePropertiesError` object on failure.
    public func propertiesUpdate(path path: String, updatePropertyGroups: Array<Files.PropertyGroupUpdate>) -> RpcRequest<VoidSerializer, Files.UpdatePropertiesErrorSerializer> {
        let route = Files.propertiesUpdate
        let serverArgs = Files.UpdatePropertyGroupArg(path: path, updatePropertyGroups: updatePropertyGroups)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Restore a file to a specific revision
    ///
    /// - parameter path: The path to the file you want to restore.
    /// - parameter rev: The revision to restore for the file.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Files.FileMetadata` object on success or a
    /// `Files.RestoreError` object on failure.
    public func restore(path path: String, rev: String) -> RpcRequest<Files.FileMetadataSerializer, Files.RestoreErrorSerializer> {
        let route = Files.restore
        let serverArgs = Files.RestoreArg(path: path, rev: rev)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Save a specified URL into a file in user's Dropbox. If the given path already exists, the file will be renamed
    /// to avoid the conflict (e.g. myfile (1).txt).
    ///
    /// - parameter path: The path in Dropbox where the URL will be saved to.
    /// - parameter url: The URL to be saved.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Files.SaveUrlResult` object on success or
    /// a `Files.SaveUrlError` object on failure.
    public func saveUrl(path path: String, url: String) -> RpcRequest<Files.SaveUrlResultSerializer, Files.SaveUrlErrorSerializer> {
        let route = Files.saveUrl
        let serverArgs = Files.SaveUrlArg(path: path, url: url)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Check the status of a saveUrl job.
    ///
    /// - parameter asyncJobId: Id of the asynchronous job. This is the value of a response returned from the method
    /// that launched the job.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Files.SaveUrlJobStatus` object on success
    /// or a `Async.PollError` object on failure.
    public func saveUrlCheckJobStatus(asyncJobId asyncJobId: String) -> RpcRequest<Files.SaveUrlJobStatusSerializer, Async.PollErrorSerializer> {
        let route = Files.saveUrlCheckJobStatus
        let serverArgs = Async.PollArg(asyncJobId: asyncJobId)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Searches for files and folders. Note: Recent changes may not immediately be reflected in search results due to a
    /// short delay in indexing.
    ///
    /// - parameter path: The path in the user's Dropbox to search. Should probably be a folder.
    /// - parameter query: The string to search for. The search string is split on spaces into multiple tokens. For file
    /// name searching, the last token is used for prefix matching (i.e. "bat c" matches "bat cave" but not "batman
    /// car").
    /// - parameter start: The starting index within the search results (used for paging).
    /// - parameter maxResults: The maximum number of search results to return.
    /// - parameter mode: The search mode (filename, filename_and_content, or deleted_filename). Note that searching
    /// file content is only available for Dropbox Business accounts.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Files.SearchResult` object on success or a
    /// `Files.SearchError` object on failure.
    public func search(path path: String, query: String, start: UInt64 = 0, maxResults: UInt64 = 100, mode: Files.SearchMode = .Filename) -> RpcRequest<Files.SearchResultSerializer, Files.SearchErrorSerializer> {
        let route = Files.search
        let serverArgs = Files.SearchArg(path: path, query: query, start: start, maxResults: maxResults, mode: mode)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Create a new file with the contents provided in the request. Do not use this to upload a file larger than 150
    /// MB. Instead, create an upload session with uploadSessionStart.
    ///
    /// - parameter path: Path in the user's Dropbox to save the file.
    /// - parameter mode: Selects what to do if the file already exists.
    /// - parameter autorename: If there's a conflict, as determined by mode, have the Dropbox server try to autorename
    /// the file to avoid conflict.
    /// - parameter clientModified: The value to store as the clientModified timestamp. Dropbox automatically records
    /// the time at which the file was written to the Dropbox servers. It can also record an additional timestamp,
    /// provided by Dropbox desktop clients, mobile clients, and API apps of when the file was actually created or
    /// modified.
    /// - parameter mute: Normally, users are made aware of any file modifications in their Dropbox account via
    /// notifications in the client software. If true, this tells the clients that this modification shouldn't result in
    /// a user notification.
    /// - parameter input: The file to upload, as an NSData object.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Files.FileMetadata` object on success or a
    /// `Files.UploadError` object on failure.
    public func upload(path path: String, mode: Files.WriteMode = .Add, autorename: Bool = false, clientModified: NSDate? = nil, mute: Bool = false, input: NSData) -> UploadRequest<Files.FileMetadataSerializer, Files.UploadErrorSerializer> {
        let route = Files.upload
        let serverArgs = Files.CommitInfo(path: path, mode: mode, autorename: autorename, clientModified: clientModified, mute: mute)
        return client.request(route, serverArgs: serverArgs, input: .Data(input))
    }

    /// Create a new file with the contents provided in the request. Do not use this to upload a file larger than 150
    /// MB. Instead, create an upload session with uploadSessionStart.
    ///
    /// - parameter path: Path in the user's Dropbox to save the file.
    /// - parameter mode: Selects what to do if the file already exists.
    /// - parameter autorename: If there's a conflict, as determined by mode, have the Dropbox server try to autorename
    /// the file to avoid conflict.
    /// - parameter clientModified: The value to store as the clientModified timestamp. Dropbox automatically records
    /// the time at which the file was written to the Dropbox servers. It can also record an additional timestamp,
    /// provided by Dropbox desktop clients, mobile clients, and API apps of when the file was actually created or
    /// modified.
    /// - parameter mute: Normally, users are made aware of any file modifications in their Dropbox account via
    /// notifications in the client software. If true, this tells the clients that this modification shouldn't result in
    /// a user notification.
    /// - parameter input: The file to upload, as an NSURL object.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Files.FileMetadata` object on success or a
    /// `Files.UploadError` object on failure.
    public func upload(path path: String, mode: Files.WriteMode = .Add, autorename: Bool = false, clientModified: NSDate? = nil, mute: Bool = false, input: NSURL) -> UploadRequest<Files.FileMetadataSerializer, Files.UploadErrorSerializer> {
        let route = Files.upload
        let serverArgs = Files.CommitInfo(path: path, mode: mode, autorename: autorename, clientModified: clientModified, mute: mute)
        return client.request(route, serverArgs: serverArgs, input: .File(input))
    }

    /// Create a new file with the contents provided in the request. Do not use this to upload a file larger than 150
    /// MB. Instead, create an upload session with uploadSessionStart.
    ///
    /// - parameter path: Path in the user's Dropbox to save the file.
    /// - parameter mode: Selects what to do if the file already exists.
    /// - parameter autorename: If there's a conflict, as determined by mode, have the Dropbox server try to autorename
    /// the file to avoid conflict.
    /// - parameter clientModified: The value to store as the clientModified timestamp. Dropbox automatically records
    /// the time at which the file was written to the Dropbox servers. It can also record an additional timestamp,
    /// provided by Dropbox desktop clients, mobile clients, and API apps of when the file was actually created or
    /// modified.
    /// - parameter mute: Normally, users are made aware of any file modifications in their Dropbox account via
    /// notifications in the client software. If true, this tells the clients that this modification shouldn't result in
    /// a user notification.
    /// - parameter input: The file to upload, as an NSInputStream object.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Files.FileMetadata` object on success or a
    /// `Files.UploadError` object on failure.
    public func upload(path path: String, mode: Files.WriteMode = .Add, autorename: Bool = false, clientModified: NSDate? = nil, mute: Bool = false, input: NSInputStream) -> UploadRequest<Files.FileMetadataSerializer, Files.UploadErrorSerializer> {
        let route = Files.upload
        let serverArgs = Files.CommitInfo(path: path, mode: mode, autorename: autorename, clientModified: clientModified, mute: mute)
        return client.request(route, serverArgs: serverArgs, input: .Stream(input))
    }

    /// Append more data to an upload session. A single request should not upload more than 150 MB of file contents.
    ///
    /// - parameter sessionId: The upload session ID (returned by uploadSessionStart).
    /// - parameter offset: The amount of data that has been uploaded so far. We use this to make sure upload data isn't
    /// lost or duplicated in the event of a network error.
    /// - parameter input: The file to upload, as an NSData object.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Void` object on success or a
    /// `Files.UploadSessionLookupError` object on failure.
    @available(*, unavailable, message="upload_session/append is deprecated. Use upload_session/append_v2.")
    public func uploadSessionAppend(sessionId sessionId: String, offset: UInt64, input: NSData) -> UploadRequest<VoidSerializer, Files.UploadSessionLookupErrorSerializer> {
        let route = Files.uploadSessionAppend
        let serverArgs = Files.UploadSessionCursor(sessionId: sessionId, offset: offset)
        return client.request(route, serverArgs: serverArgs, input: .Data(input))
    }

    /// Append more data to an upload session. A single request should not upload more than 150 MB of file contents.
    ///
    /// - parameter sessionId: The upload session ID (returned by uploadSessionStart).
    /// - parameter offset: The amount of data that has been uploaded so far. We use this to make sure upload data isn't
    /// lost or duplicated in the event of a network error.
    /// - parameter input: The file to upload, as an NSURL object.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Void` object on success or a
    /// `Files.UploadSessionLookupError` object on failure.
    @available(*, unavailable, message="upload_session/append is deprecated. Use upload_session/append_v2.")
    public func uploadSessionAppend(sessionId sessionId: String, offset: UInt64, input: NSURL) -> UploadRequest<VoidSerializer, Files.UploadSessionLookupErrorSerializer> {
        let route = Files.uploadSessionAppend
        let serverArgs = Files.UploadSessionCursor(sessionId: sessionId, offset: offset)
        return client.request(route, serverArgs: serverArgs, input: .File(input))
    }

    /// Append more data to an upload session. A single request should not upload more than 150 MB of file contents.
    ///
    /// - parameter sessionId: The upload session ID (returned by uploadSessionStart).
    /// - parameter offset: The amount of data that has been uploaded so far. We use this to make sure upload data isn't
    /// lost or duplicated in the event of a network error.
    /// - parameter input: The file to upload, as an NSInputStream object.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Void` object on success or a
    /// `Files.UploadSessionLookupError` object on failure.
    @available(*, unavailable, message="upload_session/append is deprecated. Use upload_session/append_v2.")
    public func uploadSessionAppend(sessionId sessionId: String, offset: UInt64, input: NSInputStream) -> UploadRequest<VoidSerializer, Files.UploadSessionLookupErrorSerializer> {
        let route = Files.uploadSessionAppend
        let serverArgs = Files.UploadSessionCursor(sessionId: sessionId, offset: offset)
        return client.request(route, serverArgs: serverArgs, input: .Stream(input))
    }

    /// Append more data to an upload session. When the parameter close is set, this call will close the session. A
    /// single request should not upload more than 150 MB of file contents.
    ///
    /// - parameter cursor: Contains the upload session ID and the offset.
    /// - parameter close: If true, the current session will be closed, at which point you won't be able to call
    /// uploadSessionAppendV2 anymore with the current session.
    /// - parameter input: The file to upload, as an NSData object.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Void` object on success or a
    /// `Files.UploadSessionLookupError` object on failure.
    public func uploadSessionAppendV2(cursor cursor: Files.UploadSessionCursor, close: Bool = false, input: NSData) -> UploadRequest<VoidSerializer, Files.UploadSessionLookupErrorSerializer> {
        let route = Files.uploadSessionAppendV2
        let serverArgs = Files.UploadSessionAppendArg(cursor: cursor, close: close)
        return client.request(route, serverArgs: serverArgs, input: .Data(input))
    }

    /// Append more data to an upload session. When the parameter close is set, this call will close the session. A
    /// single request should not upload more than 150 MB of file contents.
    ///
    /// - parameter cursor: Contains the upload session ID and the offset.
    /// - parameter close: If true, the current session will be closed, at which point you won't be able to call
    /// uploadSessionAppendV2 anymore with the current session.
    /// - parameter input: The file to upload, as an NSURL object.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Void` object on success or a
    /// `Files.UploadSessionLookupError` object on failure.
    public func uploadSessionAppendV2(cursor cursor: Files.UploadSessionCursor, close: Bool = false, input: NSURL) -> UploadRequest<VoidSerializer, Files.UploadSessionLookupErrorSerializer> {
        let route = Files.uploadSessionAppendV2
        let serverArgs = Files.UploadSessionAppendArg(cursor: cursor, close: close)
        return client.request(route, serverArgs: serverArgs, input: .File(input))
    }

    /// Append more data to an upload session. When the parameter close is set, this call will close the session. A
    /// single request should not upload more than 150 MB of file contents.
    ///
    /// - parameter cursor: Contains the upload session ID and the offset.
    /// - parameter close: If true, the current session will be closed, at which point you won't be able to call
    /// uploadSessionAppendV2 anymore with the current session.
    /// - parameter input: The file to upload, as an NSInputStream object.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Void` object on success or a
    /// `Files.UploadSessionLookupError` object on failure.
    public func uploadSessionAppendV2(cursor cursor: Files.UploadSessionCursor, close: Bool = false, input: NSInputStream) -> UploadRequest<VoidSerializer, Files.UploadSessionLookupErrorSerializer> {
        let route = Files.uploadSessionAppendV2
        let serverArgs = Files.UploadSessionAppendArg(cursor: cursor, close: close)
        return client.request(route, serverArgs: serverArgs, input: .Stream(input))
    }

    /// Finish an upload session and save the uploaded data to the given file path. A single request should not upload
    /// more than 150 MB of file contents.
    ///
    /// - parameter cursor: Contains the upload session ID and the offset.
    /// - parameter commit: Contains the path and other optional modifiers for the commit.
    /// - parameter input: The file to upload, as an NSData object.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Files.FileMetadata` object on success or a
    /// `Files.UploadSessionFinishError` object on failure.
    public func uploadSessionFinish(cursor cursor: Files.UploadSessionCursor, commit: Files.CommitInfo, input: NSData) -> UploadRequest<Files.FileMetadataSerializer, Files.UploadSessionFinishErrorSerializer> {
        let route = Files.uploadSessionFinish
        let serverArgs = Files.UploadSessionFinishArg(cursor: cursor, commit: commit)
        return client.request(route, serverArgs: serverArgs, input: .Data(input))
    }

    /// Finish an upload session and save the uploaded data to the given file path. A single request should not upload
    /// more than 150 MB of file contents.
    ///
    /// - parameter cursor: Contains the upload session ID and the offset.
    /// - parameter commit: Contains the path and other optional modifiers for the commit.
    /// - parameter input: The file to upload, as an NSURL object.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Files.FileMetadata` object on success or a
    /// `Files.UploadSessionFinishError` object on failure.
    public func uploadSessionFinish(cursor cursor: Files.UploadSessionCursor, commit: Files.CommitInfo, input: NSURL) -> UploadRequest<Files.FileMetadataSerializer, Files.UploadSessionFinishErrorSerializer> {
        let route = Files.uploadSessionFinish
        let serverArgs = Files.UploadSessionFinishArg(cursor: cursor, commit: commit)
        return client.request(route, serverArgs: serverArgs, input: .File(input))
    }

    /// Finish an upload session and save the uploaded data to the given file path. A single request should not upload
    /// more than 150 MB of file contents.
    ///
    /// - parameter cursor: Contains the upload session ID and the offset.
    /// - parameter commit: Contains the path and other optional modifiers for the commit.
    /// - parameter input: The file to upload, as an NSInputStream object.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Files.FileMetadata` object on success or a
    /// `Files.UploadSessionFinishError` object on failure.
    public func uploadSessionFinish(cursor cursor: Files.UploadSessionCursor, commit: Files.CommitInfo, input: NSInputStream) -> UploadRequest<Files.FileMetadataSerializer, Files.UploadSessionFinishErrorSerializer> {
        let route = Files.uploadSessionFinish
        let serverArgs = Files.UploadSessionFinishArg(cursor: cursor, commit: commit)
        return client.request(route, serverArgs: serverArgs, input: .Stream(input))
    }

    /// Upload sessions allow you to upload a single file using multiple requests. This call starts a new upload session
    /// with the given data.  You can then use uploadSessionAppendV2 to add more data and uploadSessionFinish to save
    /// all the data to a file in Dropbox. A single request should not upload more than 150 MB of file contents.
    ///
    /// - parameter close: If true, the current session will be closed, at which point you won't be able to call
    /// uploadSessionAppendV2 anymore with the current session.
    /// - parameter input: The file to upload, as an NSData object.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Files.UploadSessionStartResult` object on
    /// success or a `Void` object on failure.
    public func uploadSessionStart(close: Bool = false, input: NSData) -> UploadRequest<Files.UploadSessionStartResultSerializer, VoidSerializer> {
        let route = Files.uploadSessionStart
        let serverArgs = Files.UploadSessionStartArg(close: close)
        return client.request(route, serverArgs: serverArgs, input: .Data(input))
    }

    /// Upload sessions allow you to upload a single file using multiple requests. This call starts a new upload session
    /// with the given data.  You can then use uploadSessionAppendV2 to add more data and uploadSessionFinish to save
    /// all the data to a file in Dropbox. A single request should not upload more than 150 MB of file contents.
    ///
    /// - parameter close: If true, the current session will be closed, at which point you won't be able to call
    /// uploadSessionAppendV2 anymore with the current session.
    /// - parameter input: The file to upload, as an NSURL object.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Files.UploadSessionStartResult` object on
    /// success or a `Void` object on failure.
    public func uploadSessionStart(close: Bool = false, input: NSURL) -> UploadRequest<Files.UploadSessionStartResultSerializer, VoidSerializer> {
        let route = Files.uploadSessionStart
        let serverArgs = Files.UploadSessionStartArg(close: close)
        return client.request(route, serverArgs: serverArgs, input: .File(input))
    }

    /// Upload sessions allow you to upload a single file using multiple requests. This call starts a new upload session
    /// with the given data.  You can then use uploadSessionAppendV2 to add more data and uploadSessionFinish to save
    /// all the data to a file in Dropbox. A single request should not upload more than 150 MB of file contents.
    ///
    /// - parameter close: If true, the current session will be closed, at which point you won't be able to call
    /// uploadSessionAppendV2 anymore with the current session.
    /// - parameter input: The file to upload, as an NSInputStream object.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Files.UploadSessionStartResult` object on
    /// success or a `Void` object on failure.
    public func uploadSessionStart(close: Bool = false, input: NSInputStream) -> UploadRequest<Files.UploadSessionStartResultSerializer, VoidSerializer> {
        let route = Files.uploadSessionStart
        let serverArgs = Files.UploadSessionStartArg(close: close)
        return client.request(route, serverArgs: serverArgs, input: .Stream(input))
    }

}
