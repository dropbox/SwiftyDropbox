///
/// Auto-generated by Stone, do not modify.
///

import Foundation

/// Datatypes and serializers for the team namespace
public class Team {
    /// The DeviceSession struct
    public class DeviceSession: CustomStringConvertible {
        /// The session id
        public let sessionId: String
        /// The IP address of the last activity from this session
        public let ipAddress: String?
        /// The country from which the last activity from this session was made
        public let country: String?
        /// The time this session was created
        public let created: NSDate?
        /// The time of the last activity from this session
        public let updated: NSDate?
        public init(sessionId: String, ipAddress: String? = nil, country: String? = nil, created: NSDate? = nil, updated: NSDate? = nil) {
            stringValidator()(sessionId)
            self.sessionId = sessionId
            nullableValidator(stringValidator())(ipAddress)
            self.ipAddress = ipAddress
            nullableValidator(stringValidator())(country)
            self.country = country
            self.created = created
            self.updated = updated
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(DeviceSessionSerializer().serialize(self)))"
        }
    }
    public class DeviceSessionSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: DeviceSession) -> JSON {
            let output = [ 
            "session_id": Serialization._StringSerializer.serialize(value.sessionId),
            "ip_address": NullableSerializer(Serialization._StringSerializer).serialize(value.ipAddress),
            "country": NullableSerializer(Serialization._StringSerializer).serialize(value.country),
            "created": NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.created),
            "updated": NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.updated),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> DeviceSession {
            switch json {
                case .Dictionary(let dict):
                    let sessionId = Serialization._StringSerializer.deserialize(dict["session_id"] ?? .Null)
                    let ipAddress = NullableSerializer(Serialization._StringSerializer).deserialize(dict["ip_address"] ?? .Null)
                    let country = NullableSerializer(Serialization._StringSerializer).deserialize(dict["country"] ?? .Null)
                    let created = NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).deserialize(dict["created"] ?? .Null)
                    let updated = NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).deserialize(dict["updated"] ?? .Null)
                    return DeviceSession(sessionId: sessionId, ipAddress: ipAddress, country: country, created: created, updated: updated)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Information on active web sessions
    public class ActiveWebSession: Team.DeviceSession {
        /// Information on the hosting device
        public let userAgent: String
        /// Information on the hosting operating system
        public let os: String
        /// Information on the browser used for this web session
        public let browser: String
        public init(sessionId: String, userAgent: String, os: String, browser: String, ipAddress: String? = nil, country: String? = nil, created: NSDate? = nil, updated: NSDate? = nil) {
            stringValidator()(userAgent)
            self.userAgent = userAgent
            stringValidator()(os)
            self.os = os
            stringValidator()(browser)
            self.browser = browser
            super.init(sessionId: sessionId, ipAddress: ipAddress, country: country, created: created, updated: updated)
        }
        public override var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ActiveWebSessionSerializer().serialize(self)))"
        }
    }
    public class ActiveWebSessionSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: ActiveWebSession) -> JSON {
            let output = [ 
            "session_id": Serialization._StringSerializer.serialize(value.sessionId),
            "user_agent": Serialization._StringSerializer.serialize(value.userAgent),
            "os": Serialization._StringSerializer.serialize(value.os),
            "browser": Serialization._StringSerializer.serialize(value.browser),
            "ip_address": NullableSerializer(Serialization._StringSerializer).serialize(value.ipAddress),
            "country": NullableSerializer(Serialization._StringSerializer).serialize(value.country),
            "created": NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.created),
            "updated": NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.updated),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> ActiveWebSession {
            switch json {
                case .Dictionary(let dict):
                    let sessionId = Serialization._StringSerializer.deserialize(dict["session_id"] ?? .Null)
                    let userAgent = Serialization._StringSerializer.deserialize(dict["user_agent"] ?? .Null)
                    let os = Serialization._StringSerializer.deserialize(dict["os"] ?? .Null)
                    let browser = Serialization._StringSerializer.deserialize(dict["browser"] ?? .Null)
                    let ipAddress = NullableSerializer(Serialization._StringSerializer).deserialize(dict["ip_address"] ?? .Null)
                    let country = NullableSerializer(Serialization._StringSerializer).deserialize(dict["country"] ?? .Null)
                    let created = NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).deserialize(dict["created"] ?? .Null)
                    let updated = NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).deserialize(dict["updated"] ?? .Null)
                    return ActiveWebSession(sessionId: sessionId, userAgent: userAgent, os: os, browser: browser, ipAddress: ipAddress, country: country, created: created, updated: updated)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Arguments for adding property templates.
    public class AddPropertyTemplateArg: Properties.PropertyGroupTemplate {
        public override var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(AddPropertyTemplateArgSerializer().serialize(self)))"
        }
    }
    public class AddPropertyTemplateArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: AddPropertyTemplateArg) -> JSON {
            let output = [ 
            "name": Serialization._StringSerializer.serialize(value.name),
            "description": Serialization._StringSerializer.serialize(value.description_),
            "fields": ArraySerializer(Properties.PropertyFieldTemplateSerializer()).serialize(value.fields),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> AddPropertyTemplateArg {
            switch json {
                case .Dictionary(let dict):
                    let name = Serialization._StringSerializer.deserialize(dict["name"] ?? .Null)
                    let description_ = Serialization._StringSerializer.deserialize(dict["description"] ?? .Null)
                    let fields = ArraySerializer(Properties.PropertyFieldTemplateSerializer()).deserialize(dict["fields"] ?? .Null)
                    return AddPropertyTemplateArg(name: name, description_: description_, fields: fields)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The AddPropertyTemplateResult struct
    public class AddPropertyTemplateResult: CustomStringConvertible {
        /// An identifier for property template added by propertiesTemplateAdd.
        public let templateId: String
        public init(templateId: String) {
            stringValidator(minLength: 1, pattern: "(/|ptid:).*")(templateId)
            self.templateId = templateId
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(AddPropertyTemplateResultSerializer().serialize(self)))"
        }
    }
    public class AddPropertyTemplateResultSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: AddPropertyTemplateResult) -> JSON {
            let output = [ 
            "template_id": Serialization._StringSerializer.serialize(value.templateId),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> AddPropertyTemplateResult {
            switch json {
                case .Dictionary(let dict):
                    let templateId = Serialization._StringSerializer.deserialize(dict["template_id"] ?? .Null)
                    return AddPropertyTemplateResult(templateId: templateId)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Describes which team-related admin permissions a user has.
    public enum AdminTier: CustomStringConvertible {
        /// User is an administrator of the team - has all permissions.
        case TeamAdmin
        /// User can do most user provisioning, de-provisioning and management.
        case UserManagementAdmin
        /// User can do a limited set of common support tasks for existing users.
        case SupportAdmin
        /// User is not an admin of the team.
        case MemberOnly

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(AdminTierSerializer().serialize(self)))"
        }
    }
    public class AdminTierSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: AdminTier) -> JSON {
            switch value {
                case .TeamAdmin:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("team_admin")
                    return .Dictionary(d)
                case .UserManagementAdmin:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("user_management_admin")
                    return .Dictionary(d)
                case .SupportAdmin:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("support_admin")
                    return .Dictionary(d)
                case .MemberOnly:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("member_only")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> AdminTier {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "team_admin":
                            return AdminTier.TeamAdmin
                        case "user_management_admin":
                            return AdminTier.UserManagementAdmin
                        case "support_admin":
                            return AdminTier.SupportAdmin
                        case "member_only":
                            return AdminTier.MemberOnly
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Information on linked third party applications
    public class ApiApp: CustomStringConvertible {
        /// The application unique id
        public let appId: String
        /// The application name
        public let appName: String
        /// The application publisher name
        public let publisher: String?
        /// The publisher's URL
        public let publisherUrl: String?
        /// The time this application was linked
        public let linked: NSDate?
        /// Whether the linked application uses a dedicated folder
        public let isAppFolder: Bool
        public init(appId: String, appName: String, isAppFolder: Bool, publisher: String? = nil, publisherUrl: String? = nil, linked: NSDate? = nil) {
            stringValidator()(appId)
            self.appId = appId
            stringValidator()(appName)
            self.appName = appName
            nullableValidator(stringValidator())(publisher)
            self.publisher = publisher
            nullableValidator(stringValidator())(publisherUrl)
            self.publisherUrl = publisherUrl
            self.linked = linked
            self.isAppFolder = isAppFolder
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ApiAppSerializer().serialize(self)))"
        }
    }
    public class ApiAppSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: ApiApp) -> JSON {
            let output = [ 
            "app_id": Serialization._StringSerializer.serialize(value.appId),
            "app_name": Serialization._StringSerializer.serialize(value.appName),
            "is_app_folder": Serialization._BoolSerializer.serialize(value.isAppFolder),
            "publisher": NullableSerializer(Serialization._StringSerializer).serialize(value.publisher),
            "publisher_url": NullableSerializer(Serialization._StringSerializer).serialize(value.publisherUrl),
            "linked": NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.linked),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> ApiApp {
            switch json {
                case .Dictionary(let dict):
                    let appId = Serialization._StringSerializer.deserialize(dict["app_id"] ?? .Null)
                    let appName = Serialization._StringSerializer.deserialize(dict["app_name"] ?? .Null)
                    let isAppFolder = Serialization._BoolSerializer.deserialize(dict["is_app_folder"] ?? .Null)
                    let publisher = NullableSerializer(Serialization._StringSerializer).deserialize(dict["publisher"] ?? .Null)
                    let publisherUrl = NullableSerializer(Serialization._StringSerializer).deserialize(dict["publisher_url"] ?? .Null)
                    let linked = NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).deserialize(dict["linked"] ?? .Null)
                    return ApiApp(appId: appId, appName: appName, isAppFolder: isAppFolder, publisher: publisher, publisherUrl: publisherUrl, linked: linked)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Base report structure.
    public class BaseDfbReport: CustomStringConvertible {
        /// First date present in the results as 'YYYY-MM-DD' or None.
        public let startDate: String
        public init(startDate: String) {
            stringValidator()(startDate)
            self.startDate = startDate
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(BaseDfbReportSerializer().serialize(self)))"
        }
    }
    public class BaseDfbReportSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: BaseDfbReport) -> JSON {
            let output = [ 
            "start_date": Serialization._StringSerializer.serialize(value.startDate),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> BaseDfbReport {
            switch json {
                case .Dictionary(let dict):
                    let startDate = Serialization._StringSerializer.deserialize(dict["start_date"] ?? .Null)
                    return BaseDfbReport(startDate: startDate)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Input arguments that can be provided for most reports.
    public class DateRange: CustomStringConvertible {
        /// Optional starting date (inclusive)
        public let startDate: NSDate?
        /// Optional ending date (exclusive)
        public let endDate: NSDate?
        public init(startDate: NSDate? = nil, endDate: NSDate? = nil) {
            self.startDate = startDate
            self.endDate = endDate
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(DateRangeSerializer().serialize(self)))"
        }
    }
    public class DateRangeSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: DateRange) -> JSON {
            let output = [ 
            "start_date": NullableSerializer(NSDateSerializer("%Y-%m-%d")).serialize(value.startDate),
            "end_date": NullableSerializer(NSDateSerializer("%Y-%m-%d")).serialize(value.endDate),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> DateRange {
            switch json {
                case .Dictionary(let dict):
                    let startDate = NullableSerializer(NSDateSerializer("%Y-%m-%d")).deserialize(dict["start_date"] ?? .Null)
                    let endDate = NullableSerializer(NSDateSerializer("%Y-%m-%d")).deserialize(dict["end_date"] ?? .Null)
                    return DateRange(startDate: startDate, endDate: endDate)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Errors that can originate from problems in input arguments to reports.
    public enum DateRangeError: CustomStringConvertible {
        /// An unspecified error.
        case Other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(DateRangeErrorSerializer().serialize(self)))"
        }
    }
    public class DateRangeErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: DateRangeError) -> JSON {
            switch value {
                case .Other:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> DateRangeError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "other":
                            return DateRangeError.Other
                        default:
                            return DateRangeError.Other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Information about linked Dropbox desktop client sessions
    public class DesktopClientSession: Team.DeviceSession {
        /// Name of the hosting desktop
        public let hostName: String
        /// The Dropbox desktop client type
        public let clientType: Team.DesktopPlatform
        /// The Dropbox client version
        public let clientVersion: String
        /// Information on the hosting platform
        public let platform: String
        /// Whether it's possible to delete all of the account files upon unlinking
        public let isDeleteOnUnlinkSupported: Bool
        public init(sessionId: String, hostName: String, clientType: Team.DesktopPlatform, clientVersion: String, platform: String, isDeleteOnUnlinkSupported: Bool, ipAddress: String? = nil, country: String? = nil, created: NSDate? = nil, updated: NSDate? = nil) {
            stringValidator()(hostName)
            self.hostName = hostName
            self.clientType = clientType
            stringValidator()(clientVersion)
            self.clientVersion = clientVersion
            stringValidator()(platform)
            self.platform = platform
            self.isDeleteOnUnlinkSupported = isDeleteOnUnlinkSupported
            super.init(sessionId: sessionId, ipAddress: ipAddress, country: country, created: created, updated: updated)
        }
        public override var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(DesktopClientSessionSerializer().serialize(self)))"
        }
    }
    public class DesktopClientSessionSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: DesktopClientSession) -> JSON {
            let output = [ 
            "session_id": Serialization._StringSerializer.serialize(value.sessionId),
            "host_name": Serialization._StringSerializer.serialize(value.hostName),
            "client_type": Team.DesktopPlatformSerializer().serialize(value.clientType),
            "client_version": Serialization._StringSerializer.serialize(value.clientVersion),
            "platform": Serialization._StringSerializer.serialize(value.platform),
            "is_delete_on_unlink_supported": Serialization._BoolSerializer.serialize(value.isDeleteOnUnlinkSupported),
            "ip_address": NullableSerializer(Serialization._StringSerializer).serialize(value.ipAddress),
            "country": NullableSerializer(Serialization._StringSerializer).serialize(value.country),
            "created": NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.created),
            "updated": NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.updated),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> DesktopClientSession {
            switch json {
                case .Dictionary(let dict):
                    let sessionId = Serialization._StringSerializer.deserialize(dict["session_id"] ?? .Null)
                    let hostName = Serialization._StringSerializer.deserialize(dict["host_name"] ?? .Null)
                    let clientType = Team.DesktopPlatformSerializer().deserialize(dict["client_type"] ?? .Null)
                    let clientVersion = Serialization._StringSerializer.deserialize(dict["client_version"] ?? .Null)
                    let platform = Serialization._StringSerializer.deserialize(dict["platform"] ?? .Null)
                    let isDeleteOnUnlinkSupported = Serialization._BoolSerializer.deserialize(dict["is_delete_on_unlink_supported"] ?? .Null)
                    let ipAddress = NullableSerializer(Serialization._StringSerializer).deserialize(dict["ip_address"] ?? .Null)
                    let country = NullableSerializer(Serialization._StringSerializer).deserialize(dict["country"] ?? .Null)
                    let created = NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).deserialize(dict["created"] ?? .Null)
                    let updated = NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).deserialize(dict["updated"] ?? .Null)
                    return DesktopClientSession(sessionId: sessionId, hostName: hostName, clientType: clientType, clientVersion: clientVersion, platform: platform, isDeleteOnUnlinkSupported: isDeleteOnUnlinkSupported, ipAddress: ipAddress, country: country, created: created, updated: updated)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The DesktopPlatform union
    public enum DesktopPlatform: CustomStringConvertible {
        /// Official Windows Dropbox desktop client
        case Windows
        /// Official Mac Dropbox desktop client
        case Mac
        /// Official Linux Dropbox desktop client
        case Linux
        /// An unspecified error.
        case Other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(DesktopPlatformSerializer().serialize(self)))"
        }
    }
    public class DesktopPlatformSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: DesktopPlatform) -> JSON {
            switch value {
                case .Windows:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("windows")
                    return .Dictionary(d)
                case .Mac:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("mac")
                    return .Dictionary(d)
                case .Linux:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("linux")
                    return .Dictionary(d)
                case .Other:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> DesktopPlatform {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "windows":
                            return DesktopPlatform.Windows
                        case "mac":
                            return DesktopPlatform.Mac
                        case "linux":
                            return DesktopPlatform.Linux
                        case "other":
                            return DesktopPlatform.Other
                        default:
                            return DesktopPlatform.Other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The DeviceSessionArg struct
    public class DeviceSessionArg: CustomStringConvertible {
        /// The session id
        public let sessionId: String
        /// The unique id of the member owning the device
        public let teamMemberId: String
        public init(sessionId: String, teamMemberId: String) {
            stringValidator()(sessionId)
            self.sessionId = sessionId
            stringValidator()(teamMemberId)
            self.teamMemberId = teamMemberId
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(DeviceSessionArgSerializer().serialize(self)))"
        }
    }
    public class DeviceSessionArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: DeviceSessionArg) -> JSON {
            let output = [ 
            "session_id": Serialization._StringSerializer.serialize(value.sessionId),
            "team_member_id": Serialization._StringSerializer.serialize(value.teamMemberId),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> DeviceSessionArg {
            switch json {
                case .Dictionary(let dict):
                    let sessionId = Serialization._StringSerializer.deserialize(dict["session_id"] ?? .Null)
                    let teamMemberId = Serialization._StringSerializer.deserialize(dict["team_member_id"] ?? .Null)
                    return DeviceSessionArg(sessionId: sessionId, teamMemberId: teamMemberId)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Each of the items is an array of values, one value per day. The value is the number of devices active within a
    /// time window, ending with that day. If there is no data for a day, then the value will be None.
    public class DevicesActive: CustomStringConvertible {
        /// Array of number of linked windows (desktop) clients with activity.
        public let windows: Array<UInt64?>
        /// Array of number of linked mac (desktop) clients with activity.
        public let macos: Array<UInt64?>
        /// Array of number of linked linus (desktop) clients with activity.
        public let linux: Array<UInt64?>
        /// Array of number of linked ios devices with activity.
        public let ios: Array<UInt64?>
        /// Array of number of linked android devices with activity.
        public let android: Array<UInt64?>
        /// Array of number of other linked devices (blackberry, windows phone, etc)  with activity.
        public let other: Array<UInt64?>
        /// Array of total number of linked clients with activity.
        public let total: Array<UInt64?>
        public init(windows: Array<UInt64?>, macos: Array<UInt64?>, linux: Array<UInt64?>, ios: Array<UInt64?>, android: Array<UInt64?>, other: Array<UInt64?>, total: Array<UInt64?>) {
            arrayValidator(itemValidator: nullableValidator(comparableValidator()))(windows)
            self.windows = windows
            arrayValidator(itemValidator: nullableValidator(comparableValidator()))(macos)
            self.macos = macos
            arrayValidator(itemValidator: nullableValidator(comparableValidator()))(linux)
            self.linux = linux
            arrayValidator(itemValidator: nullableValidator(comparableValidator()))(ios)
            self.ios = ios
            arrayValidator(itemValidator: nullableValidator(comparableValidator()))(android)
            self.android = android
            arrayValidator(itemValidator: nullableValidator(comparableValidator()))(other)
            self.other = other
            arrayValidator(itemValidator: nullableValidator(comparableValidator()))(total)
            self.total = total
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(DevicesActiveSerializer().serialize(self)))"
        }
    }
    public class DevicesActiveSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: DevicesActive) -> JSON {
            let output = [ 
            "windows": ArraySerializer(NullableSerializer(Serialization._UInt64Serializer)).serialize(value.windows),
            "macos": ArraySerializer(NullableSerializer(Serialization._UInt64Serializer)).serialize(value.macos),
            "linux": ArraySerializer(NullableSerializer(Serialization._UInt64Serializer)).serialize(value.linux),
            "ios": ArraySerializer(NullableSerializer(Serialization._UInt64Serializer)).serialize(value.ios),
            "android": ArraySerializer(NullableSerializer(Serialization._UInt64Serializer)).serialize(value.android),
            "other": ArraySerializer(NullableSerializer(Serialization._UInt64Serializer)).serialize(value.other),
            "total": ArraySerializer(NullableSerializer(Serialization._UInt64Serializer)).serialize(value.total),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> DevicesActive {
            switch json {
                case .Dictionary(let dict):
                    let windows = ArraySerializer(NullableSerializer(Serialization._UInt64Serializer)).deserialize(dict["windows"] ?? .Null)
                    let macos = ArraySerializer(NullableSerializer(Serialization._UInt64Serializer)).deserialize(dict["macos"] ?? .Null)
                    let linux = ArraySerializer(NullableSerializer(Serialization._UInt64Serializer)).deserialize(dict["linux"] ?? .Null)
                    let ios = ArraySerializer(NullableSerializer(Serialization._UInt64Serializer)).deserialize(dict["ios"] ?? .Null)
                    let android = ArraySerializer(NullableSerializer(Serialization._UInt64Serializer)).deserialize(dict["android"] ?? .Null)
                    let other = ArraySerializer(NullableSerializer(Serialization._UInt64Serializer)).deserialize(dict["other"] ?? .Null)
                    let total = ArraySerializer(NullableSerializer(Serialization._UInt64Serializer)).deserialize(dict["total"] ?? .Null)
                    return DevicesActive(windows: windows, macos: macos, linux: linux, ios: ios, android: android, other: other, total: total)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Activity Report Result. Each of the items in the storage report is an array of values, one value per day. If
    /// there is no data for a day, then the value will be None.
    public class GetActivityReport: Team.BaseDfbReport {
        /// Array of total number of adds by team members.
        public let adds: Array<UInt64?>
        /// Array of number of edits by team members. If the same user edits the same file multiple times this is
        /// counted as a single edit.
        public let edits: Array<UInt64?>
        /// Array of total number of deletes by team members.
        public let deletes: Array<UInt64?>
        /// Array of the number of users who have been active in the last 28 days.
        public let activeUsers28Day: Array<UInt64?>
        /// Array of the number of users who have been active in the last week.
        public let activeUsers7Day: Array<UInt64?>
        /// Array of the number of users who have been active in the last day.
        public let activeUsers1Day: Array<UInt64?>
        /// Array of the number of shared folders with some activity in the last 28 days.
        public let activeSharedFolders28Day: Array<UInt64?>
        /// Array of the number of shared folders with some activity in the last week.
        public let activeSharedFolders7Day: Array<UInt64?>
        /// Array of the number of shared folders with some activity in the last day.
        public let activeSharedFolders1Day: Array<UInt64?>
        /// Array of the number of shared links created.
        public let sharedLinksCreated: Array<UInt64?>
        /// Array of the number of views by team users to shared links created by the team.
        public let sharedLinksViewedByTeam: Array<UInt64?>
        /// Array of the number of views by users outside of the team to shared links created by the team.
        public let sharedLinksViewedByOutsideUser: Array<UInt64?>
        /// Array of the number of views by non-logged-in users to shared links created by the team.
        public let sharedLinksViewedByNotLoggedIn: Array<UInt64?>
        /// Array of the total number of views to shared links created by the team.
        public let sharedLinksViewedTotal: Array<UInt64?>
        public init(startDate: String, adds: Array<UInt64?>, edits: Array<UInt64?>, deletes: Array<UInt64?>, activeUsers28Day: Array<UInt64?>, activeUsers7Day: Array<UInt64?>, activeUsers1Day: Array<UInt64?>, activeSharedFolders28Day: Array<UInt64?>, activeSharedFolders7Day: Array<UInt64?>, activeSharedFolders1Day: Array<UInt64?>, sharedLinksCreated: Array<UInt64?>, sharedLinksViewedByTeam: Array<UInt64?>, sharedLinksViewedByOutsideUser: Array<UInt64?>, sharedLinksViewedByNotLoggedIn: Array<UInt64?>, sharedLinksViewedTotal: Array<UInt64?>) {
            arrayValidator(itemValidator: nullableValidator(comparableValidator()))(adds)
            self.adds = adds
            arrayValidator(itemValidator: nullableValidator(comparableValidator()))(edits)
            self.edits = edits
            arrayValidator(itemValidator: nullableValidator(comparableValidator()))(deletes)
            self.deletes = deletes
            arrayValidator(itemValidator: nullableValidator(comparableValidator()))(activeUsers28Day)
            self.activeUsers28Day = activeUsers28Day
            arrayValidator(itemValidator: nullableValidator(comparableValidator()))(activeUsers7Day)
            self.activeUsers7Day = activeUsers7Day
            arrayValidator(itemValidator: nullableValidator(comparableValidator()))(activeUsers1Day)
            self.activeUsers1Day = activeUsers1Day
            arrayValidator(itemValidator: nullableValidator(comparableValidator()))(activeSharedFolders28Day)
            self.activeSharedFolders28Day = activeSharedFolders28Day
            arrayValidator(itemValidator: nullableValidator(comparableValidator()))(activeSharedFolders7Day)
            self.activeSharedFolders7Day = activeSharedFolders7Day
            arrayValidator(itemValidator: nullableValidator(comparableValidator()))(activeSharedFolders1Day)
            self.activeSharedFolders1Day = activeSharedFolders1Day
            arrayValidator(itemValidator: nullableValidator(comparableValidator()))(sharedLinksCreated)
            self.sharedLinksCreated = sharedLinksCreated
            arrayValidator(itemValidator: nullableValidator(comparableValidator()))(sharedLinksViewedByTeam)
            self.sharedLinksViewedByTeam = sharedLinksViewedByTeam
            arrayValidator(itemValidator: nullableValidator(comparableValidator()))(sharedLinksViewedByOutsideUser)
            self.sharedLinksViewedByOutsideUser = sharedLinksViewedByOutsideUser
            arrayValidator(itemValidator: nullableValidator(comparableValidator()))(sharedLinksViewedByNotLoggedIn)
            self.sharedLinksViewedByNotLoggedIn = sharedLinksViewedByNotLoggedIn
            arrayValidator(itemValidator: nullableValidator(comparableValidator()))(sharedLinksViewedTotal)
            self.sharedLinksViewedTotal = sharedLinksViewedTotal
            super.init(startDate: startDate)
        }
        public override var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GetActivityReportSerializer().serialize(self)))"
        }
    }
    public class GetActivityReportSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: GetActivityReport) -> JSON {
            let output = [ 
            "start_date": Serialization._StringSerializer.serialize(value.startDate),
            "adds": ArraySerializer(NullableSerializer(Serialization._UInt64Serializer)).serialize(value.adds),
            "edits": ArraySerializer(NullableSerializer(Serialization._UInt64Serializer)).serialize(value.edits),
            "deletes": ArraySerializer(NullableSerializer(Serialization._UInt64Serializer)).serialize(value.deletes),
            "active_users_28_day": ArraySerializer(NullableSerializer(Serialization._UInt64Serializer)).serialize(value.activeUsers28Day),
            "active_users_7_day": ArraySerializer(NullableSerializer(Serialization._UInt64Serializer)).serialize(value.activeUsers7Day),
            "active_users_1_day": ArraySerializer(NullableSerializer(Serialization._UInt64Serializer)).serialize(value.activeUsers1Day),
            "active_shared_folders_28_day": ArraySerializer(NullableSerializer(Serialization._UInt64Serializer)).serialize(value.activeSharedFolders28Day),
            "active_shared_folders_7_day": ArraySerializer(NullableSerializer(Serialization._UInt64Serializer)).serialize(value.activeSharedFolders7Day),
            "active_shared_folders_1_day": ArraySerializer(NullableSerializer(Serialization._UInt64Serializer)).serialize(value.activeSharedFolders1Day),
            "shared_links_created": ArraySerializer(NullableSerializer(Serialization._UInt64Serializer)).serialize(value.sharedLinksCreated),
            "shared_links_viewed_by_team": ArraySerializer(NullableSerializer(Serialization._UInt64Serializer)).serialize(value.sharedLinksViewedByTeam),
            "shared_links_viewed_by_outside_user": ArraySerializer(NullableSerializer(Serialization._UInt64Serializer)).serialize(value.sharedLinksViewedByOutsideUser),
            "shared_links_viewed_by_not_logged_in": ArraySerializer(NullableSerializer(Serialization._UInt64Serializer)).serialize(value.sharedLinksViewedByNotLoggedIn),
            "shared_links_viewed_total": ArraySerializer(NullableSerializer(Serialization._UInt64Serializer)).serialize(value.sharedLinksViewedTotal),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> GetActivityReport {
            switch json {
                case .Dictionary(let dict):
                    let startDate = Serialization._StringSerializer.deserialize(dict["start_date"] ?? .Null)
                    let adds = ArraySerializer(NullableSerializer(Serialization._UInt64Serializer)).deserialize(dict["adds"] ?? .Null)
                    let edits = ArraySerializer(NullableSerializer(Serialization._UInt64Serializer)).deserialize(dict["edits"] ?? .Null)
                    let deletes = ArraySerializer(NullableSerializer(Serialization._UInt64Serializer)).deserialize(dict["deletes"] ?? .Null)
                    let activeUsers28Day = ArraySerializer(NullableSerializer(Serialization._UInt64Serializer)).deserialize(dict["active_users_28_day"] ?? .Null)
                    let activeUsers7Day = ArraySerializer(NullableSerializer(Serialization._UInt64Serializer)).deserialize(dict["active_users_7_day"] ?? .Null)
                    let activeUsers1Day = ArraySerializer(NullableSerializer(Serialization._UInt64Serializer)).deserialize(dict["active_users_1_day"] ?? .Null)
                    let activeSharedFolders28Day = ArraySerializer(NullableSerializer(Serialization._UInt64Serializer)).deserialize(dict["active_shared_folders_28_day"] ?? .Null)
                    let activeSharedFolders7Day = ArraySerializer(NullableSerializer(Serialization._UInt64Serializer)).deserialize(dict["active_shared_folders_7_day"] ?? .Null)
                    let activeSharedFolders1Day = ArraySerializer(NullableSerializer(Serialization._UInt64Serializer)).deserialize(dict["active_shared_folders_1_day"] ?? .Null)
                    let sharedLinksCreated = ArraySerializer(NullableSerializer(Serialization._UInt64Serializer)).deserialize(dict["shared_links_created"] ?? .Null)
                    let sharedLinksViewedByTeam = ArraySerializer(NullableSerializer(Serialization._UInt64Serializer)).deserialize(dict["shared_links_viewed_by_team"] ?? .Null)
                    let sharedLinksViewedByOutsideUser = ArraySerializer(NullableSerializer(Serialization._UInt64Serializer)).deserialize(dict["shared_links_viewed_by_outside_user"] ?? .Null)
                    let sharedLinksViewedByNotLoggedIn = ArraySerializer(NullableSerializer(Serialization._UInt64Serializer)).deserialize(dict["shared_links_viewed_by_not_logged_in"] ?? .Null)
                    let sharedLinksViewedTotal = ArraySerializer(NullableSerializer(Serialization._UInt64Serializer)).deserialize(dict["shared_links_viewed_total"] ?? .Null)
                    return GetActivityReport(startDate: startDate, adds: adds, edits: edits, deletes: deletes, activeUsers28Day: activeUsers28Day, activeUsers7Day: activeUsers7Day, activeUsers1Day: activeUsers1Day, activeSharedFolders28Day: activeSharedFolders28Day, activeSharedFolders7Day: activeSharedFolders7Day, activeSharedFolders1Day: activeSharedFolders1Day, sharedLinksCreated: sharedLinksCreated, sharedLinksViewedByTeam: sharedLinksViewedByTeam, sharedLinksViewedByOutsideUser: sharedLinksViewedByOutsideUser, sharedLinksViewedByNotLoggedIn: sharedLinksViewedByNotLoggedIn, sharedLinksViewedTotal: sharedLinksViewedTotal)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Devices Report Result. Contains subsections for different time ranges of activity. Each of the items in each
    /// subsection of the storage report is an array of values, one value per day. If there is no data for a day, then
    /// the value will be None.
    public class GetDevicesReport: Team.BaseDfbReport {
        /// Report of the number of devices active in the last day.
        public let active1Day: Team.DevicesActive
        /// Report of the number of devices active in the last 7 days.
        public let active7Day: Team.DevicesActive
        /// Report of the number of devices active in the last 28 days.
        public let active28Day: Team.DevicesActive
        public init(startDate: String, active1Day: Team.DevicesActive, active7Day: Team.DevicesActive, active28Day: Team.DevicesActive) {
            self.active1Day = active1Day
            self.active7Day = active7Day
            self.active28Day = active28Day
            super.init(startDate: startDate)
        }
        public override var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GetDevicesReportSerializer().serialize(self)))"
        }
    }
    public class GetDevicesReportSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: GetDevicesReport) -> JSON {
            let output = [ 
            "start_date": Serialization._StringSerializer.serialize(value.startDate),
            "active_1_day": Team.DevicesActiveSerializer().serialize(value.active1Day),
            "active_7_day": Team.DevicesActiveSerializer().serialize(value.active7Day),
            "active_28_day": Team.DevicesActiveSerializer().serialize(value.active28Day),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> GetDevicesReport {
            switch json {
                case .Dictionary(let dict):
                    let startDate = Serialization._StringSerializer.deserialize(dict["start_date"] ?? .Null)
                    let active1Day = Team.DevicesActiveSerializer().deserialize(dict["active_1_day"] ?? .Null)
                    let active7Day = Team.DevicesActiveSerializer().deserialize(dict["active_7_day"] ?? .Null)
                    let active28Day = Team.DevicesActiveSerializer().deserialize(dict["active_28_day"] ?? .Null)
                    return GetDevicesReport(startDate: startDate, active1Day: active1Day, active7Day: active7Day, active28Day: active28Day)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Membership Report Result. Each of the items in the storage report is an array of values, one value per day. If
    /// there is no data for a day, then the value will be None.
    public class GetMembershipReport: Team.BaseDfbReport {
        /// Team size, for each day.
        public let teamSize: Array<UInt64?>
        /// The number of pending invites to the team, for each day.
        public let pendingInvites: Array<UInt64?>
        /// The number of members that joined the team, for each day.
        public let membersJoined: Array<UInt64?>
        /// The number of suspended team members, for each day.
        public let suspendedMembers: Array<UInt64?>
        /// The total number of licenses the team has, for each day.
        public let licenses: Array<UInt64?>
        public init(startDate: String, teamSize: Array<UInt64?>, pendingInvites: Array<UInt64?>, membersJoined: Array<UInt64?>, suspendedMembers: Array<UInt64?>, licenses: Array<UInt64?>) {
            arrayValidator(itemValidator: nullableValidator(comparableValidator()))(teamSize)
            self.teamSize = teamSize
            arrayValidator(itemValidator: nullableValidator(comparableValidator()))(pendingInvites)
            self.pendingInvites = pendingInvites
            arrayValidator(itemValidator: nullableValidator(comparableValidator()))(membersJoined)
            self.membersJoined = membersJoined
            arrayValidator(itemValidator: nullableValidator(comparableValidator()))(suspendedMembers)
            self.suspendedMembers = suspendedMembers
            arrayValidator(itemValidator: nullableValidator(comparableValidator()))(licenses)
            self.licenses = licenses
            super.init(startDate: startDate)
        }
        public override var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GetMembershipReportSerializer().serialize(self)))"
        }
    }
    public class GetMembershipReportSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: GetMembershipReport) -> JSON {
            let output = [ 
            "start_date": Serialization._StringSerializer.serialize(value.startDate),
            "team_size": ArraySerializer(NullableSerializer(Serialization._UInt64Serializer)).serialize(value.teamSize),
            "pending_invites": ArraySerializer(NullableSerializer(Serialization._UInt64Serializer)).serialize(value.pendingInvites),
            "members_joined": ArraySerializer(NullableSerializer(Serialization._UInt64Serializer)).serialize(value.membersJoined),
            "suspended_members": ArraySerializer(NullableSerializer(Serialization._UInt64Serializer)).serialize(value.suspendedMembers),
            "licenses": ArraySerializer(NullableSerializer(Serialization._UInt64Serializer)).serialize(value.licenses),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> GetMembershipReport {
            switch json {
                case .Dictionary(let dict):
                    let startDate = Serialization._StringSerializer.deserialize(dict["start_date"] ?? .Null)
                    let teamSize = ArraySerializer(NullableSerializer(Serialization._UInt64Serializer)).deserialize(dict["team_size"] ?? .Null)
                    let pendingInvites = ArraySerializer(NullableSerializer(Serialization._UInt64Serializer)).deserialize(dict["pending_invites"] ?? .Null)
                    let membersJoined = ArraySerializer(NullableSerializer(Serialization._UInt64Serializer)).deserialize(dict["members_joined"] ?? .Null)
                    let suspendedMembers = ArraySerializer(NullableSerializer(Serialization._UInt64Serializer)).deserialize(dict["suspended_members"] ?? .Null)
                    let licenses = ArraySerializer(NullableSerializer(Serialization._UInt64Serializer)).deserialize(dict["licenses"] ?? .Null)
                    return GetMembershipReport(startDate: startDate, teamSize: teamSize, pendingInvites: pendingInvites, membersJoined: membersJoined, suspendedMembers: suspendedMembers, licenses: licenses)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Storage Report Result. Each of the items in the storage report is an array of values, one value per day. If
    /// there is no data for a day, then the value will be None.
    public class GetStorageReport: Team.BaseDfbReport {
        /// Sum of the shared, unshared, and datastore usages, for each day.
        public let totalUsage: Array<UInt64?>
        /// Array of the combined size (bytes) of team members' shared folders, for each day.
        public let sharedUsage: Array<UInt64?>
        /// Array of the combined size (bytes) of team members' root namespaces, for each day.
        public let unsharedUsage: Array<UInt64?>
        /// Array of the number of shared folders owned by team members, for each day.
        public let sharedFolders: Array<UInt64?>
        /// Array of storage summaries of team members' account sizes. Each storage summary is an array of key, value
        /// pairs, where each pair describes a storage bucket. The key indicates the upper bound of the bucket and the
        /// value is the number of users in that bucket. There is one such summary per day. If there is no data for a
        /// day, the storage summary will be empty.
        public let memberStorageMap: Array<Array<Team.StorageBucket>>
        public init(startDate: String, totalUsage: Array<UInt64?>, sharedUsage: Array<UInt64?>, unsharedUsage: Array<UInt64?>, sharedFolders: Array<UInt64?>, memberStorageMap: Array<Array<Team.StorageBucket>>) {
            arrayValidator(itemValidator: nullableValidator(comparableValidator()))(totalUsage)
            self.totalUsage = totalUsage
            arrayValidator(itemValidator: nullableValidator(comparableValidator()))(sharedUsage)
            self.sharedUsage = sharedUsage
            arrayValidator(itemValidator: nullableValidator(comparableValidator()))(unsharedUsage)
            self.unsharedUsage = unsharedUsage
            arrayValidator(itemValidator: nullableValidator(comparableValidator()))(sharedFolders)
            self.sharedFolders = sharedFolders
            self.memberStorageMap = memberStorageMap
            super.init(startDate: startDate)
        }
        public override var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GetStorageReportSerializer().serialize(self)))"
        }
    }
    public class GetStorageReportSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: GetStorageReport) -> JSON {
            let output = [ 
            "start_date": Serialization._StringSerializer.serialize(value.startDate),
            "total_usage": ArraySerializer(NullableSerializer(Serialization._UInt64Serializer)).serialize(value.totalUsage),
            "shared_usage": ArraySerializer(NullableSerializer(Serialization._UInt64Serializer)).serialize(value.sharedUsage),
            "unshared_usage": ArraySerializer(NullableSerializer(Serialization._UInt64Serializer)).serialize(value.unsharedUsage),
            "shared_folders": ArraySerializer(NullableSerializer(Serialization._UInt64Serializer)).serialize(value.sharedFolders),
            "member_storage_map": ArraySerializer(ArraySerializer(Team.StorageBucketSerializer())).serialize(value.memberStorageMap),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> GetStorageReport {
            switch json {
                case .Dictionary(let dict):
                    let startDate = Serialization._StringSerializer.deserialize(dict["start_date"] ?? .Null)
                    let totalUsage = ArraySerializer(NullableSerializer(Serialization._UInt64Serializer)).deserialize(dict["total_usage"] ?? .Null)
                    let sharedUsage = ArraySerializer(NullableSerializer(Serialization._UInt64Serializer)).deserialize(dict["shared_usage"] ?? .Null)
                    let unsharedUsage = ArraySerializer(NullableSerializer(Serialization._UInt64Serializer)).deserialize(dict["unshared_usage"] ?? .Null)
                    let sharedFolders = ArraySerializer(NullableSerializer(Serialization._UInt64Serializer)).deserialize(dict["shared_folders"] ?? .Null)
                    let memberStorageMap = ArraySerializer(ArraySerializer(Team.StorageBucketSerializer())).deserialize(dict["member_storage_map"] ?? .Null)
                    return GetStorageReport(startDate: startDate, totalUsage: totalUsage, sharedUsage: sharedUsage, unsharedUsage: unsharedUsage, sharedFolders: sharedFolders, memberStorageMap: memberStorageMap)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Role of a user in group.
    public enum GroupAccessType: CustomStringConvertible {
        /// User is a member of the group, but has no special permissions.
        case Member
        /// User can rename the group, and add/remove members.
        case Owner

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GroupAccessTypeSerializer().serialize(self)))"
        }
    }
    public class GroupAccessTypeSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: GroupAccessType) -> JSON {
            switch value {
                case .Member:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("member")
                    return .Dictionary(d)
                case .Owner:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("owner")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> GroupAccessType {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "member":
                            return GroupAccessType.Member
                        case "owner":
                            return GroupAccessType.Owner
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The GroupCreateArg struct
    public class GroupCreateArg: CustomStringConvertible {
        /// Group name.
        public let groupName: String
        /// The creator of a team can associate an arbitrary external ID to the group.
        public let groupExternalId: String?
        /// Whether the team can be managed by selected users, or only by team admins
        public let groupManagementType: TeamCommon.GroupManagementType?
        public init(groupName: String, groupExternalId: String? = nil, groupManagementType: TeamCommon.GroupManagementType? = nil) {
            stringValidator()(groupName)
            self.groupName = groupName
            nullableValidator(stringValidator())(groupExternalId)
            self.groupExternalId = groupExternalId
            self.groupManagementType = groupManagementType
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GroupCreateArgSerializer().serialize(self)))"
        }
    }
    public class GroupCreateArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: GroupCreateArg) -> JSON {
            let output = [ 
            "group_name": Serialization._StringSerializer.serialize(value.groupName),
            "group_external_id": NullableSerializer(Serialization._StringSerializer).serialize(value.groupExternalId),
            "group_management_type": NullableSerializer(TeamCommon.GroupManagementTypeSerializer()).serialize(value.groupManagementType),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> GroupCreateArg {
            switch json {
                case .Dictionary(let dict):
                    let groupName = Serialization._StringSerializer.deserialize(dict["group_name"] ?? .Null)
                    let groupExternalId = NullableSerializer(Serialization._StringSerializer).deserialize(dict["group_external_id"] ?? .Null)
                    let groupManagementType = NullableSerializer(TeamCommon.GroupManagementTypeSerializer()).deserialize(dict["group_management_type"] ?? .Null)
                    return GroupCreateArg(groupName: groupName, groupExternalId: groupExternalId, groupManagementType: groupManagementType)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The GroupCreateError union
    public enum GroupCreateError: CustomStringConvertible {
        /// There is already an existing group with the requested name.
        case GroupNameAlreadyUsed
        /// Group name is empty or has invalid characters.
        case GroupNameInvalid
        /// The new external ID is already being used by another group.
        case ExternalIdAlreadyInUse
        /// An unspecified error.
        case Other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GroupCreateErrorSerializer().serialize(self)))"
        }
    }
    public class GroupCreateErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: GroupCreateError) -> JSON {
            switch value {
                case .GroupNameAlreadyUsed:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("group_name_already_used")
                    return .Dictionary(d)
                case .GroupNameInvalid:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("group_name_invalid")
                    return .Dictionary(d)
                case .ExternalIdAlreadyInUse:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("external_id_already_in_use")
                    return .Dictionary(d)
                case .Other:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> GroupCreateError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "group_name_already_used":
                            return GroupCreateError.GroupNameAlreadyUsed
                        case "group_name_invalid":
                            return GroupCreateError.GroupNameInvalid
                        case "external_id_already_in_use":
                            return GroupCreateError.ExternalIdAlreadyInUse
                        case "other":
                            return GroupCreateError.Other
                        default:
                            return GroupCreateError.Other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Error that can be raised when GroupSelector is used.
    public enum GroupSelectorError: CustomStringConvertible {
        /// No matching group found. No groups match the specified group ID.
        case GroupNotFound
        /// An unspecified error.
        case Other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GroupSelectorErrorSerializer().serialize(self)))"
        }
    }
    public class GroupSelectorErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: GroupSelectorError) -> JSON {
            switch value {
                case .GroupNotFound:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("group_not_found")
                    return .Dictionary(d)
                case .Other:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> GroupSelectorError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "group_not_found":
                            return GroupSelectorError.GroupNotFound
                        case "other":
                            return GroupSelectorError.Other
                        default:
                            return GroupSelectorError.Other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The GroupDeleteError union
    public enum GroupDeleteError: CustomStringConvertible {
        /// No matching group found. No groups match the specified group ID.
        case GroupNotFound
        /// An unspecified error.
        case Other
        /// This group has already been deleted.
        case GroupAlreadyDeleted

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GroupDeleteErrorSerializer().serialize(self)))"
        }
    }
    public class GroupDeleteErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: GroupDeleteError) -> JSON {
            switch value {
                case .GroupNotFound:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("group_not_found")
                    return .Dictionary(d)
                case .Other:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
                case .GroupAlreadyDeleted:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("group_already_deleted")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> GroupDeleteError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "group_not_found":
                            return GroupDeleteError.GroupNotFound
                        case "other":
                            return GroupDeleteError.Other
                        case "group_already_deleted":
                            return GroupDeleteError.GroupAlreadyDeleted
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Full description of a group.
    public class GroupFullInfo: TeamCommon.GroupSummary {
        /// List of group members.
        public let members: Array<Team.GroupMemberInfo>?
        /// The group creation time as a UTC timestamp in milliseconds since the Unix epoch.
        public let created: UInt64
        public init(groupName: String, groupId: String, groupManagementType: TeamCommon.GroupManagementType, created: UInt64, groupExternalId: String? = nil, memberCount: UInt32? = nil, members: Array<Team.GroupMemberInfo>? = nil) {
            self.members = members
            comparableValidator()(created)
            self.created = created
            super.init(groupName: groupName, groupId: groupId, groupManagementType: groupManagementType, groupExternalId: groupExternalId, memberCount: memberCount)
        }
        public override var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GroupFullInfoSerializer().serialize(self)))"
        }
    }
    public class GroupFullInfoSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: GroupFullInfo) -> JSON {
            let output = [ 
            "group_name": Serialization._StringSerializer.serialize(value.groupName),
            "group_id": Serialization._StringSerializer.serialize(value.groupId),
            "group_management_type": TeamCommon.GroupManagementTypeSerializer().serialize(value.groupManagementType),
            "created": Serialization._UInt64Serializer.serialize(value.created),
            "group_external_id": NullableSerializer(Serialization._StringSerializer).serialize(value.groupExternalId),
            "member_count": NullableSerializer(Serialization._UInt32Serializer).serialize(value.memberCount),
            "members": NullableSerializer(ArraySerializer(Team.GroupMemberInfoSerializer())).serialize(value.members),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> GroupFullInfo {
            switch json {
                case .Dictionary(let dict):
                    let groupName = Serialization._StringSerializer.deserialize(dict["group_name"] ?? .Null)
                    let groupId = Serialization._StringSerializer.deserialize(dict["group_id"] ?? .Null)
                    let groupManagementType = TeamCommon.GroupManagementTypeSerializer().deserialize(dict["group_management_type"] ?? .Null)
                    let created = Serialization._UInt64Serializer.deserialize(dict["created"] ?? .Null)
                    let groupExternalId = NullableSerializer(Serialization._StringSerializer).deserialize(dict["group_external_id"] ?? .Null)
                    let memberCount = NullableSerializer(Serialization._UInt32Serializer).deserialize(dict["member_count"] ?? .Null)
                    let members = NullableSerializer(ArraySerializer(Team.GroupMemberInfoSerializer())).deserialize(dict["members"] ?? .Null)
                    return GroupFullInfo(groupName: groupName, groupId: groupId, groupManagementType: groupManagementType, created: created, groupExternalId: groupExternalId, memberCount: memberCount, members: members)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Profile of group member, and role in group.
    public class GroupMemberInfo: CustomStringConvertible {
        /// Profile of group member.
        public let profile: Team.MemberProfile
        /// The role that the user has in the group.
        public let accessType: Team.GroupAccessType
        public init(profile: Team.MemberProfile, accessType: Team.GroupAccessType) {
            self.profile = profile
            self.accessType = accessType
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GroupMemberInfoSerializer().serialize(self)))"
        }
    }
    public class GroupMemberInfoSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: GroupMemberInfo) -> JSON {
            let output = [ 
            "profile": Team.MemberProfileSerializer().serialize(value.profile),
            "access_type": Team.GroupAccessTypeSerializer().serialize(value.accessType),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> GroupMemberInfo {
            switch json {
                case .Dictionary(let dict):
                    let profile = Team.MemberProfileSerializer().deserialize(dict["profile"] ?? .Null)
                    let accessType = Team.GroupAccessTypeSerializer().deserialize(dict["access_type"] ?? .Null)
                    return GroupMemberInfo(profile: profile, accessType: accessType)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Argument for selecting a group and a single user.
    public class GroupMemberSelector: CustomStringConvertible {
        /// Specify a group.
        public let group: Team.GroupSelector
        /// Identity of a user that is a member of group.
        public let user: Team.UserSelectorArg
        public init(group: Team.GroupSelector, user: Team.UserSelectorArg) {
            self.group = group
            self.user = user
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GroupMemberSelectorSerializer().serialize(self)))"
        }
    }
    public class GroupMemberSelectorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: GroupMemberSelector) -> JSON {
            let output = [ 
            "group": Team.GroupSelectorSerializer().serialize(value.group),
            "user": Team.UserSelectorArgSerializer().serialize(value.user),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> GroupMemberSelector {
            switch json {
                case .Dictionary(let dict):
                    let group = Team.GroupSelectorSerializer().deserialize(dict["group"] ?? .Null)
                    let user = Team.UserSelectorArgSerializer().deserialize(dict["user"] ?? .Null)
                    return GroupMemberSelector(group: group, user: user)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Error that can be raised when GroupMemberSelector is used, and the user is required to be a member of the
    /// specified group.
    public enum GroupMemberSelectorError: CustomStringConvertible {
        /// No matching group found. No groups match the specified group ID.
        case GroupNotFound
        /// An unspecified error.
        case Other
        /// The specified user is not a member of this group.
        case MemberNotInGroup

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GroupMemberSelectorErrorSerializer().serialize(self)))"
        }
    }
    public class GroupMemberSelectorErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: GroupMemberSelectorError) -> JSON {
            switch value {
                case .GroupNotFound:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("group_not_found")
                    return .Dictionary(d)
                case .Other:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
                case .MemberNotInGroup:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("member_not_in_group")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> GroupMemberSelectorError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "group_not_found":
                            return GroupMemberSelectorError.GroupNotFound
                        case "other":
                            return GroupMemberSelectorError.Other
                        case "member_not_in_group":
                            return GroupMemberSelectorError.MemberNotInGroup
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The GroupMemberSetAccessTypeError union
    public enum GroupMemberSetAccessTypeError: CustomStringConvertible {
        /// No matching group found. No groups match the specified group ID.
        case GroupNotFound
        /// An unspecified error.
        case Other
        /// The specified user is not a member of this group.
        case MemberNotInGroup
        /// A company managed group cannot be managed by a user.
        case UserCannotBeManagerOfCompanyManagedGroup

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GroupMemberSetAccessTypeErrorSerializer().serialize(self)))"
        }
    }
    public class GroupMemberSetAccessTypeErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: GroupMemberSetAccessTypeError) -> JSON {
            switch value {
                case .GroupNotFound:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("group_not_found")
                    return .Dictionary(d)
                case .Other:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
                case .MemberNotInGroup:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("member_not_in_group")
                    return .Dictionary(d)
                case .UserCannotBeManagerOfCompanyManagedGroup:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("user_cannot_be_manager_of_company_managed_group")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> GroupMemberSetAccessTypeError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "group_not_found":
                            return GroupMemberSetAccessTypeError.GroupNotFound
                        case "other":
                            return GroupMemberSetAccessTypeError.Other
                        case "member_not_in_group":
                            return GroupMemberSetAccessTypeError.MemberNotInGroup
                        case "user_cannot_be_manager_of_company_managed_group":
                            return GroupMemberSetAccessTypeError.UserCannotBeManagerOfCompanyManagedGroup
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The IncludeMembersArg struct
    public class IncludeMembersArg: CustomStringConvertible {
        /// Whether to return the list of members in the group.  Note that the default value will cause all the group
        /// members  to be returned in the response. This may take a long time for large groups.
        public let returnMembers: Bool
        public init(returnMembers: Bool = true) {
            self.returnMembers = returnMembers
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(IncludeMembersArgSerializer().serialize(self)))"
        }
    }
    public class IncludeMembersArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: IncludeMembersArg) -> JSON {
            let output = [ 
            "return_members": Serialization._BoolSerializer.serialize(value.returnMembers),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> IncludeMembersArg {
            switch json {
                case .Dictionary(let dict):
                    let returnMembers = Serialization._BoolSerializer.deserialize(dict["return_members"] ?? .Null)
                    return IncludeMembersArg(returnMembers: returnMembers)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The GroupMembersAddArg struct
    public class GroupMembersAddArg: Team.IncludeMembersArg {
        /// Group to which users will be added.
        public let group: Team.GroupSelector
        /// List of users to be added to the group.
        public let members: Array<Team.MemberAccess>
        public init(group: Team.GroupSelector, members: Array<Team.MemberAccess>, returnMembers: Bool = true) {
            self.group = group
            self.members = members
            super.init(returnMembers: returnMembers)
        }
        public override var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GroupMembersAddArgSerializer().serialize(self)))"
        }
    }
    public class GroupMembersAddArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: GroupMembersAddArg) -> JSON {
            let output = [ 
            "group": Team.GroupSelectorSerializer().serialize(value.group),
            "members": ArraySerializer(Team.MemberAccessSerializer()).serialize(value.members),
            "return_members": Serialization._BoolSerializer.serialize(value.returnMembers),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> GroupMembersAddArg {
            switch json {
                case .Dictionary(let dict):
                    let group = Team.GroupSelectorSerializer().deserialize(dict["group"] ?? .Null)
                    let members = ArraySerializer(Team.MemberAccessSerializer()).deserialize(dict["members"] ?? .Null)
                    let returnMembers = Serialization._BoolSerializer.deserialize(dict["return_members"] ?? .Null)
                    return GroupMembersAddArg(group: group, members: members, returnMembers: returnMembers)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The GroupMembersAddError union
    public enum GroupMembersAddError: CustomStringConvertible {
        /// No matching group found. No groups match the specified group ID.
        case GroupNotFound
        /// An unspecified error.
        case Other
        /// You cannot add duplicate users. One or more of the members you are trying to add is already a member of the
        /// group.
        case DuplicateUser
        /// Group is not in this team. You cannot add members to a group that is outside of your team.
        case GroupNotInTeam
        /// These members are not part of your team. Currently, you cannot add members to a group if they are not part
        /// of your team, though this may change in a subsequent version. To add new members to your Dropbox Business
        /// team, use the membersAdd endpoint.
        case MembersNotInTeam(Array<String>)
        /// These users were not found in Dropbox.
        case UsersNotFound(Array<String>)
        /// A suspended user cannot be added to a group as owner in GroupAccessType.
        case UserMustBeActiveToBeOwner
        /// A company-managed group cannot be managed by a user.
        case UserCannotBeManagerOfCompanyManagedGroup(Array<String>)

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GroupMembersAddErrorSerializer().serialize(self)))"
        }
    }
    public class GroupMembersAddErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: GroupMembersAddError) -> JSON {
            switch value {
                case .GroupNotFound:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("group_not_found")
                    return .Dictionary(d)
                case .Other:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
                case .DuplicateUser:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("duplicate_user")
                    return .Dictionary(d)
                case .GroupNotInTeam:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("group_not_in_team")
                    return .Dictionary(d)
                case .MembersNotInTeam(let arg):
                    var d = ["members_not_in_team": ArraySerializer(Serialization._StringSerializer).serialize(arg)]
                    d[".tag"] = .Str("members_not_in_team")
                    return .Dictionary(d)
                case .UsersNotFound(let arg):
                    var d = ["users_not_found": ArraySerializer(Serialization._StringSerializer).serialize(arg)]
                    d[".tag"] = .Str("users_not_found")
                    return .Dictionary(d)
                case .UserMustBeActiveToBeOwner:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("user_must_be_active_to_be_owner")
                    return .Dictionary(d)
                case .UserCannotBeManagerOfCompanyManagedGroup(let arg):
                    var d = ["user_cannot_be_manager_of_company_managed_group": ArraySerializer(Serialization._StringSerializer).serialize(arg)]
                    d[".tag"] = .Str("user_cannot_be_manager_of_company_managed_group")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> GroupMembersAddError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "group_not_found":
                            return GroupMembersAddError.GroupNotFound
                        case "other":
                            return GroupMembersAddError.Other
                        case "duplicate_user":
                            return GroupMembersAddError.DuplicateUser
                        case "group_not_in_team":
                            return GroupMembersAddError.GroupNotInTeam
                        case "members_not_in_team":
                            let v = ArraySerializer(Serialization._StringSerializer).deserialize(d["members_not_in_team"] ?? .Null)
                            return GroupMembersAddError.MembersNotInTeam(v)
                        case "users_not_found":
                            let v = ArraySerializer(Serialization._StringSerializer).deserialize(d["users_not_found"] ?? .Null)
                            return GroupMembersAddError.UsersNotFound(v)
                        case "user_must_be_active_to_be_owner":
                            return GroupMembersAddError.UserMustBeActiveToBeOwner
                        case "user_cannot_be_manager_of_company_managed_group":
                            let v = ArraySerializer(Serialization._StringSerializer).deserialize(d["user_cannot_be_manager_of_company_managed_group"] ?? .Null)
                            return GroupMembersAddError.UserCannotBeManagerOfCompanyManagedGroup(v)
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Result returned by groupsMembersAdd and groupsMembersRemove.
    public class GroupMembersChangeResult: CustomStringConvertible {
        /// The group info after member change operation has been performed.
        public let groupInfo: Team.GroupFullInfo
        /// An ID that can be used to obtain the status of granting/revoking group-owned resources.
        public let asyncJobId: String
        public init(groupInfo: Team.GroupFullInfo, asyncJobId: String) {
            self.groupInfo = groupInfo
            stringValidator(minLength: 1)(asyncJobId)
            self.asyncJobId = asyncJobId
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GroupMembersChangeResultSerializer().serialize(self)))"
        }
    }
    public class GroupMembersChangeResultSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: GroupMembersChangeResult) -> JSON {
            let output = [ 
            "group_info": Team.GroupFullInfoSerializer().serialize(value.groupInfo),
            "async_job_id": Serialization._StringSerializer.serialize(value.asyncJobId),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> GroupMembersChangeResult {
            switch json {
                case .Dictionary(let dict):
                    let groupInfo = Team.GroupFullInfoSerializer().deserialize(dict["group_info"] ?? .Null)
                    let asyncJobId = Serialization._StringSerializer.deserialize(dict["async_job_id"] ?? .Null)
                    return GroupMembersChangeResult(groupInfo: groupInfo, asyncJobId: asyncJobId)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The GroupMembersRemoveArg struct
    public class GroupMembersRemoveArg: Team.IncludeMembersArg {
        /// Group from which users will be removed.
        public let group: Team.GroupSelector
        /// List of users to be removed from the group.
        public let users: Array<Team.UserSelectorArg>
        public init(group: Team.GroupSelector, users: Array<Team.UserSelectorArg>, returnMembers: Bool = true) {
            self.group = group
            self.users = users
            super.init(returnMembers: returnMembers)
        }
        public override var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GroupMembersRemoveArgSerializer().serialize(self)))"
        }
    }
    public class GroupMembersRemoveArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: GroupMembersRemoveArg) -> JSON {
            let output = [ 
            "group": Team.GroupSelectorSerializer().serialize(value.group),
            "users": ArraySerializer(Team.UserSelectorArgSerializer()).serialize(value.users),
            "return_members": Serialization._BoolSerializer.serialize(value.returnMembers),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> GroupMembersRemoveArg {
            switch json {
                case .Dictionary(let dict):
                    let group = Team.GroupSelectorSerializer().deserialize(dict["group"] ?? .Null)
                    let users = ArraySerializer(Team.UserSelectorArgSerializer()).deserialize(dict["users"] ?? .Null)
                    let returnMembers = Serialization._BoolSerializer.deserialize(dict["return_members"] ?? .Null)
                    return GroupMembersRemoveArg(group: group, users: users, returnMembers: returnMembers)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Error that can be raised when GroupMembersSelector is used, and the users are required to be members of the
    /// specified group.
    public enum GroupMembersSelectorError: CustomStringConvertible {
        /// No matching group found. No groups match the specified group ID.
        case GroupNotFound
        /// An unspecified error.
        case Other
        /// At least one of the specified users is not a member of the group.
        case MemberNotInGroup

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GroupMembersSelectorErrorSerializer().serialize(self)))"
        }
    }
    public class GroupMembersSelectorErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: GroupMembersSelectorError) -> JSON {
            switch value {
                case .GroupNotFound:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("group_not_found")
                    return .Dictionary(d)
                case .Other:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
                case .MemberNotInGroup:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("member_not_in_group")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> GroupMembersSelectorError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "group_not_found":
                            return GroupMembersSelectorError.GroupNotFound
                        case "other":
                            return GroupMembersSelectorError.Other
                        case "member_not_in_group":
                            return GroupMembersSelectorError.MemberNotInGroup
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The GroupMembersRemoveError union
    public enum GroupMembersRemoveError: CustomStringConvertible {
        /// No matching group found. No groups match the specified group ID.
        case GroupNotFound
        /// An unspecified error.
        case Other
        /// At least one of the specified users is not a member of the group.
        case MemberNotInGroup
        /// Group is not in this team. You cannot remove members from a group that is outside of your team.
        case GroupNotInTeam

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GroupMembersRemoveErrorSerializer().serialize(self)))"
        }
    }
    public class GroupMembersRemoveErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: GroupMembersRemoveError) -> JSON {
            switch value {
                case .GroupNotFound:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("group_not_found")
                    return .Dictionary(d)
                case .Other:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
                case .MemberNotInGroup:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("member_not_in_group")
                    return .Dictionary(d)
                case .GroupNotInTeam:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("group_not_in_team")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> GroupMembersRemoveError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "group_not_found":
                            return GroupMembersRemoveError.GroupNotFound
                        case "other":
                            return GroupMembersRemoveError.Other
                        case "member_not_in_group":
                            return GroupMembersRemoveError.MemberNotInGroup
                        case "group_not_in_team":
                            return GroupMembersRemoveError.GroupNotInTeam
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Argument for selecting a group and a list of users.
    public class GroupMembersSelector: CustomStringConvertible {
        /// Specify a group.
        public let group: Team.GroupSelector
        /// A list of users that are members of group.
        public let users: Team.UsersSelectorArg
        public init(group: Team.GroupSelector, users: Team.UsersSelectorArg) {
            self.group = group
            self.users = users
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GroupMembersSelectorSerializer().serialize(self)))"
        }
    }
    public class GroupMembersSelectorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: GroupMembersSelector) -> JSON {
            let output = [ 
            "group": Team.GroupSelectorSerializer().serialize(value.group),
            "users": Team.UsersSelectorArgSerializer().serialize(value.users),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> GroupMembersSelector {
            switch json {
                case .Dictionary(let dict):
                    let group = Team.GroupSelectorSerializer().deserialize(dict["group"] ?? .Null)
                    let users = Team.UsersSelectorArgSerializer().deserialize(dict["users"] ?? .Null)
                    return GroupMembersSelector(group: group, users: users)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The GroupMembersSetAccessTypeArg struct
    public class GroupMembersSetAccessTypeArg: Team.GroupMemberSelector {
        /// New group access type the user will have.
        public let accessType: Team.GroupAccessType
        /// Whether to return the list of members in the group.  Note that the default value will cause all the group
        /// members  to be returned in the response. This may take a long time for large groups.
        public let returnMembers: Bool
        public init(group: Team.GroupSelector, user: Team.UserSelectorArg, accessType: Team.GroupAccessType, returnMembers: Bool = true) {
            self.accessType = accessType
            self.returnMembers = returnMembers
            super.init(group: group, user: user)
        }
        public override var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GroupMembersSetAccessTypeArgSerializer().serialize(self)))"
        }
    }
    public class GroupMembersSetAccessTypeArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: GroupMembersSetAccessTypeArg) -> JSON {
            let output = [ 
            "group": Team.GroupSelectorSerializer().serialize(value.group),
            "user": Team.UserSelectorArgSerializer().serialize(value.user),
            "access_type": Team.GroupAccessTypeSerializer().serialize(value.accessType),
            "return_members": Serialization._BoolSerializer.serialize(value.returnMembers),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> GroupMembersSetAccessTypeArg {
            switch json {
                case .Dictionary(let dict):
                    let group = Team.GroupSelectorSerializer().deserialize(dict["group"] ?? .Null)
                    let user = Team.UserSelectorArgSerializer().deserialize(dict["user"] ?? .Null)
                    let accessType = Team.GroupAccessTypeSerializer().deserialize(dict["access_type"] ?? .Null)
                    let returnMembers = Serialization._BoolSerializer.deserialize(dict["return_members"] ?? .Null)
                    return GroupMembersSetAccessTypeArg(group: group, user: user, accessType: accessType, returnMembers: returnMembers)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Argument for selecting a single group, either by group_id or by external group ID.
    public enum GroupSelector: CustomStringConvertible {
        /// Group ID.
        case GroupId(String)
        /// External ID of the group.
        case GroupExternalId(String)

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GroupSelectorSerializer().serialize(self)))"
        }
    }
    public class GroupSelectorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: GroupSelector) -> JSON {
            switch value {
                case .GroupId(let arg):
                    var d = ["group_id": Serialization._StringSerializer.serialize(arg)]
                    d[".tag"] = .Str("group_id")
                    return .Dictionary(d)
                case .GroupExternalId(let arg):
                    var d = ["group_external_id": Serialization._StringSerializer.serialize(arg)]
                    d[".tag"] = .Str("group_external_id")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> GroupSelector {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "group_id":
                            let v = Serialization._StringSerializer.deserialize(d["group_id"] ?? .Null)
                            return GroupSelector.GroupId(v)
                        case "group_external_id":
                            let v = Serialization._StringSerializer.deserialize(d["group_external_id"] ?? .Null)
                            return GroupSelector.GroupExternalId(v)
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The GroupUpdateArgs struct
    public class GroupUpdateArgs: Team.IncludeMembersArg {
        /// Specify a group.
        public let group: Team.GroupSelector
        /// Optional argument. Set group name to this if provided.
        public let newGroupName: String?
        /// Optional argument. New group external ID. If the argument is None, the group's external_id won't be updated.
        /// If the argument is empty string, the group's external id will be cleared.
        public let newGroupExternalId: String?
        /// Set new group management type, if provided.
        public let newGroupManagementType: TeamCommon.GroupManagementType?
        public init(group: Team.GroupSelector, returnMembers: Bool = true, newGroupName: String? = nil, newGroupExternalId: String? = nil, newGroupManagementType: TeamCommon.GroupManagementType? = nil) {
            self.group = group
            nullableValidator(stringValidator())(newGroupName)
            self.newGroupName = newGroupName
            nullableValidator(stringValidator())(newGroupExternalId)
            self.newGroupExternalId = newGroupExternalId
            self.newGroupManagementType = newGroupManagementType
            super.init(returnMembers: returnMembers)
        }
        public override var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GroupUpdateArgsSerializer().serialize(self)))"
        }
    }
    public class GroupUpdateArgsSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: GroupUpdateArgs) -> JSON {
            let output = [ 
            "group": Team.GroupSelectorSerializer().serialize(value.group),
            "return_members": Serialization._BoolSerializer.serialize(value.returnMembers),
            "new_group_name": NullableSerializer(Serialization._StringSerializer).serialize(value.newGroupName),
            "new_group_external_id": NullableSerializer(Serialization._StringSerializer).serialize(value.newGroupExternalId),
            "new_group_management_type": NullableSerializer(TeamCommon.GroupManagementTypeSerializer()).serialize(value.newGroupManagementType),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> GroupUpdateArgs {
            switch json {
                case .Dictionary(let dict):
                    let group = Team.GroupSelectorSerializer().deserialize(dict["group"] ?? .Null)
                    let returnMembers = Serialization._BoolSerializer.deserialize(dict["return_members"] ?? .Null)
                    let newGroupName = NullableSerializer(Serialization._StringSerializer).deserialize(dict["new_group_name"] ?? .Null)
                    let newGroupExternalId = NullableSerializer(Serialization._StringSerializer).deserialize(dict["new_group_external_id"] ?? .Null)
                    let newGroupManagementType = NullableSerializer(TeamCommon.GroupManagementTypeSerializer()).deserialize(dict["new_group_management_type"] ?? .Null)
                    return GroupUpdateArgs(group: group, returnMembers: returnMembers, newGroupName: newGroupName, newGroupExternalId: newGroupExternalId, newGroupManagementType: newGroupManagementType)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The GroupUpdateError union
    public enum GroupUpdateError: CustomStringConvertible {
        /// No matching group found. No groups match the specified group ID.
        case GroupNotFound
        /// An unspecified error.
        case Other
        /// The new external ID is already being used by another group.
        case ExternalIdAlreadyInUse

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GroupUpdateErrorSerializer().serialize(self)))"
        }
    }
    public class GroupUpdateErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: GroupUpdateError) -> JSON {
            switch value {
                case .GroupNotFound:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("group_not_found")
                    return .Dictionary(d)
                case .Other:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
                case .ExternalIdAlreadyInUse:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("external_id_already_in_use")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> GroupUpdateError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "group_not_found":
                            return GroupUpdateError.GroupNotFound
                        case "other":
                            return GroupUpdateError.Other
                        case "external_id_already_in_use":
                            return GroupUpdateError.ExternalIdAlreadyInUse
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The GroupsGetInfoError union
    public enum GroupsGetInfoError: CustomStringConvertible {
        /// The group is not on your team.
        case GroupNotOnTeam
        /// An unspecified error.
        case Other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GroupsGetInfoErrorSerializer().serialize(self)))"
        }
    }
    public class GroupsGetInfoErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: GroupsGetInfoError) -> JSON {
            switch value {
                case .GroupNotOnTeam:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("group_not_on_team")
                    return .Dictionary(d)
                case .Other:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> GroupsGetInfoError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "group_not_on_team":
                            return GroupsGetInfoError.GroupNotOnTeam
                        case "other":
                            return GroupsGetInfoError.Other
                        default:
                            return GroupsGetInfoError.Other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The GroupsGetInfoItem union
    public enum GroupsGetInfoItem: CustomStringConvertible {
        /// An ID that was provided as a parameter to groupsGetInfo, and did not match a corresponding group. The ID can
        /// be a group ID, or an external ID, depending on how the method was called.
        case IdNotFound(String)
        /// Info about a group.
        case GroupInfo(Team.GroupFullInfo)

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GroupsGetInfoItemSerializer().serialize(self)))"
        }
    }
    public class GroupsGetInfoItemSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: GroupsGetInfoItem) -> JSON {
            switch value {
                case .IdNotFound(let arg):
                    var d = ["id_not_found": Serialization._StringSerializer.serialize(arg)]
                    d[".tag"] = .Str("id_not_found")
                    return .Dictionary(d)
                case .GroupInfo(let arg):
                    var d = Serialization.getFields(Team.GroupFullInfoSerializer().serialize(arg))
                    d[".tag"] = .Str("group_info")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> GroupsGetInfoItem {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "id_not_found":
                            let v = Serialization._StringSerializer.deserialize(d["id_not_found"] ?? .Null)
                            return GroupsGetInfoItem.IdNotFound(v)
                        case "group_info":
                            let v = Team.GroupFullInfoSerializer().deserialize(json)
                            return GroupsGetInfoItem.GroupInfo(v)
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The GroupsListArg struct
    public class GroupsListArg: CustomStringConvertible {
        /// Number of results to return per call.
        public let limit: UInt32
        public init(limit: UInt32 = 1000) {
            comparableValidator(minValue: 1, maxValue: 1000)(limit)
            self.limit = limit
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GroupsListArgSerializer().serialize(self)))"
        }
    }
    public class GroupsListArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: GroupsListArg) -> JSON {
            let output = [ 
            "limit": Serialization._UInt32Serializer.serialize(value.limit),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> GroupsListArg {
            switch json {
                case .Dictionary(let dict):
                    let limit = Serialization._UInt32Serializer.deserialize(dict["limit"] ?? .Null)
                    return GroupsListArg(limit: limit)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The GroupsListContinueArg struct
    public class GroupsListContinueArg: CustomStringConvertible {
        /// Indicates from what point to get the next set of groups.
        public let cursor: String
        public init(cursor: String) {
            stringValidator()(cursor)
            self.cursor = cursor
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GroupsListContinueArgSerializer().serialize(self)))"
        }
    }
    public class GroupsListContinueArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: GroupsListContinueArg) -> JSON {
            let output = [ 
            "cursor": Serialization._StringSerializer.serialize(value.cursor),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> GroupsListContinueArg {
            switch json {
                case .Dictionary(let dict):
                    let cursor = Serialization._StringSerializer.deserialize(dict["cursor"] ?? .Null)
                    return GroupsListContinueArg(cursor: cursor)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The GroupsListContinueError union
    public enum GroupsListContinueError: CustomStringConvertible {
        /// The cursor is invalid.
        case InvalidCursor
        /// An unspecified error.
        case Other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GroupsListContinueErrorSerializer().serialize(self)))"
        }
    }
    public class GroupsListContinueErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: GroupsListContinueError) -> JSON {
            switch value {
                case .InvalidCursor:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("invalid_cursor")
                    return .Dictionary(d)
                case .Other:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> GroupsListContinueError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "invalid_cursor":
                            return GroupsListContinueError.InvalidCursor
                        case "other":
                            return GroupsListContinueError.Other
                        default:
                            return GroupsListContinueError.Other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The GroupsListResult struct
    public class GroupsListResult: CustomStringConvertible {
        /// (no description)
        public let groups: Array<TeamCommon.GroupSummary>
        /// Pass the cursor into groupsListContinue to obtain the additional groups.
        public let cursor: String
        /// Is true if there are additional groups that have not been returned yet. An additional call to
        /// groupsListContinue can retrieve them.
        public let hasMore: Bool
        public init(groups: Array<TeamCommon.GroupSummary>, cursor: String, hasMore: Bool) {
            self.groups = groups
            stringValidator()(cursor)
            self.cursor = cursor
            self.hasMore = hasMore
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GroupsListResultSerializer().serialize(self)))"
        }
    }
    public class GroupsListResultSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: GroupsListResult) -> JSON {
            let output = [ 
            "groups": ArraySerializer(TeamCommon.GroupSummarySerializer()).serialize(value.groups),
            "cursor": Serialization._StringSerializer.serialize(value.cursor),
            "has_more": Serialization._BoolSerializer.serialize(value.hasMore),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> GroupsListResult {
            switch json {
                case .Dictionary(let dict):
                    let groups = ArraySerializer(TeamCommon.GroupSummarySerializer()).deserialize(dict["groups"] ?? .Null)
                    let cursor = Serialization._StringSerializer.deserialize(dict["cursor"] ?? .Null)
                    let hasMore = Serialization._BoolSerializer.deserialize(dict["has_more"] ?? .Null)
                    return GroupsListResult(groups: groups, cursor: cursor, hasMore: hasMore)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The GroupsMembersListArg struct
    public class GroupsMembersListArg: CustomStringConvertible {
        /// The group whose members are to be listed.
        public let group: Team.GroupSelector
        /// Number of results to return per call.
        public let limit: UInt32
        public init(group: Team.GroupSelector, limit: UInt32 = 1000) {
            self.group = group
            comparableValidator(minValue: 1, maxValue: 1000)(limit)
            self.limit = limit
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GroupsMembersListArgSerializer().serialize(self)))"
        }
    }
    public class GroupsMembersListArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: GroupsMembersListArg) -> JSON {
            let output = [ 
            "group": Team.GroupSelectorSerializer().serialize(value.group),
            "limit": Serialization._UInt32Serializer.serialize(value.limit),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> GroupsMembersListArg {
            switch json {
                case .Dictionary(let dict):
                    let group = Team.GroupSelectorSerializer().deserialize(dict["group"] ?? .Null)
                    let limit = Serialization._UInt32Serializer.deserialize(dict["limit"] ?? .Null)
                    return GroupsMembersListArg(group: group, limit: limit)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The GroupsMembersListContinueArg struct
    public class GroupsMembersListContinueArg: CustomStringConvertible {
        /// Indicates from what point to get the next set of groups.
        public let cursor: String
        public init(cursor: String) {
            stringValidator()(cursor)
            self.cursor = cursor
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GroupsMembersListContinueArgSerializer().serialize(self)))"
        }
    }
    public class GroupsMembersListContinueArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: GroupsMembersListContinueArg) -> JSON {
            let output = [ 
            "cursor": Serialization._StringSerializer.serialize(value.cursor),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> GroupsMembersListContinueArg {
            switch json {
                case .Dictionary(let dict):
                    let cursor = Serialization._StringSerializer.deserialize(dict["cursor"] ?? .Null)
                    return GroupsMembersListContinueArg(cursor: cursor)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The GroupsMembersListContinueError union
    public enum GroupsMembersListContinueError: CustomStringConvertible {
        /// The cursor is invalid.
        case InvalidCursor
        /// An unspecified error.
        case Other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GroupsMembersListContinueErrorSerializer().serialize(self)))"
        }
    }
    public class GroupsMembersListContinueErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: GroupsMembersListContinueError) -> JSON {
            switch value {
                case .InvalidCursor:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("invalid_cursor")
                    return .Dictionary(d)
                case .Other:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> GroupsMembersListContinueError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "invalid_cursor":
                            return GroupsMembersListContinueError.InvalidCursor
                        case "other":
                            return GroupsMembersListContinueError.Other
                        default:
                            return GroupsMembersListContinueError.Other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The GroupsMembersListResult struct
    public class GroupsMembersListResult: CustomStringConvertible {
        /// (no description)
        public let members: Array<Team.GroupMemberInfo>
        /// Pass the cursor into groupsMembersListContinue to obtain additional group members.
        public let cursor: String
        /// Is true if there are additional group members that have not been returned yet. An additional call to
        /// groupsMembersListContinue can retrieve them.
        public let hasMore: Bool
        public init(members: Array<Team.GroupMemberInfo>, cursor: String, hasMore: Bool) {
            self.members = members
            stringValidator()(cursor)
            self.cursor = cursor
            self.hasMore = hasMore
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GroupsMembersListResultSerializer().serialize(self)))"
        }
    }
    public class GroupsMembersListResultSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: GroupsMembersListResult) -> JSON {
            let output = [ 
            "members": ArraySerializer(Team.GroupMemberInfoSerializer()).serialize(value.members),
            "cursor": Serialization._StringSerializer.serialize(value.cursor),
            "has_more": Serialization._BoolSerializer.serialize(value.hasMore),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> GroupsMembersListResult {
            switch json {
                case .Dictionary(let dict):
                    let members = ArraySerializer(Team.GroupMemberInfoSerializer()).deserialize(dict["members"] ?? .Null)
                    let cursor = Serialization._StringSerializer.deserialize(dict["cursor"] ?? .Null)
                    let hasMore = Serialization._BoolSerializer.deserialize(dict["has_more"] ?? .Null)
                    return GroupsMembersListResult(members: members, cursor: cursor, hasMore: hasMore)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The GroupsPollError union
    public enum GroupsPollError: CustomStringConvertible {
        /// The job ID is invalid.
        case InvalidAsyncJobId
        /// Something went wrong with the job on Dropbox's end. You'll need to verify that the action you were taking
        /// succeeded, and if not, try again. This should happen very rarely.
        case InternalError
        /// An unspecified error.
        case Other
        /// You are not allowed to poll this job.
        case AccessDenied

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GroupsPollErrorSerializer().serialize(self)))"
        }
    }
    public class GroupsPollErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: GroupsPollError) -> JSON {
            switch value {
                case .InvalidAsyncJobId:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("invalid_async_job_id")
                    return .Dictionary(d)
                case .InternalError:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("internal_error")
                    return .Dictionary(d)
                case .Other:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
                case .AccessDenied:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("access_denied")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> GroupsPollError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "invalid_async_job_id":
                            return GroupsPollError.InvalidAsyncJobId
                        case "internal_error":
                            return GroupsPollError.InternalError
                        case "other":
                            return GroupsPollError.Other
                        case "access_denied":
                            return GroupsPollError.AccessDenied
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Argument for selecting a list of groups, either by group_ids, or external group IDs.
    public enum GroupsSelector: CustomStringConvertible {
        /// List of group IDs.
        case GroupIds(Array<String>)
        /// List of external IDs of groups.
        case GroupExternalIds(Array<String>)

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GroupsSelectorSerializer().serialize(self)))"
        }
    }
    public class GroupsSelectorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: GroupsSelector) -> JSON {
            switch value {
                case .GroupIds(let arg):
                    var d = ["group_ids": ArraySerializer(Serialization._StringSerializer).serialize(arg)]
                    d[".tag"] = .Str("group_ids")
                    return .Dictionary(d)
                case .GroupExternalIds(let arg):
                    var d = ["group_external_ids": ArraySerializer(Serialization._StringSerializer).serialize(arg)]
                    d[".tag"] = .Str("group_external_ids")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> GroupsSelector {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "group_ids":
                            let v = ArraySerializer(Serialization._StringSerializer).deserialize(d["group_ids"] ?? .Null)
                            return GroupsSelector.GroupIds(v)
                        case "group_external_ids":
                            let v = ArraySerializer(Serialization._StringSerializer).deserialize(d["group_external_ids"] ?? .Null)
                            return GroupsSelector.GroupExternalIds(v)
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The ListMemberAppsArg struct
    public class ListMemberAppsArg: CustomStringConvertible {
        /// The team member id
        public let teamMemberId: String
        public init(teamMemberId: String) {
            stringValidator()(teamMemberId)
            self.teamMemberId = teamMemberId
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListMemberAppsArgSerializer().serialize(self)))"
        }
    }
    public class ListMemberAppsArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: ListMemberAppsArg) -> JSON {
            let output = [ 
            "team_member_id": Serialization._StringSerializer.serialize(value.teamMemberId),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> ListMemberAppsArg {
            switch json {
                case .Dictionary(let dict):
                    let teamMemberId = Serialization._StringSerializer.deserialize(dict["team_member_id"] ?? .Null)
                    return ListMemberAppsArg(teamMemberId: teamMemberId)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Error returned by linkedAppsListMemberLinkedApps.
    public enum ListMemberAppsError: CustomStringConvertible {
        /// Member not found.
        case MemberNotFound
        /// An unspecified error.
        case Other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListMemberAppsErrorSerializer().serialize(self)))"
        }
    }
    public class ListMemberAppsErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: ListMemberAppsError) -> JSON {
            switch value {
                case .MemberNotFound:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("member_not_found")
                    return .Dictionary(d)
                case .Other:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> ListMemberAppsError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "member_not_found":
                            return ListMemberAppsError.MemberNotFound
                        case "other":
                            return ListMemberAppsError.Other
                        default:
                            return ListMemberAppsError.Other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The ListMemberAppsResult struct
    public class ListMemberAppsResult: CustomStringConvertible {
        /// List of third party applications linked by this team member
        public let linkedApiApps: Array<Team.ApiApp>
        public init(linkedApiApps: Array<Team.ApiApp>) {
            self.linkedApiApps = linkedApiApps
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListMemberAppsResultSerializer().serialize(self)))"
        }
    }
    public class ListMemberAppsResultSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: ListMemberAppsResult) -> JSON {
            let output = [ 
            "linked_api_apps": ArraySerializer(Team.ApiAppSerializer()).serialize(value.linkedApiApps),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> ListMemberAppsResult {
            switch json {
                case .Dictionary(let dict):
                    let linkedApiApps = ArraySerializer(Team.ApiAppSerializer()).deserialize(dict["linked_api_apps"] ?? .Null)
                    return ListMemberAppsResult(linkedApiApps: linkedApiApps)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The ListMemberDevicesArg struct
    public class ListMemberDevicesArg: CustomStringConvertible {
        /// The team's member id
        public let teamMemberId: String
        /// Whether to list web sessions of the team's member
        public let includeWebSessions: Bool
        /// Whether to list linked desktop devices of the team's member
        public let includeDesktopClients: Bool
        /// Whether to list linked mobile devices of the team's member
        public let includeMobileClients: Bool
        public init(teamMemberId: String, includeWebSessions: Bool = true, includeDesktopClients: Bool = true, includeMobileClients: Bool = true) {
            stringValidator()(teamMemberId)
            self.teamMemberId = teamMemberId
            self.includeWebSessions = includeWebSessions
            self.includeDesktopClients = includeDesktopClients
            self.includeMobileClients = includeMobileClients
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListMemberDevicesArgSerializer().serialize(self)))"
        }
    }
    public class ListMemberDevicesArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: ListMemberDevicesArg) -> JSON {
            let output = [ 
            "team_member_id": Serialization._StringSerializer.serialize(value.teamMemberId),
            "include_web_sessions": Serialization._BoolSerializer.serialize(value.includeWebSessions),
            "include_desktop_clients": Serialization._BoolSerializer.serialize(value.includeDesktopClients),
            "include_mobile_clients": Serialization._BoolSerializer.serialize(value.includeMobileClients),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> ListMemberDevicesArg {
            switch json {
                case .Dictionary(let dict):
                    let teamMemberId = Serialization._StringSerializer.deserialize(dict["team_member_id"] ?? .Null)
                    let includeWebSessions = Serialization._BoolSerializer.deserialize(dict["include_web_sessions"] ?? .Null)
                    let includeDesktopClients = Serialization._BoolSerializer.deserialize(dict["include_desktop_clients"] ?? .Null)
                    let includeMobileClients = Serialization._BoolSerializer.deserialize(dict["include_mobile_clients"] ?? .Null)
                    return ListMemberDevicesArg(teamMemberId: teamMemberId, includeWebSessions: includeWebSessions, includeDesktopClients: includeDesktopClients, includeMobileClients: includeMobileClients)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The ListMemberDevicesError union
    public enum ListMemberDevicesError: CustomStringConvertible {
        /// Member not found.
        case MemberNotFound
        /// An unspecified error.
        case Other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListMemberDevicesErrorSerializer().serialize(self)))"
        }
    }
    public class ListMemberDevicesErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: ListMemberDevicesError) -> JSON {
            switch value {
                case .MemberNotFound:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("member_not_found")
                    return .Dictionary(d)
                case .Other:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> ListMemberDevicesError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "member_not_found":
                            return ListMemberDevicesError.MemberNotFound
                        case "other":
                            return ListMemberDevicesError.Other
                        default:
                            return ListMemberDevicesError.Other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The ListMemberDevicesResult struct
    public class ListMemberDevicesResult: CustomStringConvertible {
        /// List of web sessions made by this team member
        public let activeWebSessions: Array<Team.ActiveWebSession>?
        /// List of desktop clients used by this team member
        public let desktopClientSessions: Array<Team.DesktopClientSession>?
        /// List of mobile client used by this team member
        public let mobileClientSessions: Array<Team.MobileClientSession>?
        public init(activeWebSessions: Array<Team.ActiveWebSession>? = nil, desktopClientSessions: Array<Team.DesktopClientSession>? = nil, mobileClientSessions: Array<Team.MobileClientSession>? = nil) {
            self.activeWebSessions = activeWebSessions
            self.desktopClientSessions = desktopClientSessions
            self.mobileClientSessions = mobileClientSessions
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListMemberDevicesResultSerializer().serialize(self)))"
        }
    }
    public class ListMemberDevicesResultSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: ListMemberDevicesResult) -> JSON {
            let output = [ 
            "active_web_sessions": NullableSerializer(ArraySerializer(Team.ActiveWebSessionSerializer())).serialize(value.activeWebSessions),
            "desktop_client_sessions": NullableSerializer(ArraySerializer(Team.DesktopClientSessionSerializer())).serialize(value.desktopClientSessions),
            "mobile_client_sessions": NullableSerializer(ArraySerializer(Team.MobileClientSessionSerializer())).serialize(value.mobileClientSessions),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> ListMemberDevicesResult {
            switch json {
                case .Dictionary(let dict):
                    let activeWebSessions = NullableSerializer(ArraySerializer(Team.ActiveWebSessionSerializer())).deserialize(dict["active_web_sessions"] ?? .Null)
                    let desktopClientSessions = NullableSerializer(ArraySerializer(Team.DesktopClientSessionSerializer())).deserialize(dict["desktop_client_sessions"] ?? .Null)
                    let mobileClientSessions = NullableSerializer(ArraySerializer(Team.MobileClientSessionSerializer())).deserialize(dict["mobile_client_sessions"] ?? .Null)
                    return ListMemberDevicesResult(activeWebSessions: activeWebSessions, desktopClientSessions: desktopClientSessions, mobileClientSessions: mobileClientSessions)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Arguments for linkedAppsListMembersLinkedApps.
    public class ListMembersAppsArg: CustomStringConvertible {
        /// At the first call to the linkedAppsListMembersLinkedApps the cursor shouldn't be passed. Then, if the result
        /// of the call includes a cursor, the following requests should include the received cursors in order to
        /// receive the next sub list of the team applications
        public let cursor: String?
        public init(cursor: String? = nil) {
            nullableValidator(stringValidator())(cursor)
            self.cursor = cursor
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListMembersAppsArgSerializer().serialize(self)))"
        }
    }
    public class ListMembersAppsArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: ListMembersAppsArg) -> JSON {
            let output = [ 
            "cursor": NullableSerializer(Serialization._StringSerializer).serialize(value.cursor),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> ListMembersAppsArg {
            switch json {
                case .Dictionary(let dict):
                    let cursor = NullableSerializer(Serialization._StringSerializer).deserialize(dict["cursor"] ?? .Null)
                    return ListMembersAppsArg(cursor: cursor)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Error returned by linkedAppsListMembersLinkedApps
    public enum ListMembersAppsError: CustomStringConvertible {
        /// Indicates that the cursor has been invalidated. Call linkedAppsListMembersLinkedApps again with an empty
        /// cursor to obtain a new cursor.
        case Reset
        /// An unspecified error.
        case Other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListMembersAppsErrorSerializer().serialize(self)))"
        }
    }
    public class ListMembersAppsErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: ListMembersAppsError) -> JSON {
            switch value {
                case .Reset:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("reset")
                    return .Dictionary(d)
                case .Other:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> ListMembersAppsError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "reset":
                            return ListMembersAppsError.Reset
                        case "other":
                            return ListMembersAppsError.Other
                        default:
                            return ListMembersAppsError.Other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Information returned by linkedAppsListMembersLinkedApps.
    public class ListMembersAppsResult: CustomStringConvertible {
        /// The linked applications of each member of the team
        public let apps: Array<Team.MemberLinkedApps>
        /// If true, then there are more apps available. Pass the cursor to linkedAppsListMembersLinkedApps to retrieve
        /// the rest.
        public let hasMore: Bool
        /// Pass the cursor into linkedAppsListMembersLinkedApps to receive the next sub list of team's applications.
        public let cursor: String?
        public init(apps: Array<Team.MemberLinkedApps>, hasMore: Bool, cursor: String? = nil) {
            self.apps = apps
            self.hasMore = hasMore
            nullableValidator(stringValidator())(cursor)
            self.cursor = cursor
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListMembersAppsResultSerializer().serialize(self)))"
        }
    }
    public class ListMembersAppsResultSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: ListMembersAppsResult) -> JSON {
            let output = [ 
            "apps": ArraySerializer(Team.MemberLinkedAppsSerializer()).serialize(value.apps),
            "has_more": Serialization._BoolSerializer.serialize(value.hasMore),
            "cursor": NullableSerializer(Serialization._StringSerializer).serialize(value.cursor),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> ListMembersAppsResult {
            switch json {
                case .Dictionary(let dict):
                    let apps = ArraySerializer(Team.MemberLinkedAppsSerializer()).deserialize(dict["apps"] ?? .Null)
                    let hasMore = Serialization._BoolSerializer.deserialize(dict["has_more"] ?? .Null)
                    let cursor = NullableSerializer(Serialization._StringSerializer).deserialize(dict["cursor"] ?? .Null)
                    return ListMembersAppsResult(apps: apps, hasMore: hasMore, cursor: cursor)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The ListMembersDevicesArg struct
    public class ListMembersDevicesArg: CustomStringConvertible {
        /// At the first call to the devicesListMembersDevices the cursor shouldn't be passed. Then, if the result of
        /// the call includes a cursor, the following requests should include the received cursors in order to receive
        /// the next sub list of team devices
        public let cursor: String?
        /// Whether to list web sessions of the team members
        public let includeWebSessions: Bool
        /// Whether to list desktop clients of the team members
        public let includeDesktopClients: Bool
        /// Whether to list mobile clients of the team members
        public let includeMobileClients: Bool
        public init(cursor: String? = nil, includeWebSessions: Bool = true, includeDesktopClients: Bool = true, includeMobileClients: Bool = true) {
            nullableValidator(stringValidator())(cursor)
            self.cursor = cursor
            self.includeWebSessions = includeWebSessions
            self.includeDesktopClients = includeDesktopClients
            self.includeMobileClients = includeMobileClients
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListMembersDevicesArgSerializer().serialize(self)))"
        }
    }
    public class ListMembersDevicesArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: ListMembersDevicesArg) -> JSON {
            let output = [ 
            "cursor": NullableSerializer(Serialization._StringSerializer).serialize(value.cursor),
            "include_web_sessions": Serialization._BoolSerializer.serialize(value.includeWebSessions),
            "include_desktop_clients": Serialization._BoolSerializer.serialize(value.includeDesktopClients),
            "include_mobile_clients": Serialization._BoolSerializer.serialize(value.includeMobileClients),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> ListMembersDevicesArg {
            switch json {
                case .Dictionary(let dict):
                    let cursor = NullableSerializer(Serialization._StringSerializer).deserialize(dict["cursor"] ?? .Null)
                    let includeWebSessions = Serialization._BoolSerializer.deserialize(dict["include_web_sessions"] ?? .Null)
                    let includeDesktopClients = Serialization._BoolSerializer.deserialize(dict["include_desktop_clients"] ?? .Null)
                    let includeMobileClients = Serialization._BoolSerializer.deserialize(dict["include_mobile_clients"] ?? .Null)
                    return ListMembersDevicesArg(cursor: cursor, includeWebSessions: includeWebSessions, includeDesktopClients: includeDesktopClients, includeMobileClients: includeMobileClients)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The ListMembersDevicesError union
    public enum ListMembersDevicesError: CustomStringConvertible {
        /// Indicates that the cursor has been invalidated. Call devicesListMembersDevices again with an empty cursor to
        /// obtain a new cursor.
        case Reset
        /// An unspecified error.
        case Other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListMembersDevicesErrorSerializer().serialize(self)))"
        }
    }
    public class ListMembersDevicesErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: ListMembersDevicesError) -> JSON {
            switch value {
                case .Reset:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("reset")
                    return .Dictionary(d)
                case .Other:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> ListMembersDevicesError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "reset":
                            return ListMembersDevicesError.Reset
                        case "other":
                            return ListMembersDevicesError.Other
                        default:
                            return ListMembersDevicesError.Other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The ListMembersDevicesResult struct
    public class ListMembersDevicesResult: CustomStringConvertible {
        /// The devices of each member of the team
        public let devices: Array<Team.MemberDevices>
        /// If true, then there are more devices available. Pass the cursor to devicesListMembersDevices to retrieve the
        /// rest.
        public let hasMore: Bool
        /// Pass the cursor into devicesListMembersDevices to receive the next sub list of team's devices.
        public let cursor: String?
        public init(devices: Array<Team.MemberDevices>, hasMore: Bool, cursor: String? = nil) {
            self.devices = devices
            self.hasMore = hasMore
            nullableValidator(stringValidator())(cursor)
            self.cursor = cursor
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListMembersDevicesResultSerializer().serialize(self)))"
        }
    }
    public class ListMembersDevicesResultSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: ListMembersDevicesResult) -> JSON {
            let output = [ 
            "devices": ArraySerializer(Team.MemberDevicesSerializer()).serialize(value.devices),
            "has_more": Serialization._BoolSerializer.serialize(value.hasMore),
            "cursor": NullableSerializer(Serialization._StringSerializer).serialize(value.cursor),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> ListMembersDevicesResult {
            switch json {
                case .Dictionary(let dict):
                    let devices = ArraySerializer(Team.MemberDevicesSerializer()).deserialize(dict["devices"] ?? .Null)
                    let hasMore = Serialization._BoolSerializer.deserialize(dict["has_more"] ?? .Null)
                    let cursor = NullableSerializer(Serialization._StringSerializer).deserialize(dict["cursor"] ?? .Null)
                    return ListMembersDevicesResult(devices: devices, hasMore: hasMore, cursor: cursor)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Arguments for linkedAppsListTeamLinkedApps.
    public class ListTeamAppsArg: CustomStringConvertible {
        /// At the first call to the linkedAppsListTeamLinkedApps the cursor shouldn't be passed. Then, if the result of
        /// the call includes a cursor, the following requests should include the received cursors in order to receive
        /// the next sub list of the team applications
        public let cursor: String?
        public init(cursor: String? = nil) {
            nullableValidator(stringValidator())(cursor)
            self.cursor = cursor
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListTeamAppsArgSerializer().serialize(self)))"
        }
    }
    public class ListTeamAppsArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: ListTeamAppsArg) -> JSON {
            let output = [ 
            "cursor": NullableSerializer(Serialization._StringSerializer).serialize(value.cursor),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> ListTeamAppsArg {
            switch json {
                case .Dictionary(let dict):
                    let cursor = NullableSerializer(Serialization._StringSerializer).deserialize(dict["cursor"] ?? .Null)
                    return ListTeamAppsArg(cursor: cursor)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Error returned by linkedAppsListTeamLinkedApps
    public enum ListTeamAppsError: CustomStringConvertible {
        /// Indicates that the cursor has been invalidated. Call linkedAppsListTeamLinkedApps again with an empty cursor
        /// to obtain a new cursor.
        case Reset
        /// An unspecified error.
        case Other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListTeamAppsErrorSerializer().serialize(self)))"
        }
    }
    public class ListTeamAppsErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: ListTeamAppsError) -> JSON {
            switch value {
                case .Reset:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("reset")
                    return .Dictionary(d)
                case .Other:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> ListTeamAppsError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "reset":
                            return ListTeamAppsError.Reset
                        case "other":
                            return ListTeamAppsError.Other
                        default:
                            return ListTeamAppsError.Other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Information returned by linkedAppsListTeamLinkedApps.
    public class ListTeamAppsResult: CustomStringConvertible {
        /// The linked applications of each member of the team
        public let apps: Array<Team.MemberLinkedApps>
        /// If true, then there are more apps available. Pass the cursor to linkedAppsListTeamLinkedApps to retrieve the
        /// rest.
        public let hasMore: Bool
        /// Pass the cursor into linkedAppsListTeamLinkedApps to receive the next sub list of team's applications.
        public let cursor: String?
        public init(apps: Array<Team.MemberLinkedApps>, hasMore: Bool, cursor: String? = nil) {
            self.apps = apps
            self.hasMore = hasMore
            nullableValidator(stringValidator())(cursor)
            self.cursor = cursor
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListTeamAppsResultSerializer().serialize(self)))"
        }
    }
    public class ListTeamAppsResultSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: ListTeamAppsResult) -> JSON {
            let output = [ 
            "apps": ArraySerializer(Team.MemberLinkedAppsSerializer()).serialize(value.apps),
            "has_more": Serialization._BoolSerializer.serialize(value.hasMore),
            "cursor": NullableSerializer(Serialization._StringSerializer).serialize(value.cursor),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> ListTeamAppsResult {
            switch json {
                case .Dictionary(let dict):
                    let apps = ArraySerializer(Team.MemberLinkedAppsSerializer()).deserialize(dict["apps"] ?? .Null)
                    let hasMore = Serialization._BoolSerializer.deserialize(dict["has_more"] ?? .Null)
                    let cursor = NullableSerializer(Serialization._StringSerializer).deserialize(dict["cursor"] ?? .Null)
                    return ListTeamAppsResult(apps: apps, hasMore: hasMore, cursor: cursor)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The ListTeamDevicesArg struct
    public class ListTeamDevicesArg: CustomStringConvertible {
        /// At the first call to the devicesListTeamDevices the cursor shouldn't be passed. Then, if the result of the
        /// call includes a cursor, the following requests should include the received cursors in order to receive the
        /// next sub list of team devices
        public let cursor: String?
        /// Whether to list web sessions of the team members
        public let includeWebSessions: Bool
        /// Whether to list desktop clients of the team members
        public let includeDesktopClients: Bool
        /// Whether to list mobile clients of the team members
        public let includeMobileClients: Bool
        public init(cursor: String? = nil, includeWebSessions: Bool = true, includeDesktopClients: Bool = true, includeMobileClients: Bool = true) {
            nullableValidator(stringValidator())(cursor)
            self.cursor = cursor
            self.includeWebSessions = includeWebSessions
            self.includeDesktopClients = includeDesktopClients
            self.includeMobileClients = includeMobileClients
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListTeamDevicesArgSerializer().serialize(self)))"
        }
    }
    public class ListTeamDevicesArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: ListTeamDevicesArg) -> JSON {
            let output = [ 
            "cursor": NullableSerializer(Serialization._StringSerializer).serialize(value.cursor),
            "include_web_sessions": Serialization._BoolSerializer.serialize(value.includeWebSessions),
            "include_desktop_clients": Serialization._BoolSerializer.serialize(value.includeDesktopClients),
            "include_mobile_clients": Serialization._BoolSerializer.serialize(value.includeMobileClients),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> ListTeamDevicesArg {
            switch json {
                case .Dictionary(let dict):
                    let cursor = NullableSerializer(Serialization._StringSerializer).deserialize(dict["cursor"] ?? .Null)
                    let includeWebSessions = Serialization._BoolSerializer.deserialize(dict["include_web_sessions"] ?? .Null)
                    let includeDesktopClients = Serialization._BoolSerializer.deserialize(dict["include_desktop_clients"] ?? .Null)
                    let includeMobileClients = Serialization._BoolSerializer.deserialize(dict["include_mobile_clients"] ?? .Null)
                    return ListTeamDevicesArg(cursor: cursor, includeWebSessions: includeWebSessions, includeDesktopClients: includeDesktopClients, includeMobileClients: includeMobileClients)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The ListTeamDevicesError union
    public enum ListTeamDevicesError: CustomStringConvertible {
        /// Indicates that the cursor has been invalidated. Call devicesListTeamDevices again with an empty cursor to
        /// obtain a new cursor.
        case Reset
        /// An unspecified error.
        case Other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListTeamDevicesErrorSerializer().serialize(self)))"
        }
    }
    public class ListTeamDevicesErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: ListTeamDevicesError) -> JSON {
            switch value {
                case .Reset:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("reset")
                    return .Dictionary(d)
                case .Other:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> ListTeamDevicesError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "reset":
                            return ListTeamDevicesError.Reset
                        case "other":
                            return ListTeamDevicesError.Other
                        default:
                            return ListTeamDevicesError.Other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The ListTeamDevicesResult struct
    public class ListTeamDevicesResult: CustomStringConvertible {
        /// The devices of each member of the team
        public let devices: Array<Team.MemberDevices>
        /// If true, then there are more devices available. Pass the cursor to devicesListTeamDevices to retrieve the
        /// rest.
        public let hasMore: Bool
        /// Pass the cursor into devicesListTeamDevices to receive the next sub list of team's devices.
        public let cursor: String?
        public init(devices: Array<Team.MemberDevices>, hasMore: Bool, cursor: String? = nil) {
            self.devices = devices
            self.hasMore = hasMore
            nullableValidator(stringValidator())(cursor)
            self.cursor = cursor
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListTeamDevicesResultSerializer().serialize(self)))"
        }
    }
    public class ListTeamDevicesResultSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: ListTeamDevicesResult) -> JSON {
            let output = [ 
            "devices": ArraySerializer(Team.MemberDevicesSerializer()).serialize(value.devices),
            "has_more": Serialization._BoolSerializer.serialize(value.hasMore),
            "cursor": NullableSerializer(Serialization._StringSerializer).serialize(value.cursor),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> ListTeamDevicesResult {
            switch json {
                case .Dictionary(let dict):
                    let devices = ArraySerializer(Team.MemberDevicesSerializer()).deserialize(dict["devices"] ?? .Null)
                    let hasMore = Serialization._BoolSerializer.deserialize(dict["has_more"] ?? .Null)
                    let cursor = NullableSerializer(Serialization._StringSerializer).deserialize(dict["cursor"] ?? .Null)
                    return ListTeamDevicesResult(devices: devices, hasMore: hasMore, cursor: cursor)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Specify access type a member should have when joined to a group.
    public class MemberAccess: CustomStringConvertible {
        /// Identity of a user.
        public let user: Team.UserSelectorArg
        /// Access type.
        public let accessType: Team.GroupAccessType
        public init(user: Team.UserSelectorArg, accessType: Team.GroupAccessType) {
            self.user = user
            self.accessType = accessType
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MemberAccessSerializer().serialize(self)))"
        }
    }
    public class MemberAccessSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: MemberAccess) -> JSON {
            let output = [ 
            "user": Team.UserSelectorArgSerializer().serialize(value.user),
            "access_type": Team.GroupAccessTypeSerializer().serialize(value.accessType),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> MemberAccess {
            switch json {
                case .Dictionary(let dict):
                    let user = Team.UserSelectorArgSerializer().deserialize(dict["user"] ?? .Null)
                    let accessType = Team.GroupAccessTypeSerializer().deserialize(dict["access_type"] ?? .Null)
                    return MemberAccess(user: user, accessType: accessType)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The MemberAddArg struct
    public class MemberAddArg: CustomStringConvertible {
        /// (no description)
        public let memberEmail: String
        /// Member's first name.
        public let memberGivenName: String
        /// Member's last name.
        public let memberSurname: String
        /// External ID for member.
        public let memberExternalId: String?
        /// Whether to send a welcome email to the member. If send_welcome_email is false, no email invitation will be
        /// sent to the user. This may be useful for apps using single sign-on (SSO) flows for onboarding that want to
        /// handle announcements themselves.
        public let sendWelcomeEmail: Bool
        /// (no description)
        public let role: Team.AdminTier
        public init(memberEmail: String, memberGivenName: String, memberSurname: String, memberExternalId: String? = nil, sendWelcomeEmail: Bool = true, role: Team.AdminTier = .MemberOnly) {
            stringValidator(maxLength: 255, pattern: "^['&A-Za-z0-9._%+-]+@[A-Za-z0-9-][A-Za-z0-9.-]*.[A-Za-z]{2,15}$")(memberEmail)
            self.memberEmail = memberEmail
            stringValidator(minLength: 1, maxLength: 100, pattern: "[^/:?*<>\"|]*")(memberGivenName)
            self.memberGivenName = memberGivenName
            stringValidator(minLength: 1, maxLength: 100, pattern: "[^/:?*<>\"|]*")(memberSurname)
            self.memberSurname = memberSurname
            nullableValidator(stringValidator(maxLength: 64))(memberExternalId)
            self.memberExternalId = memberExternalId
            self.sendWelcomeEmail = sendWelcomeEmail
            self.role = role
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MemberAddArgSerializer().serialize(self)))"
        }
    }
    public class MemberAddArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: MemberAddArg) -> JSON {
            let output = [ 
            "member_email": Serialization._StringSerializer.serialize(value.memberEmail),
            "member_given_name": Serialization._StringSerializer.serialize(value.memberGivenName),
            "member_surname": Serialization._StringSerializer.serialize(value.memberSurname),
            "member_external_id": NullableSerializer(Serialization._StringSerializer).serialize(value.memberExternalId),
            "send_welcome_email": Serialization._BoolSerializer.serialize(value.sendWelcomeEmail),
            "role": Team.AdminTierSerializer().serialize(value.role),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> MemberAddArg {
            switch json {
                case .Dictionary(let dict):
                    let memberEmail = Serialization._StringSerializer.deserialize(dict["member_email"] ?? .Null)
                    let memberGivenName = Serialization._StringSerializer.deserialize(dict["member_given_name"] ?? .Null)
                    let memberSurname = Serialization._StringSerializer.deserialize(dict["member_surname"] ?? .Null)
                    let memberExternalId = NullableSerializer(Serialization._StringSerializer).deserialize(dict["member_external_id"] ?? .Null)
                    let sendWelcomeEmail = Serialization._BoolSerializer.deserialize(dict["send_welcome_email"] ?? .Null)
                    let role = Team.AdminTierSerializer().deserialize(dict["role"] ?? .Null)
                    return MemberAddArg(memberEmail: memberEmail, memberGivenName: memberGivenName, memberSurname: memberSurname, memberExternalId: memberExternalId, sendWelcomeEmail: sendWelcomeEmail, role: role)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Describes the result of attempting to add a single user to the team. 'success' is the only value indicating that
    /// a user was indeed added to the team - the other values explain the type of failure that occurred, and include
    /// the email of the user for which the operation has failed.
    public enum MemberAddResult: CustomStringConvertible {
        /// Describes a user that was successfully added to the team.
        case Success(Team.TeamMemberInfo)
        /// Team is already full. The organization has no available licenses.
        case TeamLicenseLimit(String)
        /// Team is already full. The free team member limit has been reached.
        case FreeTeamMemberLimitReached(String)
        /// User is already on this team. The provided email address is associated with a user who is already a member
        /// of or invited to the team.
        case UserAlreadyOnTeam(String)
        /// User is already on another team. The provided email address is associated with a user that is already a
        /// member or invited to another team.
        case UserOnAnotherTeam(String)
        /// User is already paired.
        case UserAlreadyPaired(String)
        /// User migration has failed.
        case UserMigrationFailed(String)
        /// A user with the given external member ID already exists on the team.
        case DuplicateExternalMemberId(String)
        /// User creation has failed.
        case UserCreationFailed(String)

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MemberAddResultSerializer().serialize(self)))"
        }
    }
    public class MemberAddResultSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: MemberAddResult) -> JSON {
            switch value {
                case .Success(let arg):
                    var d = Serialization.getFields(Team.TeamMemberInfoSerializer().serialize(arg))
                    d[".tag"] = .Str("success")
                    return .Dictionary(d)
                case .TeamLicenseLimit(let arg):
                    var d = ["team_license_limit": Serialization._StringSerializer.serialize(arg)]
                    d[".tag"] = .Str("team_license_limit")
                    return .Dictionary(d)
                case .FreeTeamMemberLimitReached(let arg):
                    var d = ["free_team_member_limit_reached": Serialization._StringSerializer.serialize(arg)]
                    d[".tag"] = .Str("free_team_member_limit_reached")
                    return .Dictionary(d)
                case .UserAlreadyOnTeam(let arg):
                    var d = ["user_already_on_team": Serialization._StringSerializer.serialize(arg)]
                    d[".tag"] = .Str("user_already_on_team")
                    return .Dictionary(d)
                case .UserOnAnotherTeam(let arg):
                    var d = ["user_on_another_team": Serialization._StringSerializer.serialize(arg)]
                    d[".tag"] = .Str("user_on_another_team")
                    return .Dictionary(d)
                case .UserAlreadyPaired(let arg):
                    var d = ["user_already_paired": Serialization._StringSerializer.serialize(arg)]
                    d[".tag"] = .Str("user_already_paired")
                    return .Dictionary(d)
                case .UserMigrationFailed(let arg):
                    var d = ["user_migration_failed": Serialization._StringSerializer.serialize(arg)]
                    d[".tag"] = .Str("user_migration_failed")
                    return .Dictionary(d)
                case .DuplicateExternalMemberId(let arg):
                    var d = ["duplicate_external_member_id": Serialization._StringSerializer.serialize(arg)]
                    d[".tag"] = .Str("duplicate_external_member_id")
                    return .Dictionary(d)
                case .UserCreationFailed(let arg):
                    var d = ["user_creation_failed": Serialization._StringSerializer.serialize(arg)]
                    d[".tag"] = .Str("user_creation_failed")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> MemberAddResult {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "success":
                            let v = Team.TeamMemberInfoSerializer().deserialize(json)
                            return MemberAddResult.Success(v)
                        case "team_license_limit":
                            let v = Serialization._StringSerializer.deserialize(d["team_license_limit"] ?? .Null)
                            return MemberAddResult.TeamLicenseLimit(v)
                        case "free_team_member_limit_reached":
                            let v = Serialization._StringSerializer.deserialize(d["free_team_member_limit_reached"] ?? .Null)
                            return MemberAddResult.FreeTeamMemberLimitReached(v)
                        case "user_already_on_team":
                            let v = Serialization._StringSerializer.deserialize(d["user_already_on_team"] ?? .Null)
                            return MemberAddResult.UserAlreadyOnTeam(v)
                        case "user_on_another_team":
                            let v = Serialization._StringSerializer.deserialize(d["user_on_another_team"] ?? .Null)
                            return MemberAddResult.UserOnAnotherTeam(v)
                        case "user_already_paired":
                            let v = Serialization._StringSerializer.deserialize(d["user_already_paired"] ?? .Null)
                            return MemberAddResult.UserAlreadyPaired(v)
                        case "user_migration_failed":
                            let v = Serialization._StringSerializer.deserialize(d["user_migration_failed"] ?? .Null)
                            return MemberAddResult.UserMigrationFailed(v)
                        case "duplicate_external_member_id":
                            let v = Serialization._StringSerializer.deserialize(d["duplicate_external_member_id"] ?? .Null)
                            return MemberAddResult.DuplicateExternalMemberId(v)
                        case "user_creation_failed":
                            let v = Serialization._StringSerializer.deserialize(d["user_creation_failed"] ?? .Null)
                            return MemberAddResult.UserCreationFailed(v)
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Information on devices of a team's member.
    public class MemberDevices: CustomStringConvertible {
        /// The member unique Id
        public let teamMemberId: String
        /// List of web sessions made by this team member
        public let webSessions: Array<Team.ActiveWebSession>?
        /// List of desktop clients by this team member
        public let desktopClients: Array<Team.DesktopClientSession>?
        /// List of mobile clients by this team member
        public let mobileClients: Array<Team.MobileClientSession>?
        public init(teamMemberId: String, webSessions: Array<Team.ActiveWebSession>? = nil, desktopClients: Array<Team.DesktopClientSession>? = nil, mobileClients: Array<Team.MobileClientSession>? = nil) {
            stringValidator()(teamMemberId)
            self.teamMemberId = teamMemberId
            self.webSessions = webSessions
            self.desktopClients = desktopClients
            self.mobileClients = mobileClients
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MemberDevicesSerializer().serialize(self)))"
        }
    }
    public class MemberDevicesSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: MemberDevices) -> JSON {
            let output = [ 
            "team_member_id": Serialization._StringSerializer.serialize(value.teamMemberId),
            "web_sessions": NullableSerializer(ArraySerializer(Team.ActiveWebSessionSerializer())).serialize(value.webSessions),
            "desktop_clients": NullableSerializer(ArraySerializer(Team.DesktopClientSessionSerializer())).serialize(value.desktopClients),
            "mobile_clients": NullableSerializer(ArraySerializer(Team.MobileClientSessionSerializer())).serialize(value.mobileClients),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> MemberDevices {
            switch json {
                case .Dictionary(let dict):
                    let teamMemberId = Serialization._StringSerializer.deserialize(dict["team_member_id"] ?? .Null)
                    let webSessions = NullableSerializer(ArraySerializer(Team.ActiveWebSessionSerializer())).deserialize(dict["web_sessions"] ?? .Null)
                    let desktopClients = NullableSerializer(ArraySerializer(Team.DesktopClientSessionSerializer())).deserialize(dict["desktop_clients"] ?? .Null)
                    let mobileClients = NullableSerializer(ArraySerializer(Team.MobileClientSessionSerializer())).deserialize(dict["mobile_clients"] ?? .Null)
                    return MemberDevices(teamMemberId: teamMemberId, webSessions: webSessions, desktopClients: desktopClients, mobileClients: mobileClients)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Information on linked applications of a team member.
    public class MemberLinkedApps: CustomStringConvertible {
        /// The member unique Id
        public let teamMemberId: String
        /// List of third party applications linked by this team member
        public let linkedApiApps: Array<Team.ApiApp>
        public init(teamMemberId: String, linkedApiApps: Array<Team.ApiApp>) {
            stringValidator()(teamMemberId)
            self.teamMemberId = teamMemberId
            self.linkedApiApps = linkedApiApps
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MemberLinkedAppsSerializer().serialize(self)))"
        }
    }
    public class MemberLinkedAppsSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: MemberLinkedApps) -> JSON {
            let output = [ 
            "team_member_id": Serialization._StringSerializer.serialize(value.teamMemberId),
            "linked_api_apps": ArraySerializer(Team.ApiAppSerializer()).serialize(value.linkedApiApps),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> MemberLinkedApps {
            switch json {
                case .Dictionary(let dict):
                    let teamMemberId = Serialization._StringSerializer.deserialize(dict["team_member_id"] ?? .Null)
                    let linkedApiApps = ArraySerializer(Team.ApiAppSerializer()).deserialize(dict["linked_api_apps"] ?? .Null)
                    return MemberLinkedApps(teamMemberId: teamMemberId, linkedApiApps: linkedApiApps)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Basic member profile.
    public class MemberProfile: CustomStringConvertible {
        /// ID of user as a member of a team.
        public let teamMemberId: String
        /// External ID that a team can attach to the user. An application using the API may find it easier to use their
        /// own IDs instead of Dropbox IDs like account_id or team_member_id.
        public let externalId: String?
        /// A user's account identifier.
        public let accountId: String?
        /// Email address of user.
        public let email: String
        /// Is true if the user's email is verified to be owned by the user.
        public let emailVerified: Bool
        /// The user's status as a member of a specific team.
        public let status: Team.TeamMemberStatus
        /// Representations for a person's name.
        public let name: Users.Name
        /// The user's membership type: full (normal team member) vs limited (does not use a license; no access to the
        /// team's shared quota).
        public let membershipType: Team.TeamMembershipType
        public init(teamMemberId: String, email: String, emailVerified: Bool, status: Team.TeamMemberStatus, name: Users.Name, membershipType: Team.TeamMembershipType, externalId: String? = nil, accountId: String? = nil) {
            stringValidator()(teamMemberId)
            self.teamMemberId = teamMemberId
            nullableValidator(stringValidator())(externalId)
            self.externalId = externalId
            nullableValidator(stringValidator(minLength: 40, maxLength: 40))(accountId)
            self.accountId = accountId
            stringValidator()(email)
            self.email = email
            self.emailVerified = emailVerified
            self.status = status
            self.name = name
            self.membershipType = membershipType
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MemberProfileSerializer().serialize(self)))"
        }
    }
    public class MemberProfileSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: MemberProfile) -> JSON {
            let output = [ 
            "team_member_id": Serialization._StringSerializer.serialize(value.teamMemberId),
            "email": Serialization._StringSerializer.serialize(value.email),
            "email_verified": Serialization._BoolSerializer.serialize(value.emailVerified),
            "status": Team.TeamMemberStatusSerializer().serialize(value.status),
            "name": Users.NameSerializer().serialize(value.name),
            "membership_type": Team.TeamMembershipTypeSerializer().serialize(value.membershipType),
            "external_id": NullableSerializer(Serialization._StringSerializer).serialize(value.externalId),
            "account_id": NullableSerializer(Serialization._StringSerializer).serialize(value.accountId),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> MemberProfile {
            switch json {
                case .Dictionary(let dict):
                    let teamMemberId = Serialization._StringSerializer.deserialize(dict["team_member_id"] ?? .Null)
                    let email = Serialization._StringSerializer.deserialize(dict["email"] ?? .Null)
                    let emailVerified = Serialization._BoolSerializer.deserialize(dict["email_verified"] ?? .Null)
                    let status = Team.TeamMemberStatusSerializer().deserialize(dict["status"] ?? .Null)
                    let name = Users.NameSerializer().deserialize(dict["name"] ?? .Null)
                    let membershipType = Team.TeamMembershipTypeSerializer().deserialize(dict["membership_type"] ?? .Null)
                    let externalId = NullableSerializer(Serialization._StringSerializer).deserialize(dict["external_id"] ?? .Null)
                    let accountId = NullableSerializer(Serialization._StringSerializer).deserialize(dict["account_id"] ?? .Null)
                    return MemberProfile(teamMemberId: teamMemberId, email: email, emailVerified: emailVerified, status: status, name: name, membershipType: membershipType, externalId: externalId, accountId: accountId)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Error that can be returned whenever a struct derived from UserSelectorArg is used.
    public enum UserSelectorError: CustomStringConvertible {
        /// No matching user found. The provided team_member_id, email, or external_id does not exist on this team.
        case UserNotFound

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(UserSelectorErrorSerializer().serialize(self)))"
        }
    }
    public class UserSelectorErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: UserSelectorError) -> JSON {
            switch value {
                case .UserNotFound:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("user_not_found")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> UserSelectorError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "user_not_found":
                            return UserSelectorError.UserNotFound
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The MemberSelectorError union
    public enum MemberSelectorError: CustomStringConvertible {
        /// No matching user found. The provided team_member_id, email, or external_id does not exist on this team.
        case UserNotFound
        /// The user is not a member of the team.
        case UserNotInTeam

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MemberSelectorErrorSerializer().serialize(self)))"
        }
    }
    public class MemberSelectorErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: MemberSelectorError) -> JSON {
            switch value {
                case .UserNotFound:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("user_not_found")
                    return .Dictionary(d)
                case .UserNotInTeam:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("user_not_in_team")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> MemberSelectorError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "user_not_found":
                            return MemberSelectorError.UserNotFound
                        case "user_not_in_team":
                            return MemberSelectorError.UserNotInTeam
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The MembersAddArg struct
    public class MembersAddArg: CustomStringConvertible {
        /// Details of new members to be added to the team.
        public let newMembers: Array<Team.MemberAddArg>
        /// Whether to force the add to happen asynchronously.
        public let forceAsync: Bool
        public init(newMembers: Array<Team.MemberAddArg>, forceAsync: Bool = false) {
            self.newMembers = newMembers
            self.forceAsync = forceAsync
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MembersAddArgSerializer().serialize(self)))"
        }
    }
    public class MembersAddArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: MembersAddArg) -> JSON {
            let output = [ 
            "new_members": ArraySerializer(Team.MemberAddArgSerializer()).serialize(value.newMembers),
            "force_async": Serialization._BoolSerializer.serialize(value.forceAsync),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> MembersAddArg {
            switch json {
                case .Dictionary(let dict):
                    let newMembers = ArraySerializer(Team.MemberAddArgSerializer()).deserialize(dict["new_members"] ?? .Null)
                    let forceAsync = Serialization._BoolSerializer.deserialize(dict["force_async"] ?? .Null)
                    return MembersAddArg(newMembers: newMembers, forceAsync: forceAsync)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The MembersAddJobStatus union
    public enum MembersAddJobStatus: CustomStringConvertible {
        /// The asynchronous job is still in progress.
        case InProgress
        /// The asynchronous job has finished. For each member that was specified in the parameter MembersAddArg that
        /// was provided to membersAdd, a corresponding item is returned in this list.
        case Complete(Array<Team.MemberAddResult>)
        /// The asynchronous job returned an error. The string contains an error message.
        case Failed(String)

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MembersAddJobStatusSerializer().serialize(self)))"
        }
    }
    public class MembersAddJobStatusSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: MembersAddJobStatus) -> JSON {
            switch value {
                case .InProgress:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("in_progress")
                    return .Dictionary(d)
                case .Complete(let arg):
                    var d = ["complete": ArraySerializer(Team.MemberAddResultSerializer()).serialize(arg)]
                    d[".tag"] = .Str("complete")
                    return .Dictionary(d)
                case .Failed(let arg):
                    var d = ["failed": Serialization._StringSerializer.serialize(arg)]
                    d[".tag"] = .Str("failed")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> MembersAddJobStatus {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "in_progress":
                            return MembersAddJobStatus.InProgress
                        case "complete":
                            let v = ArraySerializer(Team.MemberAddResultSerializer()).deserialize(d["complete"] ?? .Null)
                            return MembersAddJobStatus.Complete(v)
                        case "failed":
                            let v = Serialization._StringSerializer.deserialize(d["failed"] ?? .Null)
                            return MembersAddJobStatus.Failed(v)
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The MembersAddLaunch union
    public enum MembersAddLaunch: CustomStringConvertible {
        /// This response indicates that the processing is asynchronous. The string is an id that can be used to obtain
        /// the status of the asynchronous job.
        case AsyncJobId(String)
        /// An unspecified error.
        case Complete(Array<Team.MemberAddResult>)

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MembersAddLaunchSerializer().serialize(self)))"
        }
    }
    public class MembersAddLaunchSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: MembersAddLaunch) -> JSON {
            switch value {
                case .AsyncJobId(let arg):
                    var d = ["async_job_id": Serialization._StringSerializer.serialize(arg)]
                    d[".tag"] = .Str("async_job_id")
                    return .Dictionary(d)
                case .Complete(let arg):
                    var d = ["complete": ArraySerializer(Team.MemberAddResultSerializer()).serialize(arg)]
                    d[".tag"] = .Str("complete")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> MembersAddLaunch {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "async_job_id":
                            let v = Serialization._StringSerializer.deserialize(d["async_job_id"] ?? .Null)
                            return MembersAddLaunch.AsyncJobId(v)
                        case "complete":
                            let v = ArraySerializer(Team.MemberAddResultSerializer()).deserialize(d["complete"] ?? .Null)
                            return MembersAddLaunch.Complete(v)
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Exactly one of team_member_id, email, or external_id must be provided to identify the user account.
    public class MembersDeactivateArg: CustomStringConvertible {
        /// Identity of user to remove/suspend.
        public let user: Team.UserSelectorArg
        /// If provided, controls if the user's data will be deleted on their linked devices.
        public let wipeData: Bool
        public init(user: Team.UserSelectorArg, wipeData: Bool = true) {
            self.user = user
            self.wipeData = wipeData
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MembersDeactivateArgSerializer().serialize(self)))"
        }
    }
    public class MembersDeactivateArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: MembersDeactivateArg) -> JSON {
            let output = [ 
            "user": Team.UserSelectorArgSerializer().serialize(value.user),
            "wipe_data": Serialization._BoolSerializer.serialize(value.wipeData),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> MembersDeactivateArg {
            switch json {
                case .Dictionary(let dict):
                    let user = Team.UserSelectorArgSerializer().deserialize(dict["user"] ?? .Null)
                    let wipeData = Serialization._BoolSerializer.deserialize(dict["wipe_data"] ?? .Null)
                    return MembersDeactivateArg(user: user, wipeData: wipeData)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The MembersDeactivateError union
    public enum MembersDeactivateError: CustomStringConvertible {
        /// No matching user found. The provided team_member_id, email, or external_id does not exist on this team.
        case UserNotFound
        /// The user is not a member of the team.
        case UserNotInTeam
        /// An unspecified error.
        case Other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MembersDeactivateErrorSerializer().serialize(self)))"
        }
    }
    public class MembersDeactivateErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: MembersDeactivateError) -> JSON {
            switch value {
                case .UserNotFound:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("user_not_found")
                    return .Dictionary(d)
                case .UserNotInTeam:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("user_not_in_team")
                    return .Dictionary(d)
                case .Other:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> MembersDeactivateError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "user_not_found":
                            return MembersDeactivateError.UserNotFound
                        case "user_not_in_team":
                            return MembersDeactivateError.UserNotInTeam
                        case "other":
                            return MembersDeactivateError.Other
                        default:
                            return MembersDeactivateError.Other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The MembersGetInfoArgs struct
    public class MembersGetInfoArgs: CustomStringConvertible {
        /// List of team members.
        public let members: Array<Team.UserSelectorArg>
        public init(members: Array<Team.UserSelectorArg>) {
            self.members = members
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MembersGetInfoArgsSerializer().serialize(self)))"
        }
    }
    public class MembersGetInfoArgsSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: MembersGetInfoArgs) -> JSON {
            let output = [ 
            "members": ArraySerializer(Team.UserSelectorArgSerializer()).serialize(value.members),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> MembersGetInfoArgs {
            switch json {
                case .Dictionary(let dict):
                    let members = ArraySerializer(Team.UserSelectorArgSerializer()).deserialize(dict["members"] ?? .Null)
                    return MembersGetInfoArgs(members: members)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The MembersGetInfoError union
    public enum MembersGetInfoError: CustomStringConvertible {
        /// An unspecified error.
        case Other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MembersGetInfoErrorSerializer().serialize(self)))"
        }
    }
    public class MembersGetInfoErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: MembersGetInfoError) -> JSON {
            switch value {
                case .Other:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> MembersGetInfoError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "other":
                            return MembersGetInfoError.Other
                        default:
                            return MembersGetInfoError.Other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Describes a result obtained for a single user whose id was specified in the parameter of membersGetInfo.
    public enum MembersGetInfoItem: CustomStringConvertible {
        /// An ID that was provided as a parameter to membersGetInfo, and did not match a corresponding user. This might
        /// be a team_member_id, an email, or an external ID, depending on how the method was called.
        case IdNotFound(String)
        /// Info about a team member.
        case MemberInfo(Team.TeamMemberInfo)

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MembersGetInfoItemSerializer().serialize(self)))"
        }
    }
    public class MembersGetInfoItemSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: MembersGetInfoItem) -> JSON {
            switch value {
                case .IdNotFound(let arg):
                    var d = ["id_not_found": Serialization._StringSerializer.serialize(arg)]
                    d[".tag"] = .Str("id_not_found")
                    return .Dictionary(d)
                case .MemberInfo(let arg):
                    var d = Serialization.getFields(Team.TeamMemberInfoSerializer().serialize(arg))
                    d[".tag"] = .Str("member_info")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> MembersGetInfoItem {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "id_not_found":
                            let v = Serialization._StringSerializer.deserialize(d["id_not_found"] ?? .Null)
                            return MembersGetInfoItem.IdNotFound(v)
                        case "member_info":
                            let v = Team.TeamMemberInfoSerializer().deserialize(json)
                            return MembersGetInfoItem.MemberInfo(v)
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The MembersListArg struct
    public class MembersListArg: CustomStringConvertible {
        /// Number of results to return per call.
        public let limit: UInt32
        /// Whether to return removed members.
        public let includeRemoved: Bool
        public init(limit: UInt32 = 1000, includeRemoved: Bool = false) {
            comparableValidator(minValue: 1, maxValue: 1000)(limit)
            self.limit = limit
            self.includeRemoved = includeRemoved
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MembersListArgSerializer().serialize(self)))"
        }
    }
    public class MembersListArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: MembersListArg) -> JSON {
            let output = [ 
            "limit": Serialization._UInt32Serializer.serialize(value.limit),
            "include_removed": Serialization._BoolSerializer.serialize(value.includeRemoved),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> MembersListArg {
            switch json {
                case .Dictionary(let dict):
                    let limit = Serialization._UInt32Serializer.deserialize(dict["limit"] ?? .Null)
                    let includeRemoved = Serialization._BoolSerializer.deserialize(dict["include_removed"] ?? .Null)
                    return MembersListArg(limit: limit, includeRemoved: includeRemoved)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The MembersListContinueArg struct
    public class MembersListContinueArg: CustomStringConvertible {
        /// Indicates from what point to get the next set of members.
        public let cursor: String
        public init(cursor: String) {
            stringValidator()(cursor)
            self.cursor = cursor
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MembersListContinueArgSerializer().serialize(self)))"
        }
    }
    public class MembersListContinueArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: MembersListContinueArg) -> JSON {
            let output = [ 
            "cursor": Serialization._StringSerializer.serialize(value.cursor),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> MembersListContinueArg {
            switch json {
                case .Dictionary(let dict):
                    let cursor = Serialization._StringSerializer.deserialize(dict["cursor"] ?? .Null)
                    return MembersListContinueArg(cursor: cursor)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The MembersListContinueError union
    public enum MembersListContinueError: CustomStringConvertible {
        /// The cursor is invalid.
        case InvalidCursor
        /// An unspecified error.
        case Other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MembersListContinueErrorSerializer().serialize(self)))"
        }
    }
    public class MembersListContinueErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: MembersListContinueError) -> JSON {
            switch value {
                case .InvalidCursor:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("invalid_cursor")
                    return .Dictionary(d)
                case .Other:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> MembersListContinueError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "invalid_cursor":
                            return MembersListContinueError.InvalidCursor
                        case "other":
                            return MembersListContinueError.Other
                        default:
                            return MembersListContinueError.Other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The MembersListError union
    public enum MembersListError: CustomStringConvertible {
        /// An unspecified error.
        case Other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MembersListErrorSerializer().serialize(self)))"
        }
    }
    public class MembersListErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: MembersListError) -> JSON {
            switch value {
                case .Other:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> MembersListError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "other":
                            return MembersListError.Other
                        default:
                            return MembersListError.Other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The MembersListResult struct
    public class MembersListResult: CustomStringConvertible {
        /// List of team members.
        public let members: Array<Team.TeamMemberInfo>
        /// Pass the cursor into membersListContinue to obtain the additional members.
        public let cursor: String
        /// Is true if there are additional team members that have not been returned yet. An additional call to
        /// membersListContinue can retrieve them.
        public let hasMore: Bool
        public init(members: Array<Team.TeamMemberInfo>, cursor: String, hasMore: Bool) {
            self.members = members
            stringValidator()(cursor)
            self.cursor = cursor
            self.hasMore = hasMore
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MembersListResultSerializer().serialize(self)))"
        }
    }
    public class MembersListResultSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: MembersListResult) -> JSON {
            let output = [ 
            "members": ArraySerializer(Team.TeamMemberInfoSerializer()).serialize(value.members),
            "cursor": Serialization._StringSerializer.serialize(value.cursor),
            "has_more": Serialization._BoolSerializer.serialize(value.hasMore),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> MembersListResult {
            switch json {
                case .Dictionary(let dict):
                    let members = ArraySerializer(Team.TeamMemberInfoSerializer()).deserialize(dict["members"] ?? .Null)
                    let cursor = Serialization._StringSerializer.deserialize(dict["cursor"] ?? .Null)
                    let hasMore = Serialization._BoolSerializer.deserialize(dict["has_more"] ?? .Null)
                    return MembersListResult(members: members, cursor: cursor, hasMore: hasMore)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Exactly one of team_member_id, email, or external_id must be provided to identify the user account.
    public class MembersRecoverArg: CustomStringConvertible {
        /// Identity of user to recover.
        public let user: Team.UserSelectorArg
        public init(user: Team.UserSelectorArg) {
            self.user = user
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MembersRecoverArgSerializer().serialize(self)))"
        }
    }
    public class MembersRecoverArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: MembersRecoverArg) -> JSON {
            let output = [ 
            "user": Team.UserSelectorArgSerializer().serialize(value.user),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> MembersRecoverArg {
            switch json {
                case .Dictionary(let dict):
                    let user = Team.UserSelectorArgSerializer().deserialize(dict["user"] ?? .Null)
                    return MembersRecoverArg(user: user)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The MembersRecoverError union
    public enum MembersRecoverError: CustomStringConvertible {
        /// No matching user found. The provided team_member_id, email, or external_id does not exist on this team.
        case UserNotFound
        /// The user is not recoverable.
        case UserUnrecoverable
        /// The user is not a member of the team.
        case UserNotInTeam
        /// An unspecified error.
        case Other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MembersRecoverErrorSerializer().serialize(self)))"
        }
    }
    public class MembersRecoverErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: MembersRecoverError) -> JSON {
            switch value {
                case .UserNotFound:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("user_not_found")
                    return .Dictionary(d)
                case .UserUnrecoverable:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("user_unrecoverable")
                    return .Dictionary(d)
                case .UserNotInTeam:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("user_not_in_team")
                    return .Dictionary(d)
                case .Other:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> MembersRecoverError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "user_not_found":
                            return MembersRecoverError.UserNotFound
                        case "user_unrecoverable":
                            return MembersRecoverError.UserUnrecoverable
                        case "user_not_in_team":
                            return MembersRecoverError.UserNotInTeam
                        case "other":
                            return MembersRecoverError.Other
                        default:
                            return MembersRecoverError.Other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The MembersRemoveArg struct
    public class MembersRemoveArg: Team.MembersDeactivateArg {
        /// If provided, files from the deleted member account will be transferred to this user.
        public let transferDestId: Team.UserSelectorArg?
        /// If provided, errors during the transfer process will be sent via email to this user. If the transfer_dest_id
        /// argument was provided, then this argument must be provided as well.
        public let transferAdminId: Team.UserSelectorArg?
        /// Downgrade the member to a Basic account. The user will retain the email address associated with their
        /// Dropbox  account and data in their account that is not restricted to team members.
        public let keepAccount: Bool
        public init(user: Team.UserSelectorArg, wipeData: Bool = true, transferDestId: Team.UserSelectorArg? = nil, transferAdminId: Team.UserSelectorArg? = nil, keepAccount: Bool = false) {
            self.transferDestId = transferDestId
            self.transferAdminId = transferAdminId
            self.keepAccount = keepAccount
            super.init(user: user, wipeData: wipeData)
        }
        public override var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MembersRemoveArgSerializer().serialize(self)))"
        }
    }
    public class MembersRemoveArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: MembersRemoveArg) -> JSON {
            let output = [ 
            "user": Team.UserSelectorArgSerializer().serialize(value.user),
            "wipe_data": Serialization._BoolSerializer.serialize(value.wipeData),
            "transfer_dest_id": NullableSerializer(Team.UserSelectorArgSerializer()).serialize(value.transferDestId),
            "transfer_admin_id": NullableSerializer(Team.UserSelectorArgSerializer()).serialize(value.transferAdminId),
            "keep_account": Serialization._BoolSerializer.serialize(value.keepAccount),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> MembersRemoveArg {
            switch json {
                case .Dictionary(let dict):
                    let user = Team.UserSelectorArgSerializer().deserialize(dict["user"] ?? .Null)
                    let wipeData = Serialization._BoolSerializer.deserialize(dict["wipe_data"] ?? .Null)
                    let transferDestId = NullableSerializer(Team.UserSelectorArgSerializer()).deserialize(dict["transfer_dest_id"] ?? .Null)
                    let transferAdminId = NullableSerializer(Team.UserSelectorArgSerializer()).deserialize(dict["transfer_admin_id"] ?? .Null)
                    let keepAccount = Serialization._BoolSerializer.deserialize(dict["keep_account"] ?? .Null)
                    return MembersRemoveArg(user: user, wipeData: wipeData, transferDestId: transferDestId, transferAdminId: transferAdminId, keepAccount: keepAccount)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The MembersRemoveError union
    public enum MembersRemoveError: CustomStringConvertible {
        /// No matching user found. The provided team_member_id, email, or external_id does not exist on this team.
        case UserNotFound
        /// The user is not a member of the team.
        case UserNotInTeam
        /// An unspecified error.
        case Other
        /// The user is the last admin of the team, so it cannot be removed from it.
        case RemoveLastAdmin
        /// Expected removed user and transfer_dest user to be different
        case RemovedAndTransferDestShouldDiffer
        /// Expected removed user and transfer_admin user to be different.
        case RemovedAndTransferAdminShouldDiffer
        /// No matching user found for the argument transfer_dest_id.
        case TransferDestUserNotFound
        /// The provided transfer_dest_id does not exist on this team.
        case TransferDestUserNotInTeam
        /// No matching user found for the argument transfer_admin_id.
        case TransferAdminUserNotFound
        /// The provided transfer_admin_id does not exist on this team.
        case TransferAdminUserNotInTeam
        /// The transfer_admin_id argument must be provided when file transfer is requested.
        case UnspecifiedTransferAdminId
        /// Specified transfer_admin user is not a team admin.
        case TransferAdminIsNotAdmin
        /// Cannot keep account and transfer the data to another user at the same time.
        case CannotKeepAccountAndTransfer
        /// Cannot keep account and delete the data at the same time.
        case CannotKeepAccountAndDeleteData
        /// The email address of the user is too long to be disabled.
        case EmailAddressTooLongToBeDisabled

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MembersRemoveErrorSerializer().serialize(self)))"
        }
    }
    public class MembersRemoveErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: MembersRemoveError) -> JSON {
            switch value {
                case .UserNotFound:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("user_not_found")
                    return .Dictionary(d)
                case .UserNotInTeam:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("user_not_in_team")
                    return .Dictionary(d)
                case .Other:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
                case .RemoveLastAdmin:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("remove_last_admin")
                    return .Dictionary(d)
                case .RemovedAndTransferDestShouldDiffer:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("removed_and_transfer_dest_should_differ")
                    return .Dictionary(d)
                case .RemovedAndTransferAdminShouldDiffer:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("removed_and_transfer_admin_should_differ")
                    return .Dictionary(d)
                case .TransferDestUserNotFound:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("transfer_dest_user_not_found")
                    return .Dictionary(d)
                case .TransferDestUserNotInTeam:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("transfer_dest_user_not_in_team")
                    return .Dictionary(d)
                case .TransferAdminUserNotFound:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("transfer_admin_user_not_found")
                    return .Dictionary(d)
                case .TransferAdminUserNotInTeam:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("transfer_admin_user_not_in_team")
                    return .Dictionary(d)
                case .UnspecifiedTransferAdminId:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("unspecified_transfer_admin_id")
                    return .Dictionary(d)
                case .TransferAdminIsNotAdmin:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("transfer_admin_is_not_admin")
                    return .Dictionary(d)
                case .CannotKeepAccountAndTransfer:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("cannot_keep_account_and_transfer")
                    return .Dictionary(d)
                case .CannotKeepAccountAndDeleteData:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("cannot_keep_account_and_delete_data")
                    return .Dictionary(d)
                case .EmailAddressTooLongToBeDisabled:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("email_address_too_long_to_be_disabled")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> MembersRemoveError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "user_not_found":
                            return MembersRemoveError.UserNotFound
                        case "user_not_in_team":
                            return MembersRemoveError.UserNotInTeam
                        case "other":
                            return MembersRemoveError.Other
                        case "remove_last_admin":
                            return MembersRemoveError.RemoveLastAdmin
                        case "removed_and_transfer_dest_should_differ":
                            return MembersRemoveError.RemovedAndTransferDestShouldDiffer
                        case "removed_and_transfer_admin_should_differ":
                            return MembersRemoveError.RemovedAndTransferAdminShouldDiffer
                        case "transfer_dest_user_not_found":
                            return MembersRemoveError.TransferDestUserNotFound
                        case "transfer_dest_user_not_in_team":
                            return MembersRemoveError.TransferDestUserNotInTeam
                        case "transfer_admin_user_not_found":
                            return MembersRemoveError.TransferAdminUserNotFound
                        case "transfer_admin_user_not_in_team":
                            return MembersRemoveError.TransferAdminUserNotInTeam
                        case "unspecified_transfer_admin_id":
                            return MembersRemoveError.UnspecifiedTransferAdminId
                        case "transfer_admin_is_not_admin":
                            return MembersRemoveError.TransferAdminIsNotAdmin
                        case "cannot_keep_account_and_transfer":
                            return MembersRemoveError.CannotKeepAccountAndTransfer
                        case "cannot_keep_account_and_delete_data":
                            return MembersRemoveError.CannotKeepAccountAndDeleteData
                        case "email_address_too_long_to_be_disabled":
                            return MembersRemoveError.EmailAddressTooLongToBeDisabled
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The MembersSendWelcomeError union
    public enum MembersSendWelcomeError: CustomStringConvertible {
        /// No matching user found. The provided team_member_id, email, or external_id does not exist on this team.
        case UserNotFound
        /// The user is not a member of the team.
        case UserNotInTeam
        /// An unspecified error.
        case Other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MembersSendWelcomeErrorSerializer().serialize(self)))"
        }
    }
    public class MembersSendWelcomeErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: MembersSendWelcomeError) -> JSON {
            switch value {
                case .UserNotFound:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("user_not_found")
                    return .Dictionary(d)
                case .UserNotInTeam:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("user_not_in_team")
                    return .Dictionary(d)
                case .Other:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> MembersSendWelcomeError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "user_not_found":
                            return MembersSendWelcomeError.UserNotFound
                        case "user_not_in_team":
                            return MembersSendWelcomeError.UserNotInTeam
                        case "other":
                            return MembersSendWelcomeError.Other
                        default:
                            return MembersSendWelcomeError.Other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Exactly one of team_member_id, email, or external_id must be provided to identify the user account.
    public class MembersSetPermissionsArg: CustomStringConvertible {
        /// Identity of user whose role will be set.
        public let user: Team.UserSelectorArg
        /// The new role of the member.
        public let newRole: Team.AdminTier
        public init(user: Team.UserSelectorArg, newRole: Team.AdminTier) {
            self.user = user
            self.newRole = newRole
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MembersSetPermissionsArgSerializer().serialize(self)))"
        }
    }
    public class MembersSetPermissionsArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: MembersSetPermissionsArg) -> JSON {
            let output = [ 
            "user": Team.UserSelectorArgSerializer().serialize(value.user),
            "new_role": Team.AdminTierSerializer().serialize(value.newRole),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> MembersSetPermissionsArg {
            switch json {
                case .Dictionary(let dict):
                    let user = Team.UserSelectorArgSerializer().deserialize(dict["user"] ?? .Null)
                    let newRole = Team.AdminTierSerializer().deserialize(dict["new_role"] ?? .Null)
                    return MembersSetPermissionsArg(user: user, newRole: newRole)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The MembersSetPermissionsError union
    public enum MembersSetPermissionsError: CustomStringConvertible {
        /// No matching user found. The provided team_member_id, email, or external_id does not exist on this team.
        case UserNotFound
        /// Cannot remove the admin setting of the last admin.
        case LastAdmin
        /// The user is not a member of the team.
        case UserNotInTeam
        /// Cannot remove/grant permissions.
        case CannotSetPermissions
        /// Team is full. The organization has no available licenses.
        case TeamLicenseLimit
        /// An unspecified error.
        case Other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MembersSetPermissionsErrorSerializer().serialize(self)))"
        }
    }
    public class MembersSetPermissionsErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: MembersSetPermissionsError) -> JSON {
            switch value {
                case .UserNotFound:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("user_not_found")
                    return .Dictionary(d)
                case .LastAdmin:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("last_admin")
                    return .Dictionary(d)
                case .UserNotInTeam:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("user_not_in_team")
                    return .Dictionary(d)
                case .CannotSetPermissions:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("cannot_set_permissions")
                    return .Dictionary(d)
                case .TeamLicenseLimit:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("team_license_limit")
                    return .Dictionary(d)
                case .Other:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> MembersSetPermissionsError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "user_not_found":
                            return MembersSetPermissionsError.UserNotFound
                        case "last_admin":
                            return MembersSetPermissionsError.LastAdmin
                        case "user_not_in_team":
                            return MembersSetPermissionsError.UserNotInTeam
                        case "cannot_set_permissions":
                            return MembersSetPermissionsError.CannotSetPermissions
                        case "team_license_limit":
                            return MembersSetPermissionsError.TeamLicenseLimit
                        case "other":
                            return MembersSetPermissionsError.Other
                        default:
                            return MembersSetPermissionsError.Other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The MembersSetPermissionsResult struct
    public class MembersSetPermissionsResult: CustomStringConvertible {
        /// The member ID of the user to which the change was applied.
        public let teamMemberId: String
        /// The role after the change.
        public let role: Team.AdminTier
        public init(teamMemberId: String, role: Team.AdminTier) {
            stringValidator()(teamMemberId)
            self.teamMemberId = teamMemberId
            self.role = role
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MembersSetPermissionsResultSerializer().serialize(self)))"
        }
    }
    public class MembersSetPermissionsResultSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: MembersSetPermissionsResult) -> JSON {
            let output = [ 
            "team_member_id": Serialization._StringSerializer.serialize(value.teamMemberId),
            "role": Team.AdminTierSerializer().serialize(value.role),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> MembersSetPermissionsResult {
            switch json {
                case .Dictionary(let dict):
                    let teamMemberId = Serialization._StringSerializer.deserialize(dict["team_member_id"] ?? .Null)
                    let role = Team.AdminTierSerializer().deserialize(dict["role"] ?? .Null)
                    return MembersSetPermissionsResult(teamMemberId: teamMemberId, role: role)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Exactly one of team_member_id, email, or external_id must be provided to identify the user account. At least one
    /// of new_email, new_external_id, new_given_name, and/or new_surname must be provided.
    public class MembersSetProfileArg: CustomStringConvertible {
        /// Identity of user whose profile will be set.
        public let user: Team.UserSelectorArg
        /// New email for member.
        public let newEmail: String?
        /// New external ID for member.
        public let newExternalId: String?
        /// New given name for member.
        public let newGivenName: String?
        /// New surname for member.
        public let newSurname: String?
        public init(user: Team.UserSelectorArg, newEmail: String? = nil, newExternalId: String? = nil, newGivenName: String? = nil, newSurname: String? = nil) {
            self.user = user
            nullableValidator(stringValidator(maxLength: 255, pattern: "^['&A-Za-z0-9._%+-]+@[A-Za-z0-9-][A-Za-z0-9.-]*.[A-Za-z]{2,15}$"))(newEmail)
            self.newEmail = newEmail
            nullableValidator(stringValidator(maxLength: 64))(newExternalId)
            self.newExternalId = newExternalId
            nullableValidator(stringValidator(minLength: 1, maxLength: 100, pattern: "[^/:?*<>\"|]*"))(newGivenName)
            self.newGivenName = newGivenName
            nullableValidator(stringValidator(minLength: 1, maxLength: 100, pattern: "[^/:?*<>\"|]*"))(newSurname)
            self.newSurname = newSurname
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MembersSetProfileArgSerializer().serialize(self)))"
        }
    }
    public class MembersSetProfileArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: MembersSetProfileArg) -> JSON {
            let output = [ 
            "user": Team.UserSelectorArgSerializer().serialize(value.user),
            "new_email": NullableSerializer(Serialization._StringSerializer).serialize(value.newEmail),
            "new_external_id": NullableSerializer(Serialization._StringSerializer).serialize(value.newExternalId),
            "new_given_name": NullableSerializer(Serialization._StringSerializer).serialize(value.newGivenName),
            "new_surname": NullableSerializer(Serialization._StringSerializer).serialize(value.newSurname),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> MembersSetProfileArg {
            switch json {
                case .Dictionary(let dict):
                    let user = Team.UserSelectorArgSerializer().deserialize(dict["user"] ?? .Null)
                    let newEmail = NullableSerializer(Serialization._StringSerializer).deserialize(dict["new_email"] ?? .Null)
                    let newExternalId = NullableSerializer(Serialization._StringSerializer).deserialize(dict["new_external_id"] ?? .Null)
                    let newGivenName = NullableSerializer(Serialization._StringSerializer).deserialize(dict["new_given_name"] ?? .Null)
                    let newSurname = NullableSerializer(Serialization._StringSerializer).deserialize(dict["new_surname"] ?? .Null)
                    return MembersSetProfileArg(user: user, newEmail: newEmail, newExternalId: newExternalId, newGivenName: newGivenName, newSurname: newSurname)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The MembersSetProfileError union
    public enum MembersSetProfileError: CustomStringConvertible {
        /// No matching user found. The provided team_member_id, email, or external_id does not exist on this team.
        case UserNotFound
        /// The user is not a member of the team.
        case UserNotInTeam
        /// It is unsafe to use both external_id and new_external_id
        case ExternalIdAndNewExternalIdUnsafe
        /// None of new_email, new_given_name, new_surname, or new_external_id are specified
        case NoNewDataSpecified
        /// Email is already reserved for another user.
        case EmailReservedForOtherUser
        /// The external ID is already in use by another team member.
        case ExternalIdUsedByOtherUser
        /// Setting profile disallowed
        case SetProfileDisallowed
        /// Parameter new_email cannot be empty.
        case ParamCannotBeEmpty
        /// An unspecified error.
        case Other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MembersSetProfileErrorSerializer().serialize(self)))"
        }
    }
    public class MembersSetProfileErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: MembersSetProfileError) -> JSON {
            switch value {
                case .UserNotFound:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("user_not_found")
                    return .Dictionary(d)
                case .UserNotInTeam:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("user_not_in_team")
                    return .Dictionary(d)
                case .ExternalIdAndNewExternalIdUnsafe:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("external_id_and_new_external_id_unsafe")
                    return .Dictionary(d)
                case .NoNewDataSpecified:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("no_new_data_specified")
                    return .Dictionary(d)
                case .EmailReservedForOtherUser:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("email_reserved_for_other_user")
                    return .Dictionary(d)
                case .ExternalIdUsedByOtherUser:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("external_id_used_by_other_user")
                    return .Dictionary(d)
                case .SetProfileDisallowed:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("set_profile_disallowed")
                    return .Dictionary(d)
                case .ParamCannotBeEmpty:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("param_cannot_be_empty")
                    return .Dictionary(d)
                case .Other:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> MembersSetProfileError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "user_not_found":
                            return MembersSetProfileError.UserNotFound
                        case "user_not_in_team":
                            return MembersSetProfileError.UserNotInTeam
                        case "external_id_and_new_external_id_unsafe":
                            return MembersSetProfileError.ExternalIdAndNewExternalIdUnsafe
                        case "no_new_data_specified":
                            return MembersSetProfileError.NoNewDataSpecified
                        case "email_reserved_for_other_user":
                            return MembersSetProfileError.EmailReservedForOtherUser
                        case "external_id_used_by_other_user":
                            return MembersSetProfileError.ExternalIdUsedByOtherUser
                        case "set_profile_disallowed":
                            return MembersSetProfileError.SetProfileDisallowed
                        case "param_cannot_be_empty":
                            return MembersSetProfileError.ParamCannotBeEmpty
                        case "other":
                            return MembersSetProfileError.Other
                        default:
                            return MembersSetProfileError.Other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The MembersSuspendError union
    public enum MembersSuspendError: CustomStringConvertible {
        /// No matching user found. The provided team_member_id, email, or external_id does not exist on this team.
        case UserNotFound
        /// The user is not a member of the team.
        case UserNotInTeam
        /// An unspecified error.
        case Other
        /// The user is not active, so it cannot be suspended.
        case SuspendInactiveUser
        /// The user is the last admin of the team, so it cannot be suspended.
        case SuspendLastAdmin
        /// Team is full. The organization has no available licenses.
        case TeamLicenseLimit

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MembersSuspendErrorSerializer().serialize(self)))"
        }
    }
    public class MembersSuspendErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: MembersSuspendError) -> JSON {
            switch value {
                case .UserNotFound:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("user_not_found")
                    return .Dictionary(d)
                case .UserNotInTeam:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("user_not_in_team")
                    return .Dictionary(d)
                case .Other:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
                case .SuspendInactiveUser:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("suspend_inactive_user")
                    return .Dictionary(d)
                case .SuspendLastAdmin:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("suspend_last_admin")
                    return .Dictionary(d)
                case .TeamLicenseLimit:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("team_license_limit")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> MembersSuspendError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "user_not_found":
                            return MembersSuspendError.UserNotFound
                        case "user_not_in_team":
                            return MembersSuspendError.UserNotInTeam
                        case "other":
                            return MembersSuspendError.Other
                        case "suspend_inactive_user":
                            return MembersSuspendError.SuspendInactiveUser
                        case "suspend_last_admin":
                            return MembersSuspendError.SuspendLastAdmin
                        case "team_license_limit":
                            return MembersSuspendError.TeamLicenseLimit
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Exactly one of team_member_id, email, or external_id must be provided to identify the user account.
    public class MembersUnsuspendArg: CustomStringConvertible {
        /// Identity of user to unsuspend.
        public let user: Team.UserSelectorArg
        public init(user: Team.UserSelectorArg) {
            self.user = user
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MembersUnsuspendArgSerializer().serialize(self)))"
        }
    }
    public class MembersUnsuspendArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: MembersUnsuspendArg) -> JSON {
            let output = [ 
            "user": Team.UserSelectorArgSerializer().serialize(value.user),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> MembersUnsuspendArg {
            switch json {
                case .Dictionary(let dict):
                    let user = Team.UserSelectorArgSerializer().deserialize(dict["user"] ?? .Null)
                    return MembersUnsuspendArg(user: user)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The MembersUnsuspendError union
    public enum MembersUnsuspendError: CustomStringConvertible {
        /// No matching user found. The provided team_member_id, email, or external_id does not exist on this team.
        case UserNotFound
        /// The user is not a member of the team.
        case UserNotInTeam
        /// An unspecified error.
        case Other
        /// The user is unsuspended, so it cannot be unsuspended again.
        case UnsuspendNonSuspendedMember
        /// Team is full. The organization has no available licenses.
        case TeamLicenseLimit

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MembersUnsuspendErrorSerializer().serialize(self)))"
        }
    }
    public class MembersUnsuspendErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: MembersUnsuspendError) -> JSON {
            switch value {
                case .UserNotFound:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("user_not_found")
                    return .Dictionary(d)
                case .UserNotInTeam:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("user_not_in_team")
                    return .Dictionary(d)
                case .Other:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
                case .UnsuspendNonSuspendedMember:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("unsuspend_non_suspended_member")
                    return .Dictionary(d)
                case .TeamLicenseLimit:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("team_license_limit")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> MembersUnsuspendError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "user_not_found":
                            return MembersUnsuspendError.UserNotFound
                        case "user_not_in_team":
                            return MembersUnsuspendError.UserNotInTeam
                        case "other":
                            return MembersUnsuspendError.Other
                        case "unsuspend_non_suspended_member":
                            return MembersUnsuspendError.UnsuspendNonSuspendedMember
                        case "team_license_limit":
                            return MembersUnsuspendError.TeamLicenseLimit
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The MobileClientPlatform union
    public enum MobileClientPlatform: CustomStringConvertible {
        /// Official Dropbox iPhone client
        case Iphone
        /// Official Dropbox iPad client
        case Ipad
        /// Official Dropbox Android client
        case Android
        /// Official Dropbox Windows phone client
        case WindowsPhone
        /// Official Dropbox Blackberry client
        case Blackberry
        /// An unspecified error.
        case Other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MobileClientPlatformSerializer().serialize(self)))"
        }
    }
    public class MobileClientPlatformSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: MobileClientPlatform) -> JSON {
            switch value {
                case .Iphone:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("iphone")
                    return .Dictionary(d)
                case .Ipad:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("ipad")
                    return .Dictionary(d)
                case .Android:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("android")
                    return .Dictionary(d)
                case .WindowsPhone:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("windows_phone")
                    return .Dictionary(d)
                case .Blackberry:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("blackberry")
                    return .Dictionary(d)
                case .Other:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> MobileClientPlatform {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "iphone":
                            return MobileClientPlatform.Iphone
                        case "ipad":
                            return MobileClientPlatform.Ipad
                        case "android":
                            return MobileClientPlatform.Android
                        case "windows_phone":
                            return MobileClientPlatform.WindowsPhone
                        case "blackberry":
                            return MobileClientPlatform.Blackberry
                        case "other":
                            return MobileClientPlatform.Other
                        default:
                            return MobileClientPlatform.Other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Information about linked Dropbox mobile client sessions
    public class MobileClientSession: Team.DeviceSession {
        /// The device name
        public let deviceName: String
        /// The mobile application type
        public let clientType: Team.MobileClientPlatform
        /// The dropbox client version
        public let clientVersion: String?
        /// The hosting OS version
        public let osVersion: String?
        /// last carrier used by the device
        public let lastCarrier: String?
        public init(sessionId: String, deviceName: String, clientType: Team.MobileClientPlatform, ipAddress: String? = nil, country: String? = nil, created: NSDate? = nil, updated: NSDate? = nil, clientVersion: String? = nil, osVersion: String? = nil, lastCarrier: String? = nil) {
            stringValidator()(deviceName)
            self.deviceName = deviceName
            self.clientType = clientType
            nullableValidator(stringValidator())(clientVersion)
            self.clientVersion = clientVersion
            nullableValidator(stringValidator())(osVersion)
            self.osVersion = osVersion
            nullableValidator(stringValidator())(lastCarrier)
            self.lastCarrier = lastCarrier
            super.init(sessionId: sessionId, ipAddress: ipAddress, country: country, created: created, updated: updated)
        }
        public override var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(MobileClientSessionSerializer().serialize(self)))"
        }
    }
    public class MobileClientSessionSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: MobileClientSession) -> JSON {
            let output = [ 
            "session_id": Serialization._StringSerializer.serialize(value.sessionId),
            "device_name": Serialization._StringSerializer.serialize(value.deviceName),
            "client_type": Team.MobileClientPlatformSerializer().serialize(value.clientType),
            "ip_address": NullableSerializer(Serialization._StringSerializer).serialize(value.ipAddress),
            "country": NullableSerializer(Serialization._StringSerializer).serialize(value.country),
            "created": NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.created),
            "updated": NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.updated),
            "client_version": NullableSerializer(Serialization._StringSerializer).serialize(value.clientVersion),
            "os_version": NullableSerializer(Serialization._StringSerializer).serialize(value.osVersion),
            "last_carrier": NullableSerializer(Serialization._StringSerializer).serialize(value.lastCarrier),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> MobileClientSession {
            switch json {
                case .Dictionary(let dict):
                    let sessionId = Serialization._StringSerializer.deserialize(dict["session_id"] ?? .Null)
                    let deviceName = Serialization._StringSerializer.deserialize(dict["device_name"] ?? .Null)
                    let clientType = Team.MobileClientPlatformSerializer().deserialize(dict["client_type"] ?? .Null)
                    let ipAddress = NullableSerializer(Serialization._StringSerializer).deserialize(dict["ip_address"] ?? .Null)
                    let country = NullableSerializer(Serialization._StringSerializer).deserialize(dict["country"] ?? .Null)
                    let created = NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).deserialize(dict["created"] ?? .Null)
                    let updated = NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).deserialize(dict["updated"] ?? .Null)
                    let clientVersion = NullableSerializer(Serialization._StringSerializer).deserialize(dict["client_version"] ?? .Null)
                    let osVersion = NullableSerializer(Serialization._StringSerializer).deserialize(dict["os_version"] ?? .Null)
                    let lastCarrier = NullableSerializer(Serialization._StringSerializer).deserialize(dict["last_carrier"] ?? .Null)
                    return MobileClientSession(sessionId: sessionId, deviceName: deviceName, clientType: clientType, ipAddress: ipAddress, country: country, created: created, updated: updated, clientVersion: clientVersion, osVersion: osVersion, lastCarrier: lastCarrier)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The RemovedStatus struct
    public class RemovedStatus: CustomStringConvertible {
        /// True if the removed team member is recoverable
        public let isRecoverable: Bool
        public init(isRecoverable: Bool) {
            self.isRecoverable = isRecoverable
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(RemovedStatusSerializer().serialize(self)))"
        }
    }
    public class RemovedStatusSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: RemovedStatus) -> JSON {
            let output = [ 
            "is_recoverable": Serialization._BoolSerializer.serialize(value.isRecoverable),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> RemovedStatus {
            switch json {
                case .Dictionary(let dict):
                    let isRecoverable = Serialization._BoolSerializer.deserialize(dict["is_recoverable"] ?? .Null)
                    return RemovedStatus(isRecoverable: isRecoverable)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The RevokeDesktopClientArg struct
    public class RevokeDesktopClientArg: Team.DeviceSessionArg {
        /// Whether to delete all files of the account (this is possible only if supported by the desktop client and
        /// will be made the next time the client access the account)
        public let deleteOnUnlink: Bool
        public init(sessionId: String, teamMemberId: String, deleteOnUnlink: Bool = false) {
            self.deleteOnUnlink = deleteOnUnlink
            super.init(sessionId: sessionId, teamMemberId: teamMemberId)
        }
        public override var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(RevokeDesktopClientArgSerializer().serialize(self)))"
        }
    }
    public class RevokeDesktopClientArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: RevokeDesktopClientArg) -> JSON {
            let output = [ 
            "session_id": Serialization._StringSerializer.serialize(value.sessionId),
            "team_member_id": Serialization._StringSerializer.serialize(value.teamMemberId),
            "delete_on_unlink": Serialization._BoolSerializer.serialize(value.deleteOnUnlink),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> RevokeDesktopClientArg {
            switch json {
                case .Dictionary(let dict):
                    let sessionId = Serialization._StringSerializer.deserialize(dict["session_id"] ?? .Null)
                    let teamMemberId = Serialization._StringSerializer.deserialize(dict["team_member_id"] ?? .Null)
                    let deleteOnUnlink = Serialization._BoolSerializer.deserialize(dict["delete_on_unlink"] ?? .Null)
                    return RevokeDesktopClientArg(sessionId: sessionId, teamMemberId: teamMemberId, deleteOnUnlink: deleteOnUnlink)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The RevokeDeviceSessionArg union
    public enum RevokeDeviceSessionArg: CustomStringConvertible {
        /// End an active session
        case WebSession(Team.DeviceSessionArg)
        /// Unlink a linked desktop device
        case DesktopClient(Team.RevokeDesktopClientArg)
        /// Unlink a linked mobile device
        case MobileClient(Team.DeviceSessionArg)

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(RevokeDeviceSessionArgSerializer().serialize(self)))"
        }
    }
    public class RevokeDeviceSessionArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: RevokeDeviceSessionArg) -> JSON {
            switch value {
                case .WebSession(let arg):
                    var d = Serialization.getFields(Team.DeviceSessionArgSerializer().serialize(arg))
                    d[".tag"] = .Str("web_session")
                    return .Dictionary(d)
                case .DesktopClient(let arg):
                    var d = Serialization.getFields(Team.RevokeDesktopClientArgSerializer().serialize(arg))
                    d[".tag"] = .Str("desktop_client")
                    return .Dictionary(d)
                case .MobileClient(let arg):
                    var d = Serialization.getFields(Team.DeviceSessionArgSerializer().serialize(arg))
                    d[".tag"] = .Str("mobile_client")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> RevokeDeviceSessionArg {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "web_session":
                            let v = Team.DeviceSessionArgSerializer().deserialize(json)
                            return RevokeDeviceSessionArg.WebSession(v)
                        case "desktop_client":
                            let v = Team.RevokeDesktopClientArgSerializer().deserialize(json)
                            return RevokeDeviceSessionArg.DesktopClient(v)
                        case "mobile_client":
                            let v = Team.DeviceSessionArgSerializer().deserialize(json)
                            return RevokeDeviceSessionArg.MobileClient(v)
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The RevokeDeviceSessionBatchArg struct
    public class RevokeDeviceSessionBatchArg: CustomStringConvertible {
        /// (no description)
        public let revokeDevices: Array<Team.RevokeDeviceSessionArg>
        public init(revokeDevices: Array<Team.RevokeDeviceSessionArg>) {
            self.revokeDevices = revokeDevices
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(RevokeDeviceSessionBatchArgSerializer().serialize(self)))"
        }
    }
    public class RevokeDeviceSessionBatchArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: RevokeDeviceSessionBatchArg) -> JSON {
            let output = [ 
            "revoke_devices": ArraySerializer(Team.RevokeDeviceSessionArgSerializer()).serialize(value.revokeDevices),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> RevokeDeviceSessionBatchArg {
            switch json {
                case .Dictionary(let dict):
                    let revokeDevices = ArraySerializer(Team.RevokeDeviceSessionArgSerializer()).deserialize(dict["revoke_devices"] ?? .Null)
                    return RevokeDeviceSessionBatchArg(revokeDevices: revokeDevices)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The RevokeDeviceSessionBatchError union
    public enum RevokeDeviceSessionBatchError: CustomStringConvertible {
        /// An unspecified error.
        case Other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(RevokeDeviceSessionBatchErrorSerializer().serialize(self)))"
        }
    }
    public class RevokeDeviceSessionBatchErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: RevokeDeviceSessionBatchError) -> JSON {
            switch value {
                case .Other:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> RevokeDeviceSessionBatchError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "other":
                            return RevokeDeviceSessionBatchError.Other
                        default:
                            return RevokeDeviceSessionBatchError.Other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The RevokeDeviceSessionBatchResult struct
    public class RevokeDeviceSessionBatchResult: CustomStringConvertible {
        /// (no description)
        public let revokeDevicesStatus: Array<Team.RevokeDeviceSessionStatus>
        public init(revokeDevicesStatus: Array<Team.RevokeDeviceSessionStatus>) {
            self.revokeDevicesStatus = revokeDevicesStatus
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(RevokeDeviceSessionBatchResultSerializer().serialize(self)))"
        }
    }
    public class RevokeDeviceSessionBatchResultSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: RevokeDeviceSessionBatchResult) -> JSON {
            let output = [ 
            "revoke_devices_status": ArraySerializer(Team.RevokeDeviceSessionStatusSerializer()).serialize(value.revokeDevicesStatus),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> RevokeDeviceSessionBatchResult {
            switch json {
                case .Dictionary(let dict):
                    let revokeDevicesStatus = ArraySerializer(Team.RevokeDeviceSessionStatusSerializer()).deserialize(dict["revoke_devices_status"] ?? .Null)
                    return RevokeDeviceSessionBatchResult(revokeDevicesStatus: revokeDevicesStatus)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The RevokeDeviceSessionError union
    public enum RevokeDeviceSessionError: CustomStringConvertible {
        /// Device session not found.
        case DeviceSessionNotFound
        /// Member not found.
        case MemberNotFound
        /// An unspecified error.
        case Other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(RevokeDeviceSessionErrorSerializer().serialize(self)))"
        }
    }
    public class RevokeDeviceSessionErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: RevokeDeviceSessionError) -> JSON {
            switch value {
                case .DeviceSessionNotFound:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("device_session_not_found")
                    return .Dictionary(d)
                case .MemberNotFound:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("member_not_found")
                    return .Dictionary(d)
                case .Other:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> RevokeDeviceSessionError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "device_session_not_found":
                            return RevokeDeviceSessionError.DeviceSessionNotFound
                        case "member_not_found":
                            return RevokeDeviceSessionError.MemberNotFound
                        case "other":
                            return RevokeDeviceSessionError.Other
                        default:
                            return RevokeDeviceSessionError.Other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The RevokeDeviceSessionStatus struct
    public class RevokeDeviceSessionStatus: CustomStringConvertible {
        /// Result of the revoking request
        public let success: Bool
        /// The error cause in case of a failure
        public let errorType: Team.RevokeDeviceSessionError?
        public init(success: Bool, errorType: Team.RevokeDeviceSessionError? = nil) {
            self.success = success
            self.errorType = errorType
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(RevokeDeviceSessionStatusSerializer().serialize(self)))"
        }
    }
    public class RevokeDeviceSessionStatusSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: RevokeDeviceSessionStatus) -> JSON {
            let output = [ 
            "success": Serialization._BoolSerializer.serialize(value.success),
            "error_type": NullableSerializer(Team.RevokeDeviceSessionErrorSerializer()).serialize(value.errorType),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> RevokeDeviceSessionStatus {
            switch json {
                case .Dictionary(let dict):
                    let success = Serialization._BoolSerializer.deserialize(dict["success"] ?? .Null)
                    let errorType = NullableSerializer(Team.RevokeDeviceSessionErrorSerializer()).deserialize(dict["error_type"] ?? .Null)
                    return RevokeDeviceSessionStatus(success: success, errorType: errorType)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The RevokeLinkedApiAppArg struct
    public class RevokeLinkedApiAppArg: CustomStringConvertible {
        /// The application's unique id
        public let appId: String
        /// The unique id of the member owning the device
        public let teamMemberId: String
        /// Whether to keep the application dedicated folder (in case the application uses  one)
        public let keepAppFolder: Bool
        public init(appId: String, teamMemberId: String, keepAppFolder: Bool = true) {
            stringValidator()(appId)
            self.appId = appId
            stringValidator()(teamMemberId)
            self.teamMemberId = teamMemberId
            self.keepAppFolder = keepAppFolder
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(RevokeLinkedApiAppArgSerializer().serialize(self)))"
        }
    }
    public class RevokeLinkedApiAppArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: RevokeLinkedApiAppArg) -> JSON {
            let output = [ 
            "app_id": Serialization._StringSerializer.serialize(value.appId),
            "team_member_id": Serialization._StringSerializer.serialize(value.teamMemberId),
            "keep_app_folder": Serialization._BoolSerializer.serialize(value.keepAppFolder),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> RevokeLinkedApiAppArg {
            switch json {
                case .Dictionary(let dict):
                    let appId = Serialization._StringSerializer.deserialize(dict["app_id"] ?? .Null)
                    let teamMemberId = Serialization._StringSerializer.deserialize(dict["team_member_id"] ?? .Null)
                    let keepAppFolder = Serialization._BoolSerializer.deserialize(dict["keep_app_folder"] ?? .Null)
                    return RevokeLinkedApiAppArg(appId: appId, teamMemberId: teamMemberId, keepAppFolder: keepAppFolder)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The RevokeLinkedApiAppBatchArg struct
    public class RevokeLinkedApiAppBatchArg: CustomStringConvertible {
        /// (no description)
        public let revokeLinkedApp: Array<Team.RevokeLinkedApiAppArg>
        public init(revokeLinkedApp: Array<Team.RevokeLinkedApiAppArg>) {
            self.revokeLinkedApp = revokeLinkedApp
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(RevokeLinkedApiAppBatchArgSerializer().serialize(self)))"
        }
    }
    public class RevokeLinkedApiAppBatchArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: RevokeLinkedApiAppBatchArg) -> JSON {
            let output = [ 
            "revoke_linked_app": ArraySerializer(Team.RevokeLinkedApiAppArgSerializer()).serialize(value.revokeLinkedApp),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> RevokeLinkedApiAppBatchArg {
            switch json {
                case .Dictionary(let dict):
                    let revokeLinkedApp = ArraySerializer(Team.RevokeLinkedApiAppArgSerializer()).deserialize(dict["revoke_linked_app"] ?? .Null)
                    return RevokeLinkedApiAppBatchArg(revokeLinkedApp: revokeLinkedApp)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Error returned by linkedAppsRevokeLinkedAppBatch.
    public enum RevokeLinkedAppBatchError: CustomStringConvertible {
        /// An unspecified error.
        case Other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(RevokeLinkedAppBatchErrorSerializer().serialize(self)))"
        }
    }
    public class RevokeLinkedAppBatchErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: RevokeLinkedAppBatchError) -> JSON {
            switch value {
                case .Other:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> RevokeLinkedAppBatchError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "other":
                            return RevokeLinkedAppBatchError.Other
                        default:
                            return RevokeLinkedAppBatchError.Other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The RevokeLinkedAppBatchResult struct
    public class RevokeLinkedAppBatchResult: CustomStringConvertible {
        /// (no description)
        public let revokeLinkedAppStatus: Array<Team.RevokeLinkedAppStatus>
        public init(revokeLinkedAppStatus: Array<Team.RevokeLinkedAppStatus>) {
            self.revokeLinkedAppStatus = revokeLinkedAppStatus
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(RevokeLinkedAppBatchResultSerializer().serialize(self)))"
        }
    }
    public class RevokeLinkedAppBatchResultSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: RevokeLinkedAppBatchResult) -> JSON {
            let output = [ 
            "revoke_linked_app_status": ArraySerializer(Team.RevokeLinkedAppStatusSerializer()).serialize(value.revokeLinkedAppStatus),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> RevokeLinkedAppBatchResult {
            switch json {
                case .Dictionary(let dict):
                    let revokeLinkedAppStatus = ArraySerializer(Team.RevokeLinkedAppStatusSerializer()).deserialize(dict["revoke_linked_app_status"] ?? .Null)
                    return RevokeLinkedAppBatchResult(revokeLinkedAppStatus: revokeLinkedAppStatus)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Error returned by linkedAppsRevokeLinkedApp.
    public enum RevokeLinkedAppError: CustomStringConvertible {
        /// Application not found.
        case AppNotFound
        /// Member not found.
        case MemberNotFound
        /// An unspecified error.
        case Other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(RevokeLinkedAppErrorSerializer().serialize(self)))"
        }
    }
    public class RevokeLinkedAppErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: RevokeLinkedAppError) -> JSON {
            switch value {
                case .AppNotFound:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("app_not_found")
                    return .Dictionary(d)
                case .MemberNotFound:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("member_not_found")
                    return .Dictionary(d)
                case .Other:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> RevokeLinkedAppError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "app_not_found":
                            return RevokeLinkedAppError.AppNotFound
                        case "member_not_found":
                            return RevokeLinkedAppError.MemberNotFound
                        case "other":
                            return RevokeLinkedAppError.Other
                        default:
                            return RevokeLinkedAppError.Other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The RevokeLinkedAppStatus struct
    public class RevokeLinkedAppStatus: CustomStringConvertible {
        /// Result of the revoking request
        public let success: Bool
        /// The error cause in case of a failure
        public let errorType: Team.RevokeLinkedAppError?
        public init(success: Bool, errorType: Team.RevokeLinkedAppError? = nil) {
            self.success = success
            self.errorType = errorType
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(RevokeLinkedAppStatusSerializer().serialize(self)))"
        }
    }
    public class RevokeLinkedAppStatusSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: RevokeLinkedAppStatus) -> JSON {
            let output = [ 
            "success": Serialization._BoolSerializer.serialize(value.success),
            "error_type": NullableSerializer(Team.RevokeLinkedAppErrorSerializer()).serialize(value.errorType),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> RevokeLinkedAppStatus {
            switch json {
                case .Dictionary(let dict):
                    let success = Serialization._BoolSerializer.deserialize(dict["success"] ?? .Null)
                    let errorType = NullableSerializer(Team.RevokeLinkedAppErrorSerializer()).deserialize(dict["error_type"] ?? .Null)
                    return RevokeLinkedAppStatus(success: success, errorType: errorType)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Describes the number of users in a specific storage bucket.
    public class StorageBucket: CustomStringConvertible {
        /// The name of the storage bucket. For example, '1G' is a bucket of users with storage size up to 1 Giga.
        public let bucket: String
        /// The number of people whose storage is in the range of this storage bucket.
        public let users: UInt64
        public init(bucket: String, users: UInt64) {
            stringValidator()(bucket)
            self.bucket = bucket
            comparableValidator()(users)
            self.users = users
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(StorageBucketSerializer().serialize(self)))"
        }
    }
    public class StorageBucketSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: StorageBucket) -> JSON {
            let output = [ 
            "bucket": Serialization._StringSerializer.serialize(value.bucket),
            "users": Serialization._UInt64Serializer.serialize(value.users),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> StorageBucket {
            switch json {
                case .Dictionary(let dict):
                    let bucket = Serialization._StringSerializer.deserialize(dict["bucket"] ?? .Null)
                    let users = Serialization._UInt64Serializer.deserialize(dict["users"] ?? .Null)
                    return StorageBucket(bucket: bucket, users: users)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The TeamGetInfoResult struct
    public class TeamGetInfoResult: CustomStringConvertible {
        /// The name of the team.
        public let name: String
        /// The ID of the team.
        public let teamId: String
        /// The number of licenses available to the team.
        public let numLicensedUsers: UInt32
        /// The number of accounts that have been invited or are already active members of the team.
        public let numProvisionedUsers: UInt32
        /// (no description)
        public let policies: TeamPolicies.TeamMemberPolicies
        public init(name: String, teamId: String, numLicensedUsers: UInt32, numProvisionedUsers: UInt32, policies: TeamPolicies.TeamMemberPolicies) {
            stringValidator()(name)
            self.name = name
            stringValidator()(teamId)
            self.teamId = teamId
            comparableValidator()(numLicensedUsers)
            self.numLicensedUsers = numLicensedUsers
            comparableValidator()(numProvisionedUsers)
            self.numProvisionedUsers = numProvisionedUsers
            self.policies = policies
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(TeamGetInfoResultSerializer().serialize(self)))"
        }
    }
    public class TeamGetInfoResultSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: TeamGetInfoResult) -> JSON {
            let output = [ 
            "name": Serialization._StringSerializer.serialize(value.name),
            "team_id": Serialization._StringSerializer.serialize(value.teamId),
            "num_licensed_users": Serialization._UInt32Serializer.serialize(value.numLicensedUsers),
            "num_provisioned_users": Serialization._UInt32Serializer.serialize(value.numProvisionedUsers),
            "policies": TeamPolicies.TeamMemberPoliciesSerializer().serialize(value.policies),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> TeamGetInfoResult {
            switch json {
                case .Dictionary(let dict):
                    let name = Serialization._StringSerializer.deserialize(dict["name"] ?? .Null)
                    let teamId = Serialization._StringSerializer.deserialize(dict["team_id"] ?? .Null)
                    let numLicensedUsers = Serialization._UInt32Serializer.deserialize(dict["num_licensed_users"] ?? .Null)
                    let numProvisionedUsers = Serialization._UInt32Serializer.deserialize(dict["num_provisioned_users"] ?? .Null)
                    let policies = TeamPolicies.TeamMemberPoliciesSerializer().deserialize(dict["policies"] ?? .Null)
                    return TeamGetInfoResult(name: name, teamId: teamId, numLicensedUsers: numLicensedUsers, numProvisionedUsers: numProvisionedUsers, policies: policies)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Information about a team member.
    public class TeamMemberInfo: CustomStringConvertible {
        /// Profile of a user as a member of a team.
        public let profile: Team.TeamMemberProfile
        /// The user's role in the team.
        public let role: Team.AdminTier
        public init(profile: Team.TeamMemberProfile, role: Team.AdminTier) {
            self.profile = profile
            self.role = role
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(TeamMemberInfoSerializer().serialize(self)))"
        }
    }
    public class TeamMemberInfoSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: TeamMemberInfo) -> JSON {
            let output = [ 
            "profile": Team.TeamMemberProfileSerializer().serialize(value.profile),
            "role": Team.AdminTierSerializer().serialize(value.role),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> TeamMemberInfo {
            switch json {
                case .Dictionary(let dict):
                    let profile = Team.TeamMemberProfileSerializer().deserialize(dict["profile"] ?? .Null)
                    let role = Team.AdminTierSerializer().deserialize(dict["role"] ?? .Null)
                    return TeamMemberInfo(profile: profile, role: role)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Profile of a user as a member of a team.
    public class TeamMemberProfile: Team.MemberProfile {
        /// List of group IDs of groups that the user belongs to.
        public let groups: Array<String>
        public init(teamMemberId: String, email: String, emailVerified: Bool, status: Team.TeamMemberStatus, name: Users.Name, membershipType: Team.TeamMembershipType, groups: Array<String>, externalId: String? = nil, accountId: String? = nil) {
            arrayValidator(itemValidator: stringValidator())(groups)
            self.groups = groups
            super.init(teamMemberId: teamMemberId, email: email, emailVerified: emailVerified, status: status, name: name, membershipType: membershipType, externalId: externalId, accountId: accountId)
        }
        public override var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(TeamMemberProfileSerializer().serialize(self)))"
        }
    }
    public class TeamMemberProfileSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: TeamMemberProfile) -> JSON {
            let output = [ 
            "team_member_id": Serialization._StringSerializer.serialize(value.teamMemberId),
            "email": Serialization._StringSerializer.serialize(value.email),
            "email_verified": Serialization._BoolSerializer.serialize(value.emailVerified),
            "status": Team.TeamMemberStatusSerializer().serialize(value.status),
            "name": Users.NameSerializer().serialize(value.name),
            "membership_type": Team.TeamMembershipTypeSerializer().serialize(value.membershipType),
            "groups": ArraySerializer(Serialization._StringSerializer).serialize(value.groups),
            "external_id": NullableSerializer(Serialization._StringSerializer).serialize(value.externalId),
            "account_id": NullableSerializer(Serialization._StringSerializer).serialize(value.accountId),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> TeamMemberProfile {
            switch json {
                case .Dictionary(let dict):
                    let teamMemberId = Serialization._StringSerializer.deserialize(dict["team_member_id"] ?? .Null)
                    let email = Serialization._StringSerializer.deserialize(dict["email"] ?? .Null)
                    let emailVerified = Serialization._BoolSerializer.deserialize(dict["email_verified"] ?? .Null)
                    let status = Team.TeamMemberStatusSerializer().deserialize(dict["status"] ?? .Null)
                    let name = Users.NameSerializer().deserialize(dict["name"] ?? .Null)
                    let membershipType = Team.TeamMembershipTypeSerializer().deserialize(dict["membership_type"] ?? .Null)
                    let groups = ArraySerializer(Serialization._StringSerializer).deserialize(dict["groups"] ?? .Null)
                    let externalId = NullableSerializer(Serialization._StringSerializer).deserialize(dict["external_id"] ?? .Null)
                    let accountId = NullableSerializer(Serialization._StringSerializer).deserialize(dict["account_id"] ?? .Null)
                    return TeamMemberProfile(teamMemberId: teamMemberId, email: email, emailVerified: emailVerified, status: status, name: name, membershipType: membershipType, groups: groups, externalId: externalId, accountId: accountId)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The user's status as a member of a specific team.
    public enum TeamMemberStatus: CustomStringConvertible {
        /// User has successfully joined the team.
        case Active
        /// User has been invited to a team, but has not joined the team yet.
        case Invited
        /// User is no longer a member of the team, but the account can be un-suspended, re-establishing the user as a
        /// team member.
        case Suspended
        /// User is no longer a member of the team. Removed users are only listed when include_removed is true in
        /// members/list.
        case Removed(Team.RemovedStatus)

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(TeamMemberStatusSerializer().serialize(self)))"
        }
    }
    public class TeamMemberStatusSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: TeamMemberStatus) -> JSON {
            switch value {
                case .Active:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("active")
                    return .Dictionary(d)
                case .Invited:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("invited")
                    return .Dictionary(d)
                case .Suspended:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("suspended")
                    return .Dictionary(d)
                case .Removed(let arg):
                    var d = Serialization.getFields(Team.RemovedStatusSerializer().serialize(arg))
                    d[".tag"] = .Str("removed")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> TeamMemberStatus {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "active":
                            return TeamMemberStatus.Active
                        case "invited":
                            return TeamMemberStatus.Invited
                        case "suspended":
                            return TeamMemberStatus.Suspended
                        case "removed":
                            let v = Team.RemovedStatusSerializer().deserialize(json)
                            return TeamMemberStatus.Removed(v)
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The TeamMembershipType union
    public enum TeamMembershipType: CustomStringConvertible {
        /// User uses a license and has full access to team resources like the shared quota.
        case Full
        /// User does not have access to the shared quota and team admins have restricted administrative control.
        case Limited

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(TeamMembershipTypeSerializer().serialize(self)))"
        }
    }
    public class TeamMembershipTypeSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: TeamMembershipType) -> JSON {
            switch value {
                case .Full:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("full")
                    return .Dictionary(d)
                case .Limited:
                    var d = [String: JSON]()
                    d[".tag"] = .Str("limited")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> TeamMembershipType {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "full":
                            return TeamMembershipType.Full
                        case "limited":
                            return TeamMembershipType.Limited
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The UpdatePropertyTemplateArg struct
    public class UpdatePropertyTemplateArg: CustomStringConvertible {
        /// An identifier for property template added by propertiesTemplateAdd.
        public let templateId: String
        /// A display name for the property template. Property template names can be up to 256 bytes.
        public let name: String?
        /// Description for new property template. Property template descriptions can be up to 1024 bytes.
        public let description_: String?
        /// This is a list of custom properties to add to the property template. There can be up to 64 properties in a
        /// single property template.
        public let addFields: Array<Properties.PropertyFieldTemplate>?
        public init(templateId: String, name: String? = nil, description_: String? = nil, addFields: Array<Properties.PropertyFieldTemplate>? = nil) {
            stringValidator(minLength: 1, pattern: "(/|ptid:).*")(templateId)
            self.templateId = templateId
            nullableValidator(stringValidator())(name)
            self.name = name
            nullableValidator(stringValidator())(description_)
            self.description_ = description_
            self.addFields = addFields
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(UpdatePropertyTemplateArgSerializer().serialize(self)))"
        }
    }
    public class UpdatePropertyTemplateArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: UpdatePropertyTemplateArg) -> JSON {
            let output = [ 
            "template_id": Serialization._StringSerializer.serialize(value.templateId),
            "name": NullableSerializer(Serialization._StringSerializer).serialize(value.name),
            "description": NullableSerializer(Serialization._StringSerializer).serialize(value.description_),
            "add_fields": NullableSerializer(ArraySerializer(Properties.PropertyFieldTemplateSerializer())).serialize(value.addFields),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> UpdatePropertyTemplateArg {
            switch json {
                case .Dictionary(let dict):
                    let templateId = Serialization._StringSerializer.deserialize(dict["template_id"] ?? .Null)
                    let name = NullableSerializer(Serialization._StringSerializer).deserialize(dict["name"] ?? .Null)
                    let description_ = NullableSerializer(Serialization._StringSerializer).deserialize(dict["description"] ?? .Null)
                    let addFields = NullableSerializer(ArraySerializer(Properties.PropertyFieldTemplateSerializer())).deserialize(dict["add_fields"] ?? .Null)
                    return UpdatePropertyTemplateArg(templateId: templateId, name: name, description_: description_, addFields: addFields)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The UpdatePropertyTemplateResult struct
    public class UpdatePropertyTemplateResult: CustomStringConvertible {
        /// An identifier for property template added by propertiesTemplateAdd.
        public let templateId: String
        public init(templateId: String) {
            stringValidator(minLength: 1, pattern: "(/|ptid:).*")(templateId)
            self.templateId = templateId
        }
        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(UpdatePropertyTemplateResultSerializer().serialize(self)))"
        }
    }
    public class UpdatePropertyTemplateResultSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: UpdatePropertyTemplateResult) -> JSON {
            let output = [ 
            "template_id": Serialization._StringSerializer.serialize(value.templateId),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> UpdatePropertyTemplateResult {
            switch json {
                case .Dictionary(let dict):
                    let templateId = Serialization._StringSerializer.deserialize(dict["template_id"] ?? .Null)
                    return UpdatePropertyTemplateResult(templateId: templateId)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Argument for selecting a single user, either by team_member_id, external_id or email.
    public enum UserSelectorArg: CustomStringConvertible {
        /// An unspecified error.
        case TeamMemberId(String)
        /// An unspecified error.
        case ExternalId(String)
        /// An unspecified error.
        case Email(String)

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(UserSelectorArgSerializer().serialize(self)))"
        }
    }
    public class UserSelectorArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: UserSelectorArg) -> JSON {
            switch value {
                case .TeamMemberId(let arg):
                    var d = ["team_member_id": Serialization._StringSerializer.serialize(arg)]
                    d[".tag"] = .Str("team_member_id")
                    return .Dictionary(d)
                case .ExternalId(let arg):
                    var d = ["external_id": Serialization._StringSerializer.serialize(arg)]
                    d[".tag"] = .Str("external_id")
                    return .Dictionary(d)
                case .Email(let arg):
                    var d = ["email": Serialization._StringSerializer.serialize(arg)]
                    d[".tag"] = .Str("email")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> UserSelectorArg {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "team_member_id":
                            let v = Serialization._StringSerializer.deserialize(d["team_member_id"] ?? .Null)
                            return UserSelectorArg.TeamMemberId(v)
                        case "external_id":
                            let v = Serialization._StringSerializer.deserialize(d["external_id"] ?? .Null)
                            return UserSelectorArg.ExternalId(v)
                        case "email":
                            let v = Serialization._StringSerializer.deserialize(d["email"] ?? .Null)
                            return UserSelectorArg.Email(v)
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Argument for selecting a list of users, either by team_member_ids, external_ids or emails.
    public enum UsersSelectorArg: CustomStringConvertible {
        /// List of member IDs.
        case TeamMemberIds(Array<String>)
        /// List of external user IDs.
        case ExternalIds(Array<String>)
        /// List of email addresses.
        case Emails(Array<String>)

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(UsersSelectorArgSerializer().serialize(self)))"
        }
    }
    public class UsersSelectorArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: UsersSelectorArg) -> JSON {
            switch value {
                case .TeamMemberIds(let arg):
                    var d = ["team_member_ids": ArraySerializer(Serialization._StringSerializer).serialize(arg)]
                    d[".tag"] = .Str("team_member_ids")
                    return .Dictionary(d)
                case .ExternalIds(let arg):
                    var d = ["external_ids": ArraySerializer(Serialization._StringSerializer).serialize(arg)]
                    d[".tag"] = .Str("external_ids")
                    return .Dictionary(d)
                case .Emails(let arg):
                    var d = ["emails": ArraySerializer(Serialization._StringSerializer).serialize(arg)]
                    d[".tag"] = .Str("emails")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> UsersSelectorArg {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "team_member_ids":
                            let v = ArraySerializer(Serialization._StringSerializer).deserialize(d["team_member_ids"] ?? .Null)
                            return UsersSelectorArg.TeamMemberIds(v)
                        case "external_ids":
                            let v = ArraySerializer(Serialization._StringSerializer).deserialize(d["external_ids"] ?? .Null)
                            return UsersSelectorArg.ExternalIds(v)
                        case "emails":
                            let v = ArraySerializer(Serialization._StringSerializer).deserialize(d["emails"] ?? .Null)
                            return UsersSelectorArg.Emails(v)
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }


    /// Stone Route Objects

    static let alphaGroupsCreate = Route(
        name: "alpha/groups/create",
        namespace: "team",
        deprecated: false,
        argSerializer: Team.GroupCreateArgSerializer(),
        responseSerializer: Team.GroupFullInfoSerializer(),
        errorSerializer: Team.GroupCreateErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let alphaGroupsGetInfo = Route(
        name: "alpha/groups/get_info",
        namespace: "team",
        deprecated: false,
        argSerializer: Team.GroupsSelectorSerializer(),
        responseSerializer: ArraySerializer(Team.GroupsGetInfoItemSerializer()),
        errorSerializer: Team.GroupsGetInfoErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let alphaGroupsList = Route(
        name: "alpha/groups/list",
        namespace: "team",
        deprecated: false,
        argSerializer: Team.GroupsListArgSerializer(),
        responseSerializer: Team.GroupsListResultSerializer(),
        errorSerializer: Serialization._VoidSerializer,
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let alphaGroupsListContinue = Route(
        name: "alpha/groups/list/continue",
        namespace: "team",
        deprecated: false,
        argSerializer: Team.GroupsListContinueArgSerializer(),
        responseSerializer: Team.GroupsListResultSerializer(),
        errorSerializer: Team.GroupsListContinueErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let alphaGroupsUpdate = Route(
        name: "alpha/groups/update",
        namespace: "team",
        deprecated: false,
        argSerializer: Team.GroupUpdateArgsSerializer(),
        responseSerializer: Team.GroupFullInfoSerializer(),
        errorSerializer: Team.GroupUpdateErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let devicesListMemberDevices = Route(
        name: "devices/list_member_devices",
        namespace: "team",
        deprecated: false,
        argSerializer: Team.ListMemberDevicesArgSerializer(),
        responseSerializer: Team.ListMemberDevicesResultSerializer(),
        errorSerializer: Team.ListMemberDevicesErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let devicesListMembersDevices = Route(
        name: "devices/list_members_devices",
        namespace: "team",
        deprecated: false,
        argSerializer: Team.ListMembersDevicesArgSerializer(),
        responseSerializer: Team.ListMembersDevicesResultSerializer(),
        errorSerializer: Team.ListMembersDevicesErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let devicesListTeamDevices = Route(
        name: "devices/list_team_devices",
        namespace: "team",
        deprecated: true,
        argSerializer: Team.ListTeamDevicesArgSerializer(),
        responseSerializer: Team.ListTeamDevicesResultSerializer(),
        errorSerializer: Team.ListTeamDevicesErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let devicesRevokeDeviceSession = Route(
        name: "devices/revoke_device_session",
        namespace: "team",
        deprecated: false,
        argSerializer: Team.RevokeDeviceSessionArgSerializer(),
        responseSerializer: Serialization._VoidSerializer,
        errorSerializer: Team.RevokeDeviceSessionErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let devicesRevokeDeviceSessionBatch = Route(
        name: "devices/revoke_device_session_batch",
        namespace: "team",
        deprecated: false,
        argSerializer: Team.RevokeDeviceSessionBatchArgSerializer(),
        responseSerializer: Team.RevokeDeviceSessionBatchResultSerializer(),
        errorSerializer: Team.RevokeDeviceSessionBatchErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let getInfo = Route(
        name: "get_info",
        namespace: "team",
        deprecated: false,
        argSerializer: Serialization._VoidSerializer,
        responseSerializer: Team.TeamGetInfoResultSerializer(),
        errorSerializer: Serialization._VoidSerializer,
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let groupsCreate = Route(
        name: "groups/create",
        namespace: "team",
        deprecated: false,
        argSerializer: Team.GroupCreateArgSerializer(),
        responseSerializer: Team.GroupFullInfoSerializer(),
        errorSerializer: Team.GroupCreateErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let groupsDelete = Route(
        name: "groups/delete",
        namespace: "team",
        deprecated: false,
        argSerializer: Team.GroupSelectorSerializer(),
        responseSerializer: Async.LaunchEmptyResultSerializer(),
        errorSerializer: Team.GroupDeleteErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let groupsGetInfo = Route(
        name: "groups/get_info",
        namespace: "team",
        deprecated: false,
        argSerializer: Team.GroupsSelectorSerializer(),
        responseSerializer: ArraySerializer(Team.GroupsGetInfoItemSerializer()),
        errorSerializer: Team.GroupsGetInfoErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let groupsJobStatusGet = Route(
        name: "groups/job_status/get",
        namespace: "team",
        deprecated: false,
        argSerializer: Async.PollArgSerializer(),
        responseSerializer: Async.PollEmptyResultSerializer(),
        errorSerializer: Team.GroupsPollErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let groupsList = Route(
        name: "groups/list",
        namespace: "team",
        deprecated: false,
        argSerializer: Team.GroupsListArgSerializer(),
        responseSerializer: Team.GroupsListResultSerializer(),
        errorSerializer: Serialization._VoidSerializer,
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let groupsListContinue = Route(
        name: "groups/list/continue",
        namespace: "team",
        deprecated: false,
        argSerializer: Team.GroupsListContinueArgSerializer(),
        responseSerializer: Team.GroupsListResultSerializer(),
        errorSerializer: Team.GroupsListContinueErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let groupsMembersAdd = Route(
        name: "groups/members/add",
        namespace: "team",
        deprecated: false,
        argSerializer: Team.GroupMembersAddArgSerializer(),
        responseSerializer: Team.GroupMembersChangeResultSerializer(),
        errorSerializer: Team.GroupMembersAddErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let groupsMembersList = Route(
        name: "groups/members/list",
        namespace: "team",
        deprecated: false,
        argSerializer: Team.GroupsMembersListArgSerializer(),
        responseSerializer: Team.GroupsMembersListResultSerializer(),
        errorSerializer: Team.GroupSelectorErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let groupsMembersListContinue = Route(
        name: "groups/members/list/continue",
        namespace: "team",
        deprecated: false,
        argSerializer: Team.GroupsMembersListContinueArgSerializer(),
        responseSerializer: Team.GroupsMembersListResultSerializer(),
        errorSerializer: Team.GroupsMembersListContinueErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let groupsMembersRemove = Route(
        name: "groups/members/remove",
        namespace: "team",
        deprecated: false,
        argSerializer: Team.GroupMembersRemoveArgSerializer(),
        responseSerializer: Team.GroupMembersChangeResultSerializer(),
        errorSerializer: Team.GroupMembersRemoveErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let groupsMembersSetAccessType = Route(
        name: "groups/members/set_access_type",
        namespace: "team",
        deprecated: false,
        argSerializer: Team.GroupMembersSetAccessTypeArgSerializer(),
        responseSerializer: ArraySerializer(Team.GroupsGetInfoItemSerializer()),
        errorSerializer: Team.GroupMemberSetAccessTypeErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let groupsUpdate = Route(
        name: "groups/update",
        namespace: "team",
        deprecated: false,
        argSerializer: Team.GroupUpdateArgsSerializer(),
        responseSerializer: Team.GroupFullInfoSerializer(),
        errorSerializer: Team.GroupUpdateErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let linkedAppsListMemberLinkedApps = Route(
        name: "linked_apps/list_member_linked_apps",
        namespace: "team",
        deprecated: false,
        argSerializer: Team.ListMemberAppsArgSerializer(),
        responseSerializer: Team.ListMemberAppsResultSerializer(),
        errorSerializer: Team.ListMemberAppsErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let linkedAppsListMembersLinkedApps = Route(
        name: "linked_apps/list_members_linked_apps",
        namespace: "team",
        deprecated: false,
        argSerializer: Team.ListMembersAppsArgSerializer(),
        responseSerializer: Team.ListMembersAppsResultSerializer(),
        errorSerializer: Team.ListMembersAppsErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let linkedAppsListTeamLinkedApps = Route(
        name: "linked_apps/list_team_linked_apps",
        namespace: "team",
        deprecated: true,
        argSerializer: Team.ListTeamAppsArgSerializer(),
        responseSerializer: Team.ListTeamAppsResultSerializer(),
        errorSerializer: Team.ListTeamAppsErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let linkedAppsRevokeLinkedApp = Route(
        name: "linked_apps/revoke_linked_app",
        namespace: "team",
        deprecated: false,
        argSerializer: Team.RevokeLinkedApiAppArgSerializer(),
        responseSerializer: Serialization._VoidSerializer,
        errorSerializer: Team.RevokeLinkedAppErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let linkedAppsRevokeLinkedAppBatch = Route(
        name: "linked_apps/revoke_linked_app_batch",
        namespace: "team",
        deprecated: false,
        argSerializer: Team.RevokeLinkedApiAppBatchArgSerializer(),
        responseSerializer: Team.RevokeLinkedAppBatchResultSerializer(),
        errorSerializer: Team.RevokeLinkedAppBatchErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let membersAdd = Route(
        name: "members/add",
        namespace: "team",
        deprecated: false,
        argSerializer: Team.MembersAddArgSerializer(),
        responseSerializer: Team.MembersAddLaunchSerializer(),
        errorSerializer: Serialization._VoidSerializer,
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let membersAddJobStatusGet = Route(
        name: "members/add/job_status/get",
        namespace: "team",
        deprecated: false,
        argSerializer: Async.PollArgSerializer(),
        responseSerializer: Team.MembersAddJobStatusSerializer(),
        errorSerializer: Async.PollErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let membersGetInfo = Route(
        name: "members/get_info",
        namespace: "team",
        deprecated: false,
        argSerializer: Team.MembersGetInfoArgsSerializer(),
        responseSerializer: ArraySerializer(Team.MembersGetInfoItemSerializer()),
        errorSerializer: Team.MembersGetInfoErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let membersList = Route(
        name: "members/list",
        namespace: "team",
        deprecated: false,
        argSerializer: Team.MembersListArgSerializer(),
        responseSerializer: Team.MembersListResultSerializer(),
        errorSerializer: Team.MembersListErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let membersListContinue = Route(
        name: "members/list/continue",
        namespace: "team",
        deprecated: false,
        argSerializer: Team.MembersListContinueArgSerializer(),
        responseSerializer: Team.MembersListResultSerializer(),
        errorSerializer: Team.MembersListContinueErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let membersRecover = Route(
        name: "members/recover",
        namespace: "team",
        deprecated: false,
        argSerializer: Team.MembersRecoverArgSerializer(),
        responseSerializer: Serialization._VoidSerializer,
        errorSerializer: Team.MembersRecoverErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let membersRemove = Route(
        name: "members/remove",
        namespace: "team",
        deprecated: false,
        argSerializer: Team.MembersRemoveArgSerializer(),
        responseSerializer: Async.LaunchEmptyResultSerializer(),
        errorSerializer: Team.MembersRemoveErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let membersRemoveJobStatusGet = Route(
        name: "members/remove/job_status/get",
        namespace: "team",
        deprecated: false,
        argSerializer: Async.PollArgSerializer(),
        responseSerializer: Async.PollEmptyResultSerializer(),
        errorSerializer: Async.PollErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let membersSendWelcomeEmail = Route(
        name: "members/send_welcome_email",
        namespace: "team",
        deprecated: false,
        argSerializer: Team.UserSelectorArgSerializer(),
        responseSerializer: Serialization._VoidSerializer,
        errorSerializer: Team.MembersSendWelcomeErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let membersSetAdminPermissions = Route(
        name: "members/set_admin_permissions",
        namespace: "team",
        deprecated: false,
        argSerializer: Team.MembersSetPermissionsArgSerializer(),
        responseSerializer: Team.MembersSetPermissionsResultSerializer(),
        errorSerializer: Team.MembersSetPermissionsErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let membersSetProfile = Route(
        name: "members/set_profile",
        namespace: "team",
        deprecated: false,
        argSerializer: Team.MembersSetProfileArgSerializer(),
        responseSerializer: Team.TeamMemberInfoSerializer(),
        errorSerializer: Team.MembersSetProfileErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let membersSuspend = Route(
        name: "members/suspend",
        namespace: "team",
        deprecated: false,
        argSerializer: Team.MembersDeactivateArgSerializer(),
        responseSerializer: Serialization._VoidSerializer,
        errorSerializer: Team.MembersSuspendErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let membersUnsuspend = Route(
        name: "members/unsuspend",
        namespace: "team",
        deprecated: false,
        argSerializer: Team.MembersUnsuspendArgSerializer(),
        responseSerializer: Serialization._VoidSerializer,
        errorSerializer: Team.MembersUnsuspendErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let propertiesTemplateAdd = Route(
        name: "properties/template/add",
        namespace: "team",
        deprecated: false,
        argSerializer: Team.AddPropertyTemplateArgSerializer(),
        responseSerializer: Team.AddPropertyTemplateResultSerializer(),
        errorSerializer: Properties.ModifyPropertyTemplateErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let propertiesTemplateGet = Route(
        name: "properties/template/get",
        namespace: "team",
        deprecated: false,
        argSerializer: Properties.GetPropertyTemplateArgSerializer(),
        responseSerializer: Properties.GetPropertyTemplateResultSerializer(),
        errorSerializer: Properties.PropertyTemplateErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let propertiesTemplateList = Route(
        name: "properties/template/list",
        namespace: "team",
        deprecated: false,
        argSerializer: Serialization._VoidSerializer,
        responseSerializer: Properties.ListPropertyTemplateIdsSerializer(),
        errorSerializer: Properties.PropertyTemplateErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let propertiesTemplateUpdate = Route(
        name: "properties/template/update",
        namespace: "team",
        deprecated: false,
        argSerializer: Team.UpdatePropertyTemplateArgSerializer(),
        responseSerializer: Team.UpdatePropertyTemplateResultSerializer(),
        errorSerializer: Properties.ModifyPropertyTemplateErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let reportsGetActivity = Route(
        name: "reports/get_activity",
        namespace: "team",
        deprecated: false,
        argSerializer: Team.DateRangeSerializer(),
        responseSerializer: Team.GetActivityReportSerializer(),
        errorSerializer: Team.DateRangeErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let reportsGetDevices = Route(
        name: "reports/get_devices",
        namespace: "team",
        deprecated: false,
        argSerializer: Team.DateRangeSerializer(),
        responseSerializer: Team.GetDevicesReportSerializer(),
        errorSerializer: Team.DateRangeErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let reportsGetMembership = Route(
        name: "reports/get_membership",
        namespace: "team",
        deprecated: false,
        argSerializer: Team.DateRangeSerializer(),
        responseSerializer: Team.GetMembershipReportSerializer(),
        errorSerializer: Team.DateRangeErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let reportsGetStorage = Route(
        name: "reports/get_storage",
        namespace: "team",
        deprecated: false,
        argSerializer: Team.DateRangeSerializer(),
        responseSerializer: Team.GetStorageReportSerializer(),
        errorSerializer: Team.DateRangeErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
}
