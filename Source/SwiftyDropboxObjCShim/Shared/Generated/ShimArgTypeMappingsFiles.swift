///
/// Copyright (c) 2024 Dropbox, Inc. All rights reserved.
///
/// Auto-generated by Stone, do not modify.
///

import Foundation
import stone_sdk_objc
import stone_sdk_swift
import stone_sdk_swift_objc

func mapDBFILESAddTagArgToDBXOptional(object: DBFILESAddTagArg?) -> DBXFilesAddTagArg? {
    guard let object = object else { return nil }
    return mapDBFILESAddTagArgToDBX(object: object)
}

func mapDBFILESAddTagArgToDBX(object: DBFILESAddTagArg) -> DBXFilesAddTagArg {
    DBXFilesAddTagArg(path: object.path, tagText: object.tagText)
}

func mapDBFILESBaseTagErrorToDBXOptional(object: DBFILESBaseTagError?) -> DBXFilesBaseTagError? {
    guard let object = object else { return nil }
    return mapDBFILESBaseTagErrorToDBX(object: object)
}

func mapDBFILESBaseTagErrorToDBX(object: DBFILESBaseTagError) -> DBXFilesBaseTagError {
    if object.isPath() {
        let path = mapDBFILESLookupErrorToDBX(object: object.path)
        return DBXFilesBaseTagError.factory(swift: .path(path.swift))
    }
    if object.isOther() {
        return DBXFilesBaseTagErrorOther()
    }
    fatalError("codegen error")
}

func mapDBFILESAddTagErrorToDBXOptional(object: DBFILESAddTagError?) -> DBXFilesAddTagError? {
    guard let object = object else { return nil }
    return mapDBFILESAddTagErrorToDBX(object: object)
}

func mapDBFILESAddTagErrorToDBX(object: DBFILESAddTagError) -> DBXFilesAddTagError {
    if object.isPath() {
        let path = mapDBFILESLookupErrorToDBX(object: object.path)
        return DBXFilesAddTagError.factory(swift: .path(path.swift))
    }
    if object.isOther() {
        return DBXFilesAddTagErrorOther()
    }
    if object.isTooManyTags() {
        return DBXFilesAddTagErrorTooManyTags()
    }
    fatalError("codegen error")
}

func mapDBFILESGetMetadataArgToDBXOptional(object: DBFILESGetMetadataArg?) -> DBXFilesGetMetadataArg? {
    guard let object = object else { return nil }
    return mapDBFILESGetMetadataArgToDBX(object: object)
}

func mapDBFILESGetMetadataArgToDBX(object: DBFILESGetMetadataArg) -> DBXFilesGetMetadataArg {
    DBXFilesGetMetadataArg(
        path: object.path,
        includeMediaInfo: object.includeMediaInfo,
        includeDeleted: object.includeDeleted,
        includeHasExplicitSharedMembers: object.includeHasExplicitSharedMembers,
        includePropertyGroups: mapDBFILEPROPERTIESTemplateFilterBaseToDBXOptional(object: object.includePropertyGroups)
    )
}

func mapDBFILESAlphaGetMetadataArgToDBXOptional(object: DBFILESAlphaGetMetadataArg?) -> DBXFilesAlphaGetMetadataArg? {
    guard let object = object else { return nil }
    return mapDBFILESAlphaGetMetadataArgToDBX(object: object)
}

func mapDBFILESAlphaGetMetadataArgToDBX(object: DBFILESAlphaGetMetadataArg) -> DBXFilesAlphaGetMetadataArg {
    DBXFilesAlphaGetMetadataArg(
        path: object.path,
        includeMediaInfo: object.includeMediaInfo,
        includeDeleted: object.includeDeleted,
        includeHasExplicitSharedMembers: object.includeHasExplicitSharedMembers,
        includePropertyGroups: mapDBFILEPROPERTIESTemplateFilterBaseToDBXOptional(object: object.includePropertyGroups),
        includePropertyTemplates: object.includePropertyTemplates
    )
}

func mapDBFILESGetMetadataErrorToDBXOptional(object: DBFILESGetMetadataError?) -> DBXFilesGetMetadataError? {
    guard let object = object else { return nil }
    return mapDBFILESGetMetadataErrorToDBX(object: object)
}

func mapDBFILESGetMetadataErrorToDBX(object: DBFILESGetMetadataError) -> DBXFilesGetMetadataError {
    if object.isPath() {
        let path = mapDBFILESLookupErrorToDBX(object: object.path)
        return DBXFilesGetMetadataError.factory(swift: .path(path.swift))
    }
    fatalError("codegen error")
}

func mapDBFILESAlphaGetMetadataErrorToDBXOptional(object: DBFILESAlphaGetMetadataError?) -> DBXFilesAlphaGetMetadataError? {
    guard let object = object else { return nil }
    return mapDBFILESAlphaGetMetadataErrorToDBX(object: object)
}

func mapDBFILESAlphaGetMetadataErrorToDBX(object: DBFILESAlphaGetMetadataError) -> DBXFilesAlphaGetMetadataError {
    if object.isPath() {
        let path = mapDBFILESLookupErrorToDBX(object: object.path)
        return DBXFilesAlphaGetMetadataError.factory(swift: .path(path.swift))
    }
    if object.isPropertiesError() {
        let propertiesError = mapDBFILEPROPERTIESLookUpPropertiesErrorToDBX(object: object.propertiesError)
        return DBXFilesAlphaGetMetadataError.factory(swift: .propertiesError(propertiesError.swift))
    }
    fatalError("codegen error")
}

func mapDBFILESCommitInfoToDBXOptional(object: DBFILESCommitInfo?) -> DBXFilesCommitInfo? {
    guard let object = object else { return nil }
    return mapDBFILESCommitInfoToDBX(object: object)
}

func mapDBFILESCommitInfoToDBX(object: DBFILESCommitInfo) -> DBXFilesCommitInfo {
    DBXFilesCommitInfo(
        path: object.path,
        mode: mapDBFILESWriteModeToDBX(object: object.mode),
        autorename: object.autorename,
        clientModified: object.clientModified,
        mute: object.mute,
        propertyGroups: object.propertyGroups?.compactMap { mapDBFILEPROPERTIESPropertyGroupToDBX(object: $0) },
        strictConflict: object.strictConflict
    )
}

func mapDBFILESContentSyncSettingToDBXOptional(object: DBFILESContentSyncSetting?) -> DBXFilesContentSyncSetting? {
    guard let object = object else { return nil }
    return mapDBFILESContentSyncSettingToDBX(object: object)
}

func mapDBFILESContentSyncSettingToDBX(object: DBFILESContentSyncSetting) -> DBXFilesContentSyncSetting {
    DBXFilesContentSyncSetting(id: object.id_, syncSetting: mapDBFILESSyncSettingToDBX(object: object.syncSetting))
}

func mapDBFILESContentSyncSettingArgToDBXOptional(object: DBFILESContentSyncSettingArg?) -> DBXFilesContentSyncSettingArg? {
    guard let object = object else { return nil }
    return mapDBFILESContentSyncSettingArgToDBX(object: object)
}

func mapDBFILESContentSyncSettingArgToDBX(object: DBFILESContentSyncSettingArg) -> DBXFilesContentSyncSettingArg {
    DBXFilesContentSyncSettingArg(id: object.id_, syncSetting: mapDBFILESSyncSettingArgToDBX(object: object.syncSetting))
}

func mapDBFILESCreateFolderArgToDBXOptional(object: DBFILESCreateFolderArg?) -> DBXFilesCreateFolderArg? {
    guard let object = object else { return nil }
    return mapDBFILESCreateFolderArgToDBX(object: object)
}

func mapDBFILESCreateFolderArgToDBX(object: DBFILESCreateFolderArg) -> DBXFilesCreateFolderArg {
    DBXFilesCreateFolderArg(path: object.path, autorename: object.autorename)
}

func mapDBFILESCreateFolderBatchArgToDBXOptional(object: DBFILESCreateFolderBatchArg?) -> DBXFilesCreateFolderBatchArg? {
    guard let object = object else { return nil }
    return mapDBFILESCreateFolderBatchArgToDBX(object: object)
}

func mapDBFILESCreateFolderBatchArgToDBX(object: DBFILESCreateFolderBatchArg) -> DBXFilesCreateFolderBatchArg {
    DBXFilesCreateFolderBatchArg(paths: object.paths, autorename: object.autorename, forceAsync: object.forceAsync)
}

func mapDBFILESCreateFolderBatchErrorToDBXOptional(object: DBFILESCreateFolderBatchError?) -> DBXFilesCreateFolderBatchError? {
    guard let object = object else { return nil }
    return mapDBFILESCreateFolderBatchErrorToDBX(object: object)
}

func mapDBFILESCreateFolderBatchErrorToDBX(object: DBFILESCreateFolderBatchError) -> DBXFilesCreateFolderBatchError {
    if object.isTooManyFiles() {
        return DBXFilesCreateFolderBatchErrorTooManyFiles()
    }
    if object.isOther() {
        return DBXFilesCreateFolderBatchErrorOther()
    }
    fatalError("codegen error")
}

func mapDBFILESCreateFolderBatchJobStatusToDBXOptional(object: DBFILESCreateFolderBatchJobStatus?) -> DBXFilesCreateFolderBatchJobStatus? {
    guard let object = object else { return nil }
    return mapDBFILESCreateFolderBatchJobStatusToDBX(object: object)
}

func mapDBFILESCreateFolderBatchJobStatusToDBX(object: DBFILESCreateFolderBatchJobStatus) -> DBXFilesCreateFolderBatchJobStatus {
    if object.isInProgress() {
        return DBXFilesCreateFolderBatchJobStatusInProgress()
    }
    if object.isComplete() {
        let complete = mapDBFILESCreateFolderBatchResultToDBX(object: object.complete)
        return DBXFilesCreateFolderBatchJobStatus.factory(swift: .complete(complete.subSwift))
    }
    if object.isFailed() {
        let failed = mapDBFILESCreateFolderBatchErrorToDBX(object: object.failed)
        return DBXFilesCreateFolderBatchJobStatus.factory(swift: .failed(failed.swift))
    }
    if object.isOther() {
        return DBXFilesCreateFolderBatchJobStatusOther()
    }
    fatalError("codegen error")
}

func mapDBFILESCreateFolderBatchLaunchToDBXOptional(object: DBFILESCreateFolderBatchLaunch?) -> DBXFilesCreateFolderBatchLaunch? {
    guard let object = object else { return nil }
    return mapDBFILESCreateFolderBatchLaunchToDBX(object: object)
}

func mapDBFILESCreateFolderBatchLaunchToDBX(object: DBFILESCreateFolderBatchLaunch) -> DBXFilesCreateFolderBatchLaunch {
    if object.isAsyncJobId() {
        let asyncJobId = object.asyncJobId
        return DBXFilesCreateFolderBatchLaunch.factory(swift: .asyncJobId(asyncJobId))
    }
    if object.isComplete() {
        let complete = mapDBFILESCreateFolderBatchResultToDBX(object: object.complete)
        return DBXFilesCreateFolderBatchLaunch.factory(swift: .complete(complete.subSwift))
    }
    if object.isOther() {
        return DBXFilesCreateFolderBatchLaunchOther()
    }
    fatalError("codegen error")
}

func mapDBFILESFileOpsResultToDBXOptional(object: DBFILESFileOpsResult?) -> DBXFilesFileOpsResult? {
    guard let object = object else { return nil }
    return mapDBFILESFileOpsResultToDBX(object: object)
}

func mapDBFILESFileOpsResultToDBX(object: DBFILESFileOpsResult) -> DBXFilesFileOpsResult {
    DBXFilesFileOpsResult()
}

func mapDBFILESCreateFolderBatchResultToDBXOptional(object: DBFILESCreateFolderBatchResult?) -> DBXFilesCreateFolderBatchResult? {
    guard let object = object else { return nil }
    return mapDBFILESCreateFolderBatchResultToDBX(object: object)
}

func mapDBFILESCreateFolderBatchResultToDBX(object: DBFILESCreateFolderBatchResult) -> DBXFilesCreateFolderBatchResult {
    DBXFilesCreateFolderBatchResult(entries: object.entries.compactMap { mapDBFILESCreateFolderBatchResultEntryToDBX(object: $0) })
}

func mapDBFILESCreateFolderBatchResultEntryToDBXOptional(object: DBFILESCreateFolderBatchResultEntry?) -> DBXFilesCreateFolderBatchResultEntry? {
    guard let object = object else { return nil }
    return mapDBFILESCreateFolderBatchResultEntryToDBX(object: object)
}

func mapDBFILESCreateFolderBatchResultEntryToDBX(object: DBFILESCreateFolderBatchResultEntry) -> DBXFilesCreateFolderBatchResultEntry {
    if object.isSuccess() {
        let success = mapDBFILESCreateFolderEntryResultToDBX(object: object.success)
        return DBXFilesCreateFolderBatchResultEntry.factory(swift: .success(success.swift))
    }
    if object.isFailure() {
        let failure = mapDBFILESCreateFolderEntryErrorToDBX(object: object.failure)
        return DBXFilesCreateFolderBatchResultEntry.factory(swift: .failure(failure.swift))
    }
    fatalError("codegen error")
}

func mapDBFILESCreateFolderEntryErrorToDBXOptional(object: DBFILESCreateFolderEntryError?) -> DBXFilesCreateFolderEntryError? {
    guard let object = object else { return nil }
    return mapDBFILESCreateFolderEntryErrorToDBX(object: object)
}

func mapDBFILESCreateFolderEntryErrorToDBX(object: DBFILESCreateFolderEntryError) -> DBXFilesCreateFolderEntryError {
    if object.isPath() {
        let path = mapDBFILESWriteErrorToDBX(object: object.path)
        return DBXFilesCreateFolderEntryError.factory(swift: .path(path.swift))
    }
    if object.isOther() {
        return DBXFilesCreateFolderEntryErrorOther()
    }
    fatalError("codegen error")
}

func mapDBFILESCreateFolderEntryResultToDBXOptional(object: DBFILESCreateFolderEntryResult?) -> DBXFilesCreateFolderEntryResult? {
    guard let object = object else { return nil }
    return mapDBFILESCreateFolderEntryResultToDBX(object: object)
}

func mapDBFILESCreateFolderEntryResultToDBX(object: DBFILESCreateFolderEntryResult) -> DBXFilesCreateFolderEntryResult {
    DBXFilesCreateFolderEntryResult(metadata: mapDBFILESFolderMetadataToDBX(object: object.metadata))
}

func mapDBFILESCreateFolderErrorToDBXOptional(object: DBFILESCreateFolderError?) -> DBXFilesCreateFolderError? {
    guard let object = object else { return nil }
    return mapDBFILESCreateFolderErrorToDBX(object: object)
}

func mapDBFILESCreateFolderErrorToDBX(object: DBFILESCreateFolderError) -> DBXFilesCreateFolderError {
    if object.isPath() {
        let path = mapDBFILESWriteErrorToDBX(object: object.path)
        return DBXFilesCreateFolderError.factory(swift: .path(path.swift))
    }
    fatalError("codegen error")
}

func mapDBFILESCreateFolderResultToDBXOptional(object: DBFILESCreateFolderResult?) -> DBXFilesCreateFolderResult? {
    guard let object = object else { return nil }
    return mapDBFILESCreateFolderResultToDBX(object: object)
}

func mapDBFILESCreateFolderResultToDBX(object: DBFILESCreateFolderResult) -> DBXFilesCreateFolderResult {
    DBXFilesCreateFolderResult(metadata: mapDBFILESFolderMetadataToDBX(object: object.metadata))
}

func mapDBFILESDeleteArgToDBXOptional(object: DBFILESDeleteArg?) -> DBXFilesDeleteArg? {
    guard let object = object else { return nil }
    return mapDBFILESDeleteArgToDBX(object: object)
}

func mapDBFILESDeleteArgToDBX(object: DBFILESDeleteArg) -> DBXFilesDeleteArg {
    DBXFilesDeleteArg(path: object.path, parentRev: object.parentRev)
}

func mapDBFILESDeleteBatchArgToDBXOptional(object: DBFILESDeleteBatchArg?) -> DBXFilesDeleteBatchArg? {
    guard let object = object else { return nil }
    return mapDBFILESDeleteBatchArgToDBX(object: object)
}

func mapDBFILESDeleteBatchArgToDBX(object: DBFILESDeleteBatchArg) -> DBXFilesDeleteBatchArg {
    DBXFilesDeleteBatchArg(entries: object.entries.compactMap { mapDBFILESDeleteArgToDBX(object: $0) })
}

func mapDBFILESDeleteBatchErrorToDBXOptional(object: DBFILESDeleteBatchError?) -> DBXFilesDeleteBatchError? {
    guard let object = object else { return nil }
    return mapDBFILESDeleteBatchErrorToDBX(object: object)
}

func mapDBFILESDeleteBatchErrorToDBX(object: DBFILESDeleteBatchError) -> DBXFilesDeleteBatchError {
    if object.isTooManyWriteOperations() {
        return DBXFilesDeleteBatchErrorTooManyWriteOperations()
    }
    if object.isOther() {
        return DBXFilesDeleteBatchErrorOther()
    }
    fatalError("codegen error")
}

func mapDBFILESDeleteBatchJobStatusToDBXOptional(object: DBFILESDeleteBatchJobStatus?) -> DBXFilesDeleteBatchJobStatus? {
    guard let object = object else { return nil }
    return mapDBFILESDeleteBatchJobStatusToDBX(object: object)
}

func mapDBFILESDeleteBatchJobStatusToDBX(object: DBFILESDeleteBatchJobStatus) -> DBXFilesDeleteBatchJobStatus {
    if object.isInProgress() {
        return DBXFilesDeleteBatchJobStatusInProgress()
    }
    if object.isComplete() {
        let complete = mapDBFILESDeleteBatchResultToDBX(object: object.complete)
        return DBXFilesDeleteBatchJobStatus.factory(swift: .complete(complete.subSwift))
    }
    if object.isFailed() {
        let failed = mapDBFILESDeleteBatchErrorToDBX(object: object.failed)
        return DBXFilesDeleteBatchJobStatus.factory(swift: .failed(failed.swift))
    }
    if object.isOther() {
        return DBXFilesDeleteBatchJobStatusOther()
    }
    fatalError("codegen error")
}

func mapDBFILESDeleteBatchLaunchToDBXOptional(object: DBFILESDeleteBatchLaunch?) -> DBXFilesDeleteBatchLaunch? {
    guard let object = object else { return nil }
    return mapDBFILESDeleteBatchLaunchToDBX(object: object)
}

func mapDBFILESDeleteBatchLaunchToDBX(object: DBFILESDeleteBatchLaunch) -> DBXFilesDeleteBatchLaunch {
    if object.isAsyncJobId() {
        let asyncJobId = object.asyncJobId
        return DBXFilesDeleteBatchLaunch.factory(swift: .asyncJobId(asyncJobId))
    }
    if object.isComplete() {
        let complete = mapDBFILESDeleteBatchResultToDBX(object: object.complete)
        return DBXFilesDeleteBatchLaunch.factory(swift: .complete(complete.subSwift))
    }
    if object.isOther() {
        return DBXFilesDeleteBatchLaunchOther()
    }
    fatalError("codegen error")
}

func mapDBFILESDeleteBatchResultToDBXOptional(object: DBFILESDeleteBatchResult?) -> DBXFilesDeleteBatchResult? {
    guard let object = object else { return nil }
    return mapDBFILESDeleteBatchResultToDBX(object: object)
}

func mapDBFILESDeleteBatchResultToDBX(object: DBFILESDeleteBatchResult) -> DBXFilesDeleteBatchResult {
    DBXFilesDeleteBatchResult(entries: object.entries.compactMap { mapDBFILESDeleteBatchResultEntryToDBX(object: $0) })
}

func mapDBFILESDeleteBatchResultDataToDBXOptional(object: DBFILESDeleteBatchResultData?) -> DBXFilesDeleteBatchResultData? {
    guard let object = object else { return nil }
    return mapDBFILESDeleteBatchResultDataToDBX(object: object)
}

func mapDBFILESDeleteBatchResultDataToDBX(object: DBFILESDeleteBatchResultData) -> DBXFilesDeleteBatchResultData {
    DBXFilesDeleteBatchResultData(metadata: mapDBFILESMetadataToDBX(object: object.metadata))
}

func mapDBFILESDeleteBatchResultEntryToDBXOptional(object: DBFILESDeleteBatchResultEntry?) -> DBXFilesDeleteBatchResultEntry? {
    guard let object = object else { return nil }
    return mapDBFILESDeleteBatchResultEntryToDBX(object: object)
}

func mapDBFILESDeleteBatchResultEntryToDBX(object: DBFILESDeleteBatchResultEntry) -> DBXFilesDeleteBatchResultEntry {
    if object.isSuccess() {
        let success = mapDBFILESDeleteBatchResultDataToDBX(object: object.success)
        return DBXFilesDeleteBatchResultEntry.factory(swift: .success(success.swift))
    }
    if object.isFailure() {
        let failure = mapDBFILESDeleteErrorToDBX(object: object.failure)
        return DBXFilesDeleteBatchResultEntry.factory(swift: .failure(failure.swift))
    }
    fatalError("codegen error")
}

func mapDBFILESDeleteErrorToDBXOptional(object: DBFILESDeleteError?) -> DBXFilesDeleteError? {
    guard let object = object else { return nil }
    return mapDBFILESDeleteErrorToDBX(object: object)
}

func mapDBFILESDeleteErrorToDBX(object: DBFILESDeleteError) -> DBXFilesDeleteError {
    if object.isPathLookup() {
        let pathLookup = mapDBFILESLookupErrorToDBX(object: object.pathLookup)
        return DBXFilesDeleteError.factory(swift: .pathLookup(pathLookup.swift))
    }
    if object.isPathWrite() {
        let pathWrite = mapDBFILESWriteErrorToDBX(object: object.pathWrite)
        return DBXFilesDeleteError.factory(swift: .pathWrite(pathWrite.swift))
    }
    if object.isTooManyWriteOperations() {
        return DBXFilesDeleteErrorTooManyWriteOperations()
    }
    if object.isTooManyFiles() {
        return DBXFilesDeleteErrorTooManyFiles()
    }
    if object.isOther() {
        return DBXFilesDeleteErrorOther()
    }
    fatalError("codegen error")
}

func mapDBFILESDeleteResultToDBXOptional(object: DBFILESDeleteResult?) -> DBXFilesDeleteResult? {
    guard let object = object else { return nil }
    return mapDBFILESDeleteResultToDBX(object: object)
}

func mapDBFILESDeleteResultToDBX(object: DBFILESDeleteResult) -> DBXFilesDeleteResult {
    DBXFilesDeleteResult(metadata: mapDBFILESMetadataToDBX(object: object.metadata))
}

func mapDBFILESMetadataToDBXOptional(object: DBFILESMetadata?) -> DBXFilesMetadata? {
    guard let object = object else { return nil }
    return mapDBFILESMetadataToDBX(object: object)
}

func mapDBFILESMetadataToDBX(object: DBFILESMetadata) -> DBXFilesMetadata {
    switch object {
    case let object as DBFILESFileMetadata:
        return DBXFilesFileMetadata(
            name: object.name,
            id: object.id_,
            clientModified: object.clientModified,
            serverModified: object.serverModified,
            rev: object.rev,
            size: object.size,
            pathLower: object.pathLower,
            pathDisplay: object.pathDisplay,
            parentSharedFolderId: object.parentSharedFolderId,
            previewUrl: object.previewUrl,
            mediaInfo: mapDBFILESMediaInfoToDBXOptional(object: object.mediaInfo),
            symlinkInfo: mapDBFILESSymlinkInfoToDBXOptional(object: object.symlinkInfo),
            sharingInfo: mapDBFILESFileSharingInfoToDBXOptional(object: object.sharingInfo),
            isDownloadable: object.isDownloadable,
            exportInfo: mapDBFILESExportInfoToDBXOptional(object: object.exportInfo),
            propertyGroups: object.propertyGroups?.compactMap { mapDBFILEPROPERTIESPropertyGroupToDBX(object: $0) },
            hasExplicitSharedMembers: object.hasExplicitSharedMembers,
            contentHash: object.contentHash,
            fileLockInfo: mapDBFILESFileLockMetadataToDBXOptional(object: object.fileLockInfo)
        )
    case let object as DBFILESFolderMetadata:
        return DBXFilesFolderMetadata(
            name: object.name,
            id: object.id_,
            pathLower: object.pathLower,
            pathDisplay: object.pathDisplay,
            parentSharedFolderId: object.parentSharedFolderId,
            previewUrl: object.previewUrl,
            sharedFolderId: object.sharedFolderId,
            sharingInfo: mapDBFILESFolderSharingInfoToDBXOptional(object: object.sharingInfo),
            propertyGroups: object.propertyGroups?.compactMap { mapDBFILEPROPERTIESPropertyGroupToDBX(object: $0) }
        )
    case let object as DBFILESDeletedMetadata:
        return DBXFilesDeletedMetadata(
            name: object.name,
            pathLower: object.pathLower,
            pathDisplay: object.pathDisplay,
            parentSharedFolderId: object.parentSharedFolderId,
            previewUrl: object.previewUrl
        )
    default:
        return DBXFilesMetadata(
            name: object.name,
            pathLower: object.pathLower,
            pathDisplay: object.pathDisplay,
            parentSharedFolderId: object.parentSharedFolderId,
            previewUrl: object.previewUrl
        )
    }
}

func mapDBFILESDeletedMetadataToDBXOptional(object: DBFILESDeletedMetadata?) -> DBXFilesDeletedMetadata? {
    guard let object = object else { return nil }
    return mapDBFILESDeletedMetadataToDBX(object: object)
}

func mapDBFILESDeletedMetadataToDBX(object: DBFILESDeletedMetadata) -> DBXFilesDeletedMetadata {
    DBXFilesDeletedMetadata(
        name: object.name,
        pathLower: object.pathLower,
        pathDisplay: object.pathDisplay,
        parentSharedFolderId: object.parentSharedFolderId,
        previewUrl: object.previewUrl
    )
}

func mapDBFILESDimensionsToDBXOptional(object: DBFILESDimensions?) -> DBXFilesDimensions? {
    guard let object = object else { return nil }
    return mapDBFILESDimensionsToDBX(object: object)
}

func mapDBFILESDimensionsToDBX(object: DBFILESDimensions) -> DBXFilesDimensions {
    DBXFilesDimensions(height: object.height, width: object.width)
}

func mapDBFILESDownloadArgToDBXOptional(object: DBFILESDownloadArg?) -> DBXFilesDownloadArg? {
    guard let object = object else { return nil }
    return mapDBFILESDownloadArgToDBX(object: object)
}

func mapDBFILESDownloadArgToDBX(object: DBFILESDownloadArg) -> DBXFilesDownloadArg {
    DBXFilesDownloadArg(path: object.path, rev: object.rev)
}

func mapDBFILESDownloadErrorToDBXOptional(object: DBFILESDownloadError?) -> DBXFilesDownloadError? {
    guard let object = object else { return nil }
    return mapDBFILESDownloadErrorToDBX(object: object)
}

func mapDBFILESDownloadErrorToDBX(object: DBFILESDownloadError) -> DBXFilesDownloadError {
    if object.isPath() {
        let path = mapDBFILESLookupErrorToDBX(object: object.path)
        return DBXFilesDownloadError.factory(swift: .path(path.swift))
    }
    if object.isUnsupportedFile() {
        return DBXFilesDownloadErrorUnsupportedFile()
    }
    if object.isOther() {
        return DBXFilesDownloadErrorOther()
    }
    fatalError("codegen error")
}

func mapDBFILESDownloadZipArgToDBXOptional(object: DBFILESDownloadZipArg?) -> DBXFilesDownloadZipArg? {
    guard let object = object else { return nil }
    return mapDBFILESDownloadZipArgToDBX(object: object)
}

func mapDBFILESDownloadZipArgToDBX(object: DBFILESDownloadZipArg) -> DBXFilesDownloadZipArg {
    DBXFilesDownloadZipArg(path: object.path)
}

func mapDBFILESDownloadZipErrorToDBXOptional(object: DBFILESDownloadZipError?) -> DBXFilesDownloadZipError? {
    guard let object = object else { return nil }
    return mapDBFILESDownloadZipErrorToDBX(object: object)
}

func mapDBFILESDownloadZipErrorToDBX(object: DBFILESDownloadZipError) -> DBXFilesDownloadZipError {
    if object.isPath() {
        let path = mapDBFILESLookupErrorToDBX(object: object.path)
        return DBXFilesDownloadZipError.factory(swift: .path(path.swift))
    }
    if object.isTooLarge() {
        return DBXFilesDownloadZipErrorTooLarge()
    }
    if object.isTooManyFiles() {
        return DBXFilesDownloadZipErrorTooManyFiles()
    }
    if object.isOther() {
        return DBXFilesDownloadZipErrorOther()
    }
    fatalError("codegen error")
}

func mapDBFILESDownloadZipResultToDBXOptional(object: DBFILESDownloadZipResult?) -> DBXFilesDownloadZipResult? {
    guard let object = object else { return nil }
    return mapDBFILESDownloadZipResultToDBX(object: object)
}

func mapDBFILESDownloadZipResultToDBX(object: DBFILESDownloadZipResult) -> DBXFilesDownloadZipResult {
    DBXFilesDownloadZipResult(metadata: mapDBFILESFolderMetadataToDBX(object: object.metadata))
}

func mapDBFILESExportArgToDBXOptional(object: DBFILESExportArg?) -> DBXFilesExportArg? {
    guard let object = object else { return nil }
    return mapDBFILESExportArgToDBX(object: object)
}

func mapDBFILESExportArgToDBX(object: DBFILESExportArg) -> DBXFilesExportArg {
    DBXFilesExportArg(path: object.path, exportFormat: object.exportFormat)
}

func mapDBFILESExportErrorToDBXOptional(object: DBFILESExportError?) -> DBXFilesExportError? {
    guard let object = object else { return nil }
    return mapDBFILESExportErrorToDBX(object: object)
}

func mapDBFILESExportErrorToDBX(object: DBFILESExportError) -> DBXFilesExportError {
    if object.isPath() {
        let path = mapDBFILESLookupErrorToDBX(object: object.path)
        return DBXFilesExportError.factory(swift: .path(path.swift))
    }
    if object.isNonExportable() {
        return DBXFilesExportErrorNonExportable()
    }
    if object.isInvalidExportFormat() {
        return DBXFilesExportErrorInvalidExportFormat()
    }
    if object.isRetryError() {
        return DBXFilesExportErrorRetryError()
    }
    if object.isOther() {
        return DBXFilesExportErrorOther()
    }
    fatalError("codegen error")
}

func mapDBFILESExportInfoToDBXOptional(object: DBFILESExportInfo?) -> DBXFilesExportInfo? {
    guard let object = object else { return nil }
    return mapDBFILESExportInfoToDBX(object: object)
}

func mapDBFILESExportInfoToDBX(object: DBFILESExportInfo) -> DBXFilesExportInfo {
    DBXFilesExportInfo(exportAs: object.exportAs, exportOptions: object.exportOptions)
}

func mapDBFILESExportMetadataToDBXOptional(object: DBFILESExportMetadata?) -> DBXFilesExportMetadata? {
    guard let object = object else { return nil }
    return mapDBFILESExportMetadataToDBX(object: object)
}

func mapDBFILESExportMetadataToDBX(object: DBFILESExportMetadata) -> DBXFilesExportMetadata {
    DBXFilesExportMetadata(name: object.name, size: object.size, exportHash: object.exportHash, paperRevision: object.paperRevision)
}

func mapDBFILESExportResultToDBXOptional(object: DBFILESExportResult?) -> DBXFilesExportResult? {
    guard let object = object else { return nil }
    return mapDBFILESExportResultToDBX(object: object)
}

func mapDBFILESExportResultToDBX(object: DBFILESExportResult) -> DBXFilesExportResult {
    DBXFilesExportResult(
        exportMetadata: mapDBFILESExportMetadataToDBX(object: object.exportMetadata),
        fileMetadata: mapDBFILESFileMetadataToDBX(object: object.fileMetadata)
    )
}

func mapDBFILESFileCategoryToDBXOptional(object: DBFILESFileCategory?) -> DBXFilesFileCategory? {
    guard let object = object else { return nil }
    return mapDBFILESFileCategoryToDBX(object: object)
}

func mapDBFILESFileCategoryToDBX(object: DBFILESFileCategory) -> DBXFilesFileCategory {
    if object.isImage() {
        return DBXFilesFileCategoryImage()
    }
    if object.isDocument() {
        return DBXFilesFileCategoryDocument()
    }
    if object.isPdf() {
        return DBXFilesFileCategoryPdf()
    }
    if object.isSpreadsheet() {
        return DBXFilesFileCategorySpreadsheet()
    }
    if object.isPresentation() {
        return DBXFilesFileCategoryPresentation()
    }
    if object.isAudio() {
        return DBXFilesFileCategoryAudio()
    }
    if object.isVideo() {
        return DBXFilesFileCategoryVideo()
    }
    if object.isFolder() {
        return DBXFilesFileCategoryFolder()
    }
    if object.isPaper() {
        return DBXFilesFileCategoryPaper()
    }
    if object.isOthers() {
        return DBXFilesFileCategoryOthers()
    }
    if object.isOther() {
        return DBXFilesFileCategoryOther()
    }
    fatalError("codegen error")
}

func mapDBFILESFileLockToDBXOptional(object: DBFILESFileLock?) -> DBXFilesFileLock? {
    guard let object = object else { return nil }
    return mapDBFILESFileLockToDBX(object: object)
}

func mapDBFILESFileLockToDBX(object: DBFILESFileLock) -> DBXFilesFileLock {
    DBXFilesFileLock(content: mapDBFILESFileLockContentToDBX(object: object.content))
}

func mapDBFILESFileLockContentToDBXOptional(object: DBFILESFileLockContent?) -> DBXFilesFileLockContent? {
    guard let object = object else { return nil }
    return mapDBFILESFileLockContentToDBX(object: object)
}

func mapDBFILESFileLockContentToDBX(object: DBFILESFileLockContent) -> DBXFilesFileLockContent {
    if object.isUnlocked() {
        return DBXFilesFileLockContentUnlocked()
    }
    if object.isSingleUser() {
        let singleUser = mapDBFILESSingleUserLockToDBX(object: object.singleUser)
        return DBXFilesFileLockContent.factory(swift: .singleUser(singleUser.swift))
    }
    if object.isOther() {
        return DBXFilesFileLockContentOther()
    }
    fatalError("codegen error")
}

func mapDBFILESFileLockMetadataToDBXOptional(object: DBFILESFileLockMetadata?) -> DBXFilesFileLockMetadata? {
    guard let object = object else { return nil }
    return mapDBFILESFileLockMetadataToDBX(object: object)
}

func mapDBFILESFileLockMetadataToDBX(object: DBFILESFileLockMetadata) -> DBXFilesFileLockMetadata {
    DBXFilesFileLockMetadata(
        isLockholder: object.isLockholder,
        lockholderName: object.lockholderName,
        lockholderAccountId: object.lockholderAccountId,
        created: object.created
    )
}

func mapDBFILESFileMetadataToDBXOptional(object: DBFILESFileMetadata?) -> DBXFilesFileMetadata? {
    guard let object = object else { return nil }
    return mapDBFILESFileMetadataToDBX(object: object)
}

func mapDBFILESFileMetadataToDBX(object: DBFILESFileMetadata) -> DBXFilesFileMetadata {
    DBXFilesFileMetadata(
        name: object.name,
        id: object.id_,
        clientModified: object.clientModified,
        serverModified: object.serverModified,
        rev: object.rev,
        size: object.size,
        pathLower: object.pathLower,
        pathDisplay: object.pathDisplay,
        parentSharedFolderId: object.parentSharedFolderId,
        previewUrl: object.previewUrl,
        mediaInfo: mapDBFILESMediaInfoToDBXOptional(object: object.mediaInfo),
        symlinkInfo: mapDBFILESSymlinkInfoToDBXOptional(object: object.symlinkInfo),
        sharingInfo: mapDBFILESFileSharingInfoToDBXOptional(object: object.sharingInfo),
        isDownloadable: object.isDownloadable,
        exportInfo: mapDBFILESExportInfoToDBXOptional(object: object.exportInfo),
        propertyGroups: object.propertyGroups?.compactMap { mapDBFILEPROPERTIESPropertyGroupToDBX(object: $0) },
        hasExplicitSharedMembers: object.hasExplicitSharedMembers,
        contentHash: object.contentHash,
        fileLockInfo: mapDBFILESFileLockMetadataToDBXOptional(object: object.fileLockInfo)
    )
}

func mapDBFILESSharingInfoToDBXOptional(object: DBFILESSharingInfo?) -> DBXFilesSharingInfo? {
    guard let object = object else { return nil }
    return mapDBFILESSharingInfoToDBX(object: object)
}

func mapDBFILESSharingInfoToDBX(object: DBFILESSharingInfo) -> DBXFilesSharingInfo {
    DBXFilesSharingInfo(readOnly: object.readOnly)
}

func mapDBFILESFileSharingInfoToDBXOptional(object: DBFILESFileSharingInfo?) -> DBXFilesFileSharingInfo? {
    guard let object = object else { return nil }
    return mapDBFILESFileSharingInfoToDBX(object: object)
}

func mapDBFILESFileSharingInfoToDBX(object: DBFILESFileSharingInfo) -> DBXFilesFileSharingInfo {
    DBXFilesFileSharingInfo(readOnly: object.readOnly, parentSharedFolderId: object.parentSharedFolderId, modifiedBy: object.modifiedBy)
}

func mapDBFILESFileStatusToDBXOptional(object: DBFILESFileStatus?) -> DBXFilesFileStatus? {
    guard let object = object else { return nil }
    return mapDBFILESFileStatusToDBX(object: object)
}

func mapDBFILESFileStatusToDBX(object: DBFILESFileStatus) -> DBXFilesFileStatus {
    if object.isActive() {
        return DBXFilesFileStatusActive()
    }
    if object.isDeleted() {
        return DBXFilesFileStatusDeleted()
    }
    if object.isOther() {
        return DBXFilesFileStatusOther()
    }
    fatalError("codegen error")
}

func mapDBFILESFolderMetadataToDBXOptional(object: DBFILESFolderMetadata?) -> DBXFilesFolderMetadata? {
    guard let object = object else { return nil }
    return mapDBFILESFolderMetadataToDBX(object: object)
}

func mapDBFILESFolderMetadataToDBX(object: DBFILESFolderMetadata) -> DBXFilesFolderMetadata {
    DBXFilesFolderMetadata(
        name: object.name,
        id: object.id_,
        pathLower: object.pathLower,
        pathDisplay: object.pathDisplay,
        parentSharedFolderId: object.parentSharedFolderId,
        previewUrl: object.previewUrl,
        sharedFolderId: object.sharedFolderId,
        sharingInfo: mapDBFILESFolderSharingInfoToDBXOptional(object: object.sharingInfo),
        propertyGroups: object.propertyGroups?.compactMap { mapDBFILEPROPERTIESPropertyGroupToDBX(object: $0) }
    )
}

func mapDBFILESFolderSharingInfoToDBXOptional(object: DBFILESFolderSharingInfo?) -> DBXFilesFolderSharingInfo? {
    guard let object = object else { return nil }
    return mapDBFILESFolderSharingInfoToDBX(object: object)
}

func mapDBFILESFolderSharingInfoToDBX(object: DBFILESFolderSharingInfo) -> DBXFilesFolderSharingInfo {
    DBXFilesFolderSharingInfo(
        readOnly: object.readOnly,
        parentSharedFolderId: object.parentSharedFolderId,
        sharedFolderId: object.sharedFolderId,
        traverseOnly: object.traverseOnly,
        noAccess: object.noAccess
    )
}

func mapDBFILESGetCopyReferenceArgToDBXOptional(object: DBFILESGetCopyReferenceArg?) -> DBXFilesGetCopyReferenceArg? {
    guard let object = object else { return nil }
    return mapDBFILESGetCopyReferenceArgToDBX(object: object)
}

func mapDBFILESGetCopyReferenceArgToDBX(object: DBFILESGetCopyReferenceArg) -> DBXFilesGetCopyReferenceArg {
    DBXFilesGetCopyReferenceArg(path: object.path)
}

func mapDBFILESGetCopyReferenceErrorToDBXOptional(object: DBFILESGetCopyReferenceError?) -> DBXFilesGetCopyReferenceError? {
    guard let object = object else { return nil }
    return mapDBFILESGetCopyReferenceErrorToDBX(object: object)
}

func mapDBFILESGetCopyReferenceErrorToDBX(object: DBFILESGetCopyReferenceError) -> DBXFilesGetCopyReferenceError {
    if object.isPath() {
        let path = mapDBFILESLookupErrorToDBX(object: object.path)
        return DBXFilesGetCopyReferenceError.factory(swift: .path(path.swift))
    }
    if object.isOther() {
        return DBXFilesGetCopyReferenceErrorOther()
    }
    fatalError("codegen error")
}

func mapDBFILESGetCopyReferenceResultToDBXOptional(object: DBFILESGetCopyReferenceResult?) -> DBXFilesGetCopyReferenceResult? {
    guard let object = object else { return nil }
    return mapDBFILESGetCopyReferenceResultToDBX(object: object)
}

func mapDBFILESGetCopyReferenceResultToDBX(object: DBFILESGetCopyReferenceResult) -> DBXFilesGetCopyReferenceResult {
    DBXFilesGetCopyReferenceResult(metadata: mapDBFILESMetadataToDBX(object: object.metadata), copyReference: object.dCopyReference, expires: object.expires)
}

func mapDBFILESGetTagsArgToDBXOptional(object: DBFILESGetTagsArg?) -> DBXFilesGetTagsArg? {
    guard let object = object else { return nil }
    return mapDBFILESGetTagsArgToDBX(object: object)
}

func mapDBFILESGetTagsArgToDBX(object: DBFILESGetTagsArg) -> DBXFilesGetTagsArg {
    DBXFilesGetTagsArg(paths: object.paths)
}

func mapDBFILESGetTagsResultToDBXOptional(object: DBFILESGetTagsResult?) -> DBXFilesGetTagsResult? {
    guard let object = object else { return nil }
    return mapDBFILESGetTagsResultToDBX(object: object)
}

func mapDBFILESGetTagsResultToDBX(object: DBFILESGetTagsResult) -> DBXFilesGetTagsResult {
    DBXFilesGetTagsResult(pathsToTags: object.pathsToTags.compactMap { mapDBFILESPathToTagsToDBX(object: $0) })
}

func mapDBFILESGetTemporaryLinkArgToDBXOptional(object: DBFILESGetTemporaryLinkArg?) -> DBXFilesGetTemporaryLinkArg? {
    guard let object = object else { return nil }
    return mapDBFILESGetTemporaryLinkArgToDBX(object: object)
}

func mapDBFILESGetTemporaryLinkArgToDBX(object: DBFILESGetTemporaryLinkArg) -> DBXFilesGetTemporaryLinkArg {
    DBXFilesGetTemporaryLinkArg(path: object.path)
}

func mapDBFILESGetTemporaryLinkErrorToDBXOptional(object: DBFILESGetTemporaryLinkError?) -> DBXFilesGetTemporaryLinkError? {
    guard let object = object else { return nil }
    return mapDBFILESGetTemporaryLinkErrorToDBX(object: object)
}

func mapDBFILESGetTemporaryLinkErrorToDBX(object: DBFILESGetTemporaryLinkError) -> DBXFilesGetTemporaryLinkError {
    if object.isPath() {
        let path = mapDBFILESLookupErrorToDBX(object: object.path)
        return DBXFilesGetTemporaryLinkError.factory(swift: .path(path.swift))
    }
    if object.isEmailNotVerified() {
        return DBXFilesGetTemporaryLinkErrorEmailNotVerified()
    }
    if object.isUnsupportedFile() {
        return DBXFilesGetTemporaryLinkErrorUnsupportedFile()
    }
    if object.isNotAllowed() {
        return DBXFilesGetTemporaryLinkErrorNotAllowed()
    }
    if object.isOther() {
        return DBXFilesGetTemporaryLinkErrorOther()
    }
    fatalError("codegen error")
}

func mapDBFILESGetTemporaryLinkResultToDBXOptional(object: DBFILESGetTemporaryLinkResult?) -> DBXFilesGetTemporaryLinkResult? {
    guard let object = object else { return nil }
    return mapDBFILESGetTemporaryLinkResultToDBX(object: object)
}

func mapDBFILESGetTemporaryLinkResultToDBX(object: DBFILESGetTemporaryLinkResult) -> DBXFilesGetTemporaryLinkResult {
    DBXFilesGetTemporaryLinkResult(metadata: mapDBFILESFileMetadataToDBX(object: object.metadata), link: object.link)
}

func mapDBFILESGetTemporaryUploadLinkArgToDBXOptional(object: DBFILESGetTemporaryUploadLinkArg?) -> DBXFilesGetTemporaryUploadLinkArg? {
    guard let object = object else { return nil }
    return mapDBFILESGetTemporaryUploadLinkArgToDBX(object: object)
}

func mapDBFILESGetTemporaryUploadLinkArgToDBX(object: DBFILESGetTemporaryUploadLinkArg) -> DBXFilesGetTemporaryUploadLinkArg {
    DBXFilesGetTemporaryUploadLinkArg(commitInfo: mapDBFILESCommitInfoToDBX(object: object.commitInfo), duration: object.duration)
}

func mapDBFILESGetTemporaryUploadLinkResultToDBXOptional(object: DBFILESGetTemporaryUploadLinkResult?) -> DBXFilesGetTemporaryUploadLinkResult? {
    guard let object = object else { return nil }
    return mapDBFILESGetTemporaryUploadLinkResultToDBX(object: object)
}

func mapDBFILESGetTemporaryUploadLinkResultToDBX(object: DBFILESGetTemporaryUploadLinkResult) -> DBXFilesGetTemporaryUploadLinkResult {
    DBXFilesGetTemporaryUploadLinkResult(link: object.link)
}

func mapDBFILESGetThumbnailBatchArgToDBXOptional(object: DBFILESGetThumbnailBatchArg?) -> DBXFilesGetThumbnailBatchArg? {
    guard let object = object else { return nil }
    return mapDBFILESGetThumbnailBatchArgToDBX(object: object)
}

func mapDBFILESGetThumbnailBatchArgToDBX(object: DBFILESGetThumbnailBatchArg) -> DBXFilesGetThumbnailBatchArg {
    DBXFilesGetThumbnailBatchArg(entries: object.entries.compactMap { mapDBFILESThumbnailArgToDBX(object: $0) })
}

func mapDBFILESGetThumbnailBatchErrorToDBXOptional(object: DBFILESGetThumbnailBatchError?) -> DBXFilesGetThumbnailBatchError? {
    guard let object = object else { return nil }
    return mapDBFILESGetThumbnailBatchErrorToDBX(object: object)
}

func mapDBFILESGetThumbnailBatchErrorToDBX(object: DBFILESGetThumbnailBatchError) -> DBXFilesGetThumbnailBatchError {
    if object.isTooManyFiles() {
        return DBXFilesGetThumbnailBatchErrorTooManyFiles()
    }
    if object.isOther() {
        return DBXFilesGetThumbnailBatchErrorOther()
    }
    fatalError("codegen error")
}

func mapDBFILESGetThumbnailBatchResultToDBXOptional(object: DBFILESGetThumbnailBatchResult?) -> DBXFilesGetThumbnailBatchResult? {
    guard let object = object else { return nil }
    return mapDBFILESGetThumbnailBatchResultToDBX(object: object)
}

func mapDBFILESGetThumbnailBatchResultToDBX(object: DBFILESGetThumbnailBatchResult) -> DBXFilesGetThumbnailBatchResult {
    DBXFilesGetThumbnailBatchResult(entries: object.entries.compactMap { mapDBFILESGetThumbnailBatchResultEntryToDBX(object: $0) })
}

func mapDBFILESGetThumbnailBatchResultDataToDBXOptional(object: DBFILESGetThumbnailBatchResultData?) -> DBXFilesGetThumbnailBatchResultData? {
    guard let object = object else { return nil }
    return mapDBFILESGetThumbnailBatchResultDataToDBX(object: object)
}

func mapDBFILESGetThumbnailBatchResultDataToDBX(object: DBFILESGetThumbnailBatchResultData) -> DBXFilesGetThumbnailBatchResultData {
    DBXFilesGetThumbnailBatchResultData(metadata: mapDBFILESFileMetadataToDBX(object: object.metadata), thumbnail: object.thumbnail)
}

func mapDBFILESGetThumbnailBatchResultEntryToDBXOptional(object: DBFILESGetThumbnailBatchResultEntry?) -> DBXFilesGetThumbnailBatchResultEntry? {
    guard let object = object else { return nil }
    return mapDBFILESGetThumbnailBatchResultEntryToDBX(object: object)
}

func mapDBFILESGetThumbnailBatchResultEntryToDBX(object: DBFILESGetThumbnailBatchResultEntry) -> DBXFilesGetThumbnailBatchResultEntry {
    if object.isSuccess() {
        let success = mapDBFILESGetThumbnailBatchResultDataToDBX(object: object.success)
        return DBXFilesGetThumbnailBatchResultEntry.factory(swift: .success(success.swift))
    }
    if object.isFailure() {
        let failure = mapDBFILESThumbnailErrorToDBX(object: object.failure)
        return DBXFilesGetThumbnailBatchResultEntry.factory(swift: .failure(failure.swift))
    }
    if object.isOther() {
        return DBXFilesGetThumbnailBatchResultEntryOther()
    }
    fatalError("codegen error")
}

func mapDBFILESGpsCoordinatesToDBXOptional(object: DBFILESGpsCoordinates?) -> DBXFilesGpsCoordinates? {
    guard let object = object else { return nil }
    return mapDBFILESGpsCoordinatesToDBX(object: object)
}

func mapDBFILESGpsCoordinatesToDBX(object: DBFILESGpsCoordinates) -> DBXFilesGpsCoordinates {
    DBXFilesGpsCoordinates(latitude: object.latitude, longitude: object.longitude)
}

func mapDBFILESHighlightSpanToDBXOptional(object: DBFILESHighlightSpan?) -> DBXFilesHighlightSpan? {
    guard let object = object else { return nil }
    return mapDBFILESHighlightSpanToDBX(object: object)
}

func mapDBFILESHighlightSpanToDBX(object: DBFILESHighlightSpan) -> DBXFilesHighlightSpan {
    DBXFilesHighlightSpan(highlightStr: object.highlightStr, isHighlighted: object.isHighlighted)
}

func mapDBFILESImportFormatToDBXOptional(object: DBFILESImportFormat?) -> DBXFilesImportFormat? {
    guard let object = object else { return nil }
    return mapDBFILESImportFormatToDBX(object: object)
}

func mapDBFILESImportFormatToDBX(object: DBFILESImportFormat) -> DBXFilesImportFormat {
    if object.isHtml() {
        return DBXFilesImportFormatHtml()
    }
    if object.isMarkdown() {
        return DBXFilesImportFormatMarkdown()
    }
    if object.isPlainText() {
        return DBXFilesImportFormatPlainText()
    }
    if object.isOther() {
        return DBXFilesImportFormatOther()
    }
    fatalError("codegen error")
}

func mapDBFILESListFolderArgToDBXOptional(object: DBFILESListFolderArg?) -> DBXFilesListFolderArg? {
    guard let object = object else { return nil }
    return mapDBFILESListFolderArgToDBX(object: object)
}

func mapDBFILESListFolderArgToDBX(object: DBFILESListFolderArg) -> DBXFilesListFolderArg {
    DBXFilesListFolderArg(
        path: object.path,
        recursive: object.recursive,
        includeMediaInfo: object.includeMediaInfo,
        includeDeleted: object.includeDeleted,
        includeHasExplicitSharedMembers: object.includeHasExplicitSharedMembers,
        includeMountedFolders: object.includeMountedFolders,
        limit: object.limit,
        sharedLink: mapDBFILESSharedLinkToDBXOptional(object: object.sharedLink),
        includePropertyGroups: mapDBFILEPROPERTIESTemplateFilterBaseToDBXOptional(object: object.includePropertyGroups),
        includeNonDownloadableFiles: object.includeNonDownloadableFiles
    )
}

func mapDBFILESListFolderContinueArgToDBXOptional(object: DBFILESListFolderContinueArg?) -> DBXFilesListFolderContinueArg? {
    guard let object = object else { return nil }
    return mapDBFILESListFolderContinueArgToDBX(object: object)
}

func mapDBFILESListFolderContinueArgToDBX(object: DBFILESListFolderContinueArg) -> DBXFilesListFolderContinueArg {
    DBXFilesListFolderContinueArg(cursor: object.cursor)
}

func mapDBFILESListFolderContinueErrorToDBXOptional(object: DBFILESListFolderContinueError?) -> DBXFilesListFolderContinueError? {
    guard let object = object else { return nil }
    return mapDBFILESListFolderContinueErrorToDBX(object: object)
}

func mapDBFILESListFolderContinueErrorToDBX(object: DBFILESListFolderContinueError) -> DBXFilesListFolderContinueError {
    if object.isPath() {
        let path = mapDBFILESLookupErrorToDBX(object: object.path)
        return DBXFilesListFolderContinueError.factory(swift: .path(path.swift))
    }
    if object.isReset() {
        return DBXFilesListFolderContinueErrorReset()
    }
    if object.isOther() {
        return DBXFilesListFolderContinueErrorOther()
    }
    fatalError("codegen error")
}

func mapDBFILESListFolderErrorToDBXOptional(object: DBFILESListFolderError?) -> DBXFilesListFolderError? {
    guard let object = object else { return nil }
    return mapDBFILESListFolderErrorToDBX(object: object)
}

func mapDBFILESListFolderErrorToDBX(object: DBFILESListFolderError) -> DBXFilesListFolderError {
    if object.isPath() {
        let path = mapDBFILESLookupErrorToDBX(object: object.path)
        return DBXFilesListFolderError.factory(swift: .path(path.swift))
    }
    if object.isTemplateError() {
        let templateError = mapDBFILEPROPERTIESTemplateErrorToDBX(object: object.templateError)
        return DBXFilesListFolderError.factory(swift: .templateError(templateError.swift))
    }
    if object.isOther() {
        return DBXFilesListFolderErrorOther()
    }
    fatalError("codegen error")
}

func mapDBFILESListFolderGetLatestCursorResultToDBXOptional(object: DBFILESListFolderGetLatestCursorResult?) -> DBXFilesListFolderGetLatestCursorResult? {
    guard let object = object else { return nil }
    return mapDBFILESListFolderGetLatestCursorResultToDBX(object: object)
}

func mapDBFILESListFolderGetLatestCursorResultToDBX(object: DBFILESListFolderGetLatestCursorResult) -> DBXFilesListFolderGetLatestCursorResult {
    DBXFilesListFolderGetLatestCursorResult(cursor: object.cursor)
}

func mapDBFILESListFolderLongpollArgToDBXOptional(object: DBFILESListFolderLongpollArg?) -> DBXFilesListFolderLongpollArg? {
    guard let object = object else { return nil }
    return mapDBFILESListFolderLongpollArgToDBX(object: object)
}

func mapDBFILESListFolderLongpollArgToDBX(object: DBFILESListFolderLongpollArg) -> DBXFilesListFolderLongpollArg {
    DBXFilesListFolderLongpollArg(cursor: object.cursor, timeout: object.timeout)
}

func mapDBFILESListFolderLongpollErrorToDBXOptional(object: DBFILESListFolderLongpollError?) -> DBXFilesListFolderLongpollError? {
    guard let object = object else { return nil }
    return mapDBFILESListFolderLongpollErrorToDBX(object: object)
}

func mapDBFILESListFolderLongpollErrorToDBX(object: DBFILESListFolderLongpollError) -> DBXFilesListFolderLongpollError {
    if object.isReset() {
        return DBXFilesListFolderLongpollErrorReset()
    }
    if object.isOther() {
        return DBXFilesListFolderLongpollErrorOther()
    }
    fatalError("codegen error")
}

func mapDBFILESListFolderLongpollResultToDBXOptional(object: DBFILESListFolderLongpollResult?) -> DBXFilesListFolderLongpollResult? {
    guard let object = object else { return nil }
    return mapDBFILESListFolderLongpollResultToDBX(object: object)
}

func mapDBFILESListFolderLongpollResultToDBX(object: DBFILESListFolderLongpollResult) -> DBXFilesListFolderLongpollResult {
    DBXFilesListFolderLongpollResult(changes: object.changes, backoff: object.backoff)
}

func mapDBFILESListFolderResultToDBXOptional(object: DBFILESListFolderResult?) -> DBXFilesListFolderResult? {
    guard let object = object else { return nil }
    return mapDBFILESListFolderResultToDBX(object: object)
}

func mapDBFILESListFolderResultToDBX(object: DBFILESListFolderResult) -> DBXFilesListFolderResult {
    DBXFilesListFolderResult(entries: object.entries.compactMap { mapDBFILESMetadataToDBX(object: $0) }, cursor: object.cursor, hasMore: object.hasMore)
}

func mapDBFILESListRevisionsArgToDBXOptional(object: DBFILESListRevisionsArg?) -> DBXFilesListRevisionsArg? {
    guard let object = object else { return nil }
    return mapDBFILESListRevisionsArgToDBX(object: object)
}

func mapDBFILESListRevisionsArgToDBX(object: DBFILESListRevisionsArg) -> DBXFilesListRevisionsArg {
    DBXFilesListRevisionsArg(path: object.path, mode: mapDBFILESListRevisionsModeToDBX(object: object.mode), limit: object.limit)
}

func mapDBFILESListRevisionsErrorToDBXOptional(object: DBFILESListRevisionsError?) -> DBXFilesListRevisionsError? {
    guard let object = object else { return nil }
    return mapDBFILESListRevisionsErrorToDBX(object: object)
}

func mapDBFILESListRevisionsErrorToDBX(object: DBFILESListRevisionsError) -> DBXFilesListRevisionsError {
    if object.isPath() {
        let path = mapDBFILESLookupErrorToDBX(object: object.path)
        return DBXFilesListRevisionsError.factory(swift: .path(path.swift))
    }
    if object.isOther() {
        return DBXFilesListRevisionsErrorOther()
    }
    fatalError("codegen error")
}

func mapDBFILESListRevisionsModeToDBXOptional(object: DBFILESListRevisionsMode?) -> DBXFilesListRevisionsMode? {
    guard let object = object else { return nil }
    return mapDBFILESListRevisionsModeToDBX(object: object)
}

func mapDBFILESListRevisionsModeToDBX(object: DBFILESListRevisionsMode) -> DBXFilesListRevisionsMode {
    if object.isPath() {
        return DBXFilesListRevisionsModePath()
    }
    if object.isId_() {
        return DBXFilesListRevisionsModeId()
    }
    if object.isOther() {
        return DBXFilesListRevisionsModeOther()
    }
    fatalError("codegen error")
}

func mapDBFILESListRevisionsResultToDBXOptional(object: DBFILESListRevisionsResult?) -> DBXFilesListRevisionsResult? {
    guard let object = object else { return nil }
    return mapDBFILESListRevisionsResultToDBX(object: object)
}

func mapDBFILESListRevisionsResultToDBX(object: DBFILESListRevisionsResult) -> DBXFilesListRevisionsResult {
    DBXFilesListRevisionsResult(
        isDeleted: object.isDeleted,
        entries: object.entries.compactMap { mapDBFILESFileMetadataToDBX(object: $0) },
        serverDeleted: object.serverDeleted
    )
}

func mapDBFILESLockConflictErrorToDBXOptional(object: DBFILESLockConflictError?) -> DBXFilesLockConflictError? {
    guard let object = object else { return nil }
    return mapDBFILESLockConflictErrorToDBX(object: object)
}

func mapDBFILESLockConflictErrorToDBX(object: DBFILESLockConflictError) -> DBXFilesLockConflictError {
    DBXFilesLockConflictError(lock: mapDBFILESFileLockToDBX(object: object.lock))
}

func mapDBFILESLockFileArgToDBXOptional(object: DBFILESLockFileArg?) -> DBXFilesLockFileArg? {
    guard let object = object else { return nil }
    return mapDBFILESLockFileArgToDBX(object: object)
}

func mapDBFILESLockFileArgToDBX(object: DBFILESLockFileArg) -> DBXFilesLockFileArg {
    DBXFilesLockFileArg(path: object.path)
}

func mapDBFILESLockFileBatchArgToDBXOptional(object: DBFILESLockFileBatchArg?) -> DBXFilesLockFileBatchArg? {
    guard let object = object else { return nil }
    return mapDBFILESLockFileBatchArgToDBX(object: object)
}

func mapDBFILESLockFileBatchArgToDBX(object: DBFILESLockFileBatchArg) -> DBXFilesLockFileBatchArg {
    DBXFilesLockFileBatchArg(entries: object.entries.compactMap { mapDBFILESLockFileArgToDBX(object: $0) })
}

func mapDBFILESLockFileBatchResultToDBXOptional(object: DBFILESLockFileBatchResult?) -> DBXFilesLockFileBatchResult? {
    guard let object = object else { return nil }
    return mapDBFILESLockFileBatchResultToDBX(object: object)
}

func mapDBFILESLockFileBatchResultToDBX(object: DBFILESLockFileBatchResult) -> DBXFilesLockFileBatchResult {
    DBXFilesLockFileBatchResult(entries: object.entries.compactMap { mapDBFILESLockFileResultEntryToDBX(object: $0) })
}

func mapDBFILESLockFileErrorToDBXOptional(object: DBFILESLockFileError?) -> DBXFilesLockFileError? {
    guard let object = object else { return nil }
    return mapDBFILESLockFileErrorToDBX(object: object)
}

func mapDBFILESLockFileErrorToDBX(object: DBFILESLockFileError) -> DBXFilesLockFileError {
    if object.isPathLookup() {
        let pathLookup = mapDBFILESLookupErrorToDBX(object: object.pathLookup)
        return DBXFilesLockFileError.factory(swift: .pathLookup(pathLookup.swift))
    }
    if object.isTooManyWriteOperations() {
        return DBXFilesLockFileErrorTooManyWriteOperations()
    }
    if object.isTooManyFiles() {
        return DBXFilesLockFileErrorTooManyFiles()
    }
    if object.isNoWritePermission() {
        return DBXFilesLockFileErrorNoWritePermission()
    }
    if object.isCannotBeLocked() {
        return DBXFilesLockFileErrorCannotBeLocked()
    }
    if object.isFileNotShared() {
        return DBXFilesLockFileErrorFileNotShared()
    }
    if object.isLockConflict() {
        let lockConflict = mapDBFILESLockConflictErrorToDBX(object: object.lockConflict)
        return DBXFilesLockFileError.factory(swift: .lockConflict(lockConflict.swift))
    }
    if object.isInternalError() {
        return DBXFilesLockFileErrorInternalError()
    }
    if object.isOther() {
        return DBXFilesLockFileErrorOther()
    }
    fatalError("codegen error")
}

func mapDBFILESLockFileResultToDBXOptional(object: DBFILESLockFileResult?) -> DBXFilesLockFileResult? {
    guard let object = object else { return nil }
    return mapDBFILESLockFileResultToDBX(object: object)
}

func mapDBFILESLockFileResultToDBX(object: DBFILESLockFileResult) -> DBXFilesLockFileResult {
    DBXFilesLockFileResult(metadata: mapDBFILESMetadataToDBX(object: object.metadata), lock: mapDBFILESFileLockToDBX(object: object.lock))
}

func mapDBFILESLockFileResultEntryToDBXOptional(object: DBFILESLockFileResultEntry?) -> DBXFilesLockFileResultEntry? {
    guard let object = object else { return nil }
    return mapDBFILESLockFileResultEntryToDBX(object: object)
}

func mapDBFILESLockFileResultEntryToDBX(object: DBFILESLockFileResultEntry) -> DBXFilesLockFileResultEntry {
    if object.isSuccess() {
        let success = mapDBFILESLockFileResultToDBX(object: object.success)
        return DBXFilesLockFileResultEntry.factory(swift: .success(success.swift))
    }
    if object.isFailure() {
        let failure = mapDBFILESLockFileErrorToDBX(object: object.failure)
        return DBXFilesLockFileResultEntry.factory(swift: .failure(failure.swift))
    }
    fatalError("codegen error")
}

func mapDBFILESLookupErrorToDBXOptional(object: DBFILESLookupError?) -> DBXFilesLookupError? {
    guard let object = object else { return nil }
    return mapDBFILESLookupErrorToDBX(object: object)
}

func mapDBFILESLookupErrorToDBX(object: DBFILESLookupError) -> DBXFilesLookupError {
    if object.isMalformedPath() {
        let malformedPath = object.malformedPath
        return DBXFilesLookupError.factory(swift: .malformedPath(malformedPath))
    }
    if object.isNotFound() {
        return DBXFilesLookupErrorNotFound()
    }
    if object.isNotFile() {
        return DBXFilesLookupErrorNotFile()
    }
    if object.isNotFolder() {
        return DBXFilesLookupErrorNotFolder()
    }
    if object.isRestrictedContent() {
        return DBXFilesLookupErrorRestrictedContent()
    }
    if object.isUnsupportedContentType() {
        return DBXFilesLookupErrorUnsupportedContentType()
    }
    if object.isLocked() {
        return DBXFilesLookupErrorLocked()
    }
    if object.isOther() {
        return DBXFilesLookupErrorOther()
    }
    fatalError("codegen error")
}

func mapDBFILESMediaInfoToDBXOptional(object: DBFILESMediaInfo?) -> DBXFilesMediaInfo? {
    guard let object = object else { return nil }
    return mapDBFILESMediaInfoToDBX(object: object)
}

func mapDBFILESMediaInfoToDBX(object: DBFILESMediaInfo) -> DBXFilesMediaInfo {
    if object.isPending() {
        return DBXFilesMediaInfoPending()
    }
    if object.isMetadata() {
        let metadata = mapDBFILESMediaMetadataToDBX(object: object.metadata)
        return DBXFilesMediaInfo.factory(swift: .metadata(metadata.swift))
    }
    fatalError("codegen error")
}

func mapDBFILESMediaMetadataToDBXOptional(object: DBFILESMediaMetadata?) -> DBXFilesMediaMetadata? {
    guard let object = object else { return nil }
    return mapDBFILESMediaMetadataToDBX(object: object)
}

func mapDBFILESMediaMetadataToDBX(object: DBFILESMediaMetadata) -> DBXFilesMediaMetadata {
    switch object {
    case let object as DBFILESPhotoMetadata:
        return DBXFilesPhotoMetadata(
            dimensions: mapDBFILESDimensionsToDBXOptional(object: object.dimensions),
            location: mapDBFILESGpsCoordinatesToDBXOptional(object: object.location),
            timeTaken: object.timeTaken
        )
    case let object as DBFILESVideoMetadata:
        return DBXFilesVideoMetadata(
            dimensions: mapDBFILESDimensionsToDBXOptional(object: object.dimensions),
            location: mapDBFILESGpsCoordinatesToDBXOptional(object: object.location),
            timeTaken: object.timeTaken,
            duration: object.duration
        )
    default:
        return DBXFilesMediaMetadata(
            dimensions: mapDBFILESDimensionsToDBXOptional(object: object.dimensions),
            location: mapDBFILESGpsCoordinatesToDBXOptional(object: object.location),
            timeTaken: object.timeTaken
        )
    }
}

func mapDBFILESMetadataV2ToDBXOptional(object: DBFILESMetadataV2?) -> DBXFilesMetadataV2? {
    guard let object = object else { return nil }
    return mapDBFILESMetadataV2ToDBX(object: object)
}

func mapDBFILESMetadataV2ToDBX(object: DBFILESMetadataV2) -> DBXFilesMetadataV2 {
    if object.isMetadata() {
        let metadata = mapDBFILESMetadataToDBX(object: object.metadata)
        return DBXFilesMetadataV2.factory(swift: .metadata(metadata.swift))
    }
    if object.isOther() {
        return DBXFilesMetadataV2Other()
    }
    fatalError("codegen error")
}

func mapDBFILESMinimalFileLinkMetadataToDBXOptional(object: DBFILESMinimalFileLinkMetadata?) -> DBXFilesMinimalFileLinkMetadata? {
    guard let object = object else { return nil }
    return mapDBFILESMinimalFileLinkMetadataToDBX(object: object)
}

func mapDBFILESMinimalFileLinkMetadataToDBX(object: DBFILESMinimalFileLinkMetadata) -> DBXFilesMinimalFileLinkMetadata {
    DBXFilesMinimalFileLinkMetadata(url: object.url, rev: object.rev, id: object.id_, path: object.path)
}

func mapDBFILESRelocationBatchArgBaseToDBXOptional(object: DBFILESRelocationBatchArgBase?) -> DBXFilesRelocationBatchArgBase? {
    guard let object = object else { return nil }
    return mapDBFILESRelocationBatchArgBaseToDBX(object: object)
}

func mapDBFILESRelocationBatchArgBaseToDBX(object: DBFILESRelocationBatchArgBase) -> DBXFilesRelocationBatchArgBase {
    DBXFilesRelocationBatchArgBase(entries: object.entries.compactMap { mapDBFILESRelocationPathToDBX(object: $0) }, autorename: object.autorename)
}

func mapDBFILESMoveBatchArgToDBXOptional(object: DBFILESMoveBatchArg?) -> DBXFilesMoveBatchArg? {
    guard let object = object else { return nil }
    return mapDBFILESMoveBatchArgToDBX(object: object)
}

func mapDBFILESMoveBatchArgToDBX(object: DBFILESMoveBatchArg) -> DBXFilesMoveBatchArg {
    DBXFilesMoveBatchArg(
        entries: object.entries.compactMap { mapDBFILESRelocationPathToDBX(object: $0) },
        autorename: object.autorename,
        allowOwnershipTransfer: object.allowOwnershipTransfer
    )
}

func mapDBFILESMoveIntoFamilyErrorToDBXOptional(object: DBFILESMoveIntoFamilyError?) -> DBXFilesMoveIntoFamilyError? {
    guard let object = object else { return nil }
    return mapDBFILESMoveIntoFamilyErrorToDBX(object: object)
}

func mapDBFILESMoveIntoFamilyErrorToDBX(object: DBFILESMoveIntoFamilyError) -> DBXFilesMoveIntoFamilyError {
    if object.isIsSharedFolder() {
        return DBXFilesMoveIntoFamilyErrorIsSharedFolder()
    }
    if object.isOther() {
        return DBXFilesMoveIntoFamilyErrorOther()
    }
    fatalError("codegen error")
}

func mapDBFILESMoveIntoVaultErrorToDBXOptional(object: DBFILESMoveIntoVaultError?) -> DBXFilesMoveIntoVaultError? {
    guard let object = object else { return nil }
    return mapDBFILESMoveIntoVaultErrorToDBX(object: object)
}

func mapDBFILESMoveIntoVaultErrorToDBX(object: DBFILESMoveIntoVaultError) -> DBXFilesMoveIntoVaultError {
    if object.isIsSharedFolder() {
        return DBXFilesMoveIntoVaultErrorIsSharedFolder()
    }
    if object.isOther() {
        return DBXFilesMoveIntoVaultErrorOther()
    }
    fatalError("codegen error")
}

func mapDBFILESPaperContentErrorToDBXOptional(object: DBFILESPaperContentError?) -> DBXFilesPaperContentError? {
    guard let object = object else { return nil }
    return mapDBFILESPaperContentErrorToDBX(object: object)
}

func mapDBFILESPaperContentErrorToDBX(object: DBFILESPaperContentError) -> DBXFilesPaperContentError {
    if object.isInsufficientPermissions() {
        return DBXFilesPaperContentErrorInsufficientPermissions()
    }
    if object.isContentMalformed() {
        return DBXFilesPaperContentErrorContentMalformed()
    }
    if object.isDocLengthExceeded() {
        return DBXFilesPaperContentErrorDocLengthExceeded()
    }
    if object.isImageSizeExceeded() {
        return DBXFilesPaperContentErrorImageSizeExceeded()
    }
    if object.isOther() {
        return DBXFilesPaperContentErrorOther()
    }
    fatalError("codegen error")
}

func mapDBFILESPaperCreateArgToDBXOptional(object: DBFILESPaperCreateArg?) -> DBXFilesPaperCreateArg? {
    guard let object = object else { return nil }
    return mapDBFILESPaperCreateArgToDBX(object: object)
}

func mapDBFILESPaperCreateArgToDBX(object: DBFILESPaperCreateArg) -> DBXFilesPaperCreateArg {
    DBXFilesPaperCreateArg(path: object.path, importFormat: mapDBFILESImportFormatToDBX(object: object.importFormat))
}

func mapDBFILESPaperCreateErrorToDBXOptional(object: DBFILESPaperCreateError?) -> DBXFilesPaperCreateError? {
    guard let object = object else { return nil }
    return mapDBFILESPaperCreateErrorToDBX(object: object)
}

func mapDBFILESPaperCreateErrorToDBX(object: DBFILESPaperCreateError) -> DBXFilesPaperCreateError {
    if object.isInsufficientPermissions() {
        return DBXFilesPaperCreateErrorInsufficientPermissions()
    }
    if object.isContentMalformed() {
        return DBXFilesPaperCreateErrorContentMalformed()
    }
    if object.isDocLengthExceeded() {
        return DBXFilesPaperCreateErrorDocLengthExceeded()
    }
    if object.isImageSizeExceeded() {
        return DBXFilesPaperCreateErrorImageSizeExceeded()
    }
    if object.isOther() {
        return DBXFilesPaperCreateErrorOther()
    }
    if object.isInvalidPath() {
        return DBXFilesPaperCreateErrorInvalidPath()
    }
    if object.isEmailUnverified() {
        return DBXFilesPaperCreateErrorEmailUnverified()
    }
    if object.isInvalidFileExtension() {
        return DBXFilesPaperCreateErrorInvalidFileExtension()
    }
    if object.isPaperDisabled() {
        return DBXFilesPaperCreateErrorPaperDisabled()
    }
    fatalError("codegen error")
}

func mapDBFILESPaperCreateResultToDBXOptional(object: DBFILESPaperCreateResult?) -> DBXFilesPaperCreateResult? {
    guard let object = object else { return nil }
    return mapDBFILESPaperCreateResultToDBX(object: object)
}

func mapDBFILESPaperCreateResultToDBX(object: DBFILESPaperCreateResult) -> DBXFilesPaperCreateResult {
    DBXFilesPaperCreateResult(url: object.url, resultPath: object.resultPath, fileId: object.fileId, paperRevision: object.paperRevision)
}

func mapDBFILESPaperDocUpdatePolicyToDBXOptional(object: DBFILESPaperDocUpdatePolicy?) -> DBXFilesPaperDocUpdatePolicy? {
    guard let object = object else { return nil }
    return mapDBFILESPaperDocUpdatePolicyToDBX(object: object)
}

func mapDBFILESPaperDocUpdatePolicyToDBX(object: DBFILESPaperDocUpdatePolicy) -> DBXFilesPaperDocUpdatePolicy {
    if object.isUpdate() {
        return DBXFilesPaperDocUpdatePolicyUpdate()
    }
    if object.isOverwrite() {
        return DBXFilesPaperDocUpdatePolicyOverwrite()
    }
    if object.isPrepend() {
        return DBXFilesPaperDocUpdatePolicyPrepend()
    }
    if object.isAppend() {
        return DBXFilesPaperDocUpdatePolicyAppend()
    }
    if object.isOther() {
        return DBXFilesPaperDocUpdatePolicyOther()
    }
    fatalError("codegen error")
}

func mapDBFILESPaperUpdateArgToDBXOptional(object: DBFILESPaperUpdateArg?) -> DBXFilesPaperUpdateArg? {
    guard let object = object else { return nil }
    return mapDBFILESPaperUpdateArgToDBX(object: object)
}

func mapDBFILESPaperUpdateArgToDBX(object: DBFILESPaperUpdateArg) -> DBXFilesPaperUpdateArg {
    DBXFilesPaperUpdateArg(
        path: object.path,
        importFormat: mapDBFILESImportFormatToDBX(object: object.importFormat),
        docUpdatePolicy: mapDBFILESPaperDocUpdatePolicyToDBX(object: object.docUpdatePolicy),
        paperRevision: object.paperRevision
    )
}

func mapDBFILESPaperUpdateErrorToDBXOptional(object: DBFILESPaperUpdateError?) -> DBXFilesPaperUpdateError? {
    guard let object = object else { return nil }
    return mapDBFILESPaperUpdateErrorToDBX(object: object)
}

func mapDBFILESPaperUpdateErrorToDBX(object: DBFILESPaperUpdateError) -> DBXFilesPaperUpdateError {
    if object.isInsufficientPermissions() {
        return DBXFilesPaperUpdateErrorInsufficientPermissions()
    }
    if object.isContentMalformed() {
        return DBXFilesPaperUpdateErrorContentMalformed()
    }
    if object.isDocLengthExceeded() {
        return DBXFilesPaperUpdateErrorDocLengthExceeded()
    }
    if object.isImageSizeExceeded() {
        return DBXFilesPaperUpdateErrorImageSizeExceeded()
    }
    if object.isOther() {
        return DBXFilesPaperUpdateErrorOther()
    }
    if object.isPath() {
        let path = mapDBFILESLookupErrorToDBX(object: object.path)
        return DBXFilesPaperUpdateError.factory(swift: .path(path.swift))
    }
    if object.isRevisionMismatch() {
        return DBXFilesPaperUpdateErrorRevisionMismatch()
    }
    if object.isDocArchived() {
        return DBXFilesPaperUpdateErrorDocArchived()
    }
    if object.isDocDeleted() {
        return DBXFilesPaperUpdateErrorDocDeleted()
    }
    fatalError("codegen error")
}

func mapDBFILESPaperUpdateResultToDBXOptional(object: DBFILESPaperUpdateResult?) -> DBXFilesPaperUpdateResult? {
    guard let object = object else { return nil }
    return mapDBFILESPaperUpdateResultToDBX(object: object)
}

func mapDBFILESPaperUpdateResultToDBX(object: DBFILESPaperUpdateResult) -> DBXFilesPaperUpdateResult {
    DBXFilesPaperUpdateResult(paperRevision: object.paperRevision)
}

func mapDBFILESPathOrLinkToDBXOptional(object: DBFILESPathOrLink?) -> DBXFilesPathOrLink? {
    guard let object = object else { return nil }
    return mapDBFILESPathOrLinkToDBX(object: object)
}

func mapDBFILESPathOrLinkToDBX(object: DBFILESPathOrLink) -> DBXFilesPathOrLink {
    if object.isPath() {
        let path = object.path
        return DBXFilesPathOrLink.factory(swift: .path(path))
    }
    if object.isLink() {
        let link = mapDBFILESSharedLinkFileInfoToDBX(object: object.link)
        return DBXFilesPathOrLink.factory(swift: .link(link.swift))
    }
    if object.isOther() {
        return DBXFilesPathOrLinkOther()
    }
    fatalError("codegen error")
}

func mapDBFILESPathToTagsToDBXOptional(object: DBFILESPathToTags?) -> DBXFilesPathToTags? {
    guard let object = object else { return nil }
    return mapDBFILESPathToTagsToDBX(object: object)
}

func mapDBFILESPathToTagsToDBX(object: DBFILESPathToTags) -> DBXFilesPathToTags {
    DBXFilesPathToTags(path: object.path, tags: object.tags.compactMap { mapDBFILESTagToDBX(object: $0) })
}

func mapDBFILESPhotoMetadataToDBXOptional(object: DBFILESPhotoMetadata?) -> DBXFilesPhotoMetadata? {
    guard let object = object else { return nil }
    return mapDBFILESPhotoMetadataToDBX(object: object)
}

func mapDBFILESPhotoMetadataToDBX(object: DBFILESPhotoMetadata) -> DBXFilesPhotoMetadata {
    DBXFilesPhotoMetadata(
        dimensions: mapDBFILESDimensionsToDBXOptional(object: object.dimensions),
        location: mapDBFILESGpsCoordinatesToDBXOptional(object: object.location),
        timeTaken: object.timeTaken
    )
}

func mapDBFILESPreviewArgToDBXOptional(object: DBFILESPreviewArg?) -> DBXFilesPreviewArg? {
    guard let object = object else { return nil }
    return mapDBFILESPreviewArgToDBX(object: object)
}

func mapDBFILESPreviewArgToDBX(object: DBFILESPreviewArg) -> DBXFilesPreviewArg {
    DBXFilesPreviewArg(path: object.path, rev: object.rev)
}

func mapDBFILESPreviewErrorToDBXOptional(object: DBFILESPreviewError?) -> DBXFilesPreviewError? {
    guard let object = object else { return nil }
    return mapDBFILESPreviewErrorToDBX(object: object)
}

func mapDBFILESPreviewErrorToDBX(object: DBFILESPreviewError) -> DBXFilesPreviewError {
    if object.isPath() {
        let path = mapDBFILESLookupErrorToDBX(object: object.path)
        return DBXFilesPreviewError.factory(swift: .path(path.swift))
    }
    if object.isInProgress() {
        return DBXFilesPreviewErrorInProgress()
    }
    if object.isUnsupportedExtension() {
        return DBXFilesPreviewErrorUnsupportedExtension()
    }
    if object.isUnsupportedContent() {
        return DBXFilesPreviewErrorUnsupportedContent()
    }
    fatalError("codegen error")
}

func mapDBFILESPreviewResultToDBXOptional(object: DBFILESPreviewResult?) -> DBXFilesPreviewResult? {
    guard let object = object else { return nil }
    return mapDBFILESPreviewResultToDBX(object: object)
}

func mapDBFILESPreviewResultToDBX(object: DBFILESPreviewResult) -> DBXFilesPreviewResult {
    DBXFilesPreviewResult(
        fileMetadata: mapDBFILESFileMetadataToDBXOptional(object: object.fileMetadata),
        linkMetadata: mapDBFILESMinimalFileLinkMetadataToDBXOptional(object: object.linkMetadata)
    )
}

func mapDBFILESRelocationPathToDBXOptional(object: DBFILESRelocationPath?) -> DBXFilesRelocationPath? {
    guard let object = object else { return nil }
    return mapDBFILESRelocationPathToDBX(object: object)
}

func mapDBFILESRelocationPathToDBX(object: DBFILESRelocationPath) -> DBXFilesRelocationPath {
    DBXFilesRelocationPath(fromPath: object.fromPath, toPath: object.toPath)
}

func mapDBFILESRelocationArgToDBXOptional(object: DBFILESRelocationArg?) -> DBXFilesRelocationArg? {
    guard let object = object else { return nil }
    return mapDBFILESRelocationArgToDBX(object: object)
}

func mapDBFILESRelocationArgToDBX(object: DBFILESRelocationArg) -> DBXFilesRelocationArg {
    DBXFilesRelocationArg(
        fromPath: object.fromPath,
        toPath: object.toPath,
        allowSharedFolder: object.allowSharedFolder,
        autorename: object.autorename,
        allowOwnershipTransfer: object.allowOwnershipTransfer
    )
}

func mapDBFILESRelocationBatchArgToDBXOptional(object: DBFILESRelocationBatchArg?) -> DBXFilesRelocationBatchArg? {
    guard let object = object else { return nil }
    return mapDBFILESRelocationBatchArgToDBX(object: object)
}

func mapDBFILESRelocationBatchArgToDBX(object: DBFILESRelocationBatchArg) -> DBXFilesRelocationBatchArg {
    DBXFilesRelocationBatchArg(
        entries: object.entries.compactMap { mapDBFILESRelocationPathToDBX(object: $0) },
        autorename: object.autorename,
        allowSharedFolder: object.allowSharedFolder,
        allowOwnershipTransfer: object.allowOwnershipTransfer
    )
}

func mapDBFILESRelocationErrorToDBXOptional(object: DBFILESRelocationError?) -> DBXFilesRelocationError? {
    guard let object = object else { return nil }
    return mapDBFILESRelocationErrorToDBX(object: object)
}

func mapDBFILESRelocationErrorToDBX(object: DBFILESRelocationError) -> DBXFilesRelocationError {
    if object.isFromLookup() {
        let fromLookup = mapDBFILESLookupErrorToDBX(object: object.fromLookup)
        return DBXFilesRelocationError.factory(swift: .fromLookup(fromLookup.swift))
    }
    if object.isFromWrite() {
        let fromWrite = mapDBFILESWriteErrorToDBX(object: object.fromWrite)
        return DBXFilesRelocationError.factory(swift: .fromWrite(fromWrite.swift))
    }
    if object.isTo() {
        let to = mapDBFILESWriteErrorToDBX(object: object.to)
        return DBXFilesRelocationError.factory(swift: .to(to.swift))
    }
    if object.isCantCopySharedFolder() {
        return DBXFilesRelocationErrorCantCopySharedFolder()
    }
    if object.isCantNestSharedFolder() {
        return DBXFilesRelocationErrorCantNestSharedFolder()
    }
    if object.isCantMoveFolderIntoItself() {
        return DBXFilesRelocationErrorCantMoveFolderIntoItself()
    }
    if object.isTooManyFiles() {
        return DBXFilesRelocationErrorTooManyFiles()
    }
    if object.isDuplicatedOrNestedPaths() {
        return DBXFilesRelocationErrorDuplicatedOrNestedPaths()
    }
    if object.isCantTransferOwnership() {
        return DBXFilesRelocationErrorCantTransferOwnership()
    }
    if object.isInsufficientQuota() {
        return DBXFilesRelocationErrorInsufficientQuota()
    }
    if object.isInternalError() {
        return DBXFilesRelocationErrorInternalError()
    }
    if object.isCantMoveSharedFolder() {
        return DBXFilesRelocationErrorCantMoveSharedFolder()
    }
    if object.isCantMoveIntoVault() {
        let cantMoveIntoVault = mapDBFILESMoveIntoVaultErrorToDBX(object: object.cantMoveIntoVault)
        return DBXFilesRelocationError.factory(swift: .cantMoveIntoVault(cantMoveIntoVault.swift))
    }
    if object.isCantMoveIntoFamily() {
        let cantMoveIntoFamily = mapDBFILESMoveIntoFamilyErrorToDBX(object: object.cantMoveIntoFamily)
        return DBXFilesRelocationError.factory(swift: .cantMoveIntoFamily(cantMoveIntoFamily.swift))
    }
    if object.isOther() {
        return DBXFilesRelocationErrorOther()
    }
    fatalError("codegen error")
}

func mapDBFILESRelocationBatchErrorToDBXOptional(object: DBFILESRelocationBatchError?) -> DBXFilesRelocationBatchError? {
    guard let object = object else { return nil }
    return mapDBFILESRelocationBatchErrorToDBX(object: object)
}

func mapDBFILESRelocationBatchErrorToDBX(object: DBFILESRelocationBatchError) -> DBXFilesRelocationBatchError {
    if object.isFromLookup() {
        let fromLookup = mapDBFILESLookupErrorToDBX(object: object.fromLookup)
        return DBXFilesRelocationBatchError.factory(swift: .fromLookup(fromLookup.swift))
    }
    if object.isFromWrite() {
        let fromWrite = mapDBFILESWriteErrorToDBX(object: object.fromWrite)
        return DBXFilesRelocationBatchError.factory(swift: .fromWrite(fromWrite.swift))
    }
    if object.isTo() {
        let to = mapDBFILESWriteErrorToDBX(object: object.to)
        return DBXFilesRelocationBatchError.factory(swift: .to(to.swift))
    }
    if object.isCantCopySharedFolder() {
        return DBXFilesRelocationBatchErrorCantCopySharedFolder()
    }
    if object.isCantNestSharedFolder() {
        return DBXFilesRelocationBatchErrorCantNestSharedFolder()
    }
    if object.isCantMoveFolderIntoItself() {
        return DBXFilesRelocationBatchErrorCantMoveFolderIntoItself()
    }
    if object.isTooManyFiles() {
        return DBXFilesRelocationBatchErrorTooManyFiles()
    }
    if object.isDuplicatedOrNestedPaths() {
        return DBXFilesRelocationBatchErrorDuplicatedOrNestedPaths()
    }
    if object.isCantTransferOwnership() {
        return DBXFilesRelocationBatchErrorCantTransferOwnership()
    }
    if object.isInsufficientQuota() {
        return DBXFilesRelocationBatchErrorInsufficientQuota()
    }
    if object.isInternalError() {
        return DBXFilesRelocationBatchErrorInternalError()
    }
    if object.isCantMoveSharedFolder() {
        return DBXFilesRelocationBatchErrorCantMoveSharedFolder()
    }
    if object.isCantMoveIntoVault() {
        let cantMoveIntoVault = mapDBFILESMoveIntoVaultErrorToDBX(object: object.cantMoveIntoVault)
        return DBXFilesRelocationBatchError.factory(swift: .cantMoveIntoVault(cantMoveIntoVault.swift))
    }
    if object.isCantMoveIntoFamily() {
        let cantMoveIntoFamily = mapDBFILESMoveIntoFamilyErrorToDBX(object: object.cantMoveIntoFamily)
        return DBXFilesRelocationBatchError.factory(swift: .cantMoveIntoFamily(cantMoveIntoFamily.swift))
    }
    if object.isOther() {
        return DBXFilesRelocationBatchErrorOther()
    }
    if object.isTooManyWriteOperations() {
        return DBXFilesRelocationBatchErrorTooManyWriteOperations()
    }
    fatalError("codegen error")
}

func mapDBFILESRelocationBatchErrorEntryToDBXOptional(object: DBFILESRelocationBatchErrorEntry?) -> DBXFilesRelocationBatchErrorEntry? {
    guard let object = object else { return nil }
    return mapDBFILESRelocationBatchErrorEntryToDBX(object: object)
}

func mapDBFILESRelocationBatchErrorEntryToDBX(object: DBFILESRelocationBatchErrorEntry) -> DBXFilesRelocationBatchErrorEntry {
    if object.isRelocationError() {
        let relocationError = mapDBFILESRelocationErrorToDBX(object: object.relocationError)
        return DBXFilesRelocationBatchErrorEntry.factory(swift: .relocationError(relocationError.swift))
    }
    if object.isInternalError() {
        return DBXFilesRelocationBatchErrorEntryInternalError()
    }
    if object.isTooManyWriteOperations() {
        return DBXFilesRelocationBatchErrorEntryTooManyWriteOperations()
    }
    if object.isOther() {
        return DBXFilesRelocationBatchErrorEntryOther()
    }
    fatalError("codegen error")
}

func mapDBFILESRelocationBatchJobStatusToDBXOptional(object: DBFILESRelocationBatchJobStatus?) -> DBXFilesRelocationBatchJobStatus? {
    guard let object = object else { return nil }
    return mapDBFILESRelocationBatchJobStatusToDBX(object: object)
}

func mapDBFILESRelocationBatchJobStatusToDBX(object: DBFILESRelocationBatchJobStatus) -> DBXFilesRelocationBatchJobStatus {
    if object.isInProgress() {
        return DBXFilesRelocationBatchJobStatusInProgress()
    }
    if object.isComplete() {
        let complete = mapDBFILESRelocationBatchResultToDBX(object: object.complete)
        return DBXFilesRelocationBatchJobStatus.factory(swift: .complete(complete.subSwift))
    }
    if object.isFailed() {
        let failed = mapDBFILESRelocationBatchErrorToDBX(object: object.failed)
        return DBXFilesRelocationBatchJobStatus.factory(swift: .failed(failed.swift))
    }
    fatalError("codegen error")
}

func mapDBFILESRelocationBatchLaunchToDBXOptional(object: DBFILESRelocationBatchLaunch?) -> DBXFilesRelocationBatchLaunch? {
    guard let object = object else { return nil }
    return mapDBFILESRelocationBatchLaunchToDBX(object: object)
}

func mapDBFILESRelocationBatchLaunchToDBX(object: DBFILESRelocationBatchLaunch) -> DBXFilesRelocationBatchLaunch {
    if object.isAsyncJobId() {
        let asyncJobId = object.asyncJobId
        return DBXFilesRelocationBatchLaunch.factory(swift: .asyncJobId(asyncJobId))
    }
    if object.isComplete() {
        let complete = mapDBFILESRelocationBatchResultToDBX(object: object.complete)
        return DBXFilesRelocationBatchLaunch.factory(swift: .complete(complete.subSwift))
    }
    if object.isOther() {
        return DBXFilesRelocationBatchLaunchOther()
    }
    fatalError("codegen error")
}

func mapDBFILESRelocationBatchResultToDBXOptional(object: DBFILESRelocationBatchResult?) -> DBXFilesRelocationBatchResult? {
    guard let object = object else { return nil }
    return mapDBFILESRelocationBatchResultToDBX(object: object)
}

func mapDBFILESRelocationBatchResultToDBX(object: DBFILESRelocationBatchResult) -> DBXFilesRelocationBatchResult {
    DBXFilesRelocationBatchResult(entries: object.entries.compactMap { mapDBFILESRelocationBatchResultDataToDBX(object: $0) })
}

func mapDBFILESRelocationBatchResultDataToDBXOptional(object: DBFILESRelocationBatchResultData?) -> DBXFilesRelocationBatchResultData? {
    guard let object = object else { return nil }
    return mapDBFILESRelocationBatchResultDataToDBX(object: object)
}

func mapDBFILESRelocationBatchResultDataToDBX(object: DBFILESRelocationBatchResultData) -> DBXFilesRelocationBatchResultData {
    DBXFilesRelocationBatchResultData(metadata: mapDBFILESMetadataToDBX(object: object.metadata))
}

func mapDBFILESRelocationBatchResultEntryToDBXOptional(object: DBFILESRelocationBatchResultEntry?) -> DBXFilesRelocationBatchResultEntry? {
    guard let object = object else { return nil }
    return mapDBFILESRelocationBatchResultEntryToDBX(object: object)
}

func mapDBFILESRelocationBatchResultEntryToDBX(object: DBFILESRelocationBatchResultEntry) -> DBXFilesRelocationBatchResultEntry {
    if object.isSuccess() {
        let success = mapDBFILESMetadataToDBX(object: object.success)
        return DBXFilesRelocationBatchResultEntry.factory(swift: .success(success.swift))
    }
    if object.isFailure() {
        let failure = mapDBFILESRelocationBatchErrorEntryToDBX(object: object.failure)
        return DBXFilesRelocationBatchResultEntry.factory(swift: .failure(failure.swift))
    }
    if object.isOther() {
        return DBXFilesRelocationBatchResultEntryOther()
    }
    fatalError("codegen error")
}

func mapDBFILESRelocationBatchV2JobStatusToDBXOptional(object: DBFILESRelocationBatchV2JobStatus?) -> DBXFilesRelocationBatchV2JobStatus? {
    guard let object = object else { return nil }
    return mapDBFILESRelocationBatchV2JobStatusToDBX(object: object)
}

func mapDBFILESRelocationBatchV2JobStatusToDBX(object: DBFILESRelocationBatchV2JobStatus) -> DBXFilesRelocationBatchV2JobStatus {
    if object.isInProgress() {
        return DBXFilesRelocationBatchV2JobStatusInProgress()
    }
    if object.isComplete() {
        let complete = mapDBFILESRelocationBatchV2ResultToDBX(object: object.complete)
        return DBXFilesRelocationBatchV2JobStatus.factory(swift: .complete(complete.subSwift))
    }
    fatalError("codegen error")
}

func mapDBFILESRelocationBatchV2LaunchToDBXOptional(object: DBFILESRelocationBatchV2Launch?) -> DBXFilesRelocationBatchV2Launch? {
    guard let object = object else { return nil }
    return mapDBFILESRelocationBatchV2LaunchToDBX(object: object)
}

func mapDBFILESRelocationBatchV2LaunchToDBX(object: DBFILESRelocationBatchV2Launch) -> DBXFilesRelocationBatchV2Launch {
    if object.isAsyncJobId() {
        let asyncJobId = object.asyncJobId
        return DBXFilesRelocationBatchV2Launch.factory(swift: .asyncJobId(asyncJobId))
    }
    if object.isComplete() {
        let complete = mapDBFILESRelocationBatchV2ResultToDBX(object: object.complete)
        return DBXFilesRelocationBatchV2Launch.factory(swift: .complete(complete.subSwift))
    }
    fatalError("codegen error")
}

func mapDBFILESRelocationBatchV2ResultToDBXOptional(object: DBFILESRelocationBatchV2Result?) -> DBXFilesRelocationBatchV2Result? {
    guard let object = object else { return nil }
    return mapDBFILESRelocationBatchV2ResultToDBX(object: object)
}

func mapDBFILESRelocationBatchV2ResultToDBX(object: DBFILESRelocationBatchV2Result) -> DBXFilesRelocationBatchV2Result {
    DBXFilesRelocationBatchV2Result(entries: object.entries.compactMap { mapDBFILESRelocationBatchResultEntryToDBX(object: $0) })
}

func mapDBFILESRelocationResultToDBXOptional(object: DBFILESRelocationResult?) -> DBXFilesRelocationResult? {
    guard let object = object else { return nil }
    return mapDBFILESRelocationResultToDBX(object: object)
}

func mapDBFILESRelocationResultToDBX(object: DBFILESRelocationResult) -> DBXFilesRelocationResult {
    DBXFilesRelocationResult(metadata: mapDBFILESMetadataToDBX(object: object.metadata))
}

func mapDBFILESRemoveTagArgToDBXOptional(object: DBFILESRemoveTagArg?) -> DBXFilesRemoveTagArg? {
    guard let object = object else { return nil }
    return mapDBFILESRemoveTagArgToDBX(object: object)
}

func mapDBFILESRemoveTagArgToDBX(object: DBFILESRemoveTagArg) -> DBXFilesRemoveTagArg {
    DBXFilesRemoveTagArg(path: object.path, tagText: object.tagText)
}

func mapDBFILESRemoveTagErrorToDBXOptional(object: DBFILESRemoveTagError?) -> DBXFilesRemoveTagError? {
    guard let object = object else { return nil }
    return mapDBFILESRemoveTagErrorToDBX(object: object)
}

func mapDBFILESRemoveTagErrorToDBX(object: DBFILESRemoveTagError) -> DBXFilesRemoveTagError {
    if object.isPath() {
        let path = mapDBFILESLookupErrorToDBX(object: object.path)
        return DBXFilesRemoveTagError.factory(swift: .path(path.swift))
    }
    if object.isOther() {
        return DBXFilesRemoveTagErrorOther()
    }
    if object.isTagNotPresent() {
        return DBXFilesRemoveTagErrorTagNotPresent()
    }
    fatalError("codegen error")
}

func mapDBFILESRestoreArgToDBXOptional(object: DBFILESRestoreArg?) -> DBXFilesRestoreArg? {
    guard let object = object else { return nil }
    return mapDBFILESRestoreArgToDBX(object: object)
}

func mapDBFILESRestoreArgToDBX(object: DBFILESRestoreArg) -> DBXFilesRestoreArg {
    DBXFilesRestoreArg(path: object.path, rev: object.rev)
}

func mapDBFILESRestoreErrorToDBXOptional(object: DBFILESRestoreError?) -> DBXFilesRestoreError? {
    guard let object = object else { return nil }
    return mapDBFILESRestoreErrorToDBX(object: object)
}

func mapDBFILESRestoreErrorToDBX(object: DBFILESRestoreError) -> DBXFilesRestoreError {
    if object.isPathLookup() {
        let pathLookup = mapDBFILESLookupErrorToDBX(object: object.pathLookup)
        return DBXFilesRestoreError.factory(swift: .pathLookup(pathLookup.swift))
    }
    if object.isPathWrite() {
        let pathWrite = mapDBFILESWriteErrorToDBX(object: object.pathWrite)
        return DBXFilesRestoreError.factory(swift: .pathWrite(pathWrite.swift))
    }
    if object.isInvalidRevision() {
        return DBXFilesRestoreErrorInvalidRevision()
    }
    if object.isInProgress() {
        return DBXFilesRestoreErrorInProgress()
    }
    if object.isOther() {
        return DBXFilesRestoreErrorOther()
    }
    fatalError("codegen error")
}

func mapDBFILESSaveCopyReferenceArgToDBXOptional(object: DBFILESSaveCopyReferenceArg?) -> DBXFilesSaveCopyReferenceArg? {
    guard let object = object else { return nil }
    return mapDBFILESSaveCopyReferenceArgToDBX(object: object)
}

func mapDBFILESSaveCopyReferenceArgToDBX(object: DBFILESSaveCopyReferenceArg) -> DBXFilesSaveCopyReferenceArg {
    DBXFilesSaveCopyReferenceArg(copyReference: object.dCopyReference, path: object.path)
}

func mapDBFILESSaveCopyReferenceErrorToDBXOptional(object: DBFILESSaveCopyReferenceError?) -> DBXFilesSaveCopyReferenceError? {
    guard let object = object else { return nil }
    return mapDBFILESSaveCopyReferenceErrorToDBX(object: object)
}

func mapDBFILESSaveCopyReferenceErrorToDBX(object: DBFILESSaveCopyReferenceError) -> DBXFilesSaveCopyReferenceError {
    if object.isPath() {
        let path = mapDBFILESWriteErrorToDBX(object: object.path)
        return DBXFilesSaveCopyReferenceError.factory(swift: .path(path.swift))
    }
    if object.isInvalidCopyReference() {
        return DBXFilesSaveCopyReferenceErrorInvalidCopyReference()
    }
    if object.isNoPermission() {
        return DBXFilesSaveCopyReferenceErrorNoPermission()
    }
    if object.isNotFound() {
        return DBXFilesSaveCopyReferenceErrorNotFound()
    }
    if object.isTooManyFiles() {
        return DBXFilesSaveCopyReferenceErrorTooManyFiles()
    }
    if object.isOther() {
        return DBXFilesSaveCopyReferenceErrorOther()
    }
    fatalError("codegen error")
}

func mapDBFILESSaveCopyReferenceResultToDBXOptional(object: DBFILESSaveCopyReferenceResult?) -> DBXFilesSaveCopyReferenceResult? {
    guard let object = object else { return nil }
    return mapDBFILESSaveCopyReferenceResultToDBX(object: object)
}

func mapDBFILESSaveCopyReferenceResultToDBX(object: DBFILESSaveCopyReferenceResult) -> DBXFilesSaveCopyReferenceResult {
    DBXFilesSaveCopyReferenceResult(metadata: mapDBFILESMetadataToDBX(object: object.metadata))
}

func mapDBFILESSaveUrlArgToDBXOptional(object: DBFILESSaveUrlArg?) -> DBXFilesSaveUrlArg? {
    guard let object = object else { return nil }
    return mapDBFILESSaveUrlArgToDBX(object: object)
}

func mapDBFILESSaveUrlArgToDBX(object: DBFILESSaveUrlArg) -> DBXFilesSaveUrlArg {
    DBXFilesSaveUrlArg(path: object.path, url: object.url)
}

func mapDBFILESSaveUrlErrorToDBXOptional(object: DBFILESSaveUrlError?) -> DBXFilesSaveUrlError? {
    guard let object = object else { return nil }
    return mapDBFILESSaveUrlErrorToDBX(object: object)
}

func mapDBFILESSaveUrlErrorToDBX(object: DBFILESSaveUrlError) -> DBXFilesSaveUrlError {
    if object.isPath() {
        let path = mapDBFILESWriteErrorToDBX(object: object.path)
        return DBXFilesSaveUrlError.factory(swift: .path(path.swift))
    }
    if object.isDownloadFailed() {
        return DBXFilesSaveUrlErrorDownloadFailed()
    }
    if object.isInvalidUrl() {
        return DBXFilesSaveUrlErrorInvalidUrl()
    }
    if object.isNotFound() {
        return DBXFilesSaveUrlErrorNotFound()
    }
    if object.isOther() {
        return DBXFilesSaveUrlErrorOther()
    }
    fatalError("codegen error")
}

func mapDBFILESSaveUrlJobStatusToDBXOptional(object: DBFILESSaveUrlJobStatus?) -> DBXFilesSaveUrlJobStatus? {
    guard let object = object else { return nil }
    return mapDBFILESSaveUrlJobStatusToDBX(object: object)
}

func mapDBFILESSaveUrlJobStatusToDBX(object: DBFILESSaveUrlJobStatus) -> DBXFilesSaveUrlJobStatus {
    if object.isInProgress() {
        return DBXFilesSaveUrlJobStatusInProgress()
    }
    if object.isComplete() {
        let complete = mapDBFILESFileMetadataToDBX(object: object.complete)
        return DBXFilesSaveUrlJobStatus.factory(swift: .complete(complete.subSwift))
    }
    if object.isFailed() {
        let failed = mapDBFILESSaveUrlErrorToDBX(object: object.failed)
        return DBXFilesSaveUrlJobStatus.factory(swift: .failed(failed.swift))
    }
    fatalError("codegen error")
}

func mapDBFILESSaveUrlResultToDBXOptional(object: DBFILESSaveUrlResult?) -> DBXFilesSaveUrlResult? {
    guard let object = object else { return nil }
    return mapDBFILESSaveUrlResultToDBX(object: object)
}

func mapDBFILESSaveUrlResultToDBX(object: DBFILESSaveUrlResult) -> DBXFilesSaveUrlResult {
    if object.isAsyncJobId() {
        let asyncJobId = object.asyncJobId
        return DBXFilesSaveUrlResult.factory(swift: .asyncJobId(asyncJobId))
    }
    if object.isComplete() {
        let complete = mapDBFILESFileMetadataToDBX(object: object.complete)
        return DBXFilesSaveUrlResult.factory(swift: .complete(complete.subSwift))
    }
    fatalError("codegen error")
}

func mapDBFILESSearchArgToDBXOptional(object: DBFILESSearchArg?) -> DBXFilesSearchArg? {
    guard let object = object else { return nil }
    return mapDBFILESSearchArgToDBX(object: object)
}

func mapDBFILESSearchArgToDBX(object: DBFILESSearchArg) -> DBXFilesSearchArg {
    DBXFilesSearchArg(
        path: object.path,
        query: object.query,
        start: object.start,
        maxResults: object.maxResults,
        mode: mapDBFILESSearchModeToDBX(object: object.mode)
    )
}

func mapDBFILESSearchErrorToDBXOptional(object: DBFILESSearchError?) -> DBXFilesSearchError? {
    guard let object = object else { return nil }
    return mapDBFILESSearchErrorToDBX(object: object)
}

func mapDBFILESSearchErrorToDBX(object: DBFILESSearchError) -> DBXFilesSearchError {
    if object.isPath() {
        let path = mapDBFILESLookupErrorToDBX(object: object.path)
        return DBXFilesSearchError.factory(swift: .path(path.swift))
    }
    if object.isInvalidArgument() {
        let invalidArgument = object.invalidArgument
        return DBXFilesSearchError.factory(swift: .invalidArgument(invalidArgument))
    }
    if object.isInternalError() {
        return DBXFilesSearchErrorInternalError()
    }
    if object.isOther() {
        return DBXFilesSearchErrorOther()
    }
    fatalError("codegen error")
}

func mapDBFILESSearchMatchToDBXOptional(object: DBFILESSearchMatch?) -> DBXFilesSearchMatch? {
    guard let object = object else { return nil }
    return mapDBFILESSearchMatchToDBX(object: object)
}

func mapDBFILESSearchMatchToDBX(object: DBFILESSearchMatch) -> DBXFilesSearchMatch {
    DBXFilesSearchMatch(matchType: mapDBFILESSearchMatchTypeToDBX(object: object.matchType), metadata: mapDBFILESMetadataToDBX(object: object.metadata))
}

func mapDBFILESSearchMatchFieldOptionsToDBXOptional(object: DBFILESSearchMatchFieldOptions?) -> DBXFilesSearchMatchFieldOptions? {
    guard let object = object else { return nil }
    return mapDBFILESSearchMatchFieldOptionsToDBX(object: object)
}

func mapDBFILESSearchMatchFieldOptionsToDBX(object: DBFILESSearchMatchFieldOptions) -> DBXFilesSearchMatchFieldOptions {
    DBXFilesSearchMatchFieldOptions(includeHighlights: object.includeHighlights)
}

func mapDBFILESSearchMatchTypeToDBXOptional(object: DBFILESSearchMatchType?) -> DBXFilesSearchMatchType? {
    guard let object = object else { return nil }
    return mapDBFILESSearchMatchTypeToDBX(object: object)
}

func mapDBFILESSearchMatchTypeToDBX(object: DBFILESSearchMatchType) -> DBXFilesSearchMatchType {
    if object.isFilename() {
        return DBXFilesSearchMatchTypeFilename()
    }
    if object.isContent() {
        return DBXFilesSearchMatchTypeContent()
    }
    if object.isBoth() {
        return DBXFilesSearchMatchTypeBoth()
    }
    fatalError("codegen error")
}

func mapDBFILESSearchMatchTypeV2ToDBXOptional(object: DBFILESSearchMatchTypeV2?) -> DBXFilesSearchMatchTypeV2? {
    guard let object = object else { return nil }
    return mapDBFILESSearchMatchTypeV2ToDBX(object: object)
}

func mapDBFILESSearchMatchTypeV2ToDBX(object: DBFILESSearchMatchTypeV2) -> DBXFilesSearchMatchTypeV2 {
    if object.isFilename() {
        return DBXFilesSearchMatchTypeV2Filename()
    }
    if object.isFileContent() {
        return DBXFilesSearchMatchTypeV2FileContent()
    }
    if object.isFilenameAndContent() {
        return DBXFilesSearchMatchTypeV2FilenameAndContent()
    }
    if object.isImageContent() {
        return DBXFilesSearchMatchTypeV2ImageContent()
    }
    if object.isOther() {
        return DBXFilesSearchMatchTypeV2Other()
    }
    fatalError("codegen error")
}

func mapDBFILESSearchMatchV2ToDBXOptional(object: DBFILESSearchMatchV2?) -> DBXFilesSearchMatchV2? {
    guard let object = object else { return nil }
    return mapDBFILESSearchMatchV2ToDBX(object: object)
}

func mapDBFILESSearchMatchV2ToDBX(object: DBFILESSearchMatchV2) -> DBXFilesSearchMatchV2 {
    DBXFilesSearchMatchV2(
        metadata: mapDBFILESMetadataV2ToDBX(object: object.metadata),
        matchType: mapDBFILESSearchMatchTypeV2ToDBXOptional(object: object.matchType),
        highlightSpans: object.highlightSpans?.compactMap { mapDBFILESHighlightSpanToDBX(object: $0) }
    )
}

func mapDBFILESSearchModeToDBXOptional(object: DBFILESSearchMode?) -> DBXFilesSearchMode? {
    guard let object = object else { return nil }
    return mapDBFILESSearchModeToDBX(object: object)
}

func mapDBFILESSearchModeToDBX(object: DBFILESSearchMode) -> DBXFilesSearchMode {
    if object.isFilename() {
        return DBXFilesSearchModeFilename()
    }
    if object.isFilenameAndContent() {
        return DBXFilesSearchModeFilenameAndContent()
    }
    if object.isDeletedFilename() {
        return DBXFilesSearchModeDeletedFilename()
    }
    fatalError("codegen error")
}

func mapDBFILESSearchOptionsToDBXOptional(object: DBFILESSearchOptions?) -> DBXFilesSearchOptions? {
    guard let object = object else { return nil }
    return mapDBFILESSearchOptionsToDBX(object: object)
}

func mapDBFILESSearchOptionsToDBX(object: DBFILESSearchOptions) -> DBXFilesSearchOptions {
    DBXFilesSearchOptions(
        path: object.path,
        maxResults: object.maxResults,
        orderBy: mapDBFILESSearchOrderByToDBXOptional(object: object.orderBy),
        fileStatus: mapDBFILESFileStatusToDBX(object: object.fileStatus),
        filenameOnly: object.filenameOnly,
        fileExtensions: object.fileExtensions,
        fileCategories: object.fileCategories?.compactMap { mapDBFILESFileCategoryToDBX(object: $0) },
        accountId: object.accountId
    )
}

func mapDBFILESSearchOrderByToDBXOptional(object: DBFILESSearchOrderBy?) -> DBXFilesSearchOrderBy? {
    guard let object = object else { return nil }
    return mapDBFILESSearchOrderByToDBX(object: object)
}

func mapDBFILESSearchOrderByToDBX(object: DBFILESSearchOrderBy) -> DBXFilesSearchOrderBy {
    if object.isRelevance() {
        return DBXFilesSearchOrderByRelevance()
    }
    if object.isLastModifiedTime() {
        return DBXFilesSearchOrderByLastModifiedTime()
    }
    if object.isOther() {
        return DBXFilesSearchOrderByOther()
    }
    fatalError("codegen error")
}

func mapDBFILESSearchResultToDBXOptional(object: DBFILESSearchResult?) -> DBXFilesSearchResult? {
    guard let object = object else { return nil }
    return mapDBFILESSearchResultToDBX(object: object)
}

func mapDBFILESSearchResultToDBX(object: DBFILESSearchResult) -> DBXFilesSearchResult {
    DBXFilesSearchResult(matches: object.matches.compactMap { mapDBFILESSearchMatchToDBX(object: $0) }, more: object.more, start: object.start)
}

func mapDBFILESSearchV2ArgToDBXOptional(object: DBFILESSearchV2Arg?) -> DBXFilesSearchV2Arg? {
    guard let object = object else { return nil }
    return mapDBFILESSearchV2ArgToDBX(object: object)
}

func mapDBFILESSearchV2ArgToDBX(object: DBFILESSearchV2Arg) -> DBXFilesSearchV2Arg {
    DBXFilesSearchV2Arg(
        query: object.query,
        options: mapDBFILESSearchOptionsToDBXOptional(object: object.options),
        matchFieldOptions: mapDBFILESSearchMatchFieldOptionsToDBXOptional(object: object.matchFieldOptions),
        includeHighlights: object.includeHighlights
    )
}

func mapDBFILESSearchV2ContinueArgToDBXOptional(object: DBFILESSearchV2ContinueArg?) -> DBXFilesSearchV2ContinueArg? {
    guard let object = object else { return nil }
    return mapDBFILESSearchV2ContinueArgToDBX(object: object)
}

func mapDBFILESSearchV2ContinueArgToDBX(object: DBFILESSearchV2ContinueArg) -> DBXFilesSearchV2ContinueArg {
    DBXFilesSearchV2ContinueArg(cursor: object.cursor)
}

func mapDBFILESSearchV2ResultToDBXOptional(object: DBFILESSearchV2Result?) -> DBXFilesSearchV2Result? {
    guard let object = object else { return nil }
    return mapDBFILESSearchV2ResultToDBX(object: object)
}

func mapDBFILESSearchV2ResultToDBX(object: DBFILESSearchV2Result) -> DBXFilesSearchV2Result {
    DBXFilesSearchV2Result(matches: object.matches.compactMap { mapDBFILESSearchMatchV2ToDBX(object: $0) }, hasMore: object.hasMore, cursor: object.cursor)
}

func mapDBFILESSharedLinkToDBXOptional(object: DBFILESSharedLink?) -> DBXFilesSharedLink? {
    guard let object = object else { return nil }
    return mapDBFILESSharedLinkToDBX(object: object)
}

func mapDBFILESSharedLinkToDBX(object: DBFILESSharedLink) -> DBXFilesSharedLink {
    DBXFilesSharedLink(url: object.url, password: object.password)
}

func mapDBFILESSharedLinkFileInfoToDBXOptional(object: DBFILESSharedLinkFileInfo?) -> DBXFilesSharedLinkFileInfo? {
    guard let object = object else { return nil }
    return mapDBFILESSharedLinkFileInfoToDBX(object: object)
}

func mapDBFILESSharedLinkFileInfoToDBX(object: DBFILESSharedLinkFileInfo) -> DBXFilesSharedLinkFileInfo {
    DBXFilesSharedLinkFileInfo(url: object.url, path: object.path, password: object.password)
}

func mapDBFILESSingleUserLockToDBXOptional(object: DBFILESSingleUserLock?) -> DBXFilesSingleUserLock? {
    guard let object = object else { return nil }
    return mapDBFILESSingleUserLockToDBX(object: object)
}

func mapDBFILESSingleUserLockToDBX(object: DBFILESSingleUserLock) -> DBXFilesSingleUserLock {
    DBXFilesSingleUserLock(created: object.created, lockHolderAccountId: object.lockHolderAccountId, lockHolderTeamId: object.lockHolderTeamId)
}

func mapDBFILESSymlinkInfoToDBXOptional(object: DBFILESSymlinkInfo?) -> DBXFilesSymlinkInfo? {
    guard let object = object else { return nil }
    return mapDBFILESSymlinkInfoToDBX(object: object)
}

func mapDBFILESSymlinkInfoToDBX(object: DBFILESSymlinkInfo) -> DBXFilesSymlinkInfo {
    DBXFilesSymlinkInfo(target: object.target)
}

func mapDBFILESSyncSettingToDBXOptional(object: DBFILESSyncSetting?) -> DBXFilesSyncSetting? {
    guard let object = object else { return nil }
    return mapDBFILESSyncSettingToDBX(object: object)
}

func mapDBFILESSyncSettingToDBX(object: DBFILESSyncSetting) -> DBXFilesSyncSetting {
    if object.isDefault_() {
        return DBXFilesSyncSettingDefault_()
    }
    if object.isNotSynced() {
        return DBXFilesSyncSettingNotSynced()
    }
    if object.isNotSyncedInactive() {
        return DBXFilesSyncSettingNotSyncedInactive()
    }
    if object.isOther() {
        return DBXFilesSyncSettingOther()
    }
    fatalError("codegen error")
}

func mapDBFILESSyncSettingArgToDBXOptional(object: DBFILESSyncSettingArg?) -> DBXFilesSyncSettingArg? {
    guard let object = object else { return nil }
    return mapDBFILESSyncSettingArgToDBX(object: object)
}

func mapDBFILESSyncSettingArgToDBX(object: DBFILESSyncSettingArg) -> DBXFilesSyncSettingArg {
    if object.isDefault_() {
        return DBXFilesSyncSettingArgDefault_()
    }
    if object.isNotSynced() {
        return DBXFilesSyncSettingArgNotSynced()
    }
    if object.isOther() {
        return DBXFilesSyncSettingArgOther()
    }
    fatalError("codegen error")
}

func mapDBFILESSyncSettingsErrorToDBXOptional(object: DBFILESSyncSettingsError?) -> DBXFilesSyncSettingsError? {
    guard let object = object else { return nil }
    return mapDBFILESSyncSettingsErrorToDBX(object: object)
}

func mapDBFILESSyncSettingsErrorToDBX(object: DBFILESSyncSettingsError) -> DBXFilesSyncSettingsError {
    if object.isPath() {
        let path = mapDBFILESLookupErrorToDBX(object: object.path)
        return DBXFilesSyncSettingsError.factory(swift: .path(path.swift))
    }
    if object.isUnsupportedCombination() {
        return DBXFilesSyncSettingsErrorUnsupportedCombination()
    }
    if object.isUnsupportedConfiguration() {
        return DBXFilesSyncSettingsErrorUnsupportedConfiguration()
    }
    if object.isOther() {
        return DBXFilesSyncSettingsErrorOther()
    }
    fatalError("codegen error")
}

func mapDBFILESTagToDBXOptional(object: DBFILESTag?) -> DBXFilesTag? {
    guard let object = object else { return nil }
    return mapDBFILESTagToDBX(object: object)
}

func mapDBFILESTagToDBX(object: DBFILESTag) -> DBXFilesTag {
    if object.isUserGeneratedTag() {
        let userGeneratedTag = mapDBFILESUserGeneratedTagToDBX(object: object.userGeneratedTag)
        return DBXFilesTag.factory(swift: .userGeneratedTag(userGeneratedTag.swift))
    }
    if object.isOther() {
        return DBXFilesTagOther()
    }
    fatalError("codegen error")
}

func mapDBFILESThumbnailArgToDBXOptional(object: DBFILESThumbnailArg?) -> DBXFilesThumbnailArg? {
    guard let object = object else { return nil }
    return mapDBFILESThumbnailArgToDBX(object: object)
}

func mapDBFILESThumbnailArgToDBX(object: DBFILESThumbnailArg) -> DBXFilesThumbnailArg {
    DBXFilesThumbnailArg(
        path: object.path,
        format: mapDBFILESThumbnailFormatToDBX(object: object.format),
        size: mapDBFILESThumbnailSizeToDBX(object: object.size),
        mode: mapDBFILESThumbnailModeToDBX(object: object.mode)
    )
}

func mapDBFILESThumbnailErrorToDBXOptional(object: DBFILESThumbnailError?) -> DBXFilesThumbnailError? {
    guard let object = object else { return nil }
    return mapDBFILESThumbnailErrorToDBX(object: object)
}

func mapDBFILESThumbnailErrorToDBX(object: DBFILESThumbnailError) -> DBXFilesThumbnailError {
    if object.isPath() {
        let path = mapDBFILESLookupErrorToDBX(object: object.path)
        return DBXFilesThumbnailError.factory(swift: .path(path.swift))
    }
    if object.isUnsupportedExtension() {
        return DBXFilesThumbnailErrorUnsupportedExtension()
    }
    if object.isUnsupportedImage() {
        return DBXFilesThumbnailErrorUnsupportedImage()
    }
    if object.isConversionError() {
        return DBXFilesThumbnailErrorConversionError()
    }
    fatalError("codegen error")
}

func mapDBFILESThumbnailFormatToDBXOptional(object: DBFILESThumbnailFormat?) -> DBXFilesThumbnailFormat? {
    guard let object = object else { return nil }
    return mapDBFILESThumbnailFormatToDBX(object: object)
}

func mapDBFILESThumbnailFormatToDBX(object: DBFILESThumbnailFormat) -> DBXFilesThumbnailFormat {
    if object.isJpeg() {
        return DBXFilesThumbnailFormatJpeg()
    }
    if object.isPng() {
        return DBXFilesThumbnailFormatPng()
    }
    fatalError("codegen error")
}

func mapDBFILESThumbnailModeToDBXOptional(object: DBFILESThumbnailMode?) -> DBXFilesThumbnailMode? {
    guard let object = object else { return nil }
    return mapDBFILESThumbnailModeToDBX(object: object)
}

func mapDBFILESThumbnailModeToDBX(object: DBFILESThumbnailMode) -> DBXFilesThumbnailMode {
    if object.isStrict() {
        return DBXFilesThumbnailModeStrict()
    }
    if object.isBestfit() {
        return DBXFilesThumbnailModeBestfit()
    }
    if object.isFitoneBestfit() {
        return DBXFilesThumbnailModeFitoneBestfit()
    }
    fatalError("codegen error")
}

func mapDBFILESThumbnailSizeToDBXOptional(object: DBFILESThumbnailSize?) -> DBXFilesThumbnailSize? {
    guard let object = object else { return nil }
    return mapDBFILESThumbnailSizeToDBX(object: object)
}

func mapDBFILESThumbnailSizeToDBX(object: DBFILESThumbnailSize) -> DBXFilesThumbnailSize {
    if object.isW32h32() {
        return DBXFilesThumbnailSizeW32h32()
    }
    if object.isW64h64() {
        return DBXFilesThumbnailSizeW64h64()
    }
    if object.isW128h128() {
        return DBXFilesThumbnailSizeW128h128()
    }
    if object.isW256h256() {
        return DBXFilesThumbnailSizeW256h256()
    }
    if object.isW480h320() {
        return DBXFilesThumbnailSizeW480h320()
    }
    if object.isW640h480() {
        return DBXFilesThumbnailSizeW640h480()
    }
    if object.isW960h640() {
        return DBXFilesThumbnailSizeW960h640()
    }
    if object.isW1024h768() {
        return DBXFilesThumbnailSizeW1024h768()
    }
    if object.isW2048h1536() {
        return DBXFilesThumbnailSizeW2048h1536()
    }
    fatalError("codegen error")
}

func mapDBFILESThumbnailV2ArgToDBXOptional(object: DBFILESThumbnailV2Arg?) -> DBXFilesThumbnailV2Arg? {
    guard let object = object else { return nil }
    return mapDBFILESThumbnailV2ArgToDBX(object: object)
}

func mapDBFILESThumbnailV2ArgToDBX(object: DBFILESThumbnailV2Arg) -> DBXFilesThumbnailV2Arg {
    DBXFilesThumbnailV2Arg(
        resource: mapDBFILESPathOrLinkToDBX(object: object.resource),
        format: mapDBFILESThumbnailFormatToDBX(object: object.format),
        size: mapDBFILESThumbnailSizeToDBX(object: object.size),
        mode: mapDBFILESThumbnailModeToDBX(object: object.mode)
    )
}

func mapDBFILESThumbnailV2ErrorToDBXOptional(object: DBFILESThumbnailV2Error?) -> DBXFilesThumbnailV2Error? {
    guard let object = object else { return nil }
    return mapDBFILESThumbnailV2ErrorToDBX(object: object)
}

func mapDBFILESThumbnailV2ErrorToDBX(object: DBFILESThumbnailV2Error) -> DBXFilesThumbnailV2Error {
    if object.isPath() {
        let path = mapDBFILESLookupErrorToDBX(object: object.path)
        return DBXFilesThumbnailV2Error.factory(swift: .path(path.swift))
    }
    if object.isUnsupportedExtension() {
        return DBXFilesThumbnailV2ErrorUnsupportedExtension()
    }
    if object.isUnsupportedImage() {
        return DBXFilesThumbnailV2ErrorUnsupportedImage()
    }
    if object.isConversionError() {
        return DBXFilesThumbnailV2ErrorConversionError()
    }
    if object.isAccessDenied() {
        return DBXFilesThumbnailV2ErrorAccessDenied()
    }
    if object.isNotFound() {
        return DBXFilesThumbnailV2ErrorNotFound()
    }
    if object.isOther() {
        return DBXFilesThumbnailV2ErrorOther()
    }
    fatalError("codegen error")
}

func mapDBFILESUnlockFileArgToDBXOptional(object: DBFILESUnlockFileArg?) -> DBXFilesUnlockFileArg? {
    guard let object = object else { return nil }
    return mapDBFILESUnlockFileArgToDBX(object: object)
}

func mapDBFILESUnlockFileArgToDBX(object: DBFILESUnlockFileArg) -> DBXFilesUnlockFileArg {
    DBXFilesUnlockFileArg(path: object.path)
}

func mapDBFILESUnlockFileBatchArgToDBXOptional(object: DBFILESUnlockFileBatchArg?) -> DBXFilesUnlockFileBatchArg? {
    guard let object = object else { return nil }
    return mapDBFILESUnlockFileBatchArgToDBX(object: object)
}

func mapDBFILESUnlockFileBatchArgToDBX(object: DBFILESUnlockFileBatchArg) -> DBXFilesUnlockFileBatchArg {
    DBXFilesUnlockFileBatchArg(entries: object.entries.compactMap { mapDBFILESUnlockFileArgToDBX(object: $0) })
}

func mapDBFILESUploadArgToDBXOptional(object: DBFILESUploadArg?) -> DBXFilesUploadArg? {
    guard let object = object else { return nil }
    return mapDBFILESUploadArgToDBX(object: object)
}

func mapDBFILESUploadArgToDBX(object: DBFILESUploadArg) -> DBXFilesUploadArg {
    DBXFilesUploadArg(
        path: object.path,
        mode: mapDBFILESWriteModeToDBX(object: object.mode),
        autorename: object.autorename,
        clientModified: object.clientModified,
        mute: object.mute,
        propertyGroups: object.propertyGroups?.compactMap { mapDBFILEPROPERTIESPropertyGroupToDBX(object: $0) },
        strictConflict: object.strictConflict,
        contentHash: object.contentHash
    )
}

func mapDBFILESUploadErrorToDBXOptional(object: DBFILESUploadError?) -> DBXFilesUploadError? {
    guard let object = object else { return nil }
    return mapDBFILESUploadErrorToDBX(object: object)
}

func mapDBFILESUploadErrorToDBX(object: DBFILESUploadError) -> DBXFilesUploadError {
    if object.isPath() {
        let path = mapDBFILESUploadWriteFailedToDBX(object: object.path)
        return DBXFilesUploadError.factory(swift: .path(path.swift))
    }
    if object.isPropertiesError() {
        let propertiesError = mapDBFILEPROPERTIESInvalidPropertyGroupErrorToDBX(object: object.propertiesError)
        return DBXFilesUploadError.factory(swift: .propertiesError(propertiesError.swift))
    }
    if object.isPayloadTooLarge() {
        return DBXFilesUploadErrorPayloadTooLarge()
    }
    if object.isContentHashMismatch() {
        return DBXFilesUploadErrorContentHashMismatch()
    }
    if object.isOther() {
        return DBXFilesUploadErrorOther()
    }
    fatalError("codegen error")
}

func mapDBFILESUploadSessionAppendArgToDBXOptional(object: DBFILESUploadSessionAppendArg?) -> DBXFilesUploadSessionAppendArg? {
    guard let object = object else { return nil }
    return mapDBFILESUploadSessionAppendArgToDBX(object: object)
}

func mapDBFILESUploadSessionAppendArgToDBX(object: DBFILESUploadSessionAppendArg) -> DBXFilesUploadSessionAppendArg {
    DBXFilesUploadSessionAppendArg(cursor: mapDBFILESUploadSessionCursorToDBX(object: object.cursor), close: object.close, contentHash: object.contentHash)
}

func mapDBFILESUploadSessionLookupErrorToDBXOptional(object: DBFILESUploadSessionLookupError?) -> DBXFilesUploadSessionLookupError? {
    guard let object = object else { return nil }
    return mapDBFILESUploadSessionLookupErrorToDBX(object: object)
}

func mapDBFILESUploadSessionLookupErrorToDBX(object: DBFILESUploadSessionLookupError) -> DBXFilesUploadSessionLookupError {
    if object.isNotFound() {
        return DBXFilesUploadSessionLookupErrorNotFound()
    }
    if object.isIncorrectOffset() {
        let incorrectOffset = mapDBFILESUploadSessionOffsetErrorToDBX(object: object.incorrectOffset)
        return DBXFilesUploadSessionLookupError.factory(swift: .incorrectOffset(incorrectOffset.swift))
    }
    if object.isClosed() {
        return DBXFilesUploadSessionLookupErrorClosed()
    }
    if object.isNotClosed() {
        return DBXFilesUploadSessionLookupErrorNotClosed()
    }
    if object.isTooLarge() {
        return DBXFilesUploadSessionLookupErrorTooLarge()
    }
    if object.isConcurrentSessionInvalidOffset() {
        return DBXFilesUploadSessionLookupErrorConcurrentSessionInvalidOffset()
    }
    if object.isConcurrentSessionInvalidDataSize() {
        return DBXFilesUploadSessionLookupErrorConcurrentSessionInvalidDataSize()
    }
    if object.isPayloadTooLarge() {
        return DBXFilesUploadSessionLookupErrorPayloadTooLarge()
    }
    if object.isOther() {
        return DBXFilesUploadSessionLookupErrorOther()
    }
    fatalError("codegen error")
}

func mapDBFILESUploadSessionAppendErrorToDBXOptional(object: DBFILESUploadSessionAppendError?) -> DBXFilesUploadSessionAppendError? {
    guard let object = object else { return nil }
    return mapDBFILESUploadSessionAppendErrorToDBX(object: object)
}

func mapDBFILESUploadSessionAppendErrorToDBX(object: DBFILESUploadSessionAppendError) -> DBXFilesUploadSessionAppendError {
    if object.isNotFound() {
        return DBXFilesUploadSessionAppendErrorNotFound()
    }
    if object.isIncorrectOffset() {
        let incorrectOffset = mapDBFILESUploadSessionOffsetErrorToDBX(object: object.incorrectOffset)
        return DBXFilesUploadSessionAppendError.factory(swift: .incorrectOffset(incorrectOffset.swift))
    }
    if object.isClosed() {
        return DBXFilesUploadSessionAppendErrorClosed()
    }
    if object.isNotClosed() {
        return DBXFilesUploadSessionAppendErrorNotClosed()
    }
    if object.isTooLarge() {
        return DBXFilesUploadSessionAppendErrorTooLarge()
    }
    if object.isConcurrentSessionInvalidOffset() {
        return DBXFilesUploadSessionAppendErrorConcurrentSessionInvalidOffset()
    }
    if object.isConcurrentSessionInvalidDataSize() {
        return DBXFilesUploadSessionAppendErrorConcurrentSessionInvalidDataSize()
    }
    if object.isPayloadTooLarge() {
        return DBXFilesUploadSessionAppendErrorPayloadTooLarge()
    }
    if object.isOther() {
        return DBXFilesUploadSessionAppendErrorOther()
    }
    if object.isContentHashMismatch() {
        return DBXFilesUploadSessionAppendErrorContentHashMismatch()
    }
    fatalError("codegen error")
}

func mapDBFILESUploadSessionCursorToDBXOptional(object: DBFILESUploadSessionCursor?) -> DBXFilesUploadSessionCursor? {
    guard let object = object else { return nil }
    return mapDBFILESUploadSessionCursorToDBX(object: object)
}

func mapDBFILESUploadSessionCursorToDBX(object: DBFILESUploadSessionCursor) -> DBXFilesUploadSessionCursor {
    DBXFilesUploadSessionCursor(sessionId: object.sessionId, offset: object.offset)
}

func mapDBFILESUploadSessionFinishArgToDBXOptional(object: DBFILESUploadSessionFinishArg?) -> DBXFilesUploadSessionFinishArg? {
    guard let object = object else { return nil }
    return mapDBFILESUploadSessionFinishArgToDBX(object: object)
}

func mapDBFILESUploadSessionFinishArgToDBX(object: DBFILESUploadSessionFinishArg) -> DBXFilesUploadSessionFinishArg {
    DBXFilesUploadSessionFinishArg(
        cursor: mapDBFILESUploadSessionCursorToDBX(object: object.cursor),
        commit: mapDBFILESCommitInfoToDBX(object: object.commit),
        contentHash: object.contentHash
    )
}

func mapDBFILESUploadSessionFinishBatchArgToDBXOptional(object: DBFILESUploadSessionFinishBatchArg?) -> DBXFilesUploadSessionFinishBatchArg? {
    guard let object = object else { return nil }
    return mapDBFILESUploadSessionFinishBatchArgToDBX(object: object)
}

func mapDBFILESUploadSessionFinishBatchArgToDBX(object: DBFILESUploadSessionFinishBatchArg) -> DBXFilesUploadSessionFinishBatchArg {
    DBXFilesUploadSessionFinishBatchArg(entries: object.entries.compactMap { mapDBFILESUploadSessionFinishArgToDBX(object: $0) })
}

func mapDBFILESUploadSessionFinishBatchJobStatusToDBXOptional(object: DBFILESUploadSessionFinishBatchJobStatus?) -> DBXFilesUploadSessionFinishBatchJobStatus? {
    guard let object = object else { return nil }
    return mapDBFILESUploadSessionFinishBatchJobStatusToDBX(object: object)
}

func mapDBFILESUploadSessionFinishBatchJobStatusToDBX(object: DBFILESUploadSessionFinishBatchJobStatus) -> DBXFilesUploadSessionFinishBatchJobStatus {
    if object.isInProgress() {
        return DBXFilesUploadSessionFinishBatchJobStatusInProgress()
    }
    if object.isComplete() {
        let complete = mapDBFILESUploadSessionFinishBatchResultToDBX(object: object.complete)
        return DBXFilesUploadSessionFinishBatchJobStatus.factory(swift: .complete(complete.swift))
    }
    fatalError("codegen error")
}

func mapDBFILESUploadSessionFinishBatchLaunchToDBXOptional(object: DBFILESUploadSessionFinishBatchLaunch?) -> DBXFilesUploadSessionFinishBatchLaunch? {
    guard let object = object else { return nil }
    return mapDBFILESUploadSessionFinishBatchLaunchToDBX(object: object)
}

func mapDBFILESUploadSessionFinishBatchLaunchToDBX(object: DBFILESUploadSessionFinishBatchLaunch) -> DBXFilesUploadSessionFinishBatchLaunch {
    if object.isAsyncJobId() {
        let asyncJobId = object.asyncJobId
        return DBXFilesUploadSessionFinishBatchLaunch.factory(swift: .asyncJobId(asyncJobId))
    }
    if object.isComplete() {
        let complete = mapDBFILESUploadSessionFinishBatchResultToDBX(object: object.complete)
        return DBXFilesUploadSessionFinishBatchLaunch.factory(swift: .complete(complete.swift))
    }
    if object.isOther() {
        return DBXFilesUploadSessionFinishBatchLaunchOther()
    }
    fatalError("codegen error")
}

func mapDBFILESUploadSessionFinishBatchResultToDBXOptional(object: DBFILESUploadSessionFinishBatchResult?) -> DBXFilesUploadSessionFinishBatchResult? {
    guard let object = object else { return nil }
    return mapDBFILESUploadSessionFinishBatchResultToDBX(object: object)
}

func mapDBFILESUploadSessionFinishBatchResultToDBX(object: DBFILESUploadSessionFinishBatchResult) -> DBXFilesUploadSessionFinishBatchResult {
    DBXFilesUploadSessionFinishBatchResult(entries: object.entries.compactMap { mapDBFILESUploadSessionFinishBatchResultEntryToDBX(object: $0) })
}

func mapDBFILESUploadSessionFinishBatchResultEntryToDBXOptional(object: DBFILESUploadSessionFinishBatchResultEntry?)
    -> DBXFilesUploadSessionFinishBatchResultEntry? {
    guard let object = object else { return nil }
    return mapDBFILESUploadSessionFinishBatchResultEntryToDBX(object: object)
}

func mapDBFILESUploadSessionFinishBatchResultEntryToDBX(object: DBFILESUploadSessionFinishBatchResultEntry) -> DBXFilesUploadSessionFinishBatchResultEntry {
    if object.isSuccess() {
        let success = mapDBFILESFileMetadataToDBX(object: object.success)
        return DBXFilesUploadSessionFinishBatchResultEntry.factory(swift: .success(success.subSwift))
    }
    if object.isFailure() {
        let failure = mapDBFILESUploadSessionFinishErrorToDBX(object: object.failure)
        return DBXFilesUploadSessionFinishBatchResultEntry.factory(swift: .failure(failure.swift))
    }
    fatalError("codegen error")
}

func mapDBFILESUploadSessionFinishErrorToDBXOptional(object: DBFILESUploadSessionFinishError?) -> DBXFilesUploadSessionFinishError? {
    guard let object = object else { return nil }
    return mapDBFILESUploadSessionFinishErrorToDBX(object: object)
}

func mapDBFILESUploadSessionFinishErrorToDBX(object: DBFILESUploadSessionFinishError) -> DBXFilesUploadSessionFinishError {
    if object.isLookupFailed() {
        let lookupFailed = mapDBFILESUploadSessionLookupErrorToDBX(object: object.lookupFailed)
        return DBXFilesUploadSessionFinishError.factory(swift: .lookupFailed(lookupFailed.swift))
    }
    if object.isPath() {
        let path = mapDBFILESWriteErrorToDBX(object: object.path)
        return DBXFilesUploadSessionFinishError.factory(swift: .path(path.swift))
    }
    if object.isPropertiesError() {
        let propertiesError = mapDBFILEPROPERTIESInvalidPropertyGroupErrorToDBX(object: object.propertiesError)
        return DBXFilesUploadSessionFinishError.factory(swift: .propertiesError(propertiesError.swift))
    }
    if object.isTooManySharedFolderTargets() {
        return DBXFilesUploadSessionFinishErrorTooManySharedFolderTargets()
    }
    if object.isTooManyWriteOperations() {
        return DBXFilesUploadSessionFinishErrorTooManyWriteOperations()
    }
    if object.isConcurrentSessionDataNotAllowed() {
        return DBXFilesUploadSessionFinishErrorConcurrentSessionDataNotAllowed()
    }
    if object.isConcurrentSessionNotClosed() {
        return DBXFilesUploadSessionFinishErrorConcurrentSessionNotClosed()
    }
    if object.isConcurrentSessionMissingData() {
        return DBXFilesUploadSessionFinishErrorConcurrentSessionMissingData()
    }
    if object.isPayloadTooLarge() {
        return DBXFilesUploadSessionFinishErrorPayloadTooLarge()
    }
    if object.isContentHashMismatch() {
        return DBXFilesUploadSessionFinishErrorContentHashMismatch()
    }
    if object.isOther() {
        return DBXFilesUploadSessionFinishErrorOther()
    }
    fatalError("codegen error")
}

func mapDBFILESUploadSessionOffsetErrorToDBXOptional(object: DBFILESUploadSessionOffsetError?) -> DBXFilesUploadSessionOffsetError? {
    guard let object = object else { return nil }
    return mapDBFILESUploadSessionOffsetErrorToDBX(object: object)
}

func mapDBFILESUploadSessionOffsetErrorToDBX(object: DBFILESUploadSessionOffsetError) -> DBXFilesUploadSessionOffsetError {
    DBXFilesUploadSessionOffsetError(correctOffset: object.correctOffset)
}

func mapDBFILESUploadSessionStartArgToDBXOptional(object: DBFILESUploadSessionStartArg?) -> DBXFilesUploadSessionStartArg? {
    guard let object = object else { return nil }
    return mapDBFILESUploadSessionStartArgToDBX(object: object)
}

func mapDBFILESUploadSessionStartArgToDBX(object: DBFILESUploadSessionStartArg) -> DBXFilesUploadSessionStartArg {
    DBXFilesUploadSessionStartArg(
        close: object.close,
        sessionType: mapDBFILESUploadSessionTypeToDBXOptional(object: object.sessionType),
        contentHash: object.contentHash
    )
}

func mapDBFILESUploadSessionStartBatchArgToDBXOptional(object: DBFILESUploadSessionStartBatchArg?) -> DBXFilesUploadSessionStartBatchArg? {
    guard let object = object else { return nil }
    return mapDBFILESUploadSessionStartBatchArgToDBX(object: object)
}

func mapDBFILESUploadSessionStartBatchArgToDBX(object: DBFILESUploadSessionStartBatchArg) -> DBXFilesUploadSessionStartBatchArg {
    DBXFilesUploadSessionStartBatchArg(numSessions: object.numSessions, sessionType: mapDBFILESUploadSessionTypeToDBXOptional(object: object.sessionType))
}

func mapDBFILESUploadSessionStartBatchResultToDBXOptional(object: DBFILESUploadSessionStartBatchResult?) -> DBXFilesUploadSessionStartBatchResult? {
    guard let object = object else { return nil }
    return mapDBFILESUploadSessionStartBatchResultToDBX(object: object)
}

func mapDBFILESUploadSessionStartBatchResultToDBX(object: DBFILESUploadSessionStartBatchResult) -> DBXFilesUploadSessionStartBatchResult {
    DBXFilesUploadSessionStartBatchResult(sessionIds: object.sessionIds)
}

func mapDBFILESUploadSessionStartErrorToDBXOptional(object: DBFILESUploadSessionStartError?) -> DBXFilesUploadSessionStartError? {
    guard let object = object else { return nil }
    return mapDBFILESUploadSessionStartErrorToDBX(object: object)
}

func mapDBFILESUploadSessionStartErrorToDBX(object: DBFILESUploadSessionStartError) -> DBXFilesUploadSessionStartError {
    if object.isConcurrentSessionDataNotAllowed() {
        return DBXFilesUploadSessionStartErrorConcurrentSessionDataNotAllowed()
    }
    if object.isConcurrentSessionCloseNotAllowed() {
        return DBXFilesUploadSessionStartErrorConcurrentSessionCloseNotAllowed()
    }
    if object.isPayloadTooLarge() {
        return DBXFilesUploadSessionStartErrorPayloadTooLarge()
    }
    if object.isContentHashMismatch() {
        return DBXFilesUploadSessionStartErrorContentHashMismatch()
    }
    if object.isOther() {
        return DBXFilesUploadSessionStartErrorOther()
    }
    fatalError("codegen error")
}

func mapDBFILESUploadSessionStartResultToDBXOptional(object: DBFILESUploadSessionStartResult?) -> DBXFilesUploadSessionStartResult? {
    guard let object = object else { return nil }
    return mapDBFILESUploadSessionStartResultToDBX(object: object)
}

func mapDBFILESUploadSessionStartResultToDBX(object: DBFILESUploadSessionStartResult) -> DBXFilesUploadSessionStartResult {
    DBXFilesUploadSessionStartResult(sessionId: object.sessionId)
}

func mapDBFILESUploadSessionTypeToDBXOptional(object: DBFILESUploadSessionType?) -> DBXFilesUploadSessionType? {
    guard let object = object else { return nil }
    return mapDBFILESUploadSessionTypeToDBX(object: object)
}

func mapDBFILESUploadSessionTypeToDBX(object: DBFILESUploadSessionType) -> DBXFilesUploadSessionType {
    if object.isSequential() {
        return DBXFilesUploadSessionTypeSequential()
    }
    if object.isConcurrent() {
        return DBXFilesUploadSessionTypeConcurrent()
    }
    if object.isOther() {
        return DBXFilesUploadSessionTypeOther()
    }
    fatalError("codegen error")
}

func mapDBFILESUploadWriteFailedToDBXOptional(object: DBFILESUploadWriteFailed?) -> DBXFilesUploadWriteFailed? {
    guard let object = object else { return nil }
    return mapDBFILESUploadWriteFailedToDBX(object: object)
}

func mapDBFILESUploadWriteFailedToDBX(object: DBFILESUploadWriteFailed) -> DBXFilesUploadWriteFailed {
    DBXFilesUploadWriteFailed(reason: mapDBFILESWriteErrorToDBX(object: object.reason), uploadSessionId: object.uploadSessionId)
}

func mapDBFILESUserGeneratedTagToDBXOptional(object: DBFILESUserGeneratedTag?) -> DBXFilesUserGeneratedTag? {
    guard let object = object else { return nil }
    return mapDBFILESUserGeneratedTagToDBX(object: object)
}

func mapDBFILESUserGeneratedTagToDBX(object: DBFILESUserGeneratedTag) -> DBXFilesUserGeneratedTag {
    DBXFilesUserGeneratedTag(tagText: object.tagText)
}

func mapDBFILESVideoMetadataToDBXOptional(object: DBFILESVideoMetadata?) -> DBXFilesVideoMetadata? {
    guard let object = object else { return nil }
    return mapDBFILESVideoMetadataToDBX(object: object)
}

func mapDBFILESVideoMetadataToDBX(object: DBFILESVideoMetadata) -> DBXFilesVideoMetadata {
    DBXFilesVideoMetadata(
        dimensions: mapDBFILESDimensionsToDBXOptional(object: object.dimensions),
        location: mapDBFILESGpsCoordinatesToDBXOptional(object: object.location),
        timeTaken: object.timeTaken,
        duration: object.duration
    )
}

func mapDBFILESWriteConflictErrorToDBXOptional(object: DBFILESWriteConflictError?) -> DBXFilesWriteConflictError? {
    guard let object = object else { return nil }
    return mapDBFILESWriteConflictErrorToDBX(object: object)
}

func mapDBFILESWriteConflictErrorToDBX(object: DBFILESWriteConflictError) -> DBXFilesWriteConflictError {
    if object.isFile() {
        return DBXFilesWriteConflictErrorFile()
    }
    if object.isFolder() {
        return DBXFilesWriteConflictErrorFolder()
    }
    if object.isFileAncestor() {
        return DBXFilesWriteConflictErrorFileAncestor()
    }
    if object.isOther() {
        return DBXFilesWriteConflictErrorOther()
    }
    fatalError("codegen error")
}

func mapDBFILESWriteErrorToDBXOptional(object: DBFILESWriteError?) -> DBXFilesWriteError? {
    guard let object = object else { return nil }
    return mapDBFILESWriteErrorToDBX(object: object)
}

func mapDBFILESWriteErrorToDBX(object: DBFILESWriteError) -> DBXFilesWriteError {
    if object.isMalformedPath() {
        let malformedPath = object.malformedPath
        return DBXFilesWriteError.factory(swift: .malformedPath(malformedPath))
    }
    if object.isConflict() {
        let conflict = mapDBFILESWriteConflictErrorToDBX(object: object.conflict)
        return DBXFilesWriteError.factory(swift: .conflict(conflict.swift))
    }
    if object.isNoWritePermission() {
        return DBXFilesWriteErrorNoWritePermission()
    }
    if object.isInsufficientSpace() {
        return DBXFilesWriteErrorInsufficientSpace()
    }
    if object.isDisallowedName() {
        return DBXFilesWriteErrorDisallowedName()
    }
    if object.isTeamFolder() {
        return DBXFilesWriteErrorTeamFolder()
    }
    if object.isOperationSuppressed() {
        return DBXFilesWriteErrorOperationSuppressed()
    }
    if object.isTooManyWriteOperations() {
        return DBXFilesWriteErrorTooManyWriteOperations()
    }
    if object.isOther() {
        return DBXFilesWriteErrorOther()
    }
    fatalError("codegen error")
}

func mapDBFILESWriteModeToDBXOptional(object: DBFILESWriteMode?) -> DBXFilesWriteMode? {
    guard let object = object else { return nil }
    return mapDBFILESWriteModeToDBX(object: object)
}

func mapDBFILESWriteModeToDBX(object: DBFILESWriteMode) -> DBXFilesWriteMode {
    if object.isAdd() {
        return DBXFilesWriteModeAdd()
    }
    if object.isOverwrite() {
        return DBXFilesWriteModeOverwrite()
    }
    if object.isUpdate() {
        let update = object.update
        return DBXFilesWriteMode.factory(swift: .update(update))
    }
    fatalError("codegen error")
}
