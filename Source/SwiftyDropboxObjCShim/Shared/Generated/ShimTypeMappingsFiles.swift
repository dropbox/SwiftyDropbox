///
/// Copyright (c) 2024 Dropbox, Inc. All rights reserved.
///
/// Auto-generated by Stone, do not modify.
///

import Foundation
import stone_sdk_objc
import stone_sdk_swift
import stone_sdk_swift_objc

func mapDBXFilesAddTagArgToDBOptional(object: DBXFilesAddTagArg?) -> DBFILESAddTagArg? {
    guard let object = object else { return nil }
    return mapDBXFilesAddTagArgToDB(object: object)
}

func mapDBXFilesAddTagArgToDB(object: DBXFilesAddTagArg) -> DBFILESAddTagArg {
    DBFILESAddTagArg(path: object.path, tagText: object.tagText)
}

func mapDBXFilesBaseTagErrorToDBOptional(object: DBXFilesBaseTagError?) -> DBFILESBaseTagError? {
    guard let object = object else { return nil }
    return mapDBXFilesBaseTagErrorToDB(object: object)
}

func mapDBXFilesBaseTagErrorToDB(object: DBXFilesBaseTagError) -> DBFILESBaseTagError {
    if let object = object.asPath {
        let path = mapDBXFilesLookupErrorToDB(object: object.path)
        return DBFILESBaseTagError(path: path)
    }
    if object.asOther != nil {
        return DBFILESBaseTagError(other: ())
    }
    fatalError("codegen error")
}

func mapDBXFilesAddTagErrorToDBOptional(object: DBXFilesAddTagError?) -> DBFILESAddTagError? {
    guard let object = object else { return nil }
    return mapDBXFilesAddTagErrorToDB(object: object)
}

func mapDBXFilesAddTagErrorToDB(object: DBXFilesAddTagError) -> DBFILESAddTagError {
    if let object = object.asPath {
        let path = mapDBXFilesLookupErrorToDB(object: object.path)
        return DBFILESAddTagError(path: path)
    }
    if object.asOther != nil {
        return DBFILESAddTagError(other: ())
    }
    if object.asTooManyTags != nil {
        return DBFILESAddTagError(tooManyTags: ())
    }
    fatalError("codegen error")
}

func mapDBXFilesGetMetadataArgToDBOptional(object: DBXFilesGetMetadataArg?) -> DBFILESGetMetadataArg? {
    guard let object = object else { return nil }
    return mapDBXFilesGetMetadataArgToDB(object: object)
}

func mapDBXFilesGetMetadataArgToDB(object: DBXFilesGetMetadataArg) -> DBFILESGetMetadataArg {
    DBFILESGetMetadataArg(
        path: object.path,
        includeMediaInfo: object.includeMediaInfo,
        includeDeleted: object.includeDeleted,
        includeHasExplicitSharedMembers: object.includeHasExplicitSharedMembers,
        includePropertyGroups: mapDBXFilePropertiesTemplateFilterBaseToDBOptional(object: object.includePropertyGroups)
    )
}

func mapDBXFilesAlphaGetMetadataArgToDBOptional(object: DBXFilesAlphaGetMetadataArg?) -> DBFILESAlphaGetMetadataArg? {
    guard let object = object else { return nil }
    return mapDBXFilesAlphaGetMetadataArgToDB(object: object)
}

func mapDBXFilesAlphaGetMetadataArgToDB(object: DBXFilesAlphaGetMetadataArg) -> DBFILESAlphaGetMetadataArg {
    DBFILESAlphaGetMetadataArg(
        path: object.path,
        includeMediaInfo: object.includeMediaInfo,
        includeDeleted: object.includeDeleted,
        includeHasExplicitSharedMembers: object.includeHasExplicitSharedMembers,
        includePropertyGroups: mapDBXFilePropertiesTemplateFilterBaseToDBOptional(object: object.includePropertyGroups),
        includePropertyTemplates: object.includePropertyTemplates
    )
}

func mapDBXFilesGetMetadataErrorToDBOptional(object: DBXFilesGetMetadataError?) -> DBFILESGetMetadataError? {
    guard let object = object else { return nil }
    return mapDBXFilesGetMetadataErrorToDB(object: object)
}

func mapDBXFilesGetMetadataErrorToDB(object: DBXFilesGetMetadataError) -> DBFILESGetMetadataError {
    if let object = object.asPath {
        let path = mapDBXFilesLookupErrorToDB(object: object.path)
        return DBFILESGetMetadataError(path: path)
    }
    fatalError("codegen error")
}

func mapDBXFilesAlphaGetMetadataErrorToDBOptional(object: DBXFilesAlphaGetMetadataError?) -> DBFILESAlphaGetMetadataError? {
    guard let object = object else { return nil }
    return mapDBXFilesAlphaGetMetadataErrorToDB(object: object)
}

func mapDBXFilesAlphaGetMetadataErrorToDB(object: DBXFilesAlphaGetMetadataError) -> DBFILESAlphaGetMetadataError {
    if let object = object.asPath {
        let path = mapDBXFilesLookupErrorToDB(object: object.path)
        return DBFILESAlphaGetMetadataError(path: path)
    }
    if let object = object.asPropertiesError {
        let propertiesError = mapDBXFilePropertiesLookUpPropertiesErrorToDB(object: object.propertiesError)
        return DBFILESAlphaGetMetadataError(propertiesError: propertiesError)
    }
    fatalError("codegen error")
}

func mapDBXFilesCommitInfoToDBOptional(object: DBXFilesCommitInfo?) -> DBFILESCommitInfo? {
    guard let object = object else { return nil }
    return mapDBXFilesCommitInfoToDB(object: object)
}

func mapDBXFilesCommitInfoToDB(object: DBXFilesCommitInfo) -> DBFILESCommitInfo {
    DBFILESCommitInfo(
        path: object.path,
        mode: mapDBXFilesWriteModeToDB(object: object.mode),
        autorename: object.autorename,
        clientModified: object.clientModified,
        mute: object.mute,
        propertyGroups: object.propertyGroups?.compactMap { mapDBXFilePropertiesPropertyGroupToDB(object: $0) },
        strictConflict: object.strictConflict
    )
}

func mapDBXFilesContentSyncSettingToDBOptional(object: DBXFilesContentSyncSetting?) -> DBFILESContentSyncSetting? {
    guard let object = object else { return nil }
    return mapDBXFilesContentSyncSettingToDB(object: object)
}

func mapDBXFilesContentSyncSettingToDB(object: DBXFilesContentSyncSetting) -> DBFILESContentSyncSetting {
    DBFILESContentSyncSetting(id_: object.id, syncSetting: mapDBXFilesSyncSettingToDB(object: object.syncSetting))
}

func mapDBXFilesContentSyncSettingArgToDBOptional(object: DBXFilesContentSyncSettingArg?) -> DBFILESContentSyncSettingArg? {
    guard let object = object else { return nil }
    return mapDBXFilesContentSyncSettingArgToDB(object: object)
}

func mapDBXFilesContentSyncSettingArgToDB(object: DBXFilesContentSyncSettingArg) -> DBFILESContentSyncSettingArg {
    DBFILESContentSyncSettingArg(id_: object.id, syncSetting: mapDBXFilesSyncSettingArgToDB(object: object.syncSetting))
}

func mapDBXFilesCreateFolderArgToDBOptional(object: DBXFilesCreateFolderArg?) -> DBFILESCreateFolderArg? {
    guard let object = object else { return nil }
    return mapDBXFilesCreateFolderArgToDB(object: object)
}

func mapDBXFilesCreateFolderArgToDB(object: DBXFilesCreateFolderArg) -> DBFILESCreateFolderArg {
    DBFILESCreateFolderArg(path: object.path, autorename: object.autorename)
}

func mapDBXFilesCreateFolderBatchArgToDBOptional(object: DBXFilesCreateFolderBatchArg?) -> DBFILESCreateFolderBatchArg? {
    guard let object = object else { return nil }
    return mapDBXFilesCreateFolderBatchArgToDB(object: object)
}

func mapDBXFilesCreateFolderBatchArgToDB(object: DBXFilesCreateFolderBatchArg) -> DBFILESCreateFolderBatchArg {
    DBFILESCreateFolderBatchArg(paths: object.paths, autorename: object.autorename, forceAsync: object.forceAsync)
}

func mapDBXFilesCreateFolderBatchErrorToDBOptional(object: DBXFilesCreateFolderBatchError?) -> DBFILESCreateFolderBatchError? {
    guard let object = object else { return nil }
    return mapDBXFilesCreateFolderBatchErrorToDB(object: object)
}

func mapDBXFilesCreateFolderBatchErrorToDB(object: DBXFilesCreateFolderBatchError) -> DBFILESCreateFolderBatchError {
    if object.asTooManyFiles != nil {
        return DBFILESCreateFolderBatchError(tooManyFiles: ())
    }
    if object.asOther != nil {
        return DBFILESCreateFolderBatchError(other: ())
    }
    fatalError("codegen error")
}

func mapDBXFilesCreateFolderBatchJobStatusToDBOptional(object: DBXFilesCreateFolderBatchJobStatus?) -> DBFILESCreateFolderBatchJobStatus? {
    guard let object = object else { return nil }
    return mapDBXFilesCreateFolderBatchJobStatusToDB(object: object)
}

func mapDBXFilesCreateFolderBatchJobStatusToDB(object: DBXFilesCreateFolderBatchJobStatus) -> DBFILESCreateFolderBatchJobStatus {
    if object.asInProgress != nil {
        return DBFILESCreateFolderBatchJobStatus(inProgress: ())
    }
    if let object = object.asComplete {
        let complete = mapDBXFilesCreateFolderBatchResultToDB(object: object.complete)
        return DBFILESCreateFolderBatchJobStatus(complete: complete)
    }
    if let object = object.asFailed {
        let failed = mapDBXFilesCreateFolderBatchErrorToDB(object: object.failed)
        return DBFILESCreateFolderBatchJobStatus(failed: failed)
    }
    if object.asOther != nil {
        return DBFILESCreateFolderBatchJobStatus(other: ())
    }
    fatalError("codegen error")
}

func mapDBXFilesCreateFolderBatchLaunchToDBOptional(object: DBXFilesCreateFolderBatchLaunch?) -> DBFILESCreateFolderBatchLaunch? {
    guard let object = object else { return nil }
    return mapDBXFilesCreateFolderBatchLaunchToDB(object: object)
}

func mapDBXFilesCreateFolderBatchLaunchToDB(object: DBXFilesCreateFolderBatchLaunch) -> DBFILESCreateFolderBatchLaunch {
    if let object = object.asAsyncJobId {
        let asyncJobId = object.asyncJobId
        return DBFILESCreateFolderBatchLaunch(asyncJobId: asyncJobId)
    }
    if let object = object.asComplete {
        let complete = mapDBXFilesCreateFolderBatchResultToDB(object: object.complete)
        return DBFILESCreateFolderBatchLaunch(complete: complete)
    }
    if object.asOther != nil {
        return DBFILESCreateFolderBatchLaunch(other: ())
    }
    fatalError("codegen error")
}

func mapDBXFilesFileOpsResultToDBOptional(object: DBXFilesFileOpsResult?) -> DBFILESFileOpsResult? {
    guard let object = object else { return nil }
    return mapDBXFilesFileOpsResultToDB(object: object)
}

func mapDBXFilesFileOpsResultToDB(object: DBXFilesFileOpsResult) -> DBFILESFileOpsResult {
    DBFILESFileOpsResult(default: ())
}

func mapDBXFilesCreateFolderBatchResultToDBOptional(object: DBXFilesCreateFolderBatchResult?) -> DBFILESCreateFolderBatchResult? {
    guard let object = object else { return nil }
    return mapDBXFilesCreateFolderBatchResultToDB(object: object)
}

func mapDBXFilesCreateFolderBatchResultToDB(object: DBXFilesCreateFolderBatchResult) -> DBFILESCreateFolderBatchResult {
    DBFILESCreateFolderBatchResult(entries: object.entries.compactMap { mapDBXFilesCreateFolderBatchResultEntryToDB(object: $0) })
}

func mapDBXFilesCreateFolderBatchResultEntryToDBOptional(object: DBXFilesCreateFolderBatchResultEntry?) -> DBFILESCreateFolderBatchResultEntry? {
    guard let object = object else { return nil }
    return mapDBXFilesCreateFolderBatchResultEntryToDB(object: object)
}

func mapDBXFilesCreateFolderBatchResultEntryToDB(object: DBXFilesCreateFolderBatchResultEntry) -> DBFILESCreateFolderBatchResultEntry {
    if let object = object.asSuccess {
        let success = mapDBXFilesCreateFolderEntryResultToDB(object: object.success)
        return DBFILESCreateFolderBatchResultEntry(success: success)
    }
    if let object = object.asFailure {
        let failure = mapDBXFilesCreateFolderEntryErrorToDB(object: object.failure)
        return DBFILESCreateFolderBatchResultEntry(failure: failure)
    }
    fatalError("codegen error")
}

func mapDBXFilesCreateFolderEntryErrorToDBOptional(object: DBXFilesCreateFolderEntryError?) -> DBFILESCreateFolderEntryError? {
    guard let object = object else { return nil }
    return mapDBXFilesCreateFolderEntryErrorToDB(object: object)
}

func mapDBXFilesCreateFolderEntryErrorToDB(object: DBXFilesCreateFolderEntryError) -> DBFILESCreateFolderEntryError {
    if let object = object.asPath {
        let path = mapDBXFilesWriteErrorToDB(object: object.path)
        return DBFILESCreateFolderEntryError(path: path)
    }
    if object.asOther != nil {
        return DBFILESCreateFolderEntryError(other: ())
    }
    fatalError("codegen error")
}

func mapDBXFilesCreateFolderEntryResultToDBOptional(object: DBXFilesCreateFolderEntryResult?) -> DBFILESCreateFolderEntryResult? {
    guard let object = object else { return nil }
    return mapDBXFilesCreateFolderEntryResultToDB(object: object)
}

func mapDBXFilesCreateFolderEntryResultToDB(object: DBXFilesCreateFolderEntryResult) -> DBFILESCreateFolderEntryResult {
    DBFILESCreateFolderEntryResult(metadata: mapDBXFilesFolderMetadataToDB(object: object.metadata))
}

func mapDBXFilesCreateFolderErrorToDBOptional(object: DBXFilesCreateFolderError?) -> DBFILESCreateFolderError? {
    guard let object = object else { return nil }
    return mapDBXFilesCreateFolderErrorToDB(object: object)
}

func mapDBXFilesCreateFolderErrorToDB(object: DBXFilesCreateFolderError) -> DBFILESCreateFolderError {
    if let object = object.asPath {
        let path = mapDBXFilesWriteErrorToDB(object: object.path)
        return DBFILESCreateFolderError(path: path)
    }
    fatalError("codegen error")
}

func mapDBXFilesCreateFolderResultToDBOptional(object: DBXFilesCreateFolderResult?) -> DBFILESCreateFolderResult? {
    guard let object = object else { return nil }
    return mapDBXFilesCreateFolderResultToDB(object: object)
}

func mapDBXFilesCreateFolderResultToDB(object: DBXFilesCreateFolderResult) -> DBFILESCreateFolderResult {
    DBFILESCreateFolderResult(metadata: mapDBXFilesFolderMetadataToDB(object: object.metadata))
}

func mapDBXFilesDeleteArgToDBOptional(object: DBXFilesDeleteArg?) -> DBFILESDeleteArg? {
    guard let object = object else { return nil }
    return mapDBXFilesDeleteArgToDB(object: object)
}

func mapDBXFilesDeleteArgToDB(object: DBXFilesDeleteArg) -> DBFILESDeleteArg {
    DBFILESDeleteArg(path: object.path, parentRev: object.parentRev)
}

func mapDBXFilesDeleteBatchArgToDBOptional(object: DBXFilesDeleteBatchArg?) -> DBFILESDeleteBatchArg? {
    guard let object = object else { return nil }
    return mapDBXFilesDeleteBatchArgToDB(object: object)
}

func mapDBXFilesDeleteBatchArgToDB(object: DBXFilesDeleteBatchArg) -> DBFILESDeleteBatchArg {
    DBFILESDeleteBatchArg(entries: object.entries.compactMap { mapDBXFilesDeleteArgToDB(object: $0) })
}

func mapDBXFilesDeleteBatchErrorToDBOptional(object: DBXFilesDeleteBatchError?) -> DBFILESDeleteBatchError? {
    guard let object = object else { return nil }
    return mapDBXFilesDeleteBatchErrorToDB(object: object)
}

func mapDBXFilesDeleteBatchErrorToDB(object: DBXFilesDeleteBatchError) -> DBFILESDeleteBatchError {
    if object.asTooManyWriteOperations != nil {
        return DBFILESDeleteBatchError(tooManyWriteOperations: ())
    }
    if object.asOther != nil {
        return DBFILESDeleteBatchError(other: ())
    }
    fatalError("codegen error")
}

func mapDBXFilesDeleteBatchJobStatusToDBOptional(object: DBXFilesDeleteBatchJobStatus?) -> DBFILESDeleteBatchJobStatus? {
    guard let object = object else { return nil }
    return mapDBXFilesDeleteBatchJobStatusToDB(object: object)
}

func mapDBXFilesDeleteBatchJobStatusToDB(object: DBXFilesDeleteBatchJobStatus) -> DBFILESDeleteBatchJobStatus {
    if object.asInProgress != nil {
        return DBFILESDeleteBatchJobStatus(inProgress: ())
    }
    if let object = object.asComplete {
        let complete = mapDBXFilesDeleteBatchResultToDB(object: object.complete)
        return DBFILESDeleteBatchJobStatus(complete: complete)
    }
    if let object = object.asFailed {
        let failed = mapDBXFilesDeleteBatchErrorToDB(object: object.failed)
        return DBFILESDeleteBatchJobStatus(failed: failed)
    }
    if object.asOther != nil {
        return DBFILESDeleteBatchJobStatus(other: ())
    }
    fatalError("codegen error")
}

func mapDBXFilesDeleteBatchLaunchToDBOptional(object: DBXFilesDeleteBatchLaunch?) -> DBFILESDeleteBatchLaunch? {
    guard let object = object else { return nil }
    return mapDBXFilesDeleteBatchLaunchToDB(object: object)
}

func mapDBXFilesDeleteBatchLaunchToDB(object: DBXFilesDeleteBatchLaunch) -> DBFILESDeleteBatchLaunch {
    if let object = object.asAsyncJobId {
        let asyncJobId = object.asyncJobId
        return DBFILESDeleteBatchLaunch(asyncJobId: asyncJobId)
    }
    if let object = object.asComplete {
        let complete = mapDBXFilesDeleteBatchResultToDB(object: object.complete)
        return DBFILESDeleteBatchLaunch(complete: complete)
    }
    if object.asOther != nil {
        return DBFILESDeleteBatchLaunch(other: ())
    }
    fatalError("codegen error")
}

func mapDBXFilesDeleteBatchResultToDBOptional(object: DBXFilesDeleteBatchResult?) -> DBFILESDeleteBatchResult? {
    guard let object = object else { return nil }
    return mapDBXFilesDeleteBatchResultToDB(object: object)
}

func mapDBXFilesDeleteBatchResultToDB(object: DBXFilesDeleteBatchResult) -> DBFILESDeleteBatchResult {
    DBFILESDeleteBatchResult(entries: object.entries.compactMap { mapDBXFilesDeleteBatchResultEntryToDB(object: $0) })
}

func mapDBXFilesDeleteBatchResultDataToDBOptional(object: DBXFilesDeleteBatchResultData?) -> DBFILESDeleteBatchResultData? {
    guard let object = object else { return nil }
    return mapDBXFilesDeleteBatchResultDataToDB(object: object)
}

func mapDBXFilesDeleteBatchResultDataToDB(object: DBXFilesDeleteBatchResultData) -> DBFILESDeleteBatchResultData {
    DBFILESDeleteBatchResultData(metadata: mapDBXFilesMetadataToDB(object: object.metadata))
}

func mapDBXFilesDeleteBatchResultEntryToDBOptional(object: DBXFilesDeleteBatchResultEntry?) -> DBFILESDeleteBatchResultEntry? {
    guard let object = object else { return nil }
    return mapDBXFilesDeleteBatchResultEntryToDB(object: object)
}

func mapDBXFilesDeleteBatchResultEntryToDB(object: DBXFilesDeleteBatchResultEntry) -> DBFILESDeleteBatchResultEntry {
    if let object = object.asSuccess {
        let success = mapDBXFilesDeleteBatchResultDataToDB(object: object.success)
        return DBFILESDeleteBatchResultEntry(success: success)
    }
    if let object = object.asFailure {
        let failure = mapDBXFilesDeleteErrorToDB(object: object.failure)
        return DBFILESDeleteBatchResultEntry(failure: failure)
    }
    fatalError("codegen error")
}

func mapDBXFilesDeleteErrorToDBOptional(object: DBXFilesDeleteError?) -> DBFILESDeleteError? {
    guard let object = object else { return nil }
    return mapDBXFilesDeleteErrorToDB(object: object)
}

func mapDBXFilesDeleteErrorToDB(object: DBXFilesDeleteError) -> DBFILESDeleteError {
    if let object = object.asPathLookup {
        let pathLookup = mapDBXFilesLookupErrorToDB(object: object.pathLookup)
        return DBFILESDeleteError(pathLookup: pathLookup)
    }
    if let object = object.asPathWrite {
        let pathWrite = mapDBXFilesWriteErrorToDB(object: object.pathWrite)
        return DBFILESDeleteError(pathWrite: pathWrite)
    }
    if object.asTooManyWriteOperations != nil {
        return DBFILESDeleteError(tooManyWriteOperations: ())
    }
    if object.asTooManyFiles != nil {
        return DBFILESDeleteError(tooManyFiles: ())
    }
    if object.asOther != nil {
        return DBFILESDeleteError(other: ())
    }
    fatalError("codegen error")
}

func mapDBXFilesDeleteResultToDBOptional(object: DBXFilesDeleteResult?) -> DBFILESDeleteResult? {
    guard let object = object else { return nil }
    return mapDBXFilesDeleteResultToDB(object: object)
}

func mapDBXFilesDeleteResultToDB(object: DBXFilesDeleteResult) -> DBFILESDeleteResult {
    DBFILESDeleteResult(metadata: mapDBXFilesMetadataToDB(object: object.metadata))
}

func mapDBXFilesMetadataToDBOptional(object: DBXFilesMetadata?) -> DBFILESMetadata? {
    guard let object = object else { return nil }
    return mapDBXFilesMetadataToDB(object: object)
}

func mapDBXFilesMetadataToDB(object: DBXFilesMetadata) -> DBFILESMetadata {
    switch object {
    case let object as DBXFilesFileMetadata:
        return DBFILESFileMetadata(
            name: object.name,
            id_: object.id,
            clientModified: object.clientModified,
            serverModified: object.serverModified,
            rev: object.rev,
            size: object.size,
            pathLower: object.pathLower,
            pathDisplay: object.pathDisplay,
            parentSharedFolderId: object.parentSharedFolderId,
            previewUrl: object.previewUrl,
            mediaInfo: mapDBXFilesMediaInfoToDBOptional(object: object.mediaInfo),
            symlinkInfo: mapDBXFilesSymlinkInfoToDBOptional(object: object.symlinkInfo),
            sharingInfo: mapDBXFilesFileSharingInfoToDBOptional(object: object.sharingInfo),
            isDownloadable: object.isDownloadable,
            exportInfo: mapDBXFilesExportInfoToDBOptional(object: object.exportInfo),
            propertyGroups: object.propertyGroups?.compactMap { mapDBXFilePropertiesPropertyGroupToDB(object: $0) },
            hasExplicitSharedMembers: object.hasExplicitSharedMembers,
            contentHash: object.contentHash,
            fileLockInfo: mapDBXFilesFileLockMetadataToDBOptional(object: object.fileLockInfo)
        )
    case let object as DBXFilesFolderMetadata:
        return DBFILESFolderMetadata(
            name: object.name,
            id_: object.id,
            pathLower: object.pathLower,
            pathDisplay: object.pathDisplay,
            parentSharedFolderId: object.parentSharedFolderId,
            previewUrl: object.previewUrl,
            sharedFolderId: object.sharedFolderId,
            sharingInfo: mapDBXFilesFolderSharingInfoToDBOptional(object: object.sharingInfo),
            propertyGroups: object.propertyGroups?.compactMap { mapDBXFilePropertiesPropertyGroupToDB(object: $0) }
        )
    case let object as DBXFilesDeletedMetadata:
        return DBFILESDeletedMetadata(
            name: object.name,
            pathLower: object.pathLower,
            pathDisplay: object.pathDisplay,
            parentSharedFolderId: object.parentSharedFolderId,
            previewUrl: object.previewUrl
        )
    default:
        return DBFILESMetadata(
            name: object.name,
            pathLower: object.pathLower,
            pathDisplay: object.pathDisplay,
            parentSharedFolderId: object.parentSharedFolderId,
            previewUrl: object.previewUrl
        )
    }
}

func mapDBXFilesDeletedMetadataToDBOptional(object: DBXFilesDeletedMetadata?) -> DBFILESDeletedMetadata? {
    guard let object = object else { return nil }
    return mapDBXFilesDeletedMetadataToDB(object: object)
}

func mapDBXFilesDeletedMetadataToDB(object: DBXFilesDeletedMetadata) -> DBFILESDeletedMetadata {
    DBFILESDeletedMetadata(
        name: object.name,
        pathLower: object.pathLower,
        pathDisplay: object.pathDisplay,
        parentSharedFolderId: object.parentSharedFolderId,
        previewUrl: object.previewUrl
    )
}

func mapDBXFilesDimensionsToDBOptional(object: DBXFilesDimensions?) -> DBFILESDimensions? {
    guard let object = object else { return nil }
    return mapDBXFilesDimensionsToDB(object: object)
}

func mapDBXFilesDimensionsToDB(object: DBXFilesDimensions) -> DBFILESDimensions {
    DBFILESDimensions(height: object.height, width: object.width)
}

func mapDBXFilesDownloadArgToDBOptional(object: DBXFilesDownloadArg?) -> DBFILESDownloadArg? {
    guard let object = object else { return nil }
    return mapDBXFilesDownloadArgToDB(object: object)
}

func mapDBXFilesDownloadArgToDB(object: DBXFilesDownloadArg) -> DBFILESDownloadArg {
    DBFILESDownloadArg(path: object.path, rev: object.rev)
}

func mapDBXFilesDownloadErrorToDBOptional(object: DBXFilesDownloadError?) -> DBFILESDownloadError? {
    guard let object = object else { return nil }
    return mapDBXFilesDownloadErrorToDB(object: object)
}

func mapDBXFilesDownloadErrorToDB(object: DBXFilesDownloadError) -> DBFILESDownloadError {
    if let object = object.asPath {
        let path = mapDBXFilesLookupErrorToDB(object: object.path)
        return DBFILESDownloadError(path: path)
    }
    if object.asUnsupportedFile != nil {
        return DBFILESDownloadError(unsupportedFile: ())
    }
    if object.asOther != nil {
        return DBFILESDownloadError(other: ())
    }
    fatalError("codegen error")
}

func mapDBXFilesDownloadZipArgToDBOptional(object: DBXFilesDownloadZipArg?) -> DBFILESDownloadZipArg? {
    guard let object = object else { return nil }
    return mapDBXFilesDownloadZipArgToDB(object: object)
}

func mapDBXFilesDownloadZipArgToDB(object: DBXFilesDownloadZipArg) -> DBFILESDownloadZipArg {
    DBFILESDownloadZipArg(path: object.path)
}

func mapDBXFilesDownloadZipErrorToDBOptional(object: DBXFilesDownloadZipError?) -> DBFILESDownloadZipError? {
    guard let object = object else { return nil }
    return mapDBXFilesDownloadZipErrorToDB(object: object)
}

func mapDBXFilesDownloadZipErrorToDB(object: DBXFilesDownloadZipError) -> DBFILESDownloadZipError {
    if let object = object.asPath {
        let path = mapDBXFilesLookupErrorToDB(object: object.path)
        return DBFILESDownloadZipError(path: path)
    }
    if object.asTooLarge != nil {
        return DBFILESDownloadZipError(tooLarge: ())
    }
    if object.asTooManyFiles != nil {
        return DBFILESDownloadZipError(tooManyFiles: ())
    }
    if object.asOther != nil {
        return DBFILESDownloadZipError(other: ())
    }
    fatalError("codegen error")
}

func mapDBXFilesDownloadZipResultToDBOptional(object: DBXFilesDownloadZipResult?) -> DBFILESDownloadZipResult? {
    guard let object = object else { return nil }
    return mapDBXFilesDownloadZipResultToDB(object: object)
}

func mapDBXFilesDownloadZipResultToDB(object: DBXFilesDownloadZipResult) -> DBFILESDownloadZipResult {
    DBFILESDownloadZipResult(metadata: mapDBXFilesFolderMetadataToDB(object: object.metadata))
}

func mapDBXFilesExportArgToDBOptional(object: DBXFilesExportArg?) -> DBFILESExportArg? {
    guard let object = object else { return nil }
    return mapDBXFilesExportArgToDB(object: object)
}

func mapDBXFilesExportArgToDB(object: DBXFilesExportArg) -> DBFILESExportArg {
    DBFILESExportArg(path: object.path, exportFormat: object.exportFormat)
}

func mapDBXFilesExportErrorToDBOptional(object: DBXFilesExportError?) -> DBFILESExportError? {
    guard let object = object else { return nil }
    return mapDBXFilesExportErrorToDB(object: object)
}

func mapDBXFilesExportErrorToDB(object: DBXFilesExportError) -> DBFILESExportError {
    if let object = object.asPath {
        let path = mapDBXFilesLookupErrorToDB(object: object.path)
        return DBFILESExportError(path: path)
    }
    if object.asNonExportable != nil {
        return DBFILESExportError(nonExportable: ())
    }
    if object.asInvalidExportFormat != nil {
        return DBFILESExportError(invalidExportFormat: ())
    }
    if object.asRetryError != nil {
        return DBFILESExportError(retryError: ())
    }
    if object.asOther != nil {
        return DBFILESExportError(other: ())
    }
    fatalError("codegen error")
}

func mapDBXFilesExportInfoToDBOptional(object: DBXFilesExportInfo?) -> DBFILESExportInfo? {
    guard let object = object else { return nil }
    return mapDBXFilesExportInfoToDB(object: object)
}

func mapDBXFilesExportInfoToDB(object: DBXFilesExportInfo) -> DBFILESExportInfo {
    DBFILESExportInfo(exportAs: object.exportAs, exportOptions: object.exportOptions)
}

func mapDBXFilesExportMetadataToDBOptional(object: DBXFilesExportMetadata?) -> DBFILESExportMetadata? {
    guard let object = object else { return nil }
    return mapDBXFilesExportMetadataToDB(object: object)
}

func mapDBXFilesExportMetadataToDB(object: DBXFilesExportMetadata) -> DBFILESExportMetadata {
    DBFILESExportMetadata(name: object.name, size: object.size, exportHash: object.exportHash, paperRevision: object.paperRevision)
}

func mapDBXFilesExportResultToDBOptional(object: DBXFilesExportResult?) -> DBFILESExportResult? {
    guard let object = object else { return nil }
    return mapDBXFilesExportResultToDB(object: object)
}

func mapDBXFilesExportResultToDB(object: DBXFilesExportResult) -> DBFILESExportResult {
    DBFILESExportResult(
        exportMetadata: mapDBXFilesExportMetadataToDB(object: object.exportMetadata),
        fileMetadata: mapDBXFilesFileMetadataToDB(object: object.fileMetadata)
    )
}

func mapDBXFilesFileCategoryToDBOptional(object: DBXFilesFileCategory?) -> DBFILESFileCategory? {
    guard let object = object else { return nil }
    return mapDBXFilesFileCategoryToDB(object: object)
}

func mapDBXFilesFileCategoryToDB(object: DBXFilesFileCategory) -> DBFILESFileCategory {
    if object.asImage != nil {
        return DBFILESFileCategory(image: ())
    }
    if object.asDocument != nil {
        return DBFILESFileCategory(document: ())
    }
    if object.asPdf != nil {
        return DBFILESFileCategory(pdf: ())
    }
    if object.asSpreadsheet != nil {
        return DBFILESFileCategory(spreadsheet: ())
    }
    if object.asPresentation != nil {
        return DBFILESFileCategory(presentation: ())
    }
    if object.asAudio != nil {
        return DBFILESFileCategory(audio: ())
    }
    if object.asVideo != nil {
        return DBFILESFileCategory(video: ())
    }
    if object.asFolder != nil {
        return DBFILESFileCategory(folder: ())
    }
    if object.asPaper != nil {
        return DBFILESFileCategory(paper: ())
    }
    if object.asOthers != nil {
        return DBFILESFileCategory(others: ())
    }
    if object.asOther != nil {
        return DBFILESFileCategory(other: ())
    }
    fatalError("codegen error")
}

func mapDBXFilesFileLockToDBOptional(object: DBXFilesFileLock?) -> DBFILESFileLock? {
    guard let object = object else { return nil }
    return mapDBXFilesFileLockToDB(object: object)
}

func mapDBXFilesFileLockToDB(object: DBXFilesFileLock) -> DBFILESFileLock {
    DBFILESFileLock(content: mapDBXFilesFileLockContentToDB(object: object.content))
}

func mapDBXFilesFileLockContentToDBOptional(object: DBXFilesFileLockContent?) -> DBFILESFileLockContent? {
    guard let object = object else { return nil }
    return mapDBXFilesFileLockContentToDB(object: object)
}

func mapDBXFilesFileLockContentToDB(object: DBXFilesFileLockContent) -> DBFILESFileLockContent {
    if object.asUnlocked != nil {
        return DBFILESFileLockContent(unlocked: ())
    }
    if let object = object.asSingleUser {
        let singleUser = mapDBXFilesSingleUserLockToDB(object: object.singleUser)
        return DBFILESFileLockContent(singleUser: singleUser)
    }
    if object.asOther != nil {
        return DBFILESFileLockContent(other: ())
    }
    fatalError("codegen error")
}

func mapDBXFilesFileLockMetadataToDBOptional(object: DBXFilesFileLockMetadata?) -> DBFILESFileLockMetadata? {
    guard let object = object else { return nil }
    return mapDBXFilesFileLockMetadataToDB(object: object)
}

func mapDBXFilesFileLockMetadataToDB(object: DBXFilesFileLockMetadata) -> DBFILESFileLockMetadata {
    DBFILESFileLockMetadata(
        isLockholder: object.isLockholder,
        lockholderName: object.lockholderName,
        lockholderAccountId: object.lockholderAccountId,
        created: object.created
    )
}

func mapDBXFilesFileMetadataToDBOptional(object: DBXFilesFileMetadata?) -> DBFILESFileMetadata? {
    guard let object = object else { return nil }
    return mapDBXFilesFileMetadataToDB(object: object)
}

func mapDBXFilesFileMetadataToDB(object: DBXFilesFileMetadata) -> DBFILESFileMetadata {
    DBFILESFileMetadata(
        name: object.name,
        id_: object.id,
        clientModified: object.clientModified,
        serverModified: object.serverModified,
        rev: object.rev,
        size: object.size,
        pathLower: object.pathLower,
        pathDisplay: object.pathDisplay,
        parentSharedFolderId: object.parentSharedFolderId,
        previewUrl: object.previewUrl,
        mediaInfo: mapDBXFilesMediaInfoToDBOptional(object: object.mediaInfo),
        symlinkInfo: mapDBXFilesSymlinkInfoToDBOptional(object: object.symlinkInfo),
        sharingInfo: mapDBXFilesFileSharingInfoToDBOptional(object: object.sharingInfo),
        isDownloadable: object.isDownloadable,
        exportInfo: mapDBXFilesExportInfoToDBOptional(object: object.exportInfo),
        propertyGroups: object.propertyGroups?.compactMap { mapDBXFilePropertiesPropertyGroupToDB(object: $0) },
        hasExplicitSharedMembers: object.hasExplicitSharedMembers,
        contentHash: object.contentHash,
        fileLockInfo: mapDBXFilesFileLockMetadataToDBOptional(object: object.fileLockInfo)
    )
}

func mapDBXFilesSharingInfoToDBOptional(object: DBXFilesSharingInfo?) -> DBFILESSharingInfo? {
    guard let object = object else { return nil }
    return mapDBXFilesSharingInfoToDB(object: object)
}

func mapDBXFilesSharingInfoToDB(object: DBXFilesSharingInfo) -> DBFILESSharingInfo {
    DBFILESSharingInfo(readOnly: object.readOnly)
}

func mapDBXFilesFileSharingInfoToDBOptional(object: DBXFilesFileSharingInfo?) -> DBFILESFileSharingInfo? {
    guard let object = object else { return nil }
    return mapDBXFilesFileSharingInfoToDB(object: object)
}

func mapDBXFilesFileSharingInfoToDB(object: DBXFilesFileSharingInfo) -> DBFILESFileSharingInfo {
    DBFILESFileSharingInfo(readOnly: object.readOnly, parentSharedFolderId: object.parentSharedFolderId, modifiedBy: object.modifiedBy)
}

func mapDBXFilesFileStatusToDBOptional(object: DBXFilesFileStatus?) -> DBFILESFileStatus? {
    guard let object = object else { return nil }
    return mapDBXFilesFileStatusToDB(object: object)
}

func mapDBXFilesFileStatusToDB(object: DBXFilesFileStatus) -> DBFILESFileStatus {
    if object.asActive != nil {
        return DBFILESFileStatus(active: ())
    }
    if object.asDeleted != nil {
        return DBFILESFileStatus(deleted: ())
    }
    if object.asOther != nil {
        return DBFILESFileStatus(other: ())
    }
    fatalError("codegen error")
}

func mapDBXFilesFolderMetadataToDBOptional(object: DBXFilesFolderMetadata?) -> DBFILESFolderMetadata? {
    guard let object = object else { return nil }
    return mapDBXFilesFolderMetadataToDB(object: object)
}

func mapDBXFilesFolderMetadataToDB(object: DBXFilesFolderMetadata) -> DBFILESFolderMetadata {
    DBFILESFolderMetadata(
        name: object.name,
        id_: object.id,
        pathLower: object.pathLower,
        pathDisplay: object.pathDisplay,
        parentSharedFolderId: object.parentSharedFolderId,
        previewUrl: object.previewUrl,
        sharedFolderId: object.sharedFolderId,
        sharingInfo: mapDBXFilesFolderSharingInfoToDBOptional(object: object.sharingInfo),
        propertyGroups: object.propertyGroups?.compactMap { mapDBXFilePropertiesPropertyGroupToDB(object: $0) }
    )
}

func mapDBXFilesFolderSharingInfoToDBOptional(object: DBXFilesFolderSharingInfo?) -> DBFILESFolderSharingInfo? {
    guard let object = object else { return nil }
    return mapDBXFilesFolderSharingInfoToDB(object: object)
}

func mapDBXFilesFolderSharingInfoToDB(object: DBXFilesFolderSharingInfo) -> DBFILESFolderSharingInfo {
    DBFILESFolderSharingInfo(
        readOnly: object.readOnly,
        parentSharedFolderId: object.parentSharedFolderId,
        sharedFolderId: object.sharedFolderId,
        traverseOnly: object.traverseOnly,
        noAccess: object.noAccess
    )
}

func mapDBXFilesGetCopyReferenceArgToDBOptional(object: DBXFilesGetCopyReferenceArg?) -> DBFILESGetCopyReferenceArg? {
    guard let object = object else { return nil }
    return mapDBXFilesGetCopyReferenceArgToDB(object: object)
}

func mapDBXFilesGetCopyReferenceArgToDB(object: DBXFilesGetCopyReferenceArg) -> DBFILESGetCopyReferenceArg {
    DBFILESGetCopyReferenceArg(path: object.path)
}

func mapDBXFilesGetCopyReferenceErrorToDBOptional(object: DBXFilesGetCopyReferenceError?) -> DBFILESGetCopyReferenceError? {
    guard let object = object else { return nil }
    return mapDBXFilesGetCopyReferenceErrorToDB(object: object)
}

func mapDBXFilesGetCopyReferenceErrorToDB(object: DBXFilesGetCopyReferenceError) -> DBFILESGetCopyReferenceError {
    if let object = object.asPath {
        let path = mapDBXFilesLookupErrorToDB(object: object.path)
        return DBFILESGetCopyReferenceError(path: path)
    }
    if object.asOther != nil {
        return DBFILESGetCopyReferenceError(other: ())
    }
    fatalError("codegen error")
}

func mapDBXFilesGetCopyReferenceResultToDBOptional(object: DBXFilesGetCopyReferenceResult?) -> DBFILESGetCopyReferenceResult? {
    guard let object = object else { return nil }
    return mapDBXFilesGetCopyReferenceResultToDB(object: object)
}

func mapDBXFilesGetCopyReferenceResultToDB(object: DBXFilesGetCopyReferenceResult) -> DBFILESGetCopyReferenceResult {
    DBFILESGetCopyReferenceResult(metadata: mapDBXFilesMetadataToDB(object: object.metadata), dCopyReference: object.copyReference, expires: object.expires)
}

func mapDBXFilesGetTagsArgToDBOptional(object: DBXFilesGetTagsArg?) -> DBFILESGetTagsArg? {
    guard let object = object else { return nil }
    return mapDBXFilesGetTagsArgToDB(object: object)
}

func mapDBXFilesGetTagsArgToDB(object: DBXFilesGetTagsArg) -> DBFILESGetTagsArg {
    DBFILESGetTagsArg(paths: object.paths)
}

func mapDBXFilesGetTagsResultToDBOptional(object: DBXFilesGetTagsResult?) -> DBFILESGetTagsResult? {
    guard let object = object else { return nil }
    return mapDBXFilesGetTagsResultToDB(object: object)
}

func mapDBXFilesGetTagsResultToDB(object: DBXFilesGetTagsResult) -> DBFILESGetTagsResult {
    DBFILESGetTagsResult(pathsToTags: object.pathsToTags.compactMap { mapDBXFilesPathToTagsToDB(object: $0) })
}

func mapDBXFilesGetTemporaryLinkArgToDBOptional(object: DBXFilesGetTemporaryLinkArg?) -> DBFILESGetTemporaryLinkArg? {
    guard let object = object else { return nil }
    return mapDBXFilesGetTemporaryLinkArgToDB(object: object)
}

func mapDBXFilesGetTemporaryLinkArgToDB(object: DBXFilesGetTemporaryLinkArg) -> DBFILESGetTemporaryLinkArg {
    DBFILESGetTemporaryLinkArg(path: object.path)
}

func mapDBXFilesGetTemporaryLinkErrorToDBOptional(object: DBXFilesGetTemporaryLinkError?) -> DBFILESGetTemporaryLinkError? {
    guard let object = object else { return nil }
    return mapDBXFilesGetTemporaryLinkErrorToDB(object: object)
}

func mapDBXFilesGetTemporaryLinkErrorToDB(object: DBXFilesGetTemporaryLinkError) -> DBFILESGetTemporaryLinkError {
    if let object = object.asPath {
        let path = mapDBXFilesLookupErrorToDB(object: object.path)
        return DBFILESGetTemporaryLinkError(path: path)
    }
    if object.asEmailNotVerified != nil {
        return DBFILESGetTemporaryLinkError(emailNotVerified: ())
    }
    if object.asUnsupportedFile != nil {
        return DBFILESGetTemporaryLinkError(unsupportedFile: ())
    }
    if object.asNotAllowed != nil {
        return DBFILESGetTemporaryLinkError(notAllowed: ())
    }
    if object.asOther != nil {
        return DBFILESGetTemporaryLinkError(other: ())
    }
    fatalError("codegen error")
}

func mapDBXFilesGetTemporaryLinkResultToDBOptional(object: DBXFilesGetTemporaryLinkResult?) -> DBFILESGetTemporaryLinkResult? {
    guard let object = object else { return nil }
    return mapDBXFilesGetTemporaryLinkResultToDB(object: object)
}

func mapDBXFilesGetTemporaryLinkResultToDB(object: DBXFilesGetTemporaryLinkResult) -> DBFILESGetTemporaryLinkResult {
    DBFILESGetTemporaryLinkResult(metadata: mapDBXFilesFileMetadataToDB(object: object.metadata), link: object.link)
}

func mapDBXFilesGetTemporaryUploadLinkArgToDBOptional(object: DBXFilesGetTemporaryUploadLinkArg?) -> DBFILESGetTemporaryUploadLinkArg? {
    guard let object = object else { return nil }
    return mapDBXFilesGetTemporaryUploadLinkArgToDB(object: object)
}

func mapDBXFilesGetTemporaryUploadLinkArgToDB(object: DBXFilesGetTemporaryUploadLinkArg) -> DBFILESGetTemporaryUploadLinkArg {
    DBFILESGetTemporaryUploadLinkArg(commitInfo: mapDBXFilesCommitInfoToDB(object: object.commitInfo), duration: object.duration)
}

func mapDBXFilesGetTemporaryUploadLinkResultToDBOptional(object: DBXFilesGetTemporaryUploadLinkResult?) -> DBFILESGetTemporaryUploadLinkResult? {
    guard let object = object else { return nil }
    return mapDBXFilesGetTemporaryUploadLinkResultToDB(object: object)
}

func mapDBXFilesGetTemporaryUploadLinkResultToDB(object: DBXFilesGetTemporaryUploadLinkResult) -> DBFILESGetTemporaryUploadLinkResult {
    DBFILESGetTemporaryUploadLinkResult(link: object.link)
}

func mapDBXFilesGetThumbnailBatchArgToDBOptional(object: DBXFilesGetThumbnailBatchArg?) -> DBFILESGetThumbnailBatchArg? {
    guard let object = object else { return nil }
    return mapDBXFilesGetThumbnailBatchArgToDB(object: object)
}

func mapDBXFilesGetThumbnailBatchArgToDB(object: DBXFilesGetThumbnailBatchArg) -> DBFILESGetThumbnailBatchArg {
    DBFILESGetThumbnailBatchArg(entries: object.entries.compactMap { mapDBXFilesThumbnailArgToDB(object: $0) })
}

func mapDBXFilesGetThumbnailBatchErrorToDBOptional(object: DBXFilesGetThumbnailBatchError?) -> DBFILESGetThumbnailBatchError? {
    guard let object = object else { return nil }
    return mapDBXFilesGetThumbnailBatchErrorToDB(object: object)
}

func mapDBXFilesGetThumbnailBatchErrorToDB(object: DBXFilesGetThumbnailBatchError) -> DBFILESGetThumbnailBatchError {
    if object.asTooManyFiles != nil {
        return DBFILESGetThumbnailBatchError(tooManyFiles: ())
    }
    if object.asOther != nil {
        return DBFILESGetThumbnailBatchError(other: ())
    }
    fatalError("codegen error")
}

func mapDBXFilesGetThumbnailBatchResultToDBOptional(object: DBXFilesGetThumbnailBatchResult?) -> DBFILESGetThumbnailBatchResult? {
    guard let object = object else { return nil }
    return mapDBXFilesGetThumbnailBatchResultToDB(object: object)
}

func mapDBXFilesGetThumbnailBatchResultToDB(object: DBXFilesGetThumbnailBatchResult) -> DBFILESGetThumbnailBatchResult {
    DBFILESGetThumbnailBatchResult(entries: object.entries.compactMap { mapDBXFilesGetThumbnailBatchResultEntryToDB(object: $0) })
}

func mapDBXFilesGetThumbnailBatchResultDataToDBOptional(object: DBXFilesGetThumbnailBatchResultData?) -> DBFILESGetThumbnailBatchResultData? {
    guard let object = object else { return nil }
    return mapDBXFilesGetThumbnailBatchResultDataToDB(object: object)
}

func mapDBXFilesGetThumbnailBatchResultDataToDB(object: DBXFilesGetThumbnailBatchResultData) -> DBFILESGetThumbnailBatchResultData {
    DBFILESGetThumbnailBatchResultData(metadata: mapDBXFilesFileMetadataToDB(object: object.metadata), thumbnail: object.thumbnail)
}

func mapDBXFilesGetThumbnailBatchResultEntryToDBOptional(object: DBXFilesGetThumbnailBatchResultEntry?) -> DBFILESGetThumbnailBatchResultEntry? {
    guard let object = object else { return nil }
    return mapDBXFilesGetThumbnailBatchResultEntryToDB(object: object)
}

func mapDBXFilesGetThumbnailBatchResultEntryToDB(object: DBXFilesGetThumbnailBatchResultEntry) -> DBFILESGetThumbnailBatchResultEntry {
    if let object = object.asSuccess {
        let success = mapDBXFilesGetThumbnailBatchResultDataToDB(object: object.success)
        return DBFILESGetThumbnailBatchResultEntry(success: success)
    }
    if let object = object.asFailure {
        let failure = mapDBXFilesThumbnailErrorToDB(object: object.failure)
        return DBFILESGetThumbnailBatchResultEntry(failure: failure)
    }
    if object.asOther != nil {
        return DBFILESGetThumbnailBatchResultEntry(other: ())
    }
    fatalError("codegen error")
}

func mapDBXFilesGpsCoordinatesToDBOptional(object: DBXFilesGpsCoordinates?) -> DBFILESGpsCoordinates? {
    guard let object = object else { return nil }
    return mapDBXFilesGpsCoordinatesToDB(object: object)
}

func mapDBXFilesGpsCoordinatesToDB(object: DBXFilesGpsCoordinates) -> DBFILESGpsCoordinates {
    DBFILESGpsCoordinates(latitude: object.latitude, longitude: object.longitude)
}

func mapDBXFilesHighlightSpanToDBOptional(object: DBXFilesHighlightSpan?) -> DBFILESHighlightSpan? {
    guard let object = object else { return nil }
    return mapDBXFilesHighlightSpanToDB(object: object)
}

func mapDBXFilesHighlightSpanToDB(object: DBXFilesHighlightSpan) -> DBFILESHighlightSpan {
    DBFILESHighlightSpan(highlightStr: object.highlightStr, isHighlighted: object.isHighlighted)
}

func mapDBXFilesImportFormatToDBOptional(object: DBXFilesImportFormat?) -> DBFILESImportFormat? {
    guard let object = object else { return nil }
    return mapDBXFilesImportFormatToDB(object: object)
}

func mapDBXFilesImportFormatToDB(object: DBXFilesImportFormat) -> DBFILESImportFormat {
    if object.asHtml != nil {
        return DBFILESImportFormat(html: ())
    }
    if object.asMarkdown != nil {
        return DBFILESImportFormat(markdown: ())
    }
    if object.asPlainText != nil {
        return DBFILESImportFormat(plainText: ())
    }
    if object.asOther != nil {
        return DBFILESImportFormat(other: ())
    }
    fatalError("codegen error")
}

func mapDBXFilesListFolderArgToDBOptional(object: DBXFilesListFolderArg?) -> DBFILESListFolderArg? {
    guard let object = object else { return nil }
    return mapDBXFilesListFolderArgToDB(object: object)
}

func mapDBXFilesListFolderArgToDB(object: DBXFilesListFolderArg) -> DBFILESListFolderArg {
    DBFILESListFolderArg(
        path: object.path,
        recursive: object.recursive,
        includeMediaInfo: object.includeMediaInfo,
        includeDeleted: object.includeDeleted,
        includeHasExplicitSharedMembers: object.includeHasExplicitSharedMembers,
        includeMountedFolders: object.includeMountedFolders,
        limit: object.limit,
        sharedLink: mapDBXFilesSharedLinkToDBOptional(object: object.sharedLink),
        includePropertyGroups: mapDBXFilePropertiesTemplateFilterBaseToDBOptional(object: object.includePropertyGroups),
        includeNonDownloadableFiles: object.includeNonDownloadableFiles
    )
}

func mapDBXFilesListFolderContinueArgToDBOptional(object: DBXFilesListFolderContinueArg?) -> DBFILESListFolderContinueArg? {
    guard let object = object else { return nil }
    return mapDBXFilesListFolderContinueArgToDB(object: object)
}

func mapDBXFilesListFolderContinueArgToDB(object: DBXFilesListFolderContinueArg) -> DBFILESListFolderContinueArg {
    DBFILESListFolderContinueArg(cursor: object.cursor)
}

func mapDBXFilesListFolderContinueErrorToDBOptional(object: DBXFilesListFolderContinueError?) -> DBFILESListFolderContinueError? {
    guard let object = object else { return nil }
    return mapDBXFilesListFolderContinueErrorToDB(object: object)
}

func mapDBXFilesListFolderContinueErrorToDB(object: DBXFilesListFolderContinueError) -> DBFILESListFolderContinueError {
    if let object = object.asPath {
        let path = mapDBXFilesLookupErrorToDB(object: object.path)
        return DBFILESListFolderContinueError(path: path)
    }
    if object.asReset != nil {
        return DBFILESListFolderContinueError(reset: ())
    }
    if object.asOther != nil {
        return DBFILESListFolderContinueError(other: ())
    }
    fatalError("codegen error")
}

func mapDBXFilesListFolderErrorToDBOptional(object: DBXFilesListFolderError?) -> DBFILESListFolderError? {
    guard let object = object else { return nil }
    return mapDBXFilesListFolderErrorToDB(object: object)
}

func mapDBXFilesListFolderErrorToDB(object: DBXFilesListFolderError) -> DBFILESListFolderError {
    if let object = object.asPath {
        let path = mapDBXFilesLookupErrorToDB(object: object.path)
        return DBFILESListFolderError(path: path)
    }
    if let object = object.asTemplateError {
        let templateError = mapDBXFilePropertiesTemplateErrorToDB(object: object.templateError)
        return DBFILESListFolderError(templateError: templateError)
    }
    if object.asOther != nil {
        return DBFILESListFolderError(other: ())
    }
    fatalError("codegen error")
}

func mapDBXFilesListFolderGetLatestCursorResultToDBOptional(object: DBXFilesListFolderGetLatestCursorResult?) -> DBFILESListFolderGetLatestCursorResult? {
    guard let object = object else { return nil }
    return mapDBXFilesListFolderGetLatestCursorResultToDB(object: object)
}

func mapDBXFilesListFolderGetLatestCursorResultToDB(object: DBXFilesListFolderGetLatestCursorResult) -> DBFILESListFolderGetLatestCursorResult {
    DBFILESListFolderGetLatestCursorResult(cursor: object.cursor)
}

func mapDBXFilesListFolderLongpollArgToDBOptional(object: DBXFilesListFolderLongpollArg?) -> DBFILESListFolderLongpollArg? {
    guard let object = object else { return nil }
    return mapDBXFilesListFolderLongpollArgToDB(object: object)
}

func mapDBXFilesListFolderLongpollArgToDB(object: DBXFilesListFolderLongpollArg) -> DBFILESListFolderLongpollArg {
    DBFILESListFolderLongpollArg(cursor: object.cursor, timeout: object.timeout)
}

func mapDBXFilesListFolderLongpollErrorToDBOptional(object: DBXFilesListFolderLongpollError?) -> DBFILESListFolderLongpollError? {
    guard let object = object else { return nil }
    return mapDBXFilesListFolderLongpollErrorToDB(object: object)
}

func mapDBXFilesListFolderLongpollErrorToDB(object: DBXFilesListFolderLongpollError) -> DBFILESListFolderLongpollError {
    if object.asReset != nil {
        return DBFILESListFolderLongpollError(reset: ())
    }
    if object.asOther != nil {
        return DBFILESListFolderLongpollError(other: ())
    }
    fatalError("codegen error")
}

func mapDBXFilesListFolderLongpollResultToDBOptional(object: DBXFilesListFolderLongpollResult?) -> DBFILESListFolderLongpollResult? {
    guard let object = object else { return nil }
    return mapDBXFilesListFolderLongpollResultToDB(object: object)
}

func mapDBXFilesListFolderLongpollResultToDB(object: DBXFilesListFolderLongpollResult) -> DBFILESListFolderLongpollResult {
    DBFILESListFolderLongpollResult(changes: object.changes, backoff: object.backoff)
}

func mapDBXFilesListFolderResultToDBOptional(object: DBXFilesListFolderResult?) -> DBFILESListFolderResult? {
    guard let object = object else { return nil }
    return mapDBXFilesListFolderResultToDB(object: object)
}

func mapDBXFilesListFolderResultToDB(object: DBXFilesListFolderResult) -> DBFILESListFolderResult {
    DBFILESListFolderResult(entries: object.entries.compactMap { mapDBXFilesMetadataToDB(object: $0) }, cursor: object.cursor, hasMore: object.hasMore)
}

func mapDBXFilesListRevisionsArgToDBOptional(object: DBXFilesListRevisionsArg?) -> DBFILESListRevisionsArg? {
    guard let object = object else { return nil }
    return mapDBXFilesListRevisionsArgToDB(object: object)
}

func mapDBXFilesListRevisionsArgToDB(object: DBXFilesListRevisionsArg) -> DBFILESListRevisionsArg {
    DBFILESListRevisionsArg(path: object.path, mode: mapDBXFilesListRevisionsModeToDB(object: object.mode), limit: object.limit)
}

func mapDBXFilesListRevisionsErrorToDBOptional(object: DBXFilesListRevisionsError?) -> DBFILESListRevisionsError? {
    guard let object = object else { return nil }
    return mapDBXFilesListRevisionsErrorToDB(object: object)
}

func mapDBXFilesListRevisionsErrorToDB(object: DBXFilesListRevisionsError) -> DBFILESListRevisionsError {
    if let object = object.asPath {
        let path = mapDBXFilesLookupErrorToDB(object: object.path)
        return DBFILESListRevisionsError(path: path)
    }
    if object.asOther != nil {
        return DBFILESListRevisionsError(other: ())
    }
    fatalError("codegen error")
}

func mapDBXFilesListRevisionsModeToDBOptional(object: DBXFilesListRevisionsMode?) -> DBFILESListRevisionsMode? {
    guard let object = object else { return nil }
    return mapDBXFilesListRevisionsModeToDB(object: object)
}

func mapDBXFilesListRevisionsModeToDB(object: DBXFilesListRevisionsMode) -> DBFILESListRevisionsMode {
    if object.asPath != nil {
        return DBFILESListRevisionsMode(path: ())
    }
    if object.asId != nil {
        return DBFILESListRevisionsMode(id_: ())
    }
    if object.asOther != nil {
        return DBFILESListRevisionsMode(other: ())
    }
    fatalError("codegen error")
}

func mapDBXFilesListRevisionsResultToDBOptional(object: DBXFilesListRevisionsResult?) -> DBFILESListRevisionsResult? {
    guard let object = object else { return nil }
    return mapDBXFilesListRevisionsResultToDB(object: object)
}

func mapDBXFilesListRevisionsResultToDB(object: DBXFilesListRevisionsResult) -> DBFILESListRevisionsResult {
    DBFILESListRevisionsResult(
        isDeleted: object.isDeleted,
        entries: object.entries.compactMap { mapDBXFilesFileMetadataToDB(object: $0) },
        serverDeleted: object.serverDeleted
    )
}

func mapDBXFilesLockConflictErrorToDBOptional(object: DBXFilesLockConflictError?) -> DBFILESLockConflictError? {
    guard let object = object else { return nil }
    return mapDBXFilesLockConflictErrorToDB(object: object)
}

func mapDBXFilesLockConflictErrorToDB(object: DBXFilesLockConflictError) -> DBFILESLockConflictError {
    DBFILESLockConflictError(lock: mapDBXFilesFileLockToDB(object: object.lock))
}

func mapDBXFilesLockFileArgToDBOptional(object: DBXFilesLockFileArg?) -> DBFILESLockFileArg? {
    guard let object = object else { return nil }
    return mapDBXFilesLockFileArgToDB(object: object)
}

func mapDBXFilesLockFileArgToDB(object: DBXFilesLockFileArg) -> DBFILESLockFileArg {
    DBFILESLockFileArg(path: object.path)
}

func mapDBXFilesLockFileBatchArgToDBOptional(object: DBXFilesLockFileBatchArg?) -> DBFILESLockFileBatchArg? {
    guard let object = object else { return nil }
    return mapDBXFilesLockFileBatchArgToDB(object: object)
}

func mapDBXFilesLockFileBatchArgToDB(object: DBXFilesLockFileBatchArg) -> DBFILESLockFileBatchArg {
    DBFILESLockFileBatchArg(entries: object.entries.compactMap { mapDBXFilesLockFileArgToDB(object: $0) })
}

func mapDBXFilesLockFileBatchResultToDBOptional(object: DBXFilesLockFileBatchResult?) -> DBFILESLockFileBatchResult? {
    guard let object = object else { return nil }
    return mapDBXFilesLockFileBatchResultToDB(object: object)
}

func mapDBXFilesLockFileBatchResultToDB(object: DBXFilesLockFileBatchResult) -> DBFILESLockFileBatchResult {
    DBFILESLockFileBatchResult(entries: object.entries.compactMap { mapDBXFilesLockFileResultEntryToDB(object: $0) })
}

func mapDBXFilesLockFileErrorToDBOptional(object: DBXFilesLockFileError?) -> DBFILESLockFileError? {
    guard let object = object else { return nil }
    return mapDBXFilesLockFileErrorToDB(object: object)
}

func mapDBXFilesLockFileErrorToDB(object: DBXFilesLockFileError) -> DBFILESLockFileError {
    if let object = object.asPathLookup {
        let pathLookup = mapDBXFilesLookupErrorToDB(object: object.pathLookup)
        return DBFILESLockFileError(pathLookup: pathLookup)
    }
    if object.asTooManyWriteOperations != nil {
        return DBFILESLockFileError(tooManyWriteOperations: ())
    }
    if object.asTooManyFiles != nil {
        return DBFILESLockFileError(tooManyFiles: ())
    }
    if object.asNoWritePermission != nil {
        return DBFILESLockFileError(noWritePermission: ())
    }
    if object.asCannotBeLocked != nil {
        return DBFILESLockFileError(cannotBeLocked: ())
    }
    if object.asFileNotShared != nil {
        return DBFILESLockFileError(fileNotShared: ())
    }
    if let object = object.asLockConflict {
        let lockConflict = mapDBXFilesLockConflictErrorToDB(object: object.lockConflict)
        return DBFILESLockFileError(lockConflict: lockConflict)
    }
    if object.asInternalError != nil {
        return DBFILESLockFileError(internalError: ())
    }
    if object.asOther != nil {
        return DBFILESLockFileError(other: ())
    }
    fatalError("codegen error")
}

func mapDBXFilesLockFileResultToDBOptional(object: DBXFilesLockFileResult?) -> DBFILESLockFileResult? {
    guard let object = object else { return nil }
    return mapDBXFilesLockFileResultToDB(object: object)
}

func mapDBXFilesLockFileResultToDB(object: DBXFilesLockFileResult) -> DBFILESLockFileResult {
    DBFILESLockFileResult(metadata: mapDBXFilesMetadataToDB(object: object.metadata), lock: mapDBXFilesFileLockToDB(object: object.lock))
}

func mapDBXFilesLockFileResultEntryToDBOptional(object: DBXFilesLockFileResultEntry?) -> DBFILESLockFileResultEntry? {
    guard let object = object else { return nil }
    return mapDBXFilesLockFileResultEntryToDB(object: object)
}

func mapDBXFilesLockFileResultEntryToDB(object: DBXFilesLockFileResultEntry) -> DBFILESLockFileResultEntry {
    if let object = object.asSuccess {
        let success = mapDBXFilesLockFileResultToDB(object: object.success)
        return DBFILESLockFileResultEntry(success: success)
    }
    if let object = object.asFailure {
        let failure = mapDBXFilesLockFileErrorToDB(object: object.failure)
        return DBFILESLockFileResultEntry(failure: failure)
    }
    fatalError("codegen error")
}

func mapDBXFilesLookupErrorToDBOptional(object: DBXFilesLookupError?) -> DBFILESLookupError? {
    guard let object = object else { return nil }
    return mapDBXFilesLookupErrorToDB(object: object)
}

func mapDBXFilesLookupErrorToDB(object: DBXFilesLookupError) -> DBFILESLookupError {
    if let object = object.asMalformedPath {
        let malformedPath = object.malformedPath
        return DBFILESLookupError(malformedPath: malformedPath)
    }
    if object.asNotFound != nil {
        return DBFILESLookupError(notFound: ())
    }
    if object.asNotFile != nil {
        return DBFILESLookupError(notFile: ())
    }
    if object.asNotFolder != nil {
        return DBFILESLookupError(notFolder: ())
    }
    if object.asRestrictedContent != nil {
        return DBFILESLookupError(restrictedContent: ())
    }
    if object.asUnsupportedContentType != nil {
        return DBFILESLookupError(unsupportedContentType: ())
    }
    if object.asLocked != nil {
        return DBFILESLookupError(locked: ())
    }
    if object.asOther != nil {
        return DBFILESLookupError(other: ())
    }
    fatalError("codegen error")
}

func mapDBXFilesMediaInfoToDBOptional(object: DBXFilesMediaInfo?) -> DBFILESMediaInfo? {
    guard let object = object else { return nil }
    return mapDBXFilesMediaInfoToDB(object: object)
}

func mapDBXFilesMediaInfoToDB(object: DBXFilesMediaInfo) -> DBFILESMediaInfo {
    if object.asPending != nil {
        return DBFILESMediaInfo(pending: ())
    }
    if let object = object.asMetadata {
        let metadata = mapDBXFilesMediaMetadataToDB(object: object.metadata)
        return DBFILESMediaInfo(metadata: metadata)
    }
    fatalError("codegen error")
}

func mapDBXFilesMediaMetadataToDBOptional(object: DBXFilesMediaMetadata?) -> DBFILESMediaMetadata? {
    guard let object = object else { return nil }
    return mapDBXFilesMediaMetadataToDB(object: object)
}

func mapDBXFilesMediaMetadataToDB(object: DBXFilesMediaMetadata) -> DBFILESMediaMetadata {
    switch object {
    case let object as DBXFilesPhotoMetadata:
        return DBFILESPhotoMetadata(
            dimensions: mapDBXFilesDimensionsToDBOptional(object: object.dimensions),
            location: mapDBXFilesGpsCoordinatesToDBOptional(object: object.location),
            timeTaken: object.timeTaken
        )
    case let object as DBXFilesVideoMetadata:
        return DBFILESVideoMetadata(
            dimensions: mapDBXFilesDimensionsToDBOptional(object: object.dimensions),
            location: mapDBXFilesGpsCoordinatesToDBOptional(object: object.location),
            timeTaken: object.timeTaken,
            duration: object.duration
        )
    default:
        return DBFILESMediaMetadata(
            dimensions: mapDBXFilesDimensionsToDBOptional(object: object.dimensions),
            location: mapDBXFilesGpsCoordinatesToDBOptional(object: object.location),
            timeTaken: object.timeTaken
        )
    }
}

func mapDBXFilesMetadataV2ToDBOptional(object: DBXFilesMetadataV2?) -> DBFILESMetadataV2? {
    guard let object = object else { return nil }
    return mapDBXFilesMetadataV2ToDB(object: object)
}

func mapDBXFilesMetadataV2ToDB(object: DBXFilesMetadataV2) -> DBFILESMetadataV2 {
    if let object = object.asMetadata {
        let metadata = mapDBXFilesMetadataToDB(object: object.metadata)
        return DBFILESMetadataV2(metadata: metadata)
    }
    if object.asOther != nil {
        return DBFILESMetadataV2(other: ())
    }
    fatalError("codegen error")
}

func mapDBXFilesMinimalFileLinkMetadataToDBOptional(object: DBXFilesMinimalFileLinkMetadata?) -> DBFILESMinimalFileLinkMetadata? {
    guard let object = object else { return nil }
    return mapDBXFilesMinimalFileLinkMetadataToDB(object: object)
}

func mapDBXFilesMinimalFileLinkMetadataToDB(object: DBXFilesMinimalFileLinkMetadata) -> DBFILESMinimalFileLinkMetadata {
    DBFILESMinimalFileLinkMetadata(url: object.url, rev: object.rev, id_: object.id, path: object.path)
}

func mapDBXFilesRelocationBatchArgBaseToDBOptional(object: DBXFilesRelocationBatchArgBase?) -> DBFILESRelocationBatchArgBase? {
    guard let object = object else { return nil }
    return mapDBXFilesRelocationBatchArgBaseToDB(object: object)
}

func mapDBXFilesRelocationBatchArgBaseToDB(object: DBXFilesRelocationBatchArgBase) -> DBFILESRelocationBatchArgBase {
    DBFILESRelocationBatchArgBase(entries: object.entries.compactMap { mapDBXFilesRelocationPathToDB(object: $0) }, autorename: object.autorename)
}

func mapDBXFilesMoveBatchArgToDBOptional(object: DBXFilesMoveBatchArg?) -> DBFILESMoveBatchArg? {
    guard let object = object else { return nil }
    return mapDBXFilesMoveBatchArgToDB(object: object)
}

func mapDBXFilesMoveBatchArgToDB(object: DBXFilesMoveBatchArg) -> DBFILESMoveBatchArg {
    DBFILESMoveBatchArg(
        entries: object.entries.compactMap { mapDBXFilesRelocationPathToDB(object: $0) },
        autorename: object.autorename,
        allowOwnershipTransfer: object.allowOwnershipTransfer
    )
}

func mapDBXFilesMoveIntoFamilyErrorToDBOptional(object: DBXFilesMoveIntoFamilyError?) -> DBFILESMoveIntoFamilyError? {
    guard let object = object else { return nil }
    return mapDBXFilesMoveIntoFamilyErrorToDB(object: object)
}

func mapDBXFilesMoveIntoFamilyErrorToDB(object: DBXFilesMoveIntoFamilyError) -> DBFILESMoveIntoFamilyError {
    if object.asIsSharedFolder != nil {
        return DBFILESMoveIntoFamilyError(isSharedFolder: ())
    }
    if object.asOther != nil {
        return DBFILESMoveIntoFamilyError(other: ())
    }
    fatalError("codegen error")
}

func mapDBXFilesMoveIntoVaultErrorToDBOptional(object: DBXFilesMoveIntoVaultError?) -> DBFILESMoveIntoVaultError? {
    guard let object = object else { return nil }
    return mapDBXFilesMoveIntoVaultErrorToDB(object: object)
}

func mapDBXFilesMoveIntoVaultErrorToDB(object: DBXFilesMoveIntoVaultError) -> DBFILESMoveIntoVaultError {
    if object.asIsSharedFolder != nil {
        return DBFILESMoveIntoVaultError(isSharedFolder: ())
    }
    if object.asOther != nil {
        return DBFILESMoveIntoVaultError(other: ())
    }
    fatalError("codegen error")
}

func mapDBXFilesPaperContentErrorToDBOptional(object: DBXFilesPaperContentError?) -> DBFILESPaperContentError? {
    guard let object = object else { return nil }
    return mapDBXFilesPaperContentErrorToDB(object: object)
}

func mapDBXFilesPaperContentErrorToDB(object: DBXFilesPaperContentError) -> DBFILESPaperContentError {
    if object.asInsufficientPermissions != nil {
        return DBFILESPaperContentError(insufficientPermissions: ())
    }
    if object.asContentMalformed != nil {
        return DBFILESPaperContentError(contentMalformed: ())
    }
    if object.asDocLengthExceeded != nil {
        return DBFILESPaperContentError(docLengthExceeded: ())
    }
    if object.asImageSizeExceeded != nil {
        return DBFILESPaperContentError(imageSizeExceeded: ())
    }
    if object.asOther != nil {
        return DBFILESPaperContentError(other: ())
    }
    fatalError("codegen error")
}

func mapDBXFilesPaperCreateArgToDBOptional(object: DBXFilesPaperCreateArg?) -> DBFILESPaperCreateArg? {
    guard let object = object else { return nil }
    return mapDBXFilesPaperCreateArgToDB(object: object)
}

func mapDBXFilesPaperCreateArgToDB(object: DBXFilesPaperCreateArg) -> DBFILESPaperCreateArg {
    DBFILESPaperCreateArg(path: object.path, importFormat: mapDBXFilesImportFormatToDB(object: object.importFormat))
}

func mapDBXFilesPaperCreateErrorToDBOptional(object: DBXFilesPaperCreateError?) -> DBFILESPaperCreateError? {
    guard let object = object else { return nil }
    return mapDBXFilesPaperCreateErrorToDB(object: object)
}

func mapDBXFilesPaperCreateErrorToDB(object: DBXFilesPaperCreateError) -> DBFILESPaperCreateError {
    if object.asInsufficientPermissions != nil {
        return DBFILESPaperCreateError(insufficientPermissions: ())
    }
    if object.asContentMalformed != nil {
        return DBFILESPaperCreateError(contentMalformed: ())
    }
    if object.asDocLengthExceeded != nil {
        return DBFILESPaperCreateError(docLengthExceeded: ())
    }
    if object.asImageSizeExceeded != nil {
        return DBFILESPaperCreateError(imageSizeExceeded: ())
    }
    if object.asOther != nil {
        return DBFILESPaperCreateError(other: ())
    }
    if object.asInvalidPath != nil {
        return DBFILESPaperCreateError(invalidPath: ())
    }
    if object.asEmailUnverified != nil {
        return DBFILESPaperCreateError(emailUnverified: ())
    }
    if object.asInvalidFileExtension != nil {
        return DBFILESPaperCreateError(invalidFileExtension: ())
    }
    if object.asPaperDisabled != nil {
        return DBFILESPaperCreateError(paperDisabled: ())
    }
    fatalError("codegen error")
}

func mapDBXFilesPaperCreateResultToDBOptional(object: DBXFilesPaperCreateResult?) -> DBFILESPaperCreateResult? {
    guard let object = object else { return nil }
    return mapDBXFilesPaperCreateResultToDB(object: object)
}

func mapDBXFilesPaperCreateResultToDB(object: DBXFilesPaperCreateResult) -> DBFILESPaperCreateResult {
    DBFILESPaperCreateResult(url: object.url, resultPath: object.resultPath, fileId: object.fileId, paperRevision: object.paperRevision)
}

func mapDBXFilesPaperDocUpdatePolicyToDBOptional(object: DBXFilesPaperDocUpdatePolicy?) -> DBFILESPaperDocUpdatePolicy? {
    guard let object = object else { return nil }
    return mapDBXFilesPaperDocUpdatePolicyToDB(object: object)
}

func mapDBXFilesPaperDocUpdatePolicyToDB(object: DBXFilesPaperDocUpdatePolicy) -> DBFILESPaperDocUpdatePolicy {
    if object.asUpdate != nil {
        return DBFILESPaperDocUpdatePolicy(update: ())
    }
    if object.asOverwrite != nil {
        return DBFILESPaperDocUpdatePolicy(overwrite: ())
    }
    if object.asPrepend != nil {
        return DBFILESPaperDocUpdatePolicy(prepend: ())
    }
    if object.asAppend != nil {
        return DBFILESPaperDocUpdatePolicy(append: ())
    }
    if object.asOther != nil {
        return DBFILESPaperDocUpdatePolicy(other: ())
    }
    fatalError("codegen error")
}

func mapDBXFilesPaperUpdateArgToDBOptional(object: DBXFilesPaperUpdateArg?) -> DBFILESPaperUpdateArg? {
    guard let object = object else { return nil }
    return mapDBXFilesPaperUpdateArgToDB(object: object)
}

func mapDBXFilesPaperUpdateArgToDB(object: DBXFilesPaperUpdateArg) -> DBFILESPaperUpdateArg {
    DBFILESPaperUpdateArg(
        path: object.path,
        importFormat: mapDBXFilesImportFormatToDB(object: object.importFormat),
        docUpdatePolicy: mapDBXFilesPaperDocUpdatePolicyToDB(object: object.docUpdatePolicy),
        paperRevision: object.paperRevision
    )
}

func mapDBXFilesPaperUpdateErrorToDBOptional(object: DBXFilesPaperUpdateError?) -> DBFILESPaperUpdateError? {
    guard let object = object else { return nil }
    return mapDBXFilesPaperUpdateErrorToDB(object: object)
}

func mapDBXFilesPaperUpdateErrorToDB(object: DBXFilesPaperUpdateError) -> DBFILESPaperUpdateError {
    if object.asInsufficientPermissions != nil {
        return DBFILESPaperUpdateError(insufficientPermissions: ())
    }
    if object.asContentMalformed != nil {
        return DBFILESPaperUpdateError(contentMalformed: ())
    }
    if object.asDocLengthExceeded != nil {
        return DBFILESPaperUpdateError(docLengthExceeded: ())
    }
    if object.asImageSizeExceeded != nil {
        return DBFILESPaperUpdateError(imageSizeExceeded: ())
    }
    if object.asOther != nil {
        return DBFILESPaperUpdateError(other: ())
    }
    if let object = object.asPath {
        let path = mapDBXFilesLookupErrorToDB(object: object.path)
        return DBFILESPaperUpdateError(path: path)
    }
    if object.asRevisionMismatch != nil {
        return DBFILESPaperUpdateError(revisionMismatch: ())
    }
    if object.asDocArchived != nil {
        return DBFILESPaperUpdateError(docArchived: ())
    }
    if object.asDocDeleted != nil {
        return DBFILESPaperUpdateError(docDeleted: ())
    }
    fatalError("codegen error")
}

func mapDBXFilesPaperUpdateResultToDBOptional(object: DBXFilesPaperUpdateResult?) -> DBFILESPaperUpdateResult? {
    guard let object = object else { return nil }
    return mapDBXFilesPaperUpdateResultToDB(object: object)
}

func mapDBXFilesPaperUpdateResultToDB(object: DBXFilesPaperUpdateResult) -> DBFILESPaperUpdateResult {
    DBFILESPaperUpdateResult(paperRevision: object.paperRevision)
}

func mapDBXFilesPathOrLinkToDBOptional(object: DBXFilesPathOrLink?) -> DBFILESPathOrLink? {
    guard let object = object else { return nil }
    return mapDBXFilesPathOrLinkToDB(object: object)
}

func mapDBXFilesPathOrLinkToDB(object: DBXFilesPathOrLink) -> DBFILESPathOrLink {
    if let object = object.asPath {
        let path = object.path
        return DBFILESPathOrLink(path: path)
    }
    if let object = object.asLink {
        let link = mapDBXFilesSharedLinkFileInfoToDB(object: object.link)
        return DBFILESPathOrLink(link: link)
    }
    if object.asOther != nil {
        return DBFILESPathOrLink(other: ())
    }
    fatalError("codegen error")
}

func mapDBXFilesPathToTagsToDBOptional(object: DBXFilesPathToTags?) -> DBFILESPathToTags? {
    guard let object = object else { return nil }
    return mapDBXFilesPathToTagsToDB(object: object)
}

func mapDBXFilesPathToTagsToDB(object: DBXFilesPathToTags) -> DBFILESPathToTags {
    DBFILESPathToTags(path: object.path, tags: object.tags.compactMap { mapDBXFilesTagToDB(object: $0) })
}

func mapDBXFilesPhotoMetadataToDBOptional(object: DBXFilesPhotoMetadata?) -> DBFILESPhotoMetadata? {
    guard let object = object else { return nil }
    return mapDBXFilesPhotoMetadataToDB(object: object)
}

func mapDBXFilesPhotoMetadataToDB(object: DBXFilesPhotoMetadata) -> DBFILESPhotoMetadata {
    DBFILESPhotoMetadata(
        dimensions: mapDBXFilesDimensionsToDBOptional(object: object.dimensions),
        location: mapDBXFilesGpsCoordinatesToDBOptional(object: object.location),
        timeTaken: object.timeTaken
    )
}

func mapDBXFilesPreviewArgToDBOptional(object: DBXFilesPreviewArg?) -> DBFILESPreviewArg? {
    guard let object = object else { return nil }
    return mapDBXFilesPreviewArgToDB(object: object)
}

func mapDBXFilesPreviewArgToDB(object: DBXFilesPreviewArg) -> DBFILESPreviewArg {
    DBFILESPreviewArg(path: object.path, rev: object.rev)
}

func mapDBXFilesPreviewErrorToDBOptional(object: DBXFilesPreviewError?) -> DBFILESPreviewError? {
    guard let object = object else { return nil }
    return mapDBXFilesPreviewErrorToDB(object: object)
}

func mapDBXFilesPreviewErrorToDB(object: DBXFilesPreviewError) -> DBFILESPreviewError {
    if let object = object.asPath {
        let path = mapDBXFilesLookupErrorToDB(object: object.path)
        return DBFILESPreviewError(path: path)
    }
    if object.asInProgress != nil {
        return DBFILESPreviewError(inProgress: ())
    }
    if object.asUnsupportedExtension != nil {
        return DBFILESPreviewError(unsupportedExtension: ())
    }
    if object.asUnsupportedContent != nil {
        return DBFILESPreviewError(unsupportedContent: ())
    }
    fatalError("codegen error")
}

func mapDBXFilesPreviewResultToDBOptional(object: DBXFilesPreviewResult?) -> DBFILESPreviewResult? {
    guard let object = object else { return nil }
    return mapDBXFilesPreviewResultToDB(object: object)
}

func mapDBXFilesPreviewResultToDB(object: DBXFilesPreviewResult) -> DBFILESPreviewResult {
    DBFILESPreviewResult(
        fileMetadata: mapDBXFilesFileMetadataToDBOptional(object: object.fileMetadata),
        linkMetadata: mapDBXFilesMinimalFileLinkMetadataToDBOptional(object: object.linkMetadata)
    )
}

func mapDBXFilesRelocationPathToDBOptional(object: DBXFilesRelocationPath?) -> DBFILESRelocationPath? {
    guard let object = object else { return nil }
    return mapDBXFilesRelocationPathToDB(object: object)
}

func mapDBXFilesRelocationPathToDB(object: DBXFilesRelocationPath) -> DBFILESRelocationPath {
    DBFILESRelocationPath(fromPath: object.fromPath, toPath: object.toPath)
}

func mapDBXFilesRelocationArgToDBOptional(object: DBXFilesRelocationArg?) -> DBFILESRelocationArg? {
    guard let object = object else { return nil }
    return mapDBXFilesRelocationArgToDB(object: object)
}

func mapDBXFilesRelocationArgToDB(object: DBXFilesRelocationArg) -> DBFILESRelocationArg {
    DBFILESRelocationArg(
        fromPath: object.fromPath,
        toPath: object.toPath,
        allowSharedFolder: object.allowSharedFolder,
        autorename: object.autorename,
        allowOwnershipTransfer: object.allowOwnershipTransfer
    )
}

func mapDBXFilesRelocationBatchArgToDBOptional(object: DBXFilesRelocationBatchArg?) -> DBFILESRelocationBatchArg? {
    guard let object = object else { return nil }
    return mapDBXFilesRelocationBatchArgToDB(object: object)
}

func mapDBXFilesRelocationBatchArgToDB(object: DBXFilesRelocationBatchArg) -> DBFILESRelocationBatchArg {
    DBFILESRelocationBatchArg(
        entries: object.entries.compactMap { mapDBXFilesRelocationPathToDB(object: $0) },
        autorename: object.autorename,
        allowSharedFolder: object.allowSharedFolder,
        allowOwnershipTransfer: object.allowOwnershipTransfer
    )
}

func mapDBXFilesRelocationErrorToDBOptional(object: DBXFilesRelocationError?) -> DBFILESRelocationError? {
    guard let object = object else { return nil }
    return mapDBXFilesRelocationErrorToDB(object: object)
}

func mapDBXFilesRelocationErrorToDB(object: DBXFilesRelocationError) -> DBFILESRelocationError {
    if let object = object.asFromLookup {
        let fromLookup = mapDBXFilesLookupErrorToDB(object: object.fromLookup)
        return DBFILESRelocationError(fromLookup: fromLookup)
    }
    if let object = object.asFromWrite {
        let fromWrite = mapDBXFilesWriteErrorToDB(object: object.fromWrite)
        return DBFILESRelocationError(fromWrite: fromWrite)
    }
    if let object = object.asTo {
        let to = mapDBXFilesWriteErrorToDB(object: object.to)
        return DBFILESRelocationError(to: to)
    }
    if object.asCantCopySharedFolder != nil {
        return DBFILESRelocationError(cantCopySharedFolder: ())
    }
    if object.asCantNestSharedFolder != nil {
        return DBFILESRelocationError(cantNestSharedFolder: ())
    }
    if object.asCantMoveFolderIntoItself != nil {
        return DBFILESRelocationError(cantMoveFolderIntoItself: ())
    }
    if object.asTooManyFiles != nil {
        return DBFILESRelocationError(tooManyFiles: ())
    }
    if object.asDuplicatedOrNestedPaths != nil {
        return DBFILESRelocationError(duplicatedOrNestedPaths: ())
    }
    if object.asCantTransferOwnership != nil {
        return DBFILESRelocationError(cantTransferOwnership: ())
    }
    if object.asInsufficientQuota != nil {
        return DBFILESRelocationError(insufficientQuota: ())
    }
    if object.asInternalError != nil {
        return DBFILESRelocationError(internalError: ())
    }
    if object.asCantMoveSharedFolder != nil {
        return DBFILESRelocationError(cantMoveSharedFolder: ())
    }
    if let object = object.asCantMoveIntoVault {
        let cantMoveIntoVault = mapDBXFilesMoveIntoVaultErrorToDB(object: object.cantMoveIntoVault)
        return DBFILESRelocationError(cantMoveIntoVault: cantMoveIntoVault)
    }
    if let object = object.asCantMoveIntoFamily {
        let cantMoveIntoFamily = mapDBXFilesMoveIntoFamilyErrorToDB(object: object.cantMoveIntoFamily)
        return DBFILESRelocationError(cantMoveIntoFamily: cantMoveIntoFamily)
    }
    if object.asOther != nil {
        return DBFILESRelocationError(other: ())
    }
    fatalError("codegen error")
}

func mapDBXFilesRelocationBatchErrorToDBOptional(object: DBXFilesRelocationBatchError?) -> DBFILESRelocationBatchError? {
    guard let object = object else { return nil }
    return mapDBXFilesRelocationBatchErrorToDB(object: object)
}

func mapDBXFilesRelocationBatchErrorToDB(object: DBXFilesRelocationBatchError) -> DBFILESRelocationBatchError {
    if let object = object.asFromLookup {
        let fromLookup = mapDBXFilesLookupErrorToDB(object: object.fromLookup)
        return DBFILESRelocationBatchError(fromLookup: fromLookup)
    }
    if let object = object.asFromWrite {
        let fromWrite = mapDBXFilesWriteErrorToDB(object: object.fromWrite)
        return DBFILESRelocationBatchError(fromWrite: fromWrite)
    }
    if let object = object.asTo {
        let to = mapDBXFilesWriteErrorToDB(object: object.to)
        return DBFILESRelocationBatchError(to: to)
    }
    if object.asCantCopySharedFolder != nil {
        return DBFILESRelocationBatchError(cantCopySharedFolder: ())
    }
    if object.asCantNestSharedFolder != nil {
        return DBFILESRelocationBatchError(cantNestSharedFolder: ())
    }
    if object.asCantMoveFolderIntoItself != nil {
        return DBFILESRelocationBatchError(cantMoveFolderIntoItself: ())
    }
    if object.asTooManyFiles != nil {
        return DBFILESRelocationBatchError(tooManyFiles: ())
    }
    if object.asDuplicatedOrNestedPaths != nil {
        return DBFILESRelocationBatchError(duplicatedOrNestedPaths: ())
    }
    if object.asCantTransferOwnership != nil {
        return DBFILESRelocationBatchError(cantTransferOwnership: ())
    }
    if object.asInsufficientQuota != nil {
        return DBFILESRelocationBatchError(insufficientQuota: ())
    }
    if object.asInternalError != nil {
        return DBFILESRelocationBatchError(internalError: ())
    }
    if object.asCantMoveSharedFolder != nil {
        return DBFILESRelocationBatchError(cantMoveSharedFolder: ())
    }
    if let object = object.asCantMoveIntoVault {
        let cantMoveIntoVault = mapDBXFilesMoveIntoVaultErrorToDB(object: object.cantMoveIntoVault)
        return DBFILESRelocationBatchError(cantMoveIntoVault: cantMoveIntoVault)
    }
    if let object = object.asCantMoveIntoFamily {
        let cantMoveIntoFamily = mapDBXFilesMoveIntoFamilyErrorToDB(object: object.cantMoveIntoFamily)
        return DBFILESRelocationBatchError(cantMoveIntoFamily: cantMoveIntoFamily)
    }
    if object.asOther != nil {
        return DBFILESRelocationBatchError(other: ())
    }
    if object.asTooManyWriteOperations != nil {
        return DBFILESRelocationBatchError(tooManyWriteOperations: ())
    }
    fatalError("codegen error")
}

func mapDBXFilesRelocationBatchErrorEntryToDBOptional(object: DBXFilesRelocationBatchErrorEntry?) -> DBFILESRelocationBatchErrorEntry? {
    guard let object = object else { return nil }
    return mapDBXFilesRelocationBatchErrorEntryToDB(object: object)
}

func mapDBXFilesRelocationBatchErrorEntryToDB(object: DBXFilesRelocationBatchErrorEntry) -> DBFILESRelocationBatchErrorEntry {
    if let object = object.asRelocationError {
        let relocationError = mapDBXFilesRelocationErrorToDB(object: object.relocationError)
        return DBFILESRelocationBatchErrorEntry(relocationError: relocationError)
    }
    if object.asInternalError != nil {
        return DBFILESRelocationBatchErrorEntry(internalError: ())
    }
    if object.asTooManyWriteOperations != nil {
        return DBFILESRelocationBatchErrorEntry(tooManyWriteOperations: ())
    }
    if object.asOther != nil {
        return DBFILESRelocationBatchErrorEntry(other: ())
    }
    fatalError("codegen error")
}

func mapDBXFilesRelocationBatchJobStatusToDBOptional(object: DBXFilesRelocationBatchJobStatus?) -> DBFILESRelocationBatchJobStatus? {
    guard let object = object else { return nil }
    return mapDBXFilesRelocationBatchJobStatusToDB(object: object)
}

func mapDBXFilesRelocationBatchJobStatusToDB(object: DBXFilesRelocationBatchJobStatus) -> DBFILESRelocationBatchJobStatus {
    if object.asInProgress != nil {
        return DBFILESRelocationBatchJobStatus(inProgress: ())
    }
    if let object = object.asComplete {
        let complete = mapDBXFilesRelocationBatchResultToDB(object: object.complete)
        return DBFILESRelocationBatchJobStatus(complete: complete)
    }
    if let object = object.asFailed {
        let failed = mapDBXFilesRelocationBatchErrorToDB(object: object.failed)
        return DBFILESRelocationBatchJobStatus(failed: failed)
    }
    fatalError("codegen error")
}

func mapDBXFilesRelocationBatchLaunchToDBOptional(object: DBXFilesRelocationBatchLaunch?) -> DBFILESRelocationBatchLaunch? {
    guard let object = object else { return nil }
    return mapDBXFilesRelocationBatchLaunchToDB(object: object)
}

func mapDBXFilesRelocationBatchLaunchToDB(object: DBXFilesRelocationBatchLaunch) -> DBFILESRelocationBatchLaunch {
    if let object = object.asAsyncJobId {
        let asyncJobId = object.asyncJobId
        return DBFILESRelocationBatchLaunch(asyncJobId: asyncJobId)
    }
    if let object = object.asComplete {
        let complete = mapDBXFilesRelocationBatchResultToDB(object: object.complete)
        return DBFILESRelocationBatchLaunch(complete: complete)
    }
    if object.asOther != nil {
        return DBFILESRelocationBatchLaunch(other: ())
    }
    fatalError("codegen error")
}

func mapDBXFilesRelocationBatchResultToDBOptional(object: DBXFilesRelocationBatchResult?) -> DBFILESRelocationBatchResult? {
    guard let object = object else { return nil }
    return mapDBXFilesRelocationBatchResultToDB(object: object)
}

func mapDBXFilesRelocationBatchResultToDB(object: DBXFilesRelocationBatchResult) -> DBFILESRelocationBatchResult {
    DBFILESRelocationBatchResult(entries: object.entries.compactMap { mapDBXFilesRelocationBatchResultDataToDB(object: $0) })
}

func mapDBXFilesRelocationBatchResultDataToDBOptional(object: DBXFilesRelocationBatchResultData?) -> DBFILESRelocationBatchResultData? {
    guard let object = object else { return nil }
    return mapDBXFilesRelocationBatchResultDataToDB(object: object)
}

func mapDBXFilesRelocationBatchResultDataToDB(object: DBXFilesRelocationBatchResultData) -> DBFILESRelocationBatchResultData {
    DBFILESRelocationBatchResultData(metadata: mapDBXFilesMetadataToDB(object: object.metadata))
}

func mapDBXFilesRelocationBatchResultEntryToDBOptional(object: DBXFilesRelocationBatchResultEntry?) -> DBFILESRelocationBatchResultEntry? {
    guard let object = object else { return nil }
    return mapDBXFilesRelocationBatchResultEntryToDB(object: object)
}

func mapDBXFilesRelocationBatchResultEntryToDB(object: DBXFilesRelocationBatchResultEntry) -> DBFILESRelocationBatchResultEntry {
    if let object = object.asSuccess {
        let success = mapDBXFilesMetadataToDB(object: object.success)
        return DBFILESRelocationBatchResultEntry(success: success)
    }
    if let object = object.asFailure {
        let failure = mapDBXFilesRelocationBatchErrorEntryToDB(object: object.failure)
        return DBFILESRelocationBatchResultEntry(failure: failure)
    }
    if object.asOther != nil {
        return DBFILESRelocationBatchResultEntry(other: ())
    }
    fatalError("codegen error")
}

func mapDBXFilesRelocationBatchV2JobStatusToDBOptional(object: DBXFilesRelocationBatchV2JobStatus?) -> DBFILESRelocationBatchV2JobStatus? {
    guard let object = object else { return nil }
    return mapDBXFilesRelocationBatchV2JobStatusToDB(object: object)
}

func mapDBXFilesRelocationBatchV2JobStatusToDB(object: DBXFilesRelocationBatchV2JobStatus) -> DBFILESRelocationBatchV2JobStatus {
    if object.asInProgress != nil {
        return DBFILESRelocationBatchV2JobStatus(inProgress: ())
    }
    if let object = object.asComplete {
        let complete = mapDBXFilesRelocationBatchV2ResultToDB(object: object.complete)
        return DBFILESRelocationBatchV2JobStatus(complete: complete)
    }
    fatalError("codegen error")
}

func mapDBXFilesRelocationBatchV2LaunchToDBOptional(object: DBXFilesRelocationBatchV2Launch?) -> DBFILESRelocationBatchV2Launch? {
    guard let object = object else { return nil }
    return mapDBXFilesRelocationBatchV2LaunchToDB(object: object)
}

func mapDBXFilesRelocationBatchV2LaunchToDB(object: DBXFilesRelocationBatchV2Launch) -> DBFILESRelocationBatchV2Launch {
    if let object = object.asAsyncJobId {
        let asyncJobId = object.asyncJobId
        return DBFILESRelocationBatchV2Launch(asyncJobId: asyncJobId)
    }
    if let object = object.asComplete {
        let complete = mapDBXFilesRelocationBatchV2ResultToDB(object: object.complete)
        return DBFILESRelocationBatchV2Launch(complete: complete)
    }
    fatalError("codegen error")
}

func mapDBXFilesRelocationBatchV2ResultToDBOptional(object: DBXFilesRelocationBatchV2Result?) -> DBFILESRelocationBatchV2Result? {
    guard let object = object else { return nil }
    return mapDBXFilesRelocationBatchV2ResultToDB(object: object)
}

func mapDBXFilesRelocationBatchV2ResultToDB(object: DBXFilesRelocationBatchV2Result) -> DBFILESRelocationBatchV2Result {
    DBFILESRelocationBatchV2Result(entries: object.entries.compactMap { mapDBXFilesRelocationBatchResultEntryToDB(object: $0) })
}

func mapDBXFilesRelocationResultToDBOptional(object: DBXFilesRelocationResult?) -> DBFILESRelocationResult? {
    guard let object = object else { return nil }
    return mapDBXFilesRelocationResultToDB(object: object)
}

func mapDBXFilesRelocationResultToDB(object: DBXFilesRelocationResult) -> DBFILESRelocationResult {
    DBFILESRelocationResult(metadata: mapDBXFilesMetadataToDB(object: object.metadata))
}

func mapDBXFilesRemoveTagArgToDBOptional(object: DBXFilesRemoveTagArg?) -> DBFILESRemoveTagArg? {
    guard let object = object else { return nil }
    return mapDBXFilesRemoveTagArgToDB(object: object)
}

func mapDBXFilesRemoveTagArgToDB(object: DBXFilesRemoveTagArg) -> DBFILESRemoveTagArg {
    DBFILESRemoveTagArg(path: object.path, tagText: object.tagText)
}

func mapDBXFilesRemoveTagErrorToDBOptional(object: DBXFilesRemoveTagError?) -> DBFILESRemoveTagError? {
    guard let object = object else { return nil }
    return mapDBXFilesRemoveTagErrorToDB(object: object)
}

func mapDBXFilesRemoveTagErrorToDB(object: DBXFilesRemoveTagError) -> DBFILESRemoveTagError {
    if let object = object.asPath {
        let path = mapDBXFilesLookupErrorToDB(object: object.path)
        return DBFILESRemoveTagError(path: path)
    }
    if object.asOther != nil {
        return DBFILESRemoveTagError(other: ())
    }
    if object.asTagNotPresent != nil {
        return DBFILESRemoveTagError(tagNotPresent: ())
    }
    fatalError("codegen error")
}

func mapDBXFilesRestoreArgToDBOptional(object: DBXFilesRestoreArg?) -> DBFILESRestoreArg? {
    guard let object = object else { return nil }
    return mapDBXFilesRestoreArgToDB(object: object)
}

func mapDBXFilesRestoreArgToDB(object: DBXFilesRestoreArg) -> DBFILESRestoreArg {
    DBFILESRestoreArg(path: object.path, rev: object.rev)
}

func mapDBXFilesRestoreErrorToDBOptional(object: DBXFilesRestoreError?) -> DBFILESRestoreError? {
    guard let object = object else { return nil }
    return mapDBXFilesRestoreErrorToDB(object: object)
}

func mapDBXFilesRestoreErrorToDB(object: DBXFilesRestoreError) -> DBFILESRestoreError {
    if let object = object.asPathLookup {
        let pathLookup = mapDBXFilesLookupErrorToDB(object: object.pathLookup)
        return DBFILESRestoreError(pathLookup: pathLookup)
    }
    if let object = object.asPathWrite {
        let pathWrite = mapDBXFilesWriteErrorToDB(object: object.pathWrite)
        return DBFILESRestoreError(pathWrite: pathWrite)
    }
    if object.asInvalidRevision != nil {
        return DBFILESRestoreError(invalidRevision: ())
    }
    if object.asInProgress != nil {
        return DBFILESRestoreError(inProgress: ())
    }
    if object.asOther != nil {
        return DBFILESRestoreError(other: ())
    }
    fatalError("codegen error")
}

func mapDBXFilesSaveCopyReferenceArgToDBOptional(object: DBXFilesSaveCopyReferenceArg?) -> DBFILESSaveCopyReferenceArg? {
    guard let object = object else { return nil }
    return mapDBXFilesSaveCopyReferenceArgToDB(object: object)
}

func mapDBXFilesSaveCopyReferenceArgToDB(object: DBXFilesSaveCopyReferenceArg) -> DBFILESSaveCopyReferenceArg {
    DBFILESSaveCopyReferenceArg(dCopyReference: object.copyReference, path: object.path)
}

func mapDBXFilesSaveCopyReferenceErrorToDBOptional(object: DBXFilesSaveCopyReferenceError?) -> DBFILESSaveCopyReferenceError? {
    guard let object = object else { return nil }
    return mapDBXFilesSaveCopyReferenceErrorToDB(object: object)
}

func mapDBXFilesSaveCopyReferenceErrorToDB(object: DBXFilesSaveCopyReferenceError) -> DBFILESSaveCopyReferenceError {
    if let object = object.asPath {
        let path = mapDBXFilesWriteErrorToDB(object: object.path)
        return DBFILESSaveCopyReferenceError(path: path)
    }
    if object.asInvalidCopyReference != nil {
        return DBFILESSaveCopyReferenceError(invalidCopyReference: ())
    }
    if object.asNoPermission != nil {
        return DBFILESSaveCopyReferenceError(noPermission: ())
    }
    if object.asNotFound != nil {
        return DBFILESSaveCopyReferenceError(notFound: ())
    }
    if object.asTooManyFiles != nil {
        return DBFILESSaveCopyReferenceError(tooManyFiles: ())
    }
    if object.asOther != nil {
        return DBFILESSaveCopyReferenceError(other: ())
    }
    fatalError("codegen error")
}

func mapDBXFilesSaveCopyReferenceResultToDBOptional(object: DBXFilesSaveCopyReferenceResult?) -> DBFILESSaveCopyReferenceResult? {
    guard let object = object else { return nil }
    return mapDBXFilesSaveCopyReferenceResultToDB(object: object)
}

func mapDBXFilesSaveCopyReferenceResultToDB(object: DBXFilesSaveCopyReferenceResult) -> DBFILESSaveCopyReferenceResult {
    DBFILESSaveCopyReferenceResult(metadata: mapDBXFilesMetadataToDB(object: object.metadata))
}

func mapDBXFilesSaveUrlArgToDBOptional(object: DBXFilesSaveUrlArg?) -> DBFILESSaveUrlArg? {
    guard let object = object else { return nil }
    return mapDBXFilesSaveUrlArgToDB(object: object)
}

func mapDBXFilesSaveUrlArgToDB(object: DBXFilesSaveUrlArg) -> DBFILESSaveUrlArg {
    DBFILESSaveUrlArg(path: object.path, url: object.url)
}

func mapDBXFilesSaveUrlErrorToDBOptional(object: DBXFilesSaveUrlError?) -> DBFILESSaveUrlError? {
    guard let object = object else { return nil }
    return mapDBXFilesSaveUrlErrorToDB(object: object)
}

func mapDBXFilesSaveUrlErrorToDB(object: DBXFilesSaveUrlError) -> DBFILESSaveUrlError {
    if let object = object.asPath {
        let path = mapDBXFilesWriteErrorToDB(object: object.path)
        return DBFILESSaveUrlError(path: path)
    }
    if object.asDownloadFailed != nil {
        return DBFILESSaveUrlError(downloadFailed: ())
    }
    if object.asInvalidUrl != nil {
        return DBFILESSaveUrlError(invalidUrl: ())
    }
    if object.asNotFound != nil {
        return DBFILESSaveUrlError(notFound: ())
    }
    if object.asOther != nil {
        return DBFILESSaveUrlError(other: ())
    }
    fatalError("codegen error")
}

func mapDBXFilesSaveUrlJobStatusToDBOptional(object: DBXFilesSaveUrlJobStatus?) -> DBFILESSaveUrlJobStatus? {
    guard let object = object else { return nil }
    return mapDBXFilesSaveUrlJobStatusToDB(object: object)
}

func mapDBXFilesSaveUrlJobStatusToDB(object: DBXFilesSaveUrlJobStatus) -> DBFILESSaveUrlJobStatus {
    if object.asInProgress != nil {
        return DBFILESSaveUrlJobStatus(inProgress: ())
    }
    if let object = object.asComplete {
        let complete = mapDBXFilesFileMetadataToDB(object: object.complete)
        return DBFILESSaveUrlJobStatus(complete: complete)
    }
    if let object = object.asFailed {
        let failed = mapDBXFilesSaveUrlErrorToDB(object: object.failed)
        return DBFILESSaveUrlJobStatus(failed: failed)
    }
    fatalError("codegen error")
}

func mapDBXFilesSaveUrlResultToDBOptional(object: DBXFilesSaveUrlResult?) -> DBFILESSaveUrlResult? {
    guard let object = object else { return nil }
    return mapDBXFilesSaveUrlResultToDB(object: object)
}

func mapDBXFilesSaveUrlResultToDB(object: DBXFilesSaveUrlResult) -> DBFILESSaveUrlResult {
    if let object = object.asAsyncJobId {
        let asyncJobId = object.asyncJobId
        return DBFILESSaveUrlResult(asyncJobId: asyncJobId)
    }
    if let object = object.asComplete {
        let complete = mapDBXFilesFileMetadataToDB(object: object.complete)
        return DBFILESSaveUrlResult(complete: complete)
    }
    fatalError("codegen error")
}

func mapDBXFilesSearchArgToDBOptional(object: DBXFilesSearchArg?) -> DBFILESSearchArg? {
    guard let object = object else { return nil }
    return mapDBXFilesSearchArgToDB(object: object)
}

func mapDBXFilesSearchArgToDB(object: DBXFilesSearchArg) -> DBFILESSearchArg {
    DBFILESSearchArg(
        path: object.path,
        query: object.query,
        start: object.start,
        maxResults: object.maxResults,
        mode: mapDBXFilesSearchModeToDB(object: object.mode)
    )
}

func mapDBXFilesSearchErrorToDBOptional(object: DBXFilesSearchError?) -> DBFILESSearchError? {
    guard let object = object else { return nil }
    return mapDBXFilesSearchErrorToDB(object: object)
}

func mapDBXFilesSearchErrorToDB(object: DBXFilesSearchError) -> DBFILESSearchError {
    if let object = object.asPath {
        let path = mapDBXFilesLookupErrorToDB(object: object.path)
        return DBFILESSearchError(path: path)
    }
    if let object = object.asInvalidArgument {
        let invalidArgument = object.invalidArgument
        return DBFILESSearchError(invalidArgument: invalidArgument)
    }
    if object.asInternalError != nil {
        return DBFILESSearchError(internalError: ())
    }
    if object.asOther != nil {
        return DBFILESSearchError(other: ())
    }
    fatalError("codegen error")
}

func mapDBXFilesSearchMatchToDBOptional(object: DBXFilesSearchMatch?) -> DBFILESSearchMatch? {
    guard let object = object else { return nil }
    return mapDBXFilesSearchMatchToDB(object: object)
}

func mapDBXFilesSearchMatchToDB(object: DBXFilesSearchMatch) -> DBFILESSearchMatch {
    DBFILESSearchMatch(matchType: mapDBXFilesSearchMatchTypeToDB(object: object.matchType), metadata: mapDBXFilesMetadataToDB(object: object.metadata))
}

func mapDBXFilesSearchMatchFieldOptionsToDBOptional(object: DBXFilesSearchMatchFieldOptions?) -> DBFILESSearchMatchFieldOptions? {
    guard let object = object else { return nil }
    return mapDBXFilesSearchMatchFieldOptionsToDB(object: object)
}

func mapDBXFilesSearchMatchFieldOptionsToDB(object: DBXFilesSearchMatchFieldOptions) -> DBFILESSearchMatchFieldOptions {
    DBFILESSearchMatchFieldOptions(includeHighlights: object.includeHighlights)
}

func mapDBXFilesSearchMatchTypeToDBOptional(object: DBXFilesSearchMatchType?) -> DBFILESSearchMatchType? {
    guard let object = object else { return nil }
    return mapDBXFilesSearchMatchTypeToDB(object: object)
}

func mapDBXFilesSearchMatchTypeToDB(object: DBXFilesSearchMatchType) -> DBFILESSearchMatchType {
    if object.asFilename != nil {
        return DBFILESSearchMatchType(filename: ())
    }
    if object.asContent != nil {
        return DBFILESSearchMatchType(content: ())
    }
    if object.asBoth != nil {
        return DBFILESSearchMatchType(both: ())
    }
    fatalError("codegen error")
}

func mapDBXFilesSearchMatchTypeV2ToDBOptional(object: DBXFilesSearchMatchTypeV2?) -> DBFILESSearchMatchTypeV2? {
    guard let object = object else { return nil }
    return mapDBXFilesSearchMatchTypeV2ToDB(object: object)
}

func mapDBXFilesSearchMatchTypeV2ToDB(object: DBXFilesSearchMatchTypeV2) -> DBFILESSearchMatchTypeV2 {
    if object.asFilename != nil {
        return DBFILESSearchMatchTypeV2(filename: ())
    }
    if object.asFileContent != nil {
        return DBFILESSearchMatchTypeV2(fileContent: ())
    }
    if object.asFilenameAndContent != nil {
        return DBFILESSearchMatchTypeV2(filenameAndContent: ())
    }
    if object.asImageContent != nil {
        return DBFILESSearchMatchTypeV2(imageContent: ())
    }
    if object.asOther != nil {
        return DBFILESSearchMatchTypeV2(other: ())
    }
    fatalError("codegen error")
}

func mapDBXFilesSearchMatchV2ToDBOptional(object: DBXFilesSearchMatchV2?) -> DBFILESSearchMatchV2? {
    guard let object = object else { return nil }
    return mapDBXFilesSearchMatchV2ToDB(object: object)
}

func mapDBXFilesSearchMatchV2ToDB(object: DBXFilesSearchMatchV2) -> DBFILESSearchMatchV2 {
    DBFILESSearchMatchV2(
        metadata: mapDBXFilesMetadataV2ToDB(object: object.metadata),
        matchType: mapDBXFilesSearchMatchTypeV2ToDBOptional(object: object.matchType),
        highlightSpans: object.highlightSpans?.compactMap { mapDBXFilesHighlightSpanToDB(object: $0) }
    )
}

func mapDBXFilesSearchModeToDBOptional(object: DBXFilesSearchMode?) -> DBFILESSearchMode? {
    guard let object = object else { return nil }
    return mapDBXFilesSearchModeToDB(object: object)
}

func mapDBXFilesSearchModeToDB(object: DBXFilesSearchMode) -> DBFILESSearchMode {
    if object.asFilename != nil {
        return DBFILESSearchMode(filename: ())
    }
    if object.asFilenameAndContent != nil {
        return DBFILESSearchMode(filenameAndContent: ())
    }
    if object.asDeletedFilename != nil {
        return DBFILESSearchMode(deletedFilename: ())
    }
    fatalError("codegen error")
}

func mapDBXFilesSearchOptionsToDBOptional(object: DBXFilesSearchOptions?) -> DBFILESSearchOptions? {
    guard let object = object else { return nil }
    return mapDBXFilesSearchOptionsToDB(object: object)
}

func mapDBXFilesSearchOptionsToDB(object: DBXFilesSearchOptions) -> DBFILESSearchOptions {
    DBFILESSearchOptions(
        path: object.path,
        maxResults: object.maxResults,
        orderBy: mapDBXFilesSearchOrderByToDBOptional(object: object.orderBy),
        fileStatus: mapDBXFilesFileStatusToDB(object: object.fileStatus),
        filenameOnly: object.filenameOnly,
        fileExtensions: object.fileExtensions,
        fileCategories: object.fileCategories?.compactMap { mapDBXFilesFileCategoryToDB(object: $0) },
        accountId: object.accountId
    )
}

func mapDBXFilesSearchOrderByToDBOptional(object: DBXFilesSearchOrderBy?) -> DBFILESSearchOrderBy? {
    guard let object = object else { return nil }
    return mapDBXFilesSearchOrderByToDB(object: object)
}

func mapDBXFilesSearchOrderByToDB(object: DBXFilesSearchOrderBy) -> DBFILESSearchOrderBy {
    if object.asRelevance != nil {
        return DBFILESSearchOrderBy(relevance: ())
    }
    if object.asLastModifiedTime != nil {
        return DBFILESSearchOrderBy(lastModifiedTime: ())
    }
    if object.asOther != nil {
        return DBFILESSearchOrderBy(other: ())
    }
    fatalError("codegen error")
}

func mapDBXFilesSearchResultToDBOptional(object: DBXFilesSearchResult?) -> DBFILESSearchResult? {
    guard let object = object else { return nil }
    return mapDBXFilesSearchResultToDB(object: object)
}

func mapDBXFilesSearchResultToDB(object: DBXFilesSearchResult) -> DBFILESSearchResult {
    DBFILESSearchResult(matches: object.matches.compactMap { mapDBXFilesSearchMatchToDB(object: $0) }, more: object.more, start: object.start)
}

func mapDBXFilesSearchV2ArgToDBOptional(object: DBXFilesSearchV2Arg?) -> DBFILESSearchV2Arg? {
    guard let object = object else { return nil }
    return mapDBXFilesSearchV2ArgToDB(object: object)
}

func mapDBXFilesSearchV2ArgToDB(object: DBXFilesSearchV2Arg) -> DBFILESSearchV2Arg {
    DBFILESSearchV2Arg(
        query: object.query,
        options: mapDBXFilesSearchOptionsToDBOptional(object: object.options),
        matchFieldOptions: mapDBXFilesSearchMatchFieldOptionsToDBOptional(object: object.matchFieldOptions),
        includeHighlights: object.includeHighlights
    )
}

func mapDBXFilesSearchV2ContinueArgToDBOptional(object: DBXFilesSearchV2ContinueArg?) -> DBFILESSearchV2ContinueArg? {
    guard let object = object else { return nil }
    return mapDBXFilesSearchV2ContinueArgToDB(object: object)
}

func mapDBXFilesSearchV2ContinueArgToDB(object: DBXFilesSearchV2ContinueArg) -> DBFILESSearchV2ContinueArg {
    DBFILESSearchV2ContinueArg(cursor: object.cursor)
}

func mapDBXFilesSearchV2ResultToDBOptional(object: DBXFilesSearchV2Result?) -> DBFILESSearchV2Result? {
    guard let object = object else { return nil }
    return mapDBXFilesSearchV2ResultToDB(object: object)
}

func mapDBXFilesSearchV2ResultToDB(object: DBXFilesSearchV2Result) -> DBFILESSearchV2Result {
    DBFILESSearchV2Result(matches: object.matches.compactMap { mapDBXFilesSearchMatchV2ToDB(object: $0) }, hasMore: object.hasMore, cursor: object.cursor)
}

func mapDBXFilesSharedLinkToDBOptional(object: DBXFilesSharedLink?) -> DBFILESSharedLink? {
    guard let object = object else { return nil }
    return mapDBXFilesSharedLinkToDB(object: object)
}

func mapDBXFilesSharedLinkToDB(object: DBXFilesSharedLink) -> DBFILESSharedLink {
    DBFILESSharedLink(url: object.url, password: object.password)
}

func mapDBXFilesSharedLinkFileInfoToDBOptional(object: DBXFilesSharedLinkFileInfo?) -> DBFILESSharedLinkFileInfo? {
    guard let object = object else { return nil }
    return mapDBXFilesSharedLinkFileInfoToDB(object: object)
}

func mapDBXFilesSharedLinkFileInfoToDB(object: DBXFilesSharedLinkFileInfo) -> DBFILESSharedLinkFileInfo {
    DBFILESSharedLinkFileInfo(url: object.url, path: object.path, password: object.password)
}

func mapDBXFilesSingleUserLockToDBOptional(object: DBXFilesSingleUserLock?) -> DBFILESSingleUserLock? {
    guard let object = object else { return nil }
    return mapDBXFilesSingleUserLockToDB(object: object)
}

func mapDBXFilesSingleUserLockToDB(object: DBXFilesSingleUserLock) -> DBFILESSingleUserLock {
    DBFILESSingleUserLock(created: object.created, lockHolderAccountId: object.lockHolderAccountId, lockHolderTeamId: object.lockHolderTeamId)
}

func mapDBXFilesSymlinkInfoToDBOptional(object: DBXFilesSymlinkInfo?) -> DBFILESSymlinkInfo? {
    guard let object = object else { return nil }
    return mapDBXFilesSymlinkInfoToDB(object: object)
}

func mapDBXFilesSymlinkInfoToDB(object: DBXFilesSymlinkInfo) -> DBFILESSymlinkInfo {
    DBFILESSymlinkInfo(target: object.target)
}

func mapDBXFilesSyncSettingToDBOptional(object: DBXFilesSyncSetting?) -> DBFILESSyncSetting? {
    guard let object = object else { return nil }
    return mapDBXFilesSyncSettingToDB(object: object)
}

func mapDBXFilesSyncSettingToDB(object: DBXFilesSyncSetting) -> DBFILESSyncSetting {
    if object.asDefault_ != nil {
        return DBFILESSyncSetting(default_: ())
    }
    if object.asNotSynced != nil {
        return DBFILESSyncSetting(notSynced: ())
    }
    if object.asNotSyncedInactive != nil {
        return DBFILESSyncSetting(notSyncedInactive: ())
    }
    if object.asOther != nil {
        return DBFILESSyncSetting(other: ())
    }
    fatalError("codegen error")
}

func mapDBXFilesSyncSettingArgToDBOptional(object: DBXFilesSyncSettingArg?) -> DBFILESSyncSettingArg? {
    guard let object = object else { return nil }
    return mapDBXFilesSyncSettingArgToDB(object: object)
}

func mapDBXFilesSyncSettingArgToDB(object: DBXFilesSyncSettingArg) -> DBFILESSyncSettingArg {
    if object.asDefault_ != nil {
        return DBFILESSyncSettingArg(default_: ())
    }
    if object.asNotSynced != nil {
        return DBFILESSyncSettingArg(notSynced: ())
    }
    if object.asOther != nil {
        return DBFILESSyncSettingArg(other: ())
    }
    fatalError("codegen error")
}

func mapDBXFilesSyncSettingsErrorToDBOptional(object: DBXFilesSyncSettingsError?) -> DBFILESSyncSettingsError? {
    guard let object = object else { return nil }
    return mapDBXFilesSyncSettingsErrorToDB(object: object)
}

func mapDBXFilesSyncSettingsErrorToDB(object: DBXFilesSyncSettingsError) -> DBFILESSyncSettingsError {
    if let object = object.asPath {
        let path = mapDBXFilesLookupErrorToDB(object: object.path)
        return DBFILESSyncSettingsError(path: path)
    }
    if object.asUnsupportedCombination != nil {
        return DBFILESSyncSettingsError(unsupportedCombination: ())
    }
    if object.asUnsupportedConfiguration != nil {
        return DBFILESSyncSettingsError(unsupportedConfiguration: ())
    }
    if object.asOther != nil {
        return DBFILESSyncSettingsError(other: ())
    }
    fatalError("codegen error")
}

func mapDBXFilesTagToDBOptional(object: DBXFilesTag?) -> DBFILESTag? {
    guard let object = object else { return nil }
    return mapDBXFilesTagToDB(object: object)
}

func mapDBXFilesTagToDB(object: DBXFilesTag) -> DBFILESTag {
    if let object = object.asUserGeneratedTag {
        let userGeneratedTag = mapDBXFilesUserGeneratedTagToDB(object: object.userGeneratedTag)
        return DBFILESTag(userGeneratedTag: userGeneratedTag)
    }
    if object.asOther != nil {
        return DBFILESTag(other: ())
    }
    fatalError("codegen error")
}

func mapDBXFilesThumbnailArgToDBOptional(object: DBXFilesThumbnailArg?) -> DBFILESThumbnailArg? {
    guard let object = object else { return nil }
    return mapDBXFilesThumbnailArgToDB(object: object)
}

func mapDBXFilesThumbnailArgToDB(object: DBXFilesThumbnailArg) -> DBFILESThumbnailArg {
    DBFILESThumbnailArg(
        path: object.path,
        format: mapDBXFilesThumbnailFormatToDB(object: object.format),
        size: mapDBXFilesThumbnailSizeToDB(object: object.size),
        mode: mapDBXFilesThumbnailModeToDB(object: object.mode)
    )
}

func mapDBXFilesThumbnailErrorToDBOptional(object: DBXFilesThumbnailError?) -> DBFILESThumbnailError? {
    guard let object = object else { return nil }
    return mapDBXFilesThumbnailErrorToDB(object: object)
}

func mapDBXFilesThumbnailErrorToDB(object: DBXFilesThumbnailError) -> DBFILESThumbnailError {
    if let object = object.asPath {
        let path = mapDBXFilesLookupErrorToDB(object: object.path)
        return DBFILESThumbnailError(path: path)
    }
    if object.asUnsupportedExtension != nil {
        return DBFILESThumbnailError(unsupportedExtension: ())
    }
    if object.asUnsupportedImage != nil {
        return DBFILESThumbnailError(unsupportedImage: ())
    }
    if object.asConversionError != nil {
        return DBFILESThumbnailError(conversionError: ())
    }
    fatalError("codegen error")
}

func mapDBXFilesThumbnailFormatToDBOptional(object: DBXFilesThumbnailFormat?) -> DBFILESThumbnailFormat? {
    guard let object = object else { return nil }
    return mapDBXFilesThumbnailFormatToDB(object: object)
}

func mapDBXFilesThumbnailFormatToDB(object: DBXFilesThumbnailFormat) -> DBFILESThumbnailFormat {
    if object.asJpeg != nil {
        return DBFILESThumbnailFormat(jpeg: ())
    }
    if object.asPng != nil {
        return DBFILESThumbnailFormat(png: ())
    }
    fatalError("codegen error")
}

func mapDBXFilesThumbnailModeToDBOptional(object: DBXFilesThumbnailMode?) -> DBFILESThumbnailMode? {
    guard let object = object else { return nil }
    return mapDBXFilesThumbnailModeToDB(object: object)
}

func mapDBXFilesThumbnailModeToDB(object: DBXFilesThumbnailMode) -> DBFILESThumbnailMode {
    if object.asStrict != nil {
        return DBFILESThumbnailMode(strict: ())
    }
    if object.asBestfit != nil {
        return DBFILESThumbnailMode(bestfit: ())
    }
    if object.asFitoneBestfit != nil {
        return DBFILESThumbnailMode(fitoneBestfit: ())
    }
    fatalError("codegen error")
}

func mapDBXFilesThumbnailSizeToDBOptional(object: DBXFilesThumbnailSize?) -> DBFILESThumbnailSize? {
    guard let object = object else { return nil }
    return mapDBXFilesThumbnailSizeToDB(object: object)
}

func mapDBXFilesThumbnailSizeToDB(object: DBXFilesThumbnailSize) -> DBFILESThumbnailSize {
    if object.asW32h32 != nil {
        return DBFILESThumbnailSize(w32h32: ())
    }
    if object.asW64h64 != nil {
        return DBFILESThumbnailSize(w64h64: ())
    }
    if object.asW128h128 != nil {
        return DBFILESThumbnailSize(w128h128: ())
    }
    if object.asW256h256 != nil {
        return DBFILESThumbnailSize(w256h256: ())
    }
    if object.asW480h320 != nil {
        return DBFILESThumbnailSize(w480h320: ())
    }
    if object.asW640h480 != nil {
        return DBFILESThumbnailSize(w640h480: ())
    }
    if object.asW960h640 != nil {
        return DBFILESThumbnailSize(w960h640: ())
    }
    if object.asW1024h768 != nil {
        return DBFILESThumbnailSize(w1024h768: ())
    }
    if object.asW2048h1536 != nil {
        return DBFILESThumbnailSize(w2048h1536: ())
    }
    fatalError("codegen error")
}

func mapDBXFilesThumbnailV2ArgToDBOptional(object: DBXFilesThumbnailV2Arg?) -> DBFILESThumbnailV2Arg? {
    guard let object = object else { return nil }
    return mapDBXFilesThumbnailV2ArgToDB(object: object)
}

func mapDBXFilesThumbnailV2ArgToDB(object: DBXFilesThumbnailV2Arg) -> DBFILESThumbnailV2Arg {
    DBFILESThumbnailV2Arg(
        resource: mapDBXFilesPathOrLinkToDB(object: object.resource),
        format: mapDBXFilesThumbnailFormatToDB(object: object.format),
        size: mapDBXFilesThumbnailSizeToDB(object: object.size),
        mode: mapDBXFilesThumbnailModeToDB(object: object.mode)
    )
}

func mapDBXFilesThumbnailV2ErrorToDBOptional(object: DBXFilesThumbnailV2Error?) -> DBFILESThumbnailV2Error? {
    guard let object = object else { return nil }
    return mapDBXFilesThumbnailV2ErrorToDB(object: object)
}

func mapDBXFilesThumbnailV2ErrorToDB(object: DBXFilesThumbnailV2Error) -> DBFILESThumbnailV2Error {
    if let object = object.asPath {
        let path = mapDBXFilesLookupErrorToDB(object: object.path)
        return DBFILESThumbnailV2Error(path: path)
    }
    if object.asUnsupportedExtension != nil {
        return DBFILESThumbnailV2Error(unsupportedExtension: ())
    }
    if object.asUnsupportedImage != nil {
        return DBFILESThumbnailV2Error(unsupportedImage: ())
    }
    if object.asConversionError != nil {
        return DBFILESThumbnailV2Error(conversionError: ())
    }
    if object.asAccessDenied != nil {
        return DBFILESThumbnailV2Error(accessDenied: ())
    }
    if object.asNotFound != nil {
        return DBFILESThumbnailV2Error(notFound: ())
    }
    if object.asOther != nil {
        return DBFILESThumbnailV2Error(other: ())
    }
    fatalError("codegen error")
}

func mapDBXFilesUnlockFileArgToDBOptional(object: DBXFilesUnlockFileArg?) -> DBFILESUnlockFileArg? {
    guard let object = object else { return nil }
    return mapDBXFilesUnlockFileArgToDB(object: object)
}

func mapDBXFilesUnlockFileArgToDB(object: DBXFilesUnlockFileArg) -> DBFILESUnlockFileArg {
    DBFILESUnlockFileArg(path: object.path)
}

func mapDBXFilesUnlockFileBatchArgToDBOptional(object: DBXFilesUnlockFileBatchArg?) -> DBFILESUnlockFileBatchArg? {
    guard let object = object else { return nil }
    return mapDBXFilesUnlockFileBatchArgToDB(object: object)
}

func mapDBXFilesUnlockFileBatchArgToDB(object: DBXFilesUnlockFileBatchArg) -> DBFILESUnlockFileBatchArg {
    DBFILESUnlockFileBatchArg(entries: object.entries.compactMap { mapDBXFilesUnlockFileArgToDB(object: $0) })
}

func mapDBXFilesUploadArgToDBOptional(object: DBXFilesUploadArg?) -> DBFILESUploadArg? {
    guard let object = object else { return nil }
    return mapDBXFilesUploadArgToDB(object: object)
}

func mapDBXFilesUploadArgToDB(object: DBXFilesUploadArg) -> DBFILESUploadArg {
    DBFILESUploadArg(
        path: object.path,
        mode: mapDBXFilesWriteModeToDB(object: object.mode),
        autorename: object.autorename,
        clientModified: object.clientModified,
        mute: object.mute,
        propertyGroups: object.propertyGroups?.compactMap { mapDBXFilePropertiesPropertyGroupToDB(object: $0) },
        strictConflict: object.strictConflict,
        contentHash: object.contentHash
    )
}

func mapDBXFilesUploadErrorToDBOptional(object: DBXFilesUploadError?) -> DBFILESUploadError? {
    guard let object = object else { return nil }
    return mapDBXFilesUploadErrorToDB(object: object)
}

func mapDBXFilesUploadErrorToDB(object: DBXFilesUploadError) -> DBFILESUploadError {
    if let object = object.asPath {
        let path = mapDBXFilesUploadWriteFailedToDB(object: object.path)
        return DBFILESUploadError(path: path)
    }
    if let object = object.asPropertiesError {
        let propertiesError = mapDBXFilePropertiesInvalidPropertyGroupErrorToDB(object: object.propertiesError)
        return DBFILESUploadError(propertiesError: propertiesError)
    }
    if object.asPayloadTooLarge != nil {
        return DBFILESUploadError(payloadTooLarge: ())
    }
    if object.asContentHashMismatch != nil {
        return DBFILESUploadError(contentHashMismatch: ())
    }
    if object.asOther != nil {
        return DBFILESUploadError(other: ())
    }
    fatalError("codegen error")
}

func mapDBXFilesUploadSessionAppendArgToDBOptional(object: DBXFilesUploadSessionAppendArg?) -> DBFILESUploadSessionAppendArg? {
    guard let object = object else { return nil }
    return mapDBXFilesUploadSessionAppendArgToDB(object: object)
}

func mapDBXFilesUploadSessionAppendArgToDB(object: DBXFilesUploadSessionAppendArg) -> DBFILESUploadSessionAppendArg {
    DBFILESUploadSessionAppendArg(cursor: mapDBXFilesUploadSessionCursorToDB(object: object.cursor), close: object.close, contentHash: object.contentHash)
}

func mapDBXFilesUploadSessionLookupErrorToDBOptional(object: DBXFilesUploadSessionLookupError?) -> DBFILESUploadSessionLookupError? {
    guard let object = object else { return nil }
    return mapDBXFilesUploadSessionLookupErrorToDB(object: object)
}

func mapDBXFilesUploadSessionLookupErrorToDB(object: DBXFilesUploadSessionLookupError) -> DBFILESUploadSessionLookupError {
    if object.asNotFound != nil {
        return DBFILESUploadSessionLookupError(notFound: ())
    }
    if let object = object.asIncorrectOffset {
        let incorrectOffset = mapDBXFilesUploadSessionOffsetErrorToDB(object: object.incorrectOffset)
        return DBFILESUploadSessionLookupError(incorrectOffset: incorrectOffset)
    }
    if object.asClosed != nil {
        return DBFILESUploadSessionLookupError(closed: ())
    }
    if object.asNotClosed != nil {
        return DBFILESUploadSessionLookupError(notClosed: ())
    }
    if object.asTooLarge != nil {
        return DBFILESUploadSessionLookupError(tooLarge: ())
    }
    if object.asConcurrentSessionInvalidOffset != nil {
        return DBFILESUploadSessionLookupError(concurrentSessionInvalidOffset: ())
    }
    if object.asConcurrentSessionInvalidDataSize != nil {
        return DBFILESUploadSessionLookupError(concurrentSessionInvalidDataSize: ())
    }
    if object.asPayloadTooLarge != nil {
        return DBFILESUploadSessionLookupError(payloadTooLarge: ())
    }
    if object.asOther != nil {
        return DBFILESUploadSessionLookupError(other: ())
    }
    fatalError("codegen error")
}

func mapDBXFilesUploadSessionAppendErrorToDBOptional(object: DBXFilesUploadSessionAppendError?) -> DBFILESUploadSessionAppendError? {
    guard let object = object else { return nil }
    return mapDBXFilesUploadSessionAppendErrorToDB(object: object)
}

func mapDBXFilesUploadSessionAppendErrorToDB(object: DBXFilesUploadSessionAppendError) -> DBFILESUploadSessionAppendError {
    if object.asNotFound != nil {
        return DBFILESUploadSessionAppendError(notFound: ())
    }
    if let object = object.asIncorrectOffset {
        let incorrectOffset = mapDBXFilesUploadSessionOffsetErrorToDB(object: object.incorrectOffset)
        return DBFILESUploadSessionAppendError(incorrectOffset: incorrectOffset)
    }
    if object.asClosed != nil {
        return DBFILESUploadSessionAppendError(closed: ())
    }
    if object.asNotClosed != nil {
        return DBFILESUploadSessionAppendError(notClosed: ())
    }
    if object.asTooLarge != nil {
        return DBFILESUploadSessionAppendError(tooLarge: ())
    }
    if object.asConcurrentSessionInvalidOffset != nil {
        return DBFILESUploadSessionAppendError(concurrentSessionInvalidOffset: ())
    }
    if object.asConcurrentSessionInvalidDataSize != nil {
        return DBFILESUploadSessionAppendError(concurrentSessionInvalidDataSize: ())
    }
    if object.asPayloadTooLarge != nil {
        return DBFILESUploadSessionAppendError(payloadTooLarge: ())
    }
    if object.asOther != nil {
        return DBFILESUploadSessionAppendError(other: ())
    }
    if object.asContentHashMismatch != nil {
        return DBFILESUploadSessionAppendError(contentHashMismatch: ())
    }
    fatalError("codegen error")
}

func mapDBXFilesUploadSessionCursorToDBOptional(object: DBXFilesUploadSessionCursor?) -> DBFILESUploadSessionCursor? {
    guard let object = object else { return nil }
    return mapDBXFilesUploadSessionCursorToDB(object: object)
}

func mapDBXFilesUploadSessionCursorToDB(object: DBXFilesUploadSessionCursor) -> DBFILESUploadSessionCursor {
    DBFILESUploadSessionCursor(sessionId: object.sessionId, offset: object.offset)
}

func mapDBXFilesUploadSessionFinishArgToDBOptional(object: DBXFilesUploadSessionFinishArg?) -> DBFILESUploadSessionFinishArg? {
    guard let object = object else { return nil }
    return mapDBXFilesUploadSessionFinishArgToDB(object: object)
}

func mapDBXFilesUploadSessionFinishArgToDB(object: DBXFilesUploadSessionFinishArg) -> DBFILESUploadSessionFinishArg {
    DBFILESUploadSessionFinishArg(
        cursor: mapDBXFilesUploadSessionCursorToDB(object: object.cursor),
        commit: mapDBXFilesCommitInfoToDB(object: object.commit),
        contentHash: object.contentHash
    )
}

func mapDBXFilesUploadSessionFinishBatchArgToDBOptional(object: DBXFilesUploadSessionFinishBatchArg?) -> DBFILESUploadSessionFinishBatchArg? {
    guard let object = object else { return nil }
    return mapDBXFilesUploadSessionFinishBatchArgToDB(object: object)
}

func mapDBXFilesUploadSessionFinishBatchArgToDB(object: DBXFilesUploadSessionFinishBatchArg) -> DBFILESUploadSessionFinishBatchArg {
    DBFILESUploadSessionFinishBatchArg(entries: object.entries.compactMap { mapDBXFilesUploadSessionFinishArgToDB(object: $0) })
}

func mapDBXFilesUploadSessionFinishBatchJobStatusToDBOptional(object: DBXFilesUploadSessionFinishBatchJobStatus?) -> DBFILESUploadSessionFinishBatchJobStatus? {
    guard let object = object else { return nil }
    return mapDBXFilesUploadSessionFinishBatchJobStatusToDB(object: object)
}

func mapDBXFilesUploadSessionFinishBatchJobStatusToDB(object: DBXFilesUploadSessionFinishBatchJobStatus) -> DBFILESUploadSessionFinishBatchJobStatus {
    if object.asInProgress != nil {
        return DBFILESUploadSessionFinishBatchJobStatus(inProgress: ())
    }
    if let object = object.asComplete {
        let complete = mapDBXFilesUploadSessionFinishBatchResultToDB(object: object.complete)
        return DBFILESUploadSessionFinishBatchJobStatus(complete: complete)
    }
    fatalError("codegen error")
}

func mapDBXFilesUploadSessionFinishBatchLaunchToDBOptional(object: DBXFilesUploadSessionFinishBatchLaunch?) -> DBFILESUploadSessionFinishBatchLaunch? {
    guard let object = object else { return nil }
    return mapDBXFilesUploadSessionFinishBatchLaunchToDB(object: object)
}

func mapDBXFilesUploadSessionFinishBatchLaunchToDB(object: DBXFilesUploadSessionFinishBatchLaunch) -> DBFILESUploadSessionFinishBatchLaunch {
    if let object = object.asAsyncJobId {
        let asyncJobId = object.asyncJobId
        return DBFILESUploadSessionFinishBatchLaunch(asyncJobId: asyncJobId)
    }
    if let object = object.asComplete {
        let complete = mapDBXFilesUploadSessionFinishBatchResultToDB(object: object.complete)
        return DBFILESUploadSessionFinishBatchLaunch(complete: complete)
    }
    if object.asOther != nil {
        return DBFILESUploadSessionFinishBatchLaunch(other: ())
    }
    fatalError("codegen error")
}

func mapDBXFilesUploadSessionFinishBatchResultToDBOptional(object: DBXFilesUploadSessionFinishBatchResult?) -> DBFILESUploadSessionFinishBatchResult? {
    guard let object = object else { return nil }
    return mapDBXFilesUploadSessionFinishBatchResultToDB(object: object)
}

func mapDBXFilesUploadSessionFinishBatchResultToDB(object: DBXFilesUploadSessionFinishBatchResult) -> DBFILESUploadSessionFinishBatchResult {
    DBFILESUploadSessionFinishBatchResult(entries: object.entries.compactMap { mapDBXFilesUploadSessionFinishBatchResultEntryToDB(object: $0) })
}

func mapDBXFilesUploadSessionFinishBatchResultEntryToDBOptional(object: DBXFilesUploadSessionFinishBatchResultEntry?)
    -> DBFILESUploadSessionFinishBatchResultEntry? {
    guard let object = object else { return nil }
    return mapDBXFilesUploadSessionFinishBatchResultEntryToDB(object: object)
}

func mapDBXFilesUploadSessionFinishBatchResultEntryToDB(object: DBXFilesUploadSessionFinishBatchResultEntry) -> DBFILESUploadSessionFinishBatchResultEntry {
    if let object = object.asSuccess {
        let success = mapDBXFilesFileMetadataToDB(object: object.success)
        return DBFILESUploadSessionFinishBatchResultEntry(success: success)
    }
    if let object = object.asFailure {
        let failure = mapDBXFilesUploadSessionFinishErrorToDB(object: object.failure)
        return DBFILESUploadSessionFinishBatchResultEntry(failure: failure)
    }
    fatalError("codegen error")
}

func mapDBXFilesUploadSessionFinishErrorToDBOptional(object: DBXFilesUploadSessionFinishError?) -> DBFILESUploadSessionFinishError? {
    guard let object = object else { return nil }
    return mapDBXFilesUploadSessionFinishErrorToDB(object: object)
}

func mapDBXFilesUploadSessionFinishErrorToDB(object: DBXFilesUploadSessionFinishError) -> DBFILESUploadSessionFinishError {
    if let object = object.asLookupFailed {
        let lookupFailed = mapDBXFilesUploadSessionLookupErrorToDB(object: object.lookupFailed)
        return DBFILESUploadSessionFinishError(lookupFailed: lookupFailed)
    }
    if let object = object.asPath {
        let path = mapDBXFilesWriteErrorToDB(object: object.path)
        return DBFILESUploadSessionFinishError(path: path)
    }
    if let object = object.asPropertiesError {
        let propertiesError = mapDBXFilePropertiesInvalidPropertyGroupErrorToDB(object: object.propertiesError)
        return DBFILESUploadSessionFinishError(propertiesError: propertiesError)
    }
    if object.asTooManySharedFolderTargets != nil {
        return DBFILESUploadSessionFinishError(tooManySharedFolderTargets: ())
    }
    if object.asTooManyWriteOperations != nil {
        return DBFILESUploadSessionFinishError(tooManyWriteOperations: ())
    }
    if object.asConcurrentSessionDataNotAllowed != nil {
        return DBFILESUploadSessionFinishError(concurrentSessionDataNotAllowed: ())
    }
    if object.asConcurrentSessionNotClosed != nil {
        return DBFILESUploadSessionFinishError(concurrentSessionNotClosed: ())
    }
    if object.asConcurrentSessionMissingData != nil {
        return DBFILESUploadSessionFinishError(concurrentSessionMissingData: ())
    }
    if object.asPayloadTooLarge != nil {
        return DBFILESUploadSessionFinishError(payloadTooLarge: ())
    }
    if object.asContentHashMismatch != nil {
        return DBFILESUploadSessionFinishError(contentHashMismatch: ())
    }
    if object.asOther != nil {
        return DBFILESUploadSessionFinishError(other: ())
    }
    fatalError("codegen error")
}

func mapDBXFilesUploadSessionOffsetErrorToDBOptional(object: DBXFilesUploadSessionOffsetError?) -> DBFILESUploadSessionOffsetError? {
    guard let object = object else { return nil }
    return mapDBXFilesUploadSessionOffsetErrorToDB(object: object)
}

func mapDBXFilesUploadSessionOffsetErrorToDB(object: DBXFilesUploadSessionOffsetError) -> DBFILESUploadSessionOffsetError {
    DBFILESUploadSessionOffsetError(correctOffset: object.correctOffset)
}

func mapDBXFilesUploadSessionStartArgToDBOptional(object: DBXFilesUploadSessionStartArg?) -> DBFILESUploadSessionStartArg? {
    guard let object = object else { return nil }
    return mapDBXFilesUploadSessionStartArgToDB(object: object)
}

func mapDBXFilesUploadSessionStartArgToDB(object: DBXFilesUploadSessionStartArg) -> DBFILESUploadSessionStartArg {
    DBFILESUploadSessionStartArg(
        close: object.close,
        sessionType: mapDBXFilesUploadSessionTypeToDBOptional(object: object.sessionType),
        contentHash: object.contentHash
    )
}

func mapDBXFilesUploadSessionStartBatchArgToDBOptional(object: DBXFilesUploadSessionStartBatchArg?) -> DBFILESUploadSessionStartBatchArg? {
    guard let object = object else { return nil }
    return mapDBXFilesUploadSessionStartBatchArgToDB(object: object)
}

func mapDBXFilesUploadSessionStartBatchArgToDB(object: DBXFilesUploadSessionStartBatchArg) -> DBFILESUploadSessionStartBatchArg {
    DBFILESUploadSessionStartBatchArg(numSessions: object.numSessions, sessionType: mapDBXFilesUploadSessionTypeToDBOptional(object: object.sessionType))
}

func mapDBXFilesUploadSessionStartBatchResultToDBOptional(object: DBXFilesUploadSessionStartBatchResult?) -> DBFILESUploadSessionStartBatchResult? {
    guard let object = object else { return nil }
    return mapDBXFilesUploadSessionStartBatchResultToDB(object: object)
}

func mapDBXFilesUploadSessionStartBatchResultToDB(object: DBXFilesUploadSessionStartBatchResult) -> DBFILESUploadSessionStartBatchResult {
    DBFILESUploadSessionStartBatchResult(sessionIds: object.sessionIds)
}

func mapDBXFilesUploadSessionStartErrorToDBOptional(object: DBXFilesUploadSessionStartError?) -> DBFILESUploadSessionStartError? {
    guard let object = object else { return nil }
    return mapDBXFilesUploadSessionStartErrorToDB(object: object)
}

func mapDBXFilesUploadSessionStartErrorToDB(object: DBXFilesUploadSessionStartError) -> DBFILESUploadSessionStartError {
    if object.asConcurrentSessionDataNotAllowed != nil {
        return DBFILESUploadSessionStartError(concurrentSessionDataNotAllowed: ())
    }
    if object.asConcurrentSessionCloseNotAllowed != nil {
        return DBFILESUploadSessionStartError(concurrentSessionCloseNotAllowed: ())
    }
    if object.asPayloadTooLarge != nil {
        return DBFILESUploadSessionStartError(payloadTooLarge: ())
    }
    if object.asContentHashMismatch != nil {
        return DBFILESUploadSessionStartError(contentHashMismatch: ())
    }
    if object.asOther != nil {
        return DBFILESUploadSessionStartError(other: ())
    }
    fatalError("codegen error")
}

func mapDBXFilesUploadSessionStartResultToDBOptional(object: DBXFilesUploadSessionStartResult?) -> DBFILESUploadSessionStartResult? {
    guard let object = object else { return nil }
    return mapDBXFilesUploadSessionStartResultToDB(object: object)
}

func mapDBXFilesUploadSessionStartResultToDB(object: DBXFilesUploadSessionStartResult) -> DBFILESUploadSessionStartResult {
    DBFILESUploadSessionStartResult(sessionId: object.sessionId)
}

func mapDBXFilesUploadSessionTypeToDBOptional(object: DBXFilesUploadSessionType?) -> DBFILESUploadSessionType? {
    guard let object = object else { return nil }
    return mapDBXFilesUploadSessionTypeToDB(object: object)
}

func mapDBXFilesUploadSessionTypeToDB(object: DBXFilesUploadSessionType) -> DBFILESUploadSessionType {
    if object.asSequential != nil {
        return DBFILESUploadSessionType(sequential: ())
    }
    if object.asConcurrent != nil {
        return DBFILESUploadSessionType(concurrent: ())
    }
    if object.asOther != nil {
        return DBFILESUploadSessionType(other: ())
    }
    fatalError("codegen error")
}

func mapDBXFilesUploadWriteFailedToDBOptional(object: DBXFilesUploadWriteFailed?) -> DBFILESUploadWriteFailed? {
    guard let object = object else { return nil }
    return mapDBXFilesUploadWriteFailedToDB(object: object)
}

func mapDBXFilesUploadWriteFailedToDB(object: DBXFilesUploadWriteFailed) -> DBFILESUploadWriteFailed {
    DBFILESUploadWriteFailed(reason: mapDBXFilesWriteErrorToDB(object: object.reason), uploadSessionId: object.uploadSessionId)
}

func mapDBXFilesUserGeneratedTagToDBOptional(object: DBXFilesUserGeneratedTag?) -> DBFILESUserGeneratedTag? {
    guard let object = object else { return nil }
    return mapDBXFilesUserGeneratedTagToDB(object: object)
}

func mapDBXFilesUserGeneratedTagToDB(object: DBXFilesUserGeneratedTag) -> DBFILESUserGeneratedTag {
    DBFILESUserGeneratedTag(tagText: object.tagText)
}

func mapDBXFilesVideoMetadataToDBOptional(object: DBXFilesVideoMetadata?) -> DBFILESVideoMetadata? {
    guard let object = object else { return nil }
    return mapDBXFilesVideoMetadataToDB(object: object)
}

func mapDBXFilesVideoMetadataToDB(object: DBXFilesVideoMetadata) -> DBFILESVideoMetadata {
    DBFILESVideoMetadata(
        dimensions: mapDBXFilesDimensionsToDBOptional(object: object.dimensions),
        location: mapDBXFilesGpsCoordinatesToDBOptional(object: object.location),
        timeTaken: object.timeTaken,
        duration: object.duration
    )
}

func mapDBXFilesWriteConflictErrorToDBOptional(object: DBXFilesWriteConflictError?) -> DBFILESWriteConflictError? {
    guard let object = object else { return nil }
    return mapDBXFilesWriteConflictErrorToDB(object: object)
}

func mapDBXFilesWriteConflictErrorToDB(object: DBXFilesWriteConflictError) -> DBFILESWriteConflictError {
    if object.asFile != nil {
        return DBFILESWriteConflictError(file: ())
    }
    if object.asFolder != nil {
        return DBFILESWriteConflictError(folder: ())
    }
    if object.asFileAncestor != nil {
        return DBFILESWriteConflictError(fileAncestor: ())
    }
    if object.asOther != nil {
        return DBFILESWriteConflictError(other: ())
    }
    fatalError("codegen error")
}

func mapDBXFilesWriteErrorToDBOptional(object: DBXFilesWriteError?) -> DBFILESWriteError? {
    guard let object = object else { return nil }
    return mapDBXFilesWriteErrorToDB(object: object)
}

func mapDBXFilesWriteErrorToDB(object: DBXFilesWriteError) -> DBFILESWriteError {
    if let object = object.asMalformedPath {
        let malformedPath = object.malformedPath
        return DBFILESWriteError(malformedPath: malformedPath)
    }
    if let object = object.asConflict {
        let conflict = mapDBXFilesWriteConflictErrorToDB(object: object.conflict)
        return DBFILESWriteError(conflict: conflict)
    }
    if object.asNoWritePermission != nil {
        return DBFILESWriteError(noWritePermission: ())
    }
    if object.asInsufficientSpace != nil {
        return DBFILESWriteError(insufficientSpace: ())
    }
    if object.asDisallowedName != nil {
        return DBFILESWriteError(disallowedName: ())
    }
    if object.asTeamFolder != nil {
        return DBFILESWriteError(teamFolder: ())
    }
    if object.asOperationSuppressed != nil {
        return DBFILESWriteError(operationSuppressed: ())
    }
    if object.asTooManyWriteOperations != nil {
        return DBFILESWriteError(tooManyWriteOperations: ())
    }
    if object.asOther != nil {
        return DBFILESWriteError(other: ())
    }
    fatalError("codegen error")
}

func mapDBXFilesWriteModeToDBOptional(object: DBXFilesWriteMode?) -> DBFILESWriteMode? {
    guard let object = object else { return nil }
    return mapDBXFilesWriteModeToDB(object: object)
}

func mapDBXFilesWriteModeToDB(object: DBXFilesWriteMode) -> DBFILESWriteMode {
    if object.asAdd != nil {
        return DBFILESWriteMode(add: ())
    }
    if object.asOverwrite != nil {
        return DBFILESWriteMode(overwrite: ())
    }
    if let object = object.asUpdate {
        let update = object.update
        return DBFILESWriteMode(update: update)
    }
    fatalError("codegen error")
}
