///
/// Copyright (c) 2024 Dropbox, Inc. All rights reserved.
///
/// Auto-generated by Stone, do not modify.
///

import Foundation
import stone_sdk_objc
import stone_sdk_swift
import stone_sdk_swift_objc

func mapDBXUsersAccountToDBOptional(object: DBXUsersAccount?) -> DBUSERSAccount? {
    guard let object = object else { return nil }
    return mapDBXUsersAccountToDB(object: object)
}

func mapDBXUsersAccountToDB(object: DBXUsersAccount) -> DBUSERSAccount {
    DBUSERSAccount(
        accountId: object.accountId,
        name: mapDBXUsersNameToDB(object: object.name),
        email: object.email,
        emailVerified: object.emailVerified,
        disabled: object.disabled,
        profilePhotoUrl: object.profilePhotoUrl
    )
}

func mapDBXUsersBasicAccountToDBOptional(object: DBXUsersBasicAccount?) -> DBUSERSBasicAccount? {
    guard let object = object else { return nil }
    return mapDBXUsersBasicAccountToDB(object: object)
}

func mapDBXUsersBasicAccountToDB(object: DBXUsersBasicAccount) -> DBUSERSBasicAccount {
    DBUSERSBasicAccount(
        accountId: object.accountId,
        name: mapDBXUsersNameToDB(object: object.name),
        email: object.email,
        emailVerified: object.emailVerified,
        disabled: object.disabled,
        isTeammate: object.isTeammate,
        profilePhotoUrl: object.profilePhotoUrl,
        teamMemberId: object.teamMemberId
    )
}

func mapDBXUsersFileLockingValueToDBOptional(object: DBXUsersFileLockingValue?) -> DBUSERSFileLockingValue? {
    guard let object = object else { return nil }
    return mapDBXUsersFileLockingValueToDB(object: object)
}

func mapDBXUsersFileLockingValueToDB(object: DBXUsersFileLockingValue) -> DBUSERSFileLockingValue {
    if let object = object.asEnabled {
        let enabled = object.enabled
        return DBUSERSFileLockingValue(enabled: enabled)
    }
    if object.asOther != nil {
        return DBUSERSFileLockingValue(other: ())
    }
    fatalError("codegen error")
}

func mapDBXUsersFullAccountToDBOptional(object: DBXUsersFullAccount?) -> DBUSERSFullAccount? {
    guard let object = object else { return nil }
    return mapDBXUsersFullAccountToDB(object: object)
}

func mapDBXUsersFullAccountToDB(object: DBXUsersFullAccount) -> DBUSERSFullAccount {
    DBUSERSFullAccount(
        accountId: object.accountId,
        name: mapDBXUsersNameToDB(object: object.name),
        email: object.email,
        emailVerified: object.emailVerified,
        disabled: object.disabled,
        locale: object.locale,
        referralLink: object.referralLink,
        isPaired: object.isPaired,
        accountType: mapDBXUsersCommonAccountTypeToDB(object: object.accountType),
        rootInfo: mapDBXCommonRootInfoToDB(object: object.rootInfo),
        profilePhotoUrl: object.profilePhotoUrl,
        country: object.country,
        team: mapDBXUsersFullTeamToDBOptional(object: object.team),
        teamMemberId: object.teamMemberId
    )
}

func mapDBXUsersTeamToDBOptional(object: DBXUsersTeam?) -> DBUSERSTeam? {
    guard let object = object else { return nil }
    return mapDBXUsersTeamToDB(object: object)
}

func mapDBXUsersTeamToDB(object: DBXUsersTeam) -> DBUSERSTeam {
    DBUSERSTeam(id_: object.id, name: object.name)
}

func mapDBXUsersFullTeamToDBOptional(object: DBXUsersFullTeam?) -> DBUSERSFullTeam? {
    guard let object = object else { return nil }
    return mapDBXUsersFullTeamToDB(object: object)
}

func mapDBXUsersFullTeamToDB(object: DBXUsersFullTeam) -> DBUSERSFullTeam {
    DBUSERSFullTeam(
        id_: object.id,
        name: object.name,
        sharingPolicies: mapDBXTeamPoliciesTeamSharingPoliciesToDB(object: object.sharingPolicies),
        officeAddinPolicy: mapDBXTeamPoliciesOfficeAddInPolicyToDB(object: object.officeAddinPolicy)
    )
}

func mapDBXUsersGetAccountArgToDBOptional(object: DBXUsersGetAccountArg?) -> DBUSERSGetAccountArg? {
    guard let object = object else { return nil }
    return mapDBXUsersGetAccountArgToDB(object: object)
}

func mapDBXUsersGetAccountArgToDB(object: DBXUsersGetAccountArg) -> DBUSERSGetAccountArg {
    DBUSERSGetAccountArg(accountId: object.accountId)
}

func mapDBXUsersGetAccountBatchArgToDBOptional(object: DBXUsersGetAccountBatchArg?) -> DBUSERSGetAccountBatchArg? {
    guard let object = object else { return nil }
    return mapDBXUsersGetAccountBatchArgToDB(object: object)
}

func mapDBXUsersGetAccountBatchArgToDB(object: DBXUsersGetAccountBatchArg) -> DBUSERSGetAccountBatchArg {
    DBUSERSGetAccountBatchArg(accountIds: object.accountIds)
}

func mapDBXUsersGetAccountBatchErrorToDBOptional(object: DBXUsersGetAccountBatchError?) -> DBUSERSGetAccountBatchError? {
    guard let object = object else { return nil }
    return mapDBXUsersGetAccountBatchErrorToDB(object: object)
}

func mapDBXUsersGetAccountBatchErrorToDB(object: DBXUsersGetAccountBatchError) -> DBUSERSGetAccountBatchError {
    if let object = object.asNoAccount {
        let noAccount = object.noAccount
        return DBUSERSGetAccountBatchError(noAccount: noAccount)
    }
    if object.asOther != nil {
        return DBUSERSGetAccountBatchError(other: ())
    }
    fatalError("codegen error")
}

func mapDBXUsersGetAccountErrorToDBOptional(object: DBXUsersGetAccountError?) -> DBUSERSGetAccountError? {
    guard let object = object else { return nil }
    return mapDBXUsersGetAccountErrorToDB(object: object)
}

func mapDBXUsersGetAccountErrorToDB(object: DBXUsersGetAccountError) -> DBUSERSGetAccountError {
    if object.asNoAccount != nil {
        return DBUSERSGetAccountError(noAccount: ())
    }
    if object.asOther != nil {
        return DBUSERSGetAccountError(other: ())
    }
    fatalError("codegen error")
}

func mapDBXUsersIndividualSpaceAllocationToDBOptional(object: DBXUsersIndividualSpaceAllocation?) -> DBUSERSIndividualSpaceAllocation? {
    guard let object = object else { return nil }
    return mapDBXUsersIndividualSpaceAllocationToDB(object: object)
}

func mapDBXUsersIndividualSpaceAllocationToDB(object: DBXUsersIndividualSpaceAllocation) -> DBUSERSIndividualSpaceAllocation {
    DBUSERSIndividualSpaceAllocation(allocated: object.allocated)
}

func mapDBXUsersNameToDBOptional(object: DBXUsersName?) -> DBUSERSName? {
    guard let object = object else { return nil }
    return mapDBXUsersNameToDB(object: object)
}

func mapDBXUsersNameToDB(object: DBXUsersName) -> DBUSERSName {
    DBUSERSName(
        givenName: object.givenName,
        surname: object.surname,
        familiarName: object.familiarName,
        displayName: object.displayName,
        abbreviatedName: object.abbreviatedName
    )
}

func mapDBXUsersPaperAsFilesValueToDBOptional(object: DBXUsersPaperAsFilesValue?) -> DBUSERSPaperAsFilesValue? {
    guard let object = object else { return nil }
    return mapDBXUsersPaperAsFilesValueToDB(object: object)
}

func mapDBXUsersPaperAsFilesValueToDB(object: DBXUsersPaperAsFilesValue) -> DBUSERSPaperAsFilesValue {
    if let object = object.asEnabled {
        let enabled = object.enabled
        return DBUSERSPaperAsFilesValue(enabled: enabled)
    }
    if object.asOther != nil {
        return DBUSERSPaperAsFilesValue(other: ())
    }
    fatalError("codegen error")
}

func mapDBXUsersSpaceAllocationToDBOptional(object: DBXUsersSpaceAllocation?) -> DBUSERSSpaceAllocation? {
    guard let object = object else { return nil }
    return mapDBXUsersSpaceAllocationToDB(object: object)
}

func mapDBXUsersSpaceAllocationToDB(object: DBXUsersSpaceAllocation) -> DBUSERSSpaceAllocation {
    if let object = object.asIndividual {
        let individual = mapDBXUsersIndividualSpaceAllocationToDB(object: object.individual)
        return DBUSERSSpaceAllocation(individual: individual)
    }
    if let object = object.asTeam {
        let team = mapDBXUsersTeamSpaceAllocationToDB(object: object.team)
        return DBUSERSSpaceAllocation(team: team)
    }
    if object.asOther != nil {
        return DBUSERSSpaceAllocation(other: ())
    }
    fatalError("codegen error")
}

func mapDBXUsersSpaceUsageToDBOptional(object: DBXUsersSpaceUsage?) -> DBUSERSSpaceUsage? {
    guard let object = object else { return nil }
    return mapDBXUsersSpaceUsageToDB(object: object)
}

func mapDBXUsersSpaceUsageToDB(object: DBXUsersSpaceUsage) -> DBUSERSSpaceUsage {
    DBUSERSSpaceUsage(used: object.used, allocation: mapDBXUsersSpaceAllocationToDB(object: object.allocation))
}

func mapDBXUsersTeamSpaceAllocationToDBOptional(object: DBXUsersTeamSpaceAllocation?) -> DBUSERSTeamSpaceAllocation? {
    guard let object = object else { return nil }
    return mapDBXUsersTeamSpaceAllocationToDB(object: object)
}

func mapDBXUsersTeamSpaceAllocationToDB(object: DBXUsersTeamSpaceAllocation) -> DBUSERSTeamSpaceAllocation {
    DBUSERSTeamSpaceAllocation(
        used: object.used,
        allocated: object.allocated,
        userWithinTeamSpaceAllocated: object.userWithinTeamSpaceAllocated,
        userWithinTeamSpaceLimitType: mapDBXTeamCommonMemberSpaceLimitTypeToDB(object: object.userWithinTeamSpaceLimitType),
        userWithinTeamSpaceUsedCached: object.userWithinTeamSpaceUsedCached
    )
}

func mapDBXUsersUserFeatureToDBOptional(object: DBXUsersUserFeature?) -> DBUSERSUserFeature? {
    guard let object = object else { return nil }
    return mapDBXUsersUserFeatureToDB(object: object)
}

func mapDBXUsersUserFeatureToDB(object: DBXUsersUserFeature) -> DBUSERSUserFeature {
    if object.asPaperAsFiles != nil {
        return DBUSERSUserFeature(paperAsFiles: ())
    }
    if object.asFileLocking != nil {
        return DBUSERSUserFeature(fileLocking: ())
    }
    if object.asOther != nil {
        return DBUSERSUserFeature(other: ())
    }
    fatalError("codegen error")
}

func mapDBXUsersUserFeatureValueToDBOptional(object: DBXUsersUserFeatureValue?) -> DBUSERSUserFeatureValue? {
    guard let object = object else { return nil }
    return mapDBXUsersUserFeatureValueToDB(object: object)
}

func mapDBXUsersUserFeatureValueToDB(object: DBXUsersUserFeatureValue) -> DBUSERSUserFeatureValue {
    if let object = object.asPaperAsFiles {
        let paperAsFiles = mapDBXUsersPaperAsFilesValueToDB(object: object.paperAsFiles)
        return DBUSERSUserFeatureValue(paperAsFiles: paperAsFiles)
    }
    if let object = object.asFileLocking {
        let fileLocking = mapDBXUsersFileLockingValueToDB(object: object.fileLocking)
        return DBUSERSUserFeatureValue(fileLocking: fileLocking)
    }
    if object.asOther != nil {
        return DBUSERSUserFeatureValue(other: ())
    }
    fatalError("codegen error")
}

func mapDBXUsersUserFeaturesGetValuesBatchArgToDBOptional(object: DBXUsersUserFeaturesGetValuesBatchArg?) -> DBUSERSUserFeaturesGetValuesBatchArg? {
    guard let object = object else { return nil }
    return mapDBXUsersUserFeaturesGetValuesBatchArgToDB(object: object)
}

func mapDBXUsersUserFeaturesGetValuesBatchArgToDB(object: DBXUsersUserFeaturesGetValuesBatchArg) -> DBUSERSUserFeaturesGetValuesBatchArg {
    DBUSERSUserFeaturesGetValuesBatchArg(features: object.features.compactMap { mapDBXUsersUserFeatureToDB(object: $0) })
}

func mapDBXUsersUserFeaturesGetValuesBatchErrorToDBOptional(object: DBXUsersUserFeaturesGetValuesBatchError?) -> DBUSERSUserFeaturesGetValuesBatchError? {
    guard let object = object else { return nil }
    return mapDBXUsersUserFeaturesGetValuesBatchErrorToDB(object: object)
}

func mapDBXUsersUserFeaturesGetValuesBatchErrorToDB(object: DBXUsersUserFeaturesGetValuesBatchError) -> DBUSERSUserFeaturesGetValuesBatchError {
    if object.asEmptyFeaturesList != nil {
        return DBUSERSUserFeaturesGetValuesBatchError(emptyFeaturesList: ())
    }
    if object.asOther != nil {
        return DBUSERSUserFeaturesGetValuesBatchError(other: ())
    }
    fatalError("codegen error")
}

func mapDBXUsersUserFeaturesGetValuesBatchResultToDBOptional(object: DBXUsersUserFeaturesGetValuesBatchResult?) -> DBUSERSUserFeaturesGetValuesBatchResult? {
    guard let object = object else { return nil }
    return mapDBXUsersUserFeaturesGetValuesBatchResultToDB(object: object)
}

func mapDBXUsersUserFeaturesGetValuesBatchResultToDB(object: DBXUsersUserFeaturesGetValuesBatchResult) -> DBUSERSUserFeaturesGetValuesBatchResult {
    DBUSERSUserFeaturesGetValuesBatchResult(values: object.values.compactMap { mapDBXUsersUserFeatureValueToDB(object: $0) })
}
